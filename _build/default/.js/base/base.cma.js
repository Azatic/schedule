// Generated by js_of_ocaml
//# buildInfo:effects=false, use-js-string=false, version=5.0.1
(function
   (globalThis)
   {"use strict";
    var
     runtime=globalThis.jsoo_runtime,
     caml_blit_string=runtime.caml_blit_string,
     caml_bytes_equal=runtime.caml_bytes_equal,
     caml_bytes_get=runtime.caml_bytes_get,
     caml_bytes_greaterequal=runtime.caml_bytes_greaterequal,
     caml_bytes_lessequal=runtime.caml_bytes_lessequal,
     caml_bytes_set=runtime.caml_bytes_set,
     caml_bytes_unsafe_get=runtime.caml_bytes_unsafe_get,
     caml_bytes_unsafe_set=runtime.caml_bytes_unsafe_set,
     caml_check_bound=runtime.caml_check_bound,
     caml_classify_float=runtime.caml_classify_float,
     caml_compare=runtime.caml_compare,
     caml_create_bytes=runtime.caml_create_bytes,
     caml_div=runtime.caml_div,
     caml_equal=runtime.caml_equal,
     caml_float_compare=runtime.caml_float_compare,
     caml_float_of_string=runtime.caml_float_of_string,
     caml_format_float=runtime.caml_format_float,
     caml_fresh_oo_id=runtime.caml_fresh_oo_id,
     caml_greaterequal=runtime.caml_greaterequal,
     caml_greaterthan=runtime.caml_greaterthan,
     caml_int32_bswap=runtime.caml_int32_bswap,
     caml_int64_add=runtime.caml_int64_add,
     caml_int64_and=runtime.caml_int64_and,
     caml_int64_bits_of_float=runtime.caml_int64_bits_of_float,
     caml_int64_bswap=runtime.caml_int64_bswap,
     caml_int64_compare=runtime.caml_int64_compare,
     caml_int64_div=runtime.caml_int64_div,
     caml_int64_float_of_bits=runtime.caml_int64_float_of_bits,
     caml_int64_mod=runtime.caml_int64_mod,
     caml_int64_mul=runtime.caml_int64_mul,
     caml_int64_neg=runtime.caml_int64_neg,
     caml_int64_of_float=runtime.caml_int64_of_float,
     caml_int64_of_int32=runtime.caml_int64_of_int32,
     caml_int64_of_string=runtime.caml_int64_of_string,
     caml_int64_or=runtime.caml_int64_or,
     caml_int64_shift_left=runtime.caml_int64_shift_left,
     caml_int64_shift_right=runtime.caml_int64_shift_right,
     caml_int64_shift_right_unsigne=runtime.caml_int64_shift_right_unsigned,
     caml_int64_sub=runtime.caml_int64_sub,
     caml_int64_to_float=runtime.caml_int64_to_float,
     caml_int64_to_int32=runtime.caml_int64_to_int32,
     caml_int64_xor=runtime.caml_int64_xor,
     caml_int_compare=runtime.caml_int_compare,
     caml_int_of_string=runtime.caml_int_of_string,
     caml_lessequal=runtime.caml_lessequal,
     caml_lessthan=runtime.caml_lessthan,
     caml_log10_float=runtime.caml_log10_float,
     caml_make_vect=runtime.caml_make_vect,
     caml_ml_bytes_length=runtime.caml_ml_bytes_length,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_mod=runtime.caml_mod,
     caml_mul=runtime.caml_mul,
     caml_notequal=runtime.caml_notequal,
     caml_obj_tag=runtime.caml_obj_tag,
     caml_register_global=runtime.caml_register_global,
     caml_string_compare=runtime.caml_string_compare,
     caml_string_equal=runtime.caml_string_equal,
     caml_string_get=runtime.caml_string_get,
     caml_string_greaterequal=runtime.caml_string_greaterequal,
     caml_string_lessequal=runtime.caml_string_lessequal,
     caml_string_notequal=runtime.caml_string_notequal,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     caml_string_unsafe_get=runtime.caml_string_unsafe_get,
     caml_sys_argv=runtime.caml_sys_argv,
     caml_sys_getenv=runtime.caml_sys_getenv,
     caml_update_dummy=runtime.caml_update_dummy,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    function caml_call6(f,a0,a1,a2,a3,a4,a5)
     {return f.length == 6
              ?f(a0,a1,a2,a3,a4,a5)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5])}
    var
     global_data=runtime.caml_get_global_data(),
     description=caml_string_of_jsbytes("internalhash"),
     cst_unknown_word_size=caml_string_of_jsbytes("unknown word size"),
     cst_pp=caml_string_of_jsbytes(".pp"),
     cst_Base_Exn_Finally=caml_string_of_jsbytes("Base__Exn.Finally"),
     cst_Base_Exn_Reraised=caml_string_of_jsbytes("Base__Exn.Reraised"),
     cst_Base_Exn_Sexp=caml_string_of_jsbytes("Base__Exn.Sexp"),
     module_name=caml_string_of_jsbytes("Base.Exn"),
     cst_use_of_return_from_a_with_=
      caml_string_of_jsbytes
       ("use of [return] from a [with_return] that already returned"),
     cst_Return=caml_string_of_jsbytes("Return"),
     cst_Second$1=caml_string_of_jsbytes("Second"),
     cst_First$1=caml_string_of_jsbytes("First"),
     cst_First=caml_string_of_jsbytes("First"),
     cst_Second=caml_string_of_jsbytes("Second"),
     cst_first=caml_string_of_jsbytes("first"),
     cst_second=caml_string_of_jsbytes("second"),
     cst_First$0=caml_string_of_jsbytes("First"),
     cst_Second$0=caml_string_of_jsbytes("Second"),
     cst_first$0=caml_string_of_jsbytes("first"),
     cst_second$0=caml_string_of_jsbytes("second"),
     error_source_011=caml_string_of_jsbytes("either0.ml.t"),
     cst$0=caml_string_of_jsbytes(""),
     cst=caml_string_of_jsbytes(""),
     cst$1=caml_string_of_jsbytes(":"),
     cst$2=caml_string_of_jsbytes(":"),
     cst_Error$1=caml_string_of_jsbytes("Error"),
     cst_Ok$1=caml_string_of_jsbytes("Ok"),
     cst_Error=caml_string_of_jsbytes("Error"),
     cst_Ok=caml_string_of_jsbytes("Ok"),
     cst_error=caml_string_of_jsbytes("error"),
     cst_ok=caml_string_of_jsbytes("ok"),
     cst_Error$0=caml_string_of_jsbytes("Error"),
     cst_Ok$0=caml_string_of_jsbytes("Ok"),
     cst_error$0=caml_string_of_jsbytes("error"),
     cst_ok$0=caml_string_of_jsbytes("ok"),
     error_source_005=caml_string_of_jsbytes("result.ml.t"),
     cst_unforced_lazy=caml_string_of_jsbytes("<unforced lazy>"),
     cst_float=caml_string_of_jsbytes("float"),
     cst_int64=caml_string_of_jsbytes("int64"),
     cst_nativeint=caml_string_of_jsbytes("nativeint"),
     cst_int32=caml_string_of_jsbytes("int32"),
     cst_int=caml_string_of_jsbytes("int"),
     cst_initializing_Random_with_a=
      caml_string_of_jsbytes
       ("initializing Random with a nondeterministic seed is forbidden in inline tests"),
     cst_Equal=caml_string_of_jsbytes("Equal"),
     cst_Greater=caml_string_of_jsbytes("Greater"),
     cst_Less=caml_string_of_jsbytes("Less"),
     cst_equal=caml_string_of_jsbytes("equal"),
     cst_greater=caml_string_of_jsbytes("greater"),
     cst_less=caml_string_of_jsbytes("less"),
     cst_Equal$0=caml_string_of_jsbytes("Equal"),
     cst_Greater$0=caml_string_of_jsbytes("Greater"),
     cst_Less$0=caml_string_of_jsbytes("Less"),
     cst_equal$0=caml_string_of_jsbytes("equal"),
     cst_greater$0=caml_string_of_jsbytes("greater"),
     cst_less$0=caml_string_of_jsbytes("less"),
     all$3=[0,0,[0,1,[0,2,0]]],
     error_source_005$0=caml_string_of_jsbytes("ordering.ml.t"),
     t_sexp_grammar$11=
      [3,
       [0,
        2,
        [0,
         [1,[0,caml_string_of_jsbytes("Less"),0]],
         [0,
          [1,[0,caml_string_of_jsbytes("Equal"),0]],
          [0,[1,[0,caml_string_of_jsbytes("Greater"),0]],0]]]]],
     cst_List_last=caml_string_of_jsbytes("List.last"),
     cst_List_random_element_exn_em=
      caml_string_of_jsbytes("List.random_element_exn: empty list"),
     cst_List_drop_last_exn_empty_l=
      caml_string_of_jsbytes("List.drop_last_exn: empty list"),
     cst_List_sub=caml_string_of_jsbytes("List.sub"),
     cst_List_reduce_balanced_exn=
      caml_string_of_jsbytes("List.reduce_balanced_exn"),
     cst_List_reduce_exn=caml_string_of_jsbytes("List.reduce_exn"),
     cst_map3_exn=caml_string_of_jsbytes("map3_exn"),
     cst_rev_map3_exn=caml_string_of_jsbytes("rev_map3_exn"),
     cst_map2_exn=caml_string_of_jsbytes("map2_exn"),
     cst_exists2_exn=caml_string_of_jsbytes("exists2_exn"),
     cst_for_all2_exn=caml_string_of_jsbytes("for_all2_exn"),
     cst_fold2_exn=caml_string_of_jsbytes("fold2_exn"),
     cst_rev_map2_exn=caml_string_of_jsbytes("rev_map2_exn"),
     cst_iter2_exn=caml_string_of_jsbytes("iter2_exn"),
     cst_List_range_stride_must_be_=
      caml_string_of_jsbytes("List.range: stride must be non-zero"),
     cst_List_range_stride_function$0=
      caml_string_of_jsbytes
       ("List.range': stride function cannot change direction"),
     cst_List_range_stride_function=
      caml_string_of_jsbytes
       ("List.range': stride function cannot return the same value"),
     error_source_022=caml_string_of_jsbytes("list.ml.Assoc.t"),
     cst_Base_List_Transpose_got_li=
      caml_string_of_jsbytes
       ("Base__List.Transpose_got_lists_of_different_lengths"),
     cst$8=caml_string_of_jsbytes(""),
     cst$7=caml_string_of_jsbytes("; "),
     cst_could_not_construct_info=
      caml_string_of_jsbytes("could not construct info: "),
     cst$3=caml_string_of_jsbytes(": "),
     cst$4=caml_string_of_jsbytes(": "),
     cst$5=caml_string_of_jsbytes(": "),
     cst$6=caml_string_of_jsbytes(": "),
     cst_Backtrace=caml_string_of_jsbytes("\nBacktrace:\n"),
     t_sexp_grammar$14=[0,caml_string_of_jsbytes("Info.t")],
     cst_Base_Info_Exn=caml_string_of_jsbytes("Base__Info.Exn"),
     module_name$0=caml_string_of_jsbytes("Base.Info"),
     t_sexp_grammar$15=[0,caml_string_of_jsbytes("Error.t")],
     module_name$1=caml_string_of_jsbytes("Base.Error"),
     cst_exn$0=caml_string_of_jsbytes("exn"),
     cst_field=caml_string_of_jsbytes("field"),
     cst_problem_with_field=caml_string_of_jsbytes("problem with field"),
     cst$9=caml_string_of_jsbytes(""),
     cst_exn=caml_string_of_jsbytes("exn"),
     cst$10=caml_string_of_jsbytes(""),
     cst_invariant_failed=caml_string_of_jsbytes("invariant failed"),
     cst_unimplemented=caml_string_of_jsbytes("unimplemented"),
     cst_Neg=caml_string_of_jsbytes("Neg"),
     cst_Pos=caml_string_of_jsbytes("Pos"),
     cst_Zero=caml_string_of_jsbytes("Zero"),
     cst_neg=caml_string_of_jsbytes("neg"),
     cst_pos=caml_string_of_jsbytes("pos"),
     cst_zero=caml_string_of_jsbytes("zero"),
     cst_Neg$0=caml_string_of_jsbytes("Neg"),
     cst_Pos$0=caml_string_of_jsbytes("Pos"),
     cst_Zero$0=caml_string_of_jsbytes("Zero"),
     cst_neg$0=caml_string_of_jsbytes("neg"),
     cst_pos$0=caml_string_of_jsbytes("pos"),
     cst_zero$0=caml_string_of_jsbytes("zero"),
     error_source_003=caml_string_of_jsbytes("sign0.ml.t"),
     t_sexp_grammar$17=
      [3,
       [0,
        2,
        [0,
         [1,[0,caml_string_of_jsbytes("Neg"),0]],
         [0,
          [1,[0,caml_string_of_jsbytes("Zero"),0]],
          [0,[1,[0,caml_string_of_jsbytes("Pos"),0]],0]]]]],
     all$6=[0,0,[0,1,[0,2,0]]],
     module_name$2=caml_string_of_jsbytes("Base.Sign"),
     cst_max$0=caml_string_of_jsbytes("max"),
     cst_min$0=caml_string_of_jsbytes("min"),
     cst_clamp_requires_min_max$0=
      caml_string_of_jsbytes("clamp requires [min <= max]"),
     cst_max=caml_string_of_jsbytes("max"),
     cst_min=caml_string_of_jsbytes("min"),
     cst_clamp_requires_min_max=
      caml_string_of_jsbytes("clamp requires [min <= max]"),
     cst$12=caml_string_of_jsbytes("()"),
     cst$11=caml_string_of_jsbytes("()"),
     cst_Base_Unit_of_string_expect=
      caml_string_of_jsbytes("Base.Unit.of_string: () expected"),
     all$7=[0,0,0],
     module_name$3=caml_string_of_jsbytes("Base.Unit"),
     all$8=
      [0,
       200870407,
       [0,
        -253007807,
        [0,-1055410545,[0,-1056898635,[0,926943384,[0,-839473056,0]]]]]],
     all$9=[0,125585502,[0,-63348021,0]],
     cst$13=caml_string_of_jsbytes(""),
     cst_Option_value_exn=caml_string_of_jsbytes("Option.value_exn"),
     cst_Option_value_exn_None=caml_string_of_jsbytes("Option.value_exn None"),
     cst_Sexpable_Of_stringable_t_o=
      caml_string_of_jsbytes
       ("Sexpable.Of_stringable.t_of_sexp expected an atom, but got a list"),
     cst_Sequence_cycle_list_exn=
      caml_string_of_jsbytes("Sequence.cycle_list_exn"),
     cst_Sequence_drop=caml_string_of_jsbytes("Sequence.drop"),
     cst_Sequence_take=caml_string_of_jsbytes("Sequence.take"),
     cst_Sequence_sub=caml_string_of_jsbytes("Sequence.sub"),
     cst_Sequence_reduce_exn=caml_string_of_jsbytes("Sequence.reduce_exn"),
     cst_Sequence_find_exn=caml_string_of_jsbytes("Sequence.find_exn"),
     cst_Sequence_chunks_exn=caml_string_of_jsbytes("Sequence.chunks_exn"),
     cst_Sequence_tl_exn=caml_string_of_jsbytes("Sequence.tl_exn"),
     cst_hd_exn=caml_string_of_jsbytes("hd_exn"),
     cst_Both$1=caml_string_of_jsbytes("Both"),
     cst_Right$1=caml_string_of_jsbytes("Right"),
     cst_Left$1=caml_string_of_jsbytes("Left"),
     cst_Both=caml_string_of_jsbytes("Both"),
     cst_Left=caml_string_of_jsbytes("Left"),
     cst_Right=caml_string_of_jsbytes("Right"),
     cst_both=caml_string_of_jsbytes("both"),
     cst_left=caml_string_of_jsbytes("left"),
     cst_right=caml_string_of_jsbytes("right"),
     cst_Both$0=caml_string_of_jsbytes("Both"),
     cst_Left$0=caml_string_of_jsbytes("Left"),
     cst_Right$0=caml_string_of_jsbytes("Right"),
     cst_both$0=caml_string_of_jsbytes("both"),
     cst_left$0=caml_string_of_jsbytes("left"),
     cst_right$0=caml_string_of_jsbytes("right"),
     cst_Sequence_nth$0=caml_string_of_jsbytes("Sequence.nth"),
     cst_Sequence_nth=caml_string_of_jsbytes("Sequence.nth"),
     error_source_025=
      caml_string_of_jsbytes("sequence.ml.Merge_with_duplicates_element.t"),
     cst_Array_transpose_exn=caml_string_of_jsbytes("Array.transpose_exn"),
     cst_Array_zip_exn=caml_string_of_jsbytes("Array.zip_exn"),
     cst_Array_random_element_exn_e=
      caml_string_of_jsbytes("Array.random_element_exn: empty array"),
     cst_Array_reduce_exn=caml_string_of_jsbytes("Array.reduce_exn"),
     cst_Array_for_all2_exn=caml_string_of_jsbytes("Array.for_all2_exn"),
     cst_Array_exists2_exn=caml_string_of_jsbytes("Array.exists2_exn"),
     cst_Array_fold2_exn=caml_string_of_jsbytes("Array.fold2_exn"),
     cst_Array_map2_exn=caml_string_of_jsbytes("Array.map2_exn"),
     cst_Array_iter2_exn=caml_string_of_jsbytes("Array.iter2_exn"),
     cst_Obj_array_t_of_length=
      caml_string_of_jsbytes("<Obj_array.t of length "),
     cst_Array_map2_exn$0=caml_string_of_jsbytes("Array.map2_exn"),
     cst_Uniform_array_init=caml_string_of_jsbytes("Uniform_array.init"),
     cst_char=caml_string_of_jsbytes("char"),
     cst_Char_get_hex_digit_exn_not=
      caml_string_of_jsbytes
       ("Char.get_hex_digit_exn: not a hexadecimal digit"),
     module_name$4=caml_string_of_jsbytes("Base.Char"),
     cst_max$1=caml_string_of_jsbytes("max"),
     cst_min$1=caml_string_of_jsbytes("min"),
     cst_clamp_requires_min_max$1=
      caml_string_of_jsbytes("clamp requires [min <= max]"),
     cst$25=caml_string_of_jsbytes(""),
     cst$24=caml_string_of_jsbytes(""),
     cst$23=caml_string_of_jsbytes(""),
     cst_char$1=caml_string_of_jsbytes("char"),
     cst_pos$2=caml_string_of_jsbytes("pos"),
     cst_escape_char$0=caml_string_of_jsbytes("escape_char"),
     cst_str$0=caml_string_of_jsbytes("str"),
     cst_rindex_from_exn_not_found=
      caml_string_of_jsbytes("rindex_from_exn: not found"),
     cst_rindex_from=caml_string_of_jsbytes("rindex_from"),
     cst_char$0=caml_string_of_jsbytes("char"),
     cst_pos$1=caml_string_of_jsbytes("pos"),
     cst_escape_char=caml_string_of_jsbytes("escape_char"),
     cst_str=caml_string_of_jsbytes("str"),
     cst_index_from_exn_not_found=
      caml_string_of_jsbytes("index_from_exn: not found"),
     cst_index_from=caml_string_of_jsbytes("index_from"),
     cst_is_char_literal=caml_string_of_jsbytes("is_char_literal"),
     cst_is_char_escaped=caml_string_of_jsbytes("is_char_escaped"),
     cst_is_char_escaping=caml_string_of_jsbytes("is_char_escaping"),
     cst_escapeworthy_map=caml_string_of_jsbytes("escapeworthy_map"),
     cst_c_to=caml_string_of_jsbytes("c_to"),
     cst_c_from=caml_string_of_jsbytes("c_from"),
     cst_escapeworthy_map_not_one_t=
      caml_string_of_jsbytes("escapeworthy_map not one-to-one"),
     cst$21=caml_string_of_jsbytes(""),
     cst$22=caml_string_of_jsbytes(""),
     cst$20=caml_string_of_jsbytes(""),
     cst_tr_multi_replacement_is_em=
      caml_string_of_jsbytes("tr_multi replacement is empty string"),
     cst$19=caml_string_of_jsbytes(""),
     cst$18=caml_string_of_jsbytes(""),
     cst$17=caml_string_of_jsbytes(""),
     cst_suffix=caml_string_of_jsbytes("suffix"),
     cst_prefix=caml_string_of_jsbytes("prefix"),
     cst$16=caml_string_of_jsbytes(""),
     cst_drop_suffix=caml_string_of_jsbytes("drop_suffix"),
     cst$15=caml_string_of_jsbytes(""),
     cst_drop_prefix=caml_string_of_jsbytes("drop_prefix"),
     cst_expecting_nonnegative_argu=
      caml_string_of_jsbytes(" expecting nonnegative argument"),
     cst_substring=caml_string_of_jsbytes("substring"),
     cst_Substring_not_found=caml_string_of_jsbytes("Substring not found"),
     cst_String_rindex_from_exn=
      caml_string_of_jsbytes("String.rindex_from_exn"),
     cst_String_index_from_exn=caml_string_of_jsbytes("String.index_from_exn"),
     cst$14=caml_string_of_jsbytes(""),
     cst_max$2=caml_string_of_jsbytes("max"),
     cst_min$2=caml_string_of_jsbytes("min"),
     cst_clamp_requires_min_max$2=
      caml_string_of_jsbytes("clamp requires [min <= max]"),
     cst_tr_multi_replacement_is_th=
      caml_string_of_jsbytes("tr_multi: replacement is the empty string"),
     module_name$5=caml_string_of_jsbytes("Base.Bytes"),
     ocaml_lex_tables=
      [0,
       caml_string_of_jsbytes("\0\0\0\0\x01\0\x01\0\x02\0\x1b\0R\0i\0"),
       caml_string_of_jsbytes
        ("\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\x01\0"),
       caml_string_of_jsbytes
        ("\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"),
       caml_string_of_jsbytes
        ("\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\0\0\0\0\0\x01\0\x03\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\0\0\0\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\0\0\0\0\0\0\x06\0\x04\0\0\0\0\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\0\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x06\0\x04\0\x05\0\0\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\0\0\0\0\0\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x07\0\0\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
       caml_string_of_jsbytes
        ("\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\x02\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\xff\xff\xff\xff\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\xff\xff\xff\xff\xff\xff\x01\0\x03\0\xff\xff\xff\xff\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\xff\xff\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\0\x03\0\x05\0\xff\xff\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\xff\xff\xff\xff\xff\xff\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x07\0\xff\xff\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"),
       caml_string_of_jsbytes(""),
       caml_string_of_jsbytes(""),
       caml_string_of_jsbytes(""),
       caml_string_of_jsbytes(""),
       caml_string_of_jsbytes(""),
       caml_string_of_jsbytes("")],
     cst_0x=caml_string_of_jsbytes("-0x"),
     cst_0x$0=caml_string_of_jsbytes("0x"),
     cst_int63=caml_string_of_jsbytes("int63"),
     cst_int64$3=caml_string_of_jsbytes("int64"),
     cst_nativeint$2=caml_string_of_jsbytes("nativeint"),
     cst_int64$2=caml_string_of_jsbytes("int64"),
     cst_int32$3=caml_string_of_jsbytes("int32"),
     cst_nativeint$1=caml_string_of_jsbytes("nativeint"),
     cst_int32$2=caml_string_of_jsbytes("int32"),
     cst_int64$1=caml_string_of_jsbytes("int64"),
     cst_int$3=caml_string_of_jsbytes("int"),
     cst_nativeint$0=caml_string_of_jsbytes("nativeint"),
     cst_int$2=caml_string_of_jsbytes("int"),
     cst_int64$0=caml_string_of_jsbytes("int64"),
     cst_int$1=caml_string_of_jsbytes("int"),
     cst_int32$1=caml_string_of_jsbytes("int32"),
     cst_int32$0=caml_string_of_jsbytes("int32"),
     cst_int$0=caml_string_of_jsbytes("int"),
     overflow_bound_max_int63_on_in=
      runtime.caml_int64_create_lo_mi_hi(16777215,16777215,16383),
     overflow_bound_max_int64_value=
      runtime.caml_int64_create_lo_mi_hi(16777215,16777215,32767),
     m1=runtime.caml_int64_create_lo_mi_hi(5592405,5592405,21845),
     m2=runtime.caml_int64_create_lo_mi_hi(3355443,3355443,13107),
     m4=runtime.caml_int64_create_lo_mi_hi(986895,986895,3855),
     h01=runtime.caml_int64_create_lo_mi_hi(65793,65793,257),
     mask=runtime.caml_int64_create_lo_mi_hi(16777215,255,0),
     cst$27=caml_string_of_jsbytes(""),
     cst_Int_ceil_log2_got_invalid_=
      caml_string_of_jsbytes("[Int.ceil_log2] got invalid input"),
     cst$26=caml_string_of_jsbytes(""),
     cst_Int_floor_log2_got_invalid=
      caml_string_of_jsbytes("[Int.floor_log2] got invalid input"),
     cst_max$3=caml_string_of_jsbytes("max"),
     cst_min$3=caml_string_of_jsbytes("min"),
     cst_clamp_requires_min_max$3=
      caml_string_of_jsbytes("clamp requires [min <= max]"),
     module_name$6=caml_string_of_jsbytes("Base.Int.Hex"),
     module_name$7=caml_string_of_jsbytes("Base.Int"),
     cst_Uchar_t_of_sexp_atom_of_th=
      caml_string_of_jsbytes
       ("Uchar.t_of_sexp: atom of the form U+XXXX needed"),
     cst_Uchar_t_of_sexp_atom_neede=
      caml_string_of_jsbytes("Uchar.t_of_sexp: atom needed"),
     module_name$8=caml_string_of_jsbytes("Base.Uchar"),
     cst$28=caml_string_of_jsbytes(""),
     cst_Type_equal_Id_same_witness=
      caml_string_of_jsbytes
       ("Type_equal.Id.same_witness_exn got different ids"),
     cst_Key=caml_string_of_jsbytes("Key"),
     some_t=[0,0],
     cst_Option_array_get_some_exn_=
      caml_string_of_jsbytes
       ("Option_array.get_some_exn: the element is [None]"),
     cst_stack=caml_string_of_jsbytes("stack"),
     cst_exn$1=caml_string_of_jsbytes("exn"),
     cst_Stack_invariant_failed=
      caml_string_of_jsbytes("Stack.invariant failed"),
     cst_Stack_pop_of_empty_stack=
      caml_string_of_jsbytes("Stack.pop of empty stack"),
     cst_Stack_top_of_empty_stack=
      caml_string_of_jsbytes("Stack.top of empty stack"),
     cst_Base_Sign_or_nan_to_sign_e=
      caml_string_of_jsbytes("Base.Sign_or_nan.to_sign_exn: Nan"),
     cst_Nan=caml_string_of_jsbytes("Nan"),
     cst_Neg$1=caml_string_of_jsbytes("Neg"),
     cst_Pos$1=caml_string_of_jsbytes("Pos"),
     cst_Zero$1=caml_string_of_jsbytes("Zero"),
     cst_nan=caml_string_of_jsbytes("nan"),
     cst_neg$1=caml_string_of_jsbytes("neg"),
     cst_pos$3=caml_string_of_jsbytes("pos"),
     cst_zero$1=caml_string_of_jsbytes("zero"),
     cst_Nan$0=caml_string_of_jsbytes("Nan"),
     cst_Neg$2=caml_string_of_jsbytes("Neg"),
     cst_Pos$2=caml_string_of_jsbytes("Pos"),
     cst_Zero$2=caml_string_of_jsbytes("Zero"),
     cst_nan$0=caml_string_of_jsbytes("nan"),
     cst_neg$2=caml_string_of_jsbytes("neg"),
     cst_pos$4=caml_string_of_jsbytes("pos"),
     cst_zero$2=caml_string_of_jsbytes("zero"),
     error_source_003$0=caml_string_of_jsbytes("sign_or_nan.ml.T.t"),
     t_sexp_grammar$25=
      [3,
       [0,
        2,
        [0,
         [1,[0,caml_string_of_jsbytes("Neg"),0]],
         [0,
          [1,[0,caml_string_of_jsbytes("Zero"),0]],
          [0,
           [1,[0,caml_string_of_jsbytes("Pos"),0]],
           [0,[1,[0,caml_string_of_jsbytes("Nan"),0]],0]]]]]],
     all$14=[0,0,[0,1,[0,2,[0,3,0]]]],
     module_name$9=caml_string_of_jsbytes("Base.Sign_or_nan"),
     cst_Maybe_bound_compare_to_int=
      caml_string_of_jsbytes
       ("Maybe_bound.compare_to_interval_exn: lower bound > upper bound"),
     cst_Above_upper_bound=caml_string_of_jsbytes("Above_upper_bound"),
     cst_Below_lower_bound=caml_string_of_jsbytes("Below_lower_bound"),
     cst_In_range=caml_string_of_jsbytes("In_range"),
     cst_above_upper_bound=caml_string_of_jsbytes("above_upper_bound"),
     cst_below_lower_bound=caml_string_of_jsbytes("below_lower_bound"),
     cst_in_range=caml_string_of_jsbytes("in_range"),
     cst_Above_upper_bound$0=caml_string_of_jsbytes("Above_upper_bound"),
     cst_Below_lower_bound$0=caml_string_of_jsbytes("Below_lower_bound"),
     cst_In_range$0=caml_string_of_jsbytes("In_range"),
     cst_above_upper_bound$0=caml_string_of_jsbytes("above_upper_bound"),
     cst_below_lower_bound$0=caml_string_of_jsbytes("below_lower_bound"),
     cst_in_range$0=caml_string_of_jsbytes("in_range"),
     cst_Excl$1=caml_string_of_jsbytes("Excl"),
     cst_Incl$1=caml_string_of_jsbytes("Incl"),
     cst_Excl=caml_string_of_jsbytes("Excl"),
     cst_Incl=caml_string_of_jsbytes("Incl"),
     cst_Unbounded=caml_string_of_jsbytes("Unbounded"),
     cst_excl=caml_string_of_jsbytes("excl"),
     cst_incl=caml_string_of_jsbytes("incl"),
     cst_unbounded=caml_string_of_jsbytes("unbounded"),
     cst_Excl$0=caml_string_of_jsbytes("Excl"),
     cst_Incl$0=caml_string_of_jsbytes("Incl"),
     cst_Unbounded$0=caml_string_of_jsbytes("Unbounded"),
     cst_excl$0=caml_string_of_jsbytes("excl"),
     cst_incl$0=caml_string_of_jsbytes("incl"),
     cst_unbounded$0=caml_string_of_jsbytes("unbounded"),
     error_source_006=caml_string_of_jsbytes("maybe_bound.ml.t"),
     error_source_027=
      caml_string_of_jsbytes("maybe_bound.ml.interval_comparison"),
     interval_comparison_sexp_gramm=
      [3,
       [0,
        2,
        [0,
         [1,[0,caml_string_of_jsbytes("Below_lower_bound"),0]],
         [0,
          [1,[0,caml_string_of_jsbytes("In_range"),0]],
          [0,[1,[0,caml_string_of_jsbytes("Above_upper_bound"),0]],0]]]]],
     cst_Unequal$1=caml_string_of_jsbytes("Unequal"),
     cst_Right$4=caml_string_of_jsbytes("Right"),
     cst_Left$4=caml_string_of_jsbytes("Left"),
     cst_Left$2=caml_string_of_jsbytes("Left"),
     cst_Right$2=caml_string_of_jsbytes("Right"),
     cst_Unequal=caml_string_of_jsbytes("Unequal"),
     cst_Left$3=caml_string_of_jsbytes("Left"),
     cst_Right$3=caml_string_of_jsbytes("Right"),
     cst_Unequal$0=caml_string_of_jsbytes("Unequal"),
     error_source_057=
      caml_string_of_jsbytes("map_intf.ml.Symmetric_diff_element.t"),
     all$16=[0,0,[0,1,0]],
     all$17=[0,0,[0,1,0]],
     cst_Set_remove_min_elt=caml_string_of_jsbytes("Set.remove_min_elt"),
     cst_invalid_elements=caml_string_of_jsbytes("invalid_elements"),
     cst_is_not_a_subset_of=caml_string_of_jsbytes(" is not a subset of "),
     cst_Set_t_of_sexp_duplicate_el=
      caml_string_of_jsbytes("Set.t_of_sexp: duplicate element in set"),
     cst_Set_t_of_sexp_list_needed=
      caml_string_of_jsbytes("Set.t_of_sexp: list needed"),
     cst_Set_find_exn_failed_to_fin=
      caml_string_of_jsbytes("Set.find_exn failed to find a matching element"),
     cst_of_sorted_array_duplicated=
      caml_string_of_jsbytes("of_sorted_array: duplicated elements"),
     cst_of_sorted_array_elements_a=
      caml_string_of_jsbytes("of_sorted_array: elements are not ordered"),
     cst_of_sorted_array_duplicated$0=
      caml_string_of_jsbytes("of_sorted_array: duplicated elements"),
     cst_Base_Set_Tree0_Same=caml_string_of_jsbytes("Base__Set.Tree0.Same"),
     cst_Base_Set_Tree0_Set_min_elt=
      caml_string_of_jsbytes("Base__Set.Tree0.Set_min_elt_exn_of_empty_set"),
     cst_Base_Set_Tree0_Set_max_elt=
      caml_string_of_jsbytes("Base__Set.Tree0.Set_max_elt_exn_of_empty_set"),
     cst_length$1=caml_string_of_jsbytes("length"),
     cst_Queue_init_negative_length=
      caml_string_of_jsbytes("Queue.init: negative length"),
     cst_length$0=caml_string_of_jsbytes("length"),
     cst_Queue_blit_transfer_negati=
      caml_string_of_jsbytes("Queue.blit_transfer: negative length"),
     cst_capacity=caml_string_of_jsbytes("capacity"),
     cst_cannot_have_queue_with_neg=
      caml_string_of_jsbytes("cannot have queue with negative capacity"),
     cst$29=caml_string_of_jsbytes(""),
     cst_mutation_of_queue_during_i=
      caml_string_of_jsbytes("mutation of queue during iteration"),
     cst_length=caml_string_of_jsbytes("length"),
     cst_index=caml_string_of_jsbytes("index"),
     cst_Queue_index_out_of_bounds=
      caml_string_of_jsbytes("Queue index out of bounds"),
     cst_Base_Nothing_of_string_not=
      caml_string_of_jsbytes("Base.Nothing.of_string: not supported"),
     cst_Base_Nothing_t=caml_string_of_jsbytes("Base.Nothing.t"),
     t_sexp_grammar$30=[4,0],
     module_name$10=caml_string_of_jsbytes("Base.Nothing"),
     cst_max$4=caml_string_of_jsbytes("max"),
     cst_min$4=caml_string_of_jsbytes("min"),
     cst_clamp_requires_min_max$4=
      caml_string_of_jsbytes("clamp requires [min <= max]"),
     cst$31=caml_string_of_jsbytes(""),
     cst_Nativeint_ceil_log2_got_in=
      caml_string_of_jsbytes("[Nativeint.ceil_log2] got invalid input"),
     cst$30=caml_string_of_jsbytes(""),
     cst_Nativeint_floor_log2_got_i=
      caml_string_of_jsbytes("[Nativeint.floor_log2] got invalid input"),
     module_name$11=caml_string_of_jsbytes("Base.Nativeint.Hex"),
     module_name$12=caml_string_of_jsbytes("Base.Nativeint"),
     cst_Map_remove_min_elt=caml_string_of_jsbytes("Map.remove_min_elt"),
     cst_key$0=caml_string_of_jsbytes("key"),
     cst_Map_map_keys_exn_duplicate=
      caml_string_of_jsbytes("Map.map_keys_exn: duplicate key"),
     cst_Map_t_of_sexp_direct_dupli=
      caml_string_of_jsbytes("Map.t_of_sexp_direct: duplicate key"),
     cst_Map_of_iteri_exn_duplicate=
      caml_string_of_jsbytes("Map.of_iteri_exn: duplicate key"),
     cst_exn_duplicate_key=caml_string_of_jsbytes("_exn: duplicate key"),
     cst_Map_of$0=caml_string_of_jsbytes("Map.of_"),
     cst_or_error_duplicate_key=
      caml_string_of_jsbytes("_or_error: duplicate key"),
     cst_Map_of=caml_string_of_jsbytes("Map.of_"),
     cst_of_increasing_sequence_non=
      caml_string_of_jsbytes("of_increasing_sequence: non-increasing key"),
     cst_Map_singleton_to_tree_exn_=
      caml_string_of_jsbytes("Map.singleton_to_tree_exn: not a singleton"),
     cst_key=caml_string_of_jsbytes("key"),
     cst_Map_add_exn_got_key_alread=
      caml_string_of_jsbytes("[Map.add_exn] got key already present"),
     cst_Map_bal=caml_string_of_jsbytes("Map.bal"),
     cst_Map_bal$0=caml_string_of_jsbytes("Map.bal"),
     cst_Map_bal$1=caml_string_of_jsbytes("Map.bal"),
     cst_Map_bal$2=caml_string_of_jsbytes("Map.bal"),
     cst_of_sorted_array_duplicated$1=
      caml_string_of_jsbytes("of_sorted_array: duplicated elements"),
     cst_of_sorted_array_elements_a$0=
      caml_string_of_jsbytes("of_sorted_array: elements are not ordered"),
     cst_of_sorted_array_duplicated$2=
      caml_string_of_jsbytes("of_sorted_array: duplicated elements"),
     cst_Base_Map_Duplicate=caml_string_of_jsbytes("Base__Map.Duplicate"),
     empty$5=[0,0],
     cst_Base_Map_Tree0_Map_min_elt=
      caml_string_of_jsbytes("Base__Map.Tree0.Map_min_elt_exn_of_empty_map"),
     cst_Base_Map_Tree0_Map_max_elt=
      caml_string_of_jsbytes("Base__Map.Tree0.Map_max_elt_exn_of_empty_map"),
     cst_Base_Map_Tree0_Remove_no_o=
      caml_string_of_jsbytes("Base__Map.Tree0.Remove_no_op"),
     cst_Base_Map_Tree0_Change_no_o=
      caml_string_of_jsbytes("Base__Map.Tree0.Change_no_op"),
     name$1=caml_string_of_jsbytes("alist"),
     name$2=caml_string_of_jsbytes("sequence"),
     cst$33=caml_string_of_jsbytes(""),
     cst_Int64_ceil_log2_got_invali=
      caml_string_of_jsbytes("[Int64.ceil_log2] got invalid input"),
     cst$32=caml_string_of_jsbytes(""),
     cst_Int64_floor_log2_got_inval=
      caml_string_of_jsbytes("[Int64.floor_log2] got invalid input"),
     cst_max$5=caml_string_of_jsbytes("max"),
     cst_min$5=caml_string_of_jsbytes("min"),
     cst_clamp_requires_min_max$5=
      caml_string_of_jsbytes("clamp requires [min <= max]"),
     module_name$13=caml_string_of_jsbytes("Base.Int64.Hex"),
     module_name$14=caml_string_of_jsbytes("Base.Int64"),
     cst_0x$1=caml_string_of_jsbytes("0x"),
     cst_max$6=caml_string_of_jsbytes("max"),
     cst_min$6=caml_string_of_jsbytes("min"),
     cst_clamp_requires_min_max$6=
      caml_string_of_jsbytes("clamp requires [min <= max]"),
     mask$0=runtime.caml_int64_create_lo_mi_hi(16777214,16777215,65535),
     module_name$15=caml_string_of_jsbytes("Base.Int63.Hex"),
     module_name$16=caml_string_of_jsbytes("Base.Int63"),
     cst_max$7=caml_string_of_jsbytes("max"),
     cst_min$7=caml_string_of_jsbytes("min"),
     cst_clamp_requires_min_max$7=
      caml_string_of_jsbytes("clamp requires [min <= max]"),
     cst_false=caml_string_of_jsbytes("false"),
     cst_true=caml_string_of_jsbytes("true"),
     all$20=[0,0,[0,1,0]],
     module_name$17=caml_string_of_jsbytes("Base.Bool"),
     cst$35=caml_string_of_jsbytes(""),
     cst_Int32_ceil_log2_got_invali=
      caml_string_of_jsbytes("[Int32.ceil_log2] got invalid input"),
     cst$34=caml_string_of_jsbytes(""),
     cst_Int32_floor_log2_got_inval=
      caml_string_of_jsbytes("[Int32.floor_log2] got invalid input"),
     cst_max$8=caml_string_of_jsbytes("max"),
     cst_min$8=caml_string_of_jsbytes("min"),
     cst_clamp_requires_min_max$8=
      caml_string_of_jsbytes("clamp requires [min <= max]"),
     module_name$18=caml_string_of_jsbytes("Base.Int32.Hex"),
     module_name$19=caml_string_of_jsbytes("Base.Int32"),
     cst$36=caml_string_of_jsbytes(""),
     cst_Int_floor_log2_got_invalid$0=
      caml_string_of_jsbytes("[Int.floor_log2] got invalid input"),
     cst_neg_overflow=caml_string_of_jsbytes("neg overflow"),
     cst_abs_overflow=caml_string_of_jsbytes("abs overflow"),
     cst_product$0=caml_string_of_jsbytes("product"),
     cst_u$2=caml_string_of_jsbytes("u"),
     cst_t$2=caml_string_of_jsbytes("t"),
     cst_overflow$2=caml_string_of_jsbytes("( / ) overflow"),
     cst_product=caml_string_of_jsbytes("product"),
     cst_u$1=caml_string_of_jsbytes("u"),
     cst_t$1=caml_string_of_jsbytes("t"),
     cst_overflow$1=caml_string_of_jsbytes("( * ) overflow"),
     cst_diff=caml_string_of_jsbytes("diff"),
     cst_u$0=caml_string_of_jsbytes("u"),
     cst_t$0=caml_string_of_jsbytes("t"),
     cst_overflow$0=caml_string_of_jsbytes("( - ) overflow"),
     cst_sum=caml_string_of_jsbytes("sum"),
     cst_u=caml_string_of_jsbytes("u"),
     cst_t=caml_string_of_jsbytes("t"),
     cst_overflow=caml_string_of_jsbytes("( + ) overflow"),
     cst_Avltree_choose_exn_of_empt=
      caml_string_of_jsbytes("[Avltree.choose_exn] of empty hashtbl"),
     cst_Hashtbl_merge_different_ha=
      caml_string_of_jsbytes("Hashtbl.merge: different 'hashable' values"),
     cst_keys=caml_string_of_jsbytes("keys"),
     cst_Hashtbl_create_with_key_du=
      caml_string_of_jsbytes("Hashtbl.create_with_key: duplicate keys"),
     cst_Hashtbl_t_of_sexp_duplicat=
      caml_string_of_jsbytes("Hashtbl.t_of_sexp: duplicate key"),
     cst_Hashtbl_of_alist_exn_dupli=
      caml_string_of_jsbytes("Hashtbl.of_alist_exn: duplicate key"),
     cst_Hashtbl_choose_exn_of_empt=
      caml_string_of_jsbytes("[Hashtbl.choose_exn] of empty hashtbl"),
     cst_Hashtbl_add_exn_got_key_al=
      caml_string_of_jsbytes("Hashtbl.add_exn got key already present"),
     cst_Hashtbl_mutation_not_allow=
      caml_string_of_jsbytes("Hashtbl: mutation not allowed during iteration"),
     cst_Hash_set_t_of_sexp_got_a_d=
      caml_string_of_jsbytes("Hash_set.t_of_sexp got a duplicate element"),
     cst_Hash_set_t_of_sexp_require=
      caml_string_of_jsbytes("Hash_set.t_of_sexp requires a list"),
     cst_element_not_in_set=caml_string_of_jsbytes("element not in set"),
     cst_element_already_exists=
      caml_string_of_jsbytes("element already exists"),
     cst$42=caml_string_of_jsbytes(""),
     cst_Float_sign_exn_of_NAN=caml_string_of_jsbytes("Float.sign_exn of NAN"),
     cst_max$9=caml_string_of_jsbytes("max"),
     cst_min$9=caml_string_of_jsbytes("min"),
     cst_clamp_requires_min_max$9=
      caml_string_of_jsbytes("clamp requires [min <= max]"),
     cst_t$3=caml_string_of_jsbytes("t"),
     cst_g=caml_string_of_jsbytes("g"),
     cst_m=caml_string_of_jsbytes("m"),
     cst_k=caml_string_of_jsbytes("k"),
     cst_1f=caml_string_of_jsbytes("%.1f"),
     cst_0=caml_string_of_jsbytes(".0"),
     cst$41=caml_string_of_jsbytes(""),
     cst$40=caml_string_of_jsbytes("-"),
     cst_inf$1=caml_string_of_jsbytes("-inf  "),
     cst_inf$2=caml_string_of_jsbytes("inf  "),
     cst_nan$4=caml_string_of_jsbytes("nan  "),
     cst_sexp=caml_string_of_jsbytes("sexp"),
     cst_sexp_of_float_produced_str=
      caml_string_of_jsbytes("[sexp_of_float] produced strange sexp"),
     cst_inf=caml_string_of_jsbytes("inf"),
     cst_inf$0=caml_string_of_jsbytes("-inf"),
     cst_nan$3=caml_string_of_jsbytes("nan"),
     cst$38=caml_string_of_jsbytes(""),
     cst$39=caml_string_of_jsbytes("."),
     cst_infinite=caml_string_of_jsbytes("infinite"),
     cst_Infinite=caml_string_of_jsbytes("Infinite"),
     cst_Nan$1=caml_string_of_jsbytes("Nan"),
     cst_Normal=caml_string_of_jsbytes("Normal"),
     cst_Subnormal=caml_string_of_jsbytes("Subnormal"),
     cst_Zero$3=caml_string_of_jsbytes("Zero"),
     cst_nan$1=caml_string_of_jsbytes("nan"),
     cst_normal=caml_string_of_jsbytes("normal"),
     cst_subnormal=caml_string_of_jsbytes("subnormal"),
     cst_zero$3=caml_string_of_jsbytes("zero"),
     cst_infinite$0=caml_string_of_jsbytes("infinite"),
     cst_Infinite$0=caml_string_of_jsbytes("Infinite"),
     cst_Nan$2=caml_string_of_jsbytes("Nan"),
     cst_Normal$0=caml_string_of_jsbytes("Normal"),
     cst_Subnormal$0=caml_string_of_jsbytes("Subnormal"),
     cst_Zero$4=caml_string_of_jsbytes("Zero"),
     cst_nan$2=caml_string_of_jsbytes("nan"),
     cst_normal$0=caml_string_of_jsbytes("normal"),
     cst_subnormal$0=caml_string_of_jsbytes("subnormal"),
     cst_zero$4=caml_string_of_jsbytes("zero"),
     cst_15g=caml_string_of_jsbytes("%.15g"),
     cst_17g=caml_string_of_jsbytes("%.17g"),
     cst$37=caml_string_of_jsbytes("."),
     all$21=[0,0,[0,1,[0,2,[0,3,[0,4,0]]]]],
     error_source_006$0=caml_string_of_jsbytes("float.ml.Class.t"),
     t_sexp_grammar$34=
      [3,
       [0,
        2,
        [0,
         [1,[0,caml_string_of_jsbytes("Infinite"),0]],
         [0,
          [1,[0,caml_string_of_jsbytes("Nan"),0]],
          [0,
           [1,[0,caml_string_of_jsbytes("Normal"),0]],
           [0,
            [1,[0,caml_string_of_jsbytes("Subnormal"),0]],
            [0,[1,[0,caml_string_of_jsbytes("Zero"),0]],0]]]]]]],
     module_name$20=caml_string_of_jsbytes("Base.Float"),
     cst_b=caml_string_of_jsbytes("b"),
     cst_OCAMLRUNPARAM=caml_string_of_jsbytes("OCAMLRUNPARAM"),
     elided_message=caml_string_of_jsbytes("<backtrace elided in test>"),
     Caml=global_data.Caml,
     Stdlib_Uchar=global_data.Stdlib__Uchar,
     include$0=global_data.Shadow_stdlib,
     Stdlib_Printf=global_data.Stdlib__Printf,
     Stdlib_Sys=global_data.Stdlib__Sys,
     Stdlib_ArrayLabels=global_data.Stdlib__ArrayLabels,
     Stdlib=global_data.Stdlib,
     Stdlib_Char=global_data.Stdlib__Char,
     Stdlib_ListLabels=global_data.Stdlib__ListLabels,
     CamlinternalLazy=global_data.CamlinternalLazy,
     Sexplib0_Sexp=global_data.Sexplib0__Sexp,
     Sexplib0_Sexp_conv=global_data.Sexplib0__Sexp_conv,
     Stdlib_Format=global_data.Stdlib__Format,
     Stdlib_Printexc=global_data.Stdlib__Printexc,
     Assert_failure$0=global_data.Assert_failure,
     Stdlib_BytesLabels=global_data.Stdlib__BytesLabels,
     Sexplib0_Sexp_conv_error=global_data.Sexplib0__Sexp_conv_error,
     Stdlib_StringLabels=global_data.Stdlib__StringLabels,
     Stdlib_Lazy=global_data.Stdlib__Lazy,
     Stdlib_Int64=global_data.Stdlib__Int64,
     Stdlib_Nativeint=global_data.Stdlib__Nativeint,
     Stdlib_Int32=global_data.Stdlib__Int32,
     Stdlib_Random=global_data.Stdlib__Random,
     Stdlib_MoreLabels=global_data.Stdlib__MoreLabels,
     Stdlib_Obj=global_data.Stdlib__Obj,
     Sexplib0_Sexp_grammar=global_data.Sexplib0__Sexp_grammar,
     Stdlib_Float=global_data.Stdlib__Float,
     Stdlib_Lexing=global_data.Stdlib__Lexing,
     Stdlib_Scanf=global_data.Stdlib__Scanf,
     Stdlib_Queue=global_data.Stdlib__Queue,
     Match_failure$0=global_data.Match_failure,
     Stdlib_Buffer=global_data.Stdlib__Buffer,
     Base=[0];
    caml_register_global(970,Base,"Base__");
    var
     _c_=
      [0,
       [11,
        caml_string_of_jsbytes("Sys.getenv_exn: environment variable "),
        [2,0,[11,caml_string_of_jsbytes(" is not set"),0]]],
       caml_string_of_jsbytes
        ("Sys.getenv_exn: environment variable %s is not set")],
     _g_=
      [0,
       [11,
        caml_string_of_jsbytes("Char.of_int_exn got integer out of range: "),
        [4,0,0,0,0]],
       caml_string_of_jsbytes("Char.of_int_exn got integer out of range: %d")],
     _r_=
      [0,
       [11,
        caml_string_of_jsbytes("Equal called on the type "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(", which is abstract in an implementation."),
          0]]],
       caml_string_of_jsbytes
        ("Equal called on the type %s, which is abstract in an implementation.")],
     _q_=
      [0,
       [11,
        caml_string_of_jsbytes("Compare called on the type "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(", which is abstract in an implementation."),
          0]]],
       caml_string_of_jsbytes
        ("Compare called on the type %s, which is abstract in an implementation.")],
     _s_=[0,caml_string_of_jsbytes("W64")],
     _t_=[0,caml_string_of_jsbytes("W32")],
     _u_=[0,caml_string_of_jsbytes("Base.Sexp.pp_hum"),0],
     _I_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("Exn.handle_uncaught could not print; exiting anyway\n"),
        [10,0]],
       caml_string_of_jsbytes
        ("Exn.handle_uncaught could not print; exiting anyway\n%!")],
     _H_=
      [0,
       [18,
        [1,
         [0,
          [11,caml_string_of_jsbytes("<2>"),0],
          caml_string_of_jsbytes("<2>")]],
        [11,
         caml_string_of_jsbytes("Uncaught exception:"),
         [17,
          3,
          [17,
           3,
           [18,
            [1,[0,0,caml_string_of_jsbytes("")]],
            [15,[17,0,[17,0,[17,3,[17,4,0]]]]]]]]]],
       caml_string_of_jsbytes("@[<2>Uncaught exception:@\n@\n@[%a@]@]@\n@.")],
     _G_=[0,2],
     _F_=[0,caml_string_of_jsbytes("src/exn.ml"),54,6],
     _C_=[0,caml_string_of_jsbytes("exn.ml.Reraised")],
     _D_=[0,caml_string_of_jsbytes("src/exn.ml"),33,11],
     _z_=[0,caml_string_of_jsbytes("exn.ml.Finally")],
     _A_=[0,caml_string_of_jsbytes("src/exn.ml"),19,11],
     _O_=[0,caml_string_of_jsbytes("_")],
     _Q_=[0,caml_string_of_jsbytes("First")],
     _R_=[0,caml_string_of_jsbytes("Second")],
     _S_=[0,caml_string_of_jsbytes("pos_cnum")],
     _T_=[0,caml_string_of_jsbytes("pos_bol")],
     _U_=[0,caml_string_of_jsbytes("pos_lnum")],
     _V_=[0,caml_string_of_jsbytes("pos_fname")],
     _Y_=[0,0],
     _W_=[0,caml_string_of_jsbytes("Ok")],
     _X_=[0,caml_string_of_jsbytes("Error")],
     _aa_=
      [0,
       [11,caml_string_of_jsbytes("Negative position: "),[4,0,0,0,0]],
       caml_string_of_jsbytes("Negative position: %d")],
     _ab_=
      [0,
       [11,caml_string_of_jsbytes("Negative length: "),[4,0,0,0,0]],
       caml_string_of_jsbytes("Negative length: %d")],
     _ac_=
      [0,
       [11,
        caml_string_of_jsbytes("pos + len past end: "),
        [4,
         0,
         0,
         0,
         [11,
          caml_string_of_jsbytes(" + "),
          [4,0,0,0,[11,caml_string_of_jsbytes(" > "),[4,0,0,0,0]]]]]],
       caml_string_of_jsbytes("pos + len past end: %d + %d > %d")],
     _af_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _ae_=
      [0,
       [11,
        caml_string_of_jsbytes("Random."),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(": crossed bounds ["),
          [2,0,[11,caml_string_of_jsbytes(" > "),[2,0,[12,93,0]]]]]]],
       caml_string_of_jsbytes("Random.%s: crossed bounds [%s > %s]")],
     _ah_=[0,caml_string_of_jsbytes("Less")],
     _ai_=[0,caml_string_of_jsbytes("Equal")],
     _aj_=[0,caml_string_of_jsbytes("Greater")],
     _aC_=
      [0,
       caml_string_of_jsbytes
        ("list.ml.Transpose_got_lists_of_different_lengths")],
     _aD_=[0,caml_string_of_jsbytes("src/list.ml"),1301,13],
     _aA_=
      [0,
       [11,
        caml_string_of_jsbytes("List.chunks_of: Expected length > 0, got "),
        [4,0,0,0,0]],
       caml_string_of_jsbytes("List.chunks_of: Expected length > 0, got %d")],
     _ay_=[0,caml_string_of_jsbytes("src/list.ml"),1045,12],
     _ax_=[0,caml_string_of_jsbytes("src/list.ml"),933,4],
     _aw_=
      [0,
       [11,caml_string_of_jsbytes("List.init "),[4,0,0,0,0]],
       caml_string_of_jsbytes("List.init %d")],
     _av_=[0,caml_string_of_jsbytes("src/list.ml"),661,14],
     _au_=
      [0,
       [11,
        caml_string_of_jsbytes("length mismatch in zip_exn: "),
        [4,0,0,0,[11,caml_string_of_jsbytes(" <> "),[4,0,0,0,0]]]],
       caml_string_of_jsbytes("length mismatch in zip_exn: %d <> %d")],
     _at_=[0,caml_string_of_jsbytes("src/list.ml"),528,11],
     _ao_=
      [0,
       [11,
        caml_string_of_jsbytes("length mismatch in "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(": "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(" <> "),
            [4,
             0,
             0,
             0,
             [11,
              caml_string_of_jsbytes(" || "),
              [4,0,0,0,[11,caml_string_of_jsbytes(" <> "),[4,0,0,0,0]]]]]]]]]],
       caml_string_of_jsbytes("length mismatch in %s: %d <> %d || %d <> %d")],
     _an_=
      [0,
       [11,
        caml_string_of_jsbytes("length mismatch in "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(": "),
          [4,0,0,0,[11,caml_string_of_jsbytes(" <> "),[4,0,0,0,0]]]]]],
       caml_string_of_jsbytes("length mismatch in %s: %d <> %d")],
     _am_=
      [0,
       [11,
        caml_string_of_jsbytes("List.nth_exn "),
        [4,
         0,
         0,
         0,
         [11,caml_string_of_jsbytes(" called on list of length "),[4,0,0,0,0]]]],
       caml_string_of_jsbytes("List.nth_exn %d called on list of length %d")],
     _ak_=[0,caml_string_of_jsbytes("Ok")],
     _al_=[0,caml_string_of_jsbytes("Unequal_lengths")],
     _ap_=[0,caml_string_of_jsbytes("List.find_map_exn: not found")],
     _aq_=[0,caml_string_of_jsbytes("List.find_exn: not found")],
     _ar_=[0,caml_string_of_jsbytes("List.findi_exn: not found")],
     _as_=[0,caml_string_of_jsbytes("List.find_mapi_exn: not found")],
     _az_=[0,caml_string_of_jsbytes("List.Assoc.find_exn: not found")],
     _aQ_=[0,caml_string_of_jsbytes("src/info.ml"),204,6],
     _aF_=[0,caml_string_of_jsbytes("Could_not_construct")],
     _aG_=[0,caml_string_of_jsbytes("String")],
     _aH_=[0,caml_string_of_jsbytes("Exn")],
     _aI_=[0,caml_string_of_jsbytes("Sexp")],
     _aJ_=[0,caml_string_of_jsbytes("Tag_sexp")],
     _aK_=[0,caml_string_of_jsbytes("Tag_t")],
     _aL_=[0,caml_string_of_jsbytes("Tag_arg")],
     _aM_=[0,caml_string_of_jsbytes("Of_list")],
     _aN_=[0,caml_string_of_jsbytes("With_backtrace")],
     _aO_=
      [0,
       [11,
        caml_string_of_jsbytes("and "),
        [4,0,0,0,[11,caml_string_of_jsbytes(" more info"),0]]],
       caml_string_of_jsbytes("and %d more info")],
     _aS_=[0,caml_string_of_jsbytes("src/or_error.ml"),135,22],
     _aR_=[0,3553398],
     _aT_=[0,caml_string_of_jsbytes("Neg")],
     _aU_=[0,caml_string_of_jsbytes("Zero")],
     _aV_=[0,caml_string_of_jsbytes("Pos")],
     _aX_=[0,caml_string_of_jsbytes("src/comparable.ml"),133,4],
     _aW_=[0,caml_string_of_jsbytes("src/comparable.ml"),47,4],
     _aZ_=[0,caml_string_of_jsbytes("_")],
     _bi_=[0,0],
     _bf_=[0,caml_string_of_jsbytes("Left")],
     _bg_=[0,caml_string_of_jsbytes("Right")],
     _bh_=[0,caml_string_of_jsbytes("Both")],
     _be_=[0,caml_string_of_jsbytes("src/sequence.ml"),259,14],
     _bd_=[0,0,0],
     _a$_=[0,caml_string_of_jsbytes("Done")],
     _ba_=[0,caml_string_of_jsbytes("Skip")],
     _bb_=[0,caml_string_of_jsbytes("Yield")],
     _bp_=[0,caml_string_of_jsbytes("src/array.ml"),858,8],
     _bm_=[0,caml_string_of_jsbytes("Array.find_exn: not found")],
     _bl_=[0,caml_string_of_jsbytes("Array.findi_exn: not found")],
     _bk_=
      [0,
       [11,
        caml_string_of_jsbytes("length mismatch in "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(": "),
          [4,0,0,0,[11,caml_string_of_jsbytes(" <> "),[4,0,0,0,0]]]]]],
       caml_string_of_jsbytes("length mismatch in %s: %d <> %d")],
     _bj_=[0,caml_string_of_jsbytes("src/array.ml"),435,14],
     _bn_=[0,caml_string_of_jsbytes("Array.find_map_exn: not found")],
     _bo_=[0,caml_string_of_jsbytes("Array.find_mapi_exn: not found")],
     _br_=[0,caml_string_of_jsbytes(">"),0],
     _bs_=[0,caml_string_of_jsbytes("")],
     _bq_=[0,caml_string_of_jsbytes("src/obj_array.ml"),11,18],
     _bu_=[0,caml_string_of_jsbytes("src/uniform_array.ml"),164,8],
     _bt_=[0,caml_string_of_jsbytes("src/uniform_array.ml"),71,18],
     _bB_=[0,caml_string_of_jsbytes("src/float0.ml"),170,4],
     _bA_=[0,caml_string_of_jsbytes("src/float0.ml"),174,4],
     _by_=runtime.caml_int64_create_lo_mi_hi(16777215,16777215,65535),
     _bz_=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     _bx_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _bw_=[0,runtime.caml_int64_create_lo_mi_hi(0,0,0)],
     _bv_=
      [0,
       [8,
        [0,0,0],
        0,
        0,
        [12,
         32,
         [12,
          37,
          [12,
           32,
           [8,
            [0,0,0],
            0,
            0,
            [11,
             caml_string_of_jsbytes
              (" in float0.ml: modulus should be positive"),
             0]]]]]],
       caml_string_of_jsbytes
        ("%f %% %f in float0.ml: modulus should be positive")],
     _bP_=
      [0,
       [11,
        caml_string_of_jsbytes("Char.get_digit_exn "),
        [1,[11,caml_string_of_jsbytes(": not a digit"),0]]],
       caml_string_of_jsbytes("Char.get_digit_exn %C: not a digit")],
     _bO_=[0,[1,0],caml_string_of_jsbytes("%C")],
     _bC_=
      [0,
       [11,caml_string_of_jsbytes("Char.of_string: "),[3,0,0]],
       caml_string_of_jsbytes("Char.of_string: %S")],
     _cl_=[0,caml_string_of_jsbytes("src/string.ml"),1587,2],
     _ck_=[0,caml_string_of_jsbytes("src/string.ml"),1573,19],
     _cj_=
      [0,
       [2,0,[11,caml_string_of_jsbytes(": out of bounds"),0]],
       caml_string_of_jsbytes("%s: out of bounds")],
     _ci_=[0,[3,0,0],caml_string_of_jsbytes("%S")],
     _ch_=
      [0,
       [11,
        caml_string_of_jsbytes("String.chop_suffix_exn "),
        [3,0,[12,32,[3,0,0]]]],
       caml_string_of_jsbytes("String.chop_suffix_exn %S %S")],
     _cg_=
      [0,
       [11,
        caml_string_of_jsbytes("String.chop_prefix_exn "),
        [3,0,[12,32,[3,0,0]]]],
       caml_string_of_jsbytes("String.chop_prefix_exn %S %S")],
     _cf_=[0,caml_string_of_jsbytes("src/string.ml"),765,17],
     _cc_=
      [0,
       [11,caml_string_of_jsbytes("String.init "),[4,0,0,0,0]],
       caml_string_of_jsbytes("String.init %d")],
     _b6_=
      [0,
       [11,
        caml_string_of_jsbytes("String.is_substring_at: invalid index "),
        [4,
         0,
         0,
         0,
         [11,caml_string_of_jsbytes(" for string of length "),[4,0,0,0,0]]]],
       caml_string_of_jsbytes
        ("String.is_substring_at: invalid index %d for string of length %d")],
     _bX_=[0,caml_string_of_jsbytes("kmp_array")],
     _bY_=[0,caml_string_of_jsbytes("case_sensitive")],
     _bZ_=[0,caml_string_of_jsbytes("pattern")],
     _bV_=[0,caml_string_of_jsbytes("case_sensitive")],
     _bW_=[0,caml_string_of_jsbytes("pattern")],
     _bR_=[0,caml_string_of_jsbytes("String.index_exn: not found")],
     _bS_=[0,caml_string_of_jsbytes("String.index_from_exn: not found")],
     _bT_=[0,caml_string_of_jsbytes("String.rindex_exn: not found")],
     _bU_=[0,caml_string_of_jsbytes("String.rindex_from_exn: not found")],
     _cd_=[0,caml_string_of_jsbytes("String.lsplit2_exn: not found")],
     _ce_=[0,caml_string_of_jsbytes("String.rsplit2_exn: not found")],
     _co_=[0,caml_string_of_jsbytes("src/bytes.ml"),128,2],
     _cn_=
      [0,
       [11,caml_string_of_jsbytes("Bytes.init "),[4,0,0,0,0]],
       caml_string_of_jsbytes("Bytes.init %d")],
     _cm_=[0,[3,0,0],caml_string_of_jsbytes("%S")],
     _cF_=
      [0,
       [2,0,[11,caml_string_of_jsbytes(".of_string: invalid input "),[3,0,0]]],
       caml_string_of_jsbytes("%s.of_string: invalid input %S")],
     _cp_=
      [0,
       [11,
        caml_string_of_jsbytes("conversion from "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(" to "),
          [2,
           0,
           [11,
            caml_string_of_jsbytes(" failed: "),
            [2,0,[11,caml_string_of_jsbytes(" is out of range"),0]]]]]]],
       caml_string_of_jsbytes
        ("conversion from %s to %s failed: %s is out of range")],
     _lB_=[0,caml_string_of_jsbytes("src/int_conversions.ml"),19,9],
     _lA_=[0,caml_string_of_jsbytes("src/int_conversions.ml"),75,9],
     _lz_=[0,caml_string_of_jsbytes("src/int_conversions.ml"),96,9],
     _ly_=[0,caml_string_of_jsbytes("src/int_conversions.ml"),148,9],
     _lx_=[0,caml_string_of_jsbytes("src/int_conversions.ml"),176,9],
     _cI_=
      [0,
       2147483647,
       2147483647,
       46340,
       1290,
       215,
       73,
       35,
       21,
       14,
       10,
       8,
       7,
       5,
       5,
       4,
       4,
       3,
       3,
       3,
       3,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1],
     _lv_=[0,caml_string_of_jsbytes("src/pow_overflow_bounds.ml"),218,9],
     _cJ_=runtime.caml_int64_create_lo_mi_hi(16777215,127,0),
     _cK_=runtime.caml_int64_create_lo_mi_hi(16777215,16777215,16383),
     _cL_=runtime.caml_int64_create_lo_mi_hi(16777215,16777215,16383),
     _lw_=
      [0,
       1073741823,
       1073741823,
       32767,
       1023,
       181,
       63,
       31,
       19,
       13,
       10,
       7,
       6,
       5,
       4,
       4,
       3,
       3,
       3,
       3,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1],
     _cM_=
      [0,
       runtime.caml_int64_create_lo_mi_hi(16777215,16777215,16383),
       runtime.caml_int64_create_lo_mi_hi(16777215,16777215,16383),
       runtime.caml_int64_create_lo_mi_hi(16777215,127,0),
       runtime.caml_int64_create_lo_mi_hi(1664510,0,0),
       runtime.caml_int64_create_lo_mi_hi(46340,0,0),
       runtime.caml_int64_create_lo_mi_hi(5404,0,0),
       runtime.caml_int64_create_lo_mi_hi(1290,0,0),
       runtime.caml_int64_create_lo_mi_hi(463,0,0),
       runtime.caml_int64_create_lo_mi_hi(215,0,0),
       runtime.caml_int64_create_lo_mi_hi(118,0,0),
       runtime.caml_int64_create_lo_mi_hi(73,0,0),
       runtime.caml_int64_create_lo_mi_hi(49,0,0),
       runtime.caml_int64_create_lo_mi_hi(35,0,0),
       runtime.caml_int64_create_lo_mi_hi(27,0,0),
       runtime.caml_int64_create_lo_mi_hi(21,0,0),
       runtime.caml_int64_create_lo_mi_hi(17,0,0),
       runtime.caml_int64_create_lo_mi_hi(14,0,0),
       runtime.caml_int64_create_lo_mi_hi(12,0,0),
       runtime.caml_int64_create_lo_mi_hi(10,0,0),
       runtime.caml_int64_create_lo_mi_hi(9,0,0),
       runtime.caml_int64_create_lo_mi_hi(8,0,0),
       runtime.caml_int64_create_lo_mi_hi(7,0,0),
       runtime.caml_int64_create_lo_mi_hi(7,0,0),
       runtime.caml_int64_create_lo_mi_hi(6,0,0),
       runtime.caml_int64_create_lo_mi_hi(5,0,0),
       runtime.caml_int64_create_lo_mi_hi(5,0,0),
       runtime.caml_int64_create_lo_mi_hi(5,0,0),
       runtime.caml_int64_create_lo_mi_hi(4,0,0),
       runtime.caml_int64_create_lo_mi_hi(4,0,0),
       runtime.caml_int64_create_lo_mi_hi(4,0,0),
       runtime.caml_int64_create_lo_mi_hi(4,0,0),
       runtime.caml_int64_create_lo_mi_hi(3,0,0),
       runtime.caml_int64_create_lo_mi_hi(3,0,0),
       runtime.caml_int64_create_lo_mi_hi(3,0,0),
       runtime.caml_int64_create_lo_mi_hi(3,0,0),
       runtime.caml_int64_create_lo_mi_hi(3,0,0),
       runtime.caml_int64_create_lo_mi_hi(3,0,0),
       runtime.caml_int64_create_lo_mi_hi(3,0,0),
       runtime.caml_int64_create_lo_mi_hi(3,0,0),
       runtime.caml_int64_create_lo_mi_hi(3,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(1,0,0),
       runtime.caml_int64_create_lo_mi_hi(1,0,0)],
     _cN_=
      [0,
       runtime.caml_int64_create_lo_mi_hi(16777215,16777215,32767),
       runtime.caml_int64_create_lo_mi_hi(16777215,16777215,32767),
       runtime.caml_int64_create_lo_mi_hi(324403,181,0),
       runtime.caml_int64_create_lo_mi_hi(2097151,0,0),
       runtime.caml_int64_create_lo_mi_hi(55108,0,0),
       runtime.caml_int64_create_lo_mi_hi(6208,0,0),
       runtime.caml_int64_create_lo_mi_hi(1448,0,0),
       runtime.caml_int64_create_lo_mi_hi(511,0,0),
       runtime.caml_int64_create_lo_mi_hi(234,0,0),
       runtime.caml_int64_create_lo_mi_hi(127,0,0),
       runtime.caml_int64_create_lo_mi_hi(78,0,0),
       runtime.caml_int64_create_lo_mi_hi(52,0,0),
       runtime.caml_int64_create_lo_mi_hi(38,0,0),
       runtime.caml_int64_create_lo_mi_hi(28,0,0),
       runtime.caml_int64_create_lo_mi_hi(22,0,0),
       runtime.caml_int64_create_lo_mi_hi(18,0,0),
       runtime.caml_int64_create_lo_mi_hi(15,0,0),
       runtime.caml_int64_create_lo_mi_hi(13,0,0),
       runtime.caml_int64_create_lo_mi_hi(11,0,0),
       runtime.caml_int64_create_lo_mi_hi(9,0,0),
       runtime.caml_int64_create_lo_mi_hi(8,0,0),
       runtime.caml_int64_create_lo_mi_hi(7,0,0),
       runtime.caml_int64_create_lo_mi_hi(7,0,0),
       runtime.caml_int64_create_lo_mi_hi(6,0,0),
       runtime.caml_int64_create_lo_mi_hi(6,0,0),
       runtime.caml_int64_create_lo_mi_hi(5,0,0),
       runtime.caml_int64_create_lo_mi_hi(5,0,0),
       runtime.caml_int64_create_lo_mi_hi(5,0,0),
       runtime.caml_int64_create_lo_mi_hi(4,0,0),
       runtime.caml_int64_create_lo_mi_hi(4,0,0),
       runtime.caml_int64_create_lo_mi_hi(4,0,0),
       runtime.caml_int64_create_lo_mi_hi(4,0,0),
       runtime.caml_int64_create_lo_mi_hi(3,0,0),
       runtime.caml_int64_create_lo_mi_hi(3,0,0),
       runtime.caml_int64_create_lo_mi_hi(3,0,0),
       runtime.caml_int64_create_lo_mi_hi(3,0,0),
       runtime.caml_int64_create_lo_mi_hi(3,0,0),
       runtime.caml_int64_create_lo_mi_hi(3,0,0),
       runtime.caml_int64_create_lo_mi_hi(3,0,0),
       runtime.caml_int64_create_lo_mi_hi(3,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(2,0,0),
       runtime.caml_int64_create_lo_mi_hi(1,0,0)],
     _cO_=
      [0,
       runtime.caml_int64_create_lo_mi_hi(1,0,32768),
       runtime.caml_int64_create_lo_mi_hi(1,0,32768),
       runtime.caml_int64_create_lo_mi_hi(16452813,16777034,65535),
       runtime.caml_int64_create_lo_mi_hi(14680065,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16722108,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16771008,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16775768,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16776705,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16776982,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777089,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777138,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777164,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777178,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777188,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777194,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777198,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777201,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777203,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777205,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777207,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777208,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777209,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777209,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777210,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777210,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777211,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777211,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777211,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777212,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777212,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777212,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777212,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777213,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777213,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777213,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777213,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777213,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777213,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777213,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777213,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777214,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777214,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777214,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777214,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777214,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777214,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777214,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777214,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777214,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777214,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777214,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777214,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777214,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777214,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777214,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777214,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777214,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777214,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777214,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777214,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777214,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777214,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777214,16777215,65535),
       runtime.caml_int64_create_lo_mi_hi(16777215,16777215,65535)],
     _c1_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes(" /"),
         [12,
          37,
          [12,
           32,
           [2,
            0,
            [11,
             caml_string_of_jsbytes
              (" in core_int.ml: divisor should be positive"),
             0]]]]]],
       caml_string_of_jsbytes
        ("%s /%% %s in core_int.ml: divisor should be positive")],
     _c0_=
      [0,
       [2,
        0,
        [12,
         32,
         [12,
          37,
          [12,
           32,
           [2,
            0,
            [11,
             caml_string_of_jsbytes
              (" in core_int.ml: modulus should be positive"),
             0]]]]]],
       caml_string_of_jsbytes
        ("%s %% %s in core_int.ml: modulus should be positive")],
     _cX_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _cY_=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     _cZ_=runtime.caml_int64_create_lo_mi_hi(63,0,0),
     _cR_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _cS_=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     _cW_=runtime.caml_int64_create_lo_mi_hi(16777215,16777215,65535),
     _cT_=runtime.caml_int64_create_lo_mi_hi(63,0,0),
     _cU_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _cV_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _cQ_=
      [0,
       [11,caml_string_of_jsbytes("integer overflow in pow"),0],
       caml_string_of_jsbytes("integer overflow in pow")],
     _cP_=
      [0,
       [11,caml_string_of_jsbytes("exponent can not be negative"),0],
       caml_string_of_jsbytes("exponent can not be negative")],
     _lu_=[0,caml_string_of_jsbytes("src/popcount.ml"),45,9],
     _dm_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes(" /"),
         [12,
          37,
          [12,
           32,
           [2,
            0,
            [11,
             caml_string_of_jsbytes
              (" in core_int.ml: divisor should be positive"),
             0]]]]]],
       caml_string_of_jsbytes
        ("%s /%% %s in core_int.ml: divisor should be positive")],
     _dl_=
      [0,
       [2,
        0,
        [12,
         32,
         [12,
          37,
          [12,
           32,
           [2,
            0,
            [11,
             caml_string_of_jsbytes
              (" in core_int.ml: modulus should be positive"),
             0]]]]]],
       caml_string_of_jsbytes
        ("%s %% %s in core_int.ml: modulus should be positive")],
     _c$_=
      [0,
       [11,caml_string_of_jsbytes("argument must be strictly positive"),0],
       caml_string_of_jsbytes("argument must be strictly positive")],
     _c__=[0,caml_string_of_jsbytes("src/int.ml"),108,2],
     _c9_=[0,[4,6,0,0,0],caml_string_of_jsbytes("%x")],
     _c8_=[0,[4,6,0,0,0],caml_string_of_jsbytes("%x")],
     _c6_=
      [0,
       [11,
        caml_string_of_jsbytes("Int.of_float: argument ("),
        [8,
         [0,0,0],
         0,
         0,
         [11,caml_string_of_jsbytes(") is out of range or NaN"),0]]],
       caml_string_of_jsbytes
        ("Int.of_float: argument (%f) is out of range or NaN")],
     _c5_=
      [0,
       [11,caml_string_of_jsbytes("Int.of_string: "),[3,0,0]],
       caml_string_of_jsbytes("Int.of_string: %S")],
     _dt_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("Uchar.to_char_exn got a non latin-1 character: U+"),
        [4,8,[0,2,4],0,0]],
       caml_string_of_jsbytes
        ("Uchar.to_char_exn got a non latin-1 character: U+%04X")],
     _ds_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("Uchar.of_int_exn got a invalid Unicode scalar value: "),
        [4,8,[0,2,4],0,0]],
       caml_string_of_jsbytes
        ("Uchar.of_int_exn got a invalid Unicode scalar value: %04X")],
     _dr_=
      [0,
       [11,caml_string_of_jsbytes("Uchar.pred_exn: "),[2,0,0]],
       caml_string_of_jsbytes("Uchar.pred_exn: %s")],
     _dq_=
      [0,
       [11,caml_string_of_jsbytes("Uchar.succ_exn: "),[2,0,0]],
       caml_string_of_jsbytes("Uchar.succ_exn: %s")],
     _do_=
      [0,
       [11,caml_string_of_jsbytes("U+"),[4,8,0,0,0]],
       caml_string_of_jsbytes("U+%X")],
     _dn_=
      [0,
       [11,caml_string_of_jsbytes("U+"),[4,8,[0,2,4],0,0]],
       caml_string_of_jsbytes("U+%04X")],
     _dx_=[0,caml_string_of_jsbytes("witness")],
     _dy_=[0,caml_string_of_jsbytes("name")],
     _dw_=[0,caml_string_of_jsbytes("type_witness")],
     _dv_=[0,0,0],
     _du_=[0,caml_string_of_jsbytes("T")],
     _dY_=[0,caml_string_of_jsbytes("src/stack.ml"),107,14],
     _dK_=[0,caml_string_of_jsbytes("src/stack.ml"),39,4],
     _dJ_=[0,caml_string_of_jsbytes("src/stack.ml"),46,6],
     _dH_=[0,caml_string_of_jsbytes("elts")],
     _dI_=[0,caml_string_of_jsbytes("length")],
     _dZ_=[0,caml_string_of_jsbytes("Neg")],
     _d0_=[0,caml_string_of_jsbytes("Zero")],
     _d1_=[0,caml_string_of_jsbytes("Pos")],
     _d2_=[0,caml_string_of_jsbytes("Nan")],
     _d9_=[0,caml_string_of_jsbytes("Below_lower_bound")],
     _d__=[0,caml_string_of_jsbytes("In_range")],
     _d$_=[0,caml_string_of_jsbytes("Above_upper_bound")],
     _d8_=[0,[1,[0,caml_string_of_jsbytes("Unbounded"),0]],0],
     _d5_=[0,caml_string_of_jsbytes("Unbounded")],
     _d6_=[0,caml_string_of_jsbytes("Incl")],
     _d7_=[0,caml_string_of_jsbytes("Excl")],
     _d4_=[0,0,0],
     _ek_=[0,caml_string_of_jsbytes("Unfinished")],
     _el_=[0,caml_string_of_jsbytes("Finished")],
     _ei_=[0,caml_string_of_jsbytes("Stop")],
     _ej_=[0,caml_string_of_jsbytes("Continue")],
     _eg_=[0,caml_string_of_jsbytes("Left")],
     _eh_=[0,caml_string_of_jsbytes("Right")],
     _ef_=[0,caml_string_of_jsbytes("Both")],
     _ed_=[0,caml_string_of_jsbytes("Unequal")],
     _ee_=[0,caml_string_of_jsbytes("Right")],
     _ec_=[0,caml_string_of_jsbytes("Left")],
     _ea_=[0,caml_string_of_jsbytes("Duplicate")],
     _eb_=[0,caml_string_of_jsbytes("Ok")],
     _eF_=[0,caml_string_of_jsbytes("_")],
     _eE_=[0,0],
     _eD_=[0,caml_string_of_jsbytes("src/set.ml"),1047,8],
     _eB_=[0,0,0],
     _eA_=[0,0,0,0],
     _ey_=
      [0,caml_string_of_jsbytes("set.ml.Tree0.Set_max_elt_exn_of_empty_set")],
     _ez_=[0,caml_string_of_jsbytes("src/set.ml"),309,15],
     _ev_=
      [0,caml_string_of_jsbytes("set.ml.Tree0.Set_min_elt_exn_of_empty_set")],
     _ew_=[0,caml_string_of_jsbytes("src/set.ml"),296,15],
     _em_=[0,caml_string_of_jsbytes("src/set.ml"),199,17],
     _en_=[0,caml_string_of_jsbytes("src/set.ml"),200,18],
     _eo_=[0,caml_string_of_jsbytes("src/set.ml"),206,21],
     _ep_=[0,caml_string_of_jsbytes("src/set.ml"),208,12],
     _eq_=[0,caml_string_of_jsbytes("src/set.ml"),214,17],
     _er_=[0,caml_string_of_jsbytes("src/set.ml"),215,18],
     _es_=[0,caml_string_of_jsbytes("src/set.ml"),221,21],
     _et_=[0,caml_string_of_jsbytes("src/set.ml"),223,12],
     _eC_=[0,caml_string_of_jsbytes("Set.choose_exn: empty set")],
     _eV_=[0,caml_string_of_jsbytes("src/queue.ml"),451,2],
     _eU_=[0,caml_string_of_jsbytes("src/queue.ml"),193,2],
     _eT_=[0,caml_string_of_jsbytes("src/queue.ml"),152,2],
     _eS_=[0,caml_string_of_jsbytes("src/queue.ml"),153,2],
     _eR_=[0,caml_string_of_jsbytes("src/queue.ml"),155,2],
     _eQ_=[0,caml_string_of_jsbytes("src/queue.ml"),156,2],
     _eP_=[0,caml_string_of_jsbytes("src/queue.ml"),157,2],
     _eO_=[0,caml_string_of_jsbytes("src/queue.ml"),158,2],
     _eN_=[0,caml_string_of_jsbytes("src/queue.ml"),159,2],
     _eM_=[0,caml_string_of_jsbytes("src/queue.ml"),165,9],
     _eL_=[0,caml_string_of_jsbytes("_")],
     _eG_=[0,caml_string_of_jsbytes("elts")],
     _eH_=[0,caml_string_of_jsbytes("length")],
     _eI_=[0,caml_string_of_jsbytes("mask")],
     _eJ_=[0,caml_string_of_jsbytes("front")],
     _eK_=[0,caml_string_of_jsbytes("num_mutations")],
     _eW_=[0,caml_string_of_jsbytes("src/nothing.ml"),6,25],
     _e3_=[0,caml_string_of_jsbytes("src/nativeint.ml"),202,2],
     _e2_=
      [0,
       [11,caml_string_of_jsbytes("argument must be strictly positive"),0],
       caml_string_of_jsbytes("argument must be strictly positive")],
     _e1_=
      [0,
       [11,
        caml_string_of_jsbytes("Nativeint.of_float: argument ("),
        [8,
         [0,0,0],
         0,
         0,
         [11,caml_string_of_jsbytes(") is out of range or NaN"),0]]],
       caml_string_of_jsbytes
        ("Nativeint.of_float: argument (%f) is out of range or NaN")],
     _eZ_=[0,[6,6,0,0,0],caml_string_of_jsbytes("%nx")],
     _eY_=[0,[6,6,0,0,0],caml_string_of_jsbytes("%nx")],
     _fu_=[0,caml_string_of_jsbytes("_")],
     _ft_=
      [0,
       caml_string_of_jsbytes("Map.Build_increasing.add: non-increasing key")],
     _fs_=[0,0,0],
     _fb_=[0,0,0,0],
     _fp_=[0,0],
     _fr_=[0,caml_string_of_jsbytes("src/map.ml"),1639,6],
     _fq_=[0,0],
     _fo_=[0,[0,0,0],[0,0,0]],
     _fn_=[0,0,0],
     _fm_=[0,0,0],
     _fl_=[0,0,0],
     _fk_=[0,0,0],
     _fj_=[0,0,0],
     _fh_=
      [0,caml_string_of_jsbytes("map.ml.Tree0.Map_max_elt_exn_of_empty_map")],
     _fi_=[0,caml_string_of_jsbytes("src/map.ml"),547,15],
     _fe_=
      [0,caml_string_of_jsbytes("map.ml.Tree0.Map_min_elt_exn_of_empty_map")],
     _ff_=[0,caml_string_of_jsbytes("src/map.ml"),534,15],
     _fc_=[0,caml_string_of_jsbytes("Map.find_exn: not found")],
     _fa_=[1,0],
     _e__=[0,caml_string_of_jsbytes("src/map.ml"),196,18],
     _e$_=[0,caml_string_of_jsbytes("src/map.ml"),210,18],
     _e8_=[0,caml_string_of_jsbytes("map.ml.Duplicate")],
     _e9_=[0,caml_string_of_jsbytes("src/map.ml"),67,11],
     _fA_=[0,[7,6,0,0,0],caml_string_of_jsbytes("%Lx")],
     _fz_=[0,[7,6,0,0,0],caml_string_of_jsbytes("%Lx")],
     _fy_=
      [0,
       [11,caml_string_of_jsbytes("argument must be strictly positive"),0],
       caml_string_of_jsbytes("argument must be strictly positive")],
     _fx_=[0,caml_string_of_jsbytes("src/int64.ml"),100,2],
     _fw_=
      [0,
       [11,
        caml_string_of_jsbytes("Int64.of_float: argument ("),
        [8,
         [0,0,0],
         0,
         0,
         [11,caml_string_of_jsbytes(") is out of range or NaN"),0]]],
       caml_string_of_jsbytes
        ("Int64.of_float: argument (%f) is out of range or NaN")],
     _fQ_=[0,[7,6,0,0,0],caml_string_of_jsbytes("%Lx")],
     _fP_=[0,caml_string_of_jsbytes("src/int63_emul.ml"),317,2],
     _fN_=
      [0,
       [11,
        caml_string_of_jsbytes("Int63.of_float: argument ("),
        [8,
         [0,0,0],
         0,
         0,
         [11,caml_string_of_jsbytes(") is out of range or NaN"),0]]],
       caml_string_of_jsbytes
        ("Int63.of_float: argument (%f) is out of range or NaN")],
     _fM_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _fL_=
      [0,
       [11,caml_string_of_jsbytes("Int63.of_string: invalid input "),[3,0,0]],
       caml_string_of_jsbytes("Int63.of_string: invalid input %S")],
     _fI_=[0,caml_string_of_jsbytes("src/int63_emul.ml"),114,20],
     _fH_=runtime.caml_int64_create_lo_mi_hi(2,0,0),
     _fG_=runtime.caml_int64_create_lo_mi_hi(2,0,0),
     _fF_=runtime.caml_int64_create_lo_mi_hi(2,0,0),
     _fE_=runtime.caml_int64_create_lo_mi_hi(2,0,0),
     _fJ_=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     _f2_=[0,caml_string_of_jsbytes("src/bool.ml"),56,2],
     _f1_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("Bool.of_string: expected true or false but got "),
        [2,0,0]],
       caml_string_of_jsbytes
        ("Bool.of_string: expected true or false but got %s")],
     _f8_=[0,[5,6,0,0,0],caml_string_of_jsbytes("%lx")],
     _f7_=[0,[5,6,0,0,0],caml_string_of_jsbytes("%lx")],
     _f6_=
      [0,
       [11,caml_string_of_jsbytes("argument must be strictly positive"),0],
       caml_string_of_jsbytes("argument must be strictly positive")],
     _f5_=[0,caml_string_of_jsbytes("src/int32.ml"),97,4],
     _f4_=
      [0,
       [11,
        caml_string_of_jsbytes("Int32.of_float: argument ("),
        [8,
         [0,0,0],
         0,
         0,
         [11,caml_string_of_jsbytes(") is out of range or NaN"),0]]],
       caml_string_of_jsbytes
        ("Int32.of_float: argument (%f) is out of range or NaN")],
     _kL_=[0,caml_string_of_jsbytes("src/int63.ml"),155,9],
     _h5_=[0,caml_string_of_jsbytes("src/avltree.ml"),417,15],
     _h6_=[0,caml_string_of_jsbytes("src/avltree.ml"),436,18],
     _h4_=[0,caml_string_of_jsbytes("src/avltree.ml"),205,9],
     _h3_=[0,caml_string_of_jsbytes("src/avltree.ml"),193,9],
     _h0_=[0,caml_string_of_jsbytes("src/avltree.ml"),129,30],
     _hZ_=[0,caml_string_of_jsbytes("src/avltree.ml"),110,26],
     _h2_=[0,caml_string_of_jsbytes("src/avltree.ml"),163,30],
     _h1_=[0,caml_string_of_jsbytes("src/avltree.ml"),145,26],
     _hY_=[0,caml_string_of_jsbytes("src/avltree.ml"),87,22],
     _hX_=[0,caml_string_of_jsbytes("src/avltree.ml"),66,6],
     _hW_=[0,caml_string_of_jsbytes("src/avltree.ml"),67,6],
     _hV_=[0,caml_string_of_jsbytes("src/avltree.ml"),56,6],
     _hU_=[0,caml_string_of_jsbytes("src/avltree.ml"),50,6],
     _h9_=[0,caml_string_of_jsbytes("src/hashtbl.ml"),575,4],
     _h8_=[0,caml_string_of_jsbytes("Hashtbl.find_exn: not found")],
     _h7_=[0,caml_string_of_jsbytes("src/hashtbl.ml"),323,2],
     _ic_=[0,0],
     _ib_=[0,0],
     _ia_=[0,0],
     _iS_=[0,[8,[0,0,4],0,[0,8],0],caml_string_of_jsbytes("%.8G")],
     _iQ_=
      [0,
       [11,
        caml_string_of_jsbytes("exponent "),
        [4,
         0,
         0,
         0,
         [11,caml_string_of_jsbytes(" out of range [0, "),[4,0,0,0,[12,93,0]]]]],
       caml_string_of_jsbytes("exponent %d out of range [0, %d]")],
     _iR_=
      [0,
       [11,
        caml_string_of_jsbytes("mantissa "),
        [2,
         0,
         [11,caml_string_of_jsbytes(" out of range [0, "),[2,0,[12,93,0]]]]],
       caml_string_of_jsbytes("mantissa %s out of range [0, %s]")],
     _iP_=[0,caml_string_of_jsbytes("src/float.ml"),859,2],
     _iO_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("Float.round_significant: invalid argument significant_digits:"),
        [4,0,0,0,0]],
       caml_string_of_jsbytes
        ("Float.round_significant: invalid argument significant_digits:%d")],
     _iN_=[0,[8,[0,0,3],0,1,0],caml_string_of_jsbytes("%.*g")],
     _iM_=[0,caml_string_of_jsbytes("p")],
     _iJ_=[0,caml_string_of_jsbytes("src/float.ml"),697,8],
     _iI_=[0,caml_string_of_jsbytes("src/float.ml"),700,8],
     _iE_=[0,caml_string_of_jsbytes("src/float.ml"),707,8],
     _iF_=[0,caml_string_of_jsbytes("src/float.ml"),708,8],
     _iG_=
      [0,[2,0,[4,0,0,0,[2,0,[12,32,0]]]],caml_string_of_jsbytes("%s%d%s ")],
     _iH_=
      [0,[2,0,[4,0,0,0,[2,0,[4,0,0,0,0]]]],caml_string_of_jsbytes("%s%d%s%d")],
     _iD_=[0,caml_string_of_jsbytes("src/float.ml"),684,8],
     _iK_=[0,[2,0,[8,[0,0,1],0,[0,1],0]],caml_string_of_jsbytes("%s%.1e")],
     _iL_=[0,[2,0,[8,[0,0,1],0,[0,1],0]],caml_string_of_jsbytes("%s%.1e")],
     _iA_=
      [0,
       [11,
        caml_string_of_jsbytes("to_string_hum: invalid argument ~decimals="),
        [4,0,0,0,0]],
       caml_string_of_jsbytes("to_string_hum: invalid argument ~decimals=%d")],
     _iB_=[0,[8,[0,1,0],0,1,0],caml_string_of_jsbytes("%+.*f")],
     _iC_=[0,[8,[0,0,0],0,1,0],caml_string_of_jsbytes("%.*f")],
     _iv_=[0,caml_string_of_jsbytes("Infinite")],
     _iw_=[0,caml_string_of_jsbytes("Nan")],
     _ix_=[0,caml_string_of_jsbytes("Normal")],
     _iy_=[0,caml_string_of_jsbytes("Subnormal")],
     _iz_=[0,caml_string_of_jsbytes("Zero")],
     _it_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("Float.int63_round_nearest_portable_alloc_exn: argument ("),
        [8,[0,0,0],0,0,[11,caml_string_of_jsbytes(") is too large"),0]]],
       caml_string_of_jsbytes
        ("Float.int63_round_nearest_portable_alloc_exn: argument (%f) is too large")],
     _iu_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("Float.int63_round_nearest_portable_alloc_exn: argument ("),
        [8,[0,0,0],0,0,[11,caml_string_of_jsbytes(") is too small or NaN"),0]]],
       caml_string_of_jsbytes
        ("Float.int63_round_nearest_portable_alloc_exn: argument (%f) is too small or NaN")],
     _ir_=
      [0,
       [11,
        caml_string_of_jsbytes("Float.int63_round_down_exn: argument ("),
        [8,[0,0,0],0,0,[11,caml_string_of_jsbytes(") is too large"),0]]],
       caml_string_of_jsbytes
        ("Float.int63_round_down_exn: argument (%f) is too large")],
     _is_=
      [0,
       [11,
        caml_string_of_jsbytes("Float.int63_round_down_exn: argument ("),
        [8,[0,0,0],0,0,[11,caml_string_of_jsbytes(") is too small or NaN"),0]]],
       caml_string_of_jsbytes
        ("Float.int63_round_down_exn: argument (%f) is too small or NaN")],
     _ip_=
      [0,
       [11,
        caml_string_of_jsbytes("Float.int63_round_up_exn: argument ("),
        [8,[0,0,0],0,0,[11,caml_string_of_jsbytes(") is too large"),0]]],
       caml_string_of_jsbytes
        ("Float.int63_round_up_exn: argument (%f) is too large")],
     _iq_=
      [0,
       [11,
        caml_string_of_jsbytes("Float.int63_round_up_exn: argument ("),
        [8,[0,0,0],0,0,[11,caml_string_of_jsbytes(") is too small or NaN"),0]]],
       caml_string_of_jsbytes
        ("Float.int63_round_up_exn: argument (%f) is too small or NaN")],
     _in_=
      [0,
       [11,
        caml_string_of_jsbytes("Float.iround_nearest_exn: argument ("),
        [8,[0,0,0],0,0,[11,caml_string_of_jsbytes(") is too large"),0]]],
       caml_string_of_jsbytes
        ("Float.iround_nearest_exn: argument (%f) is too large")],
     _io_=
      [0,
       [11,
        caml_string_of_jsbytes("Float.iround_nearest_exn: argument ("),
        [8,[0,0,0],0,0,[11,caml_string_of_jsbytes(") is too small or NaN"),0]]],
       caml_string_of_jsbytes
        ("Float.iround_nearest_exn: argument (%f) is too small or NaN")],
     _il_=
      [0,
       [11,
        caml_string_of_jsbytes("Float.iround_nearest_exn: argument ("),
        [8,[0,0,0],0,0,[11,caml_string_of_jsbytes(") is too large"),0]]],
       caml_string_of_jsbytes
        ("Float.iround_nearest_exn: argument (%f) is too large")],
     _im_=
      [0,
       [11,
        caml_string_of_jsbytes("Float.iround_nearest_exn: argument ("),
        [8,[0,0,0],0,0,[11,caml_string_of_jsbytes(") is too small"),0]]],
       caml_string_of_jsbytes
        ("Float.iround_nearest_exn: argument (%f) is too small")],
     _ik_=
      [0,
       [11,
        caml_string_of_jsbytes("Float.iround_towards_zero_exn: argument ("),
        [8,
         [0,0,0],
         0,
         0,
         [11,caml_string_of_jsbytes(") is out of range or NaN"),0]]],
       caml_string_of_jsbytes
        ("Float.iround_towards_zero_exn: argument (%f) is out of range or NaN")],
     _ii_=
      [0,
       [11,
        caml_string_of_jsbytes("Float.iround_down_exn: argument ("),
        [8,[0,0,0],0,0,[11,caml_string_of_jsbytes(") is too large"),0]]],
       caml_string_of_jsbytes
        ("Float.iround_down_exn: argument (%f) is too large")],
     _ij_=
      [0,
       [11,
        caml_string_of_jsbytes("Float.iround_down_exn: argument ("),
        [8,[0,0,0],0,0,[11,caml_string_of_jsbytes(") is too small or NaN"),0]]],
       caml_string_of_jsbytes
        ("Float.iround_down_exn: argument (%f) is too small or NaN")],
     _ig_=
      [0,
       [11,
        caml_string_of_jsbytes("Float.iround_up_exn: argument ("),
        [8,[0,0,0],0,0,[11,caml_string_of_jsbytes(") is too large"),0]]],
       caml_string_of_jsbytes
        ("Float.iround_up_exn: argument (%f) is too large")],
     _ih_=
      [0,
       [11,
        caml_string_of_jsbytes("Float.iround_up_exn: argument ("),
        [8,[0,0,0],0,0,[11,caml_string_of_jsbytes(") is too small or NaN"),0]]],
       caml_string_of_jsbytes
        ("Float.iround_up_exn: argument (%f) is too small or NaN")],
     _if_=
      [0,
       [11,caml_string_of_jsbytes("Float.of_string "),[2,0,0]],
       caml_string_of_jsbytes("Float.of_string %s")];
    function descending(x,y){return caml_compare(y,x)}
    var
     max=Caml[17],
     min=Caml[16],
     ascending=caml_compare,
     include=[0,ascending,descending,min,max];
    caml_register_global(972,include,"Base__Poly0");
    var
     Exit=include$0[3],
     Not_found=include$0[4],
     max_int=include$0[8],
     min_int=include$0[9],
     infinity=include$0[11],
     neg_infinity=include$0[12],
     nan=include$0[13],
     max_float=include$0[14],
     min_float=include$0[15],
     epsilon_float=include$0[16],
     char_of_int=include$0[18],
     string_of_bool=include$0[19],
     bool_of_string_opt=include$0[20],
     bool_of_string=include$0[21],
     string_of_int=include$0[22],
     int_of_string_opt=include$0[23],
     string_of_float=include$0[24],
     float_of_string_opt=include$0[25],
     stdin=include$0[27],
     stdout=include$0[28],
     stderr=include$0[29],
     print_char=include$0[30],
     print_string=include$0[31],
     print_bytes=include$0[32],
     print_int=include$0[33],
     print_float=include$0[34],
     print_endline=include$0[35],
     print_newline=include$0[36],
     prerr_char=include$0[37],
     prerr_string=include$0[38],
     prerr_bytes=include$0[39],
     prerr_int=include$0[40],
     prerr_float=include$0[41],
     prerr_endline=include$0[42],
     prerr_newline=include$0[43],
     read_line=include$0[44],
     read_int_opt=include$0[45],
     read_int=include$0[46],
     read_float_opt=include$0[47],
     read_float=include$0[48],
     open_out=include$0[49],
     open_out_bin=include$0[50],
     open_out_gen=include$0[51],
     flush=include$0[52],
     flush_all=include$0[53],
     output_char=include$0[54],
     output_string=include$0[55],
     output_bytes=include$0[56],
     output=include$0[57],
     output_substring=include$0[58],
     output_byte=include$0[59],
     output_binary_int=include$0[60],
     output_value=include$0[61],
     seek_out=include$0[62],
     pos_out=include$0[63],
     out_channel_length=include$0[64],
     close_out=include$0[65],
     close_out_noerr=include$0[66],
     set_binary_mode_out=include$0[67],
     open_in=include$0[68],
     open_in_bin=include$0[69],
     open_in_gen=include$0[70],
     input_char=include$0[71],
     input_line=include$0[72],
     input=include$0[73],
     really_input=include$0[74],
     really_input_string=include$0[75],
     input_byte=include$0[76],
     input_binary_int=include$0[77],
     input_value=include$0[78],
     seek_in=include$0[79],
     pos_in=include$0[80],
     in_channel_length=include$0[81],
     close_in=include$0[82],
     close_in_noerr=include$0[83],
     set_binary_mode_in=include$0[84],
     string_of_format=include$0[85],
     symbol=include$0[86],
     exit=include$0[87],
     at_exit=include$0[88],
     valid_float_lexem=include$0[89],
     unsafe_really_input=include$0[90],
     do_at_exit=include$0[91],
     invalid_arg=Caml[1],
     failwith=Caml[2],
     Exit$0=Caml[3],
     Match_failure=Caml[4],
     Assert_failure=Caml[5],
     Invalid_argument=Caml[6],
     Failure=Caml[7],
     Out_of_memory=Caml[9],
     Stack_overflow=Caml[10],
     Sys_error=Caml[11],
     End_of_file=Caml[12],
     Division_by_zero=Caml[13],
     Sys_blocked_io=Caml[14],
     Undefined_recursive_module=Caml[15],
     min$0=Caml[16],
     max$0=Caml[17],
     abs=Caml[18],
     max_int$0=Caml[19],
     min_int$0=Caml[20],
     lnot=Caml[21],
     infinity$0=Caml[22],
     neg_infinity$0=Caml[23],
     nan$0=Caml[24],
     max_float$0=Caml[25],
     min_float$0=Caml[26],
     epsilon_float$0=Caml[27],
     symbol$0=Caml[28],
     char_of_int$0=Caml[29],
     string_of_bool$0=Caml[30],
     bool_of_string_opt$0=Caml[31],
     bool_of_string$0=Caml[32],
     string_of_int$0=Caml[33],
     int_of_string_opt$0=Caml[34],
     string_of_float$0=Caml[35],
     float_of_string_opt$0=Caml[36],
     symbol$1=Caml[37],
     stdin$0=Caml[38],
     stdout$0=Caml[39],
     stderr$0=Caml[40],
     print_char$0=Caml[41],
     print_string$0=Caml[42],
     print_bytes$0=Caml[43],
     print_int$0=Caml[44],
     print_float$0=Caml[45],
     print_endline$0=Caml[46],
     print_newline$0=Caml[47],
     prerr_char$0=Caml[48],
     prerr_string$0=Caml[49],
     prerr_bytes$0=Caml[50],
     prerr_int$0=Caml[51],
     prerr_float$0=Caml[52],
     prerr_endline$0=Caml[53],
     prerr_newline$0=Caml[54],
     read_line$0=Caml[55],
     read_int_opt$0=Caml[56],
     read_int$0=Caml[57],
     read_float_opt$0=Caml[58],
     read_float$0=Caml[59],
     open_out$0=Caml[60],
     open_out_bin$0=Caml[61],
     open_out_gen$0=Caml[62],
     flush$0=Caml[63],
     flush_all$0=Caml[64],
     output_char$0=Caml[65],
     output_string$0=Caml[66],
     output_bytes$0=Caml[67],
     output$0=Caml[68],
     output_substring$0=Caml[69],
     output_byte$0=Caml[70],
     output_binary_int$0=Caml[71],
     output_value$0=Caml[72],
     seek_out$0=Caml[73],
     pos_out$0=Caml[74],
     out_channel_length$0=Caml[75],
     close_out$0=Caml[76],
     close_out_noerr$0=Caml[77],
     set_binary_mode_out$0=Caml[78],
     open_in$0=Caml[79],
     open_in_bin$0=Caml[80],
     open_in_gen$0=Caml[81],
     input_char$0=Caml[82],
     input_line$0=Caml[83],
     input$0=Caml[84],
     really_input$0=Caml[85],
     really_input_string$0=Caml[86],
     input_byte$0=Caml[87],
     input_binary_int$0=Caml[88],
     input_value$0=Caml[89],
     seek_in$0=Caml[90],
     pos_in$0=Caml[91],
     in_channel_length$0=Caml[92],
     close_in$0=Caml[93],
     close_in_noerr$0=Caml[94],
     set_binary_mode_in$0=Caml[95],
     LargeFile=Caml[96],
     string_of_format$0=Caml[97],
     symbol$2=Caml[98],
     exit$0=Caml[99],
     at_exit$0=Caml[100],
     valid_float_lexem$0=Caml[101],
     unsafe_really_input$0=Caml[102],
     do_at_exit$0=Caml[103],
     Not_found$0=Caml[8],
     Caml$0=
      [0,
       invalid_arg,
       failwith,
       Exit$0,
       Match_failure,
       Assert_failure,
       Invalid_argument,
       Failure,
       Out_of_memory,
       Stack_overflow,
       Sys_error,
       End_of_file,
       Division_by_zero,
       Sys_blocked_io,
       Undefined_recursive_module,
       min$0,
       max$0,
       abs,
       max_int$0,
       min_int$0,
       lnot,
       infinity$0,
       neg_infinity$0,
       nan$0,
       max_float$0,
       min_float$0,
       epsilon_float$0,
       symbol$0,
       char_of_int$0,
       string_of_bool$0,
       bool_of_string_opt$0,
       bool_of_string$0,
       string_of_int$0,
       int_of_string_opt$0,
       string_of_float$0,
       float_of_string_opt$0,
       symbol$1,
       stdin$0,
       stdout$0,
       stderr$0,
       print_char$0,
       print_string$0,
       print_bytes$0,
       print_int$0,
       print_float$0,
       print_endline$0,
       print_newline$0,
       prerr_char$0,
       prerr_string$0,
       prerr_bytes$0,
       prerr_int$0,
       prerr_float$0,
       prerr_endline$0,
       prerr_newline$0,
       read_line$0,
       read_int_opt$0,
       read_int$0,
       read_float_opt$0,
       read_float$0,
       open_out$0,
       open_out_bin$0,
       open_out_gen$0,
       flush$0,
       flush_all$0,
       output_char$0,
       output_string$0,
       output_bytes$0,
       output$0,
       output_substring$0,
       output_byte$0,
       output_binary_int$0,
       output_value$0,
       seek_out$0,
       pos_out$0,
       out_channel_length$0,
       close_out$0,
       close_out_noerr$0,
       set_binary_mode_out$0,
       open_in$0,
       open_in_bin$0,
       open_in_gen$0,
       input_char$0,
       input_line$0,
       input$0,
       really_input$0,
       really_input_string$0,
       input_byte$0,
       input_binary_int$0,
       input_value$0,
       seek_in$0,
       pos_in$0,
       in_channel_length$0,
       close_in$0,
       close_in_noerr$0,
       set_binary_mode_in$0,
       LargeFile,
       string_of_format$0,
       symbol$2,
       exit$0,
       at_exit$0,
       valid_float_lexem$0,
       unsafe_really_input$0,
       do_at_exit$0,
       Not_found$0];
    function bool_to_int(x){return x}
    function symbol$3(_NC_,_NB_){return _NC_ !== _NB_?1:0}
    var symbol$4=caml_mul;
    function symbol$5(_NA_,_Nz_){return Math.pow(_NA_,_Nz_)}
    function scale(_Ny_,_Nx_){return _Ny_ * _Nx_}
    function symbol$6(_Nw_,_Nv_){return _Nw_ + _Nv_ | 0}
    function add(_Nu_,_Nt_){return _Nu_ + _Nt_}
    function symbol$7(_Ns_,_Nr_){return _Ns_ - _Nr_ | 0}
    function sub(_Nq_,_Np_){return _Nq_ - _Np_}
    var symbol$8=caml_div;
    function symbol$9(_No_,_Nn_){return _No_ / _Nn_}
    var ascending$0=caml_int_compare;
    function descending$0(x,y){return caml_int_compare(y,x)}
    function max$1(x,y){return y <= x?x:y}
    function min$1(x,y){return x <= y?x:y}
    var
     include$1=[0,ascending$0,descending$0,max$1,min$1],
     _a_=include$1[1],
     _b_=include$1[2],
     max$2=include$1[3],
     min$2=include$1[4];
    function symbol$10(x,y){return caml_lessthan(x,y)}
    function symbol$11(x,y){return caml_lessequal(x,y)}
    function symbol$12(x,y){return caml_notequal(x,y)}
    function symbol$13(x,y){return caml_equal(x,y)}
    function symbol$14(x,y){return caml_greaterthan(x,y)}
    function symbol$15(x,y){return caml_greaterequal(x,y)}
    var ascending$1=caml_compare;
    function descending$1(x,y){return caml_compare(y,x)}
    function compare(x,y){return caml_int_compare(x,y)}
    function equal(x,y){return caml_equal(x,y)}
    function max$3(x,y){return caml_greaterequal(x,y)?x:y}
    function min$3(x,y){return caml_lessequal(x,y)?x:y}
    var
     Int32_replace_polymorphic_comp=
      [0,
       symbol$10,
       symbol$11,
       symbol$12,
       symbol$13,
       symbol$14,
       symbol$15,
       ascending$1,
       descending$1,
       compare,
       equal,
       max$3,
       min$3],
     ascending$2=caml_compare;
    function descending$2(x,y){return caml_compare(y,x)}
    function max$4(x,y){return caml_greaterequal(x,y)?x:y}
    function min$4(x,y){return caml_lessequal(x,y)?x:y}
    var include$2=[0,ascending$2,descending$2,max$4,min$4];
    function symbol$16(x,y){return caml_lessthan(x,y)}
    function symbol$17(x,y){return caml_lessequal(x,y)}
    function symbol$18(x,y){return caml_notequal(x,y)}
    function symbol$19(x,y){return caml_equal(x,y)}
    function symbol$20(x,y){return caml_greaterthan(x,y)}
    function symbol$21(x,y){return caml_greaterequal(x,y)}
    var ascending$3=caml_compare;
    function descending$3(x,y){return caml_compare(y,x)}
    function compare$0(x,y){return caml_int_compare(x,y)}
    function equal$0(x,y){return caml_equal(x,y)}
    function max$5(x,y){return caml_greaterequal(x,y)?x:y}
    function min$5(x,y){return caml_lessequal(x,y)?x:y}
    var
     include$3=
      [0,
       symbol$16,
       symbol$17,
       symbol$18,
       symbol$19,
       symbol$20,
       symbol$21,
       ascending$3,
       descending$3,
       compare$0,
       equal$0,
       max$5,
       min$5];
    function symbol$22(x,y){return x < y?1:0}
    function symbol$23(x,y){return x <= y?1:0}
    function symbol$24(x,y){return x !== y?1:0}
    function symbol$25(x,y){return x === y?1:0}
    function symbol$26(x,y){return y < x?1:0}
    function symbol$27(x,y){return y <= x?1:0}
    var ascending$4=caml_compare;
    function descending$4(x,y){return caml_compare(y,x)}
    var compare$1=caml_int_compare;
    function equal$1(x,y){return x === y?1:0}
    function max$6(x,y){return y <= x?x:y}
    function min$6(x,y){return x <= y?x:y}
    var
     include$4=
      [0,
       symbol$22,
       symbol$23,
       symbol$24,
       symbol$25,
       symbol$26,
       symbol$27,
       ascending$4,
       descending$4,
       compare$1,
       equal$1,
       max$6,
       min$6];
    function symbol$28(x,y){return x < y?1:0}
    function symbol$29(x,y){return x <= y?1:0}
    function symbol$30(x,y){return x !== y?1:0}
    function symbol$31(x,y){return x === y?1:0}
    function symbol$32(x,y){return y < x?1:0}
    function symbol$33(x,y){return y <= x?1:0}
    var ascending$5=caml_compare;
    function descending$5(x,y){return caml_compare(y,x)}
    var compare$2=caml_int_compare;
    function equal$2(x,y){return x === y?1:0}
    function max$7(x,y){return y <= x?x:y}
    function min$7(x,y){return x <= y?x:y}
    var
     include$5=
      [0,
       symbol$28,
       symbol$29,
       symbol$30,
       symbol$31,
       symbol$32,
       symbol$33,
       ascending$5,
       descending$5,
       compare$2,
       equal$2,
       max$7,
       min$7];
    function i(x){return caml_call1(Stdlib_Uchar[10],x)}
    function symbol$34(x,y){var _Nm_=i(y);return i(x) < _Nm_?1:0}
    function symbol$35(x,y){var _Nl_=i(y);return i(x) <= _Nl_?1:0}
    function symbol$36(x,y){var _Nk_=i(y);return i(x) !== _Nk_?1:0}
    function symbol$37(x,y){var _Nj_=i(y);return i(x) === _Nj_?1:0}
    function symbol$38(x,y){var _Ni_=i(y);return _Ni_ < i(x)?1:0}
    function symbol$39(x,y){var _Nh_=i(y);return _Nh_ <= i(x)?1:0}
    function ascending$6(x,y)
     {var _Nf_=i(y),_Ng_=i(x);return caml_call2(include$1[1],_Ng_,_Nf_)}
    function descending$6(x,y)
     {var _Nd_=i(y),_Ne_=i(x);return caml_call2(include$1[2],_Ne_,_Nd_)}
    function compare$3(x,y){var _Nc_=i(y);return caml_int_compare(i(x),_Nc_)}
    function equal$3(x,y){var _Nb_=i(y);return i(x) === _Nb_?1:0}
    function max$8(x,y){return symbol$39(x,y)?x:y}
    function min$8(x,y){return symbol$35(x,y)?x:y}
    var
     include$6=
      [0,
       i,
       symbol$34,
       symbol$35,
       symbol$36,
       symbol$37,
       symbol$38,
       symbol$39,
       ascending$6,
       descending$6,
       compare$3,
       equal$3,
       max$8,
       min$8];
    function symbol$40(x,y){return x < y?1:0}
    function symbol$41(x,y){return x <= y?1:0}
    function symbol$42(x,y){return x != y?1:0}
    function symbol$43(x,y){return x == y?1:0}
    function symbol$44(x,y){return y < x?1:0}
    function symbol$45(x,y){return y <= x?1:0}
    var ascending$7=caml_compare;
    function descending$7(x,y){return caml_compare(y,x)}
    var compare$4=caml_float_compare;
    function equal$4(x,y){return x == y?1:0}
    function max$9(x,y){return y <= x?x:y}
    function min$9(x,y){return x <= y?x:y}
    var
     include$7=
      [0,
       symbol$40,
       symbol$41,
       symbol$42,
       symbol$43,
       symbol$44,
       symbol$45,
       ascending$7,
       descending$7,
       compare$4,
       equal$4,
       max$9,
       min$9];
    function symbol$46(x,y){return runtime.caml_string_lessthan(x,y)}
    function symbol$47(x,y){return caml_string_lessequal(x,y)}
    function symbol$48(x,y){return caml_string_notequal(x,y)}
    function symbol$49(x,y){return caml_string_equal(x,y)}
    function symbol$50(x,y){return runtime.caml_string_greaterthan(x,y)}
    function symbol$51(x,y){return caml_string_greaterequal(x,y)}
    var ascending$8=caml_compare;
    function descending$8(x,y){return caml_compare(y,x)}
    function compare$5(x,y){return caml_string_compare(x,y)}
    function equal$5(x,y){return caml_string_equal(x,y)}
    function max$10(x,y){return caml_string_greaterequal(x,y)?x:y}
    function min$10(x,y){return caml_string_lessequal(x,y)?x:y}
    var
     include$8=
      [0,
       symbol$46,
       symbol$47,
       symbol$48,
       symbol$49,
       symbol$50,
       symbol$51,
       ascending$8,
       descending$8,
       compare$5,
       equal$5,
       max$10,
       min$10];
    function symbol$52(x,y){return runtime.caml_bytes_lessthan(x,y)}
    function symbol$53(x,y){return caml_bytes_lessequal(x,y)}
    function symbol$54(x,y){return runtime.caml_bytes_notequal(x,y)}
    function symbol$55(x,y){return caml_bytes_equal(x,y)}
    function symbol$56(x,y){return runtime.caml_bytes_greaterthan(x,y)}
    function symbol$57(x,y){return caml_bytes_greaterequal(x,y)}
    var ascending$9=caml_compare;
    function descending$9(x,y){return caml_compare(y,x)}
    function compare$6(x,y){return runtime.caml_bytes_compare(x,y)}
    function equal$6(x,y){return caml_bytes_equal(x,y)}
    function max$11(x,y){return caml_bytes_greaterequal(x,y)?x:y}
    function min$11(x,y){return caml_bytes_lessequal(x,y)?x:y}
    var
     include$9=
      [0,
       symbol$52,
       symbol$53,
       symbol$54,
       symbol$55,
       symbol$56,
       symbol$57,
       ascending$9,
       descending$9,
       compare$6,
       equal$6,
       max$11,
       min$11],
     symbol$58=Caml$0[36],
     symbol$59=Caml$0[27];
    function neg(_Na_){return - _Na_ | 0}
    function neg$0(_M$_){return - _M$_}
    function asr(_M__,_M9_){return _M__ >> _M9_}
    function land(_M8_,_M7_){return _M8_ & _M7_}
    var lnot$0=Caml$0[20];
    function lor(_M6_,_M5_){return _M6_ | _M5_}
    function lsl(_M4_,_M3_){return _M4_ << _M3_}
    function lsr(_M2_,_M1_){return _M2_ >>> _M1_ | 0}
    function lxor(_M0_,_MZ_){return _M0_ ^ _MZ_}
    var mod=caml_mod,abs$0=Caml$0[17],failwith$0=Caml$0[2];
    function get_key(_MY_){return _MY_[1]}
    var invalid_arg$0=Caml$0[1];
    function get_data(_MX_){return _MX_[2]}
    function phys_equal(_MW_,_MV_){return _MW_ === _MV_?1:0}
    function decr(_MU_){_MU_[1] += -1;return 0}
    function incr(_MT_){_MT_[1]++;return 0}
    var
     float_of_string=caml_float_of_string,
     am_testing=runtime.Base_am_testing(0),
     Base_Import0=
      [0,
       Exit,
       Not_found,
       max_int,
       min_int,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon_float,
       char_of_int,
       string_of_bool,
       bool_of_string_opt,
       bool_of_string,
       string_of_int,
       int_of_string_opt,
       string_of_float,
       float_of_string_opt,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int_opt,
       read_int,
       read_float_opt,
       read_float,
       open_out,
       open_out_bin,
       open_out_gen,
       flush,
       flush_all,
       output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       output_byte,
       output_binary_int,
       output_value,
       seek_out,
       pos_out,
       out_channel_length,
       close_out,
       close_out_noerr,
       set_binary_mode_out,
       open_in,
       open_in_bin,
       open_in_gen,
       input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       input_byte,
       input_binary_int,
       input_value,
       seek_in,
       pos_in,
       in_channel_length,
       close_in,
       close_in_noerr,
       set_binary_mode_in,
       string_of_format,
       symbol,
       exit,
       at_exit,
       valid_float_lexem,
       unsafe_really_input,
       do_at_exit,
       Caml$0,
       bool_to_int,
       symbol$3,
       symbol$4,
       symbol$5,
       scale,
       symbol$6,
       add,
       symbol$7,
       sub,
       symbol$8,
       symbol$9,
       include$1,
       _a_,
       _b_,
       max$2,
       min$2,
       Int32_replace_polymorphic_comp,
       include$2,
       include$3,
       include$4,
       include$5,
       include$6,
       include$7,
       include$8,
       include$9,
       symbol$58,
       symbol$59,
       neg,
       neg$0,
       asr,
       land,
       lnot$0,
       lor,
       lsl,
       lsr,
       lxor,
       mod,
       abs$0,
       failwith$0,
       get_key,
       invalid_arg$0,
       get_data,
       phys_equal,
       decr,
       incr,
       float_of_string,
       am_testing];
    caml_register_global(975,Base_Import0,"Base__Import0");
    var
     sprintf=Stdlib_Printf[4],
     bprintf=Stdlib_Printf[5],
     ifprintf=Stdlib_Printf[6],
     ksprintf=Stdlib_Printf[10],
     kbprintf=Stdlib_Printf[11];
    function failwithf(fmt)
     {return caml_call2
              (ksprintf,
               function(s,param){return caml_call1(failwith$0,s)},
               fmt)}
    function invalid_argf(fmt)
     {return caml_call2
              (ksprintf,
               function(s,param){return caml_call1(invalid_arg$0,s)},
               fmt)}
    var
     Base_Printf=
      [0,ifprintf,sprintf,bprintf,ksprintf,kbprintf,failwithf,invalid_argf];
    caml_register_global(977,Base_Printf,"Base__Printf");
    var
     backend_type=Stdlib_Sys[5],
     interactive=Stdlib_Sys[3],
     os_type=Stdlib_Sys[4],
     unix=Stdlib_Sys[6],
     win32=Stdlib_Sys[7],
     cygwin=Stdlib_Sys[8],
     word_size_in_bits=Stdlib_Sys[9],
     num_bits=Stdlib_Sys[10],
     big_endian=Stdlib_Sys[11],
     max_length=Stdlib_Sys[12],
     max_length$0=Stdlib_Sys[13],
     runtime_variant=runtime.caml_runtime_variant,
     runtime_parameters=runtime.caml_runtime_parameters,
     argv=caml_sys_argv(0);
    function get_argv(param){return caml_sys_argv(0)}
    var
     ocaml_version=Stdlib_Sys[46],
     enable_runtime_warnings=Stdlib_Sys[49],
     runtime_warnings_enabled=Stdlib_Sys[50];
    function getenv_exn(var$0)
     {try
       {var _MR_=caml_sys_getenv(var$0);return _MR_}
      catch(_MS_)
       {_MS_ = caml_wrap_exception(_MS_);
        if(_MS_ === Caml$0[103])return caml_call2(failwithf(_c_),var$0,0);
        throw _MS_}}
    function getenv(var$0)
     {try
       {var x=caml_sys_getenv(var$0)}
      catch(_MQ_)
       {_MQ_ = caml_wrap_exception(_MQ_);
        if(_MQ_ === Caml$0[103])return 0;
        throw _MQ_}
      return [0,x]}
    var
     Break=Stdlib_Sys[44],
     include$10=
      [0,
       backend_type,
       interactive,
       os_type,
       unix,
       win32,
       cygwin,
       word_size_in_bits,
       num_bits,
       big_endian,
       max_length,
       max_length$0,
       runtime_variant,
       runtime_parameters,
       argv,
       get_argv,
       ocaml_version,
       enable_runtime_warnings,
       runtime_warnings_enabled,
       getenv_exn,
       getenv,
       Break];
    caml_register_global(979,include$10,"Base__Sys0");
    var Array=[0];
    function create(len,x){return caml_make_vect(len,x)}
    function create_float_uninitialized(len)
     {return runtime.caml_make_float_vect(len)}
    var
     append=Stdlib_ArrayLabels[5],
     blit=Stdlib_ArrayLabels[10],
     concat=Stdlib_ArrayLabels[6],
     copy=Stdlib_ArrayLabels[8],
     fill=Stdlib_ArrayLabels[9],
     init=Stdlib_ArrayLabels[2],
     make_matrix=Stdlib_ArrayLabels[3],
     of_list=Stdlib_ArrayLabels[12],
     sub$0=Stdlib_ArrayLabels[7],
     to_list=Stdlib_ArrayLabels[11];
    function fold(t,init,f)
     {return caml_call3(Stdlib_ArrayLabels[17],f,init,t)}
    function fold_right(t,f,init)
     {return caml_call3(Stdlib_ArrayLabels[19],f,t,init)}
    function iter(t,f){return caml_call2(Stdlib_ArrayLabels[13],f,t)}
    function iteri(t,f){return caml_call2(Stdlib_ArrayLabels[14],f,t)}
    function map(t,f){return caml_call2(Stdlib_ArrayLabels[15],f,t)}
    function mapi(t,f){return caml_call2(Stdlib_ArrayLabels[16],f,t)}
    function stable_sort(t,compare)
     {return caml_call2(Stdlib_ArrayLabels[33],compare,t)}
    function swap(t,i,j)
     {var
       elt_i=caml_check_bound(t,i)[1 + i],
       elt_j=caml_check_bound(t,j)[1 + j];
      t[1 + i] = elt_j;
      t[1 + j] = elt_i;
      return 0}
    var
     include$11=
      [0,
       invalid_argf,
       Array,
       max_length$0,
       create,
       create_float_uninitialized,
       append,
       blit,
       concat,
       copy,
       fill,
       init,
       make_matrix,
       of_list,
       sub$0,
       to_list,
       fold,
       fold_right,
       iter,
       iteri,
       map,
       mapi,
       stable_sort,
       swap];
    caml_register_global(982,include$11,"Base__Array0");
    var _d_=Stdlib_Char[2],_e_=Stdlib_Char[5];
    function to_int(_MP_){return _MP_}
    function unsafe_of_int(_MO_){return _MO_}
    var _f_=Stdlib_Char[6];
    function int_is_ok(i)
     {var _MM_=0 <= i?1:0,_MN_=_MM_?i <= 255?1:0:_MM_;return _MN_}
    var min_value=0,max_value=255;
    function of_int(i){return int_is_ok(i)?[0,i]:0}
    function of_int_exn(i)
     {return int_is_ok(i)?i:caml_call2(failwithf(_g_),i,0)}
    function equal$7(t1,t2){return t1 === t2?1:0}
    var
     include$12=
      [0,
       failwithf,
       _d_,
       _e_,
       to_int,
       unsafe_of_int,
       _f_,
       int_is_ok,
       min_value,
       max_value,
       of_int,
       of_int_exn,
       equal$7];
    caml_register_global(984,include$12,"Base__Char0");
    var Base_Hash_intf=[0];
    caml_register_global(985,Base_Hash_intf,"Base__Hash_intf");
    var to_string=Caml[33],of_string=caml_int_of_string;
    function to_float(_ML_){return _ML_}
    function of_float(_MK_){return _MK_ | 0}
    var max_value$0=Caml[19],min_value$0=Caml[20];
    function succ(_MJ_){return _MJ_ + 1 | 0}
    var
     include$13=
      [0,to_string,of_string,to_float,of_float,max_value$0,min_value$0,succ];
    caml_register_global(986,include$13,"Base__Int0");
    var
     hd_exn=Stdlib_ListLabels[5],
     length=Stdlib_ListLabels[1],
     rev_append=Stdlib_ListLabels[12],
     tl_exn=Stdlib_ListLabels[6],
     unzip=Stdlib_ListLabels[54];
    function exists(t,f){return caml_call2(Stdlib_ListLabels[33],f,t)}
    function exists2_ok(l1,l2,f)
     {return caml_call3(Stdlib_ListLabels[35],f,l1,l2)}
    function fold_left(t,init,f)
     {return caml_call3(Stdlib_ListLabels[25],f,init,t)}
    function fold2_ok(l1,l2,init,f)
     {return caml_call4(Stdlib_ListLabels[30],f,init,l1,l2)}
    function for_all(t,f){return caml_call2(Stdlib_ListLabels[32],f,t)}
    function for_all2_ok(l1,l2,f)
     {return caml_call3(Stdlib_ListLabels[34],f,l1,l2)}
    function iter$0(t,f){return caml_call2(Stdlib_ListLabels[17],f,t)}
    function iter2_ok(l1,l2,f)
     {return caml_call3(Stdlib_ListLabels[27],f,l1,l2)}
    function nontail_map(t,f){return caml_call2(Stdlib_ListLabels[19],f,t)}
    function nontail_mapi(t,f){return caml_call2(Stdlib_ListLabels[20],f,t)}
    function partition(t,f){return caml_call2(Stdlib_ListLabels[44],f,t)}
    function rev_map(t,f){return caml_call2(Stdlib_ListLabels[21],f,t)}
    function rev_map2_ok(l1,l2,f)
     {return caml_call3(Stdlib_ListLabels[29],f,l1,l2)}
    function sort(l,compare)
     {return caml_call2(Stdlib_ListLabels[56],compare,l)}
    function stable_sort$0(l,compare)
     {return caml_call2(Stdlib_ListLabels[57],compare,l)}
    function rev(res)
     {if(res)
       {var _MI_=res[2];
        if(_MI_)
         {var rest=_MI_[2],y=_MI_[1],x=res[1];
          return caml_call2(rev_append,rest,[0,y,[0,x,0]])}}
      return res}
    function fold_right$0(l,f,init)
     {if(! l)return init;
      function _MH_(a,b){return caml_call2(f,b,a)}
      return fold_left(rev(l),init,_MH_)}
    var
     include$14=
      [0,
       hd_exn,
       length,
       rev_append,
       tl_exn,
       unzip,
       exists,
       exists2_ok,
       fold_left,
       fold2_ok,
       for_all,
       for_all2_ok,
       iter$0,
       iter2_ok,
       nontail_map,
       nontail_mapi,
       partition,
       rev_map,
       rev_map2_ok,
       sort,
       stable_sort$0,
       rev,
       fold_right$0];
    caml_register_global(988,include$14,"Base__List0");
    function Folding(Hash)
     {function hash_fold_unit(s,param){return s}
      var _Ma_=Hash[2],_Mb_=Hash[3],_Mc_=Hash[4],_Md_=Hash[5];
      function as_int(f,s,x){return caml_call2(_Ma_,s,caml_call1(f,x))}
      function _Me_(_MG_){return _MG_}
      function hash_fold_int32(_ME_,_MF_){return as_int(_Me_,_ME_,_MF_)}
      function hash_fold_char(_MC_,_MD_){return as_int(to_int,_MC_,_MD_)}
      function _Mf_(param){return param?1:0}
      function hash_fold_bool(_MA_,_MB_){return as_int(_Mf_,_MA_,_MB_)}
      function hash_fold_nativeint(s,x)
       {return caml_call2(_Mb_,s,caml_int64_of_int32(x))}
      function hash_fold_option(hash_fold_elem,s,param)
       {if(! param)return caml_call2(_Ma_,s,0);
        var x=param[1];
        return caml_call2(hash_fold_elem,caml_call2(_Ma_,s,1),x)}
      function hash_fold_list(hash_fold_elem,s$1,list$0)
       {var
         s$2=caml_call2(_Ma_,s$1,caml_call1(length,list$0)),
         s=s$2,
         list=list$0;
        for(;;)
         {if(! list)return s;
          var
           xs=list[2],
           x=list[1],
           s$0=caml_call2(hash_fold_elem,s,x),
           s=s$0,
           list=xs}}
      function hash_fold_lazy_t(hash_fold_elem,s,x)
       {var
         _My_=caml_obj_tag(x),
         _Mz_=
          250 === _My_?x[1]:246 === _My_?caml_call1(CamlinternalLazy[2],x):x;
        return caml_call2(hash_fold_elem,s,_Mz_)}
      function hash_fold_ref_frozen(hash_fold_elem,s,x)
       {return caml_call2(hash_fold_elem,s,x[1])}
      function hash_fold_array_frozen(hash_fold_elem,s$1,array)
       {var s$2=caml_call2(_Ma_,s$1,array.length - 1),s=s$2,i=0;
        for(;;)
         {if(i === array.length - 1)return s;
          var
           e=array[1 + i],
           i$0=i + 1 | 0,
           s$0=caml_call2(hash_fold_elem,s,e),
           s=s$0,
           i=i$0}}
      function hash_nativeint(x)
       {var
         _Mw_=caml_call1(Hash[6],0),
         _Mx_=hash_fold_nativeint(caml_call2(Hash[7],0,_Mw_),x);
        return caml_call1(Hash[8],_Mx_)}
      function hash_int64(x)
       {var
         _Mu_=caml_call1(Hash[6],0),
         _Mv_=caml_call2(_Mb_,caml_call2(Hash[7],0,_Mu_),x);
        return caml_call1(Hash[8],_Mv_)}
      function hash_int32(x)
       {var
         _Ms_=caml_call1(Hash[6],0),
         _Mt_=hash_fold_int32(caml_call2(Hash[7],0,_Ms_),x);
        return caml_call1(Hash[8],_Mt_)}
      function hash_char(x)
       {var
         _Mq_=caml_call1(Hash[6],0),
         _Mr_=hash_fold_char(caml_call2(Hash[7],0,_Mq_),x);
        return caml_call1(Hash[8],_Mr_)}
      function hash_int(x)
       {var
         _Mo_=caml_call1(Hash[6],0),
         _Mp_=caml_call2(_Ma_,caml_call2(Hash[7],0,_Mo_),x);
        return caml_call1(Hash[8],_Mp_)}
      function hash_bool(x)
       {var
         _Mm_=caml_call1(Hash[6],0),
         _Mn_=hash_fold_bool(caml_call2(Hash[7],0,_Mm_),x);
        return caml_call1(Hash[8],_Mn_)}
      function hash_string(x)
       {var
         _Mk_=caml_call1(Hash[6],0),
         _Ml_=caml_call2(_Md_,caml_call2(Hash[7],0,_Mk_),x);
        return caml_call1(Hash[8],_Ml_)}
      function hash_float(x)
       {var
         _Mi_=caml_call1(Hash[6],0),
         _Mj_=caml_call2(_Mc_,caml_call2(Hash[7],0,_Mi_),x);
        return caml_call1(Hash[8],_Mj_)}
      function hash_unit(x)
       {var _Mg_=caml_call1(Hash[6],0),_Mh_=caml_call2(Hash[7],0,_Mg_);
        return caml_call1(Hash[8],_Mh_)}
      return [0,
              hash_fold_nativeint,
              _Mb_,
              hash_fold_int32,
              hash_fold_char,
              _Ma_,
              hash_fold_bool,
              _Md_,
              _Mc_,
              hash_fold_unit,
              hash_fold_option,
              hash_fold_list,
              hash_fold_lazy_t,
              hash_fold_ref_frozen,
              hash_fold_array_frozen,
              hash_nativeint,
              hash_int64,
              hash_int32,
              hash_char,
              hash_int,
              hash_bool,
              hash_string,
              hash_float,
              hash_unit]}
    function F(Hash)
     {var
       description=Hash[1],
       fold_int=Hash[2],
       fold_int64=Hash[3],
       fold_float=Hash[4],
       fold_string=Hash[5],
       alloc=Hash[6],
       reset=Hash[7],
       get_hash_value=Hash[8],
       For_tests=Hash[9];
      function create(seed,param)
       {return caml_call2(reset,seed,caml_call1(alloc,0))}
      function of_fold(hash_fold_t,t)
       {return caml_call1
                (get_hash_value,caml_call2(hash_fold_t,create(0,0),t))}
      var Builtin=Folding(Hash);
      function run(seed,folder,x)
       {var
         _L__=caml_call1(Hash[6],0),
         _L$_=caml_call2(folder,caml_call2(Hash[7],seed,_L__),x);
        return caml_call1(Hash[8],_L$_)}
      return [0,
              description,
              fold_int,
              fold_int64,
              fold_float,
              fold_string,
              alloc,
              reset,
              get_hash_value,
              For_tests,
              create,
              of_fold,
              Builtin,
              run]}
    function alloc(param){return 0}
    function reset(opt,t)
     {if(opt)var sth=opt[1],seed=sth;else var seed=0;return seed}
    var compare_state=caml_int_compare;
    function state_to_string(state){return caml_call1(to_string,state)}
    var For_tests=[0,compare_state,state_to_string];
    function create$0(seed,param){return reset(seed,0)}
    function run(seed,folder,x)
     {return runtime.Base_internalhash_get_hash_value
              (caml_call2(folder,reset(seed,0),x))}
    function of_fold(hash_fold_t,t)
     {return runtime.Base_internalhash_get_hash_value
              (caml_call2(hash_fold_t,create$0(0,0),t))}
    function _h_(_L9_){return runtime.Base_internalhash_get_hash_value(_L9_)}
    function _i_(_L8_,_L7_)
     {return runtime.Base_internalhash_fold_string(_L8_,_L7_)}
    function _j_(_L6_,_L5_)
     {return runtime.Base_internalhash_fold_float(_L6_,_L5_)}
    function _k_(_L4_,_L3_)
     {return runtime.Base_internalhash_fold_int64(_L4_,_L3_)}
    var
     Folding$0=
      Folding
       ([0,
         description,
         function(_L2_,_L1_)
          {return runtime.Base_internalhash_fold_int(_L2_,_L1_)},
         _k_,
         _j_,
         _i_,
         alloc,
         reset,
         _h_,
         For_tests]),
     hash_fold_nativeint=Folding$0[1],
     hash_fold_int64=Folding$0[2],
     hash_fold_int32=Folding$0[3],
     hash_fold_char=Folding$0[4],
     hash_fold_int=Folding$0[5],
     hash_fold_bool=Folding$0[6],
     hash_fold_string=Folding$0[7],
     hash_fold_float=Folding$0[8],
     hash_fold_unit=Folding$0[9],
     hash_fold_option=Folding$0[10],
     hash_fold_list=Folding$0[11],
     hash_fold_lazy_t=Folding$0[12],
     hash_fold_ref_frozen=Folding$0[13],
     hash_fold_array_frozen=Folding$0[14],
     hash_nativeint=Folding$0[15],
     hash_int64=Folding$0[16],
     hash_int32=Folding$0[17],
     hash_string=Folding$0[21];
    function hash_int(t)
     {var
       t$0=caml_call1(lnot$0,t) + (t << 21) | 0,
       t$1=t$0 ^ (t$0 >>> 24 | 0),
       t$2=(t$1 + (t$1 << 3) | 0) + (t$1 << 8) | 0,
       t$3=t$2 ^ (t$2 >>> 14 | 0),
       t$4=(t$3 + (t$3 << 2) | 0) + (t$3 << 4) | 0,
       t$5=t$4 ^ (t$4 >>> 28 | 0);
      return t$5 + (t$5 << 31) | 0}
    function hash_bool(x){return x?1:0}
    function hash_unit(param){return 0}
    var
     _l_=
      [0,
       hash_fold_nativeint,
       hash_fold_int64,
       hash_fold_int32,
       hash_fold_char,
       hash_fold_int,
       hash_fold_bool,
       hash_fold_string,
       hash_fold_float,
       hash_fold_unit,
       hash_fold_option,
       hash_fold_list,
       hash_fold_lazy_t,
       hash_fold_ref_frozen,
       hash_fold_array_frozen,
       hash_nativeint,
       hash_int64,
       hash_int32,
       to_int,
       hash_int,
       hash_bool,
       hash_string,
       function(_L0_){return runtime.Base_hash_double(_L0_)},
       hash_unit];
    function _m_(_LZ_){return runtime.Base_internalhash_get_hash_value(_LZ_)}
    function _n_(_LY_,_LX_)
     {return runtime.Base_internalhash_fold_string(_LY_,_LX_)}
    function _o_(_LW_,_LV_)
     {return runtime.Base_internalhash_fold_float(_LW_,_LV_)}
    function _p_(_LU_,_LT_)
     {return runtime.Base_internalhash_fold_int64(_LU_,_LT_)}
    var
     Base_Hash=
      [0,
       F,
       description,
       function(_LS_,_LR_)
        {return runtime.Base_internalhash_fold_int(_LS_,_LR_)},
       _p_,
       _o_,
       _n_,
       alloc,
       reset,
       _m_,
       For_tests,
       create$0,
       of_fold,
       _l_,
       run];
    caml_register_global(990,Base_Hash,"Base__Hash");
    function compare_abstract(type_name,param,_LQ_)
     {return caml_call3(ksprintf,failwith$0,_q_,type_name)}
    function equal_abstract(type_name,param,_LP_)
     {return caml_call3(ksprintf,failwith$0,_r_,type_name)}
    var
     Comparable=[0],
     Equal=[0],
     compare_bool=caml_int_compare,
     compare_char=caml_int_compare,
     compare_float=caml_float_compare,
     compare_int=caml_int_compare,
     compare_int32=caml_int_compare;
    function compare_int64(_LO_,_LN_){return caml_int64_compare(_LO_,_LN_)}
    var
     compare_nativeint=caml_int_compare,
     compare_string=caml_string_compare,
     compare_unit=caml_int_compare;
    function compare_array(compare_elt,a,b)
     {if(a === b)return 0;
      var
       len_a=a.length - 1,
       len_b=b.length - 1,
       ret=caml_int_compare(len_a,len_b);
      if(0 !== ret)return ret;
      var i=0;
      for(;;)
       {if(i === len_a)return 0;
        var l=a[1 + i],r=b[1 + i],res=caml_call2(compare_elt,l,r);
        if(0 !== res)return res;
        var i$0=i + 1 | 0,i=i$0}}
    function compare_list(compare_elt,a,b)
     {var a$0=a,b$0=b;
      for(;;)
       {if(! a$0)return b$0?-1:0;
        if(! b$0)return 1;
        var
         ys=b$0[2],
         y=b$0[1],
         xs=a$0[2],
         x=a$0[1],
         res=caml_call2(compare_elt,x,y);
        if(0 !== res)return res;
        var a$0=xs,b$0=ys}}
    function compare_option(compare_elt,a,b)
     {if(! a)return b?-1:0;
      var _LM_=a[1];
      if(! b)return 1;
      var b$0=b[1];
      return caml_call2(compare_elt,_LM_,b$0)}
    function compare_ref(compare_elt,a,b)
     {return caml_call2(compare_elt,a[1],b[1])}
    function equal_bool(_LL_,_LK_){return _LL_ === _LK_?1:0}
    function equal_char(_LJ_,_LI_){return _LJ_ === _LI_?1:0}
    function equal_int(_LH_,_LG_){return _LH_ === _LG_?1:0}
    var
     equal_int32=caml_equal,
     equal_int64=caml_equal,
     equal_nativeint=caml_equal,
     equal_string=caml_string_equal;
    function equal_unit(_LF_,_LE_){return _LF_ === _LE_?1:0}
    function equal_float(x,y){return caml_float_compare(x,y) === 0?1:0}
    function equal_array(equal_elt,a,b)
     {var _Ly_=a === b?1:0;
      if(_Ly_)
       var _Lz_=_Ly_;
      else
       {var len_a=a.length - 1,len_b=b.length - 1,_LA_=len_a === len_b?1:0;
        if(_LA_)
         {var i=0;
          for(;;)
           {var _LB_=i === len_a?1:0;
            if(_LB_)
             var _LC_=_LB_;
            else
             {var l=a[1 + i],r=b[1 + i],_LD_=caml_call2(equal_elt,l,r);
              if(_LD_){var i$0=i + 1 | 0,i=i$0;continue}
              var _LC_=_LD_}
            return _LC_}}
        var _Lz_=_LA_}
      return _Lz_}
    function equal_list(equal_elt,a,b)
     {var a$0=a,b$0=b;
      for(;;)
       {if(a$0)
         {if(b$0)
           {var
             ys=b$0[2],
             y=b$0[1],
             xs=a$0[2],
             x=a$0[1],
             _Lx_=caml_call2(equal_elt,x,y);
            if(! _Lx_)return _Lx_;
            var a$0=xs,b$0=ys;
            continue}}
        else
         if(! b$0)return 1;
        return 0}}
    function equal_option(equal_elt,a,b)
     {if(a)
       {if(b){var b$0=b[1],a$0=a[1];return caml_call2(equal_elt,a$0,b$0)}}
      else
       if(! b)return 1;
      return 0}
    function equal_ref(equal_elt,a,b){return caml_call2(equal_elt,a[1],b[1])}
    var
     include$15=
      [0,
       compare_bool,
       compare_char,
       compare_float,
       compare_int,
       compare_int32,
       compare_int64,
       compare_nativeint,
       compare_string,
       compare_unit,
       compare_array,
       compare_list,
       compare_option,
       compare_ref,
       equal_bool,
       equal_char,
       equal_float,
       equal_int,
       equal_int32,
       equal_int64,
       equal_nativeint,
       equal_string,
       equal_unit,
       equal_array,
       equal_list,
       equal_option,
       equal_ref],
     Base_Ppx_compare_lib=
      [0,
       phys_equal,
       compare_abstract,
       equal_abstract,
       Comparable,
       Equal,
       include$15];
    caml_register_global(991,Base_Ppx_compare_lib,"Base__Ppx_compare_lib");
    var Std=[0],Hashable=[0],Base_Ppx_hash_lib=[0,Std,Hashable];
    caml_register_global(992,Base_Ppx_hash_lib,"Base__Ppx_hash_lib");
    var
     t_of_sexp=Sexplib0_Sexp[1],
     sexp_of_t=Sexplib0_Sexp[2],
     equal$8=Sexplib0_Sexp[3],
     Not_found_s=Sexplib0_Sexp[5],
     Of_sexp_error=Sexplib0_Sexp[6],
     message=Sexplib0_Sexp[7],
     default_indent=Sexplib0_Sexp[8],
     pp_hum=Sexplib0_Sexp[9],
     pp_hum_indent=Sexplib0_Sexp[10],
     pp_mach=Sexplib0_Sexp[11],
     pp=Sexplib0_Sexp[12],
     to_string_hum=Sexplib0_Sexp[13],
     to_string_mach=Sexplib0_Sexp[14],
     to_string$0=Sexplib0_Sexp[15],
     of_float_style=Sexplib0_Sexp[16],
     of_int_style=Sexplib0_Sexp[17],
     Private=Sexplib0_Sexp[18];
    function compare$7(a_001,b_002)
     {if(a_001 === b_002)return 0;
      if(0 === a_001[0])
       {var _Lv_=a_001[1];
        if(0 !== b_002[0])return -1;
        var b_004=b_002[1];
        return caml_call2(include$15[8],_Lv_,b_004)}
      var _Lw_=a_001[1];
      if(0 === b_002[0])return 1;
      var b_006=b_002[1];
      return caml_call3(include$15[11],compare$7,_Lw_,b_006)}
    var
     hash_fold_t=function _Lu_(_Ls_,_Lt_){return _Lu_.fun(_Ls_,_Lt_)},
     hash=function _Lr_(_Lq_){return _Lr_.fun(_Lq_)};
    caml_update_dummy
     (hash_fold_t,
      function(hsv,arg)
       {if(0 === arg[0])
         {var a0=arg[1],hsv$0=runtime.Base_internalhash_fold_int(hsv,0);
          return caml_call2(_l_[7],hsv$0,a0)}
        var a0$0=arg[1],hsv$1=runtime.Base_internalhash_fold_int(hsv,1);
        return caml_call3(_l_[11],hash_fold_t,hsv$1,a0$0)});
    caml_update_dummy
     (hash,
      function(x)
       {var hsv=create$0(0,0);
        return runtime.Base_internalhash_get_hash_value
                (caml_call2(hash_fold_t,hsv,x))});
    var t_sexp_grammar=Sexplib0_Sexp_conv[59],of_string$0=0;
    function invariant(param){return 0}
    var
     Base_Sexp=
      [0,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       equal$8,
       compare$7,
       Not_found_s,
       Of_sexp_error,
       message,
       default_indent,
       pp_hum,
       pp_hum_indent,
       pp_mach,
       pp,
       to_string_hum,
       to_string_mach,
       to_string$0,
       of_float_style,
       of_int_style,
       Private,
       t_sexp_grammar,
       invariant,
       of_string$0];
    caml_register_global(995,Base_Sexp,"Base__Sexp");
    var
     default_string_of_float=Sexplib0_Sexp_conv[1],
     write_old_option_format=Sexplib0_Sexp_conv[2],
     read_old_option_format=Sexplib0_Sexp_conv[3],
     list_map=Sexplib0_Sexp_conv[4],
     sexp_of_t$0=Sexplib0_Sexp_conv[5],
     sexp_of_t$1=Sexplib0_Sexp_conv[6],
     sexp_of_t$2=Sexplib0_Sexp_conv[7],
     sexp_of_bytes=Sexplib0_Sexp_conv[8],
     sexp_of_t$3=Sexplib0_Sexp_conv[9],
     sexp_of_t$4=Sexplib0_Sexp_conv[10],
     sexp_of_t$5=Sexplib0_Sexp_conv[11],
     sexp_of_t$6=Sexplib0_Sexp_conv[12],
     sexp_of_t$7=Sexplib0_Sexp_conv[13],
     sexp_of_t$8=Sexplib0_Sexp_conv[14],
     sexp_of_ref=Sexplib0_Sexp_conv[15],
     sexp_of_t$9=Sexplib0_Sexp_conv[16],
     sexp_of_option=Sexplib0_Sexp_conv[17],
     sexp_of_pair=Sexplib0_Sexp_conv[18],
     sexp_of_triple=Sexplib0_Sexp_conv[19],
     sexp_of_t$10=Sexplib0_Sexp_conv[20],
     sexp_of_array=Sexplib0_Sexp_conv[21],
     sexp_of_hashtbl=Sexplib0_Sexp_conv[22],
     sexp_of_opaque=Sexplib0_Sexp_conv[23],
     sexp_of_fun=Sexplib0_Sexp_conv[24],
     Of_sexp_error$0=Sexplib0_Sexp_conv[25],
     record_check_extra_fields=Sexplib0_Sexp_conv[26],
     of_sexp_error=Sexplib0_Sexp_conv[27],
     of_sexp_error_exn=Sexplib0_Sexp_conv[28],
     t_of_sexp$0=Sexplib0_Sexp_conv[29],
     t_of_sexp$1=Sexplib0_Sexp_conv[30],
     t_of_sexp$2=Sexplib0_Sexp_conv[31],
     bytes_of_sexp=Sexplib0_Sexp_conv[32],
     t_of_sexp$3=Sexplib0_Sexp_conv[33],
     t_of_sexp$4=Sexplib0_Sexp_conv[34],
     t_of_sexp$5=Sexplib0_Sexp_conv[35],
     t_of_sexp$6=Sexplib0_Sexp_conv[36],
     t_of_sexp$7=Sexplib0_Sexp_conv[37],
     t_of_sexp$8=Sexplib0_Sexp_conv[38],
     ref_of_sexp=Sexplib0_Sexp_conv[39],
     t_of_sexp$9=Sexplib0_Sexp_conv[40],
     option_of_sexp=Sexplib0_Sexp_conv[41],
     pair_of_sexp=Sexplib0_Sexp_conv[42],
     triple_of_sexp=Sexplib0_Sexp_conv[43],
     t_of_sexp$10=Sexplib0_Sexp_conv[44],
     array_of_sexp=Sexplib0_Sexp_conv[45],
     hashtbl_of_sexp=Sexplib0_Sexp_conv[46],
     opaque_of_sexp=Sexplib0_Sexp_conv[47],
     fun_of_sexp=Sexplib0_Sexp_conv[48],
     unit_sexp_grammar=Sexplib0_Sexp_conv[49],
     t_sexp_grammar$0=Sexplib0_Sexp_conv[50],
     t_sexp_grammar$1=Sexplib0_Sexp_conv[51],
     bytes_sexp_grammar=Sexplib0_Sexp_conv[52],
     t_sexp_grammar$2=Sexplib0_Sexp_conv[53],
     t_sexp_grammar$3=Sexplib0_Sexp_conv[54],
     t_sexp_grammar$4=Sexplib0_Sexp_conv[55],
     t_sexp_grammar$5=Sexplib0_Sexp_conv[56],
     t_sexp_grammar$6=Sexplib0_Sexp_conv[57],
     t_sexp_grammar$7=Sexplib0_Sexp_conv[58],
     sexp_t_sexp_grammar=Sexplib0_Sexp_conv[59],
     ref_sexp_grammar=Sexplib0_Sexp_conv[60],
     lazy_t_sexp_grammar=Sexplib0_Sexp_conv[61],
     option_sexp_grammar=Sexplib0_Sexp_conv[62],
     list_sexp_grammar=Sexplib0_Sexp_conv[63],
     array_sexp_grammar=Sexplib0_Sexp_conv[64],
     opaque_sexp_grammar=Sexplib0_Sexp_conv[65],
     fun_sexp_grammar=Sexplib0_Sexp_conv[66],
     sexp_of_exn=Sexplib0_Sexp_conv[67],
     printexc_prefer_sexp=Sexplib0_Sexp_conv[68],
     sexp_of_exn_opt=Sexplib0_Sexp_conv[69],
     Exn_converter=Sexplib0_Sexp_conv[70],
     hash_fold_t$0=_l_[1],
     hash_fold_t$1=_l_[2],
     hash_fold_t$2=_l_[3],
     hash_fold_t$3=_l_[4],
     hash_fold_t$4=_l_[5],
     hash_fold_t$5=_l_[6],
     hash_fold_t$6=_l_[7],
     hash_fold_t$7=_l_[8],
     hash_fold_t$8=_l_[9],
     hash_fold_option$0=_l_[10],
     hash_fold_t$9=_l_[11],
     hash_fold_lazy_t$0=_l_[12],
     hash_fold_ref_frozen$0=_l_[13],
     hash_fold_array_frozen$0=_l_[14],
     func=_l_[15],
     func$0=_l_[16],
     func$1=_l_[17],
     func$2=_l_[18],
     func$3=_l_[19],
     func$4=_l_[20],
     func$5=_l_[21],
     specialized_hash=_l_[22],
     func$6=_l_[23],
     compare$8=include$15[1],
     compare$9=include$15[2],
     compare_float$0=include$15[3],
     compare$10=include$15[4],
     compare$11=include$15[5],
     compare$12=include$15[6],
     compare$13=include$15[7],
     compare_string$0=include$15[8],
     compare_unit$0=include$15[9],
     compare_array$0=include$15[10],
     compare_list$0=include$15[11],
     compare_option$0=include$15[12],
     compare_ref$0=include$15[13],
     equal_bool$0=include$15[14],
     equal_char$0=include$15[15],
     equal_float$0=include$15[16],
     equal_int$0=include$15[17],
     equal_int32$0=include$15[18],
     equal_int64$0=include$15[19],
     equal_nativeint$0=include$15[20],
     equal_string$0=include$15[21],
     equal_unit$0=include$15[22],
     equal_array$0=include$15[23],
     equal_list$0=include$15[24],
     equal_option$0=include$15[25],
     equal_ref$0=include$15[26],
     Base_Import=
      [0,
       Exit,
       Not_found,
       max_int,
       min_int,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon_float,
       char_of_int,
       string_of_bool,
       bool_of_string_opt,
       bool_of_string,
       string_of_int,
       int_of_string_opt,
       string_of_float,
       float_of_string_opt,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int_opt,
       read_int,
       read_float_opt,
       read_float,
       open_out,
       open_out_bin,
       open_out_gen,
       flush,
       flush_all,
       output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       output_byte,
       output_binary_int,
       output_value,
       seek_out,
       pos_out,
       out_channel_length,
       close_out,
       close_out_noerr,
       set_binary_mode_out,
       open_in,
       open_in_bin,
       open_in_gen,
       input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       input_byte,
       input_binary_int,
       input_value,
       seek_in,
       pos_in,
       in_channel_length,
       close_in,
       close_in_noerr,
       set_binary_mode_in,
       string_of_format,
       symbol,
       exit,
       at_exit,
       valid_float_lexem,
       unsafe_really_input,
       do_at_exit,
       Caml$0,
       bool_to_int,
       symbol$3,
       symbol$4,
       symbol$5,
       scale,
       symbol$6,
       add,
       symbol$7,
       sub,
       symbol$8,
       symbol$9,
       include$1,
       _a_,
       _b_,
       max$2,
       min$2,
       Int32_replace_polymorphic_comp,
       include$2,
       include$3,
       include$4,
       include$5,
       include$6,
       include$7,
       include$8,
       include$9,
       symbol$58,
       symbol$59,
       neg,
       neg$0,
       asr,
       land,
       lnot$0,
       lor,
       lsl,
       lsr,
       lxor,
       mod,
       abs$0,
       failwith$0,
       get_key,
       invalid_arg$0,
       get_data,
       phys_equal,
       decr,
       incr,
       float_of_string,
       am_testing,
       default_string_of_float,
       write_old_option_format,
       read_old_option_format,
       list_map,
       sexp_of_t$0,
       sexp_of_t$1,
       sexp_of_t$2,
       sexp_of_bytes,
       sexp_of_t$3,
       sexp_of_t$4,
       sexp_of_t$5,
       sexp_of_t$6,
       sexp_of_t$7,
       sexp_of_t$8,
       sexp_of_ref,
       sexp_of_t$9,
       sexp_of_option,
       sexp_of_pair,
       sexp_of_triple,
       sexp_of_t$10,
       sexp_of_array,
       sexp_of_hashtbl,
       sexp_of_opaque,
       sexp_of_fun,
       Of_sexp_error$0,
       record_check_extra_fields,
       of_sexp_error,
       of_sexp_error_exn,
       t_of_sexp$0,
       t_of_sexp$1,
       t_of_sexp$2,
       bytes_of_sexp,
       t_of_sexp$3,
       t_of_sexp$4,
       t_of_sexp$5,
       t_of_sexp$6,
       t_of_sexp$7,
       t_of_sexp$8,
       ref_of_sexp,
       t_of_sexp$9,
       option_of_sexp,
       pair_of_sexp,
       triple_of_sexp,
       t_of_sexp$10,
       array_of_sexp,
       hashtbl_of_sexp,
       opaque_of_sexp,
       fun_of_sexp,
       unit_sexp_grammar,
       t_sexp_grammar$0,
       t_sexp_grammar$1,
       bytes_sexp_grammar,
       t_sexp_grammar$2,
       t_sexp_grammar$3,
       t_sexp_grammar$4,
       t_sexp_grammar$5,
       t_sexp_grammar$6,
       t_sexp_grammar$7,
       sexp_t_sexp_grammar,
       ref_sexp_grammar,
       lazy_t_sexp_grammar,
       option_sexp_grammar,
       list_sexp_grammar,
       array_sexp_grammar,
       opaque_sexp_grammar,
       fun_sexp_grammar,
       sexp_of_exn,
       printexc_prefer_sexp,
       sexp_of_exn_opt,
       Exn_converter,
       hash_fold_t$0,
       hash_fold_t$1,
       hash_fold_t$2,
       hash_fold_t$3,
       hash_fold_t$4,
       hash_fold_t$5,
       hash_fold_t$6,
       hash_fold_t$7,
       hash_fold_t$8,
       hash_fold_option$0,
       hash_fold_t$9,
       hash_fold_lazy_t$0,
       hash_fold_ref_frozen$0,
       hash_fold_array_frozen$0,
       func,
       func$0,
       func$1,
       func$2,
       func$3,
       func$4,
       func$5,
       specialized_hash,
       func$6,
       compare$8,
       compare$9,
       compare_float$0,
       compare$10,
       compare$11,
       compare$12,
       compare$13,
       compare_string$0,
       compare_unit$0,
       compare_array$0,
       compare_list$0,
       compare_option$0,
       compare_ref$0,
       equal_bool$0,
       equal_char$0,
       equal_float$0,
       equal_int$0,
       equal_int32$0,
       equal_int64$0,
       equal_nativeint$0,
       equal_string$0,
       equal_unit$0,
       equal_array$0,
       equal_list$0,
       equal_option$0,
       equal_ref$0,
       Not_found_s];
    caml_register_global(996,Base_Import,"Base__Import");
    function sexp_of_t$11(param){return param?_s_:_t_}
    function num_bits$0(param){return param?64:32}
    var
     word_size=
      32 === word_size_in_bits
       ?0
       :64 === word_size_in_bits
         ?1
         :caml_call1(failwith$0,cst_unknown_word_size),
     Base_Word_size=[0,sexp_of_t$11,num_bits$0,word_size];
    caml_register_global(997,Base_Word_size,"Base__Word_size");
    var Base_Formatter=[0];
    caml_register_global(998,Base_Formatter,"Base__Formatter");
    var r=[0,_u_];
    function all(param){return r[1]}
    function register(p){r[1] = [0,p,r[1]];return 0}
    function Register_pp(_Ln_)
     {var _Lo_=_Ln_[1],_Lp_=_Ln_[2];
      register(caml_call2(symbol$59,_Ln_[2],cst_pp));
      return [0,_Lo_,_Lp_]}
    function _v_(_Lm_){return [0,Register_pp(_Lm_)[1]]}
    function _w_(M)
     {var module_name=M[1];
      function pp(formatter,t)
       {var _Ll_=caml_call1(M[2],t);
        return caml_call2(Stdlib_Format[13],formatter,_Ll_)}
      return [0,Register_pp([0,pp,module_name])[1]]}
    var Base_Pretty_printer=[0,all,_w_,_v_,register];
    caml_register_global(1000,Base_Pretty_printer,"Base__Pretty_printer");
    var _x_=Caml$0[98],Finally=[248,cst_Base_Exn_Finally,caml_fresh_oo_id(0)];
    function _y_(param)
     {if(param[1] !== Finally)throw [0,Assert_failure$0,_A_];
      var
       arg1_002=param[3],
       arg0_001=param[2],
       res0_003=caml_call1(sexp_of_exn,arg0_001),
       res1_004=caml_call1(sexp_of_exn,arg1_002);
      return [1,[0,_z_,[0,res0_003,[0,res1_004,0]]]]}
    caml_call4(Sexplib0_Sexp_conv[70][1],0,0,Finally,_y_);
    var Reraised=[248,cst_Base_Exn_Reraised,caml_fresh_oo_id(0)];
    function _B_(param)
     {if(param[1] !== Reraised)throw [0,Assert_failure$0,_D_];
      var
       arg1_006=param[3],
       arg0_005=param[2],
       res0_007=caml_call1(sexp_of_t$2,arg0_005),
       res1_008=caml_call1(sexp_of_exn,arg1_006);
      return [1,[0,_C_,[0,res0_007,[0,res1_008,0]]]]}
    caml_call4(Sexplib0_Sexp_conv[70][1],0,0,Reraised,_B_);
    var Sexp=[248,cst_Base_Exn_Sexp,caml_fresh_oo_id(0)];
    function _E_(param)
     {if(param[1] !== Sexp)throw [0,Assert_failure$0,_F_];
      var t=param[2];
      return t}
    caml_call4(Sexplib0_Sexp_conv[70][1],0,0,Sexp,_E_);
    function create_s(sexp){return [0,Sexp,sexp]}
    function raise_with_original_backtrace(t,backtrace)
     {runtime.caml_restore_raw_backtrace(t,backtrace);throw t}
    function reraise(exn,str)
     {var exn$0=[0,Reraised,str,exn];
      if(! runtime.Base_caml_exn_is_most_recent_exn(exn))throw exn$0;
      var bt=caml_call1(Stdlib_Printexc[12],0);
      return raise_with_original_backtrace(exn$0,bt)}
    function reraisef(exc,format)
     {return caml_call2
              (ksprintf,function(str,param){return reraise(exc,str)},format)}
    function to_string$1(exc)
     {return caml_call2(to_string_hum,_G_,caml_call1(sexp_of_exn,exc))}
    function to_string_mach$0(exc)
     {return caml_call1(to_string_mach,caml_call1(sexp_of_exn,exc))}
    function protectx(f,x,finally$0)
     {try
       {var res=caml_call1(f,x)}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        var bt=caml_call1(Stdlib_Printexc[12],0);
        try
         {caml_call1(finally$0,x)}
        catch(final_exn)
         {final_exn = caml_wrap_exception(final_exn);
          return raise_with_original_backtrace([0,Finally,exn,final_exn],bt)}
        return raise_with_original_backtrace(exn,bt)}
      caml_call1(finally$0,x);
      return res}
    function protect(f,finally$0){return protectx(f,0,finally$0)}
    function does_raise(f)
     {try {caml_call1(f,0);var _Lj_=0;return _Lj_}catch(_Lk_){return 1}}
    function pp$0(ppf,t)
     {var match=caml_call1(sexp_of_exn_opt,t);
      if(match){var sexp=match[1];return caml_call2(pp_hum,ppf,sexp)}
      var _Li_=caml_call1(Stdlib_Printexc[1],t);
      return caml_call2(Stdlib_Format[13],ppf,_Li_)}
    var include$16=_v_([0,pp$0,module_name]),pp$1=include$16[1];
    function print_with_backtrace(exc,raw_backtrace)
     {caml_call3(Stdlib_Format[131],_H_,pp$1,exc);
      if(caml_call1(Stdlib_Printexc[8],0))
       caml_call2(Stdlib_Printexc[13],Caml$0[39],raw_backtrace);
      return caml_call1(Caml$0[62],Caml$0[39])}
    function handle_uncaught_aux(do_at_exit,exit,f)
     {try
       {var _Le_=caml_call1(f,0);return _Le_}
      catch(exc)
       {exc = caml_wrap_exception(exc);
        var raw_backtrace=caml_call1(Stdlib_Printexc[12],0);
        if(do_at_exit)try {caml_call1(Caml$0[102],0)}catch(_Lh_){}
        try
         {print_with_backtrace(exc,raw_backtrace)}
        catch(_Lf_){try {caml_call1(Stdlib_Printf[3],_I_)}catch(_Lg_){}}
        return caml_call1(exit,1)}}
    function handle_uncaught_and_exit(f){return handle_uncaught_aux(1,_x_,f)}
    function handle_uncaught(must_exit,f)
     {var exit=must_exit?_x_:function(_Ld_){return 0};
      return handle_uncaught_aux(must_exit,exit,f)}
    function reraise_uncaught(str,func)
     {try
       {var _Lc_=caml_call1(func,0);return _Lc_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        var bt=caml_call1(Stdlib_Printexc[12],0);
        return raise_with_original_backtrace([0,Reraised,str,exn],bt)}}
    function raise_without_backtrace(e)
     {runtime.Base_clear_caml_backtrace_pos(0);throw e}
    function initialize_module(param)
     {return caml_call1(Stdlib_Printexc[16],print_with_backtrace)}
    function clear_backtrace(_Lb_)
     {return runtime.Base_clear_caml_backtrace_pos(_Lb_)}
    var
     Private$0=[0,clear_backtrace],
     Base_Exn=
      [0,
       sexp_of_exn,
       pp$1,
       Finally,
       Reraised,
       create_s,
       raise_without_backtrace,
       raise_with_original_backtrace,
       reraise,
       reraisef,
       to_string$1,
       to_string_mach$0,
       protectx,
       protect,
       handle_uncaught,
       handle_uncaught_and_exit,
       reraise_uncaught,
       does_raise,
       function(_La_){return runtime.Base_caml_exn_is_most_recent_exn(_La_)},
       initialize_module,
       Private$0];
    caml_register_global(1003,Base_Exn,"Base__Exn");
    function with_return(f)
     {var Return=[248,cst_Return,caml_fresh_oo_id(0)],is_alive=[0,1];
      function return$0(a)
       {if(1 - is_alive[1])
         caml_call1(failwith$0,cst_use_of_return_from_a_with_);
        return raise_without_backtrace([0,Return,a])}
      try
       {var a$0=caml_call1(f,return$0);is_alive[1] = 0;return a$0}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        is_alive[1] = 0;
        if(exn[1] !== Return)throw exn;
        var a=exn[2];
        return a}}
    function with_return_option(f)
     {return with_return
              (function(return$0)
                {caml_call1(f,function(a){return caml_call1(return$0,[0,a])});
                 return 0})}
    function prepend(param,f)
     {return function(x){return caml_call1(param,caml_call1(f,x))}}
    var Base_With_return=[0,with_return,with_return_option,prepend];
    caml_register_global(1004,Base_With_return,"Base__With_return");
    var Base_Variant=[0];
    caml_register_global(1005,Base_Variant,"Base__Variant");
    var Base_Variantslib=[0];
    caml_register_global(1006,Base_Variantslib,"Base__Variantslib");
    function S_to_S2(X)
     {var
       symbol_bind=X[1],
       symbol_map=X[2],
       Monad_infix=X[3],
       bind=X[4],
       return$0=X[5],
       map=X[6],
       join=X[7],
       ignore_m=X[8],
       all=X[9],
       all_unit=X[10],
       Let_syntax=X[11];
      return [0,
              symbol_bind,
              symbol_map,
              Let_syntax,
              Monad_infix,
              bind,
              return$0,
              map,
              join,
              ignore_m,
              all,
              all_unit]}
    function S2_to_S3(X)
     {var
       symbol_bind=X[1],
       symbol_map=X[2],
       Let_syntax=X[3],
       Monad_infix=X[4],
       bind=X[5],
       return$0=X[6],
       map=X[7],
       join=X[8],
       ignore_m=X[9],
       all=X[10],
       all_unit=X[11];
      return [0,
              symbol_bind,
              symbol_map,
              Let_syntax,
              Monad_infix,
              bind,
              return$0,
              map,
              join,
              ignore_m,
              all,
              all_unit]}
    function S_to_S_indexed(X)
     {var
       symbol_bind=X[1],
       symbol_map=X[2],
       Monad_infix=X[3],
       bind=X[4],
       return$0=X[5],
       map=X[6],
       join=X[7],
       ignore_m=X[8],
       all=X[9],
       all_unit=X[10],
       Let_syntax=X[11];
      return [0,
              symbol_bind,
              symbol_map,
              Let_syntax,
              Monad_infix,
              bind,
              return$0,
              map,
              join,
              ignore_m,
              all,
              all_unit]}
    function S2_to_S(X)
     {var
       symbol_bind=X[1],
       symbol_map=X[2],
       Let_syntax=X[3],
       Monad_infix=X[4],
       bind=X[5],
       return$0=X[6],
       map=X[7],
       join=X[8],
       ignore_m=X[9],
       all=X[10],
       all_unit=X[11];
      return [0,
              symbol_bind,
              symbol_map,
              Monad_infix,
              bind,
              return$0,
              map,
              join,
              ignore_m,
              all,
              all_unit,
              Let_syntax]}
    function S3_to_S2(X)
     {var
       symbol_bind=X[1],
       symbol_map=X[2],
       Let_syntax=X[3],
       Monad_infix=X[4],
       bind=X[5],
       return$0=X[6],
       map=X[7],
       join=X[8],
       ignore_m=X[9],
       all=X[10],
       all_unit=X[11];
      return [0,
              symbol_bind,
              symbol_map,
              Let_syntax,
              Monad_infix,
              bind,
              return$0,
              map,
              join,
              ignore_m,
              all,
              all_unit]}
    function S_indexed_to_S2(X)
     {var
       symbol_bind=X[1],
       symbol_map=X[2],
       Let_syntax=X[3],
       Monad_infix=X[4],
       bind=X[5],
       return$0=X[6],
       map=X[7],
       join=X[8],
       ignore_m=X[9],
       all=X[10],
       all_unit=X[11];
      return [0,
              symbol_bind,
              symbol_map,
              Let_syntax,
              Monad_infix,
              bind,
              return$0,
              map,
              join,
              ignore_m,
              all,
              all_unit]}
    var
     Base_Monad_intf=
      [0,S_to_S2,S2_to_S3,S_to_S_indexed,S2_to_S,S3_to_S2,S_indexed_to_S2];
    caml_register_global(1007,Base_Monad_intf,"Base__Monad_intf");
    function Make_general(_K6_)
     {var _K7_=_K6_[1],_K8_=_K6_[3];
      function map_via_bind(ma,f)
       {function _K__(a)
         {var _K$_=caml_call1(f,a);return caml_call1(_K6_[3],_K$_)}
        return caml_call2(_K6_[1],ma,_K__)}
      var _K9_=_K6_[2];
      if(typeof _K9_ === "number")
       var map=map_via_bind;
      else
       var x=_K9_[2],map=x;
      function symbol_bind(t,f){return caml_call2(_K7_,t,f)}
      function symbol_map(t,f){return caml_call2(map,t,f)}
      var
       Monad_infix=[0,symbol_bind,symbol_map],
       symbol_bind$0=Monad_infix[1],
       symbol_map$0=Monad_infix[2],
       symbol_bind$1=Monad_infix[1],
       symbol_map$1=Monad_infix[2];
      function both(a,b)
       {return caml_call2
                (symbol_bind$1,
                 a,
                 function(a)
                  {return caml_call2
                           (symbol_map$1,b,function(b){return [0,a,b]})})}
      var
       Open_on_rhs=[0],
       Let_syntax=[0,_K8_,_K7_,map,both,Open_on_rhs],
       Let_syntax$0=[0,_K8_,symbol_bind$1,symbol_map$1,Let_syntax];
      function join(t)
       {return caml_call2(symbol_bind$0,t,function(t){return t})}
      function ignore_m(t){return caml_call2(map,t,function(param){return 0})}
      function loop(vs,param)
       {if(! param)return caml_call1(_K8_,rev(vs));
        var ts=param[2],t=param[1];
        return caml_call2
                (symbol_bind$0,t,function(v){return loop([0,v,vs],ts)})}
      function all(ts){return loop(0,ts)}
      function all_unit(param)
       {if(! param)return caml_call1(_K8_,0);
        var ts=param[2],t=param[1];
        return caml_call2
                (symbol_bind$0,t,function(param){return all_unit(ts)})}
      return [0,
              _K7_,
              _K8_,
              map_via_bind,
              map,
              Monad_infix,
              symbol_bind$0,
              symbol_map$0,
              Let_syntax$0,
              join,
              ignore_m,
              all,
              all_unit]}
    function Make_indexed(M)
     {var
       bind=M[1],
       map=M[2],
       return$0=M[3],
       _K5_=Make_general([0,bind,map,return$0]);
      return [0,
              _K5_[6],
              _K5_[7],
              _K5_[8],
              _K5_[5],
              _K5_[1],
              _K5_[2],
              _K5_[4],
              _K5_[9],
              _K5_[10],
              _K5_[11],
              _K5_[12]]}
    function Make3(M)
     {var
       bind=M[1],
       map=M[2],
       return$0=M[3],
       _K4_=Make_general([0,bind,map,return$0]);
      return [0,
              _K4_[6],
              _K4_[7],
              _K4_[8],
              _K4_[5],
              _K4_[1],
              _K4_[2],
              _K4_[4],
              _K4_[9],
              _K4_[10],
              _K4_[11],
              _K4_[12]]}
    function Make2(M)
     {var
       bind=M[1],
       map=M[2],
       return$0=M[3],
       _K3_=Make_general([0,bind,map,return$0]);
      return [0,
              _K3_[6],
              _K3_[7],
              _K3_[8],
              _K3_[5],
              _K3_[1],
              _K3_[2],
              _K3_[4],
              _K3_[9],
              _K3_[10],
              _K3_[11],
              _K3_[12]]}
    function Make(M)
     {var
       bind=M[1],
       return$0=M[2],
       map=M[3],
       _K2_=Make_general([0,bind,map,return$0]);
      return [0,
              _K2_[6],
              _K2_[7],
              _K2_[5],
              _K2_[1],
              _K2_[2],
              _K2_[4],
              _K2_[9],
              _K2_[10],
              _K2_[11],
              _K2_[12],
              _K2_[8]]}
    function Of_monad_general(Monad,M)
     {function return$0(a)
       {var _K1_=caml_call1(Monad[3],a);return caml_call1(M[2],_K1_)}
      function bind(t,f)
       {function _KX_(a)
         {var _K0_=caml_call1(f,a);return caml_call1(M[1],_K0_)}
        var _KY_=caml_call1(M[1],t),_KZ_=caml_call2(Monad[1],_KY_,_KX_);
        return caml_call1(M[2],_KZ_)}
      var
       map=
        [0,
         -198771759,
         function(t,f)
          {var _KV_=caml_call1(M[1],t),_KW_=caml_call2(Monad[2],_KV_,f);
           return caml_call1(M[2],_KW_)}];
      return Make_general([0,bind,map,return$0])}
    function bind(a,f){return caml_call1(f,a)}
    function return$0(a){return a}
    var
     map$0=[0,-198771759,function(a,f){return caml_call1(f,a)}],
     include$17=Make([0,bind,return$0,map$0]),
     symbol_bind=include$17[1],
     symbol_map=include$17[2],
     Monad_infix=include$17[3],
     bind$0=include$17[4],
     return$1=include$17[5],
     map$1=include$17[6],
     join=include$17[7],
     ignore_m=include$17[8],
     all$0=include$17[9],
     all_unit=include$17[10],
     Let_syntax=include$17[11],
     Ident=
      [0,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind$0,
       return$1,
       map$1,
       join,
       ignore_m,
       all$0,
       all_unit,
       Let_syntax];
    function _J_(Monad,M)
     {var
       to_monad=M[1],
       of_monad=M[2],
       bind=Monad[5],
       return$0=Monad[6],
       map=Monad[7],
       _KU_=Of_monad_general([0,bind,map,return$0],[0,to_monad,of_monad]);
      return [0,
              _KU_[6],
              _KU_[7],
              _KU_[8],
              _KU_[5],
              _KU_[1],
              _KU_[2],
              _KU_[4],
              _KU_[9],
              _KU_[10],
              _KU_[11],
              _KU_[12]]}
    function _K_(Monad,M)
     {var
       to_monad=M[1],
       of_monad=M[2],
       bind=Monad[5],
       return$0=Monad[6],
       map=Monad[7],
       _KT_=Of_monad_general([0,bind,map,return$0],[0,to_monad,of_monad]);
      return [0,
              _KT_[6],
              _KT_[7],
              _KT_[8],
              _KT_[5],
              _KT_[1],
              _KT_[2],
              _KT_[4],
              _KT_[9],
              _KT_[10],
              _KT_[11],
              _KT_[12]]}
    function _L_(Monad,M)
     {var
       to_monad=M[1],
       of_monad=M[2],
       bind=Monad[5],
       return$0=Monad[6],
       map=Monad[7],
       _KS_=Of_monad_general([0,bind,map,return$0],[0,to_monad,of_monad]);
      return [0,
              _KS_[6],
              _KS_[7],
              _KS_[8],
              _KS_[5],
              _KS_[1],
              _KS_[2],
              _KS_[4],
              _KS_[9],
              _KS_[10],
              _KS_[11],
              _KS_[12]]}
    var
     Base_Monad=
      [0,
       Make,
       Make2,
       Make3,
       Make_indexed,
       function(Monad,M)
        {var
          to_monad=M[1],
          of_monad=M[2],
          bind=Monad[4],
          return$0=Monad[5],
          map=Monad[6],
          _KR_=Of_monad_general([0,bind,map,return$0],[0,to_monad,of_monad]);
         return [0,
                 _KR_[6],
                 _KR_[7],
                 _KR_[5],
                 _KR_[1],
                 _KR_[2],
                 _KR_[4],
                 _KR_[9],
                 _KR_[10],
                 _KR_[11],
                 _KR_[12],
                 _KR_[8]]},
       _L_,
       _K_,
       _J_,
       Ident];
    caml_register_global(1008,Base_Monad,"Base__Monad");
    var Base_Applicative_intf=[0];
    caml_register_global(1009,Base_Applicative_intf,"Base__Applicative_intf");
    function S_to_S2$0(X)
     {var
       return$0=X[1],
       map=X[2],
       both=X[3],
       symbol=X[4],
       symbol$0=X[5],
       symbol$1=X[6],
       symbol_map=X[7],
       apply=X[8],
       map2=X[9],
       map3=X[10],
       all=X[11],
       all_unit=X[12],
       Applicative_infix=X[13];
      return [0,
              return$0,
              map,
              both,
              symbol,
              symbol$0,
              symbol$1,
              symbol_map,
              apply,
              map2,
              map3,
              all,
              all_unit,
              Applicative_infix]}
    function S2_to_S$0(X)
     {var
       return$0=X[1],
       map=X[2],
       both=X[3],
       symbol=X[4],
       symbol$0=X[5],
       symbol$1=X[6],
       symbol_map=X[7],
       apply=X[8],
       map2=X[9],
       map3=X[10],
       all=X[11],
       all_unit=X[12],
       Applicative_infix=X[13];
      return [0,
              return$0,
              map,
              both,
              symbol,
              symbol$0,
              symbol$1,
              symbol_map,
              apply,
              map2,
              map3,
              all,
              all_unit,
              Applicative_infix]}
    function S2_to_S3$0(X)
     {var
       return$0=X[1],
       map=X[2],
       both=X[3],
       symbol=X[4],
       symbol$0=X[5],
       symbol$1=X[6],
       symbol_map=X[7],
       apply=X[8],
       map2=X[9],
       map3=X[10],
       all=X[11],
       all_unit=X[12],
       Applicative_infix=X[13];
      return [0,
              return$0,
              map,
              both,
              symbol,
              symbol$0,
              symbol$1,
              symbol_map,
              apply,
              map2,
              map3,
              all,
              all_unit,
              Applicative_infix]}
    function S3_to_S2$0(X)
     {var
       return$0=X[1],
       map=X[2],
       both=X[3],
       symbol=X[4],
       symbol$0=X[5],
       symbol$1=X[6],
       symbol_map=X[7],
       apply=X[8],
       map2=X[9],
       map3=X[10],
       all=X[11],
       all_unit=X[12],
       Applicative_infix=X[13];
      return [0,
              return$0,
              map,
              both,
              symbol,
              symbol$0,
              symbol$1,
              symbol_map,
              apply,
              map2,
              map3,
              all,
              all_unit,
              Applicative_infix]}
    function Make3$0(_KJ_)
     {var _KK_=_KJ_[1],_KL_=_KJ_[2];
      function derived_map(t,f){return caml_call2(_KL_,caml_call1(_KK_,f),t)}
      var _KM_=_KJ_[3];
      if(typeof _KM_ === "number")
       var map=derived_map;
      else
       var x=_KM_[2],map=x;
      function symbol_map(t,f){return caml_call2(map,t,f)}
      function map2(ta,tb,f){return caml_call2(_KL_,caml_call2(map,ta,f),tb)}
      function map3(ta,tb,tc,f)
       {return caml_call2(_KL_,caml_call2(_KL_,caml_call2(map,ta,f),tb),tc)}
      function all(ts)
       {var _KN_=caml_call1(_KK_,0);
        function _KO_(x,xs){return [0,x,xs]}
        return fold_right$0
                (ts,
                 function(_KP_)
                  {return function(_KQ_){return map2(_KP_,_KQ_,_KO_)}},
                 _KN_)}
      function both(ta,tb){return map2(ta,tb,function(a,b){return [0,a,b]})}
      function symbol(u,v)
       {return caml_call2
                (_KL_,
                 caml_call2
                  (_KL_,caml_call1(_KK_,function(param,y){return y}),u),
                 v)}
      function symbol$0(u,v)
       {return caml_call2
                (_KL_,
                 caml_call2
                  (_KL_,caml_call1(_KK_,function(x,param){return x}),u),
                 v)}
      function all_unit(ts){return fold_left(ts,caml_call1(_KK_,0),symbol)}
      return [0,
              _KK_,
              map,
              both,
              _KL_,
              symbol$0,
              symbol,
              symbol_map,
              _KL_,
              map2,
              map3,
              all,
              all_unit,
              [0,_KL_,symbol$0,symbol,symbol_map]]}
    function Make2$0(X)
     {var return$0=X[1],apply=X[2],map=X[3];
      return Make3$0([0,return$0,apply,map])}
    function Make$0(X)
     {var return$0=X[1],apply=X[2],map=X[3];
      return Make2$0([0,return$0,apply,map])}
    function Make_let_syntax3(X,Intf,Impl)
     {var
       return$0=X[1],
       map=X[2],
       both=X[3],
       symbol=X[4],
       symbol$0=X[5],
       symbol$1=X[6],
       symbol_map=X[7],
       return$1=X[1],
       map$0=X[2],
       both$0=X[3],
       symbol$2=X[4],
       symbol$3=X[5],
       symbol$4=X[6],
       symbol_map$0=X[7],
       Let_syntax=
        [0,return$1,map$0,both$0,symbol$2,symbol$3,symbol$4,symbol_map$0,Impl],
       Let_syntax$0=
        [0,return$0,map,both,symbol,symbol$0,symbol$1,symbol_map,Let_syntax];
      return [0,Let_syntax$0]}
    function Make_let_syntax2(X,Intf,Impl)
     {var
       return$0=X[1],
       map=X[2],
       both=X[3],
       symbol=X[4],
       symbol$0=X[5],
       symbol$1=X[6],
       symbol_map=X[7];
      return Make_let_syntax3
              ([0,return$0,map,both,symbol,symbol$0,symbol$1,symbol_map],
               Intf,
               Impl)}
    function Make3_using_map2(_Kz_)
     {var _KA_=_Kz_[1],_KB_=_Kz_[2];
      function symbol(tf,ta)
       {return caml_call3(_KB_,tf,ta,function(f,a){return caml_call1(f,a)})}
      function derived_map(t,f){return symbol(caml_call1(_KA_,f),t)}
      var _KC_=_Kz_[3];
      if(typeof _KC_ === "number")
       var map=derived_map;
      else
       var x=_KC_[2],map=x;
      function symbol_map(t,f){return caml_call2(map,t,f)}
      function both(ta,tb)
       {return caml_call3(_KB_,ta,tb,function(a,b){return [0,a,b]})}
      function map3(ta,tb,tc,f)
       {function _KI_(fab,c){return caml_call1(fab,c)}
        return caml_call3(_KB_,caml_call3(_KB_,ta,tb,f),tc,_KI_)}
      function all(ts)
       {var _KD_=caml_call1(_KA_,0);
        function _KE_(x,xs){return [0,x,xs]}
        return fold_right$0
                (ts,
                 function(_KF_)
                  {var _KG_=caml_call1(_KB_,_KF_);
                   return function(_KH_){return caml_call2(_KG_,_KH_,_KE_)}},
                 _KD_)}
      function symbol$0(u,v)
       {return caml_call3(_KB_,u,v,function(param,y){return y})}
      function symbol$1(u,v)
       {return caml_call3(_KB_,u,v,function(x,param){return x})}
      function all_unit(ts){return fold_left(ts,caml_call1(_KA_,0),symbol$0)}
      return [0,
              _KA_,
              map,
              both,
              symbol,
              symbol$1,
              symbol$0,
              symbol_map,
              symbol,
              _KB_,
              map3,
              all,
              all_unit,
              [0,symbol,symbol$1,symbol$0,symbol_map]]}
    function Make2_using_map2(X)
     {var return$0=X[1],map2=X[2],map=X[3];
      return Make3_using_map2([0,return$0,map2,map])}
    function Make_using_map2(X)
     {var return$0=X[1],map2=X[2],map=X[3];
      return Make2_using_map2([0,return$0,map2,map])}
    function Of_monad2(M)
     {var return$0=M[6];
      function apply(mf,mx)
       {function _Ky_(f){return caml_call2(M[7],mx,f)}
        return caml_call2(M[5],mf,_Ky_)}
      var map=[0,-198771759,M[7]];
      return Make2$0([0,return$0,apply,map])}
    function Of_monad(M)
     {var
       symbol_bind=M[1],
       symbol_map=M[2],
       Monad_infix=M[3],
       bind=M[4],
       return$0=M[5],
       map=M[6],
       join=M[7],
       ignore_m=M[8],
       all=M[9],
       all_unit=M[10],
       Let_syntax=M[11];
      return Of_monad2
              ([0,
                symbol_bind,
                symbol_map,
                Let_syntax,
                Monad_infix,
                bind,
                return$0,
                map,
                join,
                ignore_m,
                all,
                all_unit])}
    function Compose(F,G)
     {function return$0(a)
       {var _Kx_=caml_call1(F[1],a);return caml_call1(G[1],_Kx_)}
      function apply(tf,tx)
       {var _Kw_=caml_call2(G[2],tf,F[8]);return caml_call2(G[8],_Kw_,tx)}
      function custom_map(t,f)
       {var _Kt_=F[2];
        function _Ku_(_Kv_){return caml_call2(_Kt_,_Kv_,f)}
        return caml_call2(G[2],t,_Ku_)}
      var
       map=[0,-198771759,custom_map],
       include=Make$0([0,return$0,apply,map]),
       return$1=include[1],
       map$0=include[2],
       both=include[3],
       symbol=include[4],
       symbol$0=include[5],
       symbol$1=include[6],
       symbol_map=include[7],
       apply$0=include[8],
       map2=include[9],
       map3=include[10],
       all=include[11],
       all_unit=include[12],
       Applicative_infix=include[13];
      return [0,
              return$1,
              map$0,
              both,
              symbol,
              symbol$0,
              symbol$1,
              symbol_map,
              apply$0,
              map2,
              map3,
              all,
              all_unit,
              Applicative_infix]}
    function Pair(F,G)
     {function return$0(a)
       {var _Ks_=caml_call1(G[1],a);return [0,caml_call1(F[1],a),_Ks_]}
      function apply(tf,tx)
       {var _Kr_=caml_call2(G[8],tf[2],tx[2]);
        return [0,caml_call2(F[8],tf[1],tx[1]),_Kr_]}
      function custom_map(t,f)
       {var _Kq_=caml_call2(G[2],t[2],f);
        return [0,caml_call2(F[2],t[1],f),_Kq_]}
      var
       map=[0,-198771759,custom_map],
       include=Make$0([0,return$0,apply,map]),
       return$1=include[1],
       map$0=include[2],
       both=include[3],
       symbol=include[4],
       symbol$0=include[5],
       symbol$1=include[6],
       symbol_map=include[7],
       apply$0=include[8],
       map2=include[9],
       map3=include[10],
       all=include[11],
       all_unit=include[12],
       Applicative_infix=include[13];
      return [0,
              return$1,
              map$0,
              both,
              symbol,
              symbol$0,
              symbol$1,
              symbol_map,
              apply$0,
              map2,
              map3,
              all,
              all_unit,
              Applicative_infix]}
    function _M_(_Kn_,_Km_,_Kl_)
     {var _Ko_=Make_let_syntax3(_Kn_,_Km_,_Kl_)[1],_Kp_=_Ko_[8];
      return [0,
              [0,
               _Ko_[1],
               _Ko_[4],
               _Ko_[5],
               _Ko_[6],
               _Ko_[7],
               [0,_Kp_[1],_Kp_[2],_Kp_[3],_Kp_[8]]]]}
    function _N_(_Ki_,_Kh_,_Kg_)
     {var _Kj_=Make_let_syntax2(_Ki_,_Kh_,_Kg_)[1],_Kk_=_Kj_[8];
      return [0,
              [0,
               _Kj_[1],
               _Kj_[4],
               _Kj_[5],
               _Kj_[6],
               _Kj_[7],
               [0,_Kk_[1],_Kk_[2],_Kk_[3],_Kk_[8]]]]}
    var
     Base_Applicative=
      [0,
       S2_to_S$0,
       S_to_S2$0,
       S3_to_S2$0,
       S2_to_S3$0,
       Make$0,
       Make2$0,
       Make3$0,
       function(X,Intf,Impl)
        {var
          return$0=X[1],
          map=X[2],
          both=X[3],
          symbol=X[4],
          symbol$0=X[5],
          symbol$1=X[6],
          symbol_map=X[7],
          _Ke_=
           Make_let_syntax2
             ([0,return$0,map,both,symbol,symbol$0,symbol$1,symbol_map],
              Intf,
              Impl)
            [1],
          _Kf_=_Ke_[8];
         return [0,
                 [0,
                  _Ke_[1],
                  _Ke_[4],
                  _Ke_[5],
                  _Ke_[6],
                  _Ke_[7],
                  [0,_Kf_[1],_Kf_[2],_Kf_[3],_Kf_[8]]]]},
       _N_,
       _M_,
       Make_using_map2,
       Make2_using_map2,
       Make3_using_map2,
       Of_monad,
       Of_monad2,
       Compose,
       Pair];
    caml_register_global(1010,Base_Applicative,"Base__Applicative");
    var
     Primitives=[0],
     blit$0=Stdlib_BytesLabels[11],
     blit_string=Stdlib_BytesLabels[12],
     compare$14=Stdlib_BytesLabels[44],
     copy$0=Stdlib_BytesLabels[4],
     create$1=caml_create_bytes,
     fill$0=Stdlib_BytesLabels[10],
     make=Stdlib_BytesLabels[1],
     map$2=Stdlib_BytesLabels[17],
     mapi$0=Stdlib_BytesLabels[18],
     sub$1=Stdlib_BytesLabels[7],
     unsafe_blit=runtime.caml_blit_bytes,
     to_string$2=Stdlib_BytesLabels[6],
     of_string$1=Stdlib_BytesLabels[5];
    function unsafe_to_string(s){return caml_call1(Stdlib_BytesLabels[48],s)}
    var
     unsafe_of_string_promise_no_mu=Stdlib_BytesLabels[49],
     include$18=
      [0,
       Primitives,
       max_length,
       blit$0,
       blit_string,
       compare$14,
       copy$0,
       create$1,
       fill$0,
       make,
       map$2,
       mapi$0,
       sub$1,
       unsafe_blit,
       to_string$2,
       of_string$1,
       unsafe_to_string,
       unsafe_of_string_promise_no_mu];
    caml_register_global(1012,include$18,"Base__Bytes0");
    var Module=[0];
    function make$0(compare,sexp_of_t)
     {var comparator=[0,compare,sexp_of_t];return [0,comparator]}
    function S_to_S1(S){var comparator=S[1];return [0,comparator]}
    function Make1(M){var comparator=[0,M[1],M[2]];return [0,comparator]}
    var compare$15=caml_compare;
    function sexp_of_t$12(param){return _O_}
    var
     include$19=Make1([0,compare$15,sexp_of_t$12]),
     comparator=include$19[1],
     Poly=[0,comparator];
    function Derived(M)
     {function comparator(a)
       {var _Kd_=caml_call1(M[2],a[2]);return [0,caml_call1(M[1],a[1]),_Kd_]}
      return [0,comparator]}
    function Derived2(M)
     {function comparator(a,b)
       {var _Kc_=caml_call2(M[2],a[2],b[2]);
        return [0,caml_call2(M[1],a[1],b[1]),_Kc_]}
      return [0,comparator]}
    function Derived_phantom(M)
     {function comparator(a)
       {var _Kb_=caml_call1(M[2],a[2]);return [0,caml_call1(M[1],a[1]),_Kb_]}
      return [0,comparator]}
    function _P_(M){var comparator=[0,M[1],M[2]];return [0,comparator]}
    var
     Base_Comparator=
      [0,
       make$0,
       Poly,
       Module,
       S_to_S1,
       _P_,
       Make1,
       Derived,
       Derived2,
       Derived_phantom];
    caml_register_global(1013,Base_Comparator,"Base__Comparator");
    var Base_Comparisons=[0];
    caml_register_global(1014,Base_Comparisons,"Base__Comparisons");
    function compare$16(cmp_f,cmp_s,a_001,b_002)
     {if(a_001 === b_002)return 0;
      if(0 === a_001[0])
       {var _J$_=a_001[1];
        if(0 !== b_002[0])return -1;
        var b_004=b_002[1];
        return caml_call2(cmp_f,_J$_,b_004)}
      var _Ka_=a_001[1];
      if(0 === b_002[0])return 1;
      var b_006=b_002[1];
      return caml_call2(cmp_s,_Ka_,b_006)}
    function hash_fold_t$10(hash_fold_f,hash_fold_s,hsv,arg)
     {if(0 === arg[0])
       {var a0=arg[1],hsv$0=runtime.Base_internalhash_fold_int(hsv,0);
        return caml_call2(hash_fold_f,hsv$0,a0)}
      var a0$0=arg[1],hsv$1=runtime.Base_internalhash_fold_int(hsv,1);
      return caml_call2(hash_fold_s,hsv$1,a0$0)}
    function t_of_sexp$11(of_f_007,of_s_008,sexp_013)
     {if(0 === sexp_013[0])
       {var _J7_=sexp_013[1],switch$0=0;
        if(caml_string_notequal(_J7_,cst_First))
         {var switch$1=0;
          if(caml_string_notequal(_J7_,cst_Second))
           if(caml_string_notequal(_J7_,cst_first))
            {if(caml_string_notequal(_J7_,cst_second))
              {switch$0 = 1;switch$1 = 1}}
           else
            switch$1 = 1;
          if(! switch$1)
           return caml_call2
                   (Sexplib0_Sexp_conv_error[5],error_source_011,sexp_013)}
        if(! switch$0)
         return caml_call2
                 (Sexplib0_Sexp_conv_error[5],error_source_011,sexp_013)}
      else
       {var _J8_=sexp_013[1];
        if(! _J8_)
         return caml_call2
                 (Sexplib0_Sexp_conv_error[7],error_source_011,sexp_013);
        var _J9_=_J8_[1];
        if(0 !== _J9_[0])
         return caml_call2
                 (Sexplib0_Sexp_conv_error[6],error_source_011,sexp_013);
        var _J__=_J9_[1],switch$2=0;
        if(caml_string_notequal(_J__,cst_First$0))
         {var switch$3=0;
          if(caml_string_notequal(_J__,cst_Second$0))
           if(caml_string_notequal(_J__,cst_first$0))
            {if(caml_string_notequal(_J__,cst_second$0))
              {switch$2 = 1;switch$3 = 1}}
           else
            switch$3 = 1;
          if(! switch$3)
           {var sexp_args_020=_J8_[2];
            if(sexp_args_020 && ! sexp_args_020[2])
             {var
               arg0_021=sexp_args_020[1],
               res0_022=caml_call1(of_s_008,arg0_021);
              return [1,res0_022]}
            return caml_call3
                    (Sexplib0_Sexp_conv_error[4],error_source_011,_J__,sexp_013)}}
        if(! switch$2)
         {var sexp_args_015=_J8_[2];
          if(sexp_args_015 && ! sexp_args_015[2])
           {var
             arg0_016=sexp_args_015[1],
             res0_017=caml_call1(of_f_007,arg0_016);
            return [0,res0_017]}
          return caml_call3
                  (Sexplib0_Sexp_conv_error[4],error_source_011,_J__,sexp_013)}}
      return caml_call2(Sexplib0_Sexp_conv_error[8],error_source_011,sexp_013)}
    function sexp_of_t$13(of_f_025,of_s_026,param)
     {if(0 === param[0])
       {var arg0_027=param[1],res0_028=caml_call1(of_f_025,arg0_027);
        return [1,[0,_Q_,[0,res0_028,0]]]}
      var arg0_029=param[1],res0_030=caml_call1(of_s_026,arg0_029);
      return [1,[0,_R_,[0,res0_030,0]]]}
    function t_sexp_grammar$8(f_sexp_grammar,s_sexp_grammar)
     {return [3,
              [0,
               2,
               [0,
                [1,[0,cst_First$1,[0,[0,f_sexp_grammar,0]]]],
                [0,[1,[0,cst_Second$1,[0,[0,s_sexp_grammar,0]]]],0]]]]}
    var
     include$20=
      [0,compare$16,hash_fold_t$10,t_of_sexp$11,sexp_of_t$13,t_sexp_grammar$8];
    caml_register_global(1016,include$20,"Base__Either0");
    function opaque_identity(_J6_){return _J6_}
    var For_generated_code=[0,opaque_identity];
    function name(param){return param[2]}
    function get(param,r){return caml_call1(param[4],r)}
    function fset(param,r,v){return caml_call2(param[5],r,v)}
    function setter(param){return param[3]}
    function map$3(field,r,f)
     {var _J5_=caml_call1(f,caml_call1(field[4],r));
      return caml_call2(field[5],r,_J5_)}
    function updater(field)
     {var _J4_=field[3];
      if(! _J4_)return 0;
      var setter=_J4_[1];
      return [0,
              function(r,f)
               {return caml_call2
                        (setter,r,caml_call1(f,caml_call1(field[4],r)))}]}
    var Base_Field=[0,For_generated_code,name,get,fset,setter,map$3,updater];
    caml_register_global(1017,Base_Field,"Base__Field");
    var
     String=[0],
     capitalize=Stdlib_StringLabels[27],
     compare$17=Stdlib_StringLabels[9];
    function copy$1(x){return unsafe_to_string(caml_call1(of_string$1,x))}
    var
     escaped=Stdlib_StringLabels[24],
     lowercase=Stdlib_StringLabels[26],
     make$1=Stdlib_StringLabels[1],
     sub$2=Stdlib_StringLabels[15],
     uncapitalize=Stdlib_StringLabels[28],
     unsafe_blit$0=caml_blit_string,
     uppercase=Stdlib_StringLabels[25];
    function concat$0(opt,l)
     {if(opt)var sth=opt[1],sep=sth;else var sep=cst$0;
      if(! l)return cst;
      if(l[2])return caml_call2(Stdlib_StringLabels[6],sep,l);
      var x=l[1];
      return x}
    function iter$1(t,f){return caml_call2(Stdlib_StringLabels[29],f,t)}
    var
     include$21=
      [0,
       String,
       max_length,
       symbol$59,
       capitalize,
       compare$17,
       copy$1,
       escaped,
       lowercase,
       make$1,
       sub$2,
       uncapitalize,
       unsafe_blit$0,
       uppercase,
       concat$0,
       iter$1];
    caml_register_global(1019,include$21,"Base__String0");
    function compare$18(a_001,b_002)
     {if(a_001 === b_002)return 0;
      var n=caml_call2(compare_string$0,a_001[1],b_002[1]);
      if(0 !== n)return n;
      var n$0=caml_call2(compare$10,a_001[2],b_002[2]);
      if(0 !== n$0)return n$0;
      var n$1=caml_call2(compare$10,a_001[3],b_002[3]);
      return 0 === n$1?caml_call2(compare$10,a_001[4],b_002[4]):n$1}
    function hash_fold_t$11(hsv,arg)
     {var
       hsv$0=caml_call2(hash_fold_t$6,hsv,arg[1]),
       hsv$1=caml_call2(hash_fold_t$4,hsv$0,arg[2]),
       hsv$2=caml_call2(hash_fold_t$4,hsv$1,arg[3]);
      return caml_call2(hash_fold_t$4,hsv$2,arg[4])}
    function hash$0(x)
     {var hsv=create$0(0,0);
      return runtime.Base_internalhash_get_hash_value(hash_fold_t$11(hsv,x))}
    function sexp_of_t$14(param)
     {var
       pos_cnum_010=param[4],
       pos_bol_008=param[3],
       pos_lnum_006=param[2],
       pos_fname_004=param[1],
       arg_011=caml_call1(sexp_of_t$4,pos_cnum_010),
       bnds_003=[0,[1,[0,_S_,[0,arg_011,0]]],0],
       arg_009=caml_call1(sexp_of_t$4,pos_bol_008),
       bnds_003$0=[0,[1,[0,_T_,[0,arg_009,0]]],bnds_003],
       arg_007=caml_call1(sexp_of_t$4,pos_lnum_006),
       bnds_003$1=[0,[1,[0,_U_,[0,arg_007,0]]],bnds_003$0],
       arg_005=caml_call1(sexp_of_t$2,pos_fname_004),
       bnds_003$2=[0,[1,[0,_V_,[0,arg_005,0]]],bnds_003$1];
      return [1,bnds_003$2]}
    var
     T=[0,compare$18,hash_fold_t$11,hash$0,sexp_of_t$14],
     compare$19=T[1],
     hash_fold_t$12=T[2],
     hash$1=T[3],
     include$22=_P_([0,T[1],T[4]]),
     comparator$0=include$22[1];
    function make_location_string(pos_fname,pos_lnum,pos_cnum,pos_bol)
     {var _J3_=[0,cst$1,[0,caml_call1(to_string,pos_cnum - pos_bol | 0),0]];
      return concat$0
              (0,
               [0,pos_fname,[0,cst$2,[0,caml_call1(to_string,pos_lnum),_J3_]]])}
    function to_string$3(param)
     {var
       pos_cnum=param[4],
       pos_bol=param[3],
       pos_lnum=param[2],
       pos_fname=param[1];
      return make_location_string(pos_fname,pos_lnum,pos_cnum,pos_bol)}
    function sexp_of_t$15(t){return [0,to_string$3(t)]}
    var
     include$23=
      [0,
       T,
       compare$19,
       hash_fold_t$12,
       hash$1,
       comparator$0,
       make_location_string,
       to_string$3,
       sexp_of_t$15];
    caml_register_global(1020,include$23,"Base__Source_code_position0");
    var Base_Invariant_intf=[0];
    caml_register_global(1021,Base_Invariant_intf,"Base__Invariant_intf");
    function is_empty(param){return param?0:1}
    function partition_map(t,f)
     {var t$0=t,fst=0,snd=0;
      for(;;)
       {if(! t$0){var _J2_=rev(snd);return [0,rev(fst),_J2_]}
        var t$1=t$0[2],x=t$0[1],match=caml_call1(f,x);
        if(0 === match[0])
         {var y=match[1],fst$0=[0,y,fst],t$0=t$1,fst=fst$0;continue}
        var y$0=match[1],snd$0=[0,y$0,snd],t$0=t$1,snd=snd$0}}
    var
     include$24=
      [0,
       hd_exn,
       length,
       rev_append,
       tl_exn,
       unzip,
       exists,
       exists2_ok,
       fold_left,
       fold2_ok,
       for_all,
       for_all2_ok,
       iter$0,
       iter2_ok,
       nontail_map,
       nontail_mapi,
       partition,
       rev_map,
       rev_map2_ok,
       sort,
       stable_sort$0,
       rev,
       fold_right$0,
       is_empty,
       partition_map];
    caml_register_global(1022,include$24,"Base__List1");
    function t_of_sexp$12(of_a_001,of_b_002,sexp_007)
     {if(0 === sexp_007[0])
       {var _JY_=sexp_007[1],switch$0=0;
        if(caml_string_notequal(_JY_,cst_Error))
         {var switch$1=0;
          if(caml_string_notequal(_JY_,cst_Ok))
           if(caml_string_notequal(_JY_,cst_error))
            {if(caml_string_notequal(_JY_,cst_ok)){switch$0 = 1;switch$1 = 1}}
           else
            switch$1 = 1;
          if(! switch$1)
           return caml_call2
                   (Sexplib0_Sexp_conv_error[5],error_source_005,sexp_007)}
        if(! switch$0)
         return caml_call2
                 (Sexplib0_Sexp_conv_error[5],error_source_005,sexp_007)}
      else
       {var _JZ_=sexp_007[1];
        if(! _JZ_)
         return caml_call2
                 (Sexplib0_Sexp_conv_error[7],error_source_005,sexp_007);
        var _J0_=_JZ_[1];
        if(0 !== _J0_[0])
         return caml_call2
                 (Sexplib0_Sexp_conv_error[6],error_source_005,sexp_007);
        var _J1_=_J0_[1],switch$2=0;
        if(caml_string_notequal(_J1_,cst_Error$0))
         {var switch$3=0;
          if(caml_string_notequal(_J1_,cst_Ok$0))
           if(caml_string_notequal(_J1_,cst_error$0))
            {if(caml_string_notequal(_J1_,cst_ok$0))
              {switch$2 = 1;switch$3 = 1}}
           else
            switch$3 = 1;
          if(! switch$3)
           {var sexp_args_009=_JZ_[2];
            if(sexp_args_009 && ! sexp_args_009[2])
             {var
               arg0_010=sexp_args_009[1],
               res0_011=caml_call1(of_a_001,arg0_010);
              return [0,res0_011]}
            return caml_call3
                    (Sexplib0_Sexp_conv_error[4],error_source_005,_J1_,sexp_007)}}
        if(! switch$2)
         {var sexp_args_014=_JZ_[2];
          if(sexp_args_014 && ! sexp_args_014[2])
           {var
             arg0_015=sexp_args_014[1],
             res0_016=caml_call1(of_b_002,arg0_015);
            return [1,res0_016]}
          return caml_call3
                  (Sexplib0_Sexp_conv_error[4],error_source_005,_J1_,sexp_007)}}
      return caml_call2(Sexplib0_Sexp_conv_error[8],error_source_005,sexp_007)}
    function sexp_of_t$16(of_a_019,of_b_020,param)
     {if(0 === param[0])
       {var arg0_021=param[1],res0_022=caml_call1(of_a_019,arg0_021);
        return [1,[0,_W_,[0,res0_022,0]]]}
      var arg0_023=param[1],res0_024=caml_call1(of_b_020,arg0_023);
      return [1,[0,_X_,[0,res0_024,0]]]}
    function t_sexp_grammar$9(a_sexp_grammar,b_sexp_grammar)
     {return [3,
              [0,
               2,
               [0,
                [1,[0,cst_Ok$1,[0,[0,a_sexp_grammar,0]]]],
                [0,[1,[0,cst_Error$1,[0,[0,b_sexp_grammar,0]]]],0]]]]}
    function compare$20(cmp_a,cmp_b,a_027,b_028)
     {if(a_027 === b_028)return 0;
      if(0 === a_027[0])
       {var _JW_=a_027[1];
        if(0 !== b_028[0])return -1;
        var b_030=b_028[1];
        return caml_call2(cmp_a,_JW_,b_030)}
      var _JX_=a_027[1];
      if(0 === b_028[0])return 1;
      var b_032=b_028[1];
      return caml_call2(cmp_b,_JX_,b_032)}
    function equal$9(cmp_a,cmp_b,a_033,b_034)
     {if(a_033 === b_034)return 1;
      if(0 === a_033[0])
       {var _JU_=a_033[1];
        if(0 !== b_034[0])return 0;
        var b_036=b_034[1];
        return caml_call2(cmp_a,_JU_,b_036)}
      var _JV_=a_033[1];
      if(0 === b_034[0])return 0;
      var b_038=b_034[1];
      return caml_call2(cmp_b,_JV_,b_038)}
    function hash_fold_t$13(hash_fold_a,hash_fold_b,hsv,arg)
     {if(0 === arg[0])
       {var a0=arg[1],hsv$0=runtime.Base_internalhash_fold_int(hsv,0);
        return caml_call2(hash_fold_a,hsv$0,a0)}
      var a0$0=arg[1],hsv$1=runtime.Base_internalhash_fold_int(hsv,1);
      return caml_call2(hash_fold_b,hsv$1,a0$0)}
    function bind$1(x,f)
     {if(0 !== x[0])return x;var x$0=x[1];return caml_call1(f,x$0)}
    var
     map$4=
      [0,
       -198771759,
       function(x,f)
        {if(0 !== x[0])return x;var x$0=x[1];return [0,caml_call1(f,x$0)]}];
    function return$2(x){return [0,x]}
    var
     include$25=Make2([0,bind$1,map$4,return$2]),
     symbol_bind$0=include$25[1],
     symbol_map$0=include$25[2],
     Let_syntax$0=include$25[3],
     include$26=include$25[4],
     bind$2=include$25[5],
     return$3=include$25[6],
     map$5=include$25[7],
     join$0=include$25[8],
     ignore_m$0=include$25[9],
     all$1=include$25[10],
     all_unit$0=include$25[11];
    function invariant$0(check_ok,check_error,t)
     {if(0 === t[0]){var ok=t[1];return caml_call1(check_ok,ok)}
      var error=t[1];
      return caml_call1(check_error,error)}
    function fail(x){return [1,x]}
    function failf(format){return caml_call2(ksprintf,fail,format)}
    function map_error(t,f)
     {if(0 === t[0])return t;var x=t[1];return [1,caml_call1(f,x)]}
    function bind$3(x,f)
     {if(0 === x[0])return x;var e=x[1];return caml_call1(f,e)}
    var map$6=[0,-198771759,map_error];
    function return$4(e){return [1,e]}
    var Error=Make2([0,bind$3,map$6,return$4]);
    function is_ok(param){return 0 === param[0]?1:0}
    function is_error(param){return 0 === param[0]?0:1}
    function ok(param){if(0 !== param[0])return 0;var x=param[1];return [0,x]}
    function error(param)
     {if(0 === param[0])return 0;var x=param[1];return [0,x]}
    function of_option(opt,error)
     {if(! opt)return [1,error];var x=opt[1];return [0,x]}
    function iter$2(v,f)
     {if(0 !== v[0])return 0;var x=v[1];return caml_call1(f,x)}
    function iter_error(v,f)
     {if(0 === v[0])return 0;var x=v[1];return caml_call1(f,x)}
    function to_either(param)
     {if(0 === param[0]){var x=param[1];return [0,x]}
      var x$0=param[1];
      return [1,x$0]}
    function of_either(param)
     {if(0 === param[0]){var x=param[1];return [0,x]}
      var x$0=param[1];
      return [1,x$0]}
    function ok_if_true(bool,error){return bool?_Y_:[1,error]}
    function try_with(f)
     {try
       {var _JT_=[0,caml_call1(f,0)];return _JT_}
      catch(exn){exn = caml_wrap_exception(exn);return [1,exn]}}
    function ok_exn(param)
     {if(0 === param[0]){var x=param[1];return x}var exn=param[1];throw exn}
    function ok_or_failwith(param)
     {if(0 === param[0]){var x=param[1];return x}
      var str=param[1];
      return caml_call1(failwith$0,str)}
    function combine(t1,t2,ok,err)
     {if(0 === t1[0])
       {var _JR_=t1[1];
        if(0 === t2[0]){var ok2=t2[1];return [0,caml_call2(ok,_JR_,ok2)]}
        var e=t2[1]}
      else
       {var _JS_=t1[1];
        if(0 !== t2[0]){var err2=t2[1];return [1,caml_call2(err,_JS_,err2)]}
        var e=_JS_}
      return [1,e]}
    function combine_errors(l)
     {var match=partition_map(l,to_either),errs=match[2],ok=match[1];
      return errs?[1,errs]:[0,ok]}
    function combine_errors_unit(l)
     {function _JQ_(param){return 0}
      return caml_call2(map$5,combine_errors(l),_JQ_)}
    var
     Base_Result=
      [0,
       t_of_sexp$12,
       sexp_of_t$16,
       t_sexp_grammar$9,
       compare$20,
       equal$9,
       hash_fold_t$13,
       symbol_bind$0,
       symbol_map$0,
       Let_syntax$0,
       include$26,
       bind$2,
       return$3,
       join$0,
       ignore_m$0,
       all$1,
       all_unit$0,
       Error,
       invariant$0,
       fail,
       failf,
       is_ok,
       is_error,
       ok,
       ok_exn,
       ok_or_failwith,
       error,
       of_option,
       iter$2,
       iter_error,
       map$5,
       map_error,
       combine,
       combine_errors,
       combine_errors_unit,
       to_either,
       of_either,
       to_either,
       ok_if_true,
       try_with,
       [0,is_ok,is_error]];
    caml_register_global(1023,Base_Result,"Base__Result");
    var
     Continue_or_stop=[0],
     include$27=[0,Continue_or_stop],
     Continue_or_stop$0=include$27[1],
     Base_Container_intf=[0,include$27,Continue_or_stop$0];
    caml_register_global(1024,Base_Container_intf,"Base__Container_intf");
    function iter$3(fold,t,f)
     {return caml_call3(fold,t,0,function(param,a){return caml_call1(f,a)})}
    function count(fold,t,f)
     {return caml_call3
              (fold,t,0,function(n,a){return caml_call1(f,a)?n + 1 | 0:n})}
    function sum(fold,M)
     {return function(t,f)
       {function _JO_(n,a)
         {var _JP_=caml_call1(f,a);return caml_call2(M[2],n,_JP_)}
        return caml_call3(fold,t,M[1],_JO_)}}
    function fold_result(fold,init,f,t)
     {return with_return
              (function(param)
                {return [0,
                         caml_call3
                          (fold,
                           t,
                           init,
                           function(acc,item)
                            {var e=caml_call2(f,acc,item);
                             if(0 !== e[0])return caml_call1(param,e);
                             var x=e[1];
                             return x})]})}
    function fold_until(fold,init,f,finish,t)
     {return with_return
              (function(param)
                {return caml_call1
                         (finish,
                          caml_call3
                           (fold,
                            t,
                            init,
                            function(acc,item)
                             {var match=caml_call2(f,acc,item);
                              if(0 === match[0]){var x=match[1];return x}
                              var x$0=match[1];
                              return caml_call1(param,x$0)}))})}
    function min_elt(fold,t,compare)
     {return caml_call3
              (fold,
               t,
               0,
               function(acc,elt)
                {if(! acc)return [0,elt];
                 var min=acc[1];
                 return 0 < caml_call2(compare,min,elt)?[0,elt]:acc})}
    function max_elt(fold,t,compare)
     {return caml_call3
              (fold,
               t,
               0,
               function(acc,elt)
                {if(! acc)return [0,elt];
                 var max=acc[1];
                 return 0 <= caml_call2(compare,max,elt)?acc:[0,elt]})}
    function length$0(fold,c)
     {return caml_call3(fold,c,0,function(acc,param){return acc + 1 | 0})}
    function is_empty$0(iter,c)
     {return with_return
              (function(r)
                {caml_call2(iter,c,function(param){return caml_call1(r,0)});
                 return 1})}
    function exists$0(iter,c,f)
     {return with_return
              (function(r)
                {caml_call2
                  (iter,
                   c,
                   function(x)
                    {var _JN_=caml_call1(f,x);return _JN_?caml_call1(r,1):_JN_});
                 return 0})}
    function for_all$0(iter,c,f)
     {return with_return
              (function(r)
                {caml_call2
                  (iter,
                   c,
                   function(x)
                    {var _JM_=1 - caml_call1(f,x);
                     return _JM_?caml_call1(r,0):_JM_});
                 return 1})}
    function find_map(iter,t,f)
     {return with_return
              (function(r)
                {caml_call2
                  (iter,
                   t,
                   function(x)
                    {var res=caml_call1(f,x);return res?caml_call1(r,res):0});
                 return 0})}
    function find(iter,c,f)
     {return with_return
              (function(r)
                {caml_call2
                  (iter,
                   c,
                   function(x)
                    {var _JL_=caml_call1(f,x);
                     return _JL_?caml_call1(r,[0,x]):_JL_});
                 return 0})}
    function to_list$0(fold,c)
     {return rev(caml_call3(fold,c,0,function(acc,x){return [0,x,acc]}))}
    function to_array(length,iter,c)
     {var array=[0,[0]],i=[0,0];
      caml_call2
       (iter,
        c,
        function(x)
         {if(0 === i[1])array[1] = caml_make_vect(caml_call1(length,c),x);
          var _JK_=i[1];
          caml_check_bound(array[1],_JK_)[1 + _JK_] = x;
          return incr(i)});
      return array[1]}
    function Make_gen(T)
     {var _JG_=T[1],_JH_=T[2];
      if(typeof _JH_ === "number")
       var _JI_=function(t,f){return iter$3(_JG_,t,f)};
      else
       var iter=_JH_[2],_JI_=iter;
      var _JJ_=T[3];
      if(typeof _JJ_ === "number")
       var length=function(t){return length$0(_JG_,t)};
      else
       var length$1=_JJ_[2],length=length$1;
      function is_empty(t){return is_empty$0(_JI_,t)}
      function sum$0(m,t){return caml_call1(sum(_JG_,m),t)}
      function count$0(t,f){return count(_JG_,t,f)}
      function exists(t,f){return exists$0(_JI_,t,f)}
      function for_all(t,f){return for_all$0(_JI_,t,f)}
      function find_map$0(t,f){return find_map(_JI_,t,f)}
      function find$0(t,f){return find(_JI_,t,f)}
      function to_list(t){return to_list$0(_JG_,t)}
      function to_array$0(t){return to_array(length,_JI_,t)}
      function min_elt$0(t,compare){return min_elt(_JG_,t,compare)}
      function max_elt$0(t,compare){return max_elt(_JG_,t,compare)}
      function fold_result$0(t,init,f){return fold_result(_JG_,init,f,t)}
      function fold_until$0(t,init,f,finish)
       {return fold_until(_JG_,init,f,finish,t)}
      return [0,
              length,
              is_empty,
              _JI_,
              _JG_,
              fold_result$0,
              fold_until$0,
              exists,
              for_all,
              count$0,
              sum$0,
              find$0,
              find_map$0,
              to_list,
              to_array$0,
              min_elt$0,
              max_elt$0]}
    function _Z_(T)
     {var
       fold=T[2],
       iter=T[3],
       length=T[4],
       include=Make_gen([0,fold,iter,length]),
       length$0=include[1],
       is_empty=include[2],
       iter$0=include[3],
       fold$0=include[4],
       fold_result=include[5],
       fold_until=include[6],
       exists=include[7],
       for_all=include[8],
       count=include[9],
       sum=include[10],
       find=include[11],
       find_map=include[12],
       to_list=include[13],
       to_array=include[14],
       min_elt=include[15],
       max_elt=include[16];
      function mem(t,elt){return caml_call2(exists,t,caml_call1(T[1][1],elt))}
      return [0,
              mem,
              length$0,
              is_empty,
              iter$0,
              fold$0,
              fold_result,
              fold_until,
              exists,
              for_all,
              count,
              sum,
              find,
              find_map,
              to_list,
              to_array,
              min_elt,
              max_elt]}
    function ___(T)
     {var
       fold=T[1],
       iter=T[2],
       length=T[3],
       include=Make_gen([0,fold,iter,length]),
       length$0=include[1],
       is_empty=include[2],
       iter$0=include[3],
       fold$0=include[4],
       fold_result=include[5],
       fold_until=include[6],
       exists=include[7],
       for_all=include[8],
       count=include[9],
       sum=include[10],
       find=include[11],
       find_map=include[12],
       to_list=include[13],
       to_array=include[14],
       min_elt=include[15],
       max_elt=include[16];
      function mem(t,a,equal){return caml_call2(exists,t,caml_call1(equal,a))}
      return [0,
              mem,
              length$0,
              is_empty,
              iter$0,
              fold$0,
              fold_result,
              fold_until,
              exists,
              for_all,
              count,
              sum,
              find,
              find_map,
              to_list,
              to_array,
              min_elt,
              max_elt]}
    var
     Base_Container=
      [0,
       iter$3,
       count,
       min_elt,
       max_elt,
       length$0,
       to_list$0,
       sum,
       fold_result,
       fold_until,
       is_empty$0,
       exists$0,
       for_all$0,
       find,
       find_map,
       to_array,
       ___,
       _Z_,
       Make_gen];
    caml_register_global(1025,Base_Container,"Base__Container");
    var
     Undefined=Stdlib_Lazy[1],
     is_val=Stdlib_Lazy[3],
     from_val=Stdlib_Lazy[4],
     from_fun=Stdlib_Lazy[6],
     force_val=Stdlib_Lazy[7];
    function t_sexp_grammar$10(a_sexp_grammar)
     {return caml_call1(lazy_t_sexp_grammar,a_sexp_grammar)}
    function _$_(t,f)
     {return [246,
              function(_JD_)
               {var
                 _JE_=caml_obj_tag(t),
                 _JF_=
                  250 === _JE_
                   ?t[1]
                   :246 === _JE_?caml_call1(CamlinternalLazy[2],t):t;
                return caml_call1(f,_JF_)}]}
    function compare$21(compare_a,t1,t2)
     {if(t1 === t2)return 0;
      var
       _Jz_=caml_obj_tag(t2),
       _JA_=
        250 === _Jz_?t2[1]:246 === _Jz_?caml_call1(CamlinternalLazy[2],t2):t2,
       _JB_=caml_obj_tag(t1),
       _JC_=
        250 === _JB_?t1[1]:246 === _JB_?caml_call1(CamlinternalLazy[2],t1):t1;
      return caml_call2(compare_a,_JC_,_JA_)}
    function equal$10(equal_a,t1,t2)
     {if(t1 === t2)return 1;
      var
       _Jv_=caml_obj_tag(t2),
       _Jw_=
        250 === _Jv_?t2[1]:246 === _Jv_?caml_call1(CamlinternalLazy[2],t2):t2,
       _Jx_=caml_obj_tag(t1),
       _Jy_=
        250 === _Jx_?t1[1]:246 === _Jx_?caml_call1(CamlinternalLazy[2],t1):t1;
      return caml_call2(equal_a,_Jy_,_Jw_)}
    var hash_fold_t$14=_l_[12];
    function return$5(x){return caml_call1(from_val,x)}
    function bind$4(t,f)
     {return [246,
              function(_Jq_)
               {var
                 _Jr_=caml_obj_tag(t),
                 _Js_=
                  250 === _Jr_
                   ?t[1]
                   :246 === _Jr_?caml_call1(CamlinternalLazy[2],t):t,
                 _Jt_=caml_call1(f,_Js_),
                 _Ju_=caml_obj_tag(_Jt_);
                return 250 === _Ju_
                        ?_Jt_[1]
                        :246 === _Ju_?caml_call1(CamlinternalLazy[2],_Jt_):_Jt_}]}
    var
     map$7=[0,-198771759,_$_],
     include$28=Make([0,bind$4,return$5,map$7]),
     symbol_bind$1=include$28[1],
     symbol_map$1=include$28[2],
     Monad_infix$0=include$28[3],
     bind$5=include$28[4],
     return$6=include$28[5],
     map$8=include$28[6],
     join$1=include$28[7],
     ignore_m$1=include$28[8],
     all$2=include$28[9],
     all_unit$1=include$28[10],
     Let_syntax$1=include$28[11];
    function sexp_of_t$17(sexp_of_a,t)
     {if(! caml_call1(is_val,t))
       return caml_call1(sexp_of_t$2,cst_unforced_lazy);
      var
       _Jo_=caml_obj_tag(t),
       _Jp_=250 === _Jo_?t[1]:246 === _Jo_?caml_call1(CamlinternalLazy[2],t):t;
      return caml_call1(sexp_of_a,_Jp_)}
    var
     T_unforcing=[0,sexp_of_t$17],
     Base_Lazy=
      [0,
       compare$21,
       equal$10,
       hash_fold_t$14,
       t_of_sexp$9,
       sexp_of_t$9,
       t_sexp_grammar$10,
       symbol_bind$1,
       symbol_map$1,
       Monad_infix$0,
       bind$5,
       return$6,
       map$8,
       join$1,
       ignore_m$1,
       all$2,
       all_unit$1,
       Let_syntax$1,
       Undefined,
       force_val,
       from_fun,
       from_val,
       is_val,
       T_unforcing];
    caml_register_global(1027,Base_Lazy,"Base__Lazy");
    var Base_Info_intf=[0];
    caml_register_global(1028,Base_Info_intf,"Base__Info_intf");
    function slow_check_pos_len_exn(pos,len,total_length)
     {if(pos < 0)caml_call2(invalid_argf(_aa_),pos,0);
      if(len < 0)caml_call2(invalid_argf(_ab_),len,0);
      var _Jn_=(total_length - len | 0) < pos?1:0;
      return _Jn_?caml_call4(invalid_argf(_ac_),pos,len,total_length,0):_Jn_}
    function check_pos_len_exn(pos,len,total_length)
     {var
       stop=pos + len | 0,
       _Jm_=(pos | len | stop | total_length - stop | 0) < 0?1:0;
      return _Jm_?slow_check_pos_len_exn(pos,len,total_length):_Jm_}
    function get_pos_len_exn(opt,len,param,total_length)
     {if(opt)var sth=opt[1],pos=sth;else var pos=0;
      if(len)var i=len[1],len$0=i;else var len$0=total_length - pos | 0;
      check_pos_len_exn(pos,len$0,total_length);
      return [0,pos,len$0]}
    var
     Private$1=[0,slow_check_pos_len_exn],
     include$29=[0,get_pos_len_exn,check_pos_len_exn,Private$1];
    caml_register_global(1029,include$29,"Base__Ordered_collection_common0");
    function of_state(_Jl_){return _Jl_}
    var Repr=[0,of_state];
    function assign(t1,t2)
     {var
       _Jh_=caml_obj_tag(t1),
       _Ji_=
        250 === _Jh_?t1[1]:246 === _Jh_?caml_call1(CamlinternalLazy[2],t1):t1,
       t1$0=caml_call1(Repr[1],_Ji_),
       _Jj_=caml_obj_tag(t2),
       _Jk_=
        250 === _Jj_?t2[1]:246 === _Jj_?caml_call1(CamlinternalLazy[2],t2):t2,
       t2$0=caml_call1(Repr[1],_Jk_);
      caml_call5(blit,t2$0[1],0,t1$0[1],0,t1$0[1].length - 1);
      t1$0[2] = t2$0[2];
      return 0}
    function make_default(default$0){return default$0}
    function get_state(state){return state}
    var Base_Random_repr=[0,Repr,assign,make_default,get_state];
    caml_register_global(1030,Base_Random_repr,"Base__Random_repr");
    function forbid_nondeterminism_in_tests(allow_in_tests)
     {if(! am_testing)return am_testing;
      if(allow_in_tests && allow_in_tests[1])return 0;
      return caml_call1(failwith$0,cst_initializing_Random_with_a)}
    function bits(t)
     {var
       _Jf_=caml_obj_tag(t),
       _Jg_=250 === _Jf_?t[1]:246 === _Jf_?caml_call1(CamlinternalLazy[2],t):t;
      return caml_call1(Stdlib_Random[15][4],_Jg_)}
    function bool(t)
     {var
       _Jd_=caml_obj_tag(t),
       _Je_=250 === _Jd_?t[1]:246 === _Jd_?caml_call1(CamlinternalLazy[2],t):t;
      return caml_call1(Stdlib_Random[15][11],_Je_)}
    function int$0(t,x)
     {var
       _Jb_=caml_obj_tag(t),
       _Jc_=250 === _Jb_?t[1]:246 === _Jb_?caml_call1(CamlinternalLazy[2],t):t;
      return caml_call2(Stdlib_Random[15][5],_Jc_,x)}
    function int32(t,x)
     {var
       _I$_=caml_obj_tag(t),
       _Ja_=250 === _I$_?t[1]:246 === _I$_?caml_call1(CamlinternalLazy[2],t):t;
      return caml_call2(Stdlib_Random[15][7],_Ja_,x)}
    function int64(t,x)
     {var
       _I9_=caml_obj_tag(t),
       _I__=250 === _I9_?t[1]:246 === _I9_?caml_call1(CamlinternalLazy[2],t):t;
      return caml_call2(Stdlib_Random[15][9],_I__,x)}
    function nativeint(t,x)
     {var
       _I7_=caml_obj_tag(t),
       _I8_=250 === _I7_?t[1]:246 === _I7_?caml_call1(CamlinternalLazy[2],t):t;
      return caml_call2(Stdlib_Random[15][8],_I8_,x)}
    function make$2(seed)
     {return caml_call1(from_val,caml_call1(Stdlib_Random[15][1],seed))}
    function copy$2(t)
     {var
       _I5_=caml_obj_tag(t),
       _I6_=250 === _I5_?t[1]:246 === _I5_?caml_call1(CamlinternalLazy[2],t):t;
      return caml_call1(from_val,caml_call1(Stdlib_Random[15][3],_I6_))}
    function char$0(t){return int$0(t,256)}
    function ascii(t){return int$0(t,128)}
    function make_self_init(allow_in_tests,param)
     {forbid_nondeterminism_in_tests(allow_in_tests);
      return caml_call1(from_val,caml_call1(Stdlib_Random[15][2],0))}
    if(am_testing)
     {var t=caml_call1(Stdlib_Random[16],0);
      caml_call1(Stdlib_Random[1],137);
      var _ad_=caml_call1(from_val,t)}
    else
     var
      _ad_=
       [246,
        function(_I2_)
         {var _I3_=make_self_init(0,0),_I4_=caml_obj_tag(_I3_);
          return 250 === _I4_
                  ?_I3_[1]
                  :246 === _I4_?caml_call1(CamlinternalLazy[2],_I3_):_I3_}];
    function int_on_64bits(t,bound)
     {return 1073741823 < bound
              ?caml_int64_to_int32(int64(t,caml_int64_of_int32(bound)))
              :int$0(t,bound)}
    function int_on_32bits(t,bound)
     {return 1073741823 < bound?int32(t,bound):int$0(t,bound)}
    var int$1=word_size?int_on_64bits:int_on_32bits;
    function bits$0(state){return caml_int64_of_int32(bits(state))}
    function full_range_int64(state)
     {var
       _I0_=caml_int64_shift_left(bits$0(state),60),
       _I1_=caml_int64_xor(caml_int64_shift_left(bits$0(state),30),_I0_);
      return caml_int64_xor(bits$0(state),_I1_)}
    function bits$1(state){return bits(state)}
    function full_range_int32(state)
     {var _IZ_=bits$1(state) << 30;return bits$1(state) ^ _IZ_}
    function full_range_int_on_64bits(state)
     {return caml_int64_to_int32(full_range_int64(state))}
    function full_range_int_on_32bits(state){return full_range_int32(state)}
    var
     full_range_int_on_64bits$0=
      word_size?full_range_int_on_64bits:full_range_int_on_32bits;
    function full_range_nativeint_on_64bits(state)
     {return caml_int64_to_int32(full_range_int64(state))}
    function full_range_nativeint_on_32bits(state)
     {return full_range_int32(state)}
    var
     full_range_nativeint=
      word_size?full_range_nativeint_on_64bits:full_range_nativeint_on_32bits;
    function raise_crossed_bounds
     (name,lower_bound,upper_bound,string_of_bound)
     {var
       _IX_=caml_call1(string_of_bound,upper_bound),
       _IY_=caml_call1(string_of_bound,lower_bound);
      return caml_call4(failwithf(_ae_),name,_IY_,_IX_,0)}
    function int_incl(state,lo,hi)
     {if(hi < lo)raise_crossed_bounds(cst_int,lo,hi,to_string);
      var diff=hi - lo | 0;
      if(diff === max_value$0)
       return lo + (full_range_int_on_64bits$0(state) & max_value$0) | 0;
      if(0 <= diff)return lo + int$1(state,diff + 1 | 0) | 0;
      for(;;)
       {var int$0=full_range_int_on_64bits$0(state);
        if(lo <= int$0 && int$0 <= hi)return int$0}}
    function int32_incl(state,lo,hi)
     {if(caml_call2(Int32_replace_polymorphic_comp[5],lo,hi))
       raise_crossed_bounds(cst_int32,lo,hi,Stdlib_Int32[14]);
      var diff=hi - lo | 0;
      if(caml_call2(Int32_replace_polymorphic_comp[4],diff,Stdlib_Int32[9]))
       {var _IW_=Stdlib_Int32[9];
        return lo + (full_range_int32(state) & _IW_) | 0}
      if(caml_call2(Int32_replace_polymorphic_comp[6],diff,0))
       return lo + int32(state,caml_call1(Stdlib_Int32[6],diff)) | 0;
      for(;;)
       {var int$0=full_range_int32(state);
        if
         (caml_call2(Int32_replace_polymorphic_comp[6],int$0,lo)
          &&
          caml_call2(Int32_replace_polymorphic_comp[2],int$0,hi))
         return int$0}}
    function nativeint_incl(state,lo,hi)
     {if(caml_call2(include$3[5],lo,hi))
       raise_crossed_bounds(cst_nativeint,lo,hi,Stdlib_Nativeint[15]);
      var diff=hi - lo | 0;
      if(caml_call2(include$3[4],diff,Stdlib_Nativeint[10]))
       {var _IV_=Stdlib_Nativeint[10];
        return lo + (full_range_nativeint(state) & _IV_) | 0}
      if(caml_call2(include$3[6],diff,0))
       return lo + nativeint(state,caml_call1(Stdlib_Nativeint[6],diff)) | 0;
      for(;;)
       {var int$0=full_range_nativeint(state);
        if
         (caml_call2(include$3[6],int$0,lo)
          &&
          caml_call2(include$3[2],int$0,hi))
         return int$0}}
    function int64_incl(state,lo,hi)
     {if(caml_greaterthan(lo,hi))
       raise_crossed_bounds(cst_int64,lo,hi,Stdlib_Int64[14]);
      var diff=caml_int64_sub(hi,lo);
      if(caml_equal(diff,Stdlib_Int64[9]))
       {var _IU_=Stdlib_Int64[9];
        return caml_int64_add(lo,caml_int64_and(full_range_int64(state),_IU_))}
      if(caml_greaterequal(diff,_af_))
       return caml_int64_add(lo,int64(state,caml_call1(Stdlib_Int64[6],diff)));
      for(;;)
       {var int$0=full_range_int64(state);
        if(caml_greaterequal(int$0,lo) && caml_lessequal(int$0,hi))
         return int$0}}
    function float$0(state,hi)
     {for(;;)
       {var
         r1=bits(state),
         r2=bits(state),
         result=(r1 * 9.31322574615478516e-10 + r2) * 9.31322574615478516e-10;
        if(caml_call2(include$7[1],result,1.))return result * hi}}
    function float_range(state,lo,hi)
     {if(caml_call2(include$7[5],lo,hi))
       raise_crossed_bounds(cst_float,lo,hi,Caml$0[34]);
      return lo + float$0(state,hi - lo)}
    function bits$2(param){return bits(_ad_)}
    function int$2(x){return int$1(_ad_,x)}
    function int32$0(x){return int32(_ad_,x)}
    function nativeint$0(x){return nativeint(_ad_,x)}
    function int64$0(x){return int64(_ad_,x)}
    function float$1(x){return float$0(_ad_,x)}
    function int_incl$0(x,y){return int_incl(_ad_,x,y)}
    function int32_incl$0(x,y){return int32_incl(_ad_,x,y)}
    function nativeint_incl$0(x,y){return nativeint_incl(_ad_,x,y)}
    function int64_incl$0(x,y){return int64_incl(_ad_,x,y)}
    function float_range$0(x,y){return float_range(_ad_,x,y)}
    function bool$0(param){return bool(_ad_)}
    function char$1(param){return char$0(_ad_)}
    function ascii$0(param){return ascii(_ad_)}
    function full_init(seed){return assign(_ad_,make$2(seed))}
    function init$0(seed){return full_init([0,seed])}
    function self_init(allow_in_tests,param)
     {forbid_nondeterminism_in_tests(allow_in_tests);
      return full_init(runtime.caml_sys_random_seed(0))}
    function set_state(s){return assign(_ad_,s)}
    var
     _ag_=
      [0,
       _ad_,
       make$2,
       make_self_init,
       copy$2,
       bits,
       int$1,
       int32,
       nativeint,
       int64,
       float$0,
       int_incl,
       int32_incl,
       nativeint_incl,
       int64_incl,
       float_range,
       bool,
       char$0,
       ascii],
     Base_Random=
      [0,
       init$0,
       full_init,
       self_init,
       bits$2,
       int$2,
       int32$0,
       nativeint$0,
       int64$0,
       float$1,
       int_incl$0,
       int32_incl$0,
       nativeint_incl$0,
       int64_incl$0,
       float_range$0,
       bool$0,
       char$1,
       ascii$0,
       _ag_,
       set_state];
    caml_register_global(1035,Base_Random,"Base__Random");
    function permute(opt,_IS_,len,t)
     {if(opt)var sth=opt[1],random_state=sth;else var random_state=_ag_[1];
      if(_IS_)var sth$0=_IS_[1],pos=sth$0;else var pos=0;
      var total_length=t.length - 1;
      if(len)var l=len[1],len$0=l;else var len$0=total_length - pos | 0;
      check_pos_len_exn(pos,len$0,total_length);
      var num_swaps=len$0 - 1 | 0;
      if(num_swaps >= 1)
       {var i=num_swaps;
        for(;;)
         {var
           this_i=pos + i | 0,
           random_i=pos + caml_call2(_ag_[6],random_state,i + 1 | 0) | 0;
          swap(t,this_i,random_i);
          var _IT_=i - 1 | 0;
          if(1 !== i){var i=_IT_;continue}
          break}}
      return 0}
    var
     Base_Array_permute=
      [0,
       invalid_argf,
       Array,
       max_length$0,
       create,
       create_float_uninitialized,
       append,
       blit,
       concat,
       copy,
       fill,
       init,
       make_matrix,
       of_list,
       sub$0,
       to_list,
       fold,
       fold_right,
       iter,
       iteri,
       map,
       mapi,
       stable_sort,
       swap,
       permute];
    caml_register_global(1036,Base_Array_permute,"Base__Array_permute");
    var Base_Equal=[0];
    caml_register_global(1037,Base_Equal,"Base__Equal");
    function const$0(c,param){return c}
    function non(f,x){return 1 - caml_call1(f,x)}
    function forever(f)
     {function forever(param){for(;;)caml_call1(f,0)}
      try
       {var _IR_=forever(0);return _IR_}
      catch(e){e = caml_wrap_exception(e);return e}}
    function compose(f,g,x){return caml_call1(f,caml_call1(g,x))}
    function flip(f,x,y){return caml_call2(f,y,x)}
    function apply_n_times(n,f,x)
     {var n$0=n,x$0=x;
      for(;;)
       {if(0 >= n$0)return x$0;
        var x$1=caml_call1(f,x$0),n$1=n$0 - 1 | 0,n$0=n$1,x$0=x$1}}
    var Base_Fn=[0,const$0,non,forever,apply_n_times,compose,flip];
    caml_register_global(1038,Base_Fn,"Base__Fn");
    var compare$22=caml_int_compare;
    function hash_fold_t$15(hsv,arg)
     {switch(arg)
       {case 0:return runtime.Base_internalhash_fold_int(hsv,0);
        case 1:return runtime.Base_internalhash_fold_int(hsv,1);
        default:return runtime.Base_internalhash_fold_int(hsv,2)}}
    function hash$2(x)
     {var hsv=create$0(0,0);
      return runtime.Base_internalhash_get_hash_value(hash_fold_t$15(hsv,x))}
    function t_of_sexp$13(sexp_006)
     {if(0 === sexp_006[0])
       {var _IN_=sexp_006[1],switch$0=0;
        if(caml_string_notequal(_IN_,cst_Equal))
         {var switch$1=0;
          if(caml_string_notequal(_IN_,cst_Greater))
           {var switch$2=0;
            if(caml_string_notequal(_IN_,cst_Less))
             if(caml_string_notequal(_IN_,cst_equal))
              if(caml_string_notequal(_IN_,cst_greater))
               {if(caml_string_notequal(_IN_,cst_less))
                 {switch$0 = 1;switch$1 = 1;switch$2 = 1}}
              else
               switch$2 = 1;
             else
              {switch$1 = 1;switch$2 = 1}
            if(! switch$2)return 0}
          if(! switch$1)return 2}
        if(! switch$0)return 1}
      else
       {var _IO_=sexp_006[1];
        if(! _IO_)
         return caml_call2
                 (Sexplib0_Sexp_conv_error[7],error_source_005$0,sexp_006);
        var _IP_=_IO_[1];
        if(0 !== _IP_[0])
         return caml_call2
                 (Sexplib0_Sexp_conv_error[6],error_source_005$0,sexp_006);
        var _IQ_=_IP_[1],switch$3=0;
        if(caml_string_notequal(_IQ_,cst_Equal$0))
         {var switch$4=0;
          if(caml_string_notequal(_IQ_,cst_Greater$0))
           {var switch$5=0;
            if(caml_string_notequal(_IQ_,cst_Less$0))
             if(caml_string_notequal(_IQ_,cst_equal$0))
              if(caml_string_notequal(_IQ_,cst_greater$0))
               {if(caml_string_notequal(_IQ_,cst_less$0))
                 {switch$3 = 1;switch$4 = 1;switch$5 = 1}}
              else
               switch$5 = 1;
             else
              {switch$4 = 1;switch$5 = 1}
            if(! switch$5)
             return caml_call2
                     (Sexplib0_Sexp_conv_error[3],error_source_005$0,sexp_006)}
          if(! switch$4)
           return caml_call2
                   (Sexplib0_Sexp_conv_error[3],error_source_005$0,sexp_006)}
        if(! switch$3)
         return caml_call2
                 (Sexplib0_Sexp_conv_error[3],error_source_005$0,sexp_006)}
      return caml_call2
              (Sexplib0_Sexp_conv_error[8],error_source_005$0,sexp_006)}
    function sexp_of_t$18(param)
     {switch(param){case 0:return _ah_;case 1:return _ai_;default:return _aj_}}
    function equal$11(a,b){return 0 === caml_int_compare(a,b)?1:0}
    var Export=[0];
    function of_int$0(n){return 0 <= n?0 === n?1:2:0}
    function to_int$0(param)
     {switch(param){case 0:return -1;case 1:return 0;default:return 1}}
    var
     Base_Ordering=
      [0,
       compare$22,
       hash_fold_t$15,
       hash$2,
       t_of_sexp$13,
       sexp_of_t$18,
       t_sexp_grammar$11,
       all$3,
       equal$11,
       of_int$0,
       to_int$0,
       Export];
    caml_register_global(1039,Base_Ordering,"Base__Ordering");
    var
     Base_Sys=
      [0,
       get_argv,
       argv,
       interactive,
       os_type,
       unix,
       win32,
       cygwin,
       backend_type,
       word_size_in_bits,
       num_bits,
       big_endian,
       max_length,
       max_length$0,
       runtime_variant,
       runtime_parameters,
       ocaml_version,
       enable_runtime_warnings,
       runtime_warnings_enabled,
       getenv,
       getenv_exn];
    caml_register_global(1040,Base_Sys,"Base__Sys");
    function t_sexp_grammar$12(a_sexp_grammar)
     {return caml_call1(list_sexp_grammar,a_sexp_grammar)}
    function compare$23(cmp_a,a_006,b_007)
     {if(a_006 === b_007)return 0;
      if(! a_006)return b_007?1:0;
      var _IM_=a_006[1];
      if(! b_007)return -1;
      var b_009=b_007[1];
      return caml_call2(cmp_a,_IM_,b_009)}
    function sexp_of_t$19(of_a_010,param)
     {if(! param)return _al_;
      var arg0_011=param[1],res0_012=caml_call1(of_a_010,arg0_011);
      return [1,[0,_ak_,[0,res0_012,0]]]}
    var Or_unequal_lengths=[0,compare$23,sexp_of_t$19];
    function invariant$1(f,t){return iter$0(t,f)}
    function of_list$0(t){return t}
    function range(compare,stride,opt,_IK_,start_i,stop_i)
     {if(opt)var sth=opt[1],start=sth;else var start=104758188;
      if(_IK_)var sth$0=_IK_[1],stop=sth$0;else var stop=-160346914;
      var next_i=caml_call1(stride,start_i);
      function order(x,y){return of_int$0(caml_call2(compare,x,y))}
      function raise_stride_cannot_return_sam(param)
       {return caml_call1(invalid_arg$0,cst_List_range_stride_function)}
      var match=order(start_i,next_i);
      switch(match)
       {case 0:var initial_stride_order=847855481;break;
        case 1:
         var initial_stride_order=raise_stride_cannot_return_sam(0);break;
        default:var initial_stride_order=85047514}
      var start_i$0=104758188 <= start?start_i:next_i,i=start_i$0,accum=0;
      for(;;)
       {var i_to_stop_order=order(i,stop_i),switch$0=0;
        switch(i_to_stop_order)
         {case 0:switch$0 = 847855481 <= initial_stride_order?1:2;break;
          case 1:var _IL_=104758188 <= stop?[0,i,accum]:accum;break;
          default:switch$0 = 847855481 <= initial_stride_order?2:1}
        switch(switch$0)
         {case 1:
           var
            next_i$0=caml_call1(stride,i),
            match$0=order(i,next_i$0),
            switch$1=0;
           switch(match$0)
            {case 0:switch$1 = 847855481 <= initial_stride_order?2:1;break;
             case 1:var _IL_=raise_stride_cannot_return_sam(0);break;
             default:switch$1 = 847855481 <= initial_stride_order?1:2}
           switch(switch$1)
            {case 1:
              var
               _IL_=
                caml_call1(invalid_arg$0,cst_List_range_stride_function$0);
              break;
             case 2:var accum$0=[0,i,accum],i=next_i$0,accum=accum$0;continue
             }
           break;
          case 2:var _IL_=accum;break
          }
        return rev(_IL_)}}
    function range$0(opt,_IH_,_IG_,start_i,stop_i)
     {if(opt)var sth=opt[1],stride=sth;else var stride=1;
      if(_IH_)var sth$0=_IH_[1],start=sth$0;else var start=104758188;
      if(_IG_)var sth$1=_IG_[1],stop=sth$1;else var stop=-160346914;
      if(0 === stride)
       caml_call1(invalid_arg$0,cst_List_range_stride_must_be_);
      var _II_=[0,stop],_IJ_=[0,start];
      return range
              (caml_int_compare,
               function(x){return x + stride | 0},
               _IJ_,
               _II_,
               start_i,
               stop_i)}
    function hd(t){if(! t)return 0;var x=t[1];return [0,x]}
    function tl(t){if(! t)return 0;var t$0=t[2];return [0,t$0]}
    function nth(t,n)
     {if(0 > n)return 0;
      var t$0=t,n$0=n;
      for(;;)
       {if(! t$0)return 0;
        var t$1=t$0[2],a=t$0[1];
        if(0 === n$0)return [0,a];
        var n$1=n$0 - 1 | 0,t$0=t$1,n$0=n$1}}
    function nth_exn(t,n)
     {var match=nth(t,n);
      if(match){var a=match[1];return a}
      var _IF_=caml_call1(length,t);
      return caml_call3(invalid_argf(_am_),n,_IF_,0)}
    function unordered_append(l1,l2)
     {if(l1){if(l2)return caml_call2(rev_append,l1,l2);var l=l1}else var l=l2;
      return l}
    function of_lists(a,b)
     {var a$0=a,b$0=b,shared_length=0;
      for(;;)
       {if(a$0)
         {if(b$0)
           {var
             b$1=b$0[2],
             a$1=a$0[2],
             shared_length$0=shared_length + 1 | 0,
             a$0=a$1,
             b$0=b$1,
             shared_length=shared_length$0;
            continue}}
        else
         if(! b$0)return [0,shared_length];
        return [1,shared_length,a$0,b$0]}}
    function check_length2_exn(name,l1,l2)
     {var match=of_lists(l1,l2);
      if(0 === match[0])return 0;
      var
       tail_of_b=match[3],
       tail_of_a=match[2],
       shared_length=match[1],
       _ID_=shared_length + caml_call1(length,tail_of_b) | 0,
       _IE_=shared_length + caml_call1(length,tail_of_a) | 0;
      return caml_call4(invalid_argf(_an_),name,_IE_,_ID_,0)}
    function check_length2(l1,l2,f)
     {var match=of_lists(l1,l2);
      return 0 === match[0]?[0,caml_call2(f,l1,l2)]:0}
    function of_lists$0(a,b,c)
     {var a$0=a,b$0=b,c$0=c,shared_length=0;
      for(;;)
       {if(a$0)
         {if(b$0 && c$0)
           {var
             c$1=c$0[2],
             b$1=b$0[2],
             a$1=a$0[2],
             shared_length$0=shared_length + 1 | 0,
             a$0=a$1,
             b$0=b$1,
             c$0=c$1,
             shared_length=shared_length$0;
            continue}}
        else
         if(! b$0 && ! c$0)return [0,shared_length];
        return [1,shared_length,a$0,b$0,c$0]}}
    function check_length3_exn(name,l1,l2,l3)
     {var match=of_lists$0(l1,l2,l3);
      if(0 === match[0])return 0;
      var
       tail_of_c=match[4],
       tail_of_b=match[3],
       tail_of_a=match[2],
       shared_length=match[1],
       n1=shared_length + caml_call1(length,tail_of_a) | 0,
       n2=shared_length + caml_call1(length,tail_of_b) | 0,
       n3=shared_length + caml_call1(length,tail_of_c) | 0;
      return caml_call6(invalid_argf(_ao_),name,n1,n2,n2,n3,0)}
    function check_length3(l1,l2,l3,f)
     {var match=of_lists$0(l1,l2,l3);
      return 0 === match[0]?[0,caml_call3(f,l1,l2,l3)]:0}
    function iter2(l1,l2,f)
     {return check_length2
              (l1,
               l2,
               function(_IB_)
                {return function(_IC_){return iter2_ok(_IB_,_IC_,f)}})}
    function iter2_exn(l1,l2,f)
     {check_length2_exn(cst_iter2_exn,l1,l2);return iter2_ok(l1,l2,f)}
    function rev_map2(l1,l2,f)
     {return check_length2
              (l1,
               l2,
               function(_Iz_)
                {return function(_IA_){return rev_map2_ok(_Iz_,_IA_,f)}})}
    function rev_map2_exn(l1,l2,f)
     {check_length2_exn(cst_rev_map2_exn,l1,l2);return rev_map2_ok(l1,l2,f)}
    function fold2(l1,l2,init,f)
     {return check_length2
              (l1,
               l2,
               function(_Ix_)
                {return function(_Iy_){return fold2_ok(_Ix_,_Iy_,init,f)}})}
    function fold2_exn(l1,l2,init,f)
     {check_length2_exn(cst_fold2_exn,l1,l2);return fold2_ok(l1,l2,init,f)}
    function for_all2(l1,l2,f)
     {return check_length2
              (l1,
               l2,
               function(_Iv_)
                {return function(_Iw_){return for_all2_ok(_Iv_,_Iw_,f)}})}
    function for_all2_exn(l1,l2,f)
     {check_length2_exn(cst_for_all2_exn,l1,l2);return for_all2_ok(l1,l2,f)}
    function exists2(l1,l2,f)
     {return check_length2
              (l1,
               l2,
               function(_It_)
                {return function(_Iu_){return exists2_ok(_It_,_Iu_,f)}})}
    function exists2_exn(l1,l2,f)
     {check_length2_exn(cst_exists2_exn,l1,l2);return exists2_ok(l1,l2,f)}
    function mem(param,a,equal)
     {var param$0=param;
      for(;;)
       {if(! param$0)return 0;
        var bs=param$0[2],b=param$0[1],_Is_=caml_call2(equal,a,b);
        if(_Is_)return _Is_;
        var param$0=bs}}
    function rev_filter(param,f)
     {var accu=0,param$0=param;
      for(;;)
       {if(! param$0)return accu;
        var l=param$0[2],x=param$0[1];
        if(caml_call1(f,x))
         {var accu$0=[0,x,accu],accu=accu$0,param$0=l;continue}
        var param$0=l}}
    function filter(t,f){return rev(rev_filter(t,f))}
    function find_map$0(param,f)
     {var param$0=param;
      for(;;)
       {if(! param$0)return 0;
        var l=param$0[2],x=param$0[1],r=caml_call1(f,x);
        if(r)return r;
        var param$0=l}}
    var not_found=[0,Not_found_s,_ap_];
    function find_map_exn(t,f)
     {var match=find_map$0(t,f);
      if(! match)throw not_found;
      var x=match[1];
      return x}
    function find$0(param,f)
     {var param$0=param;
      for(;;)
       {if(! param$0)return 0;
        var l=param$0[2],x=param$0[1];
        if(caml_call1(f,x))return [0,x];
        var param$0=l}}
    var not_found$0=[0,Not_found_s,_aq_];
    function find_exn(t,f)
     {var t$0=t;
      for(;;)
       {if(! t$0)throw not_found$0;
        var t$1=t$0[2],x=t$0[1];
        if(caml_call1(f,x))return x;
        var t$0=t$1}}
    function findi(t,f)
     {var i=0,t$0=t;
      for(;;)
       {if(! t$0)return 0;
        var l=t$0[2],x=t$0[1];
        if(caml_call2(f,i,x))return [0,[0,i,x]];
        var i$0=i + 1 | 0,i=i$0,t$0=l}}
    var not_found$1=[0,Not_found_s,_ar_];
    function findi_exn(t,f)
     {var match=findi(t,f);
      if(! match)throw not_found$1;
      var x=match[1];
      return x}
    function find_mapi(t,f)
     {var i=0,t$0=t;
      for(;;)
       {if(! t$0)return 0;
        var l=t$0[2],x=t$0[1],result=caml_call2(f,i,x);
        if(result)return result;
        var i$0=i + 1 | 0,i=i$0,t$0=l}}
    var not_found$2=[0,Not_found_s,_as_];
    function find_mapi_exn(t,f)
     {var match=find_mapi(t,f);
      if(! match)throw not_found$2;
      var x=match[1];
      return x}
    function for_alli(t,f)
     {var i=0,t$0=t;
      for(;;)
       {if(! t$0)return 1;
        var tl=t$0[2],hd=t$0[1],_Ir_=caml_call2(f,i,hd);
        if(! _Ir_)return _Ir_;
        var i$0=i + 1 | 0,i=i$0,t$0=tl}}
    function existsi(t,f)
     {var i=0,t$0=t;
      for(;;)
       {if(! t$0)return 0;
        var tl=t$0[2],hd=t$0[1],_Iq_=caml_call2(f,i,hd);
        if(_Iq_)return _Iq_;
        var i$0=i + 1 | 0,i=i$0,t$0=tl}}
    function to_list$1(t){return t}
    var max_non_tailcall=typeof backend_type === "number"?1000:50;
    function count_append(l1,l2,count)
     {if(! l2)return l1;
      if(! l1)return l2;
      var _Ih_=l1[2],_Ii_=l1[1];
      if(! _Ih_)return [0,_Ii_,l2];
      var _Ij_=_Ih_[2],_Ik_=_Ih_[1];
      if(! _Ij_)return [0,_Ii_,[0,_Ik_,l2]];
      var _Il_=_Ij_[2],_Im_=_Ij_[1];
      if(! _Il_)return [0,_Ii_,[0,_Ik_,[0,_Im_,l2]]];
      var _In_=_Il_[2],_Io_=_Il_[1];
      if(! _In_)return [0,_Ii_,[0,_Ik_,[0,_Im_,[0,_Io_,l2]]]];
      var
       tl=_In_[2],
       x5=_In_[1],
       _Ip_=
        max_non_tailcall < count
         ?caml_call2(rev_append,rev(tl),l2)
         :count_append(tl,l2,count + 1 | 0);
      return [0,_Ii_,[0,_Ik_,[0,_Im_,[0,_Io_,[0,x5,_Ip_]]]]]}
    function append$0(l1,l2){return count_append(l1,l2,0)}
    function count_map(f,l,ctr)
     {if(! l)return 0;
      var _H__=l[2],_H$_=l[1];
      if(! _H__){var f1$3=caml_call1(f,_H$_);return [0,f1$3,0]}
      var _Ia_=_H__[2],_Ib_=_H__[1];
      if(! _Ia_)
       {var f1$2=caml_call1(f,_H$_),f2$2=caml_call1(f,_Ib_);
        return [0,f1$2,[0,f2$2,0]]}
      var _Ic_=_Ia_[2],_Id_=_Ia_[1];
      if(! _Ic_)
       {var
         f1$1=caml_call1(f,_H$_),
         f2$1=caml_call1(f,_Ib_),
         f3$1=caml_call1(f,_Id_);
        return [0,f1$1,[0,f2$1,[0,f3$1,0]]]}
      var _Ie_=_Ic_[2],_If_=_Ic_[1];
      if(! _Ie_)
       {var
         f1$0=caml_call1(f,_H$_),
         f2$0=caml_call1(f,_Ib_),
         f3$0=caml_call1(f,_Id_),
         f4$0=caml_call1(f,_If_);
        return [0,f1$0,[0,f2$0,[0,f3$0,[0,f4$0,0]]]]}
      var
       tl=_Ie_[2],
       x5$0=_Ie_[1],
       f1=caml_call1(f,_H$_),
       f2=caml_call1(f,_Ib_),
       f3=caml_call1(f,_Id_),
       f4=caml_call1(f,_If_),
       f5=caml_call1(f,x5$0);
      if(max_non_tailcall < ctr)
       {var bs=0,xs=tl;
        for(;;)
         {if(xs)
           {var _H2_=xs[2];
            if(_H2_)
             {var _H3_=_H2_[2];
              if(_H3_)
               {var _H4_=_H3_[2];
                if(_H4_)
                 {var _H5_=_H4_[2];
                  if(_H5_)
                   {var _H6_=_H5_[2];
                    if(_H6_)
                     {var _H7_=_H6_[2];
                      if(_H7_)
                       {var _H8_=_H7_[2];
                        if(_H8_)
                         {var _H9_=_H8_[2];
                          if(_H9_)
                           {var
                             xs$0=_H9_[2],
                             x8=_H9_[1],
                             x7=_H8_[1],
                             x6=_H7_[1],
                             x5=_H6_[1],
                             x4=_H5_[1],
                             x3=_H4_[1],
                             x2=_H3_[1],
                             x1=_H2_[1],
                             x0=xs[1],
                             y0$0=caml_call1(f,x0),
                             y1$0=caml_call1(f,x1),
                             y2$0=caml_call1(f,x2),
                             y3$0=caml_call1(f,x3),
                             y4$0=caml_call1(f,x4),
                             y5$0=caml_call1(f,x5),
                             y6$0=caml_call1(f,x6),
                             y7$0=caml_call1(f,x7),
                             y8$0=caml_call1(f,x8),
                             bs$0=[0,[0,y0$0,y1$0,y2$0,y3$0,y4$0,y5$0,y6$0,y7$0,y8$0],bs],
                             bs=bs$0,
                             xs=xs$0;
                            continue}}}}}}}}}
          var ys$1=nontail_map(xs,f),ys=ys$1,param=bs;
          for(;;)
           {if(param)
             {var
               param$0=param[2],
               match=param[1],
               y8=match[9],
               y7=match[8],
               y6=match[7],
               y5=match[6],
               y4=match[5],
               y3=match[4],
               y2=match[3],
               y1=match[2],
               y0=match[1],
               ys$0=
                [0,
                 y0,
                 [0,y1,[0,y2,[0,y3,[0,y4,[0,y5,[0,y6,[0,y7,[0,y8,ys]]]]]]]]],
               ys=ys$0,
               param=param$0;
              continue}
            var _Ig_=ys;
            break}
          break}}
      else
       var _Ig_=count_map(f,tl,ctr + 1 | 0);
      return [0,f1,[0,f2,[0,f3,[0,f4,[0,f5,_Ig_]]]]]}
    function map$9(l,f){return count_map(f,l,0)}
    function folding_map(t,init,f)
     {var acc=[0,init];
      return map$9
              (t,
               function(x)
                {var match=caml_call2(f,acc[1],x),y=match[2],new_acc=match[1];
                 acc[1] = new_acc;
                 return y})}
    function fold_map(t,init,f)
     {var
       acc=[0,init],
       result=
        map$9
         (t,
          function(x)
           {var match=caml_call2(f,acc[1],x),y=match[2],new_acc=match[1];
            acc[1] = new_acc;
            return y});
      return [0,acc[1],result]}
    function symbol_map$2(l,f){return map$9(l,f)}
    function map2_ok(l1,l2,f){return rev(rev_map2_ok(l1,l2,f))}
    function map2(l1,l2,f)
     {return check_length2
              (l1,
               l2,
               function(_H0_)
                {return function(_H1_){return map2_ok(_H0_,_H1_,f)}})}
    function map2_exn(l1,l2,f)
     {check_length2_exn(cst_map2_exn,l1,l2);return map2_ok(l1,l2,f)}
    function rev_map3_ok(l1,l2,l3,f)
     {var l1$0=l1,l2$0=l2,l3$0=l3,ac=0;
      for(;;)
       {if(l1$0)
         {if(l2$0 && l3$0)
           {var
             l3$1=l3$0[2],
             x3=l3$0[1],
             l2$1=l2$0[2],
             x2=l2$0[1],
             l1$1=l1$0[2],
             x1=l1$0[1],
             ac$0=[0,caml_call3(f,x1,x2,x3),ac],
             l1$0=l1$1,
             l2$0=l2$1,
             l3$0=l3$1,
             ac=ac$0;
            continue}}
        else
         if(! l2$0 && ! l3$0)return ac;
        throw [0,Assert_failure$0,_at_]}}
    function rev_map3(l1,l2,l3,f)
     {return check_length3
              (l1,
               l2,
               l3,
               function(_HX_)
                {return function(_HY_)
                  {return function(_HZ_){return rev_map3_ok(_HX_,_HY_,_HZ_,f)}}})}
    function rev_map3_exn(l1,l2,l3,f)
     {check_length3_exn(cst_rev_map3_exn,l1,l2,l3);
      return rev_map3_ok(l1,l2,l3,f)}
    function map3_ok(l1,l2,l3,f){return rev(rev_map3_ok(l1,l2,l3,f))}
    function map3(l1,l2,l3,f)
     {return check_length3
              (l1,
               l2,
               l3,
               function(_HU_)
                {return function(_HV_)
                  {return function(_HW_){return map3_ok(_HU_,_HV_,_HW_,f)}}})}
    function map3_exn(l1,l2,l3,f)
     {check_length3_exn(cst_map3_exn,l1,l2,l3);return map3_ok(l1,l2,l3,f)}
    function rev_map_append(l1,l2,f)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(! l1$0)return l2$0;
        var t=l1$0[2],h=l1$0[1],l2$1=[0,caml_call1(f,h),l2$0],l1$0=t,l2$0=l2$1}}
    function unzip$0(list)
     {var list$2=rev(list),list$0=list$2,l1=0,l2=0;
      for(;;)
       {if(! list$0)return [0,l1,l2];
        var
         list$1=list$0[2],
         match=list$0[1],
         y=match[2],
         x=match[1],
         l2$0=[0,y,l2],
         l1$0=[0,x,l1],
         list$0=list$1,
         l1=l1$0,
         l2=l2$0}}
    function unzip3(list)
     {var list$2=rev(list),list$0=list$2,l1=0,l2=0,l3=0;
      for(;;)
       {if(! list$0)return [0,l1,l2,l3];
        var
         list$1=list$0[2],
         match=list$0[1],
         z=match[3],
         y=match[2],
         x=match[1],
         l3$0=[0,z,l3],
         l2$0=[0,y,l2],
         l1$0=[0,x,l1],
         list$0=list$1,
         l1=l1$0,
         l2=l2$0,
         l3=l3$0}}
    function zip_exn(l1,l2)
     {try
       {var _HS_=map2_ok(l1,l2,function(a,b){return [0,a,b]});return _HS_}
      catch(_HT_)
       {var _HQ_=caml_call1(length,l2),_HR_=caml_call1(length,l1);
        return caml_call3(invalid_argf(_au_),_HR_,_HQ_,0)}}
    function zip(l1,l2){return map2(l1,l2,function(a,b){return [0,a,b]})}
    function rev_mapi(param,f)
     {var i=0,acc=0,param$0=param;
      for(;;)
       {if(! param$0)return acc;
        var
         t=param$0[2],
         h=param$0[1],
         acc$0=[0,caml_call2(f,i,h),acc],
         i$0=i + 1 | 0,
         i=i$0,
         acc=acc$0,
         param$0=t}}
    function mapi$1(l,f){return rev(rev_mapi(l,f))}
    function folding_mapi(t,init,f)
     {var acc=[0,init];
      return mapi$1
              (t,
               function(i,x)
                {var
                  match=caml_call3(f,i,acc[1],x),
                  y=match[2],
                  new_acc=match[1];
                 acc[1] = new_acc;
                 return y})}
    function fold_mapi(t,init,f)
     {var
       acc=[0,init],
       result=
        mapi$1
         (t,
          function(i,x)
           {var match=caml_call3(f,i,acc[1],x),y=match[2],new_acc=match[1];
            acc[1] = new_acc;
            return y});
      return [0,acc[1],result]}
    function iteri$0(l,f)
     {fold_left(l,0,function(i,x){caml_call2(f,i,x);return i + 1 | 0});
      return 0}
    function foldi(t,init,f)
     {return fold_left
               (t,
                [0,0,init],
                function(param,v)
                 {var acc=param[2],i=param[1];
                  return [0,i + 1 | 0,caml_call3(f,i,acc,v)]})
              [2]}
    function filteri(l,f)
     {return rev
              (foldi
                (l,
                 0,
                 function(pos,acc,x){return caml_call2(f,pos,x)?[0,x,acc]:acc}))}
    function reduce(l,f)
     {if(! l)return 0;var tl=l[2],hd=l[1];return [0,fold_left(tl,hd,f)]}
    function reduce_exn(l,f)
     {var match=reduce(l,f);
      if(! match)return caml_call1(invalid_arg$0,cst_List_reduce_exn);
      var v=match[1];
      return v}
    function reduce_balanced(l,f)
     {function step_accum(num,acc,x)
       {var num$0=num,acc$0=acc,x$0=x;
        for(;;)
         {if(0 === (num$0 & 1))return [0,x$0,acc$0];
          if(! acc$0)throw [0,Assert_failure$0,_av_];
          var
           ys=acc$0[2],
           y=acc$0[1],
           x$1=caml_call2(f,y,x$0),
           num$1=num$0 >> 1,
           num$0=num$1,
           acc$0=ys,
           x$0=x$1}}
      var match=foldi(l,0,step_accum);
      if(! match)return 0;
      var xs=match[2],x=match[1];
      return [0,fold_left(xs,x,function(x,y){return caml_call2(f,y,x)})]}
    function reduce_balanced_exn(l,f)
     {var match=reduce_balanced(l,f);
      if(! match)
       return caml_call1(invalid_arg$0,cst_List_reduce_balanced_exn);
      var v=match[1];
      return v}
    function groupi(l,break$0)
     {var
       groups=
        foldi
         (l,
          0,
          function(i,acc,x)
           {if(! acc)return [0,[0,x,0],0];
            var tl=acc[2],current_group=acc[1];
            return caml_call3(break$0,i,caml_call1(hd_exn,current_group),x)
                    ?[0,[0,x,0],[0,current_group,tl]]
                    :[0,[0,x,current_group],tl]});
      return groups?rev_map(groups,rev):0}
    function group(l,break$0)
     {return groupi(l,function(param,x,y){return caml_call2(break$0,x,y)})}
    function sort_and_group(l,compare)
     {var _HP_=stable_sort$0(l,compare);
      return group
              (_HP_,function(x,y){return 0 !== caml_call2(compare,x,y)?1:0})}
    function bind$6(param,f)
     {var acc=0,param$0=param;
      for(;;)
       {if(! param$0)return rev(acc);
        var
         tl=param$0[2],
         hd=param$0[1],
         acc$0=caml_call2(rev_append,caml_call1(f,hd),acc),
         acc=acc$0,
         param$0=tl}}
    function concat_mapi(param,f)
     {var cont=0,acc=0,param$0=param;
      for(;;)
       {if(! param$0)return rev(acc);
        var
         tl=param$0[2],
         hd=param$0[1],
         acc$0=caml_call2(rev_append,caml_call2(f,cont,hd),acc),
         cont$0=cont + 1 | 0,
         cont=cont$0,
         acc=acc$0,
         param$0=tl}}
    function merge(l1,l2,compare)
     {var acc=0,l1$0=l1,l2$0=l2;
      for(;;)
       {if(! l1$0)return caml_call2(rev_append,acc,l2$0);
        if(! l2$0)return caml_call2(rev_append,acc,l1$0);
        var t2=l2$0[2],h2=l2$0[1],t1=l1$0[2],h1=l1$0[1];
        if(0 < caml_call2(compare,h1,h2))
         {var acc$0=[0,h2,acc],acc=acc$0,l2$0=t2;continue}
        var acc$1=[0,h1,acc],acc=acc$1,l1$0=t1}}
    function map2$0(a,b,f)
     {return bind$6
              (a,
               function(x)
                {return map$9(b,function(y){return caml_call2(f,x,y)})})}
    function return$7(x){return [0,x,0]}
    function symbol_bind$2(t,f){return bind$6(t,f)}
    var
     map$10=[0,-198771759,map$9],
     Applicative=Make_using_map2([0,return$7,map2$0,map$10]),
     map$11=[0,-198771759,map$9],
     Monad=Make([0,bind$6,return$7,map$11]),
     all$4=Monad[9],
     all_unit$2=Monad[10],
     ignore_m$2=Monad[8],
     join$2=Monad[7],
     apply=Applicative[8],
     both=Applicative[3],
     map3$0=Applicative[10],
     symbol$60=Applicative[4],
     symbol$61=Applicative[6],
     symbol$62=Applicative[5],
     symbol$63=Applicative[4],
     symbol$64=Applicative[6],
     symbol$65=Applicative[5],
     Open_on_rhs=[0],
     Let_syntax$2=[0,return$7,bind$6,map$9,both,Open_on_rhs],
     Let_syntax$3=[0,return$7,symbol_bind$2,symbol_map$2,Let_syntax$2],
     Monad_infix$1=[0,symbol_bind$2,symbol_map$2];
    function last_exn(list)
     {var list$0=list;
      for(;;)
       {if(! list$0)return caml_call1(invalid_arg$0,cst_List_last);
        var _HO_=list$0[1];
        if(! list$0[2])return _HO_;
        var list$1=list$0[2],list$0=list$1}}
    function last(list)
     {var list$0=list;
      for(;;)
       {if(! list$0)return 0;
        var _HN_=list$0[1];
        if(! list$0[2])return [0,_HN_];
        var list$1=list$0[2],list$0=list$1}}
    function is_prefix(list,prefix,equal)
     {var list$0=list,prefix$0=prefix;
      for(;;)
       {if(! prefix$0)return 1;
        var tl=prefix$0[2],hd=prefix$0[1];
        if(! list$0)return 0;
        var tl$0=list$0[2],hd$0=list$0[1],_HM_=caml_call2(equal,hd,hd$0);
        if(! _HM_)return _HM_;
        var list$0=tl$0,prefix$0=tl}}
    function find_consecutive_duplicate(t,equal)
     {if(! t)return 0;
      var t$0=t[2],a1=t[1],a1$0=a1,t$1=t$0;
      for(;;)
       {if(! t$1)return 0;
        var t$2=t$1[2],a2=t$1[1];
        if(caml_call2(equal,a1$0,a2))return [0,[0,a1$0,a2]];
        var a1$0=a2,t$1=t$2}}
    function remove_consecutive_duplicates(opt,list,equal)
     {if(opt)
       var sth=opt[1],which_to_keep=sth;
      else
       var which_to_keep=847656566;
      if(! list)return 0;
      var tl$0=list[2],hd$0=list[1],to_keep=hd$0,accum=0,param=tl$0;
      for(;;)
       {if(! param)return rev([0,to_keep,accum]);
        var tl=param[2],hd=param[1];
        if(caml_call2(equal,hd,to_keep))
         {var
           to_keep$0=847656566 <= which_to_keep?hd:to_keep,
           to_keep=to_keep$0,
           param=tl;
          continue}
        var accum$0=[0,to_keep,accum],to_keep=hd,accum=accum$0,param=tl}}
    function dedup_and_sort(list,compare)
     {if(list && list[2])
       {var
         equal=function(x$0,x){return 0 === caml_call2(compare,x$0,x)?1:0},
         sorted=sort(list,compare);
        return remove_consecutive_duplicates(0,sorted,equal)}
      return list}
    function find_a_dup(l,compare)
     {var l$0=sort(l,compare),l$1=l$0;
      for(;;)
       {if(l$1)
         {var _HL_=l$1[2];
          if(_HL_)
           {var hd2=_HL_[1],hd1=l$1[1];
            if(0 === caml_call2(compare,hd1,hd2))return [0,hd1];
            var l$1=_HL_;
            continue}}
        return 0}}
    function contains_dup(lst,compare)
     {var match=find_a_dup(lst,compare);return match?1:0}
    function find_all_dups(l,compare)
     {function compare$0(a,b){return -1 * caml_call2(compare,a,b) | 0}
      var sorted=sort(l,compare$0);
      if(! sorted)return 0;
      var
       tl$0=sorted[2],
       hd$0=sorted[1],
       sorted$0=tl$0,
       prev=hd$0,
       already_recorded=0,
       acc=0;
      for(;;)
       {if(! sorted$0)return acc;
        var tl=sorted$0[2],hd=sorted$0[1];
        if(0 !== compare$0(prev,hd))
         {var sorted$0=tl,prev=hd,already_recorded=0;continue}
        if(already_recorded)
         {var sorted$0=tl,prev=hd,already_recorded=1;continue}
        var acc$0=[0,hd,acc],sorted$0=tl,prev=hd,already_recorded=1,acc=acc$0}}
    function all_equal(t$0,equal)
     {if(! t$0)return 0;
      var xs$0=t$0[2],x$0=t$0[1],t=xs$0;
      for(;;)
       {if(t)
         {var xs=t[2],x=t[1],_HJ_=caml_call2(equal,x,x$0);
          if(_HJ_){var t=xs;continue}
          var _HK_=_HJ_}
        else
         var _HK_=1;
        return _HK_?[0,x$0]:0}}
    function count$0(t,f){return count(fold_left,t,f)}
    function sum$0(m,t,f){return caml_call2(sum(fold_left,m),t,f)}
    function min_elt$0(t,compare){return min_elt(fold_left,t,compare)}
    function max_elt$0(t,compare){return max_elt(fold_left,t,compare)}
    function counti(t,f)
     {return foldi
              (t,
               0,
               function(idx,count,a)
                {return caml_call2(f,idx,a)?count + 1 | 0:count})}
    function init$1(i,f)
     {if(i < 0)caml_call2(invalid_argf(_aw_),i,0);
      var i$0=i,accum=0;
      for(;;)
       {if(0 > i$0)throw [0,Assert_failure$0,_ax_];
        if(0 === i$0)return accum;
        var
         accum$0=[0,caml_call1(f,i$0 - 1 | 0),accum],
         i$1=i$0 - 1 | 0,
         i$0=i$1,
         accum=accum$0}}
    function rev_filter_map(l,f)
     {var l$0=l,accum=0;
      for(;;)
       {if(! l$0)return accum;
        var tl=l$0[2],hd=l$0[1],match=caml_call1(f,hd);
        if(match)
         {var x=match[1],accum$0=[0,x,accum],l$0=tl,accum=accum$0;continue}
        var l$0=tl}}
    function filter_map(l,f){return rev(rev_filter_map(l,f))}
    function rev_filter_mapi(l,f)
     {var i=0,l$0=l,accum=0;
      for(;;)
       {if(! l$0)return accum;
        var tl=l$0[2],hd=l$0[1],match=caml_call2(f,i,hd);
        if(match)
         {var
           x=match[1],
           accum$0=[0,x,accum],
           i$0=i + 1 | 0,
           i=i$0,
           l$0=tl,
           accum=accum$0;
          continue}
        var i$1=i + 1 | 0,i=i$1,l$0=tl}}
    function filter_mapi(l,f){return rev(rev_filter_mapi(l,f))}
    function filter_opt(l){return filter_map(l,function(_HI_){return _HI_})}
    function partition3_map(t,f)
     {var t$0=t,fst=0,snd=0,trd=0;
      for(;;)
       {if(! t$0)
         {var _HG_=rev(trd),_HH_=rev(snd);return [0,rev(fst),_HH_,_HG_]}
        var t$1=t$0[2],x=t$0[1],match=caml_call1(f,x),_HF_=match[1];
        if(4152137 === _HF_)
         {var y=match[2],snd$0=[0,y,snd],t$0=t$1,snd=snd$0;continue}
        if(4202758 <= _HF_)
         {var y$0=match[2],trd$0=[0,y$0,trd],t$0=t$1,trd=trd$0;continue}
        var y$1=match[2],fst$0=[0,y$1,fst],t$0=t$1,fst=fst$0}}
    function partition_tf(t,f)
     {function f$0(x){return caml_call1(f,x)?[0,x]:[1,x]}
      return partition_map(t,f$0)}
    function partition_result(t){return partition_map(t,to_either)}
    function t_of_sexp$14(of_a_014,of_b_015,x_023)
     {return caml_call2
              (t_of_sexp$10,
               function(sexp_021)
                {if(1 === sexp_021[0])
                  {var _HD_=sexp_021[1];
                   if(_HD_)
                    {var _HE_=_HD_[2];
                     if(_HE_ && ! _HE_[2])
                      {var
                        arg1_018=_HE_[1],
                        arg0_017=_HD_[1],
                        res0_019=caml_call1(of_a_014,arg0_017),
                        res1_020=caml_call1(of_b_015,arg1_018);
                       return [0,res0_019,res1_020]}}}
                 return caml_call3
                         (Sexplib0_Sexp_conv_error[2],error_source_022,2,sexp_021)},
               x_023)}
    function sexp_of_t$20(of_a_024,of_b_025,x_030)
     {return caml_call2
              (sexp_of_t$10,
               function(param)
                {var
                  arg1_027=param[2],
                  arg0_026=param[1],
                  res0_028=caml_call1(of_a_024,arg0_026),
                  res1_029=caml_call1(of_b_025,arg1_027);
                 return [1,[0,res0_028,[0,res1_029,0]]]},
               x_030)}
    function t_sexp_grammar$13(a_sexp_grammar,b_sexp_grammar)
     {return caml_call1
              (list_sexp_grammar,[2,[0,a_sexp_grammar,[0,b_sexp_grammar,0]]])}
    function pair_of_group(list)
     {if(! list)throw [0,Assert_failure$0,_ay_];
      var match=list[1],k=match[1];
      return [0,k,map$9(list,get_data)]}
    function group$0(alist,equal)
     {return map$9
              (group
                (alist,
                 function(param,_HC_)
                  {var y=_HC_[1],x=param[1];return 1 - caml_call2(equal,x,y)}),
               pair_of_group)}
    function sort_and_group$0(alist,compare)
     {return map$9
              (sort_and_group
                (alist,
                 function(param,_HB_)
                  {var y=_HB_[1],x=param[1];return caml_call2(compare,x,y)}),
               pair_of_group)}
    function find$1(t,equal,key)
     {var
       match=
        find$0
         (t,
          function(param)
           {var key$0=param[1];return caml_call2(equal,key,key$0)});
      if(! match)return 0;
      var x=match[1];
      return [0,x[2]]}
    var not_found$3=[0,Not_found_s,_az_];
    function find_exn$0(t,equal,key)
     {var match=find$1(t,equal,key);
      if(! match)throw not_found$3;
      var value=match[1];
      return value}
    function mem$0(t,equal,key)
     {var match=find$1(t,equal,key);return match?1:0}
    function remove(t,equal,key)
     {return filter
              (t,
               function(param)
                {var key$0=param[1];return 1 - caml_call2(equal,key,key$0)})}
    function add$0(t,equal,key,value)
     {return [0,[0,key,value],remove(t,equal,key)]}
    function inverse(t)
     {return map$9
              (t,function(param){var y=param[2],x=param[1];return [0,y,x]})}
    function map$12(t,f)
     {return map$9
              (t,
               function(param)
                {var value=param[2],key=param[1];
                 return [0,key,caml_call1(f,value)]})}
    function sub$3(l,pos,len)
     {var _Hy_=pos < 0?1:0;
      if(_Hy_)
       var _Hz_=_Hy_;
      else
       var
        _HA_=len < 0?1:0,
        _Hz_=_HA_ || ((caml_call1(length,l) - len | 0) < pos?1:0);
      if(_Hz_)caml_call1(invalid_arg$0,cst_List_sub);
      return rev
              (foldi
                (l,
                 0,
                 function(i,acc,el)
                  {if(pos <= i && i < (pos + len | 0))return [0,el,acc];
                   return acc}))}
    function split_n(t_orig,n)
     {if(0 >= n)return [0,0,t_orig];
      var n$0=n,t=t_orig,accum=0;
      for(;;)
       {if(0 === n$0)return [0,rev(accum),t];
        if(! t)return [0,t_orig,0];
        var
         tl=t[2],
         hd=t[1],
         accum$0=[0,hd,accum],
         n$1=n$0 - 1 | 0,
         n$0=n$1,
         t=tl,
         accum=accum$0}}
    function take(t,n)
     {if(0 >= n)return 0;
      var n$0=n,t$0=t,accum=0;
      for(;;)
       {if(0 === n$0)return rev(accum);
        if(! t$0)return t;
        var
         tl=t$0[2],
         hd=t$0[1],
         accum$0=[0,hd,accum],
         n$1=n$0 - 1 | 0,
         n$0=n$1,
         t$0=tl,
         accum=accum$0}}
    function drop(t,n)
     {var t$0=t,n$0=n;
      for(;;)
       {if(t$0)
         {var tl=t$0[2];
          if(0 < n$0){var n$1=n$0 - 1 | 0,t$0=tl,n$0=n$1;continue}}
        return t$0}}
    function chunks_of(l,length)
     {if(length <= 0)caml_call2(invalid_argf(_aA_),length,0);
      var acc=0,l$0=l;
      for(;;)
       {if(! l$0)return rev(acc);
        var
         match=split_n(l$0,length),
         l$1=match[2],
         sublist=match[1],
         acc$0=[0,sublist,acc],
         acc=acc$0,
         l$0=l$1}}
    function split_while(t,f)
     {var acc=0,t$0=t;
      for(;;)
       {if(t$0)
         {var tl=t$0[2],hd=t$0[1];
          if(caml_call1(f,hd)){var acc$0=[0,hd,acc],acc=acc$0,t$0=tl;continue}}
        return [0,rev(acc),t$0]}}
    function take_while(param,f)
     {var acc=0,param$0=param;
      for(;;)
       {if(param$0)
         {var tl=param$0[2],hd=param$0[1];
          if(caml_call1(f,hd))
           {var acc$0=[0,hd,acc],acc=acc$0,param$0=tl;continue}}
        return rev(acc)}}
    function drop_while(t,f)
     {var t$0=t;
      for(;;)
       {if(t$0)
         {var tl=t$0[2],hd=t$0[1];if(caml_call1(f,hd)){var t$0=tl;continue}}
        return t$0}}
    function drop_last(t)
     {var match=rev(t);
      if(! match)return 0;
      var lst=match[2];
      return [0,rev(lst)]}
    function drop_last_exn(t)
     {var match=drop_last(t);
      if(! match)return caml_call1(failwith$0,cst_List_drop_last_exn_empty_l);
      var lst=match[1];
      return lst}
    function cartesian_product(list1,list2)
     {if(is_empty(list2))return 0;
      var l1=list1,accum=0;
      for(;;)
       {if(! l1)return rev(accum);
        var
         tl=l1[2],
         hd=l1[1],
         accum$0=
          caml_call2
           (rev_append,
            map$9(list2,function(hd){return function(x){return [0,hd,x]}}(hd)),
            accum),
         l1=tl,
         accum=accum$0}}
    function concat$1(l){return fold_right$0(l,append$0,0)}
    function concat_no_order(l)
     {return fold_left
              (l,0,function(acc,l){return caml_call2(rev_append,l,acc)})}
    function cons(x,l){return [0,x,l]}
    function is_sorted(l,compare)
     {var l$0=l;
      for(;;)
       {if(l$0)
         {var _Hw_=l$0[2];
          if(_Hw_)
           {var x2=_Hw_[1],x1=l$0[1],_Hx_=caml_call2(compare,x1,x2) <= 0?1:0;
            if(! _Hx_)return _Hx_;
            var l$0=_Hw_;
            continue}}
        return 1}}
    function is_sorted_strictly(l,compare)
     {var l$0=l;
      for(;;)
       {if(l$0)
         {var _Hu_=l$0[2];
          if(_Hu_)
           {var x2=_Hu_[1],x1=l$0[1],_Hv_=caml_call2(compare,x1,x2) < 0?1:0;
            if(! _Hv_)return _Hv_;
            var l$0=_Hu_;
            continue}}
        return 1}}
    var Infix=[0,append$0];
    function permute$0(opt,list)
     {if(opt)var sth=opt[1],random_state=sth;else var random_state=_ag_[1];
      if(list)
       {var _Ht_=list[2];
        if(_Ht_)
         {if(_Ht_[2])
           {var arr=caml_call1(of_list,list);
            permute([0,random_state],0,0,arr);
            return caml_call1(to_list,arr)}
          var y=_Ht_[1],x=list[1];
          return caml_call1(_ag_[16],random_state)?[0,y,[0,x,0]]:list}}
      return list}
    function random_element_exn(opt,list)
     {if(opt)var sth=opt[1],random_state=sth;else var random_state=_ag_[1];
      if(is_empty(list))
       return caml_call1(failwith$0,cst_List_random_element_exn_em);
      var _Hs_=caml_call1(length,list);
      return nth_exn(list,caml_call2(_ag_[6],random_state,_Hs_))}
    function random_element(opt,list)
     {if(opt)var sth=opt[1],random_state=sth;else var random_state=_ag_[1];
      try
       {var _Hq_=[0,random_element_exn([0,random_state],list)];return _Hq_}
      catch(_Hr_){return 0}}
    function compare_list$1(cmp,a,b)
     {var a$0=a,b$0=b;
      for(;;)
       {if(! a$0)return b$0?-1:0;
        if(! b$0)return 1;
        var ys=b$0[2],y=b$0[1],xs=a$0[2],x=a$0[1],n=caml_call2(cmp,x,y);
        if(0 !== n)return n;
        var a$0=xs,b$0=ys}}
    function equal_list$1(equal,t1,t2)
     {var t1$0=t1,t2$0=t2;
      for(;;)
       {if(t1$0)
         {if(t2$0)
           {var
             t2$1=t2$0[2],
             x2=t2$0[1],
             t1$1=t1$0[2],
             x1=t1$0[1],
             _Hp_=caml_call2(equal,x1,x2);
            if(! _Hp_)return _Hp_;
            var t1$0=t1$1,t2$0=t2$1;
            continue}}
        else
         if(! t2$0)return 1;
        return 0}}
    function transpose(t$2)
     {var rows=t$2,columns=0,do_rev=1;
      a:
      for(;;)
       {var t=rows,column_acc=0,trimmed_rows=0,found_empty=0;
        for(;;)
         {if(! t)
           {if(! column_acc && ! trimmed_rows)return [0,rev(columns)];
            if(found_empty)return 0;
            var
             column=do_rev?rev(column_acc):column_acc,
             do_rev$0=1 - do_rev,
             columns$0=[0,column,columns],
             rows=trimmed_rows,
             columns=columns$0,
             do_rev=do_rev$0;
            continue a}
          var _Ho_=t[1];
          if(_Ho_)
           {var
             t$0=t[2],
             xs=_Ho_[2],
             x=_Ho_[1],
             trimmed=[0,xs,trimmed_rows],
             column_acc$0=[0,x,column_acc],
             t=t$0,
             column_acc=column_acc$0,
             trimmed_rows=trimmed;
            continue}
          var t$1=t[2],t=t$1,found_empty=1}}}
    var
     Transpose_got_lists_of_differe=
      [248,cst_Base_List_Transpose_got_li,caml_fresh_oo_id(0)];
    function _aB_(param)
     {if(param[1] !== Transpose_got_lists_of_differe)
       throw [0,Assert_failure$0,_aD_];
      var
       arg0_031=param[2],
       res0_032=caml_call2(sexp_of_t$10,sexp_of_t$4,arg0_031);
      return [1,[0,_aC_,[0,res0_032,0]]]}
    caml_call4
     (Sexplib0_Sexp_conv[70][1],0,0,Transpose_got_lists_of_differe,_aB_);
    function transpose_exn(l)
     {var match=transpose(l);
      if(! match)throw [0,Transpose_got_lists_of_differe,map$9(l,length)];
      var l$0=match[1];
      return l$0}
    function intersperse(t,sep)
     {if(! t)return 0;
      var xs=t[2],x=t[1],_Hn_=0;
      return [0,
              x,
              fold_right$0(xs,function(y,acc){return [0,sep,[0,y,acc]]},_Hn_)]}
    function fold_result$0(t,init,f){return fold_result(fold_left,init,f,t)}
    function fold_until$0(t,init,f)
     {return function(_Hm_){return fold_until(fold_left,init,f,_Hm_,t)}}
    function is_suffix(list,suffix,equal_elt)
     {var
       list_len=caml_call1(length,list),
       suffix_len=caml_call1(length,suffix),
       _Hl_=suffix_len <= list_len?1:0;
      return _Hl_
              ?equal_list$1
                (equal_elt,drop(list,list_len - suffix_len | 0),suffix)
              :_Hl_}
    var
     _aE_=
      [0,
       t_of_sexp$14,
       sexp_of_t$20,
       t_sexp_grammar$13,
       add$0,
       find$1,
       find_exn$0,
       mem$0,
       remove,
       map$12,
       inverse,
       group$0,
       sort_and_group$0],
     Base_List=
      [0,
       compare_list$1,
       hash_fold_t$9,
       t_of_sexp$10,
       sexp_of_t$10,
       t_sexp_grammar$12,
       mem,
       length,
       is_empty,
       iter$0,
       fold_left,
       fold_result$0,
       fold_until$0,
       exists,
       for_all,
       sum$0,
       find$0,
       find_map$0,
       to_list$1,
       of_list,
       min_elt$0,
       max_elt$0,
       invariant$1,
       [0,
        both,
        symbol$60,
        symbol$62,
        symbol$61,
        apply,
        map2$0,
        map3$0,
        [0,symbol$63,symbol$65,symbol$64,symbol_map$2],
        symbol_bind$2,
        symbol_map$2,
        [0,symbol_bind$2,symbol_map$2],
        bind$6,
        return$7,
        map$9,
        join$2,
        ignore_m$2,
        all$4,
        all_unit$2,
        [0,return$7,symbol_bind$2,symbol_map$2,Let_syntax$2]],
       symbol_bind$2,
       symbol_map$2,
       Monad_infix$1,
       bind$6,
       return$7,
       join$2,
       ignore_m$2,
       all$4,
       all_unit$2,
       Let_syntax$3,
       Or_unequal_lengths,
       of_list$0,
       nth,
       nth_exn,
       rev,
       rev_append,
       unordered_append,
       rev_map,
       iter2_exn,
       iter2,
       rev_map2_exn,
       rev_map2,
       fold2_exn,
       fold2,
       for_alli,
       for_all2_exn,
       for_all2,
       existsi,
       exists2_exn,
       exists2,
       filter,
       rev_filter,
       filteri,
       partition_map,
       partition3_map,
       partition_tf,
       partition_result,
       split_n,
       sort,
       stable_sort$0,
       merge,
       hd,
       tl,
       hd_exn,
       tl_exn,
       findi,
       findi_exn,
       find_exn,
       find_map_exn,
       find_mapi,
       find_mapi_exn,
       append$0,
       map$9,
       folding_map,
       folding_mapi,
       fold_map,
       fold_mapi,
       bind$6,
       concat_mapi,
       map2_exn,
       map2,
       rev_map3_exn,
       rev_map3,
       map3_exn,
       map3,
       rev_map_append,
       fold_right$0,
       fold_left,
       unzip$0,
       unzip3,
       zip,
       zip_exn,
       mapi$1,
       rev_mapi,
       iteri$0,
       foldi,
       reduce_exn,
       reduce,
       reduce_balanced,
       reduce_balanced_exn,
       group,
       groupi,
       sort_and_group,
       chunks_of,
       last,
       last_exn,
       is_prefix,
       is_suffix,
       find_consecutive_duplicate,
       remove_consecutive_duplicates,
       dedup_and_sort,
       find_a_dup,
       contains_dup,
       find_all_dups,
       all_equal,
       count$0,
       counti,
       range$0,
       range,
       init$1,
       rev_filter_map,
       rev_filter_mapi,
       filter_map,
       filter_mapi,
       filter_opt,
       _aE_,
       sub$3,
       take,
       drop,
       take_while,
       drop_while,
       split_while,
       drop_last,
       drop_last_exn,
       concat$1,
       concat_no_order,
       cons,
       cartesian_product,
       permute$0,
       random_element,
       random_element_exn,
       is_sorted,
       is_sorted_strictly,
       equal_list$1,
       Infix,
       transpose,
       transpose_exn,
       intersperse];
    caml_register_global(1041,Base_List,"Base__List");
    function sexp_of_t$21(param)
     {switch(param[0])
       {case 0:
         var arg0_001=param[1],res0_002=caml_call1(sexp_of_t,arg0_001);
         return [1,[0,_aF_,[0,res0_002,0]]];
        case 1:
         var arg0_003=param[1],res0_004=caml_call1(sexp_of_t$2,arg0_003);
         return [1,[0,_aG_,[0,res0_004,0]]];
        case 2:
         var arg0_005=param[1],res0_006=caml_call1(sexp_of_exn,arg0_005);
         return [1,[0,_aH_,[0,res0_006,0]]];
        case 3:
         var arg0_007=param[1],res0_008=caml_call1(sexp_of_t,arg0_007);
         return [1,[0,_aI_,[0,res0_008,0]]];
        case 4:
         var
          arg2_011=param[3],
          arg1_010=param[2],
          arg0_009=param[1],
          res0_012=caml_call1(sexp_of_t$2,arg0_009),
          res1_013=caml_call1(sexp_of_t,arg1_010),
          res2_014=caml_call2(sexp_of_option,sexp_of_t$15,arg2_011);
         return [1,[0,_aJ_,[0,res0_012,[0,res1_013,[0,res2_014,0]]]]];
        case 5:
         var
          arg1_016=param[2],
          arg0_015=param[1],
          res0_017=caml_call1(sexp_of_t$2,arg0_015),
          res1_018=sexp_of_t$21(arg1_016);
         return [1,[0,_aK_,[0,res0_017,[0,res1_018,0]]]];
        case 6:
         var
          arg2_021=param[3],
          arg1_020=param[2],
          arg0_019=param[1],
          res0_022=caml_call1(sexp_of_t$2,arg0_019),
          res1_023=caml_call1(sexp_of_t,arg1_020),
          res2_024=sexp_of_t$21(arg2_021);
         return [1,[0,_aL_,[0,res0_022,[0,res1_023,[0,res2_024,0]]]]];
        case 7:
         var
          arg1_026=param[2],
          arg0_025=param[1],
          res0_027=caml_call2(sexp_of_option,sexp_of_t$4,arg0_025),
          res1_028=caml_call2(sexp_of_t$10,sexp_of_t$21,arg1_026);
         return [1,[0,_aM_,[0,res0_027,[0,res1_028,0]]]];
        default:
         var
          arg1_030=param[2],
          arg0_029=param[1],
          res0_031=sexp_of_t$21(arg0_029),
          res1_032=caml_call1(sexp_of_t$2,arg1_030);
         return [1,[0,_aN_,[0,res0_031,[0,res1_032,0]]]]}}
    function to_strings_hum(t,ac)
     {var t$0=t,ac$0=ac;
      for(;;)
       switch(t$0[0])
        {case 0:
          var sexp=t$0[1];
          return [0,
                  cst_could_not_construct_info,
                  [0,caml_call1(to_string_mach,sexp),ac$0]];
         case 1:var string=t$0[1];return [0,string,ac$0];
         case 2:
          var exn=t$0[1];
          return [0,
                  caml_call1(to_string_mach,caml_call1(sexp_of_exn,exn)),
                  ac$0];
         case 3:
          var sexp$0=t$0[1];return [0,caml_call1(to_string_mach,sexp$0),ac$0];
         case 4:
          var sexp$1=t$0[2],tag=t$0[1];
          return [0,tag,[0,cst$3,[0,caml_call1(to_string_mach,sexp$1),ac$0]]];
         case 5:
          var t$1=t$0[2],tag$0=t$0[1];
          return [0,tag$0,[0,cst$4,to_strings_hum(t$1,ac$0)]];
         case 6:
          var
           t$2=t$0[3],
           sexp$2=t$0[2],
           tag$1=t$0[1],
           _Hi_=[0,cst$5,to_strings_hum(t$2,ac$0)],
           body=[0,caml_call1(to_string_mach,sexp$2),_Hi_];
          return 0 === caml_ml_string_length(tag$1)
                  ?body
                  :[0,tag$1,[0,cst$6,body]];
         case 7:
          var ts=t$0[2],trunc_after=t$0[1];
          if(trunc_after)
           {var max=trunc_after[1],n=caml_call1(length,ts);
            if(n <= max)
             var ts$0=ts;
            else
             var
              _Hk_=[0,[1,caml_call2(sprintf,_aO_,n - max | 0)],0],
              ts$0=caml_call2(symbol$58,take(ts,max),_Hk_);
            var ts$1=ts$0}
          else
           var ts$1=ts;
          var
           _Hj_=
            function(ac,t)
             {var ac$0=is_empty(ac)?ac:[0,cst$7,ac];
              return to_strings_hum(t,ac$0)};
          return fold_left(rev(ts$1),ac$0,_Hj_);
         default:
          var
           backtrace=t$0[2],
           t$3=t$0[1],
           ac$1=[0,cst_Backtrace,[0,backtrace,ac$0]],
           t$0=t$3,
           ac$0=ac$1;
          continue}}
    function to_sexps_hum(t,ac)
     {switch(t[0])
       {case 0:return [0,sexp_of_t$21(t),ac];
        case 1:var string=t[1];return [0,[0,string],ac];
        case 2:var exn=t[1];return [0,caml_call1(sexp_of_exn,exn),ac];
        case 3:var sexp=t[1];return [0,sexp,ac];
        case 4:
         var here=t[3],sexp$0=t[2],tag=t[1];
         if(here)
          var here$0=here[1],_Hg_=[0,sexp_of_t$15(here$0),0];
         else
          var _Hg_=0;
         return [0,[1,[0,[0,tag],[0,sexp$0,_Hg_]]],ac];
        case 5:
         var t$0=t[2],tag$0=t[1];
         return [0,[1,[0,[0,tag$0],to_sexps_hum(t$0,0)]],ac];
        case 6:
         var
          t$1=t[3],
          sexp$1=t[2],
          tag$1=t[1],
          body=[0,sexp$1,to_sexps_hum(t$1,0)];
         return 0 === caml_ml_string_length(tag$1)
                 ?[0,[1,body],ac]
                 :[0,[1,[0,[0,tag$1],body]],ac];
        case 7:
         var ts=t[2],_Hh_=function(ac,t){return to_sexps_hum(t,ac)};
         return fold_left(rev(ts),ac,_Hh_);
        default:
         var backtrace=t[2],t$2=t[1];
         return [0,[1,[0,to_sexp_hum(t$2),[0,[0,backtrace],0]]],ac]}}
    function to_sexp_hum(t)
     {var sexps=to_sexps_hum(t,0);
      if(sexps && ! sexps[2]){var sexp=sexps[1];return sexp}
      return [1,sexps]}
    function protect$0(f)
     {try
       {var _Hf_=caml_call1(f,0);return _Hf_}
      catch(exn)
       {exn = caml_wrap_exception(exn);return [0,caml_call1(sexp_of_exn,exn)]}}
    function to_message(info)
     {return protect$0
              (function(param)
                {var _He_=caml_obj_tag(info);
                 return 250 === _He_
                         ?info[1]
                         :246 === _He_?caml_call1(CamlinternalLazy[2],info):info})}
    function of_message(t){return [250,t]}
    function invariant$2(param){return 0}
    function sexp_of_t$22(t){return to_sexp_hum(to_message(t))}
    function t_of_sexp$15(sexp){return [246,function(_Hd_){return [3,sexp]}]}
    function compare$24(t1,t2)
     {var _Hc_=sexp_of_t$22(t2);return compare$7(sexp_of_t$22(t1),_Hc_)}
    function equal$12(t1,t2)
     {var _Hb_=sexp_of_t$22(t2);
      return caml_call2(equal$8,sexp_of_t$22(t1),_Hb_)}
    function hash_fold_t$16(state,t)
     {return caml_call2(hash_fold_t,state,sexp_of_t$22(t))}
    function hash$3(t){return run(0,hash_fold_t$16,t)}
    function to_string_hum$0(t)
     {var message=to_message(t);
      if(1 !== message[0])
       return caml_call2(to_string_hum,0,to_sexp_hum(message));
      var s=message[1];
      return s}
    function to_string_hum_deprecated(t)
     {var t$0=to_message(t);return concat$0(0,to_strings_hum(t$0,0))}
    function to_string_mach$1(t)
     {return caml_call1(to_string_mach,sexp_of_t$22(t))}
    function of_lazy(l)
     {return [246,
              function(_G__)
               {return protect$0
                        (function(param)
                          {var
                            _G$_=caml_obj_tag(l),
                            _Ha_=
                             250 === _G$_
                              ?l[1]
                              :246 === _G$_?caml_call1(CamlinternalLazy[2],l):l;
                           return [1,_Ha_]})}]}
    function of_lazy_sexp(l)
     {return [246,
              function(_G7_)
               {return protect$0
                        (function(param)
                          {var
                            _G8_=caml_obj_tag(l),
                            _G9_=
                             250 === _G8_
                              ?l[1]
                              :246 === _G8_?caml_call1(CamlinternalLazy[2],l):l;
                           return [3,_G9_]})}]}
    function of_lazy_t(lazy_t){return caml_call1(join$1,lazy_t)}
    function of_string$2(message){return caml_call1(from_val,[1,message])}
    function createf(format){return caml_call2(ksprintf,of_string$2,format)}
    function of_thunk(f)
     {return [246,
              function(_G6_)
               {return protect$0(function(param){return [1,caml_call1(f,0)]})}]}
    function create$2(here,strict,tag,x,sexp_of_x)
     {return strict
              ?[250,[4,tag,caml_call1(sexp_of_x,x),here]]
              :[246,
                function(_G5_)
                 {return protect$0
                          (function(param)
                            {return [4,tag,caml_call1(sexp_of_x,x),here]})}]}
    function create_s$0(sexp){return caml_call1(from_val,[3,sexp])}
    function tag(t,tag)
     {return [246,function(_G4_){return [5,tag,to_message(t)]}]}
    function tag_s_lazy(t,tag)
     {return [246,
              function(_G0_)
               {return protect$0
                        (function(param)
                          {var
                            _G1_=to_message(t),
                            _G2_=caml_obj_tag(tag),
                            _G3_=
                             250 === _G2_
                              ?tag[1]
                              :246 === _G2_?caml_call1(CamlinternalLazy[2],tag):tag;
                           return [6,cst$8,_G3_,_G1_]})}]}
    function tag_s(t,tag){return tag_s_lazy(t,caml_call1(from_val,tag))}
    function tag_arg(t,tag,x,sexp_of_x)
     {return [246,
              function(_GY_)
               {return protect$0
                        (function(param)
                          {var _GZ_=to_message(t);
                           return [6,tag,caml_call1(sexp_of_x,x),_GZ_]})}]}
    function arg(trunc_after,ts)
     {return [246,function(_GX_){return [7,trunc_after,map$9(ts,to_message)]}]}
    var Exn=[248,cst_Base_Info_Exn,caml_fresh_oo_id(0)];
    function _aP_(param)
     {if(param[1] !== Exn)throw [0,Assert_failure$0,_aQ_];
      var t=param[2];
      return sexp_of_t$22(t)}
    caml_call4(Sexplib0_Sexp_conv[70][1],0,0,Exn,_aP_);
    function to_exn(t)
     {if(! caml_call1(is_val,t))return [0,Exn,t];
      var
       _GV_=caml_obj_tag(t),
       _GW_=250 === _GV_?t[1]:246 === _GV_?caml_call1(CamlinternalLazy[2],t):t;
      if(2 !== _GW_[0])return [0,Exn,t];
      var exn=_GW_[1];
      return exn}
    function of_exn(backtrace,exn)
     {if(backtrace)
       {var _GQ_=backtrace[1];
        if(typeof _GQ_ === "number")
         var _GR_=[0,caml_call1(Stdlib_Printexc[6],0)];
        else
         var s=_GQ_[2],_GR_=[0,s];
        var backtrace$0=_GR_}
      else
       var backtrace$0=0;
      if(exn[1] === Exn)
       {var _GS_=exn[2];
        if(! backtrace$0)return _GS_;
        var backtrace$1=backtrace$0[1];
        return [246,function(_GU_){return [8,to_message(_GS_),backtrace$1]}]}
      if(! backtrace$0)return caml_call1(from_val,[2,exn]);
      var backtrace$2=backtrace$0[1];
      return [246,
              function(_GT_)
               {return [8,[3,caml_call1(sexp_of_exn,exn)],backtrace$2]}]}
    function pp$2(ppf,t)
     {var _GP_=to_string_hum$0(t);
      return caml_call2(Stdlib_Format[13],ppf,_GP_)}
    var
     include$30=_v_([0,pp$2,module_name$0]),
     pp$3=include$30[1],
     Internal_repr=[0,sexp_of_t$21,to_message,of_message],
     include$31=
      [0,
       compare$24,
       equal$12,
       hash_fold_t$16,
       hash$3,
       t_of_sexp$15,
       sexp_of_t$22,
       t_sexp_grammar$14,
       invariant$2,
       to_string_hum$0,
       to_string_mach$1,
       to_string_hum_deprecated,
       of_string$2,
       of_lazy,
       of_lazy_sexp,
       of_thunk,
       of_lazy_t,
       create$2,
       create_s$0,
       createf,
       tag,
       tag_s,
       tag_s_lazy,
       tag_arg,
       arg,
       of_exn,
       to_exn,
       pp$3,
       Internal_repr];
    caml_register_global(1042,include$31,"Base__Info");
    function raise(t){throw to_exn(t)}
    function raise_s(sexp){return raise(create_s$0(sexp))}
    function to_info(t){return t}
    function of_info(t){return t}
    var
     include$32=_v_([0,pp$3,module_name$1]),
     pp$4=include$32[1],
     Base_Error=
      [0,
       compare$24,
       equal$12,
       hash_fold_t$16,
       hash$3,
       t_of_sexp$15,
       sexp_of_t$22,
       t_sexp_grammar$15,
       invariant$2,
       to_string_hum$0,
       to_string_mach$1,
       to_string_hum_deprecated,
       of_string$2,
       of_lazy,
       of_lazy_sexp,
       of_thunk,
       of_lazy_t,
       create$2,
       create_s$0,
       createf,
       tag,
       tag_s,
       tag_s_lazy,
       tag_arg,
       arg,
       of_exn,
       to_exn,
       pp$4,
       Internal_repr,
       raise,
       raise_s,
       to_info,
       of_info];
    caml_register_global(1043,Base_Error,"Base__Error");
    function invariant$3(here,t,sexp_of_t,f)
     {try
       {var _GO_=caml_call1(f,0);return _GO_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        var
         _GM_=[0,[0,cst$9,caml_call1(sexp_of_t,t)],0],
         _GN_=[0,[0,cst_exn,caml_call1(sexp_of_exn,exn)],_GM_];
        return raise_s
                (caml_call2
                  (message,
                   cst_invariant_failed,
                   [0,[0,cst$10,sexp_of_t$15(here)],_GN_]))}}
    function check_field(t,f,field)
     {try
       {var _GL_=caml_call1(f,get(field,t));return _GL_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        var _GK_=[0,[0,cst_exn$0,caml_call1(sexp_of_exn,exn)],0];
        return raise_s
                (caml_call2
                  (message,
                   cst_problem_with_field,
                   [0,[0,cst_field,caml_call1(sexp_of_t$2,field[2])],_GK_]))}}
    var Base_Invariant=[0,invariant$3,check_field];
    caml_register_global(1044,Base_Invariant,"Base__Invariant");
    function compare$25(cmp_a,a_001,b_002)
     {return compare$20(cmp_a,compare$24,a_001,b_002)}
    function equal$13(cmp_a,a_007,b_008)
     {return equal$9(cmp_a,equal$12,a_007,b_008)}
    function hash_fold_t$17(hash_fold_a,hsv,arg)
     {return hash_fold_t$13(hash_fold_a,hash_fold_t$16,hsv,arg)}
    function t_of_sexp$16(of_a_013,x_015)
     {return t_of_sexp$12(of_a_013,t_of_sexp$15,x_015)}
    function sexp_of_t$23(of_a_016,x_017)
     {return sexp_of_t$16(of_a_016,sexp_of_t$22,x_017)}
    function t_sexp_grammar$16(a_sexp_grammar)
     {return t_sexp_grammar$9(a_sexp_grammar,t_sexp_grammar$15)}
    function invariant$4(invariant_a,t)
     {if(0 !== t[0])return 0;var a=t[1];return caml_call1(invariant_a,a)}
    function apply$0(f,x)
     {function _GJ_(e1,e2){return arg(0,[0,e1,[0,e2,0]])}
      return combine(f,x,function(f,x){return caml_call1(f,x)},_GJ_)}
    var
     map$13=[0,-198771759,map$5],
     include$33=Make$0([0,return$3,apply$0,map$13]),
     return$8=include$33[1],
     map$14=include$33[2],
     both$0=include$33[3],
     symbol$66=include$33[4],
     symbol$67=include$33[5],
     symbol$68=include$33[6],
     symbol_map$3=include$33[7],
     apply$1=include$33[8],
     map2$1=include$33[9],
     map3$1=include$33[10],
     all$5=include$33[11],
     all_unit$3=include$33[12],
     Applicative_infix=include$33[13],
     symbol_bind$3=include$26[1],
     symbol_map$4=include$26[2],
     Open_on_rhs$0=[0];
    function try_with$0(opt,f)
     {if(opt)var sth=opt[1],backtrace=sth;else var backtrace=0;
      try
       {var _GI_=[0,caml_call1(f,0)];return _GI_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        var _GH_=backtrace?_aR_:0;
        return [1,of_exn(_GH_,exn)]}}
    function try_with_join(backtrace,f)
     {return caml_call1(join$0,try_with$0(backtrace,f))}
    function ok_exn$0(param)
     {if(0 === param[0]){var x=param[1];return x}
      var err=param[1];
      return raise(err)}
    function of_exn$0(backtrace,exn){return [1,of_exn(backtrace,exn)]}
    function of_exn_result(backtrace,z)
     {if(0 === z[0])return z;var exn=z[1];return of_exn$0(backtrace,exn)}
    function error$0(here,strict,message,a,sexp_of_a)
     {return [1,create$2(here,strict,message,a,sexp_of_a)]}
    function error_s(sexp){return [1,create_s$0(sexp)]}
    function error_string(message){return [1,of_string$2(message)]}
    function errorf(format){return caml_call2(ksprintf,error_string,format)}
    function tag$0(t,tag$0)
     {return map_error(t,function(_GG_){return tag(_GG_,tag$0)})}
    function tag_s$0(t,tag)
     {return map_error(t,function(_GF_){return tag_s(_GF_,tag)})}
    function tag_s_lazy$0(t,tag)
     {return map_error(t,function(_GE_){return tag_s_lazy(_GE_,tag)})}
    function tag_arg$0(t,message,a,sexp_of_a)
     {return map_error(t,function(e){return tag_arg(e,message,a,sexp_of_a)})}
    function unimplemented(s)
     {return error$0(0,0,cst_unimplemented,s,sexp_of_t$2)}
    function combine_errors$0(l)
     {function _GD_(eta){return arg(0,eta)}
      return map_error(combine_errors(l),_GD_)}
    function combine_errors_unit$0(l)
     {function _GC_(param){return 0}
      return caml_call2(map$5,combine_errors$0(l),_GC_)}
    function filter_ok_at_least_one(l)
     {var match=partition_map(l,to_either),errs=match[2],ok=match[1];
      return ok?[0,ok]:[1,arg(0,errs)]}
    function find_ok(l)
     {var match=find_map$0(l,ok);
      if(! match)
       return [1,
               arg
                (0,
                 map$9
                  (l,
                   function(param)
                    {if(0 === param[0])throw [0,Assert_failure$0,_aS_];
                     var err=param[1];
                     return err}))];
      var x=match[1];
      return [0,x]}
    function find_map_ok(l,f)
     {return with_return
              (function(param)
                {return [1,
                         arg
                          (0,
                           map$9
                            (l,
                             function(elt)
                              {var x=caml_call1(f,elt);
                               if(0 === x[0])return caml_call1(param,x);
                               var err=x[1];
                               return err}))]})}
    var
     Base_Or_error=
      [0,
       compare$25,
       equal$13,
       hash_fold_t$17,
       t_of_sexp$16,
       sexp_of_t$23,
       t_sexp_grammar$16,
       both$0,
       symbol$66,
       symbol$67,
       symbol$68,
       apply$1,
       map2$1,
       map3$1,
       Applicative_infix,
       invariant$4,
       symbol_bind$0,
       symbol_map$3,
       include$26,
       bind$2,
       return$8,
       join$0,
       ignore_m$0,
       all$5,
       all_unit$3,
       [0,
        return$8,
        symbol_bind$3,
        symbol_map$4,
        [0,return$8,bind$2,map$14,both$0,Open_on_rhs$0]],
       is_ok,
       is_error,
       try_with$0,
       try_with_join,
       ok,
       ok_exn$0,
       of_exn$0,
       of_exn_result,
       error$0,
       error_s,
       error_string,
       errorf,
       tag$0,
       tag_s$0,
       tag_s_lazy$0,
       tag_arg$0,
       unimplemented,
       map$5,
       iter$2,
       iter_error,
       combine_errors$0,
       combine_errors_unit$0,
       filter_ok_at_least_one,
       find_ok,
       find_map_ok];
    caml_register_global(1045,Base_Or_error,"Base__Or_error");
    function t_of_sexp$17(sexp_004)
     {if(0 === sexp_004[0])
       {var _Gy_=sexp_004[1],switch$0=0;
        if(caml_string_notequal(_Gy_,cst_Neg))
         {var switch$1=0;
          if(caml_string_notequal(_Gy_,cst_Pos))
           {var switch$2=0;
            if(caml_string_notequal(_Gy_,cst_Zero))
             if(caml_string_notequal(_Gy_,cst_neg))
              if(caml_string_notequal(_Gy_,cst_pos))
               {if(caml_string_notequal(_Gy_,cst_zero))
                 {switch$0 = 1;switch$1 = 1;switch$2 = 1}}
              else
               switch$2 = 1;
             else
              {switch$1 = 1;switch$2 = 1}
            if(! switch$2)return 1}
          if(! switch$1)return 2}
        if(! switch$0)return 0}
      else
       {var _Gz_=sexp_004[1];
        if(! _Gz_)
         return caml_call2
                 (Sexplib0_Sexp_conv_error[7],error_source_003,sexp_004);
        var _GA_=_Gz_[1];
        if(0 !== _GA_[0])
         return caml_call2
                 (Sexplib0_Sexp_conv_error[6],error_source_003,sexp_004);
        var _GB_=_GA_[1],switch$3=0;
        if(caml_string_notequal(_GB_,cst_Neg$0))
         {var switch$4=0;
          if(caml_string_notequal(_GB_,cst_Pos$0))
           {var switch$5=0;
            if(caml_string_notequal(_GB_,cst_Zero$0))
             if(caml_string_notequal(_GB_,cst_neg$0))
              if(caml_string_notequal(_GB_,cst_pos$0))
               {if(caml_string_notequal(_GB_,cst_zero$0))
                 {switch$3 = 1;switch$4 = 1;switch$5 = 1}}
              else
               switch$5 = 1;
             else
              {switch$4 = 1;switch$5 = 1}
            if(! switch$5)
             return caml_call2
                     (Sexplib0_Sexp_conv_error[3],error_source_003,sexp_004)}
          if(! switch$4)
           return caml_call2
                   (Sexplib0_Sexp_conv_error[3],error_source_003,sexp_004)}
        if(! switch$3)
         return caml_call2
                 (Sexplib0_Sexp_conv_error[3],error_source_003,sexp_004)}
      return caml_call2(Sexplib0_Sexp_conv_error[8],error_source_003,sexp_004)}
    function sexp_of_t$24(param)
     {switch(param){case 0:return _aT_;case 1:return _aU_;default:return _aV_}}
    var compare$26=caml_int_compare;
    function hash_fold_t$18(hsv,arg)
     {switch(arg)
       {case 0:return runtime.Base_internalhash_fold_int(hsv,0);
        case 1:return runtime.Base_internalhash_fold_int(hsv,1);
        default:return runtime.Base_internalhash_fold_int(hsv,2)}}
    function symbol$69(x,y){return x < y?1:0}
    function symbol$70(x,y){return x <= y?1:0}
    function symbol$71(x,y){return x !== y?1:0}
    function symbol$72(x,y){return x === y?1:0}
    function symbol$73(x,y){return y < x?1:0}
    function symbol$74(x,y){return y <= x?1:0}
    var ascending$10=caml_compare;
    function descending$10(x,y){return caml_compare(y,x)}
    var compare$27=caml_int_compare;
    function equal$14(x,y){return x === y?1:0}
    function max$12(x,y){return y <= x?x:y}
    function min$12(x,y){return x <= y?x:y}
    var
     Replace_polymorphic_compare=
      [0,
       symbol$69,
       symbol$70,
       symbol$71,
       symbol$72,
       symbol$73,
       symbol$74,
       ascending$10,
       descending$10,
       compare$27,
       equal$14,
       max$12,
       min$12];
    function of_string$3(s){return t_of_sexp$17(caml_call1(sexp_of_t$2,s))}
    function to_string$4(t){return caml_call1(t_of_sexp$2,sexp_of_t$24(t))}
    function to_int$1(param)
     {switch(param){case 0:return -1;case 1:return 0;default:return 1}}
    function sign(n){return 0 <= n?0 === n?1:2:0}
    var
     Base_Sign0=
      [0,
       t_of_sexp$17,
       sexp_of_t$24,
       t_sexp_grammar$17,
       compare$26,
       hash_fold_t$18,
       all$6,
       Replace_polymorphic_compare,
       of_string$3,
       to_string$4,
       to_int$1,
       to_int$1,
       module_name$2,
       sign];
    caml_register_global(1046,Base_Sign0,"Base__Sign0");
    var Base_Comparable_intf=[0];
    caml_register_global(1047,Base_Comparable_intf,"Base__Comparable_intf");
    function geq(cmp,a,b){return 0 <= caml_call2(cmp,a,b)?1:0}
    function leq(cmp,a,b){return caml_call2(cmp,a,b) <= 0?1:0}
    function equal$15(cmp,a,b){return 0 === caml_call2(cmp,a,b)?1:0}
    function min$13(cmp,t$0,t){return leq(cmp,t$0,t)?t$0:t}
    function max$13(cmp,t$0,t){return geq(cmp,t$0,t)?t$0:t}
    function Infix$0(T)
     {function symbol(a,b){return 0 < caml_call2(T[1],a,b)?1:0}
      function symbol$0(a,b){return caml_call2(T[1],a,b) < 0?1:0}
      function symbol$1(a,b){return geq(T[1],a,b)}
      function symbol$2(a,b){return leq(T[1],a,b)}
      function symbol$3(a,b){return equal$15(T[1],a,b)}
      function symbol$4(a,b){return 0 !== caml_call2(T[1],a,b)?1:0}
      return [0,symbol$1,symbol$2,symbol$3,symbol,symbol$0,symbol$4]}
    function Polymorphic_compare(T)
     {var
       include=Infix$0(T),
       symbol=include[1],
       symbol$0=include[2],
       symbol$1=include[3],
       symbol$2=include[4],
       symbol$3=include[5],
       symbol$4=include[6],
       compare=T[1];
      function min(t$0,t){return min$13(compare,t$0,t)}
      function max(t$0,t){return max$13(compare,t$0,t)}
      return [0,
              symbol,
              symbol$0,
              symbol$1,
              symbol$2,
              symbol$3,
              symbol$4,
              symbol$1,
              compare,
              min,
              max]}
    function Make_using_comparator(T)
     {var
       sexp_of_t=T[1],
       comparator=T[2],
       compare=comparator[1],
       Replace_polymorphic_compare=Polymorphic_compare([0,compare]),
       symbol=Replace_polymorphic_compare[1],
       symbol$0=Replace_polymorphic_compare[2],
       symbol$1=Replace_polymorphic_compare[3],
       symbol$2=Replace_polymorphic_compare[4],
       symbol$3=Replace_polymorphic_compare[5],
       symbol$4=Replace_polymorphic_compare[6],
       equal=Replace_polymorphic_compare[7],
       compare$0=Replace_polymorphic_compare[8],
       min=Replace_polymorphic_compare[9],
       max=Replace_polymorphic_compare[10];
      function descending(t$0,t){return caml_call2(compare$0,t,t$0)}
      function between(t,low,high)
       {var _Gx_=caml_call2(symbol$0,low,t);
        return _Gx_?caml_call2(symbol$0,t,high):_Gx_}
      function clamp_unchecked(t,min,max)
       {return caml_call2(symbol$3,t,min)?min:caml_call2(symbol$0,t,max)?t:max}
      function clamp_exn(t,min,max)
       {if(caml_call2(symbol$0,min,max))return clamp_unchecked(t,min,max);
        throw [0,Assert_failure$0,_aX_]}
      function clamp(t,min,max)
       {if(! caml_call2(symbol$2,min,max))
         return [0,clamp_unchecked(t,min,max)];
        var _Gw_=[0,[0,cst_max$0,caml_call1(sexp_of_t,max)],0];
        return error_s
                (caml_call2
                  (message,
                   cst_clamp_requires_min_max$0,
                   [0,[0,cst_min$0,caml_call1(sexp_of_t,min)],_Gw_]))}
      return [0,
              symbol,
              symbol$0,
              symbol$1,
              symbol$2,
              symbol$3,
              symbol$4,
              equal,
              compare$0,
              min,
              max,
              compare$0,
              descending,
              between,
              clamp_exn,
              clamp,
              comparator]}
    function Make$1(T)
     {var sexp_of_t=T[2],include=_P_(T),comparator=include[1];
      return Make_using_comparator([0,sexp_of_t,comparator])}
    function Inherit(C,T)
     {var sexp_of_t=T[1];
      function compare(t$0,t)
       {var _Gu_=caml_call1(T[2],t),_Gv_=caml_call1(T[2],t$0);
        return caml_call2(C[1],_Gv_,_Gu_)}
      return Make$1([0,compare,sexp_of_t])}
    function lexicographic(param,x,y)
     {var param$0=param;
      for(;;)
       {if(! param$0)return 0;
        var cmps=param$0[2],cmp=param$0[1],res=caml_call2(cmp,x,y);
        if(0 !== res)return res;
        var param$0=cmps}}
    function lift(cmp,f,x,y)
     {var _Gt_=caml_call1(f,y);return caml_call2(cmp,caml_call1(f,x),_Gt_)}
    function reverse(cmp,x,y){return caml_call2(cmp,y,x)}
    function _aY_(_Gq_)
     {var _Gr_=_Gq_[3],_Gs_=_Gq_[1];
      function is_positive(t){return 0 < caml_call2(_Gs_,t,_Gr_)?1:0}
      function is_non_negative(t){return 0 <= caml_call2(_Gs_,t,_Gr_)?1:0}
      function is_negative(t){return caml_call2(_Gs_,t,_Gr_) < 0?1:0}
      function is_non_positive(t){return caml_call2(_Gs_,t,_Gr_) <= 0?1:0}
      function sign$0(t){return sign(caml_call2(_Gs_,t,_Gr_))}
      return [0,
              is_positive,
              is_non_negative,
              is_negative,
              is_non_positive,
              sign$0]}
    var
     Base_Comparable=
      [0,
       lexicographic,
       lift,
       reverse,
       equal$15,
       max$13,
       min$13,
       Infix$0,
       Polymorphic_compare,
       Inherit,
       Make$1,
       Make_using_comparator,
       function(T)
        {var sexp_of_t=T[1];
         function between(t,low,high)
          {var
            _Go_=caml_lessequal(low,t),
            _Gp_=_Go_?caml_lessequal(t,high):_Go_;
           return _Gp_}
         function clamp_unchecked(t,min,max)
          {return caml_lessthan(t,min)?min:caml_lessequal(t,max)?t:max}
         function clamp_exn(t,min,max)
          {if(caml_lessequal(min,max))return clamp_unchecked(t,min,max);
           throw [0,Assert_failure$0,_aW_]}
         function clamp(t,min,max)
          {if(! caml_greaterthan(min,max))
            return [0,clamp_unchecked(t,min,max)];
           var _Gn_=[0,[0,cst_max,caml_call1(T[1],max)],0];
           return error_s
                   (caml_call2
                     (message,
                      cst_clamp_requires_min_max,
                      [0,[0,cst_min,caml_call1(T[1],min)],_Gn_]))}
         var include=_P_([0,caml_compare,sexp_of_t]),comparator=include[1];
         return [0,
                 caml_greaterequal,
                 caml_lessequal,
                 caml_equal,
                 caml_greaterthan,
                 caml_lessthan,
                 caml_notequal,
                 caml_equal,
                 caml_compare,
                 min,
                 max,
                 ascending,
                 descending,
                 between,
                 clamp_exn,
                 clamp,
                 comparator]},
       _aY_];
    caml_register_global(1048,Base_Comparable,"Base__Comparable");
    function equal$16(a,b)
     {var _Gj_=a === b?1:0;
      if(_Gj_)
       var _Gk_=_Gj_;
      else
       {var _Gl_=a[1] === b[1]?1:0;
        if(_Gl_)
         {var _Gm_=a[2] === b[2]?1:0;
          if(_Gm_)return a[3] === b[3]?1:0;
          var _Gk_=_Gm_}
        else
         var _Gk_=_Gl_}
      return _Gk_}
    var
     hash_param=Stdlib_MoreLabels[1][30],
     hash$4=Stdlib_MoreLabels[1][28],
     poly=[0,hash$4,caml_compare,function(param){return _aZ_}];
    function of_key(Key){return [0,Key[3],Key[1],Key[2]]}
    function to_key(param)
     {var sexp_of_t=param[3],compare=param[2],hash=param[1];
      return [0,compare,sexp_of_t,hash]}
    var
     Hashable$0=[0,equal$16,hash_param,hash$4,poly,of_key,to_key],
     equal$17=Hashable$0[1],
     hash_param$0=Hashable$0[2],
     hash$5=Hashable$0[3],
     hashable=Hashable$0[4],
     of_key$0=Hashable$0[5],
     to_key$0=Hashable$0[6],
     include$34=
      [0,Hashable$0,equal$17,hash_param$0,hash$5,hashable,of_key$0,to_key$0];
    caml_register_global(1050,include$34,"Base__Hashable_intf");
    var
     Base_Hashable=
      [0,equal$17,hashable,of_key$0,to_key$0,hash_param$0,hash$5];
    caml_register_global(1051,Base_Hashable,"Base__Hashable");
    var Base_Stringable=[0];
    caml_register_global(1052,Base_Stringable,"Base__Stringable");
    var Base_Identifiable_intf=[0];
    caml_register_global
     (1053,Base_Identifiable_intf,"Base__Identifiable_intf");
    function _a0_(T)
     {var
       hash_fold_t=T[2],
       hash=T[3],
       t_of_sexp=T[4],
       sexp_of_t=T[5],
       of_string=T[6],
       to_string=T[7],
       _Gi_=Make_using_comparator([0,T[5],T[9]]),
       symbol=_Gi_[1],
       symbol$0=_Gi_[2],
       symbol$1=_Gi_[3],
       symbol$2=_Gi_[4],
       symbol$3=_Gi_[5],
       symbol$4=_Gi_[6],
       equal=_Gi_[7],
       compare=_Gi_[8],
       min=_Gi_[9],
       max=_Gi_[10],
       ascending=_Gi_[11],
       descending=_Gi_[12],
       between=_Gi_[13],
       clamp_exn=_Gi_[14],
       clamp=_Gi_[15],
       comparator=_Gi_[16],
       include=_w_([0,T[8],T[7]]),
       pp=include[1],
       hashable=[0,hash,compare,sexp_of_t];
      return [0,
              hash_fold_t,
              hash,
              t_of_sexp,
              sexp_of_t,
              of_string,
              to_string,
              symbol,
              symbol$0,
              symbol$1,
              symbol$2,
              symbol$3,
              symbol$4,
              equal,
              compare,
              min,
              max,
              ascending,
              descending,
              between,
              clamp_exn,
              clamp,
              comparator,
              pp,
              hashable]}
    function _a1_(T)
     {var
       hash_fold_t=T[2],
       hash=T[3],
       t_of_sexp=T[4],
       sexp_of_t=T[5],
       of_string=T[6],
       to_string=T[7],
       _Gh_=Make$1([0,T[1],T[5]]),
       symbol=_Gh_[1],
       symbol$0=_Gh_[2],
       symbol$1=_Gh_[3],
       symbol$2=_Gh_[4],
       symbol$3=_Gh_[5],
       symbol$4=_Gh_[6],
       equal=_Gh_[7],
       compare=_Gh_[8],
       min=_Gh_[9],
       max=_Gh_[10],
       ascending=_Gh_[11],
       descending=_Gh_[12],
       between=_Gh_[13],
       clamp_exn=_Gh_[14],
       clamp=_Gh_[15],
       comparator=_Gh_[16],
       include=_w_([0,T[8],T[7]]),
       pp=include[1],
       hashable=[0,hash,compare,sexp_of_t];
      return [0,
              hash_fold_t,
              hash,
              t_of_sexp,
              sexp_of_t,
              of_string,
              to_string,
              symbol,
              symbol$0,
              symbol$1,
              symbol$2,
              symbol$3,
              symbol$4,
              equal,
              compare,
              min,
              max,
              ascending,
              descending,
              between,
              clamp_exn,
              clamp,
              comparator,
              pp,
              hashable]}
    var Base_Identifiable=[0,_a1_,_a0_];
    caml_register_global(1054,Base_Identifiable,"Base__Identifiable");
    function hash$6(x){return caml_call1(func$6,x)}
    function compare$28(param,_Gg_){return 0}
    function of_string$4(param)
     {return caml_string_notequal(param,cst$11)
              ?caml_call1(failwith$0,cst_Base_Unit_of_string_expect)
              :0}
    function to_string$5(param){return cst$12}
    var
     include$35=
      _a1_
       ([0,
         compare$28,
         hash_fold_t$8,
         hash$6,
         t_of_sexp$0,
         sexp_of_t$0,
         of_string$4,
         to_string$5,
         module_name$3]),
     hash_fold_unit$0=include$35[1],
     func$7=include$35[2],
     unit_of_sexp=include$35[3],
     sexp_of_unit=include$35[4],
     of_string$5=include$35[5],
     to_string$6=include$35[6],
     symbol$75=include$35[7],
     symbol$76=include$35[8],
     symbol$77=include$35[9],
     symbol$78=include$35[10],
     symbol$79=include$35[11],
     symbol$80=include$35[12],
     equal_unit$1=include$35[13],
     compare_unit$1=include$35[14],
     min$14=include$35[15],
     max$14=include$35[16],
     ascending$11=include$35[17],
     descending$11=include$35[18],
     between=include$35[19],
     clamp_exn=include$35[20],
     clamp=include$35[21],
     comparator$1=include$35[22],
     pp$5=include$35[23],
     hashable$0=include$35[24];
    function invariant$5(param){return 0}
    var
     Base_Unit=
      [0,
       all$7,
       unit_sexp_grammar,
       hash_fold_unit$0,
       func$7,
       unit_of_sexp,
       sexp_of_unit,
       of_string$5,
       to_string$6,
       symbol$75,
       symbol$76,
       symbol$77,
       symbol$78,
       symbol$79,
       symbol$80,
       equal_unit$1,
       compare_unit$1,
       min$14,
       max$14,
       ascending$11,
       descending$11,
       between,
       clamp_exn,
       clamp,
       comparator$1,
       pp$5,
       hashable$0,
       invariant$5];
    caml_register_global(1055,Base_Unit,"Base__Unit");
    function get_pos_len(pos,len,param,total_length)
     {try
       {var _Gf_=[0,get_pos_len_exn(pos,len,0,total_length)];return _Gf_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] !== Stdlib[6])throw exn;
        var s=exn[2];
        return error_string(s)}}
    var
     Base_Ordered_collection_common=
      [0,get_pos_len_exn,check_pos_len_exn,Private$1,get_pos_len];
    caml_register_global
     (1056,Base_Ordered_collection_common,"Base__Ordered_collection_common");
    function find_first_satisfying(pos,len,t,get,length,pred)
     {var
       match=get_pos_len_exn(pos,len,0,caml_call1(length,t)),
       len$0=match[2],
       pos$0=match[1],
       hi$0=(pos$0 + len$0 | 0) - 1 | 0,
       lo$1=pos$0,
       hi=hi$0;
      for(;;)
       {if(8 < (hi - lo$1 | 0))
         {var mid=lo$1 + ((hi - lo$1 | 0) / 2 | 0) | 0;
          if(caml_call1(pred,caml_call2(get,t,mid))){var hi=mid;continue}
          var lo$2=mid + 1 | 0,lo$1=lo$2;
          continue}
        var lo=lo$1;
        for(;;)
         {if(hi < lo)return 0;
          if(caml_call1(pred,caml_call2(get,t,lo)))return [0,lo];
          var lo$0=lo + 1 | 0,lo=lo$0}}}
    function find_last_satisfying(pos,len,t,pred,get,length)
     {var
       match=get_pos_len_exn(pos,len,0,caml_call1(length,t)),
       len$0=match[2],
       pos$0=match[1];
      if(0 === len$0)return 0;
      var
       match$0=
        find_first_satisfying
         ([0,pos$0],
          [0,len$0],
          t,
          get,
          length,
          function(_Ge_){return non(pred,_Ge_)});
      if(! match$0)return [0,(pos$0 + len$0 | 0) - 1 | 0];
      var i=match$0[1];
      return i === pos$0?0:[0,i - 1 | 0]}
    function binary_search(pos,len,t,length,get,compare,how,v)
     {if(-839473056 <= how)
       return 200870407 <= how
               ?926943384 <= how
                 ?find_first_satisfying
                   (pos,
                    len,
                    t,
                    get,
                    length,
                    function(x){return 0 <= caml_call2(compare,x,v)?1:0})
                 :find_last_satisfying
                   (pos,
                    len,
                    t,
                    function(x){return caml_call2(compare,x,v) < 0?1:0},
                    get,
                    length)
               :-253007807 <= how
                 ?find_last_satisfying
                   (pos,
                    len,
                    t,
                    function(x){return caml_call2(compare,x,v) <= 0?1:0},
                    get,
                    length)
                 :find_first_satisfying
                   (pos,
                    len,
                    t,
                    get,
                    length,
                    function(x){return 0 < caml_call2(compare,x,v)?1:0});
      if(-1055410545 <= how)
       {var
         match=
          find_last_satisfying
           (pos,
            len,
            t,
            function(x){return caml_call2(compare,x,v) <= 0?1:0},
            get,
            length);
        if(match)
         {var x=match[1];
          if(0 === caml_call2(compare,caml_call2(get,t,x),v))return [0,x]}
        return 0}
      var
       match$0=
        find_first_satisfying
         (pos,
          len,
          t,
          get,
          length,
          function(x){return 0 <= caml_call2(compare,x,v)?1:0});
      if(match$0)
       {var x$0=match$0[1];
        if(0 === caml_call2(compare,caml_call2(get,t,x$0),v))return [0,x$0]}
      return 0}
    function binary_search_segmented(pos,len,t,length,get,segment_of,how)
     {function is_left(x)
       {var match=caml_call1(segment_of,x);return 847852583 <= match?1:0}
      function is_right(x){return 1 - is_left(x)}
      return 125585502 <= how
              ?find_last_satisfying(pos,len,t,is_left,get,length)
              :find_first_satisfying(pos,len,t,get,length,is_right)}
    var Base_Binary_search=[0,binary_search,binary_search_segmented];
    caml_register_global(1057,Base_Binary_search,"Base__Binary_search");
    var
     Which_target_by_key=[0,all$8],
     Which_target_by_segment=[0,all$9],
     Base_Binary_searchable_intf=
      [0,Which_target_by_key,Which_target_by_segment];
    caml_register_global
     (1058,Base_Binary_searchable_intf,"Base__Binary_searchable_intf");
    function Make_gen$0(T)
     {var get=T[1],length=T[2];
      function binary_search$0(pos,len,t,compare,how,v)
       {return binary_search(pos,len,t,length,get,compare,how,v)}
      function binary_search_segmented$0(pos,len,t,segment_of,how)
       {return binary_search_segmented(pos,len,t,length,get,segment_of,how)}
      return [0,get,length,binary_search$0,binary_search_segmented$0]}
    function _a2_(T)
     {var get=T[1],length=T[2],_Gd_=Make_gen$0([0,get,length]);
      return [0,_Gd_[3],_Gd_[4]]}
    var
     Base_Binary_searchable=
      [0,
       function(T)
        {var get=T[1],length=T[2],_Gc_=Make_gen$0([0,get,length]);
         return [0,_Gc_[3],_Gc_[4]]},
       _a2_];
    caml_register_global
     (1059,Base_Binary_searchable,"Base__Binary_searchable");
    var Base_Blit_intf=[0];
    caml_register_global(1060,Base_Blit_intf,"Base__Blit_intf");
    function Make_gen$1(Src,Dst)
     {var unsafe_blit=Dst[3];
      function blit(src,src_pos,dst,dst_pos,len)
       {check_pos_len_exn(src_pos,len,caml_call1(Src[1],src));
        check_pos_len_exn(dst_pos,len,caml_call1(Dst[1],dst));
        var _Gb_=0 < len?1:0;
        return _Gb_?caml_call5(unsafe_blit,src,src_pos,dst,dst_pos,len):_Gb_}
      function blito(src,opt,_Ga_,dst,_F$_,param)
       {if(opt)var sth=opt[1],src_pos=sth;else var src_pos=0;
        if(_Ga_)
         var sth$0=_Ga_[1],src_len=sth$0;
        else
         var src_len=caml_call1(Src[1],src) - src_pos | 0;
        if(_F$_)var sth$1=_F$_[1],dst_pos=sth$1;else var dst_pos=0;
        return blit(src,src_pos,dst,dst_pos,src_len)}
      function sub(src,pos,len)
       {check_pos_len_exn(pos,len,caml_call1(Src[1],src));
        var dst=caml_call2(Dst[2],len,src);
        if(0 < len)caml_call5(unsafe_blit,src,pos,dst,0,len);
        return dst}
      function subo(opt,len,src)
       {if(opt)var sth=opt[1],pos=sth;else var pos=0;
        if(len)
         var i=len[1],i$0=i;
        else
         var i$0=caml_call1(Src[1],src) - pos | 0;
        return sub(src,pos,i$0)}
      return [0,unsafe_blit,blit,blito,sub,subo]}
    function Make_to_string(T,To_bytes)
     {function sub(src,pos,len)
       {return unsafe_to_string(caml_call3(To_bytes[4],src,pos,len))}
      function subo(pos,len,src)
       {return unsafe_to_string(caml_call3(To_bytes[5],pos,len,src))}
      return [0,sub,subo]}
    function _a3_(_F9_)
     {var _F__=Make_gen$1([0,_F9_[2]],[0,_F9_[2],_F9_[1],_F9_[3]]);
      return [0,_F__[2],_F__[3],_F__[1],_F__[4],_F__[5]]}
    function _a4_(_F6_)
     {var _F7_=[0,_F6_[2],_F6_[1],_F6_[3]],_F8_=Make_gen$1([0,_F7_[1]],_F7_);
      return [0,_F8_[2],_F8_[3],_F8_[1],_F8_[4],_F8_[5]]}
    function _a5_(Src,Dst)
     {var length=Dst[1];
      function create_like(len,param){return caml_call1(Dst[2],len)}
      var
       unsafe_blit=Dst[3],
       length$0=Src[1],
       _F5_=Make_gen$1([0,length$0],[0,length,create_like,unsafe_blit]);
      return [0,_F5_[2],_F5_[3],_F5_[1],_F5_[4],_F5_[5]]}
    function _a6_(Sequence)
     {function create_like(len,param){return caml_call1(Sequence[2],len)}
      var
       length=Sequence[1],
       unsafe_blit=Sequence[3],
       include=Make_gen$1([0,length],[0,length,create_like,unsafe_blit]),
       unsafe_blit$0=include[1],
       blit=include[2],
       blito=include[3],
       sub=include[4],
       subo=include[5];
      return [0,blit,blito,unsafe_blit$0,sub,subo]}
    var Base_Blit=[0,_a6_,_a5_,Make_to_string,_a4_,_a3_];
    caml_register_global(1061,Base_Blit,"Base__Blit");
    var Base_Either_intf=[0];
    caml_register_global(1062,Base_Either_intf,"Base__Either_intf");
    function t_sexp_grammar$18(a_sexp_grammar)
     {return caml_call1(option_sexp_grammar,a_sexp_grammar)}
    function is_none(param){return param?0:1}
    function is_some(param){return param?1:0}
    function value_map(o,default$0,f)
     {if(! o)return default$0;var x=o[1];return caml_call1(f,x)}
    function iter$4(o,f){if(! o)return 0;var a=o[1];return caml_call1(f,a)}
    function invariant$6(f,t){return iter$4(t,f)}
    function call(x,f){if(! f)return 0;var f$0=f[1];return caml_call1(f$0,x)}
    function value(t,default$0){if(! t)return default$0;var x=t[1];return x}
    function value_exn(here,error,message,t)
     {if(t){var x=t[1];return x}
      if(here)
       {var _F0_=here[1];
        if(error)
         var
          e=error[1],
          _F1_=caml_call2(sexp_of_pair,sexp_of_t$22,sexp_of_t$15),
          _F2_=create$2(0,0,value(message,cst$13),[0,e,_F0_],_F1_);
        else
         if(message)
          var m=message[1],_F2_=create$2(0,0,m,_F0_,sexp_of_t$15);
         else
          var _F2_=create$2(0,0,cst_Option_value_exn,_F0_,sexp_of_t$15);
        var error$0=_F2_}
      else
       if(error)
        {var _F3_=error[1];
         if(message)var m$0=message[1],_F4_=tag(_F3_,m$0);else var _F4_=_F3_;
         var error$0=_F4_}
       else
        if(message)
         var m$1=message[1],error$0=of_string$2(m$1);
        else
         var error$0=of_string$2(cst_Option_value_exn_None);
      return raise(error$0)}
    function value_or_thunk(o,default$0)
     {if(! o)return caml_call1(default$0,0);var x=o[1];return x}
    function to_array$0(t){if(! t)return [0];var x=t[1];return [0,x]}
    function to_list$2(t){if(! t)return 0;var x=t[1];return [0,x,0]}
    function min_elt$1(t,param){return t}
    function max_elt$1(t,param){return t}
    function sum$1(M){return function(t,f){return value_map(t,M[1],f)}}
    function for_all$1(t,f){if(! t)return 1;var x=t[1];return caml_call1(f,x)}
    function exists$1(t,f){if(! t)return 0;var x=t[1];return caml_call1(f,x)}
    function mem$1(t,a,equal)
     {if(! t)return 0;var a$0=t[1];return caml_call2(equal,a,a$0)}
    function length$1(t){return t?1:0}
    function fold$0(t,init,f)
     {if(! t)return init;var x=t[1];return caml_call2(f,init,x)}
    function count$1(t,f)
     {if(! t)return 0;var a=t[1];return caml_call1(f,a)?1:0}
    function find$2(t,f)
     {if(! t)return 0;var x=t[1];return caml_call1(f,x)?t:0}
    function find_map$1(t,f)
     {if(! t)return 0;var a=t[1];return caml_call1(f,a)}
    function equal_option$1(f,t$0,t)
     {if(t$0)
       {if(t){var x=t[1],x$0=t$0[1];return caml_call2(f,x$0,x)}}
      else
       if(! t)return 1;
      return 0}
    function some(x){return [0,x]}
    function first_some(x,y){return x?x:y}
    function some_if(cond,x){return cond?[0,x]:0}
    function merge$0(a,b,f)
     {if(a)
       {if(b){var b$0=b[1],a$0=a[1];return [0,caml_call2(f,a$0,b$0)]}var x=a}
      else
       var x=b;
      return x}
    function filter$0(o,f)
     {if(o){var v=o[1];if(caml_call1(f,v))return o}return 0}
    function try_with$1(f)
     {try {var x=caml_call1(f,0)}catch(_FZ_){return 0}return [0,x]}
    function try_with_join$0(f)
     {try {var x=caml_call1(f,0);return x}catch(_FY_){return 0}}
    function _a7_(t,f){if(! t)return 0;var a=t[1];return [0,caml_call1(f,a)]}
    function apply$2(f,x){if(! f)return 0;var f$0=f[1];return _a7_(x,f$0)}
    function return$9(x){return [0,x]}
    var map$15=[0,-198771759,_a7_];
    function bind$7(o,f){if(! o)return 0;var x=o[1];return caml_call1(f,x)}
    var
     _a8_=Make([0,bind$7,return$9,map$15]),
     symbol_bind$4=_a8_[1],
     Monad_infix$2=_a8_[3],
     bind$8=_a8_[4],
     join$3=_a8_[7],
     ignore_m$3=_a8_[8],
     Let_syntax$4=_a8_[11],
     include$36=Make$0([0,return$9,apply$2,map$15]),
     return$10=include$36[1],
     map$16=include$36[2],
     both$1=include$36[3],
     symbol$81=include$36[4],
     symbol$82=include$36[5],
     symbol$83=include$36[6],
     symbol_map$5=include$36[7],
     apply$3=include$36[8],
     map2$2=include$36[9],
     map3$2=include$36[10],
     all$10=include$36[11],
     all_unit$4=include$36[12],
     Applicative_infix$0=include$36[13];
    function fold_result$1(t,init,f){return fold_result(fold$0,init,f,t)}
    function fold_until$1(t,init,f)
     {return function(_FX_){return fold_until(fold$0,init,f,_FX_,t)}}
    var
     Base_Option=
      [0,
       compare_option$0,
       hash_fold_option$0,
       t_sexp_grammar$18,
       equal_option$1,
       invariant$6,
       option_of_sexp,
       sexp_of_option,
       both$1,
       symbol$81,
       symbol$82,
       symbol$83,
       apply$3,
       map2$2,
       map3$2,
       Applicative_infix$0,
       symbol_bind$4,
       symbol_map$5,
       Monad_infix$2,
       bind$8,
       return$10,
       map$16,
       join$3,
       ignore_m$3,
       all$10,
       all_unit$4,
       Let_syntax$4,
       value,
       value_exn,
       value_map,
       value_or_thunk,
       fold$0,
       mem$1,
       length$1,
       iter$4,
       exists$1,
       for_all$1,
       find$2,
       find_map$1,
       to_list$2,
       to_array$0,
       call,
       merge$0,
       filter$0,
       try_with$1,
       try_with_join$0,
       some,
       first_some,
       some_if,
       is_none,
       is_some,
       is_none,
       fold_result$1,
       fold_until$1,
       min_elt$1,
       max_elt$1,
       count$1,
       sum$1];
    caml_register_global(1063,Base_Option,"Base__Option");
    function Of_sexpable(Sexpable,M)
     {function t_of_sexp(sexp)
       {var s=caml_call1(Sexpable[1],sexp);
        try
         {var _FW_=caml_call1(M[2],s);return _FW_}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          return caml_call2(of_sexp_error_exn,exn,sexp)}}
      function sexp_of_t(t)
       {var _FV_=caml_call1(M[1],t);return caml_call1(Sexpable[2],_FV_)}
      return [0,t_of_sexp,sexp_of_t]}
    function Of_sexpable1(Sexpable,M)
     {function t_of_sexp(a_of_sexp,sexp)
       {var s=caml_call2(Sexpable[1],a_of_sexp,sexp);
        try
         {var _FU_=caml_call1(M[2],s);return _FU_}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          return caml_call2(of_sexp_error_exn,exn,sexp)}}
      function sexp_of_t(sexp_of_a,t)
       {var _FT_=caml_call1(M[1],t);
        return caml_call2(Sexpable[2],sexp_of_a,_FT_)}
      return [0,t_of_sexp,sexp_of_t]}
    function Of_sexpable2(Sexpable,M)
     {function t_of_sexp(a_of_sexp,b_of_sexp,sexp)
       {var s=caml_call3(Sexpable[1],a_of_sexp,b_of_sexp,sexp);
        try
         {var _FS_=caml_call1(M[2],s);return _FS_}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          return caml_call2(of_sexp_error_exn,exn,sexp)}}
      function sexp_of_t(sexp_of_a,sexp_of_b,t)
       {var _FR_=caml_call1(M[1],t);
        return caml_call3(Sexpable[2],sexp_of_a,sexp_of_b,_FR_)}
      return [0,t_of_sexp,sexp_of_t]}
    function Of_sexpable3(Sexpable,M)
     {function t_of_sexp(a_of_sexp,b_of_sexp,c_of_sexp,sexp)
       {var s=caml_call4(Sexpable[1],a_of_sexp,b_of_sexp,c_of_sexp,sexp);
        try
         {var _FQ_=caml_call1(M[2],s);return _FQ_}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          return caml_call2(of_sexp_error_exn,exn,sexp)}}
      function sexp_of_t(sexp_of_a,sexp_of_b,sexp_of_c,t)
       {var _FP_=caml_call1(M[1],t);
        return caml_call4(Sexpable[2],sexp_of_a,sexp_of_b,sexp_of_c,_FP_)}
      return [0,t_of_sexp,sexp_of_t]}
    function Of_stringable(M)
     {function t_of_sexp(sexp)
       {if(0 !== sexp[0])
         return caml_call2(of_sexp_error,cst_Sexpable_Of_stringable_t_o,sexp);
        var s=sexp[1];
        try
         {var _FO_=caml_call1(M[1],s);return _FO_}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          return caml_call2(of_sexp_error_exn,exn,sexp)}}
      function sexp_of_t(t){return [0,caml_call1(M[2],t)]}
      return [0,t_of_sexp,sexp_of_t]}
    var
     Base_Sexpable=
      [0,Of_sexpable,Of_sexpable1,Of_sexpable2,Of_sexpable3,Of_stringable];
    caml_register_global(1064,Base_Sexpable,"Base__Sexpable");
    function swap$0(param)
     {if(0 === param[0]){var x=param[1];return [1,x]}
      var x$0=param[1];
      return [0,x$0]}
    function is_first(param){return 0 === param[0]?1:0}
    function is_second(param){return 0 === param[0]?0:1}
    function value$0(param){var x=param[1];return x}
    function value_map$0(t,first,second)
     {if(0 === t[0]){var x=t[1];return caml_call1(first,x)}
      var x$0=t[1];
      return caml_call1(second,x$0)}
    function map$17(t,first,second)
     {if(0 === t[0]){var x=t[1];return [0,caml_call1(first,x)]}
      var x$0=t[1];
      return [1,caml_call1(second,x$0)]}
    function first(x){return [0,x]}
    function second(x){return [1,x]}
    function equal$18(eq1,eq2,t1,t2)
     {if(0 === t1[0])
       {var _FM_=t1[1];
        if(0 === t2[0]){var y=t2[1];return caml_call2(eq1,_FM_,y)}}
      else
       {var _FN_=t1[1];
        if(0 !== t2[0]){var y$0=t2[1];return caml_call2(eq2,_FN_,y$0)}}
      return 0}
    function invariant$7(f,s,param)
     {if(0 === param[0]){var x=param[1];return caml_call1(f,x)}
      var y=param[1];
      return caml_call1(s,y)}
    function Make_focused(M)
     {var
       return$0=M[1],
       other=M[2],
       either=M[3],
       combine=M[4],
       bind=M[5],
       map=
        [0,
         -198771759,
         function(t,f)
          {return caml_call2
                   (bind,
                    t,
                    function(x){return caml_call1(return$0,caml_call1(f,x))})}],
       include=Make2([0,bind,map,return$0]),
       symbol_bind=include[1],
       Let_syntax=include[3],
       Monad_infix=include[4],
       bind$0=include[5],
       return$1=include[6],
       join=include[8],
       ignore_m=include[9],
       _FF_=include[7];
      function apply(t1,t2)
       {return caml_call2
                (bind$0,
                 t1,
                 function(f)
                  {return caml_call2
                           (bind$0,
                            t2,
                            function(x){return caml_call1(return$1,caml_call1(f,x))})})}
      var
       map$0=[0,-198771759,_FF_],
       App=Make2$0([0,return$1,apply,map$0]),
       return$2=App[1],
       map$1=App[2],
       both=App[3],
       symbol=App[4],
       symbol$0=App[5],
       symbol$1=App[6],
       symbol_map=App[7],
       apply$0=App[8],
       map2=App[9],
       map3=App[10],
       all=App[11],
       all_unit=App[12],
       Applicative_infix=App[13];
      function other_loop(f,acc,param)
       {if(! param)return caml_call1(other,acc);
        var ts=param[2],t=param[1];
        function _FL_(o){return other_loop(f,caml_call2(f,acc,o),ts)}
        return caml_call3
                (either,t,function(param){return other_loop(f,acc,ts)},_FL_)}
      function return_loop(f,acc,param)
       {if(! param)return caml_call1(return$2,rev(acc));
        var ts=param[2],t=param[1];
        function _FK_(o){return other_loop(f,o,ts)}
        return caml_call3
                (either,
                 t,
                 function(x){return return_loop(f,[0,x,acc],ts)},
                 _FK_)}
      function combine_all(ts,f){return return_loop(f,0,ts)}
      function other_loop$0(f,acc,param)
       {if(! param)return caml_call1(other,acc);
        var ts=param[2],t=param[1];
        function _FJ_(o){return other_loop$0(f,caml_call2(f,acc,o),ts)}
        return caml_call3
                (either,t,function(param){return other_loop$0(f,acc,ts)},_FJ_)}
      function return_loop$0(f,param)
       {if(! param)return caml_call1(return$2,0);
        var ts=param[2],t=param[1];
        function _FI_(o){return other_loop$0(f,o,ts)}
        return caml_call3
                (either,t,function(param){return return_loop$0(f,ts)},_FI_)}
      function combine_all_unit(ts,f){return return_loop$0(f,ts)}
      function to_option(t)
       {return caml_call3(either,t,some,function(param){return 0})}
      function value(t,default$0)
       {function _FG_(param){return default$0}
        return caml_call3(either,t,function(_FH_){return _FH_},_FG_)}
      function with_return$0(f)
       {return with_return
                (function(ret)
                  {return caml_call1
                           (other,caml_call1(f,prepend(ret,return$2)))})}
      return [0,
              other,
              either,
              combine,
              symbol_bind,
              Let_syntax,
              Monad_infix,
              bind$0,
              join,
              ignore_m,
              App,
              return$2,
              map$1,
              both,
              symbol,
              symbol$0,
              symbol$1,
              symbol_map,
              apply$0,
              map2,
              map3,
              all,
              all_unit,
              Applicative_infix,
              combine_all,
              combine_all_unit,
              to_option,
              value,
              with_return$0]}
    function either(t,return$0,other)
     {if(0 === t[0]){var x=t[1];return caml_call1(return$0,x)}
      var y=t[1];
      return caml_call1(other,y)}
    function combine$0(t1,t2,f,other)
     {if(0 === t1[0])
       {var _FD_=t1[1];
        if(0 === t2[0]){var y=t2[1];return [0,caml_call2(f,_FD_,y)]}
        var x=t2[1]}
      else
       {var _FE_=t1[1];
        if(0 !== t2[0]){var y$0=t2[1];return [1,caml_call2(other,_FE_,y$0)]}
        var x=_FE_}
      return [1,x]}
    function bind$9(t,f)
     {if(0 !== t[0])return t;var x=t[1];return caml_call1(f,x)}
    var First=Make_focused([0,first,second,either,combine$0,bind$9]);
    function either$0(t,return$0,other)
     {if(0 === t[0]){var x=t[1];return caml_call1(other,x)}
      var y=t[1];
      return caml_call1(return$0,y)}
    function combine$1(t1,t2,f,other)
     {if(0 === t1[0])
       {var _FB_=t1[1];
        if(0 === t2[0]){var y=t2[1];return [0,caml_call2(other,_FB_,y)]}
        var x=_FB_}
      else
       {var _FC_=t1[1];
        if(0 !== t2[0]){var y$0=t2[1];return [1,caml_call2(f,_FC_,y$0)]}
        var x=t2[1]}
      return [0,x]}
    function bind$10(t,f)
     {if(0 === t[0])return t;var x=t[1];return caml_call1(f,x)}
    var
     Second=Make_focused([0,second,first,either$0,combine$1,bind$10]),
     Export$0=[0],
     Base_Either=
      [0,
       compare$16,
       hash_fold_t$10,
       t_of_sexp$11,
       sexp_of_t$13,
       t_sexp_grammar$8,
       invariant$7,
       swap$0,
       value$0,
       value_map$0,
       value_map$0,
       map$17,
       equal$18,
       [0,
        First[4],
        First[5],
        First[6],
        First[7],
        First[8],
        First[9],
        First[11],
        First[12],
        First[13],
        First[14],
        First[15],
        First[16],
        First[17],
        First[18],
        First[19],
        First[20],
        First[21],
        First[22],
        First[23],
        First[27],
        First[26],
        First[28],
        First[3],
        First[24],
        First[25]],
       [0,
        Second[4],
        Second[5],
        Second[6],
        Second[7],
        Second[8],
        Second[9],
        Second[11],
        Second[12],
        Second[13],
        Second[14],
        Second[15],
        Second[16],
        Second[17],
        Second[18],
        Second[19],
        Second[20],
        Second[21],
        Second[22],
        Second[23],
        Second[27],
        Second[26],
        Second[28],
        Second[3],
        Second[24],
        Second[25]],
       is_first,
       is_second,
       first,
       second,
       Export$0];
    caml_register_global(1065,Base_Either,"Base__Either");
    var Base_Indexed_container_intf=[0];
    caml_register_global
     (1066,Base_Indexed_container_intf,"Base__Indexed_container_intf");
    function iteri$1(fold,t,f)
     {caml_call3(fold,t,0,function(i,x){caml_call2(f,i,x);return i + 1 | 0});
      return 0}
    function foldi$0(fold,t,init,f)
     {var i=[0,0];
      return caml_call3
              (fold,
               t,
               init,
               function(acc,v)
                {var acc$0=caml_call3(f,i[1],acc,v);
                 i[1] = i[1] + 1 | 0;
                 return acc$0})}
    function counti$0(foldi,t,f)
     {return caml_call3
              (foldi,
               t,
               0,
               function(i,n,a){return caml_call2(f,i,a)?n + 1 | 0:n})}
    function existsi$0(iteri,c,f)
     {return with_return
              (function(r)
                {caml_call2
                  (iteri,
                   c,
                   function(i,x)
                    {var _FA_=caml_call2(f,i,x);
                     return _FA_?caml_call1(r,1):_FA_});
                 return 0})}
    function for_alli$0(iteri,c,f)
     {return with_return
              (function(r)
                {caml_call2
                  (iteri,
                   c,
                   function(i,x)
                    {var _Fz_=1 - caml_call2(f,i,x);
                     return _Fz_?caml_call1(r,0):_Fz_});
                 return 1})}
    function find_mapi$0(iteri,t,f)
     {return with_return
              (function(r)
                {caml_call2
                  (iteri,
                   t,
                   function(i,x)
                    {var res=caml_call2(f,i,x);return res?caml_call1(r,res):0});
                 return 0})}
    function findi$0(iteri,c,f)
     {return with_return
              (function(r)
                {caml_call2
                  (iteri,
                   c,
                   function(i,x)
                    {var _Fy_=caml_call2(f,i,x);
                     return _Fy_?caml_call1(r,[0,[0,i,x]]):_Fy_});
                 return 0})}
    function Make_gen$2(T)
     {var
       include=Make_gen([0,T[1],T[2],T[3]]),
       _Fi_=include[4],
       _Fv_=T[4],
       _Ff_=include[1],
       _Fg_=include[2],
       _Fh_=include[3],
       _Fj_=include[5],
       _Fk_=include[6],
       _Fl_=include[7],
       _Fm_=include[8],
       _Fn_=include[9],
       _Fo_=include[10],
       _Fp_=include[11],
       _Fq_=include[12],
       _Fr_=include[13],
       _Fs_=include[14],
       _Ft_=include[15],
       _Fu_=include[16];
      if(typeof _Fv_ === "number")
       var _Fw_=function(t,f){return iteri$1(_Fi_,t,f)};
      else
       var iteri=_Fv_[2],_Fw_=iteri;
      var _Fx_=T[5];
      if(typeof _Fx_ === "number")
       var foldi=function(t,init,f){return foldi$0(_Fi_,t,init,f)};
      else
       var foldi$1=_Fx_[2],foldi=foldi$1;
      function counti(t,f){return counti$0(foldi,t,f)}
      function existsi(t,f){return existsi$0(_Fw_,t,f)}
      function for_alli(t,f){return for_alli$0(_Fw_,t,f)}
      function find_mapi(t,f){return find_mapi$0(_Fw_,t,f)}
      function findi(t,f){return findi$0(_Fw_,t,f)}
      return [0,
              _Ff_,
              _Fg_,
              _Fh_,
              _Fi_,
              _Fj_,
              _Fk_,
              _Fl_,
              _Fm_,
              _Fn_,
              _Fo_,
              _Fp_,
              _Fq_,
              _Fr_,
              _Fs_,
              _Ft_,
              _Fu_,
              foldi,
              _Fw_,
              existsi,
              for_alli,
              counti,
              findi,
              find_mapi]}
    function _a9_(T)
     {var
       C=_Z_([0,T[1],T[2],T[3],T[4]]),
       mem=C[1],
       fold=T[2],
       iter=T[3],
       length=T[4],
       iteri=T[5],
       foldi=T[6],
       include=Make_gen$2([0,fold,iter,length,iteri,foldi]),
       length$0=include[1],
       is_empty=include[2],
       iter$0=include[3],
       fold$0=include[4],
       fold_result=include[5],
       fold_until=include[6],
       exists=include[7],
       for_all=include[8],
       count=include[9],
       sum=include[10],
       find=include[11],
       find_map=include[12],
       to_list=include[13],
       to_array=include[14],
       min_elt=include[15],
       max_elt=include[16],
       foldi$0=include[17],
       iteri$0=include[18],
       existsi=include[19],
       for_alli=include[20],
       counti=include[21],
       findi=include[22],
       find_mapi=include[23];
      return [0,
              mem,
              length$0,
              is_empty,
              iter$0,
              fold$0,
              fold_result,
              fold_until,
              exists,
              for_all,
              count,
              sum,
              find,
              find_map,
              to_list,
              to_array,
              min_elt,
              max_elt,
              foldi$0,
              iteri$0,
              existsi,
              for_alli,
              counti,
              findi,
              find_mapi]}
    function _a__(T)
     {var
       C=___([0,T[1],T[2],T[3]]),
       mem=C[1],
       fold=T[1],
       iter=T[2],
       length=T[3],
       iteri=T[4],
       foldi=T[5],
       include=Make_gen$2([0,fold,iter,length,iteri,foldi]),
       length$0=include[1],
       is_empty=include[2],
       iter$0=include[3],
       fold$0=include[4],
       fold_result=include[5],
       fold_until=include[6],
       exists=include[7],
       for_all=include[8],
       count=include[9],
       sum=include[10],
       find=include[11],
       find_map=include[12],
       to_list=include[13],
       to_array=include[14],
       min_elt=include[15],
       max_elt=include[16],
       foldi$0=include[17],
       iteri$0=include[18],
       existsi=include[19],
       for_alli=include[20],
       counti=include[21],
       findi=include[22],
       find_mapi=include[23];
      return [0,
              mem,
              length$0,
              is_empty,
              iter$0,
              fold$0,
              fold_result,
              fold_until,
              exists,
              for_all,
              count,
              sum,
              find,
              find_map,
              to_list,
              to_array,
              min_elt,
              max_elt,
              foldi$0,
              iteri$0,
              existsi,
              for_alli,
              counti,
              findi,
              find_mapi]}
    var
     Base_Indexed_container=
      [0,
       foldi$0,
       iteri$1,
       counti$0,
       existsi$0,
       for_alli$0,
       findi$0,
       find_mapi$0,
       _a__,
       _a9_,
       Make_gen$2];
    caml_register_global
     (1067,Base_Indexed_container,"Base__Indexed_container");
    function sexp_of_t$25(of_a_001,of_s_002,param)
     {if(typeof param === "number")return _a$_;
      if(0 === param[0])
       {var arg0_003=param[1],res0_004=caml_call1(of_s_002,arg0_003);
        return [1,[0,_ba_,[0,res0_004,0]]]}
      var
       arg1_006=param[2],
       arg0_005=param[1],
       res0_007=caml_call1(of_a_001,arg0_005),
       res1_008=caml_call1(of_s_002,arg1_006);
      return [1,[0,_bb_,[0,res0_007,[0,res1_008,0]]]]}
    var Step=[0,sexp_of_t$25];
    function next_step(param)
     {var f=param[2],s=param[1],match=caml_call1(f,s);
      if(typeof match === "number")return 0;
      if(0 === match[0]){var s$0=match[1];return [0,[0,s$0,f]]}
      var s$1=match[2],a=match[1];
      return [1,a,[0,s$1,f]]}
    function delayed_fold_step(s,init,f,finish)
     {function loop(s,next,finish,f,acc)
       {var match=caml_call1(next,s);
        if(typeof match === "number")return caml_call1(finish,acc);
        if(0 === match[0])
         {var s$0=match[1];
          return caml_call3
                  (f,
                   acc,
                   0,
                   function(_Fe_){return loop(s$0,next,finish,f,_Fe_)})}
        var s$1=match[2],a=match[1];
        return caml_call3
                (f,
                 acc,
                 [0,a],
                 function(_Fd_){return loop(s$1,next,finish,f,_Fd_)})}
      var next=s[2],s$0=s[1];
      return loop(s$0,next,finish,f,init)}
    var Expert=[0,next_step,delayed_fold_step];
    function unfold_step(init,f){return [0,init,f]}
    function unfold(init,f)
     {return [0,
              init,
              function(s)
               {var match=caml_call1(f,s);
                if(! match)return 0;
                var match$0=match[1],s$0=match$0[2],a=match$0[1];
                return [1,a,s$0]}]}
    function unfold_with(s,init,f)
     {var next=s[2],s$0=s[1];
      return [0,
              [0,init,s$0],
              function(param)
               {var s=param[2],seed=param[1],match=caml_call1(next,s);
                if(typeof match === "number")return 0;
                if(0 === match[0]){var s$0=match[1];return [0,[0,seed,s$0]]}
                var s$1=match[2],a=match[1],match$0=caml_call2(f,seed,a);
                if(typeof match$0 === "number")return 0;
                if(0 === match$0[0])
                 {var seed$0=match$0[1];return [0,[0,seed$0,s$1]]}
                var seed$1=match$0[2],a$0=match$0[1];
                return [1,a$0,[0,seed$1,s$1]]}]}
    function unfold_with_and_finish
     (s,init,running_step,inner_finished,finishing_step)
     {var next=s[2],s$0=s[1];
      return [0,
              [0,-172306698,[0,init,s$0]],
              function(state)
               {if(301075099 <= state[1])
                 {var
                   state$0=state[2],
                   match=caml_call1(finishing_step,state$0);
                  if(typeof match === "number")return 0;
                  if(0 === match[0])
                   {var state$1=match[1];return [0,[0,301075099,state$1]]}
                  var state$2=match[2],y=match[1];
                  return [1,y,[0,301075099,state$2]]}
                var
                 match$0=state[2],
                 inner_state=match$0[2],
                 state$3=match$0[1],
                 match$1=caml_call1(next,inner_state);
                if(typeof match$1 === "number")
                 return [0,[0,301075099,caml_call1(inner_finished,state$3)]];
                if(0 === match$1[0])
                 {var inner_state$0=match$1[1];
                  return [0,[0,-172306698,[0,state$3,inner_state$0]]]}
                var
                 inner_state$1=match$1[2],
                 x=match$1[1],
                 match$2=caml_call2(running_step,state$3,x);
                if(typeof match$2 === "number")return 0;
                if(0 === match$2[0])
                 {var state$4=match$2[1];
                  return [0,[0,-172306698,[0,state$4,inner_state$1]]]}
                var state$5=match$2[2],y$0=match$2[1];
                return [1,y$0,[0,-172306698,[0,state$5,inner_state$1]]]}]}
    function of_list$1(l)
     {return [0,
              l,
              function(param)
               {if(! param)return 0;var l=param[2],x=param[1];return [1,x,l]}]}
    function fold$1(t,v,f)
     {var next=t[2],seed$1=t[1],seed=seed$1,v$0=v;
      for(;;)
       {var match=caml_call1(next,seed);
        if(typeof match === "number")return v$0;
        if(0 === match[0]){var seed$0=match[1],seed=seed$0;continue}
        var s=match[2],a=match[1],v$1=caml_call2(f,v$0,a),seed=s,v$0=v$1}}
    function to_list_rev(t){return fold$1(t,0,function(l,x){return [0,x,l]})}
    function to_list$3(param)
     {var next=param[2],s=param[1];
      function to_list(s,next,i)
       {var s$0=s;
        for(;;)
         {if(0 === i){var t=[0,s$0,next];return rev(to_list_rev(t))}
          var match=caml_call1(next,s$0);
          if(typeof match === "number")return 0;
          if(0 === match[0]){var s$1=match[1],s$0=s$1;continue}
          var s$2=match[2],a=match[1];
          return [0,a,to_list(s$2,next,i - 1 | 0)]}}
      return to_list(s,next,500)}
    function sexp_of_t$26(sexp_of_a,t)
     {return caml_call2(sexp_of_t$10,sexp_of_a,to_list$3(t))}
    function range$1(opt,_Fc_,_Fb_,start_v,stop_v)
     {if(opt)var sth=opt[1],stride=sth;else var stride=1;
      if(_Fc_)var sth$0=_Fc_[1],start=sth$0;else var start=104758188;
      if(_Fb_)var sth$1=_Fb_[1],stop=sth$1;else var stop=-160346914;
      var
       step=
        104758188 <= stop
         ?0 <= stride
           ?function(i){return stop_v < i?0:[1,i,i + stride | 0]}
           :function(i){return i < stop_v?0:[1,i,i + stride | 0]}
         :0 <= stride
           ?function(i){return stop_v <= i?0:[1,i,i + stride | 0]}
           :function(i){return i <= stop_v?0:[1,i,i + stride | 0]},
       init=104758188 <= start?start_v:start_v + stride | 0;
      return [0,init,step]}
    function of_lazy$0(t_lazy)
     {return [0,
              t_lazy,
              function(t_lazy)
               {var
                 _Fa_=caml_obj_tag(t_lazy),
                 match=
                  250 === _Fa_
                   ?t_lazy[1]
                   :246 === _Fa_?caml_call1(CamlinternalLazy[2],t_lazy):t_lazy,
                 next=match[2],
                 s=match[1],
                 match$0=caml_call1(next,s);
                if(typeof match$0 === "number")return 0;
                if(0 === match$0[0])
                 {var s$0=match$0[1],v=[0,s$0,next];return [0,v]}
                var s$1=match$0[2],x=match$0[1],v$0=[0,s$1,next];
                return [1,x,v$0]}]}
    function _bc_(t,f)
     {var next=t[2],seed=t[1];
      return [0,
              seed,
              function(seed)
               {var match=caml_call1(next,seed);
                if(typeof match === "number")return 0;
                if(0 === match[0]){var s=match[1];return [0,s]}
                var s$0=match[2],a=match[1];
                return [1,caml_call1(f,a),s$0]}]}
    function mapi$2(t,f)
     {var next=t[2],s=t[1];
      return [0,
              [0,0,s],
              function(param)
               {var s=param[2],i=param[1],match=caml_call1(next,s);
                if(typeof match === "number")return 0;
                if(0 === match[0]){var s$0=match[1];return [0,[0,i,s$0]]}
                var s$1=match[2],a=match[1];
                return [1,caml_call2(f,i,a),[0,i + 1 | 0,s$1]]}]}
    function folding_map$0(t,init,f)
     {return unfold_with
              (t,
               init,
               function(acc,x)
                {var match=caml_call2(f,acc,x),x$0=match[2],acc$0=match[1];
                 return [1,x$0,acc$0]})}
    function folding_mapi$0(t,init,f)
     {return unfold_with
              (t,
               [0,0,init],
               function(param,x)
                {var
                  acc=param[2],
                  i=param[1],
                  match=caml_call3(f,i,acc,x),
                  x$0=match[2],
                  acc$0=match[1];
                 return [1,x$0,[0,i + 1 | 0,acc$0]]})}
    function filter$1(t,f)
     {var next=t[2],seed=t[1];
      return [0,
              seed,
              function(seed)
               {var match=caml_call1(next,seed);
                if(typeof match === "number")return 0;
                if(0 === match[0]){var s=match[1];return [0,s]}
                var a=match[1],s$0=match[2];
                if(caml_call1(f,a))return [1,a,s$0];
                var s$1=match[2];
                return [0,s$1]}]}
    function filteri$0(t,f)
     {function _E$_(param){var s=param[2],i=param[1];return caml_call2(f,i,s)}
      return _bc_
              (filter$1(mapi$2(t,function(i,s){return [0,i,s]}),_E$_),
               get_data)}
    function length$2(t)
     {var next=t[2],seed=t[1],i=0,s=seed;
      for(;;)
       {var match=caml_call1(next,s);
        if(typeof match === "number")return i;
        if(0 === match[0]){var s$0=match[1],s=s$0;continue}
        var s$1=match[2],i$0=i + 1 | 0,i=i$0,s=s$1}}
    function to_array$1(t)
     {var
       match=
        fold$1
         (t,
          _bd_,
          function(param,x)
           {var i=param[2],l=param[1];return [0,[0,x,l],i + 1 | 0]}),
       len=match[2],
       l=match[1];
      if(! l)return [0];
      var
       l$0=l[2],
       x=l[1],
       a=caml_make_vect(len,x),
       i$1=len - 2 | 0,
       i=i$1,
       l$1=l$0;
      for(;;)
       {if(l$1)
         {var l$2=l$1[2],x$0=l$1[1];
          caml_check_bound(a,i)[1 + i] = x$0;
          var i$0=i - 1 | 0,i=i$0,l$1=l$2;
          continue}
        if(-1 === i)return a;
        throw [0,Assert_failure$0,_be_]}}
    function find$3(t,f)
     {var next=t[2],seed=t[1],s=seed;
      for(;;)
       {var match=caml_call1(next,s);
        if(typeof match === "number")return 0;
        if(0 === match[0])
         var s$0=match[1];
        else
         {var a=match[1];if(caml_call1(f,a))return [0,a];var s$0=match[2]}
        var s=s$0}}
    function find_map$2(t,f)
     {var next=t[2],seed=t[1],s=seed;
      for(;;)
       {var match=caml_call1(next,s);
        if(typeof match === "number")return 0;
        if(0 === match[0]){var s$0=match[1],s=s$0;continue}
        var s$1=match[2],a=match[1],some_b=caml_call1(f,a);
        if(some_b)return some_b;
        var s=s$1}}
    function find_mapi$1(t,f)
     {var next=t[2],seed=t[1],s=seed,i=0;
      for(;;)
       {var match=caml_call1(next,s);
        if(typeof match === "number")return 0;
        if(0 === match[0]){var s$0=match[1],s=s$0;continue}
        var s$1=match[2],a=match[1],some_b=caml_call2(f,i,a);
        if(some_b)return some_b;
        var i$0=i + 1 | 0,s=s$1,i=i$0}}
    function for_all$2(t,f)
     {var next=t[2],seed=t[1],s=seed;
      for(;;)
       {var match=caml_call1(next,s);
        if(typeof match === "number")return 1;
        if(0 === match[0])
         var s$0=match[1];
        else
         {var a=match[1];if(! caml_call1(f,a))return 0;var s$0=match[2]}
        var s=s$0}}
    function for_alli$1(t,f)
     {var next=t[2],seed=t[1],s=seed,i=0;
      for(;;)
       {var match=caml_call1(next,s);
        if(typeof match === "number")return 1;
        if(0 === match[0]){var s$0=match[1],s=s$0;continue}
        var a=match[1];
        if(! caml_call2(f,i,a))return 0;
        var s$1=match[2],i$0=i + 1 | 0,s=s$1,i=i$0}}
    function exists$2(t,f)
     {var next=t[2],seed=t[1],s=seed;
      for(;;)
       {var match=caml_call1(next,s);
        if(typeof match === "number")return 0;
        if(0 === match[0])
         var s$0=match[1];
        else
         {var a=match[1];if(caml_call1(f,a))return 1;var s$0=match[2]}
        var s=s$0}}
    function existsi$1(t,f)
     {var next=t[2],seed=t[1],s=seed,i=0;
      for(;;)
       {var match=caml_call1(next,s);
        if(typeof match === "number")return 0;
        if(0 === match[0]){var s$0=match[1],s=s$0;continue}
        var a=match[1];
        if(caml_call2(f,i,a))return 1;
        var s$1=match[2],i$0=i + 1 | 0,s=s$1,i=i$0}}
    function iter$5(t,f)
     {var next=t[2],seed$1=t[1],seed=seed$1;
      for(;;)
       {var match=caml_call1(next,seed);
        if(typeof match === "number")return 0;
        if(0 === match[0]){var seed$0=match[1],seed=seed$0;continue}
        var s=match[2],a=match[1];
        caml_call1(f,a);
        var seed=s}}
    function is_empty$1(t)
     {var next=t[2],seed=t[1],s=seed;
      for(;;)
       {var match=caml_call1(next,s);
        if(typeof match === "number")return 1;
        if(0 !== match[0])return 0;
        var s$0=match[1],s=s$0}}
    function mem$2(t,a,equal)
     {var next=t[2],seed=t[1],s=seed;
      for(;;)
       {var match=caml_call1(next,s);
        if(typeof match === "number")return 0;
        if(0 === match[0])
         var s$0=match[1];
        else
         {var b=match[1];if(caml_call2(equal,a,b))return 1;var s$0=match[2]}
        var s=s$0}}
    var empty=[0,0,function(param){return 0}];
    function bind$11(t,f)
     {return [0,
              [0,empty,t],
              function(param)
               {var
                 rest=param[2],
                 match=param[1],
                 next=match[2],
                 seed=match[1],
                 match$0=caml_call1(next,seed);
                if(typeof match$0 === "number")
                 {var
                   next$0=rest[2],
                   seed$0=rest[1],
                   match$1=caml_call1(next$0,seed$0);
                  if(typeof match$1 === "number")return 0;
                  if(0 === match$1[0])
                   {var s=match$1[1];return [0,[0,empty,[0,s,next$0]]]}
                  var s$0=match$1[2],a=match$1[1];
                  return [0,[0,caml_call1(f,a),[0,s$0,next$0]]]}
                if(0 === match$0[0])
                 {var s$1=match$0[1];return [0,[0,[0,s$1,next],rest]]}
                var s$2=match$0[2],a$0=match$0[1];
                return [1,a$0,[0,[0,s$2,next],rest]]}]}
    function return$11(x)
     {return [0,
              [0,x],
              function(param)
               {if(! param)return 0;var x=param[1];return [1,x,0]}]}
    var
     map$18=[0,-198771759,_bc_],
     include$37=Make([0,bind$11,return$11,map$18]),
     symbol_bind$5=include$37[1],
     symbol_map$6=include$37[2],
     Monad_infix$3=include$37[3],
     bind$12=include$37[4],
     return$12=include$37[5],
     map$19=include$37[6],
     join$4=include$37[7],
     ignore_m$4=include$37[8],
     all$11=include$37[9],
     all_unit$5=include$37[10],
     Let_syntax$5=include$37[11];
    function nth$0(s,i)
     {if(0 > i)return 0;
      var next=s[2],s$3=s[1],i$0=i,s$0=s$3;
      for(;;)
       {var match=caml_call1(next,s$0);
        if(typeof match === "number")return 0;
        if(0 === match[0]){var s$1=match[1],s$0=s$1;continue}
        var s$2=match[2],a=match[1];
        if(i$0 === 0)return [0,a];
        var i$1=i$0 - 1 | 0,i$0=i$1,s$0=s$2}}
    function nth_exn$0(s,n)
     {if(0 > n)return caml_call1(invalid_arg$0,cst_Sequence_nth$0);
      var match=nth$0(s,n);
      if(! match)return caml_call1(failwith$0,cst_Sequence_nth);
      var x=match[1];
      return x}
    function compare$29(cmp_a,cmp_b,a_011,b_012)
     {if(a_011 === b_012)return 0;
      switch(a_011[0])
       {case 0:
         var _E7_=a_011[1];
         if(0 !== b_012[0])return -1;
         var b_014=b_012[1];
         return caml_call2(cmp_a,_E7_,b_014);
        case 1:
         var _E8_=a_011[1];
         switch(b_012[0])
          {case 0:break;
           case 1:var b_016=b_012[1];return caml_call2(cmp_b,_E8_,b_016);
           default:return -1}
         break;
        default:
         var _E9_=a_011[2],_E__=a_011[1];
         switch(b_012[0])
          {case 0:break;
           case 1:return 1;
           default:
            var b_020=b_012[2],b_018=b_012[1],n=caml_call2(cmp_a,_E__,b_018);
            return 0 === n?caml_call2(cmp_b,_E9_,b_020):n}}
      return 1}
    function hash_fold_t$19(hash_fold_a,hash_fold_b,hsv,arg)
     {switch(arg[0])
       {case 0:
         var a0=arg[1],hsv$0=runtime.Base_internalhash_fold_int(hsv,0);
         return caml_call2(hash_fold_a,hsv$0,a0);
        case 1:
         var a0$0=arg[1],hsv$1=runtime.Base_internalhash_fold_int(hsv,1);
         return caml_call2(hash_fold_b,hsv$1,a0$0);
        default:
         var
          a1=arg[2],
          a0$1=arg[1],
          hsv$2=runtime.Base_internalhash_fold_int(hsv,2),
          hsv$3=caml_call2(hash_fold_a,hsv$2,a0$1);
         return caml_call2(hash_fold_b,hsv$3,a1)}}
    function t_of_sexp$18(of_a_021,of_b_022,sexp_027)
     {if(0 === sexp_027[0])
       {var _E2_=sexp_027[1],switch$0=0;
        if(caml_string_notequal(_E2_,cst_Both))
         {var switch$1=0;
          if(caml_string_notequal(_E2_,cst_Left))
           {var switch$2=0;
            if(caml_string_notequal(_E2_,cst_Right))
             if(caml_string_notequal(_E2_,cst_both))
              if(caml_string_notequal(_E2_,cst_left))
               {if(caml_string_notequal(_E2_,cst_right))
                 {switch$0 = 1;switch$1 = 1;switch$2 = 1}}
              else
               switch$2 = 1;
             else
              {switch$1 = 1;switch$2 = 1}
            if(! switch$2)
             return caml_call2
                     (Sexplib0_Sexp_conv_error[5],error_source_025,sexp_027)}
          if(! switch$1)
           return caml_call2
                   (Sexplib0_Sexp_conv_error[5],error_source_025,sexp_027)}
        if(! switch$0)
         return caml_call2
                 (Sexplib0_Sexp_conv_error[5],error_source_025,sexp_027)}
      else
       {var _E3_=sexp_027[1];
        if(! _E3_)
         return caml_call2
                 (Sexplib0_Sexp_conv_error[7],error_source_025,sexp_027);
        var _E4_=_E3_[1];
        if(0 !== _E4_[0])
         return caml_call2
                 (Sexplib0_Sexp_conv_error[6],error_source_025,sexp_027);
        var _E5_=_E4_[1],switch$3=0;
        if(caml_string_notequal(_E5_,cst_Both$0))
         {var switch$4=0;
          if(caml_string_notequal(_E5_,cst_Left$0))
           {var switch$5=0;
            if(caml_string_notequal(_E5_,cst_Right$0))
             if(caml_string_notequal(_E5_,cst_both$0))
              if(caml_string_notequal(_E5_,cst_left$0))
               {if(caml_string_notequal(_E5_,cst_right$0))
                 {switch$3 = 1;switch$4 = 1;switch$5 = 1}}
              else
               switch$5 = 1;
             else
              {switch$4 = 1;switch$5 = 1}
            if(! switch$5)
             {var sexp_args_034=_E3_[2];
              if(sexp_args_034 && ! sexp_args_034[2])
               {var
                 arg0_035=sexp_args_034[1],
                 res0_036=caml_call1(of_b_022,arg0_035);
                return [1,res0_036]}
              return caml_call3
                      (Sexplib0_Sexp_conv_error[4],error_source_025,_E5_,sexp_027)}}
          if(! switch$4)
           {var sexp_args_029=_E3_[2];
            if(sexp_args_029 && ! sexp_args_029[2])
             {var
               arg0_030=sexp_args_029[1],
               res0_031=caml_call1(of_a_021,arg0_030);
              return [0,res0_031]}
            return caml_call3
                    (Sexplib0_Sexp_conv_error[4],error_source_025,_E5_,sexp_027)}}
        if(! switch$3)
         {var sexp_args_039=_E3_[2];
          if(sexp_args_039)
           {var _E6_=sexp_args_039[2];
            if(_E6_ && ! _E6_[2])
             {var
               arg1_041=_E6_[1],
               arg0_040=sexp_args_039[1],
               res0_042=caml_call1(of_a_021,arg0_040),
               res1_043=caml_call1(of_b_022,arg1_041);
              return [2,res0_042,res1_043]}}
          return caml_call3
                  (Sexplib0_Sexp_conv_error[4],error_source_025,_E5_,sexp_027)}}
      return caml_call2(Sexplib0_Sexp_conv_error[8],error_source_025,sexp_027)}
    function sexp_of_t$27(of_a_046,of_b_047,param)
     {switch(param[0])
       {case 0:
         var arg0_048=param[1],res0_049=caml_call1(of_a_046,arg0_048);
         return [1,[0,_bf_,[0,res0_049,0]]];
        case 1:
         var arg0_050=param[1],res0_051=caml_call1(of_b_047,arg0_050);
         return [1,[0,_bg_,[0,res0_051,0]]];
        default:
         var
          arg1_053=param[2],
          arg0_052=param[1],
          res0_054=caml_call1(of_a_046,arg0_052),
          res1_055=caml_call1(of_b_047,arg1_053);
         return [1,[0,_bh_,[0,res0_054,[0,res1_055,0]]]]}}
    function t_sexp_grammar$19(a_sexp_grammar,b_sexp_grammar)
     {return [3,
              [0,
               2,
               [0,
                [1,[0,cst_Left$1,[0,[0,a_sexp_grammar,0]]]],
                [0,
                 [1,[0,cst_Right$1,[0,[0,b_sexp_grammar,0]]]],
                 [0,
                  [1,
                   [0,cst_Both$1,[0,[0,a_sexp_grammar,[0,b_sexp_grammar,0]]]]],
                  0]]]]]}
    var
     Merge_with_duplicates_element=
      [0,
       compare$29,
       hash_fold_t$19,
       t_of_sexp$18,
       sexp_of_t$27,
       t_sexp_grammar$19];
    function merge_with_duplicates(param,_EW_,compare)
     {var next2=_EW_[2],s2=_EW_[1],next1=param[2],s1=param[1];
      function next(param)
       {var _EX_=param[1];
        if(typeof _EX_ === "number")
         {var _EY_=param[2];
          if(typeof _EY_ === "number")return 0;
          if(0 !== _EY_[0])
           {var s2$0=_EY_[2],b=_EY_[1];return [1,[1,b],[0,0,[0,s2$0]]]}}
        else
         {if(0 === _EX_[0])
           {var s2$1=param[2],s1=_EX_[1];
            return [0,[0,caml_call1(next1,s1),s2$1]]}
          var _EZ_=param[2],_E0_=_EX_[2],_E1_=_EX_[1];
          if(typeof _EZ_ === "number")return [1,[0,_E1_],[0,[0,_E0_],0]];
          if(0 !== _EZ_[0])
           {var
             s2$2=_EZ_[2],
             b$0=_EZ_[1],
             comparison=caml_call2(compare,_E1_,b$0);
            return 0 <= comparison
                    ?0 === comparison
                      ?[1,[2,_E1_,b$0],[0,[0,_E0_],[0,s2$2]]]
                      :[1,[1,b$0],[0,_EX_,[0,s2$2]]]
                    :[1,[0,_E1_],[0,[0,_E0_],_EZ_]]}}
        var match=param[2],s2=match[1];
        return [0,[0,_EX_,caml_call1(next2,s2)]]}
      return [0,[0,[0,s1],[0,s2]],next]}
    function merge_deduped_and_sorted(s1,s2,compare)
     {function _EV_(param){var x=param[1];return x}
      return caml_call2(map$19,merge_with_duplicates(s1,s2,compare),_EV_)}
    function merge_sorted(param,_EP_,compare)
     {var next2=_EP_[2],s2=_EP_[1],next1=param[2],s1=param[1];
      function next(param)
       {var _EQ_=param[1];
        if(typeof _EQ_ === "number")
         {var _ER_=param[2];
          if(typeof _ER_ === "number")return 0;
          if(0 !== _ER_[0])
           {var s2$0=_ER_[2],b=_ER_[1];return [1,b,[0,0,[0,s2$0]]]}}
        else
         {if(0 === _EQ_[0])
           {var s2$1=param[2],s1=_EQ_[1];
            return [0,[0,caml_call1(next1,s1),s2$1]]}
          var _ES_=param[2],_ET_=_EQ_[2],_EU_=_EQ_[1];
          if(typeof _ES_ === "number")return [1,_EU_,[0,[0,_ET_],0]];
          if(0 !== _ES_[0])
           {var
             s2$2=_ES_[2],
             b$0=_ES_[1],
             comparison=caml_call2(compare,_EU_,b$0);
            return 0 < comparison
                    ?[1,b$0,[0,_EQ_,[0,s2$2]]]
                    :[1,_EU_,[0,[0,_ET_],_ES_]]}}
        var match=param[2],s2=match[1];
        return [0,[0,_EQ_,caml_call1(next2,s2)]]}
      return [0,[0,[0,s1],[0,s2]],next]}
    function hd$0(s)
     {var next=s[2],s$2=s[1],s$0=s$2;
      for(;;)
       {var match=caml_call1(next,s$0);
        if(typeof match === "number")return 0;
        if(0 === match[0]){var s$1=match[1],s$0=s$1;continue}
        var a=match[1];
        return [0,a]}}
    function hd_exn$0(s)
     {var match=hd$0(s);
      if(! match)return caml_call1(failwith$0,cst_hd_exn);
      var a=match[1];
      return a}
    function tl$0(s)
     {var next=s[2],s$2=s[1],s$0=s$2;
      for(;;)
       {var match=caml_call1(next,s$0);
        if(typeof match === "number")
         var match$0=0;
        else
         {if(0 === match[0]){var s$1=match[1],s$0=s$1;continue}
          var a=match[2],match$0=[0,a]}
        if(! match$0)return 0;
        var s$3=match$0[1];
        return [0,[0,s$3,next]]}}
    function tl_eagerly_exn(s)
     {var match=tl$0(s);
      if(! match)return caml_call1(failwith$0,cst_Sequence_tl_exn);
      var s$0=match[1];
      return s$0}
    function lift_identity(next,s)
     {var match=caml_call1(next,s);
      if(typeof match === "number")return 0;
      if(0 === match[0]){var s$0=match[1];return [0,[0,316735838,s$0]]}
      var s$1=match[2],a=match[1];
      return [1,a,[0,316735838,s$1]]}
    function next(s)
     {var next=s[2],s$3=s[1],s$0=s$3;
      for(;;)
       {var match=caml_call1(next,s$0);
        if(typeof match === "number")return 0;
        if(0 === match[0]){var s$1=match[1],s$0=s$1;continue}
        var s$2=match[2],a=match[1];
        return [0,[0,a,[0,s$2,next]]]}}
    function filter_opt$0(s)
     {var next=s[2],s$0=s[1];
      return [0,
              s$0,
              function(s)
               {var match=caml_call1(next,s);
                if(typeof match === "number")return 0;
                if(0 === match[0]){var s$0=match[1];return [0,s$0]}
                var _EO_=match[1];
                if(_EO_){var s$1=match[2],a=_EO_[1];return [1,a,s$1]}
                var s$2=match[2];
                return [0,s$2]}]}
    function filter_map$0(s,f){return filter_opt$0(caml_call2(map$19,s,f))}
    function filter_mapi$0(s,f)
     {function _EN_(param){var s=param[2],i=param[1];return caml_call2(f,i,s)}
      return filter_map$0(mapi$2(s,function(i,s){return [0,i,s]}),_EN_)}
    function split_n$0(s,i)
     {var next=s[2],s$3=s[1],s$0=s$3,i$0=i,accum=0;
      for(;;)
       {if(0 >= i$0)return [0,rev(accum),[0,s$0,next]];
        var match=caml_call1(next,s$0);
        if(typeof match === "number")return [0,rev(accum),empty];
        if(0 === match[0]){var s$1=match[1],s$0=s$1;continue}
        var
         s$2=match[2],
         a=match[1],
         accum$0=[0,a,accum],
         i$1=i$0 - 1 | 0,
         s$0=s$2,
         i$0=i$1,
         accum=accum$0}}
    function chunks_exn(t,n)
     {return 0 < n
              ?[0,
                t,
                function(t)
                 {var match=split_n$0(t,n),_EM_=match[1];
                  if(! _EM_)return 0;
                  var t$0=match[2];
                  return [1,_EM_,t$0]}]
              :caml_call1(invalid_arg$0,cst_Sequence_chunks_exn)}
    function findi$1(s,f)
     {function _EL_(param){var s=param[2],i=param[1];return caml_call2(f,i,s)}
      return find$3(mapi$2(s,function(i,s){return [0,i,s]}),_EL_)}
    function find_exn$1(s,f)
     {var match=find$3(s,f);
      if(! match)return caml_call1(failwith$0,cst_Sequence_find_exn);
      var x=match[1];
      return x}
    function append$1(s1,s2)
     {var next2=s2[2],s2$0=s2[1],next1=s1[2],s1$0=s1[1];
      return [0,
              [0,472258093,s1$0],
              function(param)
               {if(472258093 <= param[1])
                 {var s1=param[2],match=caml_call1(next1,s1);
                  if(typeof match === "number")return [0,[0,-630817751,s2$0]];
                  if(0 === match[0])
                   {var s1$0=match[1];return [0,[0,472258093,s1$0]]}
                  var s1$1=match[2],a=match[1];
                  return [1,a,[0,472258093,s1$1]]}
                var s2=param[2],match$0=caml_call1(next2,s2);
                if(typeof match$0 === "number")return 0;
                if(0 === match$0[0])
                 {var s2$1=match$0[1];return [0,[0,-630817751,s2$1]]}
                var s2$2=match$0[2],a$0=match$0[1];
                return [1,a$0,[0,-630817751,s2$2]]}]}
    function concat_map(s,f){return caml_call2(bind$12,s,f)}
    function concat$2(s){return concat_map(s,function(_EK_){return _EK_})}
    function concat_mapi$0(s,f)
     {function _EJ_(param){var s=param[2],i=param[1];return caml_call2(f,i,s)}
      return concat_map(mapi$2(s,function(i,s){return [0,i,s]}),_EJ_)}
    function zip$0(param,_EE_)
     {var next2=_EE_[2],s2=_EE_[1],next1=param[2],s1=param[1];
      function next(param)
       {var _EF_=param[1],switch$0=0;
        if(typeof _EF_ === "number")
         switch$0 = 1;
        else
         if(1 === _EF_[0])
          {var _EG_=param[2],_EH_=_EF_[2],_EI_=_EF_[1];
           if(typeof _EG_ !== "number")
            {if(0 === _EG_[0])
              {var match=param[2],s2$0=match[1];
               return [0,[0,_EF_,caml_call1(next2,s2$0)]]}
             var s2$1=_EG_[2],b=_EG_[1];
             return [1,[0,_EI_,b],[0,[0,_EH_],[0,s2$1]]]}}
        if(! switch$0 && typeof param[2] !== "number")
         {var s2=param[2],s1=_EF_[1];return [0,[0,caml_call1(next1,s1),s2]]}
        return 0}
      return [0,[0,[0,s1],[0,s2]],next]}
    function zip_full(param,_Ey_)
     {var next2=_Ey_[2],s2=_Ey_[1],next1=param[2],s1=param[1];
      function next(param)
       {var _Ez_=param[1];
        if(typeof _Ez_ === "number")
         {var _EA_=param[2];
          if(typeof _EA_ === "number")return 0;
          if(0 !== _EA_[0])
           {var s2$0=_EA_[2],b=_EA_[1];
            return [1,[0,-57574468,b],[0,0,caml_call1(next2,s2$0)]]}}
        else
         {if(0 === _Ez_[0])
           {var s2$1=param[2],s1=_Ez_[1];
            return [0,[0,caml_call1(next1,s1),s2$1]]}
          var _EB_=param[2],_EC_=_Ez_[2],_ED_=_Ez_[1];
          if(typeof _EB_ === "number")
           return [1,[0,847852583,_ED_],[0,caml_call1(next1,_EC_),0]];
          if(0 !== _EB_[0])
           {var s2$2=_EB_[2],b$0=_EB_[1];
            return [1,[0,737457313,[0,_ED_,b$0]],[0,[0,_EC_],[0,s2$2]]]}}
        var match=param[2],s2=match[1];
        return [0,[0,_Ez_,caml_call1(next2,s2)]]}
      return [0,[0,[0,s1],[0,s2]],next]}
    function bounded_length(param,at_most)
     {var next=param[2],seed=param[1],i=0,seed$0=seed;
      for(;;)
       {if(at_most < i)return 85047514;
        var match=caml_call1(next,seed$0);
        if(typeof match === "number")return [0,16394,i];
        if(0 === match[0]){var seed$1=match[1],seed$0=seed$1;continue}
        var seed$2=match[2],i$0=i + 1 | 0,i=i$0,seed$0=seed$2}}
    function length_is_bounded_by(opt,max,t)
     {if(opt)var sth=opt[1],min=sth;else var min=-1;
      if(max)
       {var max$0=max[1],match$0=bounded_length(t,max$0);
        if(typeof match$0 !== "number" && 16394 === match$0[1])
         {var len=match$0[2];if(min <= len)return 1}
        return 0}
      var next=t[2],s=t[1],s$0=s,acc=0;
      for(;;)
       {if(min <= acc)return 1;
        var match=caml_call1(next,s$0);
        if(typeof match === "number")return 0;
        if(0 === match[0]){var s$1=match[1],s$0=s$1;continue}
        var s$2=match[2],acc$0=acc + 1 | 0,s$0=s$2,acc=acc$0}}
    function iteri$2(s,f)
     {function _Ex_(param){var s=param[2],i=param[1];return caml_call2(f,i,s)}
      return iter$5(mapi$2(s,function(i,s){return [0,i,s]}),_Ex_)}
    function foldi$1(s,init,f)
     {function _Ew_(acc,param)
       {var s=param[2],i=param[1];return caml_call3(f,i,acc,s)}
      return fold$1(mapi$2(s,function(i,s){return [0,i,s]}),init,_Ew_)}
    function reduce$0(s,f)
     {var match=next(s);
      if(! match)return 0;
      var match$0=match[1],s$0=match$0[2],a=match$0[1];
      return [0,fold$1(s$0,a,f)]}
    function reduce_exn$0(s,f)
     {var match=reduce$0(s,f);
      if(! match)return caml_call1(failwith$0,cst_Sequence_reduce_exn);
      var res=match[1];
      return res}
    function group$1(param,break$0)
     {var next=param[2],s=param[1];
      return [0,
              [0,[0,0,s]],
              function(param)
               {if(! param)return 0;
                var
                 match=param[1],
                 s=match[2],
                 acc=match[1],
                 match$0=caml_call1(next,s);
                if(typeof match$0 !== "number" && 0 === match$0[0])
                 {var s$2=match$0[1];return [0,[0,[0,acc,s$2]]]}
                if(acc)
                 {if(typeof match$0 === "number")return [1,rev(acc),0];
                  var s$0=match$0[2],cur=match$0[1],prev=acc[1];
                  return caml_call2(break$0,prev,cur)
                          ?[1,rev(acc),[0,[0,[0,cur,0],s$0]]]
                          :[0,[0,[0,[0,cur,acc],s$0]]]}
                if(typeof match$0 === "number")return 0;
                var s$1=match$0[2],cur$0=match$0[1];
                return [0,[0,[0,[0,cur$0,0],s$1]]]}]}
    function find_consecutive_duplicate$0(param,equal)
     {var next=param[2],s=param[1],last_elt=0,s$0=s;
      for(;;)
       {var match=caml_call1(next,s$0);
        if(typeof match === "number")return 0;
        if(0 === match[0]){var s$1=match[1],s$0=s$1;continue}
        var s$2=match[2],a=match[1];
        if(last_elt)
         {var b=last_elt[1];if(caml_call2(equal,a,b))return [0,[0,b,a]]}
        var last_elt$0=[0,a],last_elt=last_elt$0,s$0=s$2}}
    function remove_consecutive_duplicates$0(s,equal)
     {return unfold_with
              (s,
               0,
               function(prev,a)
                {if(prev)
                  {var b=prev[1];if(caml_call2(equal,a,b))return [0,[0,a]]}
                 return [1,a,[0,a]]})}
    function count$2(s,f){return length$2(filter$1(s,f))}
    function counti$1(t,f){return length$2(filteri$0(t,f))}
    function sum$2(m,t,f){return caml_call2(sum(fold$1,m),t,f)}
    function min_elt$2(t,compare){return min_elt(fold$1,t,compare)}
    function max_elt$2(t,compare){return max_elt(fold$1,t,compare)}
    function init$2(n,f)
     {return [0,0,function(i){return n <= i?0:[1,caml_call1(f,i),i + 1 | 0]}]}
    function sub$4(s,pos,len)
     {var _Eu_=pos < 0?1:0,_Ev_=_Eu_ || (len < 0?1:0);
      if(_Ev_)caml_call1(failwith$0,cst_Sequence_sub);
      var next=s[2],s$0=s[1];
      return [0,
              [0,0,s$0],
              function(param)
               {var s=param[2],i=param[1];
                if(len <= (i - pos | 0))return 0;
                var match=caml_call1(next,s);
                if(typeof match === "number")return 0;
                if(0 === match[0]){var s$0=match[1];return [0,[0,i,s$0]]}
                var a=match[1],s$1=match[2];
                if(pos <= i)return [1,a,[0,i + 1 | 0,s$1]];
                var s$2=match[2];
                return [0,[0,i + 1 | 0,s$2]]}]}
    function take$0(s,len)
     {if(len < 0)caml_call1(failwith$0,cst_Sequence_take);
      var next=s[2],s$0=s[1];
      return [0,
              [0,0,s$0],
              function(param)
               {var s=param[2],i=param[1];
                if(len <= i)return 0;
                var match=caml_call1(next,s);
                if(typeof match === "number")return 0;
                if(0 === match[0]){var s$0=match[1];return [0,[0,i,s$0]]}
                var s$1=match[2],a=match[1];
                return [1,a,[0,i + 1 | 0,s$1]]}]}
    function drop$0(s,len)
     {if(len < 0)caml_call1(failwith$0,cst_Sequence_drop);
      var next=s[2],s$0=s[1];
      return [0,
              [0,0,s$0],
              function(param)
               {var s=param[2],i=param[1],match=caml_call1(next,s);
                if(typeof match === "number")return 0;
                if(0 === match[0]){var s$0=match[1];return [0,[0,i,s$0]]}
                var a=match[1],s$1=match[2];
                if(len <= i)return [1,a,[0,i + 1 | 0,s$1]];
                var s$2=match[2];
                return [0,[0,i + 1 | 0,s$2]]}]}
    function take_while$0(s,f)
     {var next=s[2],s$0=s[1];
      return [0,
              s$0,
              function(s)
               {var match=caml_call1(next,s);
                if(typeof match === "number")return 0;
                if(0 === match[0]){var s$0=match[1];return [0,s$0]}
                var a=match[1],s$1=match[2];
                return caml_call1(f,a)?[1,a,s$1]:0}]}
    function drop_while$0(s,f)
     {var next=s[2],s$0=s[1];
      return [0,
              [0,-557110719,s$0],
              function(param)
               {if(316735838 <= param[1])
                 {var s=param[2];return lift_identity(next,s)}
                var s$0=param[2],match=caml_call1(next,s$0);
                if(typeof match === "number")return 0;
                if(0 === match[0])
                 {var s$1=match[1];return [0,[0,-557110719,s$1]]}
                var a=match[1],s$2=match[2];
                if(caml_call1(f,a))return [0,[0,-557110719,s$2]];
                var s$3=match[2];
                return [1,a,[0,316735838,s$3]]}]}
    function shift_right(s,x)
     {var next=s[2],seed=s[1];
      return [0,
              [0,-433944719,[0,seed,x]],
              function(param)
               {if(316735838 <= param[1])
                 {var s=param[2];return lift_identity(next,s)}
                var match=param[2],x=match[2],seed=match[1];
                return [1,x,[0,316735838,seed]]}]}
    function shift_right_with_list(s,l){return append$1(of_list$1(l),s)}
    var Infix$1=[0,append$1];
    function intersperse$0(s,sep)
     {var next=s[2],s$0=s[1];
      return [0,
              [0,815032112,s$0],
              function(param)
               {var _Et_=param[1];
                if(815032112 === _Et_)
                 {var s=param[2],match=caml_call1(next,s);
                  if(typeof match === "number")return 0;
                  if(0 === match[0])
                   {var s$0=match[1];return [0,[0,815032112,s$0]]}
                  var s$1=match[2],a=match[1];
                  return [1,a,[0,951752159,s$1]]}
                if(951752159 > _Et_)
                 {var match$1=param[2],s$5=match$1[2],a$1=match$1[1];
                  return [1,a$1,[0,951752159,s$5]]}
                var s$2=param[2],match$0=caml_call1(next,s$2);
                if(typeof match$0 === "number")return 0;
                if(0 === match$0[0])
                 {var s$3=match$0[1];return [0,[0,951752159,s$3]]}
                var s$4=match$0[2],a$0=match$0[1];
                return [1,sep,[0,-571577571,[0,a$0,s$4]]]}]}
    function repeat(x){return [0,x,function(x){return [1,x,x]}]}
    function cycle_list_exn(xs)
     {if(is_empty(xs))caml_call1(invalid_arg$0,cst_Sequence_cycle_list_exn);
      var s=of_list$1(xs);
      function _Es_(param){return s}
      return concat_map(repeat(0),_Es_)}
    function cartesian_product$0(sa,sb)
     {return concat_map(sa,function(a){return zip$0(repeat(a),sb)})}
    function singleton(x){return caml_call1(return$12,x)}
    function delayed_fold(s,init,f,finish)
     {function _Er_(acc,option,k)
       {if(! option)return caml_call1(k,acc);
        var a=option[1];
        return caml_call3(f,acc,a,k)}
      return caml_call4(Expert[2],s,init,_Er_,finish)}
    function fold_m(bind,return$0,t,init,f)
     {function _Eq_(acc,option,k)
       {if(! option)return caml_call2(bind,caml_call1(return$0,acc),k);
        var a=option[1];
        return caml_call2(bind,caml_call2(f,acc,a),k)}
      return caml_call4(Expert[2],t,init,_Eq_,return$0)}
    function iter_m(bind,return$0,t,f)
     {function _Ep_(param,option,k)
       {if(! option)return caml_call2(bind,caml_call1(return$0,0),k);
        var a=option[1];
        return caml_call2(bind,caml_call1(f,a),k)}
      return caml_call4(Expert[2],t,0,_Ep_,return$0)}
    function fold_until$2(s,acc,f,finish)
     {var next=s[2],s$3=s[1],s$0=s$3,acc$0=acc;
      for(;;)
       {var match=caml_call1(next,s$0);
        if(typeof match === "number")return caml_call1(finish,acc$0);
        if(0 === match[0]){var s$1=match[1],s$0=s$1;continue}
        var s$2=match[2],a=match[1],match$0=caml_call2(f,acc$0,a);
        if(0 === match$0[0])
         {var acc$1=match$0[1],s$0=s$2,acc$0=acc$1;continue}
        var x=match$0[1];
        return x}}
    function fold_result$2(s,acc,f)
     {var next=s[2],s$3=s[1],s$0=s$3,acc$0=acc;
      for(;;)
       {var match=caml_call1(next,s$0);
        if(typeof match === "number")return caml_call1(return$3,acc$0);
        if(0 === match[0]){var s$1=match[1],s$0=s$1;continue}
        var s$2=match[2],a=match[1],e=caml_call2(f,acc$0,a);
        if(0 !== e[0])return e;
        var acc$1=e[1],s$0=s$2,acc$0=acc$1}}
    function force_eagerly(t){return of_list$1(to_list$3(t))}
    function memoize(param)
     {var next=param[2],s=param[1];
      function memoize(s)
       {return [0,
                [246,
                 function(_Eo_)
                  {var s$0=s;
                   for(;;)
                    {var match=caml_call1(next,s$0);
                     if(typeof match === "number")return 0;
                     if(0 === match[0]){var s$1=match[1],s$0=s$1;continue}
                     var s$2=match[2],a=match[1];
                     return [1,a,memoize(s$2)]}}]]}
      function _Em_(param)
       {var l=param[1],_En_=caml_obj_tag(l);
        return 250 === _En_
                ?l[1]
                :246 === _En_?caml_call1(CamlinternalLazy[2],l):l}
      return [0,memoize(s),_Em_]}
    function drop_eagerly(s,len)
     {var next=s[2],s$3=s[1],i=0,s$0=s$3;
      for(;;)
       {if(len <= i)return [0,s$0,next];
        var match=caml_call1(next,s$0);
        if(typeof match === "number")return empty;
        if(0 === match[0]){var s$1=match[1],s$0=s$1;continue}
        var s$2=match[2],i$0=i + 1 | 0,i=i$0,s$0=s$2}}
    function drop_while_option(param,f)
     {var next=param[2],s=param[1],s$0=s;
      for(;;)
       {var match=caml_call1(next,s$0);
        if(typeof match === "number")return 0;
        if(0 === match[0]){var s$1=match[1],s$0=s$1;continue}
        var s$2=match[2],x=match[1];
        if(! caml_call1(f,x))return [0,[0,x,[0,s$2,next]]];
        var s$0=s$2}}
    function compare$30(compare_a,t1,t2)
     {return with_return
              (function(r)
                {function _Ej_(param)
                  {var _Ek_=param[1];
                   if(737457313 !== _Ek_)
                    return 847852583 <= _Ek_?caml_call1(r,1):caml_call1(r,-1);
                   var
                    match=param[2],
                    v2=match[2],
                    v1=match[1],
                    c=caml_call2(compare_a,v1,v2),
                    _El_=0 !== c?1:0;
                   return _El_?caml_call1(r,c):_El_}
                 iter$5(zip_full(t1,t2),_Ej_);
                 return 0})}
    function equal$19(equal_a,t1,t2)
     {function _Ei_(param)
       {if(737457313 !== param[1])return 0;
        var match=param[2],a2=match[2],a1=match[1];
        return caml_call2(equal_a,a1,a2)}
      return for_all$2(zip_full(t1,t2),_Ei_)}
    function round_robin(list)
     {function next(param)
       {var done_stack=param[2],todo_stack=param[1];
        if(! todo_stack)
         return is_empty(done_stack)?0:[0,[0,rev(done_stack),0]];
        var
         todo_stack$0=todo_stack[2],
         match=todo_stack[1],
         f=match[2],
         s=match[1],
         match$0=caml_call1(f,s);
        if(typeof match$0 === "number")return [0,[0,todo_stack$0,done_stack]];
        if(0 === match$0[0])
         {var s$0=match$0[1];
          return [0,[0,[0,[0,s$0,f],todo_stack$0],done_stack]]}
        var s$1=match$0[2],x=match$0[1];
        return [1,x,[0,todo_stack$0,[0,[0,s$1,f],done_stack]]]}
      var state=[0,list,0];
      return [0,state,next]}
    function interleave(param)
     {var f1=param[2],s1=param[1];
      function next(param)
       {var s1=param[3],done_stack=param[2],todo_stack=param[1];
        if(todo_stack)
         {var
           todo_stack$0=todo_stack[2],
           match=todo_stack[1],
           f2=match[2],
           s2=match[1],
           match$0=caml_call1(f2,s2);
          if(typeof match$0 === "number")
           return [0,[0,todo_stack$0,done_stack,s1]];
          if(0 === match$0[0])
           {var s2$0=match$0[1];
            return [0,[0,todo_stack$0,[0,[0,s2$0,f2],done_stack],s1]]}
          var s2$1=match$0[2],x=match$0[1];
          return [1,x,[0,todo_stack$0,[0,[0,s2$1,f2],done_stack],s1]]}
        var match$1=caml_call1(f1,s1);
        if(typeof match$1 === "number")
         return done_stack?[0,[0,rev(done_stack),0,s1]]:0;
        if(0 === match$1[0])
         {var s1$0=match$1[1];return [0,[0,rev(done_stack),0,s1$0]]}
        var s1$1=match$1[2],t=match$1[1];
        return [0,[0,rev([0,t,done_stack]),0,s1$1]]}
      var state=[0,0,0,s1];
      return [0,state,next]}
    function interleaved_cartesian_product(s1,s2)
     {return interleave
              (caml_call2
                (map$19,
                 s1,
                 function(x1)
                  {return caml_call2(map$19,s2,function(x2){return [0,x1,x2]})}))}
    function of_seq(seq)
     {return [0,
              seq,
              function(seq)
               {var match=caml_call1(seq,0);
                if(! match)return 0;
                var tl=match[2],hd=match[1];
                return [1,hd,tl]}]}
    function to_seq(param)
     {var next=param[2],state=param[1];
      function loop(state)
       {var state$0=state;
        for(;;)
         {var match=caml_call1(next,state$0);
          if(typeof match === "number")return 0;
          if(0 === match[0]){var state$1=match[1],state$0=state$1;continue}
          var state$2=match[2],hd=match[1];
          return [0,hd,function(param){return loop(state$2)}]}}
      return function(param){return loop(state)}}
    function return$13(x,k){return caml_call1(k,x)}
    function bind$13(m,f,k)
     {return caml_call1
              (m,function(a){var m=caml_call1(f,a);return caml_call1(m,k)})}
    var
     map$20=
      [0,
       -198771759,
       function(m,f,k)
        {return caml_call1
                 (m,function(a){return caml_call1(k,caml_call1(f,a))})}],
     include$38=Make2([0,bind$13,map$20,return$13]),
     symbol_bind$6=include$38[1],
     symbol_map$7=include$38[2],
     Let_syntax$6=include$38[3],
     Monad_infix$4=include$38[4],
     bind$14=include$38[5],
     return$14=include$38[6],
     map$21=include$38[7],
     join$5=include$38[8],
     ignore_m$5=include$38[9],
     all$12=include$38[10],
     all_unit$6=include$38[11];
    function yield$0(e,k){return [0,[1,e,k]]}
    function of_sequence(sequence)
     {return delayed_fold
              (sequence,
               0,
               function(param,x,k,f)
                {return [0,[1,x,function(param){return caml_call2(k,0,f)}]]},
               return$14)}
    function run$0(t)
     {function init(param){return caml_call1(t,function(param){return _bi_})}
      function f(thunk){return caml_call1(thunk,0)[1]}
      return [0,init,f]}
    var
     Base_Sequence=
      [0,
       sexp_of_t$26,
       equal$19,
       compare$30,
       mem$2,
       length$2,
       is_empty$1,
       iter$5,
       fold$1,
       fold_result$2,
       fold_until$2,
       exists$2,
       for_all$2,
       count$2,
       sum$2,
       find$3,
       find_map$2,
       to_list$3,
       to_array$1,
       min_elt$2,
       max_elt$2,
       foldi$1,
       iteri$2,
       existsi$1,
       counti$1,
       findi$1,
       find_mapi$1,
       symbol_bind$5,
       symbol_map$6,
       Monad_infix$3,
       bind$12,
       return$12,
       map$19,
       join$4,
       ignore_m$4,
       all$11,
       all_unit$5,
       Let_syntax$5,
       empty,
       next,
       Step,
       unfold_step,
       unfold,
       unfold_with,
       unfold_with_and_finish,
       nth$0,
       nth_exn$0,
       folding_map$0,
       folding_mapi$0,
       mapi$2,
       filteri$0,
       filter$1,
       merge_deduped_and_sorted,
       merge_deduped_and_sorted,
       merge_sorted,
       Merge_with_duplicates_element,
       merge_with_duplicates,
       hd$0,
       hd_exn$0,
       tl$0,
       tl_eagerly_exn,
       find_exn$1,
       for_alli$1,
       append$1,
       concat$2,
       concat_map,
       concat_mapi$0,
       interleave,
       round_robin,
       zip$0,
       zip_full,
       reduce_exn$0,
       reduce$0,
       group$1,
       find_consecutive_duplicate$0,
       remove_consecutive_duplicates$0,
       range$1,
       init$2,
       filter_map$0,
       filter_mapi$0,
       filter_opt$0,
       sub$4,
       take$0,
       drop$0,
       drop_eagerly,
       take_while$0,
       drop_while$0,
       drop_while_option,
       split_n$0,
       chunks_exn,
       shift_right,
       shift_right_with_list,
       drop$0,
       Infix$1,
       cartesian_product$0,
       interleaved_cartesian_product,
       intersperse$0,
       cycle_list_exn,
       repeat,
       singleton,
       delayed_fold,
       fold_m,
       iter_m,
       to_list_rev,
       of_list$1,
       of_lazy$0,
       memoize,
       force_eagerly,
       bounded_length,
       length_is_bounded_by,
       of_seq,
       to_seq,
       [0,
        symbol_bind$6,
        symbol_map$7,
        Let_syntax$6,
        Monad_infix$4,
        bind$14,
        return$14,
        map$21,
        join$5,
        ignore_m$5,
        all$12,
        all_unit$6,
        yield$0,
        of_sequence,
        run$0],
       Expert];
    caml_register_global(1068,Base_Sequence,"Base__Sequence");
    function t_sexp_grammar$20(a_sexp_grammar)
     {return caml_call1(array_sexp_grammar,a_sexp_grammar)}
    function get$0(_Eh_,_Eg_){return caml_check_bound(_Eh_,_Eg_)[1 + _Eg_]}
    function set(_Ef_,_Ee_,_Ed_)
     {caml_check_bound(_Ef_,_Ee_)[1 + _Ee_] = _Ed_;return 0}
    function swap$1(arr,i,j)
     {var tmp=get$0(arr,i);set(arr,i,get$0(arr,j));return set(arr,j,tmp)}
    function sort$0(arr,compare,left,right)
     {var _Eb_=left + 1 | 0;
      if(right >= _Eb_)
       {var pos=_Eb_;
        a:
        for(;;)
         {var v=get$0(arr,pos),i=pos;
          for(;;)
           {var i_next=i - 1 | 0;
            if(left <= i_next && 0 < caml_call2(compare,get$0(arr,i_next),v))
             {set(arr,i,get$0(arr,i_next));var i=i_next;continue}
            set(arr,i,v);
            var _Ec_=pos + 1 | 0;
            if(right !== pos){var pos=_Ec_;continue a}
            break}
          break}}
      return 0}
    var Insertion_sort=[0,sort$0];
    function heapify(arr,compare,root,left,right)
     {var root$0=root;
      for(;;)
       {var
         relative_root=root$0 - left | 0,
         left_child=((2 * relative_root | 0) + left | 0) + 1 | 0,
         right_child=((2 * relative_root | 0) + left | 0) + 2 | 0,
         switch$0=0;
        if(left_child <= right)
         {var _D__=get$0(arr,root$0);
          if(0 < caml_call2(compare,get$0(arr,left_child),_D__))
           {var largest=left_child;switch$0 = 1}}
        if(! switch$0)var largest=root$0;
        var switch$1=0;
        if(right_child <= right)
         {var _D$_=get$0(arr,largest);
          if(0 < caml_call2(compare,get$0(arr,right_child),_D$_))
           {var largest$0=right_child;switch$1 = 1}}
        if(! switch$1)var largest$0=largest;
        var _Ea_=largest$0 !== root$0?1:0;
        if(! _Ea_)return _Ea_;
        swap$1(arr,root$0,largest$0);
        var root$0=largest$0}}
    function sort$1(arr,compare,left,right)
     {var _D6_=(left + right | 0) / 2 | 0;
      if(_D6_ >= left)
       {var i=_D6_;
        for(;;)
         {heapify(arr,compare,i,left,right);
          var _D7_=i - 1 | 0;
          if(left !== i){var i=_D7_;continue}
          break}}
      var _D8_=left + 1 | 0;
      if(right >= _D8_)
       {var i$0=right;
        for(;;)
         {swap$1(arr,left,i$0);
          heapify(arr,compare,left,left,i$0 - 1 | 0);
          var _D9_=i$0 - 1 | 0;
          if(_D8_ !== i$0){var i$0=_D9_;continue}
          break}}
      return 0}
    var Heap_sort=[0,sort$1];
    function five_element_sort(arr,compare,m1,m2,m3,m4,m5)
     {function compare_and_swap(i,j)
       {var
         _D4_=get$0(arr,j),
         _D5_=0 < caml_call2(compare,get$0(arr,i),_D4_)?1:0;
        return _D5_?swap$1(arr,i,j):_D5_}
      compare_and_swap(m1,m2);
      compare_and_swap(m4,m5);
      compare_and_swap(m1,m3);
      compare_and_swap(m2,m3);
      compare_and_swap(m1,m4);
      compare_and_swap(m3,m4);
      compare_and_swap(m2,m5);
      compare_and_swap(m2,m3);
      return compare_and_swap(m4,m5)}
    function intro_sort(arr,max_depth,compare,left,r$3)
     {var max_depth$0=max_depth,left$0=left;
      a:
      for(;;)
       {var len=(r$3 - left$0 | 0) + 1 | 0;
        if(32 >= len)
         return caml_call4(Insertion_sort[1],arr,compare,left$0,r$3);
        if(0 > max_depth$0)
         return caml_call4(Heap_sort[1],arr,compare,left$0,r$3);
        var
         max_depth$1=max_depth$0 - 1 | 0,
         sixth=(r$3 - left$0 | 0) / 6 | 0,
         m1=left$0 + sixth | 0,
         m2=m1 + sixth | 0,
         m3=m2 + sixth | 0,
         m4=m3 + sixth | 0,
         m5=m4 + sixth | 0;
        five_element_sort(arr,compare,m1,m2,m3,m4,m5);
        var
         m2_val=get$0(arr,m2),
         m3_val=get$0(arr,m3),
         m4_val=get$0(arr,m4),
         match=
          0 === caml_call2(compare,m2_val,m3_val)
           ?[0,m2_val,m3_val,1]
           :0 === caml_call2(compare,m3_val,m4_val)
             ?[0,m3_val,m4_val,1]
             :[0,m2_val,m4_val,0],
         middle_sorted=match[3],
         pivot2=match[2],
         pivot1=match[1],
         l$0=left$0,
         p$1=left$0,
         r$2=r$3;
        b:
        for(;;)
         {if(r$2 < p$1)
           {intro_sort(arr,max_depth$1,compare,left$0,l$0 - 1 | 0);
            if(1 - middle_sorted)intro_sort(arr,max_depth$1,compare,l$0,r$2);
            var left$1=r$2 + 1 | 0,max_depth$0=max_depth$1,left$0=left$1;
            continue a}
          var pv=get$0(arr,p$1);
          if(0 > caml_call2(compare,pv,pivot1))
           {swap$1(arr,p$1,l$0);
            var p$0=p$1 + 1 | 0,l=l$0 + 1 | 0,l$0=l,p$1=p$0;
            continue}
          if(0 >= caml_call2(compare,pv,pivot2))
           {var p=p$1 + 1 | 0,p$1=p;continue}
          var r=r$2;
          for(;;)
           {if(p$1 < r && 0 < caml_call2(compare,get$0(arr,r),pivot2))
             {var r$0=r - 1 | 0,r=r$0;continue}
            swap$1(arr,r,p$1);
            var r$1=r - 1 | 0,r$2=r$1;
            continue b}}}}
    function sort$2(arr,compare,left,right)
     {return intro_sort(arr,32,compare,left,right)}
    var Intro_sort=[0,sort$2,five_element_sort];
    function sort$3(pos,len,arr,compare)
     {var
       match=get_pos_len_exn(pos,len,0,arr.length - 1),
       len$0=match[2],
       pos$0=match[1];
      return caml_call4
              (Intro_sort[1],arr,compare,pos$0,(pos$0 + len$0 | 0) - 1 | 0)}
    function to_array$2(t){return t}
    function is_empty$2(t){return 0 === t.length - 1?1:0}
    function is_sorted$0(t,compare)
     {var i=[0,t.length - 1 - 1 | 0],result=[0,1];
      for(;;)
       {if(0 < i[1] && result[1])
         {var elt_i=t[1 + i[1]],elt_i_minus_1=t[1 + (i[1] - 1 | 0)];
          if(0 < caml_call2(compare,elt_i_minus_1,elt_i))result[1] = 0;
          decr(i);
          continue}
        return result[1]}}
    function is_sorted_strictly$0(t,compare)
     {var i=[0,t.length - 1 - 1 | 0],result=[0,1];
      for(;;)
       {if(0 < i[1] && result[1])
         {var elt_i=t[1 + i[1]],elt_i_minus_1=t[1 + (i[1] - 1 | 0)];
          if(0 <= caml_call2(compare,elt_i_minus_1,elt_i))result[1] = 0;
          decr(i);
          continue}
        return result[1]}}
    function merge$1(a1,a2,compare)
     {var l1=a1.length - 1,l2=a2.length - 1;
      if(0 === l1)return caml_call1(copy,a2);
      if(0 === l2)return caml_call1(copy,a1);
      if(0 <= caml_call2(compare,a2[1],a1[1 + (l1 - 1 | 0)]))
       return caml_call2(append,a1,a2);
      if(0 < caml_call2(compare,a1[1],a2[1 + (l2 - 1 | 0)]))
       return caml_call2(append,a2,a1);
      var
       len=l1 + l2 | 0,
       merged=caml_make_vect(len,a1[1]),
       a1_index=[0,0],
       a2_index=[0,0],
       _D2_=len - 1 | 0,
       _D1_=0;
      if(_D2_ >= 0)
       {var i=_D1_;
        for(;;)
         {var
           use_a1=
            l1 === a1_index[1]
             ?0
             :l2 === a2_index[1]
               ?1
               :caml_call2(compare,a1[1 + a1_index[1]],a2[1 + a2_index[1]])
                 <=
                 0
                 ?1
                 :0;
          if(use_a1)
           {merged[1 + i] = a1[1 + a1_index[1]];
            a1_index[1] = a1_index[1] + 1 | 0}
          else
           {merged[1 + i] = a2[1 + a2_index[1]];
            a2_index[1] = a2_index[1] + 1 | 0}
          var _D3_=i + 1 | 0;
          if(_D2_ !== i){var i=_D3_;continue}
          break}}
      return merged}
    function copy_matrix(_D0_){return map(_D0_,copy)}
    function folding_map$1(t,init,f)
     {var acc=[0,init];
      return map
              (t,
               function(x)
                {var match=caml_call2(f,acc[1],x),y=match[2],new_acc=match[1];
                 acc[1] = new_acc;
                 return y})}
    function fold_map$0(t,init,f)
     {var
       acc=[0,init],
       result=
        map
         (t,
          function(x)
           {var match=caml_call2(f,acc[1],x),y=match[2],new_acc=match[1];
            acc[1] = new_acc;
            return y});
      return [0,acc[1],result]}
    function fold_result$3(t,init,f){return fold_result(fold,init,f,t)}
    function fold_until$3(t,init,f)
     {return function(_DZ_){return fold_until(fold,init,f,_DZ_,t)}}
    function count$3(t,f){return count(fold,t,f)}
    function sum$3(m,t,f){return caml_call2(sum(fold,m),t,f)}
    function min_elt$3(t,compare){return min_elt(fold,t,compare)}
    function max_elt$3(t,compare){return max_elt(fold,t,compare)}
    function foldi$2(t,init,f)
     {var acc=[0,init],_DX_=t.length - 1 - 1 | 0,_DW_=0;
      if(_DX_ >= 0)
       {var i=_DW_;
        for(;;)
         {acc[1] = caml_call3(f,i,acc[1],t[1 + i]);
          var _DY_=i + 1 | 0;
          if(_DX_ !== i){var i=_DY_;continue}
          break}}
      return acc[1]}
    function folding_mapi$1(t,init,f)
     {var acc=[0,init];
      return mapi
              (t,
               function(i,x)
                {var
                  match=caml_call3(f,i,acc[1],x),
                  y=match[2],
                  new_acc=match[1];
                 acc[1] = new_acc;
                 return y})}
    function fold_mapi$0(t,init,f)
     {var
       acc=[0,init],
       result=
        mapi
         (t,
          function(i,x)
           {var match=caml_call3(f,i,acc[1],x),y=match[2],new_acc=match[1];
            acc[1] = new_acc;
            return y});
      return [0,acc[1],result]}
    function counti$2(t,f)
     {return foldi$2
              (t,
               0,
               function(idx,count,a)
                {return caml_call2(f,idx,a)?count + 1 | 0:count})}
    function concat_map$0(t,f)
     {return caml_call1(concat,caml_call1(to_list,map(t,f)))}
    function concat_mapi$1(t,f)
     {return caml_call1(concat,caml_call1(to_list,mapi(t,f)))}
    function rev_inplace(t)
     {var i=[0,0],j=[0,t.length - 1 - 1 | 0];
      for(;;){if(i[1] >= j[1])return 0;swap(t,i[1],j[1]);incr(i);decr(j)}}
    function rev$0(t){var t$0=caml_call1(copy,t);rev_inplace(t$0);return t$0}
    function of_list_rev(l)
     {if(! l)return [0];
      var
       l$0=l[2],
       a=l[1],
       len=1 + caml_call1(length,l$0) | 0,
       t=caml_make_vect(len,a),
       r=[0,l$0],
       _DT_=len - 2 | 0;
      if(_DT_ >= 0)
       {var i=_DT_;
        for(;;)
         {var _DU_=r[1];
          if(! _DU_)throw [0,Assert_failure$0,_bj_];
          var l$1=_DU_[2],a$0=_DU_[1];
          caml_check_bound(t,i)[1 + i] = a$0;
          r[1] = l$1;
          var _DV_=i - 1 | 0;
          if(0 !== i){var i=_DV_;continue}
          break}}
      return t}
    function of_list_map(xs,f)
     {if(! xs)return [0];
      var
       tl=xs[2],
       hd=xs[1],
       _DS_=caml_call1(f,hd),
       a=caml_make_vect(1 + caml_call1(length,tl) | 0,_DS_),
       i=1,
       param=tl;
      for(;;)
       {if(! param)return a;
        var tl$0=param[2],hd$0=param[1];
        a[1 + i] = caml_call1(f,hd$0);
        var i$0=i + 1 | 0,i=i$0,param=tl$0}}
    function of_list_mapi(xs,f)
     {if(! xs)return [0];
      var
       tl=xs[2],
       hd=xs[1],
       _DR_=caml_call2(f,0,hd),
       a=caml_make_vect(1 + caml_call1(length,tl) | 0,_DR_),
       i=1,
       param=tl;
      for(;;)
       {if(! param)return a;
        var tl$0=param[2],hd$0=param[1];
        a[1 + i] = caml_call2(f,i,hd$0);
        var i$0=i + 1 | 0,i=i$0,param=tl$0}}
    function of_list_rev_map(xs,f)
     {var t=of_list_map(xs,f);rev_inplace(t);return t}
    function of_list_rev_mapi(xs,f)
     {var t=of_list_mapi(xs,f);rev_inplace(t);return t}
    function filter_mapi$1(t,f)
     {var r=[0,[0]],k=[0,0],_DP_=t.length - 1 - 1 | 0,_DO_=0;
      if(_DP_ >= 0)
       {var i=_DO_;
        for(;;)
         {var match=caml_call2(f,i,t[1 + i]);
          if(match)
           {var a=match[1];
            if(0 === k[1])r[1] = caml_make_vect(t.length - 1,a);
            r[1][1 + k[1]] = a;
            incr(k)}
          var _DQ_=i + 1 | 0;
          if(_DP_ !== i){var i=_DQ_;continue}
          break}}
      return k[1] === t.length - 1
              ?r[1]
              :0 < k[1]?caml_call3(sub$0,r[1],0,k[1]):[0]}
    function filter_map$1(t,f)
     {return filter_mapi$1(t,function(i,a){return caml_call1(f,a)})}
    function filter_opt$1(t)
     {return filter_map$1(t,function(_DN_){return _DN_})}
    function check_length2_exn$0(name,t1,t2)
     {var n1=t1.length - 1,n2=t2.length - 1,_DM_=n1 !== n2?1:0;
      return _DM_?caml_call4(invalid_argf(_bk_),name,n1,n2,0):_DM_}
    function iter2_exn$0(t1,t2,f)
     {check_length2_exn$0(cst_Array_iter2_exn,t1,t2);
      return iteri(t1,function(i,x1){return caml_call2(f,x1,t2[1 + i])})}
    function map2_exn$0(t1,t2,f)
     {check_length2_exn$0(cst_Array_map2_exn,t1,t2);
      return caml_call2
              (init,
               t1.length - 1,
               function(i){return caml_call2(f,t1[1 + i],t2[1 + i])})}
    function fold2_exn$0(t1,t2,init,f)
     {check_length2_exn$0(cst_Array_fold2_exn,t1,t2);
      return foldi$2
              (t1,init,function(i,ac,x){return caml_call3(f,ac,x,t2[1 + i])})}
    function filter$2(t,f)
     {return filter_map$1(t,function(x){return caml_call1(f,x)?[0,x]:0})}
    function filteri$1(t,f)
     {return filter_mapi$1(t,function(i,x){return caml_call2(f,i,x)?[0,x]:0})}
    function exists$3(t,f)
     {var i=[0,t.length - 1 - 1 | 0],result=[0,0];
      for(;;)
       {if(0 <= i[1] && ! result[1])
         {if(caml_call1(f,t[1 + i[1]])){result[1] = 1;continue}
          decr(i);
          continue}
        return result[1]}}
    function existsi$2(t,f)
     {var i=[0,t.length - 1 - 1 | 0],result=[0,0];
      for(;;)
       {if(0 <= i[1] && ! result[1])
         {if(caml_call2(f,i[1],t[1 + i[1]])){result[1] = 1;continue}
          decr(i);
          continue}
        return result[1]}}
    function mem$3(t,a,equal){return exists$3(t,caml_call1(equal,a))}
    function for_all$3(t,f)
     {var i=[0,t.length - 1 - 1 | 0],result=[0,1];
      for(;;)
       {if(0 <= i[1] && result[1])
         {if(caml_call1(f,t[1 + i[1]])){decr(i);continue}
          result[1] = 0;
          continue}
        return result[1]}}
    function for_alli$2(t,f)
     {var length=t.length - 1,i=[0,length - 1 | 0],result=[0,1];
      for(;;)
       {if(0 <= i[1] && result[1])
         {if(caml_call2(f,i[1],t[1 + i[1]])){decr(i);continue}
          result[1] = 0;
          continue}
        return result[1]}}
    function exists2_exn$0(t1,t2,f)
     {check_length2_exn$0(cst_Array_exists2_exn,t1,t2);
      var i=[0,t1.length - 1 - 1 | 0],result=[0,0];
      for(;;)
       {if(0 <= i[1] && ! result[1])
         {if(caml_call2(f,t1[1 + i[1]],t2[1 + i[1]])){result[1] = 1;continue}
          decr(i);
          continue}
        return result[1]}}
    function for_all2_exn$0(t1,t2,f)
     {check_length2_exn$0(cst_Array_for_all2_exn,t1,t2);
      var i=[0,t1.length - 1 - 1 | 0],result=[0,1];
      for(;;)
       {if(0 <= i[1] && result[1])
         {if(caml_call2(f,t1[1 + i[1]],t2[1 + i[1]])){decr(i);continue}
          result[1] = 0;
          continue}
        return result[1]}}
    function equal_array$1(equal,t1,t2)
     {var _DL_=t1.length - 1 === t2.length - 1?1:0;
      return _DL_?for_all2_exn$0(t1,t2,equal):_DL_}
    function map_inplace(t,f)
     {var _DJ_=t.length - 1 - 1 | 0,_DI_=0;
      if(_DJ_ >= 0)
       {var i=_DI_;
        for(;;)
         {t[1 + i] = caml_call1(f,t[1 + i]);
          var _DK_=i + 1 | 0;
          if(_DJ_ !== i){var i=_DK_;continue}
          break}}
      return 0}
    function findi_internal(t,f,if_found,if_not_found)
     {var length=t.length - 1;
      if(0 === length)return caml_call1(if_not_found,0);
      var i=[0,0],found=[0,0],value_found=[0,t[1]];
      for(;;)
       {if(! found[1] && i[1] < length)
         {var value=t[1 + i[1]];
          if(caml_call2(f,i[1],value))
           {value_found[1] = value;found[1] = 1}
          else
           incr(i);
          continue}
        return found[1]
                ?caml_call2(if_found,i[1],value_found[1])
                :caml_call1(if_not_found,0)}}
    function findi$2(t,f)
     {function _DH_(param){return 0}
      return findi_internal
              (t,f,function(i,value){return [0,[0,i,value]]},_DH_)}
    function findi_exn$0(t,f)
     {function _DG_(param){throw [0,Not_found_s,_bl_]}
      return findi_internal(t,f,function(i,value){return [0,i,value]},_DG_)}
    function find_exn$2(t,f)
     {function _DE_(param){throw [0,Not_found_s,_bm_]}
      function _DF_(param,value){return value}
      return findi_internal(t,function(i,x){return caml_call1(f,x)},_DF_,_DE_)}
    function find$4(t,f)
     {function _DD_(param){var x=param[2];return x}
      return caml_call2
              (map$16,findi$2(t,function(i,x){return caml_call1(f,x)}),_DD_)}
    function find_map$3(t,f)
     {var length=t.length - 1;
      if(0 === length)return 0;
      var i=[0,0],value_found=[0,0];
      for(;;)
       {if(is_none(value_found[1]) && i[1] < length)
         {var value=t[1 + i[1]];
          value_found[1] = caml_call1(f,value);
          incr(i);
          continue}
        return value_found[1]}}
    var not_found$4=[0,Not_found_s,_bn_];
    function find_map_exn$0(t,f)
     {var match=find_map$3(t,f);
      if(! match)throw not_found$4;
      var x=match[1];
      return x}
    function find_mapi$2(t,f)
     {var length=t.length - 1;
      if(0 === length)return 0;
      var i=[0,0],value_found=[0,0];
      for(;;)
       {if(is_none(value_found[1]) && i[1] < length)
         {var value=t[1 + i[1]];
          value_found[1] = caml_call2(f,i[1],value);
          incr(i);
          continue}
        return value_found[1]}}
    var not_found$5=[0,Not_found_s,_bo_];
    function find_mapi_exn$0(t,f)
     {var match=find_mapi$2(t,f);
      if(! match)throw not_found$5;
      var x=match[1];
      return x}
    function find_consecutive_duplicate$1(t,equal)
     {var n=t.length - 1;
      if(1 >= n)return 0;
      var result=[0,0],i=[0,1],prev=[0,t[1]];
      for(;;)
       {if(i[1] >= n)return result[1];
        var cur=t[1 + i[1]];
        if(caml_call2(equal,cur,prev[1]))
         {result[1] = [0,[0,prev[1],cur]];i[1] = n}
        else
         {prev[1] = cur;incr(i)}}}
    function reduce$1(t,f)
     {if(0 === t.length - 1)return 0;
      var r=[0,t[1]],_DB_=t.length - 1 - 1 | 0,_DA_=1;
      if(_DB_ >= 1)
       {var i=_DA_;
        for(;;)
         {r[1] = caml_call2(f,r[1],t[1 + i]);
          var _DC_=i + 1 | 0;
          if(_DB_ !== i){var i=_DC_;continue}
          break}}
      return [0,r[1]]}
    function reduce_exn$1(t,f)
     {var match=reduce$1(t,f);
      if(! match)return caml_call1(invalid_arg$0,cst_Array_reduce_exn);
      var v=match[1];
      return v}
    function random_element_exn$0(opt,t)
     {if(opt)var sth=opt[1],random_state=sth;else var random_state=_ag_[1];
      if(is_empty$2(t))
       return caml_call1(failwith$0,cst_Array_random_element_exn_e);
      var _Dz_=caml_call2(_ag_[6],random_state,t.length - 1);
      return caml_check_bound(t,_Dz_)[1 + _Dz_]}
    function random_element$0(opt,t)
     {if(opt)var sth=opt[1],random_state=sth;else var random_state=_ag_[1];
      try
       {var _Dx_=[0,random_element_exn$0([0,random_state],t)];return _Dx_}
      catch(_Dy_){return 0}}
    function zip$1(t1,t2)
     {return t1.length - 1 !== t2.length - 1
              ?0
              :[0,map2_exn$0(t1,t2,function(x1,x2){return [0,x1,x2]})]}
    function zip_exn$0(t1,t2)
     {return t1.length - 1 !== t2.length - 1
              ?caml_call1(failwith$0,cst_Array_zip_exn)
              :map2_exn$0(t1,t2,function(x1,x2){return [0,x1,x2]})}
    function unzip$1(t)
     {var n=t.length - 1;
      if(0 === n)return [0,[0],[0]];
      var
       match=caml_check_bound(t,0)[1],
       y=match[2],
       x=match[1],
       res1=caml_make_vect(n,x),
       res2=caml_make_vect(n,y),
       _Dv_=n - 1 | 0,
       _Du_=1;
      if(_Dv_ >= 1)
       {var i=_Du_;
        for(;;)
         {var
           match$0=caml_check_bound(t,i)[1 + i],
           y$0=match$0[2],
           x$0=match$0[1];
          caml_check_bound(res1,i)[1 + i] = x$0;
          caml_check_bound(res2,i)[1 + i] = y$0;
          var _Dw_=i + 1 | 0;
          if(_Dv_ !== i){var i=_Dw_;continue}
          break}}
      return [0,res1,res2]}
    function sorted_copy(t,compare)
     {var t1=caml_call1(copy,t);sort$3(0,0,t1,compare);return t1}
    function partitioni_tf(t,f)
     {var
       both=mapi(t,function(i,x){return caml_call2(f,i,x)?[0,x]:[1,x]}),
       trues=
        filter_map$1
         (both,
          function(param)
           {if(0 !== param[0])return 0;var x=param[1];return [0,x]}),
       falses=
        filter_map$1
         (both,
          function(param)
           {if(0 === param[0])return 0;var x=param[1];return [0,x]});
      return [0,trues,falses]}
    function partition_tf$0(t,f)
     {return partitioni_tf(t,function(i,x){return caml_call1(f,x)})}
    function last$0(t)
     {var _Dt_=t.length - 1 - 1 | 0;return caml_check_bound(t,_Dt_)[1 + _Dt_]}
    function to_sequence_mutable(t)
     {return [0,
              0,
              function(i)
               {return t.length - 1 <= i
                        ?0
                        :[1,caml_check_bound(t,i)[1 + i],i + 1 | 0]}]}
    function to_sequence(t){return to_sequence_mutable(caml_call1(copy,t))}
    function cartesian_product$1(t1,t2)
     {if(! is_empty$2(t1) && ! is_empty$2(t2))
       {var
         n1=t1.length - 1,
         n2=t2.length - 1,
         _Dj_=caml_check_bound(t2,0)[1],
         t=caml_make_vect(caml_mul(n1,n2),[0,caml_check_bound(t1,0)[1],_Dj_]),
         r=[0,0],
         _Dl_=n1 - 1 | 0,
         _Dk_=0;
        if(_Dl_ >= 0)
         {var i1=_Dk_;
          for(;;)
           {var _Dn_=n2 - 1 | 0,_Dm_=0;
            if(_Dn_ >= 0)
             {var i2=_Dm_;
              for(;;)
               {var
                 _Dp_=caml_check_bound(t2,i2)[1 + i2],
                 _Dq_=[0,caml_check_bound(t1,i1)[1 + i1],_Dp_],
                 _Dr_=r[1];
                caml_check_bound(t,_Dr_)[1 + _Dr_] = _Dq_;
                incr(r);
                var _Ds_=i2 + 1 | 0;
                if(_Dn_ !== i2){var i2=_Ds_;continue}
                break}}
            var _Do_=i1 + 1 | 0;
            if(_Dl_ !== i1){var i1=_Do_;continue}
            break}}
        return t}
      return [0]}
    function transpose$0(tt)
     {if(0 === tt.length - 1)return [0,[0]];
      var width=tt.length - 1,depth=caml_check_bound(tt,0)[1].length - 1;
      return exists$3(tt,function(t){return t.length - 1 !== depth?1:0})
              ?0
              :[0,
                caml_call2
                 (init,
                  depth,
                  function(d)
                   {return caml_call2
                            (init,
                             width,
                             function(w)
                              {return caml_check_bound(caml_check_bound(tt,w)[1 + w],d)
                                       [1 + d]})})]}
    function transpose_exn$0(tt)
     {var match=transpose$0(tt);
      if(! match)return caml_call1(invalid_arg$0,cst_Array_transpose_exn);
      var tt$0=match[1];
      return tt$0}
    function get$1(_Di_,_Dh_){return caml_check_bound(_Di_,_Dh_)[1 + _Dh_]}
    function length$3(_Dg_){return _Dg_.length - 1}
    var
     include$39=_a2_([0,get$1,length$3]),
     binary_search$0=include$39[1],
     binary_search_segmented$0=include$39[2];
    function length$4(_Df_){return _Df_.length - 1}
    function create_like(len,t)
     {if(0 === len)return [0];
      if(0 < t.length - 1)return caml_make_vect(len,caml_check_bound(t,0)[1]);
      throw [0,Assert_failure$0,_bp_]}
    var
     unsafe_blit$1=runtime.caml_array_blit,
     include$40=_a4_([0,create_like,length$4,unsafe_blit$1]),
     blit$1=include$40[1],
     blito=include$40[2],
     unsafe_blit$2=include$40[3],
     sub$5=include$40[4],
     subo=include$40[5];
    function invariant$8(invariant_a,t){return iter(t,invariant_a)}
    var
     Base_Array=
      [0,
       compare_array$0,
       array_of_sexp,
       sexp_of_array,
       t_sexp_grammar$20,
       binary_search$0,
       binary_search_segmented$0,
       mem$3,
       is_empty$2,
       iter,
       fold,
       fold_result$3,
       fold_until$3,
       exists$3,
       for_all$3,
       count$3,
       sum$3,
       find$4,
       find_map$3,
       to_list,
       to_array$2,
       min_elt$3,
       max_elt$3,
       invariant$8,
       max_length$0,
       create,
       create_float_uninitialized,
       init,
       make_matrix,
       copy_matrix,
       append,
       concat,
       copy,
       fill,
       blit$1,
       blito,
       unsafe_blit$2,
       sub$5,
       subo,
       of_list,
       map,
       folding_map$1,
       folding_mapi$1,
       fold_map$0,
       fold_mapi$0,
       iteri,
       mapi,
       foldi$2,
       fold_right,
       sort$3,
       stable_sort,
       is_sorted$0,
       is_sorted_strictly$0,
       merge$1,
       concat_map$0,
       concat_mapi$1,
       partition_tf$0,
       partitioni_tf,
       cartesian_product$1,
       transpose$0,
       transpose_exn$0,
       filter_opt$1,
       filter_map$1,
       filter_mapi$1,
       for_alli$2,
       existsi$2,
       counti$2,
       iter2_exn$0,
       map2_exn$0,
       fold2_exn$0,
       for_all2_exn$0,
       exists2_exn$0,
       filter$2,
       filteri$1,
       swap,
       rev_inplace,
       rev$0,
       of_list_rev,
       of_list_map,
       of_list_mapi,
       of_list_rev_map,
       of_list_rev_mapi,
       map_inplace,
       find_exn$2,
       find_map_exn$0,
       findi$2,
       findi_exn$0,
       find_mapi$2,
       find_mapi_exn$0,
       find_consecutive_duplicate$1,
       reduce$1,
       reduce_exn$1,
       permute,
       random_element$0,
       random_element_exn$0,
       zip$1,
       zip_exn$0,
       unzip$1,
       sorted_copy,
       last$0,
       equal_array$1,
       to_sequence,
       to_sequence_mutable,
       [0,[0,Insertion_sort,Heap_sort,Intro_sort]]];
    caml_register_global(1069,Base_Array,"Base__Array");
    function invariant$9(t)
     {var _De_=Stdlib_Obj[15];
      if(caml_obj_tag(t) !== _De_)return 0;
      throw [0,Assert_failure$0,_bq_]}
    function length$5(_Dd_){return _Dd_.length - 1}
    function sexp_of_t$28(t)
     {return [0,
              concat$0
               (_bs_,
                [0,
                 cst_Obj_array_t_of_length,
                 [0,caml_call1(to_string,t.length - 1),_br_]])]}
    function create_zero(len){return caml_make_vect(len,0)}
    var empty$0=[0];
    function get$2(t,i){return caml_check_bound(t,i)[1 + i]}
    function unsafe_get(t,i){return t[1 + i]}
    function unsafe_set_with_caml_modify(t,i,obj){t[1 + i] = obj;return 0}
    function set_with_caml_modify(t,i,obj)
     {caml_check_bound(t,i)[1 + i] = obj;return 0}
    function unsafe_set_int_assuming_curren(t,i,int$0)
     {t[1 + i] = int$0;return 0}
    function set$0(t,i,obj)
     {var old_obj=get$2(t,i);
      if(typeof old_obj === "number" && typeof obj === "number")
       return unsafe_set_int_assuming_curren(t,i,obj);
      var _Dc_=1 - (old_obj === obj?1:0);
      return _Dc_?unsafe_set_with_caml_modify(t,i,obj):_Dc_}
    function unsafe_set(t,i,obj)
     {var old_obj=t[1 + i];
      if(typeof old_obj === "number" && typeof obj === "number")
       return unsafe_set_int_assuming_curren(t,i,obj);
      var _Db_=1 - (old_obj === obj?1:0);
      return _Db_?unsafe_set_with_caml_modify(t,i,obj):_Db_}
    function unsafe_set_omit_phys_equal_che(t,i,obj)
     {var old_obj=t[1 + i];
      if(typeof old_obj === "number" && typeof obj === "number")
       return unsafe_set_int_assuming_curren(t,i,obj);
      return unsafe_set_with_caml_modify(t,i,obj)}
    function swap$2(t,i,j)
     {var a=get$2(t,i),b=get$2(t,j);
      unsafe_set(t,i,b);
      return unsafe_set(t,j,a)}
    function create$3(len,x)
     {var _C9_=Stdlib_Obj[14];
      if(caml_obj_tag(x) !== _C9_)return caml_make_vect(len,x);
      var t=caml_make_vect(len,0),_C$_=len - 1 | 0,_C__=0;
      if(_C$_ >= 0)
       {var i=_C__;
        for(;;)
         {unsafe_set_with_caml_modify(t,i,x);
          var _Da_=i + 1 | 0;
          if(_C$_ !== i){var i=_Da_;continue}
          break}}
      return t}
    function singleton$0(obj){return create$3(1,obj)}
    function unsafe_set_assuming_currently_(t,i,obj)
     {return typeof obj === "number"
              ?unsafe_set_int_assuming_curren(t,i,obj)
              :unsafe_set_with_caml_modify(t,i,obj)}
    function unsafe_set_int(t,i,int$0)
     {var old_obj=t[1 + i];
      return typeof old_obj === "number"
              ?unsafe_set_int_assuming_curren(t,i,int$0)
              :unsafe_set_with_caml_modify(t,i,int$0)}
    function unsafe_clear_if_pointer(t,i)
     {var old_obj=t[1 + i],_C8_=1 - (typeof old_obj === "number"?1:0);
      return _C8_?unsafe_set_with_caml_modify(t,i,0):_C8_}
    function unsafe_blit$3(src,src_pos,dst,dst_pos,len)
     {if(dst_pos < src_pos)
       {var _C4_=len - 1 | 0,_C3_=0;
        if(_C4_ >= 0)
         {var i=_C3_;
          for(;;)
           {unsafe_set(dst,dst_pos + i | 0,src[1 + (src_pos + i | 0)]);
            var _C5_=i + 1 | 0;
            if(_C4_ !== i){var i=_C5_;continue}
            break}}
        return 0}
      var _C6_=len - 1 | 0;
      if(_C6_ >= 0)
       {var i$0=_C6_;
        for(;;)
         {unsafe_set(dst,dst_pos + i$0 | 0,src[1 + (src_pos + i$0 | 0)]);
          var _C7_=i$0 - 1 | 0;
          if(0 !== i$0){var i$0=_C7_;continue}
          break}}
      return 0}
    var
     include$41=_a6_([0,length$5,create_zero,unsafe_blit$3]),
     blit$2=include$41[1],
     blito$0=include$41[2],
     unsafe_blit$4=include$41[3],
     sub$6=include$41[4],
     subo$0=include$41[5];
    function copy$3(src)
     {var dst=caml_make_vect(src.length - 1,0);
      caml_call6(blito$0,src,0,0,dst,0,0);
      return dst}
    var
     Base_Obj_array=
      [0,
       sexp_of_t$28,
       blit$2,
       blito$0,
       unsafe_blit$4,
       sub$6,
       subo$0,
       invariant$9,
       create$3,
       create_zero,
       copy$3,
       singleton$0,
       empty$0,
       length$5,
       get$2,
       unsafe_get,
       set$0,
       unsafe_set,
       swap$2,
       set_with_caml_modify,
       unsafe_set_assuming_currently_,
       unsafe_set_int_assuming_curren,
       unsafe_set_int,
       unsafe_set_omit_phys_equal_che,
       unsafe_set_with_caml_modify,
       unsafe_clear_if_pointer];
    caml_register_global(1071,Base_Obj_array,"Base__Obj_array");
    function unsafe_create_uninitialized(len){return caml_make_vect(len,0)}
    function create_obj_array(len){return caml_make_vect(len,0)}
    function create$4(len,x){return create$3(len,x)}
    function singleton$1(x){return singleton$0(x)}
    function swap$3(t,i,j){return swap$2(t,i,j)}
    function get$3(arr,i){return get$2(arr,i)}
    function set$1(arr,i,x){return set$0(arr,i,x)}
    function unsafe_get$0(arr,i){return arr[1 + i]}
    function unsafe_set$0(arr,i,x){return unsafe_set(arr,i,x)}
    function unsafe_set_int$0(arr,i,x){return unsafe_set_int(arr,i,x)}
    function unsafe_set_int_assuming_curren$0(arr,i,x)
     {return unsafe_set_int_assuming_curren(arr,i,x)}
    function unsafe_set_assuming_currently_$0(arr,i,x)
     {return unsafe_set_assuming_currently_(arr,i,x)}
    function unsafe_set_omit_phys_equal_che$0(t,i,x)
     {return unsafe_set_omit_phys_equal_che(t,i,x)}
    function unsafe_set_with_caml_modify$0(t,i,x)
     {return unsafe_set_with_caml_modify(t,i,x)}
    function set_with_caml_modify$0(t,i,x){return set_with_caml_modify(t,i,x)}
    function invariant$10(t)
     {var _C2_=Stdlib_Obj[15];
      if(caml_obj_tag(t) !== _C2_)return 0;
      throw [0,Assert_failure$0,_bt_]}
    function init$3(l,f)
     {if(0 > l)return caml_call1(invalid_arg$0,cst_Uniform_array_init);
      var res=caml_make_vect(l,0),_C0_=l - 1 | 0,_CZ_=0;
      if(_C0_ >= 0)
       {var i=_CZ_;
        for(;;)
         {unsafe_set$0(res,i,caml_call1(f,i));
          var _C1_=i + 1 | 0;
          if(_C0_ !== i){var i=_C1_;continue}
          break}}
      return res}
    function of_array(arr)
     {return init$3(arr.length - 1,function(_CY_){return arr[1 + _CY_]})}
    function map$22(a,f)
     {return init$3(a.length - 1,function(i){return caml_call1(f,a[1 + i])})}
    function mapi$3(a,f)
     {return init$3(a.length - 1,function(i){return caml_call2(f,i,a[1 + i])})}
    function iter$6(a,f)
     {var _CW_=a.length - 1 - 1 | 0,_CV_=0;
      if(_CW_ >= 0)
       {var i=_CV_;
        for(;;)
         {caml_call1(f,a[1 + i]);
          var _CX_=i + 1 | 0;
          if(_CW_ !== i){var i=_CX_;continue}
          break}}
      return 0}
    function iteri$3(a,f)
     {var _CT_=a.length - 1 - 1 | 0,_CS_=0;
      if(_CT_ >= 0)
       {var i=_CS_;
        for(;;)
         {caml_call2(f,i,a[1 + i]);
          var _CU_=i + 1 | 0;
          if(_CT_ !== i){var i=_CU_;continue}
          break}}
      return 0}
    function foldi$3(a,init,f)
     {var acc=[0,init],_CQ_=a.length - 1 - 1 | 0,_CP_=0;
      if(_CQ_ >= 0)
       {var i=_CP_;
        for(;;)
         {acc[1] = caml_call3(f,i,acc[1],a[1 + i]);
          var _CR_=i + 1 | 0;
          if(_CQ_ !== i){var i=_CR_;continue}
          break}}
      return acc[1]}
    function to_list$4(t)
     {return init$1(t.length - 1,function(_CO_){return get$3(t,_CO_)})}
    function of_list$2(l)
     {var len=caml_call1(length,l),res=caml_make_vect(len,0);
      iteri$0(l,function(i,x){return set$1(res,i,x)});
      return res}
    function to_array$3(t)
     {return caml_call2(init,t.length - 1,function(i){return t[1 + i]})}
    function exists$4(t,f)
     {var i$1=t.length - 1 - 1 | 0,i=i$1;
      for(;;)
       {if(0 > i)return 0;
        var _CN_=caml_call1(f,t[1 + i]);
        if(_CN_)return _CN_;
        var i$0=i - 1 | 0,i=i$0}}
    function for_all$4(t,f)
     {var i$1=t.length - 1 - 1 | 0,i=i$1;
      for(;;)
       {if(0 > i)return 1;
        var _CM_=caml_call1(f,t[1 + i]);
        if(! _CM_)return _CM_;
        var i$0=i - 1 | 0,i=i$0}}
    function map2_exn$1(t1,t2,f)
     {var len=t1.length - 1;
      if(t2.length - 1 !== len)caml_call1(invalid_arg$0,cst_Array_map2_exn$0);
      return init$3(len,function(i){return caml_call2(f,t1[1 + i],t2[1 + i])})}
    function t_sexp_grammar$21(grammar)
     {var _CL_=t_sexp_grammar$20(grammar);
      return caml_call1(Sexplib0_Sexp_grammar[1],_CL_)}
    var
     include$90=
      Of_sexpable1([0,array_of_sexp,sexp_of_array],[0,to_array$3,of_array]),
     t_of_sexp$19=include$90[1],
     sexp_of_t$29=include$90[2];
    function create_like$0(len,t)
     {if(0 === len)return empty$0;
      if(0 < t.length - 1)return create$4(len,get$3(t,0));
      throw [0,Assert_failure$0,_bu_]}
    var
     include$42=_a4_([0,create_like$0,length$5,unsafe_blit$4]),
     blit$3=include$42[1],
     blito$1=include$42[2],
     unsafe_blit$5=include$42[3],
     sub$7=include$42[4],
     subo$1=include$42[5];
    function fold$2(t,init,f)
     {var r=[0,init],_CJ_=t.length - 1 - 1 | 0,_CI_=0;
      if(_CJ_ >= 0)
       {var i=_CI_;
        for(;;)
         {r[1] = caml_call2(f,r[1],t[1 + i]);
          var _CK_=i + 1 | 0;
          if(_CJ_ !== i){var i=_CK_;continue}
          break}}
      return r[1]}
    function min_elt$4(t,compare){return min_elt(fold$2,t,compare)}
    function max_elt$4(t,compare){return max_elt(fold$2,t,compare)}
    function compare$31(compare_elt,a,b)
     {if(a === b)return 0;
      var
       len_a=a.length - 1,
       len_b=b.length - 1,
       ret=caml_int_compare(len_a,len_b);
      if(0 !== ret)return ret;
      var i=0;
      for(;;)
       {if(i === len_a)return 0;
        var l=a[1 + i],r=b[1 + i],res=caml_call2(compare_elt,l,r);
        if(0 !== res)return res;
        var i$0=i + 1 | 0,i=i$0}}
    var
     Base_Uniform_array=
      [0,
       t_of_sexp$19,
       sexp_of_t$29,
       t_sexp_grammar$21,
       compare$31,
       invariant$10,
       empty$0,
       create$4,
       singleton$1,
       init$3,
       length$5,
       get$3,
       unsafe_get$0,
       set$1,
       unsafe_set$0,
       swap$3,
       unsafe_set_omit_phys_equal_che$0,
       unsafe_set_with_caml_modify$0,
       set_with_caml_modify$0,
       map$22,
       mapi$3,
       iter$6,
       iteri$3,
       foldi$3,
       of_array,
       to_array$3,
       of_list$2,
       to_list$4,
       blit$3,
       blito$1,
       unsafe_blit$5,
       sub$7,
       subo$1,
       copy$3,
       unsafe_create_uninitialized,
       create_obj_array,
       unsafe_set_assuming_currently_$0,
       unsafe_set_int_assuming_curren$0,
       unsafe_set_int$0,
       unsafe_clear_if_pointer,
       exists$4,
       for_all$4,
       map2_exn$1,
       min_elt$4,
       max_elt$4];
    caml_register_global(1073,Base_Uniform_array,"Base__Uniform_array");
    var
     succ$0=Stdlib_Uchar[5],
     pred=Stdlib_Uchar[6],
     is_valid=Stdlib_Uchar[7],
     is_char=Stdlib_Uchar[11],
     unsafe_to_char=Stdlib_Uchar[14],
     unsafe_of_int$0=Stdlib_Uchar[9],
     of_int$1=Stdlib_Uchar[8],
     to_int$2=Stdlib_Uchar[10],
     of_char=Stdlib_Uchar[12],
     compare$32=Stdlib_Uchar[16],
     equal$20=Stdlib_Uchar[15],
     min_value$1=Stdlib_Uchar[1],
     max_value$1=Stdlib_Uchar[2],
     include$43=
      [0,
       succ$0,
       pred,
       is_valid,
       is_char,
       unsafe_to_char,
       unsafe_of_int$0,
       of_int$1,
       to_int$2,
       of_char,
       compare$32,
       equal$20,
       min_value$1,
       max_value$1];
    caml_register_global(1074,include$43,"Base__Uchar0");
    var Base_Floatable=[0];
    caml_register_global(1075,Base_Floatable,"Base__Floatable");
    function ceil(_CH_){return Math.ceil(_CH_)}
    function floor(_CG_){return Math.floor(_CG_)}
    function mod_float(_CF_,_CE_){return _CF_ % _CE_}
    var
     modf=runtime.caml_modf_float,
     float_of_string$0=caml_float_of_string,
     nan$1=Caml$0[23],
     infinity$1=Caml$0[21],
     neg_infinity$1=Caml$0[22],
     max_finite_value=Caml$0[24],
     epsilon_float$1=Caml$0[26],
     classify_float=caml_classify_float;
    function abs_float(_CD_){return Math.abs(_CD_)}
    var is_integer=Stdlib_Float[16];
    function symbol$84(_CC_,_CB_){return Math.pow(_CC_,_CB_)}
    function symbol$85(a,b)
     {if(caml_call2(include$7[1],b,0.))caml_call3(invalid_argf(_bv_),a,b,0);
      var m=a % b;
      return caml_call2(include$7[1],m,0.)?m + b:m}
    var frexp=runtime.caml_frexp_float,ldexp=runtime.caml_ldexp_float;
    function is_nan(x){return caml_call2(include$7[3],x,x)}
    function to_int64_preserve_order(t)
     {return is_nan(t)
              ?0
              :caml_call2(include$7[4],t,0.)
                ?_bw_
                :caml_call2(include$7[5],t,0.)
                  ?[0,caml_int64_bits_of_float(t)]
                  :[0,caml_int64_neg(caml_int64_bits_of_float(- t))]}
    function to_int64_preserve_order_exn(x)
     {return value_exn(0,0,0,to_int64_preserve_order(x))}
    function of_int64_preserve_order(x)
     {return caml_greaterequal(x,_bx_)
              ?caml_int64_float_of_bits(x)
              :- caml_int64_float_of_bits(caml_int64_neg(x))}
    function one_ulp(dir,t)
     {var match=to_int64_preserve_order(t);
      if(! match)return Caml$0[23];
      var x=match[1],_CA_=759637122 <= dir?_by_:_bz_;
      return of_int64_preserve_order(caml_int64_add(x,_CA_))}
    function upper_bound_for_int(num_bits)
     {var exp=num_bits - 1 | 0;return one_ulp(759637122,Math.pow(2.,exp))}
    function is_x_minus_one_exact(x)
     {return 1
             -
             caml_equal
              (caml_int64_bits_of_float(x),caml_int64_bits_of_float(x - 1.))}
    function lower_bound_for_int(num_bits)
     {var exp=num_bits - 1 | 0,min_int_as_float=- Math.pow(2.,exp);
      if(53 <= (num_bits - 1 | 0))
       {if(is_x_minus_one_exact(min_int_as_float))
         throw [0,Assert_failure$0,_bA_];
        return min_int_as_float}
      if(is_x_minus_one_exact(min_int_as_float))
       return one_ulp(19067,min_int_as_float - 1.);
      throw [0,Assert_failure$0,_bB_]}
    function clamp_unchecked(t,min,max)
     {return caml_call2(include$7[1],t,min)
              ?min
              :caml_call2(include$7[1],max,t)?max:t}
    function box(f){return f + 0.}
    var
     symbol$86=include$7[1],
     symbol$87=include$7[2],
     symbol$88=include$7[3],
     symbol$89=include$7[4],
     symbol$90=include$7[5],
     symbol$91=include$7[6],
     ascending$12=include$7[7],
     descending$12=include$7[8],
     compare$33=include$7[9],
     equal$21=include$7[10],
     max$15=include$7[11],
     min$15=include$7[12],
     include$44=
      [0,
       ceil,
       floor,
       mod_float,
       modf,
       float_of_string$0,
       nan$1,
       infinity$1,
       neg_infinity$1,
       max_finite_value,
       epsilon_float$1,
       classify_float,
       abs_float,
       is_integer,
       symbol$84,
       symbol$85,
       frexp,
       ldexp,
       is_nan,
       to_int64_preserve_order,
       to_int64_preserve_order_exn,
       of_int64_preserve_order,
       one_ulp,
       upper_bound_for_int,
       is_x_minus_one_exact,
       lower_bound_for_int,
       clamp_unchecked,
       box,
       symbol$86,
       symbol$87,
       symbol$88,
       symbol$89,
       symbol$90,
       symbol$91,
       ascending$12,
       descending$12,
       compare$33,
       equal$21,
       max$15,
       min$15];
    caml_register_global(1077,include$44,"Base__Float0");
    function hash$7(x){return caml_call1(func$2,x)}
    function to_string$7(t){return caml_call2(make$1,1,t)}
    function of_string$6(s)
     {var match=caml_ml_string_length(s);
      return 1 === match?caml_string_get(s,0):caml_call2(failwithf(_bC_),s,0)}
    var
     include$45=
      _a1_
       ([0,
         compare$9,
         hash_fold_t$3,
         hash$7,
         t_of_sexp$3,
         sexp_of_t$3,
         of_string$6,
         to_string$7,
         module_name$4]),
     _bD_=include$45[1],
     _bE_=include$45[2],
     _bF_=include$45[3],
     _bG_=include$45[4],
     _bH_=include$45[5],
     _bI_=include$45[6],
     _bJ_=include$45[19],
     _bK_=include$45[20],
     _bL_=include$45[21],
     _bM_=include$45[22],
     _bN_=include$45[24];
    function pp$6(fmt,c){return caml_call3(Stdlib_Format[129],fmt,_bO_,c)}
    function invariant$11(param){return 0}
    var all$13=caml_call1(to_list,caml_call2(init,256,unsafe_of_int));
    function is_lowercase(param){return 25 < param - 97 >>> 0?0:1}
    function is_uppercase(param){return 25 < param - 65 >>> 0?0:1}
    function is_print(param){return 94 < param - 32 >>> 0?0:1}
    function is_whitespace(param)
     {var switch$0=0;
      if(14 <= param)
       {if(32 === param)switch$0 = 1}
      else
       if(9 <= param)switch$0 = 1;
      return switch$0?1:0}
    function is_digit(param){return 9 < param - 48 >>> 0?0:1}
    function is_alpha(param)
     {var switch$0=0;
      if(91 <= param)
       {if(25 >= param - 97 >>> 0)switch$0 = 1}
      else
       if(65 <= param)switch$0 = 1;
      return switch$0?1:0}
    function is_alphanum(param)
     {var _Cz_=param - 48 | 0,switch$0=0;
      if(42 < _Cz_ >>> 0)
       {if(25 >= _Cz_ - 49 >>> 0)switch$0 = 1}
      else
       if(6 < _Cz_ - 10 >>> 0)switch$0 = 1;
      return switch$0?1:0}
    function get_digit_exn(t)
     {return is_digit(t)?t - 48 | 0:caml_call2(failwithf(_bP_),t,0)}
    function get_digit(t){return is_digit(t)?[0,t - 48 | 0]:0}
    function is_hex_digit(param)
     {var _Cy_=param - 48 | 0,switch$0=0;
      if(22 < _Cy_ >>> 0)
       {if(5 >= _Cy_ - 49 >>> 0)switch$0 = 1}
      else
       if(6 < _Cy_ - 10 >>> 0)switch$0 = 1;
      return switch$0?1:0}
    function is_hex_digit_lower(param)
     {var switch$0=0;
      if(58 <= param)
       {if(5 >= param - 97 >>> 0)switch$0 = 1}
      else
       if(48 <= param)switch$0 = 1;
      return switch$0?1:0}
    function is_hex_digit_upper(param)
     {var switch$0=0;
      if(58 <= param)
       {if(5 >= param - 65 >>> 0)switch$0 = 1}
      else
       if(48 <= param)switch$0 = 1;
      return switch$0?1:0}
    function get_hex_digit_exn(t)
     {if(65 <= t)
       {if(97 <= t)
         {if(103 > t)return (t - 97 | 0) + 10 | 0}
        else
         if(71 > t)return (t - 65 | 0) + 10 | 0}
      else
       if(9 >= t - 48 >>> 0)return t - 48 | 0;
      return raise_s
              (caml_call2
                (message,
                 cst_Char_get_hex_digit_exn_not,
                 [0,[0,cst_char,caml_call1(_bG_,t)],0]))}
    function get_hex_digit(t)
     {return is_hex_digit(t)?[0,get_hex_digit_exn(t)]:0}
    var
     symbol$92=include$5[6],
     symbol$93=include$5[2],
     symbol$94=include$5[4],
     symbol$95=include$5[5],
     symbol$96=include$5[1],
     symbol$97=include$5[3],
     O=[0,symbol$92,symbol$93,symbol$94,symbol$95,symbol$96,symbol$97];
    function compare$34(c1,c2)
     {var _Cw_=caml_call1(_e_,c2),_Cx_=caml_call1(_e_,c1);
      return caml_call2(include$5[9],_Cx_,_Cw_)}
    function hash_fold_t$20(state,t)
     {return caml_call2(hash_fold_t$3,state,caml_call1(_e_,t))}
    function hash$8(t){return run(0,hash_fold_t$20,t)}
    var
     include$46=Make$1([0,compare$34,sexp_of_t$3]),
     symbol$98=include$46[1],
     symbol$99=include$46[2],
     symbol$100=include$46[3],
     symbol$101=include$46[4],
     symbol$102=include$46[5],
     symbol$103=include$46[6],
     equal$22=include$46[7],
     compare$35=include$46[8],
     min$16=include$46[9],
     max$16=include$46[10],
     ascending$13=include$46[11],
     descending$13=include$46[12],
     between$0=include$46[13],
     clamp_exn$0=include$46[14],
     clamp$0=include$46[15],
     comparator$2=include$46[16],
     symbol$104=include$5[1],
     symbol$105=include$5[2],
     symbol$106=include$5[3],
     symbol$107=include$5[4],
     symbol$108=include$5[5],
     symbol$109=include$5[6],
     ascending$14=include$5[7],
     descending$14=include$5[8],
     compare_char$0=include$5[9],
     equal_char$1=include$5[10],
     max$17=include$5[11],
     min$17=include$5[12],
     _bQ_=
      [0,
       hash_fold_t$20,
       hash$8,
       t_of_sexp$3,
       sexp_of_t$3,
       t_sexp_grammar$2,
       symbol$98,
       symbol$99,
       symbol$100,
       symbol$101,
       symbol$102,
       symbol$103,
       equal$22,
       compare$35,
       min$16,
       max$16,
       ascending$13,
       descending$13,
       between$0,
       clamp_exn$0,
       clamp$0,
       comparator$2],
     Base_Char=
      [0,
       all$13,
       t_sexp_grammar$2,
       _bD_,
       _bE_,
       _bF_,
       _bG_,
       _bH_,
       _bI_,
       symbol$109,
       symbol$105,
       symbol$107,
       symbol$108,
       symbol$104,
       symbol$106,
       equal_char$1,
       compare_char$0,
       min$17,
       max$17,
       ascending$14,
       descending$14,
       _bJ_,
       _bK_,
       _bL_,
       _bM_,
       pp$6,
       _bN_,
       invariant$11,
       O,
       to_int,
       of_int,
       of_int_exn,
       unsafe_of_int,
       _d_,
       _e_,
       _f_,
       is_digit,
       is_lowercase,
       is_uppercase,
       is_alpha,
       is_alphanum,
       is_print,
       is_whitespace,
       get_digit,
       get_digit_exn,
       is_hex_digit,
       is_hex_digit_lower,
       is_hex_digit_upper,
       get_hex_digit,
       get_hex_digit_exn,
       min_value,
       max_value,
       _bQ_];
    caml_register_global(1078,Base_Char,"Base__Char");
    var Enumerable=[0],Base_Ppx_enumerate_lib=[0,Enumerable];
    caml_register_global
     (1079,Base_Ppx_enumerate_lib,"Base__Ppx_enumerate_lib");
    function tr_create_map(target,replacement)
     {var tr_map=caml_create_bytes(256),i$3=0;
      for(;;)
       {caml_bytes_unsafe_set(tr_map,i$3,of_int_exn(i$3));
        var _Cv_=i$3 + 1 | 0;
        if(255 !== i$3){var i$3=_Cv_;continue}
        var
         _Co_=
          caml_call2
           (include$1[4],
            caml_ml_string_length(target),
            caml_ml_string_length(replacement))
          -
          1
          |
          0,
         _Cn_=0;
        if(_Co_ >= 0)
         {var i$2=_Cn_;
          for(;;)
           {var index$0=caml_string_unsafe_get(target,i$2);
            caml_bytes_unsafe_set
             (tr_map,index$0,caml_string_unsafe_get(replacement,i$2));
            var _Cu_=i$2 + 1 | 0;
            if(_Co_ !== i$2){var i$2=_Cu_;continue}
            break}}
        var
         last_replacement=
          caml_string_unsafe_get
           (replacement,caml_ml_string_length(replacement) - 1 | 0),
         _Cp_=
          caml_call2
           (include$1[4],
            caml_ml_string_length(target),
            caml_ml_string_length(replacement)),
         _Cq_=caml_ml_string_length(target) - 1 | 0;
        if(_Cq_ >= _Cp_)
         {var i$1=_Cp_;
          for(;;)
           {var index=caml_string_unsafe_get(target,i$1);
            caml_bytes_unsafe_set(tr_map,index,last_replacement);
            var _Ct_=i$1 + 1 | 0;
            if(_Cq_ !== i$1){var i$1=_Ct_;continue}
            break}}
        var first_target=caml_string_get(target,0);
        if
         (!
          caml_call2
           (symbol$106,
            caml_bytes_unsafe_get(tr_map,first_target),
            first_target))
         {var i=0;
          for(;;)
           {if(256 === i)
             var _Cs_=0;
            else
             {var _Cr_=of_int_exn(i);
              if
               (! caml_call2(symbol$106,caml_bytes_unsafe_get(tr_map,i),_Cr_))
               {var i$0=i + 1 | 0,i=i$0;continue}
              var _Cs_=1}
            if(! _Cs_)return 0;
            break}}
        return [0,unsafe_to_string(tr_map)]}}
    var Base_Bytes_tr=[0,tr_create_map];
    caml_register_global(1080,Base_Bytes_tr,"Base__Bytes_tr");
    function stage(_Cm_){return _Cm_}
    function unstage(_Cl_){return _Cl_}
    var Base_Staged=[0,stage,unstage];
    caml_register_global(1081,Base_Staged,"Base__Staged");
    function hash$9(x){return caml_call1(func$5,x)}
    var
     hashable$1=[0,hash$9,compare$17,sexp_of_t$2],
     include$47=_P_([0,compare$17,sexp_of_t$2]),
     comparator$3=include$47[1];
    function invariant$12(param){return 0}
    function sub$8(src,pos,len)
     {if(0 === pos && len === caml_ml_string_length(src))return src;
      check_pos_len_exn(pos,len,caml_ml_string_length(src));
      if(0 === len)return cst$14;
      var dst=caml_create_bytes(len);
      caml_blit_string(src,pos,dst,0,len);
      return unsafe_to_string(dst)}
    function subo$2(opt,len,src)
     {if(opt)var sth=opt[1],pos=sth;else var pos=0;
      if(len)
       var i=len[1],i$0=i;
      else
       var i$0=caml_ml_string_length(src) - pos | 0;
      return sub$8(src,pos,i$0)}
    function contains(opt,len,t,char$0)
     {if(opt)var sth=opt[1],pos$1=sth;else var pos$1=0;
      var
       total_length=caml_ml_string_length(t),
       len$0=value(len,total_length - pos$1 | 0);
      check_pos_len_exn(pos$1,len$0,total_length);
      var end=pos$1 + len$0 | 0,pos=pos$1;
      for(;;)
       {var _Ci_=pos < end?1:0;
        if(_Ci_)
         {var
           _Cj_=
            caml_call2(equal_char$1,caml_string_unsafe_get(t,pos),char$0);
          if(! _Cj_){var pos$0=pos + 1 | 0,pos=pos$0;continue}
          var _Ck_=_Cj_}
        else
         var _Ck_=_Ci_;
        return _Ck_}}
    function is_empty$3(t){return 0 === caml_ml_string_length(t)?1:0}
    function index_from_exn_internal(string,pos,len,not_found,char$0)
     {var pos$0=pos;
      for(;;)
       {if(len <= pos$0)throw not_found;
        if
         (caml_call2(equal_char$1,caml_string_unsafe_get(string,pos$0),char$0))
         return pos$0;
        var pos$1=pos$0 + 1 | 0,pos$0=pos$1}}
    function index_exn_internal(t,not_found,char$0)
     {return index_from_exn_internal
              (t,0,caml_ml_string_length(t),not_found,char$0)}
    var not_found$6=[0,Not_found_s,_bR_];
    function index_exn(t,char$0)
     {return index_exn_internal(t,not_found$6,char$0)}
    var not_found$7=[0,Not_found_s,_bS_];
    function index_from_exn(t,pos,char$0)
     {var len=caml_ml_string_length(t);
      if(0 <= pos && len >= pos)
       return index_from_exn_internal(t,pos,len,not_found$7,char$0);
      return caml_call1(invalid_arg$0,cst_String_index_from_exn)}
    function rindex_from_exn_internal(string,pos,len,not_found,char$0)
     {var pos$0=pos;
      for(;;)
       {if(0 > pos$0)throw not_found;
        if
         (caml_call2(equal_char$1,caml_string_unsafe_get(string,pos$0),char$0))
         return pos$0;
        var pos$1=pos$0 - 1 | 0,pos$0=pos$1}}
    function rindex_exn_internal(t,not_found,char$0)
     {var len=caml_ml_string_length(t);
      return rindex_from_exn_internal(t,len - 1 | 0,len,not_found,char$0)}
    var not_found$8=[0,Not_found_s,_bT_];
    function rindex_exn(t,char$0)
     {return rindex_exn_internal(t,not_found$8,char$0)}
    var not_found$9=[0,Not_found_s,_bU_];
    function rindex_from_exn(t,pos,char$0)
     {var len=caml_ml_string_length(t);
      if(-1 <= pos && len > pos)
       return rindex_from_exn_internal(t,pos,len,not_found$9,char$0);
      return caml_call1(invalid_arg$0,cst_String_rindex_from_exn)}
    function index(t,char$0)
     {try
       {var _Cg_=[0,index_exn(t,char$0)];return _Cg_}
      catch(_Ch_)
       {_Ch_ = caml_wrap_exception(_Ch_);
        if(_Ch_[1] !== Not_found_s && _Ch_ !== Caml$0[103])throw _Ch_;
        return 0}}
    function rindex(t,char$0)
     {try
       {var _Ce_=[0,rindex_exn(t,char$0)];return _Ce_}
      catch(_Cf_)
       {_Cf_ = caml_wrap_exception(_Cf_);
        if(_Cf_[1] !== Not_found_s && _Cf_ !== Caml$0[103])throw _Cf_;
        return 0}}
    function index_from(t,pos,char$0)
     {try
       {var _Cc_=[0,index_from_exn(t,pos,char$0)];return _Cc_}
      catch(_Cd_)
       {_Cd_ = caml_wrap_exception(_Cd_);
        if(_Cd_[1] !== Not_found_s && _Cd_ !== Caml$0[103])throw _Cd_;
        return 0}}
    function rindex_from(t,pos,char$0)
     {try
       {var _Ca_=[0,rindex_from_exn(t,pos,char$0)];return _Ca_}
      catch(_Cb_)
       {_Cb_ = caml_wrap_exception(_Cb_);
        if(_Cb_[1] !== Not_found_s && _Cb_ !== Caml$0[103])throw _Cb_;
        return 0}}
    function sexp_of_t$30(param)
     {var
       case_sensitive=param[2],
       pattern=param[1],
       _B$_=[0,[1,[0,_bV_,[0,caml_call1(sexp_of_t$1,case_sensitive),0]]],0];
      return [1,[0,[1,[0,_bW_,[0,caml_call1(sexp_of_t$2,pattern),0]]],_B$_]]}
    function pattern(t){return t[1]}
    function case_sensitive(t){return t[2]}
    function kmp_internal_loop
     (matched_chars,next_text_char,pattern,kmp_array,char_equal)
     {var matched_chars$0=[0,matched_chars];
      for(;;)
       {if
         (0
          <
          matched_chars$0[1]
          &&
          !
          caml_call2
           (char_equal,
            next_text_char,
            caml_string_unsafe_get(pattern,matched_chars$0[1])))
         {matched_chars$0[1] = kmp_array[1 + (matched_chars$0[1] - 1 | 0)];
          continue}
        if
         (caml_call2
           (char_equal,
            next_text_char,
            caml_string_unsafe_get(pattern,matched_chars$0[1])))
         matched_chars$0[1] = matched_chars$0[1] + 1 | 0;
        return matched_chars$0[1]}}
    function get_char_equal(case_sensitive)
     {return case_sensitive?equal_char$1:_bQ_[12]}
    function create$5(pattern,case_sensitive)
     {var n=caml_ml_string_length(pattern),kmp_array=caml_make_vect(n,-1);
      if(0 < n)
       {var char_equal=get_char_equal(case_sensitive);
        kmp_array[1] = 0;
        var matched_chars=[0,0],_B9_=n - 1 | 0,_B8_=1;
        if(_B9_ >= 1)
         {var i=_B8_;
          for(;;)
           {matched_chars[1]
            =
            kmp_internal_loop
             (matched_chars[1],
              caml_string_unsafe_get(pattern,i),
              pattern,
              kmp_array,
              char_equal);
            kmp_array[1 + i] = matched_chars[1];
            var _B__=i + 1 | 0;
            if(_B9_ !== i){var i=_B__;continue}
            break}}}
      return [0,pattern,case_sensitive,kmp_array]}
    function index_internal(opt,param)
     {if(opt)var sth=opt[1],pos=sth;else var pos=0;
      var kmp_array=param[3],case_sensitive=param[2],pattern=param[1];
      return function(text)
       {if
         (0
          <=
          pos
          &&
          (caml_ml_string_length(text) - caml_ml_string_length(pattern) | 0)
          >=
          pos)
         {var
           char_equal=get_char_equal(case_sensitive),
           j=[0,pos],
           matched_chars=[0,0],
           k=caml_ml_string_length(pattern),
           n=caml_ml_string_length(text);
          for(;;)
           {if(j[1] < n && matched_chars[1] < k)
             {var next_text_char=caml_string_unsafe_get(text,j[1]);
              matched_chars[1]
              =
              kmp_internal_loop
               (matched_chars[1],next_text_char,pattern,kmp_array,char_equal);
              j[1] = j[1] + 1 | 0;
              continue}
            return matched_chars[1] === k?j[1] - k | 0:-1}}
        return -1}}
    function matches(t,str)
     {return 0 <= caml_call1(index_internal(0,t),str)?1:0}
    function index$0(pos,t,in$0)
     {var p=caml_call1(index_internal(pos,t),in$0);return 0 <= p?[0,p]:0}
    function index_exn$0(pos,t,in$0)
     {var p=caml_call1(index_internal(pos,t),in$0);
      return 0 <= p
              ?p
              :raise_s
                (caml_call2
                  (message,
                   cst_Substring_not_found,
                   [0,[0,cst_substring,caml_call1(sexp_of_t$2,t[1])],0]))}
    function index_all(param,may_overlap,text)
     {var kmp_array=param[3],case_sensitive=param[2],pattern=param[1];
      if(0 === caml_ml_string_length(pattern))
       return init$1
               (1 + caml_ml_string_length(text) | 0,
                function(_B7_){return _B7_});
      var
       char_equal=get_char_equal(case_sensitive),
       matched_chars=[0,0],
       k=caml_ml_string_length(pattern),
       n=caml_ml_string_length(text),
       found=[0,0],
       _B5_=0;
      if(n >= 0)
       {var j=_B5_;
        for(;;)
         {if(matched_chars[1] === k)
           {found[1] = [0,j - k | 0,found[1]];
            matched_chars[1] = may_overlap?kmp_array[1 + (k - 1 | 0)]:0}
          if(j < n)
           {var next_text_char=caml_string_unsafe_get(text,j);
            matched_chars[1]
            =
            kmp_internal_loop
             (matched_chars[1],next_text_char,pattern,kmp_array,char_equal)}
          var _B6_=j + 1 | 0;
          if(n !== j){var j=_B6_;continue}
          break}}
      return rev(found[1])}
    function replace_first(pos,t,s,with$0)
     {var match=index$0(pos,t,s);
      if(! match)return s;
      var
       i=match[1],
       len_s=caml_ml_string_length(s),
       len_t=caml_ml_string_length(t[1]),
       len_with=caml_ml_string_length(with$0),
       dst=caml_create_bytes((len_s + len_with | 0) - len_t | 0);
      caml_call5(blit_string,s,0,dst,0,i);
      caml_call5(blit_string,with$0,0,dst,i,len_with);
      caml_call5
       (blit_string,
        s,
        i + len_t | 0,
        dst,
        i + len_with | 0,
        (len_s - i | 0) - len_t | 0);
      return unsafe_to_string(dst)}
    function replace_all(t,s,with$0)
     {var matches=index_all(t,0,s);
      if(! matches)return s;
      var
       len_s=caml_ml_string_length(s),
       len_t=caml_ml_string_length(t[1]),
       len_with=caml_ml_string_length(with$0),
       num_matches=caml_call1(length,matches),
       dst=
        caml_create_bytes
         (len_s + caml_mul(len_with - len_t | 0,num_matches) | 0),
       next_dst_pos=[0,0],
       next_src_pos=[0,0];
      iter$0
       (matches,
        function(i)
         {var len=i - next_src_pos[1] | 0;
          caml_call5(blit_string,s,next_src_pos[1],dst,next_dst_pos[1],len);
          caml_call5
           (blit_string,with$0,0,dst,next_dst_pos[1] + len | 0,len_with);
          next_dst_pos[1] = (next_dst_pos[1] + len | 0) + len_with | 0;
          next_src_pos[1] = (next_src_pos[1] + len | 0) + len_t | 0;
          return 0});
      caml_call5
       (blit_string,
        s,
        next_src_pos[1],
        dst,
        next_dst_pos[1],
        len_s - next_src_pos[1] | 0);
      return unsafe_to_string(dst)}
    function split_on(t,s)
     {var pattern_len=caml_ml_string_length(t[1]),matches=index_all(t,0,s);
      function _B4_(i,j)
       {return sub$8(s,i + pattern_len | 0,(j - i | 0) - pattern_len | 0)}
      return map2_exn
              ([0,- pattern_len | 0,matches],
               caml_call2(symbol$58,matches,[0,caml_ml_string_length(s),0]),
               _B4_)}
    function equal$23(a_002,b_003)
     {if(a_002 === b_003)return 1;
      var _B1_=caml_call2(equal_string$0,a_002[1],b_003[1]);
      if(_B1_)
       {var _B2_=caml_call2(equal_bool$0,a_002[2],b_003[2]);
        if(_B2_)
         return caml_call3(equal_array$0,equal_int$0,a_002[3],b_003[3]);
        var _B3_=_B2_}
      else
       var _B3_=_B1_;
      return _B3_}
    function sexp_of_t$31(param)
     {var
       kmp_array_011=param[3],
       case_sensitive_009=param[2],
       pattern_007=param[1],
       arg_012=caml_call2(sexp_of_array,sexp_of_t$4,kmp_array_011),
       bnds_006=[0,[1,[0,_bX_,[0,arg_012,0]]],0],
       arg_010=caml_call1(sexp_of_t$1,case_sensitive_009),
       bnds_006$0=[0,[1,[0,_bY_,[0,arg_010,0]]],bnds_006],
       arg_008=caml_call1(sexp_of_t$2,pattern_007),
       bnds_006$1=[0,[1,[0,_bZ_,[0,arg_008,0]]],bnds_006$0];
      return [1,bnds_006$1]}
    function representation(_B0_){return _B0_}
    var Private$2=[0,equal$23,sexp_of_t$31,representation];
    function substr_index_gen(case_sensitive,pos,t,pattern)
     {return index$0(pos,create$5(pattern,case_sensitive),t)}
    function substr_index_exn_gen(case_sensitive,pos,t,pattern)
     {return index_exn$0(pos,create$5(pattern,case_sensitive),t)}
    function substr_index_all_gen(case_sensitive,t,may_overlap,pattern)
     {return index_all(create$5(pattern,case_sensitive),may_overlap,t)}
    function substr_replace_first_gen(case_sensitive,pos,t,pattern)
     {var _BY_=create$5(pattern,case_sensitive);
      return function(_BZ_){return replace_first(pos,_BY_,t,_BZ_)}}
    function substr_replace_all_gen(case_sensitive,t,pattern)
     {var _BW_=create$5(pattern,case_sensitive);
      return function(_BX_){return replace_all(_BW_,t,_BX_)}}
    function is_substring_gen(case_sensitive,t,substring)
     {return is_some(substr_index_gen(case_sensitive,0,t,substring))}
    var _b0_=1;
    function substr_index(_BT_,_BU_,_BV_)
     {return substr_index_gen(_b0_,_BT_,_BU_,_BV_)}
    var _b1_=1;
    function substr_index_exn(_BQ_,_BR_,_BS_)
     {return substr_index_exn_gen(_b1_,_BQ_,_BR_,_BS_)}
    var _b2_=1;
    function substr_index_all(_BN_,_BO_,_BP_)
     {return substr_index_all_gen(_b2_,_BN_,_BO_,_BP_)}
    var _b3_=1;
    function substr_replace_first(_BK_,_BL_,_BM_)
     {return substr_replace_first_gen(_b3_,_BK_,_BL_,_BM_)}
    var _b4_=1;
    function substr_replace_all(_BI_,_BJ_)
     {return substr_replace_all_gen(_b4_,_BI_,_BJ_)}
    var _b5_=1;
    function is_substring(_BG_,_BH_){return is_substring_gen(_b5_,_BG_,_BH_)}
    function is_substring_at_gen(str,str_pos$1,sub,char_equal)
     {var
       str_len=caml_ml_string_length(str),
       sub_len=caml_ml_string_length(sub),
       _BD_=str_pos$1 < 0?1:0,
       _BE_=_BD_ || (str_len < str_pos$1?1:0);
      if(_BE_)caml_call3(invalid_argf(_b6_),str_pos$1,str_len,0);
      var _BF_=(str_pos$1 + sub_len | 0) <= str_len?1:0;
      if(! _BF_)return _BF_;
      var str_pos=str_pos$1,sub_pos=0;
      for(;;)
       {if(sub_pos === sub_len)return 1;
        if
         (!
          caml_call2
           (char_equal,
            caml_string_unsafe_get(str,str_pos),
            caml_string_unsafe_get(sub,sub_pos)))
         return 0;
        var
         sub_pos$0=sub_pos + 1 | 0,
         str_pos$0=str_pos + 1 | 0,
         str_pos=str_pos$0,
         sub_pos=sub_pos$0}}
    function is_suffix_gen(string,suffix,char_equal)
     {var
       string_len=caml_ml_string_length(string),
       suffix_len=caml_ml_string_length(suffix),
       _BC_=suffix_len <= string_len?1:0;
      return _BC_
              ?is_substring_at_gen
                (string,string_len - suffix_len | 0,suffix,char_equal)
              :_BC_}
    function is_prefix_gen(string,prefix,char_equal)
     {var
       string_len=caml_ml_string_length(string),
       prefix_len=caml_ml_string_length(prefix),
       _BB_=prefix_len <= string_len?1:0;
      return _BB_?is_substring_at_gen(string,0,prefix,char_equal):_BB_}
    function compare$36(string1,string2)
     {if(string1 === string2)return 0;
      var
       len2=caml_ml_string_length(string2),
       len1=caml_ml_string_length(string1),
       pos=0;
      for(;;)
       {if(pos === len1)return pos === len2?0:-1;
        if(pos === len2)return 1;
        var
         c2=caml_string_unsafe_get(string2,pos),
         c1=caml_string_unsafe_get(string1,pos),
         _BA_=caml_call1(_e_,c2),
         c=caml_call2(compare_char$0,caml_call1(_e_,c1),_BA_);
        if(0 !== c)return c;
        var pos$0=pos + 1 | 0,pos=pos$0}}
    function hash_fold_t$21(state,t)
     {var
       len=caml_ml_string_length(t),
       state$0=[0,caml_call2(hash_fold_t$4,state,len)],
       _Bx_=len - 1 | 0,
       _Bw_=0;
      if(_Bx_ >= 0)
       {var pos=_Bw_;
        for(;;)
         {var _By_=caml_call1(_e_,caml_string_unsafe_get(t,pos));
          state$0[1] = caml_call2(hash_fold_t$3,state$0[1],_By_);
          var _Bz_=pos + 1 | 0;
          if(_Bx_ !== pos){var pos=_Bz_;continue}
          break}}
      return state$0[1]}
    function hash$10(t){return run(0,hash_fold_t$21,t)}
    function is_suffix$0(s,suffix){return is_suffix_gen(s,suffix,_bQ_[12])}
    function is_prefix$0(s,prefix){return is_prefix_gen(s,prefix,_bQ_[12])}
    var _b7_=0;
    function substr_index$0(_Bt_,_Bu_,_Bv_)
     {return substr_index_gen(_b7_,_Bt_,_Bu_,_Bv_)}
    var _b8_=0;
    function substr_index_exn$0(_Bq_,_Br_,_Bs_)
     {return substr_index_exn_gen(_b8_,_Bq_,_Br_,_Bs_)}
    var _b9_=0;
    function substr_index_all$0(_Bn_,_Bo_,_Bp_)
     {return substr_index_all_gen(_b9_,_Bn_,_Bo_,_Bp_)}
    var _b__=0;
    function substr_replace_first$0(_Bk_,_Bl_,_Bm_)
     {return substr_replace_first_gen(_b__,_Bk_,_Bl_,_Bm_)}
    var _b$_=0;
    function substr_replace_all$0(_Bi_,_Bj_)
     {return substr_replace_all_gen(_b$_,_Bi_,_Bj_)}
    var _ca_=0;
    function is_substring$0(_Bg_,_Bh_)
     {return is_substring_gen(_ca_,_Bg_,_Bh_)}
    var _cb_=_bQ_[12];
    function is_substring_at(_Bd_)
     {return function(_Be_)
       {return function(_Bf_){return is_substring_at_gen(_Bd_,_Be_,_Bf_,_cb_)}}}
    var
     include$48=Make$1([0,compare$36,sexp_of_t$2]),
     symbol$110=include$48[1],
     symbol$111=include$48[2],
     symbol$112=include$48[3],
     symbol$113=include$48[4],
     symbol$114=include$48[5],
     symbol$115=include$48[6],
     equal$24=include$48[7],
     compare$37=include$48[8],
     min$18=include$48[9],
     max$18=include$48[10],
     ascending$15=include$48[11],
     descending$15=include$48[12],
     between$1=include$48[13],
     clamp_exn$1=include$48[14],
     clamp$1=include$48[15],
     comparator$4=include$48[16];
    function of_string$7(_Bc_){return _Bc_}
    function to_string$8(_Bb_){return _Bb_}
    function init$4(n,f)
     {if(n < 0)caml_call2(invalid_argf(_cc_),n,0);
      var t=caml_create_bytes(n),_A$_=n - 1 | 0,_A__=0;
      if(_A$_ >= 0)
       {var i=_A__;
        for(;;)
         {caml_bytes_set(t,i,caml_call1(f,i));
          var _Ba_=i + 1 | 0;
          if(_A$_ !== i){var i=_Ba_;continue}
          break}}
      return unsafe_to_string(t)}
    function to_list$5(s)
     {var i$1=caml_ml_string_length(s) - 1 | 0,acc=0,i=i$1;
      for(;;)
       {if(0 > i)return acc;
        var i$0=i - 1 | 0,acc$0=[0,caml_string_get(s,i),acc],acc=acc$0,i=i$0}}
    function to_list_rev$0(s)
     {var len=caml_ml_string_length(s),acc=0,i=0;
      for(;;)
       {if(i === len)return acc;
        var i$0=i + 1 | 0,acc$0=[0,caml_string_get(s,i),acc],acc=acc$0,i=i$0}}
    function rev$1(t)
     {var
       len=caml_ml_string_length(t),
       res=caml_create_bytes(len),
       _A8_=len - 1 | 0,
       _A7_=0;
      if(_A8_ >= 0)
       {var i=_A7_;
        for(;;)
         {caml_bytes_unsafe_set
           (res,i,caml_string_unsafe_get(t,(len - 1 | 0) - i | 0));
          var _A9_=i + 1 | 0;
          if(_A8_ !== i){var i=_A9_;continue}
          break}}
      return unsafe_to_string(res)}
    var not_found$10=[0,Not_found_s,_cd_];
    function lsplit2_exn(line,delim)
     {var
       pos=index_exn_internal(line,not_found$10,delim),
       _A6_=
        sub$8
         (line,pos + 1 | 0,(caml_ml_string_length(line) - pos | 0) - 1 | 0);
      return [0,sub$8(line,0,pos),_A6_]}
    var not_found$11=[0,Not_found_s,_ce_];
    function rsplit2_exn(line,delim)
     {var
       pos=rindex_exn_internal(line,not_found$11,delim),
       _A5_=
        sub$8
         (line,pos + 1 | 0,(caml_ml_string_length(line) - pos | 0) - 1 | 0);
      return [0,sub$8(line,0,pos),_A5_]}
    function lsplit2(line,on)
     {try
       {var _A3_=[0,lsplit2_exn(line,on)];return _A3_}
      catch(_A4_)
       {_A4_ = caml_wrap_exception(_A4_);
        if(_A4_[1] !== Not_found_s && _A4_ !== Caml$0[103])throw _A4_;
        return 0}}
    function rsplit2(line,on)
     {try
       {var _A1_=[0,rsplit2_exn(line,on)];return _A1_}
      catch(_A2_)
       {_A2_ = caml_wrap_exception(_A2_);
        if(_A2_[1] !== Not_found_s && _A2_ !== Caml$0[103])throw _A2_;
        return 0}}
    function char_list_mem(l,c)
     {var l$0=l;
      for(;;)
       {if(! l$0)return 0;
        var tl=l$0[2],hd=l$0[1],_A0_=caml_call2(equal_char$1,hd,c);
        if(_A0_)return _A0_;
        var l$0=tl}}
    function split_gen(str,on)
     {if(552554919 <= on[1])
       var l=on[2],is_delim=function(c){return char_list_mem(l,c)};
      else
       var
        c=on[2],
        is_delim=function(c$0){return caml_call2(equal_char$1,c$0,c)};
      var
       last_pos=caml_ml_string_length(str),
       pos$2=last_pos - 1 | 0,
       acc=0,
       last_pos$0=last_pos,
       pos=pos$2;
      for(;;)
       {if(-1 === pos)return [0,sub$8(str,0,last_pos$0),acc];
        if(is_delim(caml_string_get(str,pos)))
         {var
           pos1=pos + 1 | 0,
           sub_str=sub$8(str,pos1,last_pos$0 - pos1 | 0),
           pos$0=pos - 1 | 0,
           acc$0=[0,sub_str,acc],
           acc=acc$0,
           last_pos$0=pos,
           pos=pos$0;
          continue}
        var pos$1=pos - 1 | 0,pos=pos$1}}
    function split(str,on){return split_gen(str,[0,-1044422954,on])}
    function split_on_chars(str,chars)
     {return split_gen(str,[0,552554919,chars])}
    function back_up_at_newline(t,pos,eol)
     {var switch$0=0;
      if
       (0
        <
        pos[1]
        &&
        caml_call2(equal_char$1,caml_string_get(t,pos[1] - 1 | 0),13))
       {var _AZ_=2;switch$0 = 1}
      if(! switch$0)var _AZ_=1;
      pos[1] = pos[1] - _AZ_ | 0;
      eol[1] = pos[1] + 1 | 0;
      return 0}
    function split_lines(t)
     {var n=caml_ml_string_length(t);
      if(0 === n)return 0;
      var pos=[0,n - 1 | 0],eol=[0,n],ac=[0,0];
      if(caml_call2(equal_char$1,caml_string_get(t,pos[1]),10))
       back_up_at_newline(t,pos,eol);
      for(;;)
       {if(0 > pos[1]){var _AY_=ac[1];return [0,sub$8(t,0,eol[1]),_AY_]}
        if(caml_call2(symbol$106,caml_string_get(t,pos[1]),10))
         {decr(pos);continue}
        var start=pos[1] + 1 | 0,_AX_=ac[1];
        ac[1] = [0,sub$8(t,start,eol[1] - start | 0),_AX_];
        back_up_at_newline(t,pos,eol)}}
    function is_suffix$1(s,suffix)
     {return is_suffix_gen(s,suffix,equal_char$1)}
    function is_prefix$1(s,prefix)
     {return is_prefix_gen(s,prefix,equal_char$1)}
    function is_substring_at$0(s,pos,substring)
     {return is_substring_at_gen(s,pos,substring,equal_char$1)}
    function wrap_sub_n(t,n,name,pos,len,on_error)
     {if(0 > n)
       return caml_call1
               (invalid_arg$0,
                caml_call2(symbol$59,name,cst_expecting_nonnegative_argu));
      try {var _AV_=sub$8(t,pos,len);return _AV_}catch(_AW_){return on_error}}
    function drop_prefix(t,n)
     {return wrap_sub_n
              (t,n,cst_drop_prefix,n,caml_ml_string_length(t) - n | 0,cst$15)}
    function drop_suffix(t,n)
     {return wrap_sub_n
              (t,n,cst_drop_suffix,0,caml_ml_string_length(t) - n | 0,cst$16)}
    function prefix(t,n){return wrap_sub_n(t,n,cst_prefix,0,n,t)}
    function suffix(t,n)
     {return wrap_sub_n(t,n,cst_suffix,caml_ml_string_length(t) - n | 0,n,t)}
    function lfindi(opt,t,f)
     {if(opt)var sth=opt[1],pos=sth;else var pos=0;
      var n=caml_ml_string_length(t),i=pos;
      for(;;)
       {if(i === n)return 0;
        if(caml_call2(f,i,caml_string_get(t,i)))return [0,i];
        var i$0=i + 1 | 0,i=i$0}}
    function find$5(t,f)
     {var match=lfindi(0,t,function(param,c){return caml_call1(f,c)});
      if(! match)return 0;
      var i=match[1];
      return [0,caml_string_get(t,i)]}
    function find_map$4(t,f)
     {var n=caml_ml_string_length(t),i=0;
      for(;;)
       {if(i === n)return 0;
        var res=caml_call1(f,caml_string_get(t,i));
        if(res)return res;
        var i$0=i + 1 | 0,i=i$0}}
    function rfindi(pos,t,f)
     {if(pos)
       var pos$0=pos[1],pos$1=pos$0;
      else
       var pos$1=caml_ml_string_length(t) - 1 | 0;
      var i=pos$1;
      for(;;)
       {if(0 > i)return 0;
        if(caml_call2(f,i,caml_string_get(t,i)))return [0,i];
        var i$0=i - 1 | 0,i=i$0}}
    function last_non_drop(drop,t)
     {return rfindi(0,t,function(param,c){return 1 - caml_call1(drop,c)})}
    function rstrip(opt,t)
     {if(opt)var sth=opt[1],drop=sth;else var drop=is_whitespace;
      var match=last_non_drop(drop,t);
      if(! match)return cst$17;
      var i=match[1];
      return i === (caml_ml_string_length(t) - 1 | 0)?t:prefix(t,i + 1 | 0)}
    function first_non_drop(drop,t)
     {return lfindi(0,t,function(param,c){return 1 - caml_call1(drop,c)})}
    function lstrip(opt,t)
     {if(opt)var sth=opt[1],drop=sth;else var drop=is_whitespace;
      var match=first_non_drop(drop,t);
      if(! match)return cst$18;
      var _AU_=match[1];
      return 0 === _AU_?t:drop_prefix(t,_AU_)}
    function strip(opt,t)
     {if(opt)var sth=opt[1],drop=sth;else var drop=is_whitespace;
      var length=caml_ml_string_length(t);
      if(0 !== length)
       {var switch$0=0;
        if
         (caml_call1(drop,caml_string_get(t,0))
          ||
          caml_call1(drop,caml_string_get(t,length - 1 | 0)))
         switch$0 = 1;
        if(switch$0)
         {var match=first_non_drop(drop,t);
          if(! match)return cst$19;
          var first=match[1],match$0=last_non_drop(drop,t);
          if(! match$0)throw [0,Assert_failure$0,_cf_];
          var last=match$0[1];
          return sub$8(t,first,(last - first | 0) + 1 | 0)}}
      return t}
    function mapi$4(t,f)
     {var
       l=caml_ml_string_length(t),
       t$0=caml_create_bytes(l),
       _AS_=l - 1 | 0,
       _AR_=0;
      if(_AS_ >= 0)
       {var i=_AR_;
        for(;;)
         {caml_bytes_unsafe_set(t$0,i,caml_call2(f,i,caml_string_get(t,i)));
          var _AT_=i + 1 | 0;
          if(_AS_ !== i){var i=_AT_;continue}
          break}}
      return unsafe_to_string(t$0)}
    function map$23(t,f)
     {var
       l=caml_ml_string_length(t),
       t$0=caml_create_bytes(l),
       _AP_=l - 1 | 0,
       _AO_=0;
      if(_AP_ >= 0)
       {var i=_AO_;
        for(;;)
         {caml_bytes_unsafe_set(t$0,i,caml_call1(f,caml_string_get(t,i)));
          var _AQ_=i + 1 | 0;
          if(_AP_ !== i){var i=_AQ_;continue}
          break}}
      return unsafe_to_string(t$0)}
    function to_array$4(s)
     {return caml_call2
              (init,
               caml_ml_string_length(s),
               function(i){return caml_string_get(s,i)})}
    function exists$5(s,f)
     {var len=caml_ml_string_length(s),i=0;
      for(;;)
       {var _AL_=i < len?1:0;
        if(_AL_)
         {var _AM_=caml_call1(f,caml_string_get(s,i));
          if(! _AM_){var i$0=i + 1 | 0,i=i$0;continue}
          var _AN_=_AM_}
        else
         var _AN_=_AL_;
        return _AN_}}
    function for_all$5(s,f)
     {var len=caml_ml_string_length(s),i=0;
      for(;;)
       {var _AI_=i === len?1:0;
        if(_AI_)
         var _AJ_=_AI_;
        else
         {var _AK_=caml_call1(f,caml_string_get(s,i));
          if(_AK_){var i$0=i + 1 | 0,i=i$0;continue}
          var _AJ_=_AK_}
        return _AJ_}}
    function fold$3(t,init,f)
     {var len=caml_ml_string_length(t),i=0,ac=init;
      for(;;)
       {if(i === len)return ac;
        var
         ac$0=caml_call2(f,ac,caml_string_get(t,i)),
         i$0=i + 1 | 0,
         i=i$0,
         ac=ac$0}}
    function foldi$4(t,init,f)
     {var len=caml_ml_string_length(t),i=0,ac=init;
      for(;;)
       {if(i === len)return ac;
        var
         ac$0=caml_call3(f,i,ac,caml_string_get(t,i)),
         i$0=i + 1 | 0,
         i=i$0,
         ac=ac$0}}
    function iteri$4(t,f)
     {var _AG_=caml_ml_string_length(t) - 1 | 0,_AF_=0;
      if(_AG_ >= 0)
       {var i=_AF_;
        for(;;)
         {caml_call2(f,i,caml_string_unsafe_get(t,i));
          var _AH_=i + 1 | 0;
          if(_AG_ !== i){var i=_AH_;continue}
          break}}
      return 0}
    function count$4(t,f){return count(fold$3,t,f)}
    function sum$4(m,t,f){return caml_call2(sum(fold$3,m),t,f)}
    function min_elt$5(t)
     {return function(_AE_){return min_elt(fold$3,t,_AE_)}}
    function max_elt$5(t)
     {return function(_AD_){return max_elt(fold$3,t,_AD_)}}
    function fold_result$4(t,init,f){return fold_result(fold$3,init,f,t)}
    function fold_until$4(t,init,f)
     {return function(_AC_){return fold_until(fold$3,init,f,_AC_,t)}}
    function find_mapi$3(t,f){return find_mapi$0(iteri$4,t,f)}
    function findi$3(t,f){return findi$0(iteri$4,t,f)}
    function counti$3(t,f){return counti$0(foldi$4,t,f)}
    function for_alli$3(t,f){return for_alli$0(iteri$4,t,f)}
    function existsi$3(t,f){return existsi$0(iteri$4,t,f)}
    function mem$4(t,c)
     {var len=caml_ml_string_length(t),i=0;
      for(;;)
       {var _Az_=i < len?1:0;
        if(_Az_)
         {var _AA_=caml_call2(equal_char$1,c,caml_string_unsafe_get(t,i));
          if(! _AA_){var i$0=i + 1 | 0,i=i$0;continue}
          var _AB_=_AA_}
        else
         var _AB_=_Az_;
        return _AB_}}
    function tr(target,replacement,s)
     {return caml_call2(equal_char$1,target,replacement)
              ?s
              :mem$4(s,target)
                ?map$23
                  (s,
                   function(c)
                    {return caml_call2(equal_char$1,c,target)?replacement:c})
                :s}
    function tr_multi(target,replacement)
     {if(is_empty$3(target))return function(_Ay_){return _Ay_};
      if(is_empty$3(replacement))
       return caml_call1(invalid_arg$0,cst_tr_multi_replacement_is_em);
      var match=tr_create_map(target,replacement);
      if(! match)return function(_Ax_){return _Ax_};
      var tr_map=match[1];
      return function(s)
       {return exists$5
                 (s,
                  function(c)
                   {return caml_call2
                            (symbol$106,c,caml_string_unsafe_get(tr_map,c))})
                ?map$23
                  (s,function(c){return caml_string_unsafe_get(tr_map,c)})
                :s}}
    function concat_array(sep,ar){return concat$0(sep,caml_call1(to_list,ar))}
    function concat_map$1(sep,s,f)
     {return concat_array(sep,map(to_array$4(s),f))}
    function filter$3(t,f)
     {var n=caml_ml_string_length(t),i=[0,0];
      for(;;)
       {if(i[1] < n && caml_call1(f,caml_string_get(t,i[1])))
         {incr(i);continue}
        if(i[1] === n)return t;
        var out=caml_create_bytes(n - 1 | 0);
        caml_call5(blit_string,t,0,out,0,i[1]);
        var out_pos=[0,i[1]];
        incr(i);
        for(;;)
         {if(i[1] >= n)
           {var out$0=unsafe_to_string(out);
            return out_pos[1] === (n - 1 | 0)?out$0:sub$8(out$0,0,out_pos[1])}
          var c=caml_string_get(t,i[1]);
          if(caml_call1(f,c)){caml_bytes_set(out,out_pos[1],c);incr(out_pos)}
          incr(i)}}}
    function filteri$2(t,f)
     {var n=caml_ml_string_length(t),i=[0,0];
      for(;;)
       {if(i[1] < n)
         {var _Aw_=caml_string_get(t,i[1]);
          if(caml_call2(f,i[1],_Aw_)){incr(i);continue}}
        if(i[1] === n)return t;
        var out=caml_create_bytes(n - 1 | 0);
        caml_call5(blit_string,t,0,out,0,i[1]);
        var out_pos=[0,i[1]];
        incr(i);
        for(;;)
         {if(i[1] >= n)
           {var out$0=unsafe_to_string(out);
            return out_pos[1] === (n - 1 | 0)?out$0:sub$8(out$0,0,out_pos[1])}
          var c=caml_string_get(t,i[1]);
          if(caml_call2(f,i[1],c))
           {caml_bytes_set(out,out_pos[1],c);incr(out_pos)}
          incr(i)}}}
    function chop_prefix(s,prefix)
     {return is_prefix$1(s,prefix)
              ?[0,drop_prefix(s,caml_ml_string_length(prefix))]
              :0}
    function chop_prefix_if_exists(s,prefix)
     {return is_prefix$1(s,prefix)
              ?drop_prefix(s,caml_ml_string_length(prefix))
              :s}
    function chop_prefix_exn(s,prefix)
     {var match=chop_prefix(s,prefix);
      if(! match)return caml_call3(invalid_argf(_cg_),s,prefix,0);
      var str=match[1];
      return str}
    function chop_suffix(s,suffix)
     {return is_suffix$1(s,suffix)
              ?[0,drop_suffix(s,caml_ml_string_length(suffix))]
              :0}
    function chop_suffix_if_exists(s,suffix)
     {return is_suffix$1(s,suffix)
              ?drop_suffix(s,caml_ml_string_length(suffix))
              :s}
    function chop_suffix_exn(s,suffix)
     {var match=chop_suffix(s,suffix);
      if(! match)return caml_call3(invalid_argf(_ch_),s,suffix,0);
      var str=match[1];
      return str}
    function shorter(a,b)
     {return caml_ml_string_length(a) <= caml_ml_string_length(b)?a:b}
    function shortest(list)
     {if(! list)return cst$20;
      var rest=list[2],first=list[1];
      return fold_left(rest,first,shorter)}
    function pos_from_left(param,i){return i}
    function pos_from_right(t,i)
     {return (caml_ml_string_length(t) - i | 0) - 1 | 0}
    function common_generic2_length_loop(a,b,get_pos,max_len,len_so_far)
     {var len_so_far$0=len_so_far;
      for(;;)
       {if(max_len <= len_so_far$0)return max_len;
        var _Av_=caml_string_unsafe_get(b,caml_call2(get_pos,b,len_so_far$0));
        if
         (!
          caml_call2
           (equal_char$1,
            caml_string_unsafe_get(a,caml_call2(get_pos,a,len_so_far$0)),
            _Av_))
         return len_so_far$0;
        var len_so_far$1=len_so_far$0 + 1 | 0,len_so_far$0=len_so_far$1}}
    function common_generic2_length(a,b,get_pos)
     {var
       max_len=
        caml_call2(min$2,caml_ml_string_length(a),caml_ml_string_length(b));
      return common_generic2_length_loop(a,b,get_pos,max_len,0)}
    function common_generic_length_loop(first,list,get_pos,max_len)
     {var first$0=first,list$0=list,max_len$0=max_len;
      for(;;)
       {if(! list$0)return max_len$0;
        var
         rest=list$0[2],
         second=list$0[1],
         max_len$1=
          common_generic2_length_loop(first$0,second,get_pos,max_len$0,0),
         first$0=second,
         list$0=rest,
         max_len$0=max_len$1}}
    function common_generic_length(list,get_pos)
     {if(! list)return 0;
      var
       rest=list[2],
       first=list[1],
       max_len=caml_ml_string_length(shortest(list));
      return common_generic_length_loop(first,rest,get_pos,max_len)}
    function common_generic2(a,b,get_pos,take)
     {var len=common_generic2_length(a,b,get_pos);
      return caml_call2(take,shorter(a,b),len)}
    function common_generic(list,get_pos,take)
     {if(! list)return cst$22;
      var
       rest=list[2],
       first=list[1],
       s=shortest(list),
       max_len=caml_ml_string_length(s);
      if(0 === max_len)return cst$21;
      var len=common_generic_length_loop(first,rest,get_pos,max_len);
      return caml_call2(take,s,len)}
    function common_prefix(list)
     {return common_generic(list,pos_from_left,prefix)}
    function common_suffix(list)
     {return common_generic(list,pos_from_right,suffix)}
    function common_prefix2(a,b)
     {return common_generic2(a,b,pos_from_left,prefix)}
    function common_suffix2(a,b)
     {return common_generic2(a,b,pos_from_right,suffix)}
    function common_prefix_length(list)
     {return common_generic_length(list,pos_from_left)}
    function common_suffix_length(list)
     {return common_generic_length(list,pos_from_right)}
    function common_prefix2_length(a,b)
     {return common_generic2_length(a,b,pos_from_left)}
    function common_suffix2_length(a,b)
     {return common_generic2_length(a,b,pos_from_right)}
    function pp$7(ppf,string)
     {return caml_call3(Stdlib_Format[129],ppf,_ci_,string)}
    function of_char$0(c){return caml_call2(make$1,1,c)}
    function of_char_list(l)
     {var t=caml_create_bytes(caml_call1(length,l));
      iteri$0(l,function(i,c){return caml_bytes_set(t,i,c)});
      return unsafe_to_string(t)}
    function build_and_validate_escapeworth(escapeworthy_map,escape_char,func)
     {var
       escapeworthy_map$0=
        caml_call3(_aE_[7],escapeworthy_map,equal_char$1,escape_char)
         ?escapeworthy_map
         :[0,[0,escape_char,escape_char],escapeworthy_map],
       arr=caml_make_vect(256,-1),
       vals=caml_make_vect(256,0),
       param=escapeworthy_map$0;
      for(;;)
       {if(! param)return [0,arr];
        var l=param[2],match=param[1],c_to=match[2],c_from=match[1];
        if(919809722 <= func)var v=c_from,k=c_to;else var v=c_to,k=c_from;
        if
         (-1
          ===
          caml_check_bound(arr,k)[1 + k]
          &&
          !
          caml_check_bound(vals,v)[1 + v])
         {caml_check_bound(arr,k)[1 + k] = v;
          caml_check_bound(vals,v)[1 + v] = 1;
          var param=l;
          continue}
        var
         _At_=
          [0,
           [0,
            cst_escapeworthy_map,
            caml_call2
             (sexp_of_t$10,
              caml_call2(sexp_of_pair,sexp_of_t$3,sexp_of_t$3),
              escapeworthy_map$0)],
           0],
         _Au_=[0,[0,cst_c_to,caml_call1(sexp_of_t$3,c_to)],_At_];
        return error_s
                (caml_call2
                  (message,
                   cst_escapeworthy_map_not_one_t,
                   [0,[0,cst_c_from,caml_call1(sexp_of_t$3,c_from)],_Au_]))}}
    function escape_gen(escapeworthy_map,escape_char)
     {var
       x=
        build_and_validate_escapeworth(escapeworthy_map,escape_char,258914209);
      if(0 !== x[0])return x;
      var escapeworthy=x[1];
      return [0,
              function(src)
               {var
                 to_escape_len=[0,0],
                 param=
                  foldi$4
                   (src,
                    0,
                    function(i,acc,c)
                     {var n=caml_check_bound(escapeworthy,c)[1 + c];
                      return -1 === n?acc:(incr(to_escape_len),[0,[0,i,n],acc])});
                if(! param)return src;
                var
                 last_idx=caml_ml_string_length(src),
                 last_dst_pos=last_idx + to_escape_len[1] | 0,
                 dst=caml_create_bytes(last_dst_pos),
                 last_idx$0=last_idx,
                 last_dst_pos$0=last_dst_pos,
                 param$0=param;
                for(;;)
                 {if(param$0)
                   {var
                     to_escape=param$0[2],
                     match=param$0[1],
                     escaped_char=match[2],
                     idx=match[1],
                     len=(last_idx$0 - idx | 0) - 1 | 0,
                     dst_pos=last_dst_pos$0 - len | 0;
                    caml_call5(blit_string,src,idx + 1 | 0,dst,dst_pos,len);
                    var last_dst_pos$1=dst_pos - 2 | 0;
                    caml_bytes_set(dst,last_dst_pos$1,escape_char);
                    caml_bytes_set(dst,last_dst_pos$1 + 1 | 0,escaped_char);
                    var
                     last_idx$0=idx,
                     last_dst_pos$0=last_dst_pos$1,
                     param$0=to_escape;
                    continue}
                  caml_call5(blit_string,src,0,dst,0,last_idx$0);
                  return unsafe_to_string(dst)}}]}
    function escape_gen_exn(escapeworthy_map,escape_char)
     {return ok_exn$0(escape_gen(escapeworthy_map,escape_char))}
    function escape(escapeworthy,escape_char)
     {var
       _As_=dedup_and_sort(escapeworthy,compare_char$0),
       escapeworthy_map=map$9(_As_,function(c){return [0,c,c]});
      return escape_gen_exn(escapeworthy_map,escape_char)}
    function unescape_gen(escapeworthy_map,escape_char)
     {var
       x=
        build_and_validate_escapeworth(escapeworthy_map,escape_char,919809722);
      if(0 !== x[0])return x;
      var escapeworthy=x[1];
      return [0,
              function(src)
               {var i=0,status=-512962225,acc=0;
                for(;;)
                 {if(caml_ml_string_length(src) > i)
                   {var
                     status$0=
                      -512962225 <= status
                       ?caml_call2(equal_char$1,caml_string_get(src,i),escape_char)
                         ?-767030498
                         :-512962225
                       :-244189789,
                     acc$0=-512962225 <= status$0?acc:[0,i,acc],
                     i$0=i + 1 | 0,
                     i=i$0,
                     status=status$0,
                     acc=acc$0;
                    continue}
                  if(! acc)return src;
                  var
                   to_unescape=acc[2],
                   idx=acc[1],
                   dst=
                    caml_create_bytes
                     (caml_ml_string_length(src) - caml_call1(length,acc) | 0),
                   loop=
                    function(last_idx,last_dst_pos,param)
                     {var
                       last_idx$0=last_idx,
                       last_dst_pos$0=last_dst_pos,
                       param$0=param;
                      for(;;)
                       {if(! param$0)
                         return caml_call5(blit_string,src,0,dst,0,last_idx$0);
                        var
                         to_unescape=param$0[2],
                         idx=param$0[1],
                         len=(last_idx$0 - idx | 0) - 2 | 0,
                         dst_pos=last_dst_pos$0 - len | 0;
                        caml_call5(blit_string,src,idx + 2 | 0,dst,dst_pos,len);
                        var
                         dst_pos$0=dst_pos - 1 | 0,
                         _Aq_=caml_string_get(src,idx + 1 | 0),
                         n=caml_check_bound(escapeworthy,_Aq_)[1 + _Aq_],
                         _Ar_=-1 === n?caml_string_get(src,idx + 1 | 0):n;
                        caml_bytes_set(dst,dst_pos$0,_Ar_);
                        var
                         last_idx$0=idx,
                         last_dst_pos$0=dst_pos$0,
                         param$0=to_unescape}};
                  if(idx < (caml_ml_string_length(src) - 1 | 0))
                   loop
                    (caml_ml_string_length(src),caml_ml_bytes_length(dst),acc);
                  else
                   loop
                    (caml_ml_string_length(src) - 1 | 0,
                     caml_ml_bytes_length(dst),
                     to_unescape);
                  return unsafe_to_string(dst)}}]}
    function unescape_gen_exn(escapeworthy_map,escape_char)
     {return ok_exn$0(unescape_gen(escapeworthy_map,escape_char))}
    function unescape(escape_char){return unescape_gen_exn(0,escape_char)}
    function preceding_escape_chars(str,escape_char,pos)
     {var p$1=pos - 1 | 0,p=p$1,cnt=0;
      for(;;)
       {if
         (0
          <=
          p
          &&
          !
          caml_call2(symbol$106,caml_string_get(str,p),escape_char))
         {var cnt$0=cnt + 1 | 0,p$0=p - 1 | 0,p=p$0,cnt=cnt$0;continue}
        return cnt}}
    function update_escape_status(str,escape_char,i,param)
     {return -512962225 <= param
              ?caml_call2(equal_char$1,caml_string_get(str,i),escape_char)
                ?-767030498
                :-512962225
              :-244189789}
    function escape_status(str,escape_char,pos)
     {var
       odd=1 === (preceding_escape_chars(str,escape_char,pos) % 2 | 0)?1:0,
       match=caml_call2(equal_char$1,caml_string_get(str,pos),escape_char);
      return odd?-244189789:match?-767030498:-512962225}
    function check_bound(str,pos,function_name)
     {var
       _Ao_=caml_ml_string_length(str) <= pos?1:0,
       _Ap_=_Ao_ || (pos < 0?1:0);
      return _Ap_?caml_call2(invalid_argf(_cj_),function_name,0):_Ap_}
    function is_char_escaping(str,escape_char,pos)
     {check_bound(str,pos,cst_is_char_escaping);
      var match=escape_status(str,escape_char,pos);
      return -512962225 <= match?0:1}
    function is_char_escaped(str,escape_char,pos)
     {check_bound(str,pos,cst_is_char_escaped);
      var match=escape_status(str,escape_char,pos);
      return -244189789 <= match?1:0}
    function is_char_literal(str,escape_char,pos)
     {check_bound(str,pos,cst_is_char_literal);
      var match=escape_status(str,escape_char,pos);
      return -512962225 === match?1:0}
    function index_from$0(str,escape_char,pos,char$0)
     {check_bound(str,pos,cst_index_from);
      var status$1=escape_status(str,escape_char,pos),i=pos,status=status$1;
      for(;;)
       {if(pos <= i)
         {var _An_=-512962225 === status?1:0;
          if(_An_ && caml_call2(equal_char$1,caml_string_get(str,i),char$0))
           return [0,i]}
        var i$0=i + 1 | 0;
        if(caml_ml_string_length(str) <= i$0)return 0;
        var
         status$0=update_escape_status(str,escape_char,i$0,status),
         i=i$0,
         status=status$0}}
    function index_from_exn$0(str,escape_char,pos,char$0)
     {var match=index_from$0(str,escape_char,pos,char$0);
      if(match){var pos$0=match[1];return pos$0}
      var
       _Ak_=[0,[0,cst_char$0,caml_call1(sexp_of_t$3,char$0)],0],
       _Al_=[0,[0,cst_pos$1,caml_call1(sexp_of_t$4,pos)],_Ak_],
       _Am_=[0,[0,cst_escape_char,caml_call1(sexp_of_t$3,escape_char)],_Al_];
      return raise_s
              (caml_call2
                (message,
                 cst_index_from_exn_not_found,
                 [0,[0,cst_str,caml_call1(sexp_of_t$2,str)],_Am_]))}
    function index$1(str,escape_char,char$0)
     {return index_from$0(str,escape_char,0,char$0)}
    function index_exn$1(str,escape_char,char$0)
     {return index_from_exn$0(str,escape_char,0,char$0)}
    function rindex_from$0(str,escape_char,pos,char$0)
     {check_bound(str,pos,cst_rindex_from);
      if(caml_call2(equal_char$1,char$0,escape_char))return 0;
      var pos$0=pos;
      for(;;)
       {if(0 > pos$0)return 0;
        var escape_chars=preceding_escape_chars(str,escape_char,pos$0);
        if
         (0
          ===
          (escape_chars % 2 | 0)
          &&
          caml_call2(equal_char$1,caml_string_get(str,pos$0),char$0))
         return [0,pos$0];
        var pos$1=(pos$0 - escape_chars | 0) - 1 | 0,pos$0=pos$1}}
    function rindex_from_exn$0(str,escape_char,pos,char$0)
     {var match=rindex_from$0(str,escape_char,pos,char$0);
      if(match){var pos$0=match[1];return pos$0}
      var
       _Ah_=[0,[0,cst_char$1,caml_call1(sexp_of_t$3,char$0)],0],
       _Ai_=[0,[0,cst_pos$2,caml_call1(sexp_of_t$4,pos)],_Ah_],
       _Aj_=[0,[0,cst_escape_char$0,caml_call1(sexp_of_t$3,escape_char)],_Ai_];
      return raise_s
              (caml_call2
                (message,
                 cst_rindex_from_exn_not_found,
                 [0,[0,cst_str$0,caml_call1(sexp_of_t$2,str)],_Aj_]))}
    function rindex$0(str,escape_char,char$0)
     {return is_empty$3(str)
              ?0
              :rindex_from$0
                (str,escape_char,caml_ml_string_length(str) - 1 | 0,char$0)}
    function rindex_exn$0(str,escape_char,char$0)
     {return rindex_from_exn$0
              (str,escape_char,caml_ml_string_length(str) - 1 | 0,char$0)}
    function split_gen$0(str,escape_char,on)
     {if(552554919 <= on[1])
       var l=on[2],is_delim=function(c){return char_list_mem(l,c)};
      else
       var
        c=on[2],
        is_delim=function(c$0){return caml_call2(equal_char$1,c$0,c)};
      var
       len=caml_ml_string_length(str),
       acc=0,
       status=-512962225,
       last_pos=0,
       pos=0;
      for(;;)
       {if(pos === len)
         return rev([0,sub$8(str,last_pos,len - last_pos | 0),acc]);
        var
         status$0=update_escape_status(str,escape_char,pos,status),
         _Ag_=-512962225 === status$0?1:0;
        if(_Ag_ && is_delim(caml_string_get(str,pos)))
         {var
           sub_str=sub$8(str,last_pos,pos - last_pos | 0),
           pos$0=pos + 1 | 0,
           last_pos$0=pos + 1 | 0,
           acc$0=[0,sub_str,acc],
           acc=acc$0,
           status=status$0,
           last_pos=last_pos$0,
           pos=pos$0;
          continue}
        var pos$1=pos + 1 | 0,status=status$0,pos=pos$1}}
    function split$0(str,on)
     {var _Ae_=[0,-1044422954,on];
      return function(_Af_){return split_gen$0(str,_Af_,_Ae_)}}
    function split_on_chars$0(str,chars)
     {var _Ac_=[0,552554919,chars];
      return function(_Ad_){return split_gen$0(str,_Ad_,_Ac_)}}
    function split_at(str,pos)
     {var
       _Ab_=
        sub$8(str,pos + 1 | 0,(caml_ml_string_length(str) - pos | 0) - 1 | 0);
      return [0,sub$8(str,0,pos),_Ab_]}
    function lsplit2$0(str,on,escape_char)
     {function _Aa_(x){return split_at(str,x)}
      return caml_call2(map$16,index$1(str,escape_char,on),_Aa_)}
    function rsplit2$0(str,on,escape_char)
     {function _z$_(x){return split_at(str,x)}
      return caml_call2(map$16,rindex$0(str,escape_char,on),_z$_)}
    function lsplit2_exn$0(str,on,escape_char)
     {return split_at(str,index_exn$1(str,escape_char,on))}
    function rsplit2_exn$0(str,on,escape_char)
     {return split_at(str,rindex_exn$0(str,escape_char,on))}
    function last_non_drop_literal(drop,escape_char,t)
     {return rfindi
              (0,
               t,
               function(i,c)
                {var _z8_=1 - caml_call1(drop,c);
                 if(_z8_)
                  var _z9_=_z8_;
                 else
                  {var _z__=is_char_escaping(t,escape_char,i);
                   if(! _z__)return is_char_escaped(t,escape_char,i);
                   var _z9_=_z__}
                 return _z9_})}
    function first_non_drop_literal(drop,escape_char,t)
     {return lfindi
              (0,
               t,
               function(i,c)
                {var _z5_=1 - caml_call1(drop,c);
                 if(_z5_)
                  var _z6_=_z5_;
                 else
                  {var _z7_=is_char_escaping(t,escape_char,i);
                   if(! _z7_)return is_char_escaped(t,escape_char,i);
                   var _z6_=_z7_}
                 return _z6_})}
    function rstrip_literal(opt,t,escape_char)
     {if(opt)var sth=opt[1],drop=sth;else var drop=is_whitespace;
      var match=last_non_drop_literal(drop,escape_char,t);
      if(! match)return cst$23;
      var i=match[1];
      return i === (caml_ml_string_length(t) - 1 | 0)?t:prefix(t,i + 1 | 0)}
    function lstrip_literal(opt,t,escape_char)
     {if(opt)var sth=opt[1],drop=sth;else var drop=is_whitespace;
      var match=first_non_drop_literal(drop,escape_char,t);
      if(! match)return cst$24;
      var _z4_=match[1];
      return 0 === _z4_?t:drop_prefix(t,_z4_)}
    function strip_literal(opt,t,escape_char)
     {if(opt)var sth=opt[1],drop=sth;else var drop=is_whitespace;
      var length=caml_ml_string_length(t);
      if(0 !== length)
       {var switch$0=0;
        if
         (caml_call1(drop,caml_string_get(t,0))
          ||
          caml_call1(drop,caml_string_get(t,length - 1 | 0)))
         switch$0 = 1;
        if(switch$0)
         {var match=first_non_drop_literal(drop,escape_char,t);
          if(! match)return cst$25;
          var
           first=match[1],
           match$0=last_non_drop_literal(drop,escape_char,t);
          if(! match$0)throw [0,Assert_failure$0,_ck_];
          var last=match$0[1];
          return sub$8(t,first,(last - first | 0) + 1 | 0)}}
      return t}
    function between$2(t,low,high)
     {var _z3_=caml_call2(include$8[2],low,t);
      return _z3_?caml_call2(include$8[2],t,high):_z3_}
    function clamp_unchecked$0(t,min,max)
     {return caml_call2(include$8[1],t,min)
              ?min
              :caml_call2(include$8[2],t,max)?t:max}
    function clamp_exn$2(t,min,max)
     {if(caml_call2(include$8[2],min,max))return clamp_unchecked$0(t,min,max);
      throw [0,Assert_failure$0,_cl_]}
    function clamp$2(t,min,max)
     {if(! caml_call2(include$8[5],min,max))
       return [0,clamp_unchecked$0(t,min,max)];
      var _z2_=[0,[0,cst_max$1,caml_call1(sexp_of_t$2,max)],0];
      return error_s
              (caml_call2
                (message,
                 cst_clamp_requires_min_max$1,
                 [0,[0,cst_min$1,caml_call1(sexp_of_t$2,min)],_z2_]))}
    function create$6(opt,pattern)
     {if(opt)var sth=opt[1],case_sensitive=sth;else var case_sensitive=1;
      return create$5(pattern,case_sensitive)}
    var
     symbol$116=include$8[1],
     symbol$117=include$8[2],
     symbol$118=include$8[3],
     symbol$119=include$8[4],
     symbol$120=include$8[5],
     symbol$121=include$8[6],
     ascending$16=include$8[7],
     descending$16=include$8[8],
     compare_string$1=include$8[9],
     equal_string$1=include$8[10],
     max$19=include$8[11],
     min$19=include$8[12],
     Base_String=
      [0,
       t_sexp_grammar$1,
       sub$8,
       subo$2,
       mem$4,
       is_empty$3,
       iter$1,
       fold$3,
       fold_result$4,
       fold_until$4,
       exists$5,
       for_all$5,
       count$4,
       sum$4,
       find$5,
       find_map$4,
       to_list$5,
       to_array$4,
       min_elt$5,
       max_elt$5,
       iteri$4,
       existsi$3,
       for_alli$3,
       counti$3,
       findi$3,
       find_mapi$3,
       hash_fold_t$6,
       t_of_sexp$2,
       sexp_of_t$2,
       of_string$7,
       to_string$8,
       symbol$121,
       symbol$117,
       symbol$119,
       symbol$120,
       symbol$116,
       symbol$118,
       compare_string$1,
       min$19,
       max$19,
       ascending$16,
       descending$16,
       between$2,
       clamp_exn$2,
       clamp$2,
       comparator$3,
       pp$7,
       hashable$1,
       invariant$12,
       max_length,
       make$1,
       copy$1,
       init$4,
       symbol$59,
       concat$0,
       escaped,
       contains,
       uppercase,
       lowercase,
       capitalize,
       uncapitalize,
       [0,
        hash_fold_t$21,
        hash$10,
        t_of_sexp$2,
        sexp_of_t$2,
        t_sexp_grammar$1,
        symbol$110,
        symbol$111,
        symbol$112,
        symbol$113,
        symbol$114,
        symbol$115,
        equal$24,
        compare$37,
        min$18,
        max$18,
        ascending$15,
        descending$15,
        between$1,
        clamp_exn$1,
        clamp$1,
        comparator$4,
        is_suffix$0,
        is_prefix$0,
        is_substring$0,
        is_substring_at,
        substr_index$0,
        substr_index_exn$0,
        substr_index_all$0,
        substr_replace_first$0,
        substr_replace_all$0],
       index,
       index_exn,
       index_from,
       index_from_exn,
       rindex,
       rindex_exn,
       rindex_from,
       rindex_from_exn,
       [0,
        sexp_of_t$30,
        create$6,
        pattern,
        case_sensitive,
        matches,
        index$0,
        index_exn$0,
        index_all,
        replace_first,
        replace_all,
        split_on,
        Private$2],
       substr_index,
       substr_index_exn,
       substr_index_all,
       substr_replace_first,
       substr_replace_all,
       is_substring,
       is_substring_at$0,
       to_list_rev$0,
       rev$1,
       is_suffix$1,
       is_prefix$1,
       lsplit2_exn,
       rsplit2_exn,
       lsplit2,
       rsplit2,
       split,
       split_on_chars,
       split_lines,
       lfindi,
       rfindi,
       lstrip,
       rstrip,
       strip,
       map$23,
       mapi$4,
       foldi$4,
       concat_map$1,
       filter$3,
       filteri$2,
       tr,
       tr_multi,
       chop_suffix_exn,
       chop_prefix_exn,
       chop_suffix,
       chop_prefix,
       chop_suffix_if_exists,
       chop_prefix_if_exists,
       suffix,
       prefix,
       drop_suffix,
       drop_prefix,
       common_suffix,
       common_prefix,
       common_suffix_length,
       common_prefix_length,
       common_suffix2,
       common_prefix2,
       common_suffix2_length,
       common_prefix2_length,
       concat_array,
       equal_string$1,
       of_char$0,
       of_char_list,
       [0,
        escape_gen_exn,
        escape_gen,
        escape,
        unescape_gen_exn,
        unescape_gen,
        unescape,
        is_char_escaping,
        is_char_escaped,
        is_char_literal,
        index$1,
        index_exn$1,
        rindex$0,
        rindex_exn$0,
        index_from$0,
        index_from_exn$0,
        rindex_from$0,
        rindex_from_exn$0,
        split$0,
        split_on_chars$0,
        lsplit2$0,
        lsplit2_exn$0,
        rsplit2$0,
        rsplit2_exn$0,
        lstrip_literal,
        rstrip_literal,
        strip_literal]];
    caml_register_global(1082,Base_String,"Base__String");
    function pp$8(fmt,t)
     {var _z1_=caml_call1(to_string$2,t);
      return caml_call3(Stdlib_Format[129],fmt,_cm_,_z1_)}
    var
     create$7=caml_create_bytes,
     To_bytes=_a6_([0,caml_ml_bytes_length,create$7,unsafe_blit]),
     blit$4=To_bytes[1],
     blito$2=To_bytes[2],
     unsafe_blit$6=To_bytes[3],
     sub$9=To_bytes[4],
     subo$3=To_bytes[5],
     comparator$5=_P_([0,compare$14,sexp_of_bytes])[1],
     include$49=_v_([0,pp$8,module_name$5]),
     pp$9=include$49[1],
     To_string=Make_to_string([0],To_bytes),
     create$8=caml_create_bytes,
     length$6=caml_ml_bytes_length,
     unsafe_blit$7=caml_blit_string,
     length$7=caml_ml_string_length,
     From_string=_a5_([0,length$7],[0,length$6,create$8,unsafe_blit$7]);
    function invariant$13(param){return 0}
    function init$5(n,f)
     {if(n < 0)caml_call2(invalid_argf(_cn_),n,0);
      var t=caml_create_bytes(n),_zZ_=n - 1 | 0,_zY_=0;
      if(_zZ_ >= 0)
       {var i=_zY_;
        for(;;)
         {caml_bytes_unsafe_set(t,i,caml_call1(f,i));
          var _z0_=i + 1 | 0;
          if(_zZ_ !== i){var i=_z0_;continue}
          break}}
      return t}
    function of_char_list$0(l)
     {var t=caml_create_bytes(caml_call1(length,l));
      iteri$0(l,function(i,c){return caml_bytes_set(t,i,c)});
      return t}
    function to_list$6(t)
     {var i$1=caml_ml_bytes_length(t) - 1 | 0,i=i$1,acc=0;
      for(;;)
       {if(0 > i)return acc;
        var
         acc$0=[0,caml_bytes_unsafe_get(t,i),acc],
         i$0=i - 1 | 0,
         i=i$0,
         acc=acc$0}}
    function to_array$5(t)
     {return caml_call2
              (init,
               caml_ml_bytes_length(t),
               function(i){return caml_bytes_unsafe_get(t,i)})}
    function map$24(t,f){return caml_call2(map$2,f,t)}
    function mapi$5(t,f){return caml_call2(mapi$0,f,t)}
    function fold$4(t,init,f)
     {var len=caml_ml_bytes_length(t),pos=0,acc=init;
      for(;;)
       {if(pos === len)return acc;
        var
         acc$0=caml_call2(f,acc,caml_bytes_unsafe_get(t,pos)),
         pos$0=pos + 1 | 0,
         pos=pos$0,
         acc=acc$0}}
    function foldi$5(t,init,f)
     {var len=caml_ml_bytes_length(t),pos=0,acc=init;
      for(;;)
       {if(pos === len)return acc;
        var
         acc$0=caml_call3(f,pos,acc,caml_bytes_unsafe_get(t,pos)),
         pos$0=pos + 1 | 0,
         pos=pos$0,
         acc=acc$0}}
    function tr$0(target,replacement,s)
     {var _zW_=caml_ml_bytes_length(s) - 1 | 0,_zV_=0;
      if(_zW_ >= 0)
       {var i=_zV_;
        for(;;)
         {if(caml_call2(equal_char$1,caml_bytes_unsafe_get(s,i),target))
           caml_bytes_unsafe_set(s,i,replacement);
          var _zX_=i + 1 | 0;
          if(_zW_ !== i){var i=_zX_;continue}
          break}}
      return 0}
    function tr_multi$0(target,replacement)
     {if(0 === caml_ml_string_length(target))return function(_zU_){return 0};
      if(0 === caml_ml_string_length(replacement))
       return caml_call1(invalid_arg$0,cst_tr_multi_replacement_is_th);
      var match=tr_create_map(target,replacement);
      if(! match)return function(_zT_){return 0};
      var tr_map=match[1];
      return function(s)
       {var _zR_=caml_ml_bytes_length(s) - 1 | 0,_zQ_=0;
        if(_zR_ >= 0)
         {var i=_zQ_;
          for(;;)
           {caml_bytes_unsafe_set
             (s,i,caml_string_unsafe_get(tr_map,caml_bytes_unsafe_get(s,i)));
            var _zS_=i + 1 | 0;
            if(_zR_ !== i){var i=_zS_;continue}
            break}}
        return 0}}
    function between$3(t,low,high)
     {var _zP_=caml_call2(include$9[2],low,t);
      return _zP_?caml_call2(include$9[2],t,high):_zP_}
    function clamp_unchecked$1(t,min,max)
     {return caml_call2(include$9[1],t,min)
              ?min
              :caml_call2(include$9[2],t,max)?t:max}
    function clamp_exn$3(t,min,max)
     {if(caml_call2(include$9[2],min,max))return clamp_unchecked$1(t,min,max);
      throw [0,Assert_failure$0,_co_]}
    function clamp$3(t,min,max)
     {if(! caml_call2(include$9[5],min,max))
       return [0,clamp_unchecked$1(t,min,max)];
      var _zO_=[0,[0,cst_max$2,caml_call1(sexp_of_bytes,max)],0];
      return error_s
              (caml_call2
                (message,
                 cst_clamp_requires_min_max$2,
                 [0,[0,cst_min$2,caml_call1(sexp_of_bytes,min)],_zO_]))}
    function contains$0(pos,len,t,char$0)
     {var
       match=get_pos_len_exn(pos,len,0,caml_ml_bytes_length(t)),
       len$0=match[2],
       pos$0=match[1],
       last=pos$0 + len$0 | 0,
       i=pos$0;
      for(;;)
       {var _zL_=i < last?1:0;
        if(_zL_)
         {var _zM_=caml_call2(equal_char$1,caml_bytes_get(t,i),char$0);
          if(! _zM_){var i$0=i + 1 | 0,i=i$0;continue}
          var _zN_=_zM_}
        else
         var _zN_=_zL_;
        return _zN_}}
    var
     symbol$122=include$9[1],
     symbol$123=include$9[2],
     symbol$124=include$9[3],
     symbol$125=include$9[4],
     symbol$126=include$9[5],
     symbol$127=include$9[6],
     ascending$17=include$9[7],
     descending$17=include$9[8],
     compare_bytes=include$9[9],
     equal_bytes=include$9[10],
     max$20=include$9[11],
     min$20=include$9[12],
     Base_Bytes=
      [0,
       bytes_of_sexp,
       sexp_of_bytes,
       bytes_sexp_grammar,
       blit$4,
       blito$2,
       unsafe_blit$6,
       sub$9,
       subo$3,
       symbol$127,
       symbol$123,
       symbol$125,
       symbol$126,
       symbol$122,
       symbol$124,
       equal_bytes,
       compare_bytes,
       min$20,
       max$20,
       ascending$17,
       descending$17,
       between$3,
       clamp_exn$3,
       clamp$3,
       comparator$5,
       of_string$1,
       to_string$2,
       pp$9,
       invariant$13,
       To_string,
       From_string,
       create$1,
       make,
       map$24,
       mapi$5,
       copy$0,
       init$5,
       of_char_list$0,
       caml_bytes_get,
       caml_bytes_set,
       fill$0,
       tr$0,
       tr_multi$0,
       to_list$6,
       to_array$5,
       fold$4,
       foldi$5,
       contains$0,
       max_length,
       unsafe_to_string,
       unsafe_of_string_promise_no_mu];
    caml_register_global(1083,Base_Bytes,"Base__Bytes");
    function parse_hex(lexbuf)
     {var ocaml_lex_state=0;
      for(;;)
       {var
         ocaml_lex_state$0=
          caml_call3
           (Stdlib_Lexing[20],ocaml_lex_tables,ocaml_lex_state,lexbuf);
        if(0 === ocaml_lex_state$0)
         {var
           body=
            caml_call3(Stdlib_Lexing[16],lexbuf,lexbuf[5] + 3 | 0,lexbuf[6]);
          return [0,body]}
        if(1 === ocaml_lex_state$0)
         {var
           body$0=
            caml_call3(Stdlib_Lexing[16],lexbuf,lexbuf[5] + 2 | 0,lexbuf[6]);
          return [1,body$0]}
        caml_call1(lexbuf[1],lexbuf);
        var ocaml_lex_state=ocaml_lex_state$0}}
    var Base_Hex_lexer=[0,parse_hex];
    caml_register_global(1085,Base_Hex_lexer,"Base__Hex_lexer");
    function convert_failure(x,a,b,to_string)
     {var _zK_=caml_call1(to_string,x);
      return caml_call4(failwithf(_cp_),a,b,_zK_,0)}
    var
     num_bits_nativeint=num_bits$0(word_size),
     num_bits_int32=32,
     num_bits_int64=64;
    if(63 !== num_bits && 31 !== num_bits && 32 !== num_bits)
     throw [0,Assert_failure$0,_lB_];
    var
     _cq_=Stdlib_Int32[10],
     _cr_=Stdlib_Int32[9],
     _cy_=Stdlib_Int64[14],
     _cz_=Stdlib_Nativeint[15],
     _cs_=Stdlib_Int64[10],
     _ct_=Stdlib_Int64[9],
     _cu_=Stdlib_Nativeint[11],
     _cv_=Stdlib_Nativeint[10],
     _cw_=Caml$0[32],
     _cx_=Stdlib_Int32[14];
    function int32_to_int_trunc(_zJ_){return _zJ_}
    function int_to_int32_trunc(_zI_){return _zI_}
    var
     _cA_=
      num_bits <= 32
       ?function(param){return 1}
       :function(x)
         {var
           _zG_=caml_call2(compare$10,_cq_,x) <= 0?1:0,
           _zH_=_zG_?caml_call2(compare$10,x,_cr_) <= 0?1:0:_zG_;
          return _zH_},
     _cB_=
      32 <= num_bits
       ?function(param){return 1}
       :function(x)
         {var
           _zE_=caml_call2(compare$11,min_value$0,x) <= 0?1:0,
           _zF_=_zE_?caml_call2(compare$11,x,max_value$0) <= 0?1:0:_zE_;
          return _zF_};
    function int_to_int32(x){return _cA_(x)?[0,x]:0}
    function int32_to_int(x){return _cB_(x)?[0,x]:0}
    function int_to_int32_exn(x)
     {return _cA_(x)?x:convert_failure(x,cst_int$0,cst_int32$0,_cw_)}
    function int32_to_int_exn(x)
     {return _cB_(x)?x:convert_failure(x,cst_int32$1,cst_int$1,_cx_)}
    if(num_bits >= 64)throw [0,Assert_failure$0,_lA_];
    var
     int_to_int64=caml_int64_of_int32,
     int64_to_int_trunc=caml_int64_to_int32,
     min$21=caml_int64_of_int32(min_value$0),
     max$21=caml_int64_of_int32(max_value$0);
    function int64_is_representable_as_int(x)
     {var
       _zC_=caml_call2(compare$12,min$21,x) <= 0?1:0,
       _zD_=_zC_?caml_call2(compare$12,x,max$21) <= 0?1:0:_zC_;
      return _zD_}
    function int64_to_int(x)
     {return int64_is_representable_as_int(x)?[0,caml_int64_to_int32(x)]:0}
    function int64_to_int_exn(x)
     {return int64_is_representable_as_int(x)
              ?caml_int64_to_int32(x)
              :convert_failure(x,cst_int64$0,cst_int$2,_cy_)}
    if(num_bits > num_bits_nativeint)throw [0,Assert_failure$0,_lz_];
    function int_to_nativeint(_zB_){return _zB_}
    function nativeint_to_int_trunc(_zA_){return _zA_}
    var
     _cC_=
      num_bits_nativeint <= num_bits
       ?function(param){return 1}
       :function(x)
         {var
           _zy_=caml_call2(compare$13,min_value$0,x) <= 0?1:0,
           _zz_=_zy_?caml_call2(compare$13,x,max_value$0) <= 0?1:0:_zy_;
          return _zz_};
    function nativeint_to_int(x){return _cC_(x)?[0,x]:0}
    function nativeint_to_int_exn(x)
     {return _cC_(x)?x:convert_failure(x,cst_nativeint$0,cst_int$3,_cz_)}
    var
     int32_to_int64=caml_int64_of_int32,
     int64_to_int32_trunc=caml_int64_to_int32,
     min$22=caml_int64_of_int32(_cq_),
     max$22=caml_int64_of_int32(_cr_);
    function int64_is_representable_as_int3(x)
     {var
       _zw_=caml_call2(compare$12,min$22,x) <= 0?1:0,
       _zx_=_zw_?caml_call2(compare$12,x,max$22) <= 0?1:0:_zw_;
      return _zx_}
    function int64_to_int32(x)
     {return int64_is_representable_as_int3(x)?[0,caml_int64_to_int32(x)]:0}
    function int64_to_int32_exn(x)
     {return int64_is_representable_as_int3(x)
              ?caml_int64_to_int32(x)
              :convert_failure(x,cst_int64$1,cst_int32$2,_cy_)}
    if(32 > num_bits_nativeint)throw [0,Assert_failure$0,_ly_];
    function int32_to_nativeint(_zv_){return _zv_}
    function nativeint_to_int32_trunc(_zu_){return _zu_}
    var
     _cD_=
      num_bits_nativeint <= 32
       ?function(param){return 1}
       :function(x)
         {var
           _zs_=caml_call2(compare$13,_cq_,x) <= 0?1:0,
           _zt_=_zs_?caml_call2(compare$13,x,_cr_) <= 0?1:0:_zs_;
          return _zt_};
    function nativeint_to_int32(x){return _cD_(x)?[0,x]:0}
    function nativeint_to_int32_exn(x)
     {return _cD_(x)?x:convert_failure(x,cst_nativeint$1,cst_int32$3,_cz_)}
    if(num_bits_nativeint > 64)throw [0,Assert_failure$0,_lx_];
    var
     int64_to_nativeint_trunc=caml_int64_to_int32,
     nativeint_to_int64=caml_int64_of_int32;
    if(64 <= num_bits_nativeint)
     var _cE_=function(param){return 1};
    else
     var
      min$38=caml_int64_of_int32(_cu_),
      max$39=caml_int64_of_int32(_cv_),
      _cE_=
       function(x)
        {var
          _zq_=caml_call2(compare$12,min$38,x) <= 0?1:0,
          _zr_=_zq_?caml_call2(compare$12,x,max$39) <= 0?1:0:_zq_;
         return _zr_};
    function to_nativeint(x){return _cE_(x)?[0,caml_int64_to_int32(x)]:0}
    function to_nativeint_exn(x)
     {return _cE_(x)
              ?caml_int64_to_int32(x)
              :convert_failure(x,cst_int64$2,cst_nativeint$2,_cy_)}
    var
     min$23=caml_int64_shift_right(_cs_,1),
     max$23=caml_int64_shift_right(_ct_,1);
    function int64_is_representable_as_int6(x)
     {var
       _zo_=caml_call2(compare$12,min$23,x) <= 0?1:0,
       _zp_=_zo_?caml_call2(compare$12,x,max$23) <= 0?1:0:_zo_;
      return _zp_}
    function int64_fit_on_int63_exn(x)
     {return int64_is_representable_as_int6(x)
              ?0
              :convert_failure(x,cst_int64$3,cst_int63,_cy_)}
    function insert_delimiter_every(input,delimiter,chars_per_delimiter)
     {var input_length=caml_ml_string_length(input);
      if(input_length <= chars_per_delimiter)return input;
      var match=caml_string_get(input,0),switch$0=0;
      if(43 !== match && 45 !== match){var has_sign=0;switch$0 = 1}
      if(! switch$0)var has_sign=1;
      var
       num_digits=has_sign?input_length - 1 | 0:input_length,
       num_delimiters=caml_div(num_digits - 1 | 0,chars_per_delimiter),
       output_length=input_length + num_delimiters | 0,
       output=caml_create_bytes(output_length),
       input_pos=[0,input_length - 1 | 0],
       output_pos=[0,output_length - 1 | 0],
       num_chars_until_delimiter=[0,chars_per_delimiter],
       first_digit_pos=has_sign?1:0;
      for(;;)
       {if(first_digit_pos > input_pos[1])
         {if(has_sign)caml_bytes_set(output,0,caml_string_get(input,0));
          return unsafe_to_string(output)}
        if(0 === num_chars_until_delimiter[1])
         {caml_bytes_set(output,output_pos[1],delimiter);
          decr(output_pos);
          num_chars_until_delimiter[1] = chars_per_delimiter}
        var _zn_=caml_string_get(input,input_pos[1]);
        caml_bytes_set(output,output_pos[1],_zn_);
        decr(input_pos);
        decr(output_pos);
        decr(num_chars_until_delimiter)}}
    function insert_delimiter(input,delimiter)
     {return insert_delimiter_every(input,delimiter,3)}
    function insert_underscores(input){return insert_delimiter(input,95)}
    function _cG_(I)
     {var compare=I[1],hash_fold_t=I[2],func=I[3];
      function hash(x){return caml_call1(func,x)}
      var chars_per_delimiter=4;
      function to_string(delimiter,t)
       {if(delimiter)
         var
          delimiter$0=delimiter[1],
          make_suffix=
           function(t)
            {return insert_delimiter_every
                     (caml_call1(I[4],t),delimiter$0,chars_per_delimiter)};
        else
         var make_suffix=I[4];
        return caml_call2(I[7],t,I[6])
                ?caml_call2
                  (symbol$59,
                   cst_0x,
                   caml_call1(make_suffix,caml_call1(I[8],t)))
                :caml_call2(symbol$59,cst_0x$0,caml_call1(make_suffix,t))}
      function to_string$0(t){return to_string(0,t)}
      function to_string_hum(opt,t)
       {if(opt)var sth=opt[1],delimiter=sth;else var delimiter=95;
        return to_string([0,delimiter],t)}
      function invalid(str)
       {var _zm_=I[9];return caml_call3(failwithf(_cF_),_zm_,str,0)}
      function of_string_with_delimiter(str)
       {var
         _zl_=
          filter$3(str,function(c){return caml_call2(symbol$106,c,95)});
        return caml_call1(I[5],_zl_)}
      function of_string(str)
       {var
         lex=caml_call2(Stdlib_Lexing[3],0,str),
         result=try_with$1(function(param){return parse_hex(lex)});
        if(lex[6] !== lex[3])return invalid(str);
        if(! result)return invalid(str);
        var _zj_=result[1];
        if(0 === _zj_[0])
         {var body=_zj_[1],_zk_=of_string_with_delimiter(body);
          return caml_call1(I[8],_zk_)}
        var body$0=_zj_[1];
        return of_string_with_delimiter(body$0)}
      var
       t_sexp_grammar=caml_call1(Sexplib0_Sexp_grammar[1],t_sexp_grammar$1),
       include=Of_stringable([0,of_string,to_string$0]),
       t_of_sexp=include[1],
       sexp_of_t=include[2];
      return [0,
              [0,
               t_of_sexp,
               sexp_of_t,
               t_sexp_grammar,
               compare,
               hash_fold_t,
               hash,
               of_string,
               to_string$0,
               to_string_hum]]}
    function _cH_(I)
     {var chars_per_delimiter=3;
      function to_string_hum(opt,t)
       {if(opt)var sth=opt[1],delimiter=sth;else var delimiter=95;
        return insert_delimiter_every
                (caml_call1(I[1],t),delimiter,chars_per_delimiter)}
      function sexp_of_t(t)
       {var
         s=caml_call1(I[1],t),
         s$0=
          1009018843 <= of_int_style[1]
           ?s
           :insert_delimiter_every(s,95,chars_per_delimiter);
        return [0,s$0]}
      return [0,to_string_hum,sexp_of_t]}
    var
     Base_Int_conversions=
      [0,
       int_to_int32,
       int_to_int32_exn,
       int_to_int32_trunc,
       int_to_int64,
       int_to_nativeint,
       int32_to_int,
       int32_to_int_exn,
       int32_to_int_trunc,
       int32_to_int64,
       int32_to_nativeint,
       int64_to_int,
       int64_to_int_exn,
       int64_to_int_trunc,
       int64_to_int32,
       int64_to_int32_exn,
       int64_to_int32_trunc,
       to_nativeint,
       to_nativeint_exn,
       int64_to_nativeint_trunc,
       int64_fit_on_int63_exn,
       int64_is_representable_as_int6,
       nativeint_to_int,
       nativeint_to_int_exn,
       nativeint_to_int_trunc,
       nativeint_to_int32,
       nativeint_to_int32_exn,
       nativeint_to_int32_trunc,
       nativeint_to_int64,
       num_bits,
       num_bits_int32,
       num_bits_int64,
       num_bits_nativeint,
       _cH_,
       _cG_,
       of_int_style,
       insert_delimiter_every,
       insert_delimiter,
       insert_underscores];
    caml_register_global(1086,Base_Int_conversions,"Base__Int_conversions");
    var Base_Intable=[0];
    caml_register_global(1087,Base_Intable,"Base__Intable");
    var Base_Int_intf=[0];
    caml_register_global(1088,Base_Int_intf,"Base__Int_intf");
    var
     int32_positive_overflow_bounds=_cI_.slice(),
     switcher=num_bits - 31 | 0,
     overflow_bound_max_int32_value=2147483647,
     overflow_bound_max_int_value=2147483647;
    if(1 < switcher >>> 0)
     {if(32 !== switcher)throw [0,Assert_failure$0,_lv_];
      var
       int_positive_overflow_bounds=
        [0,
         caml_int64_to_int32(_cL_),
         caml_int64_to_int32(_cK_),
         caml_int64_to_int32(_cJ_),
         1664510,
         46340,
         5404,
         1290,
         463,
         215,
         118,
         73,
         49,
         35,
         27,
         21,
         17,
         14,
         12,
         10,
         9,
         8,
         7,
         7,
         6,
         5,
         5,
         5,
         4,
         4,
         4,
         4,
         3,
         3,
         3,
         3,
         3,
         3,
         3,
         3,
         3,
         2,
         2,
         2,
         2,
         2,
         2,
         2,
         2,
         2,
         2,
         2,
         2,
         2,
         2,
         2,
         2,
         2,
         2,
         2,
         2,
         2,
         2,
         1,
         1]}
    else
     var
      int_positive_overflow_bounds=
       switcher
        ?map(int32_positive_overflow_bounds,function(_zi_){return _zi_})
        :_lw_.slice();
    var
     int63_on_int64_positive_overfl=_cM_.slice(),
     int64_positive_overflow_bounds=_cN_.slice(),
     int64_negative_overflow_bounds=_cO_.slice(),
     Base_Pow_overflow_bounds=
      [0,
       overflow_bound_max_int32_value,
       int32_positive_overflow_bounds,
       overflow_bound_max_int_value,
       int_positive_overflow_bounds,
       overflow_bound_max_int63_on_in,
       int63_on_int64_positive_overfl,
       overflow_bound_max_int64_value,
       int64_positive_overflow_bounds,
       int64_negative_overflow_bounds];
    caml_register_global
     (1089,Base_Pow_overflow_bounds,"Base__Pow_overflow_bounds");
    function negative_exponent(param){return caml_call1(invalid_argf(_cP_),0)}
    function overflow(param){return caml_call1(invalid_argf(_cQ_),0)}
    function int_pow(base,exponent)
     {if(exponent < 0)negative_exponent(0);
      var _ze_=1 < caml_call1(abs$0,base)?1:0;
      if(_ze_)
       {var _zf_=63 < exponent?1:0;
        if(_zf_)
         var _zg_=_zf_;
        else
         var
          _zh_=
           caml_check_bound(int_positive_overflow_bounds,exponent)
            [1 + exponent],
          _zg_=_zh_ < caml_call1(abs$0,base)?1:0}
      else
       var _zg_=_ze_;
      if(_zg_)overflow(0);
      return runtime.Base_int_math_int_pow_stub(base,exponent)}
    var abs$1=Stdlib_Int64[8];
    function int64_pow(base,exponent)
     {if(caml_lessthan(exponent,_cR_))negative_exponent(0);
      var
       _y7_=caml_greaterthan(base,_cS_),
       _y8_=_y7_ || caml_lessthan(base,_cW_);
      if(_y8_)
       {var _y9_=caml_greaterthan(exponent,_cT_);
        if(_y9_)
         var _y__=_y9_;
        else
         {var _y$_=caml_greaterequal(base,_cU_);
          if(_y$_)
           var
            _za_=caml_int64_to_int32(exponent),
            _zb_=
             caml_greaterthan
              (base,
               caml_check_bound(int64_positive_overflow_bounds,_za_)[1 + _za_]);
          else
           var _zb_=_y$_;
          if(_zb_)
           var _y__=_zb_;
          else
           {var _zc_=caml_lessthan(base,_cV_);
            if(_zc_)
             var
              _zd_=caml_int64_to_int32(exponent),
              _y__=
               caml_lessthan
                (base,
                 caml_check_bound(int64_negative_overflow_bounds,_zd_)
                  [1 + _zd_]);
            else
             var _y__=_zc_}}}
      else
       var _y__=_y8_;
      if(_y__)overflow(0);
      return runtime.Base_int_math_int64_pow_stub(base,exponent)}
    function int63_pow_on_int64(base,exponent)
     {if(caml_lessthan(exponent,_cX_))negative_exponent(0);
      var _y2_=caml_greaterthan(caml_call1(abs$1,base),_cY_);
      if(_y2_)
       {var _y3_=caml_greaterthan(exponent,_cZ_);
        if(_y3_)
         var _y4_=_y3_;
        else
         var
          _y5_=caml_int64_to_int32(exponent),
          _y6_=caml_check_bound(int63_on_int64_positive_overfl,_y5_)[1 + _y5_],
          _y4_=caml_greaterthan(caml_call1(abs$1,base),_y6_)}
      else
       var _y4_=_y2_;
      if(_y4_)overflow(0);
      return runtime.Base_int_math_int64_pow_stub(base,exponent)}
    var Private$3=[0,int_pow,int64_pow,int63_pow_on_int64];
    function _c2_(X)
     {function symbol(x,y)
       {if(caml_call2(X[11],y,X[18]))
         {var _y0_=caml_call1(X[4],y),_y1_=caml_call1(X[4],x);
          caml_call3(invalid_argf(_c0_),_y1_,_y0_,0)}
        var rval=caml_call2(X[20],x,y);
        return caml_call2(X[14],rval,X[18])?caml_call2(X[5],rval,y):rval}
      var one=caml_call1(X[19],1);
      function symbol$0(x,y)
       {if(caml_call2(X[11],y,X[18]))
         {var _yW_=caml_call1(X[4],y),_yX_=caml_call1(X[4],x);
          caml_call3(invalid_argf(_c1_),_yX_,_yW_,0)}
        if(! caml_call2(X[14],x,X[18]))return caml_call2(X[8],x,y);
        var _yY_=caml_call2(X[5],x,one),_yZ_=caml_call2(X[8],_yY_,y);
        return caml_call2(X[6],_yZ_,one)}
      function symbol$1(x,y)
       {var _yV_=caml_call1(X[2],y);return caml_call1(X[2],x) / _yV_}
      function round_down(i,modulus)
       {var _yU_=symbol(i,modulus);return caml_call2(X[6],i,_yU_)}
      function round_up(i,modulus)
       {var remainder=symbol(i,modulus);
        if(caml_call2(X[12],remainder,X[18]))return i;
        var _yT_=caml_call2(X[5],i,modulus);
        return caml_call2(X[6],_yT_,remainder)}
      function round_towards_zero(i,to_multiple_of)
       {return caml_call2(X[12],i,X[18])
                ?X[18]
                :caml_call2(X[13],i,X[18])
                  ?round_down(i,to_multiple_of)
                  :round_up(i,to_multiple_of)}
      function round_nearest(i,modulus)
       {var
         remainder=symbol(i,modulus),
         modulus_minus_remainder=caml_call2(X[6],modulus,remainder);
        return caml_call2(X[11],modulus_minus_remainder,remainder)
                ?caml_call2(X[5],i,modulus_minus_remainder)
                :caml_call2(X[6],i,remainder)}
      function round(opt,i,to_multiple_of)
       {if(opt)var sth=opt[1],dir=sth;else var dir=857423934;
        return 857423934 <= dir
                ?1003109192 <= dir
                  ?round_towards_zero(i,to_multiple_of)
                  :round_nearest(i,to_multiple_of)
                :759637122 <= dir
                  ?round_down(i,to_multiple_of)
                  :round_up(i,to_multiple_of)}
      return [0,
              symbol,
              symbol$0,
              symbol$1,
              round,
              round_towards_zero,
              round_down,
              round_up,
              round_nearest]}
    var Base_Int_math=[0,_c2_,Private$3];
    caml_register_global(1090,Base_Int_math,"Base__Int_math");
    function int64_popcount(x)
     {var
       x$0=
        caml_int64_sub
         (x,caml_int64_and(caml_int64_shift_right_unsigne(x,1),m1)),
       x$1=
        caml_int64_add
         (caml_int64_and(x$0,m2),
          caml_int64_and(caml_int64_shift_right_unsigne(x$0,2),m2)),
       x$2=
        caml_int64_and
         (caml_int64_add(x$1,caml_int64_shift_right_unsigne(x$1,4)),m4);
      return caml_int64_to_int32
              (caml_int64_shift_right_unsigne(caml_int64_mul(x$2,h01),56))}
    function int32_popcount(x)
     {return int64_popcount(caml_int64_and(caml_int64_of_int32(x),mask))}
    var _c3_=Stdlib_Nativeint[9];
    if(32 === _c3_)
     var popcount=function(x){return int32_popcount(x)};
    else
     {if(64 !== _c3_)throw [0,Assert_failure$0,_lu_];
      var popcount=function(x){return int64_popcount(caml_int64_of_int32(x))}}
    function popcount$0(_yS_){return runtime.Base_int_math_int_popcount(_yS_)}
    var Base_Popcount=[0,popcount$0,int32_popcount,int64_popcount,popcount];
    caml_register_global(1091,Base_Popcount,"Base__Popcount");
    var
     _c4_=
      _a1_
       ([0,
         compare$26,
         hash_fold_t$18,
         to_int$1,
         t_of_sexp$17,
         sexp_of_t$24,
         of_string$3,
         to_string$4,
         module_name$2]),
     hash_fold_t$22=_c4_[1],
     hash$11=_c4_[2],
     t_of_sexp$20=_c4_[3],
     sexp_of_t$32=_c4_[4],
     of_string$8=_c4_[5],
     to_string$9=_c4_[6],
     between$4=_c4_[19],
     clamp_exn$4=_c4_[20],
     clamp$4=_c4_[21],
     comparator$6=_c4_[22],
     pp$10=_c4_[23],
     hashable$2=_c4_[24];
    function to_float$0(param)
     {switch(param){case 0:return -1.;case 1:return 0.;default:return 1.}}
    function flip$0(param)
     {switch(param){case 0:return 2;case 1:return 1;default:return 0}}
    function symbol$128(t$0,t)
     {var _yR_=to_int$1(t);return sign(caml_mul(to_int$1(t$0),_yR_))}
    var
     symbol$129=Replace_polymorphic_compare[1],
     symbol$130=Replace_polymorphic_compare[2],
     symbol$131=Replace_polymorphic_compare[3],
     symbol$132=Replace_polymorphic_compare[4],
     symbol$133=Replace_polymorphic_compare[5],
     symbol$134=Replace_polymorphic_compare[6],
     ascending$18=Replace_polymorphic_compare[7],
     descending$18=Replace_polymorphic_compare[8],
     compare$38=Replace_polymorphic_compare[9],
     equal$25=Replace_polymorphic_compare[10],
     max$24=Replace_polymorphic_compare[11],
     min$24=Replace_polymorphic_compare[12],
     Base_Sign=
      [0,
       all$6,
       t_sexp_grammar$17,
       hash_fold_t$22,
       hash$11,
       t_of_sexp$20,
       sexp_of_t$32,
       of_string$8,
       to_string$9,
       symbol$134,
       symbol$130,
       symbol$132,
       symbol$133,
       symbol$129,
       symbol$131,
       equal$25,
       compare$38,
       min$24,
       max$24,
       ascending$18,
       descending$18,
       between$4,
       clamp_exn$4,
       clamp$4,
       comparator$6,
       pp$10,
       hashable$2,
       sign,
       to_int$1,
       to_float$0,
       flip$0,
       symbol$128];
    caml_register_global(1092,Base_Sign,"Base__Sign");
    function func$8(x){return caml_call1(func$3,x)}
    var
     hashable$3=[0,func$8,caml_int_compare,sexp_of_t$4],
     compare$39=caml_int_compare;
    function of_string$9(s)
     {try
       {var _yP_=caml_int_of_string(s);return _yP_}
      catch(_yQ_){return caml_call2(failwithf(_c5_),s,0)}}
    var
     float_lower_bound=lower_bound_for_int(num_bits),
     float_upper_bound=upper_bound_for_int(num_bits);
    function of_int$2(_yO_){return _yO_}
    function of_float_unchecked(_yN_){return _yN_ | 0}
    function to_int$3(f)
     {if
       (caml_call2(include$7[6],f,float_lower_bound)
        &&
        caml_call2(include$7[2],f,float_upper_bound))
       return f | 0;
      return caml_call2(invalid_argf(_c6_),f + 0.,0)}
    var
     comparator$7=_P_([0,compare$39,sexp_of_t$4])[1],
     _c7_=_aY_([0,compare$39,sexp_of_t$4,0]),
     is_positive=_c7_[1],
     is_non_negative=_c7_[2],
     is_negative=_c7_[3],
     is_non_positive=_c7_[4],
     include$50=_cH_([0,to_string]),
     to_string_hum$1=include$50[1],
     sexp_of_t$33=include$50[2],
     zero=0,
     one=1,
     minus_one=-1;
    function hash$12(x){return caml_call1(func$3,x)}
    function symbol$135(_yM_,_yL_){return _yM_ < _yL_?1:0}
    function to_string$10(i){return caml_call2(sprintf,_c8_,i)}
    function of_string$10(s)
     {function _yJ_(_yK_){return _yK_}
      return caml_call3(Stdlib_Scanf[4],s,_c9_,_yJ_)}
    var
     include$51=
      _cG_
       ([0,
         compare$10,
         hash_fold_t$4,
         hash$12,
         to_string$10,
         of_string$10,
         zero,
         symbol$135,
         neg,
         module_name$6]),
     Hex=include$51[1],
     include$52=_w_([0,module_name$7,to_string]),
     pp$11=include$52[1];
    function invariant$14(param){return 0}
    function between$5(t,low,high)
     {var _yH_=low <= t?1:0,_yI_=_yH_?t <= high?1:0:_yH_;return _yI_}
    function clamp_unchecked$2(t,min,max){return t < min?min:t <= max?t:max}
    function clamp_exn$5(t,min,max)
     {if(min <= max)return clamp_unchecked$2(t,min,max);
      throw [0,Assert_failure$0,_c__]}
    function clamp$5(t,min,max)
     {if(max >= min)return [0,clamp_unchecked$2(t,min,max)];
      var _yG_=[0,[0,cst_max$3,caml_call1(sexp_of_t$4,max)],0];
      return error_s
              (caml_call2
                (message,
                 cst_clamp_requires_min_max$3,
                 [0,[0,cst_min$3,caml_call1(sexp_of_t$4,min)],_yG_]))}
    function pred$0(i){return i - 1 | 0}
    function succ$1(i){return i + 1 | 0}
    function to_int_exn(i){return i}
    function of_int$3(i){return i}
    var
     max_value$2=Caml$0[18],
     min_value$2=Caml$0[19],
     max_value_30_bits=1073741823;
    function abs$2(x){return caml_call1(abs$0,x)}
    var rem=caml_mod;
    function incr$0(_yF_){_yF_[1]++;return 0}
    function decr$0(_yE_){_yE_[1] += -1;return 0}
    function shift_right$0(a,b){return a >> b}
    function shift_right_logical(a,b){return a >>> b | 0}
    function shift_left(a,b){return a << b}
    function bit_not(a){return caml_call1(lnot$0,a)}
    function bit_or(a,b){return a | b}
    function bit_and(a,b){return a & b}
    function bit_xor(a,b){return a ^ b}
    var pow=Private$3[1];
    function symbol$136(b,e){return caml_call2(pow,b,e)}
    function non_positive_argument(param)
     {return caml_call1(invalid_argf(_c$_),0)}
    function ceil_pow2(x)
     {if(x <= 0)non_positive_argument(0);
      var
       x$0=x - 1 | 0,
       x$1=x$0 | x$0 >>> 1 | 0,
       x$2=x$1 | x$1 >>> 2 | 0,
       x$3=x$2 | x$2 >>> 4 | 0,
       x$4=x$3 | x$3 >>> 8 | 0,
       x$5=x$4 | x$4 >>> 16 | 0,
       x$6=x$5 | x$5 >>> 32 | 0;
      return x$6 + 1 | 0}
    function floor_pow2(x)
     {if(x <= 0)non_positive_argument(0);
      var
       x$0=x | x >>> 1 | 0,
       x$1=x$0 | x$0 >>> 2 | 0,
       x$2=x$1 | x$1 >>> 4 | 0,
       x$3=x$2 | x$2 >>> 8 | 0,
       x$4=x$3 | x$3 >>> 16 | 0,
       x$5=x$4 | x$4 >>> 32 | 0;
      return x$5 - (x$5 >>> 1 | 0) | 0}
    function is_pow2(x)
     {if(x <= 0)non_positive_argument(0);return 0 === (x & (x - 1 | 0))?1:0}
    function floor_log2(i)
     {if(i <= 0)
       raise_s
        (caml_call2
          (message,
           cst_Int_floor_log2_got_invalid,
           [0,[0,cst$26,caml_call1(sexp_of_t$4,i)],0]));
      return (num_bits - 1 | 0) - runtime.Base_int_math_int_clz(i) | 0}
    function ceil_log2(i)
     {if(i <= 0)
       raise_s
        (caml_call2
          (message,
           cst_Int_ceil_log2_got_invalid_,
           [0,[0,cst$27,caml_call1(sexp_of_t$4,i)],0]));
      return 1 === i?0:num_bits - runtime.Base_int_math_int_clz(i - 1 | 0) | 0}
    function _da_(_yD_){return - _yD_ | 0}
    function _db_(_yC_,_yB_){return _yC_ !== _yB_?1:0}
    function _dc_(_yA_,_yz_){return _yA_ < _yz_?1:0}
    function _dd_(_yy_,_yx_){return _yx_ < _yy_?1:0}
    function _de_(_yw_,_yv_){return _yw_ === _yv_?1:0}
    function _df_(_yu_,_yt_){return _yu_ <= _yt_?1:0}
    function _dg_(_ys_,_yr_){return _yr_ <= _ys_?1:0}
    function _dh_(_yq_){return - _yq_ | 0}
    var _di_=caml_div,_dj_=caml_mul;
    function _dk_(_yp_,_yo_){return _yp_ - _yo_ | 0}
    var
     F$0=
      _c2_
       ([0,
         to_int$3,
         of_int$2,
         of_string$9,
         to_string,
         function(_yn_,_ym_){return _yn_ + _ym_ | 0},
         _dk_,
         _dj_,
         _di_,
         _dh_,
         _dg_,
         _df_,
         _de_,
         _dd_,
         _dc_,
         _db_,
         abs$2,
         _da_,
         zero,
         of_int$3,
         rem]),
     round=F$0[4],
     round_towards_zero=F$0[5],
     round_down=F$0[6],
     round_up=F$0[7],
     round_nearest=F$0[8];
    function symbol$137(x,y)
     {if(y <= 0)
       {var _yk_=caml_call1(to_string,y),_yl_=caml_call1(to_string,x);
        caml_call3(invalid_argf(_dl_),_yl_,_yk_,0)}
      var rval=caml_mod(x,y);
      return rval < 0?rval + y | 0:rval}
    function symbol$138(x,y)
     {if(y <= 0)
       {var _yi_=caml_call1(to_string,y),_yj_=caml_call1(to_string,x);
        caml_call3(invalid_argf(_dm_),_yj_,_yi_,0)}
      return x < 0?caml_div(x + 1 | 0,y) - 1 | 0:caml_div(x,y)}
    function symbol$139(x,y){return x / y}
    var
     ascending$19=include$1[1],
     descending$19=include$1[2],
     max$25=include$1[3],
     min$25=include$1[4],
     Private$4=[0,[0,F$0[1],F$0[2],F$0[3]]],
     O$0=[0,symbol$136,lnot$0,abs$2,zero,symbol$137,symbol$138,symbol$139];
    function ctz(_yh_){return runtime.Base_int_math_int_ctz(_yh_)}
    function clz(_yg_){return runtime.Base_int_math_int_clz(_yg_)}
    var compare_int$0=caml_int_compare;
    function equal_int$1(_yf_,_ye_){return _yf_ === _ye_?1:0}
    var
     include$53=
      [0,
       t_sexp_grammar$3,
       to_int$3,
       of_int$2,
       of_int$3,
       to_int_exn,
       hash_fold_t$4,
       func$8,
       t_of_sexp$4,
       sexp_of_t$33,
       of_string$9,
       to_string,
       equal_int$1,
       compare_int$0,
       min$25,
       max$25,
       ascending$19,
       descending$19,
       between$5,
       clamp_exn$5,
       clamp$5,
       comparator$7,
       pp$11,
       hashable$3,
       is_positive,
       is_non_negative,
       is_negative,
       is_non_positive,
       sign,
       invariant$14,
       Hex,
       to_string_hum$1,
       one,
       minus_one,
       rem,
       round,
       round_towards_zero,
       round_down,
       round_up,
       round_nearest,
       succ$1,
       pred$0,
       pow,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       popcount$0,
       shift_left,
       shift_right$0,
       decr$0,
       incr$0,
       int32_to_int_exn,
       int_to_int32_exn,
       int64_to_int_exn,
       int_to_int64,
       nativeint_to_int_exn,
       int_to_nativeint,
       of_float_unchecked,
       num_bits,
       max_value$2,
       min_value$2,
       shift_right_logical,
       ceil_pow2,
       floor_pow2,
       ceil_log2,
       floor_log2,
       is_pow2,
       clz,
       ctz,
       O$0,
       symbol$136,
       lnot$0,
       abs$2,
       zero,
       symbol$137,
       symbol$138,
       symbol$139,
       max_value_30_bits,
       of_int$3,
       to_int_exn,
       int32_to_int,
       int_to_int32,
       int64_to_int,
       nativeint_to_int,
       int_to_nativeint,
       Private$4];
    caml_register_global(1094,include$53,"Base__Int");
    function hash_fold_t$23(state,t)
     {return runtime.Base_internalhash_fold_int(state,caml_call1(to_int$2,t))}
    function hash$13(t){return run(0,hash_fold_t$23,t)}
    function to_string$11(t)
     {return caml_call2(sprintf,_dn_,caml_call1(to_int$2,t))}
    function sexp_of_t$34(t){return [0,to_string$11(t)]}
    function t_of_sexp$21(sexp)
     {if(0 !== sexp[0])
       return caml_call2(of_sexp_error,cst_Uchar_t_of_sexp_atom_neede,sexp);
      var s=sexp[1];
      try
       {var
         _yb_=function(i){return caml_call1(of_int$1,i)},
         _yc_=caml_call3(Stdlib_Scanf[4],s,_do_,_yb_);
        return _yc_}
      catch(_yd_)
       {return caml_call2(of_sexp_error,cst_Uchar_t_of_sexp_atom_of_th,sexp)}}
    var
     t_sexp_grammar$22=caml_call1(Sexplib0_Sexp_grammar[1],t_sexp_grammar$1),
     pp$12=_w_([0,module_name$8,to_string$11])[1],
     _dp_=Make$1([0,compare$32,sexp_of_t$34]),
     between$6=_dp_[13],
     clamp_exn$6=_dp_[14],
     clamp$6=_dp_[15],
     comparator$8=_dp_[16];
    function invariant$15(param){return 0}
    function succ_exn(c)
     {try
       {var _ya_=caml_call1(succ$0,c);return _ya_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] !== Stdlib[6])throw exn;
        var msg=exn[2];
        return caml_call2(failwithf(_dq_),msg,0)}}
    function succ$2(c)
     {try
       {var _x__=[0,caml_call1(succ$0,c)];return _x__}
      catch(_x$_)
       {_x$_ = caml_wrap_exception(_x$_);
        if(_x$_[1] === Stdlib[6])return 0;
        throw _x$_}}
    function pred_exn(c)
     {try
       {var _x9_=caml_call1(pred,c);return _x9_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] !== Stdlib[6])throw exn;
        var msg=exn[2];
        return caml_call2(failwithf(_dr_),msg,0)}}
    function pred$1(c)
     {try
       {var _x7_=[0,caml_call1(pred,c)];return _x7_}
      catch(_x8_)
       {_x8_ = caml_wrap_exception(_x8_);
        if(_x8_[1] === Stdlib[6])return 0;
        throw _x8_}}
    function of_scalar(i)
     {return caml_call1(is_valid,i)?[0,caml_call1(unsafe_of_int$0,i)]:0}
    function of_scalar_exn(i)
     {return caml_call1(is_valid,i)
              ?caml_call1(unsafe_of_int$0,i)
              :caml_call2(failwithf(_ds_),i,0)}
    function to_scalar(t){return caml_call1(to_int$2,t)}
    function to_char(c)
     {return caml_call1(is_char,c)?[0,caml_call1(unsafe_to_char,c)]:0}
    function to_char_exn(c)
     {if(caml_call1(is_char,c))return caml_call1(unsafe_to_char,c);
      var _x6_=caml_call1(to_int$2,c);
      return caml_call2(failwithf(_dt_),_x6_,0)}
    function utf8_byte_length(uchar)
     {var codepoint=to_scalar(uchar);
      return 128 <= codepoint?2048 <= codepoint?65536 <= codepoint?4:3:2:1}
    var
     symbol$140=include$6[2],
     symbol$141=include$6[3],
     symbol$142=include$6[4],
     symbol$143=include$6[5],
     symbol$144=include$6[6],
     symbol$145=include$6[7],
     ascending$20=include$6[8],
     descending$20=include$6[9],
     compare$40=include$6[10],
     equal$26=include$6[11],
     max$26=include$6[12],
     min$26=include$6[13],
     Base_Uchar=
      [0,
       hash_fold_t$23,
       hash$13,
       t_of_sexp$21,
       sexp_of_t$34,
       t_sexp_grammar$22,
       symbol$145,
       symbol$141,
       symbol$143,
       symbol$144,
       symbol$140,
       symbol$142,
       equal$26,
       compare$40,
       min$26,
       max$26,
       ascending$20,
       descending$20,
       between$6,
       clamp_exn$6,
       clamp$6,
       comparator$8,
       pp$12,
       invariant$15,
       succ$2,
       succ_exn,
       pred$1,
       pred_exn,
       is_char,
       to_char,
       to_char_exn,
       of_char,
       is_valid,
       of_scalar,
       of_scalar_exn,
       to_scalar,
       utf8_byte_length,
       min_value$1,
       max_value$1];
    caml_register_global(1095,Base_Uchar,"Base__Uchar");
    function sexp_of_t$35(of_a_001,of_b_002,param){return _du_}
    var refl=0;
    function sym(param){return 0}
    function trans(param,_x5_){return 0}
    function conv(param,a){return a}
    function Lift(X){function lift(param){return 0}return [0,lift]}
    function Lift2(X){function lift(param,_x4_){return 0}return [0,lift]}
    function Lift3(X){function lift(param,_x3_,_x2_){return 0}return [0,lift]}
    function detuple2(param){return _dv_}
    function tuple2(param,_x1_){return 0}
    function Composition_preserves_injectiv(M1,M2)
     {function strip(e)
       {var _x0_=caml_call1(M2[1],e);return caml_call1(M1[1],_x0_)}
      return [0,strip]}
    function sexp_of_t$36(param,_xZ_)
     {var name=_xZ_[2],witness=_xZ_[1];
      if(am_testing)return [0,name];
      var
       _xY_=caml_call1(Stdlib_Obj[22][1],witness[1]),
       v_005=caml_call1(Stdlib_Obj[22][3],_xY_);
      return [1,
              [0,
               [1,[0,_dy_,[0,[0,name],0]]],
               [0,
                [1,
                 [0,
                  _dx_,
                  [0,[1,[0,_dw_,[0,caml_call1(sexp_of_t$4,v_005),0]]],0]]],
                0]]]}
    function to_sexp(t){return t[3]}
    function name$0(t){return t[2]}
    function create$9(name,to_sexp)
     {var Key=[248,cst_Key,caml_fresh_oo_id(0)];
      return [0,[0,Key],name,to_sexp]}
    function uid(t)
     {var _xX_=caml_call1(Stdlib_Obj[22][1],t[1][1]);
      return caml_call1(Stdlib_Obj[22][3],_xX_)}
    function hash$14(t){return uid(t)}
    function hash_fold_t$24(s,t){return caml_call2(hash_fold_t$4,s,uid(t))}
    function same_witness(t1,t2){return t1[1][1] === t2[1][1]?some_t:0}
    function same(t1,t2){return is_some(same_witness(t1,t2))}
    function same_witness_exn(t1,t2)
     {var match=same_witness(t1,t2);
      if(match){var w=match[1];return w}
      var _xS_=0,_xT_=[0,t1,t2];
      function _xU_(_xW_){return sexp_of_t$36(sexp_of_opaque,_xW_)}
      return raise_s
              (caml_call2
                (message,
                 cst_Type_equal_Id_same_witness,
                 [0,
                  [0,
                   cst$28,
                   caml_call3
                    (sexp_of_pair,
                     function(_xV_){return sexp_of_t$36(sexp_of_opaque,_xV_)},
                     _xU_,
                     _xT_)],
                  _xS_]))}
    function _dz_(_xR_,_xQ_){return _xR_ !== _xQ_?1:0}
    function _dA_(_xP_,_xO_){return _xP_ < _xO_?1:0}
    function _dB_(_xN_,_xM_){return _xM_ < _xN_?1:0}
    function _dC_(_xL_,_xK_){return _xL_ === _xK_?1:0}
    function _dD_(_xJ_,_xI_){return _xJ_ <= _xI_?1:0}
    var
     Base_Type_equal=
      [0,
       sexp_of_t$35,
       refl,
       sym,
       trans,
       conv,
       Lift,
       Lift2,
       Lift3,
       detuple2,
       tuple2,
       Composition_preserves_injectiv,
       [0,
        sexp_of_t$36,
        [0,
         hash_fold_t$4,
         func$8,
         t_of_sexp$4,
         sexp_of_t$33,
         function(_xH_,_xG_){return _xG_ <= _xH_?1:0},
         _dD_,
         _dC_,
         _dB_,
         _dA_,
         _dz_,
         equal_int$1,
         compare_int$0,
         min$25,
         max$25,
         ascending$19,
         descending$19,
         between$5,
         clamp_exn$5,
         clamp$5,
         comparator$7],
        uid,
        create$9,
        hash$14,
        name$0,
        to_sexp,
        hash_fold_t$24,
        same,
        same_witness,
        same_witness_exn]];
    caml_register_global(1096,Base_Type_equal,"Base__Type_equal");
    var Base_T=[0];
    caml_register_global(1097,Base_T,"Base__T");
    var Base_Stack_intf=[0];
    caml_register_global(1098,Base_Stack_intf,"Base__Stack_intf");
    var
     none_substitute=runtime.caml_obj_block(Stdlib_Obj[12],1),
     none=24791911;
    function is_none$0(x){return x === 24791911?1:0}
    function is_some$0(x){return 1 - (x === 24791911?1:0)}
    function some$0(x){return x === 24791911?none_substitute:x}
    function value_unsafe(x){return x === none_substitute?none:x}
    function value_exn$0(x)
     {return is_some$0(x)
              ?value_unsafe(x)
              :caml_call1(failwith$0,cst_Option_array_get_some_exn_)}
    function of_sexpable(param)
     {if(! param)return none;var x=param[1];return some$0(x)}
    function to_sexpable(x){return is_some$0(x)?[0,value_unsafe(x)]:0}
    var
     include$91=
      Of_sexpable1
       ([0,option_of_sexp,sexp_of_option],[0,to_sexpable,of_sexpable]),
     t_of_sexp$22=include$91[1],
     sexp_of_t$37=include$91[2];
    function t_of_sexp$23(of_a_001,x_003)
     {return caml_call2(t_of_sexp$19,caml_call1(t_of_sexp$22,of_a_001),x_003)}
    function sexp_of_t$38(of_a_004,x_005)
     {return caml_call2(sexp_of_t$29,caml_call1(sexp_of_t$37,of_a_004),x_005)}
    function t_sexp_grammar$23(a_sexp_grammar)
     {var _xF_=t_sexp_grammar$18(a_sexp_grammar);
      return t_sexp_grammar$21(caml_call1(Sexplib0_Sexp_grammar[1],_xF_))}
    function create$10(len){return create$4(len,none)}
    function init$6(n,f)
     {return init$3(n,function(i){return of_sexpable(caml_call1(f,i))})}
    function init_some(n,f)
     {return init$3(n,function(i){return some$0(caml_call1(f,i))})}
    function get$4(t,i){return to_sexpable(get$3(t,i))}
    function get_some_exn(t,i){return value_exn$0(get$3(t,i))}
    function is_none$1(t,i){return get$3(t,i) === 24791911?1:0}
    function is_some$1(t,i){return is_some$0(get$3(t,i))}
    function set$2(t,i,x){return set$1(t,i,of_sexpable(x))}
    function set_some(t,i,x){return set$1(t,i,some$0(x))}
    function set_none(t,i){return set$1(t,i,none)}
    function swap$4(t,i,j){return swap$3(t,i,j)}
    function unsafe_get$1(t,i){return to_sexpable(t[1 + i])}
    function unsafe_get_some_exn(t,i){return value_exn$0(t[1 + i])}
    function unsafe_get_some_assuming_some(t,i){return value_unsafe(t[1 + i])}
    function unsafe_is_some(t,i){return is_some$0(t[1 + i])}
    function unsafe_set$1(t,i,x){return unsafe_set$0(t,i,of_sexpable(x))}
    function unsafe_set_some(t,i,x){return unsafe_set$0(t,i,some$0(x))}
    function unsafe_set_none(t,i){return unsafe_set$0(t,i,none)}
    function clear(t)
     {var _xD_=t.length - 1 - 1 | 0,_xC_=0;
      if(_xD_ >= 0)
       {var i=_xC_;
        for(;;)
         {unsafe_set_none(t,i);
          var _xE_=i + 1 | 0;
          if(_xD_ !== i){var i=_xE_;continue}
          break}}
      return 0}
    function _dE_(input,f)
     {var _xA_=input.length - 1 - 1 | 0,_xz_=0;
      if(_xA_ >= 0)
       {var i=_xz_;
        for(;;)
         {caml_call2(f,i,unsafe_get$1(input,i));
          var _xB_=i + 1 | 0;
          if(_xA_ !== i){var i=_xB_;continue}
          break}}
      return 0}
    function _dF_(input,f)
     {return _dE_(input,function(param,x){return caml_call1(f,x)})}
    function _dG_(input,init,f)
     {var acc=[0,init];
      _dE_
       (input,function(i,elem){acc[1] = caml_call3(f,i,acc[1],elem);return 0});
      return acc[1]}
    function fold$5(input,init,f)
     {return _dG_
              (input,init,function(param,acc,x){return caml_call2(f,acc,x)})}
    var
     foldi$6=[0,-198771759,_dG_],
     iter$7=[0,-198771759,_dF_],
     iteri$5=[0,-198771759,_dE_],
     length$8=[0,-198771759,length$5],
     include$54=Make_gen$2([0,fold$5,iter$7,length$8,iteri$5,foldi$6]),
     length$9=include$54[1],
     is_empty$4=include$54[2],
     iter$8=include$54[3],
     fold$6=include$54[4],
     fold_result$5=include$54[5],
     fold_until$5=include$54[6],
     exists$6=include$54[7],
     for_all$6=include$54[8],
     count$5=include$54[9],
     sum$5=include$54[10],
     find$6=include$54[11],
     find_map$5=include$54[12],
     to_list$7=include$54[13],
     min_elt$6=include$54[15],
     max_elt$6=include$54[16],
     foldi$7=include$54[17],
     iteri$6=include$54[18],
     existsi$4=include$54[19],
     for_alli$4=include$54[20],
     counti$4=include$54[21],
     findi$4=include$54[22],
     find_mapi$4=include$54[23];
    function map$25(input,f)
     {var output=create$10(caml_call1(length$9,input));
      caml_call2
       (iteri$6,
        input,
        function(i,elem){return unsafe_set$1(output,i,caml_call1(f,elem))});
      return output}
    function map_some(input,f)
     {var
       len=caml_call1(length$9,input),
       output=create$10(len),
       _xx_=len - 1 | 0,
       _xw_=0;
      if(_xx_ >= 0)
       {var i=_xw_;
        for(;;)
         {var t=input[1 + i];
          if(is_some$0(t))
           {var x=value_unsafe(t);unsafe_set_some(output,i,caml_call1(f,x))}
          var _xy_=i + 1 | 0;
          if(_xx_ !== i){var i=_xy_;continue}
          break}}
      return output}
    function of_array$0(array)
     {return init$6(array.length - 1,function(i){return array[1 + i]})}
    function of_array_some(array)
     {return init_some(array.length - 1,function(i){return array[1 + i]})}
    function to_array$6(t)
     {function _xv_(i){return unsafe_get$1(t,i)}
      return caml_call2(init,caml_call1(length$9,t),_xv_)}
    function create_like$1(len,param){return create$10(len)}
    var
     include$55=_a3_([0,create_like$1,length$9,unsafe_blit$5]),
     blit$5=include$55[1],
     blito$3=include$55[2],
     unsafe_blit$8=include$55[3],
     sub$10=include$55[4],
     subo$4=include$55[5],
     Base_Option_array=
      [0,
       t_of_sexp$23,
       sexp_of_t$38,
       t_sexp_grammar$23,
       empty$0,
       create$10,
       length$9,
       is_empty$4,
       iter$8,
       fold$6,
       fold_result$5,
       fold_until$5,
       exists$6,
       for_all$6,
       count$5,
       sum$5,
       find$6,
       find_map$5,
       to_list$7,
       min_elt$6,
       max_elt$6,
       foldi$7,
       iteri$6,
       existsi$4,
       for_alli$4,
       counti$4,
       findi$4,
       find_mapi$4,
       init_some,
       init$6,
       of_array$0,
       of_array_some,
       to_array$6,
       get$4,
       get_some_exn,
       is_none$1,
       is_some$1,
       unsafe_get$1,
       unsafe_get_some_exn,
       unsafe_get_some_assuming_some,
       unsafe_is_some,
       set$2,
       set_some,
       set_none,
       swap$4,
       clear,
       map$25,
       map_some,
       unsafe_set$1,
       unsafe_set_some,
       unsafe_set_none,
       blit$5,
       blito$3,
       unsafe_blit$8,
       sub$10,
       subo$4,
       copy$3,
       [0,
        [0,
         t_of_sexp$22,
         sexp_of_t$37,
         none,
         some$0,
         is_none$0,
         is_some$0,
         value_exn$0,
         value_unsafe,
         to_sexpable,
         of_sexpable]]];
    caml_register_global(1099,Base_Option_array,"Base__Option_array");
    function capacity(t){return caml_call1(length$9,t[2])}
    function invariant$16(invariant_a,t)
     {var length=t[1],elts=t[2];
      try
       {if(0 <= length && length <= caml_call1(length$9,elts))
         {var _xq_=length - 1 | 0,_xp_=0;
          if(_xq_ >= 0)
           {var i$0=_xp_;
            for(;;)
             {caml_call1(invariant_a,get_some_exn(elts,i$0));
              var _xu_=i$0 + 1 | 0;
              if(_xq_ !== i$0){var i$0=_xu_;continue}
              break}}
          var _xr_=caml_call1(length$9,elts) - 1 | 0;
          if(_xr_ >= length)
           {var i=length;
            for(;;)
             {if(is_some$1(elts,i))throw [0,Assert_failure$0,_dJ_];
              var _xt_=i + 1 | 0;
              if(_xr_ !== i){var i=_xt_;continue}
              break}}
          var _xs_=0;
          return _xs_}
        throw [0,Assert_failure$0,_dK_]}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        var
         _xn_=0,
         _xo_=
          [0,
           [0,
            cst_stack,
            function(param)
              {var
                length_003=param[1],
                elts_005=param[2],
                arg_006=sexp_of_t$38(sexp_of_opaque,elts_005),
                bnds_002=[0,[1,[0,_dH_,[0,arg_006,0]]],0],
                arg_004=caml_call1(sexp_of_t$4,length_003),
                bnds_002$0=[0,[1,[0,_dI_,[0,arg_004,0]]],bnds_002];
               return [1,bnds_002$0]}
             (t)],
           _xn_];
        return raise_s
                (caml_call2
                  (message,
                   cst_Stack_invariant_failed,
                   [0,[0,cst_exn$1,caml_call1(sexp_of_exn,exn)],_xo_]))}}
    function create$11(param){return [0,0,empty$0]}
    function length$10(t){return t[1]}
    function is_empty$5(t){return 0 === t[1]?1:0}
    function fold$7(t,init,f)
     {var r=[0,init],_xk_=t[1] - 1 | 0;
      if(_xk_ >= 0)
       {var i=_xk_;
        for(;;)
         {var _xl_=get_some_exn(t[2],i);
          r[1] = caml_call2(f,r[1],_xl_);
          var _xm_=i - 1 | 0;
          if(0 !== i){var i=_xm_;continue}
          break}}
      return r[1]}
    function iter$9(t,f)
     {var _xi_=t[1] - 1 | 0;
      if(_xi_ >= 0)
       {var i=_xi_;
        for(;;)
         {caml_call1(f,get_some_exn(t[2],i));
          var _xj_=i - 1 | 0;
          if(0 !== i){var i=_xj_;continue}
          break}}
      return 0}
    var
     iter$10=[0,-198771759,iter$9],
     length$11=[0,-198771759,length$10],
     C=___([0,fold$7,iter$10,length$11]),
     _dS_=C[14],
     _dL_=C[1],
     _dM_=C[8],
     _dN_=C[9],
     _dO_=C[10],
     _dP_=C[11],
     _dQ_=C[12],
     _dR_=C[13],
     _dT_=C[15],
     _dU_=C[16],
     _dV_=C[17],
     _dW_=C[6],
     _dX_=C[7];
    function of_list$3(l)
     {if(is_empty(l))return create$11(0);
      var
       length$0=caml_call1(length,l),
       elts=create$10(2 * length$0 | 0),
       r=[0,l],
       _xf_=length$0 - 1 | 0;
      if(_xf_ >= 0)
       {var i=_xf_;
        for(;;)
         {var _xg_=r[1];
          if(! _xg_)throw [0,Assert_failure$0,_dY_];
          var l$0=_xg_[2],a=_xg_[1];
          set_some(elts,i,a);
          r[1] = l$0;
          var _xh_=i - 1 | 0;
          if(0 !== i){var i=_xh_;continue}
          break}}
      return [0,length$0,elts]}
    function sexp_of_t$39(sexp_of_a,t)
     {return caml_call2(sexp_of_t$10,sexp_of_a,caml_call1(_dS_,t))}
    function t_of_sexp$24(a_of_sexp,sexp)
     {return of_list$3(caml_call2(t_of_sexp$10,a_of_sexp,sexp))}
    function t_sexp_grammar$24(grammar)
     {var _xe_=t_sexp_grammar$12(grammar);
      return caml_call1(Sexplib0_Sexp_grammar[1],_xe_)}
    function resize(t,size)
     {var arr=create$10(size);
      caml_call5(blit$5,t[2],0,arr,0,t[1]);
      t[2] = arr;
      return 0}
    function set_capacity(t,new_capacity)
     {var
       new_capacity$0=caml_call2(max$2,new_capacity,t[1]),
       _xd_=new_capacity$0 !== capacity(t)?1:0;
      return _xd_?resize(t,new_capacity$0):_xd_}
    function push(t,a)
     {var _xc_=caml_call1(length$9,t[2]);
      if(t[1] === _xc_)resize(t,2 * (t[1] + 1 | 0) | 0);
      set_some(t[2],t[1],a);
      t[1] = t[1] + 1 | 0;
      return 0}
    function pop_nonempty(t)
     {var i=t[1] - 1 | 0,result=get_some_exn(t[2],i);
      set_none(t[2],i);
      t[1] = i;
      return result}
    var pop_error=of_string$2(cst_Stack_pop_of_empty_stack);
    function pop(t){return is_empty$5(t)?0:[0,pop_nonempty(t)]}
    function pop_exn(t){return is_empty$5(t)?raise(pop_error):pop_nonempty(t)}
    function top_nonempty(t){return get_some_exn(t[2],t[1] - 1 | 0)}
    var top_error=of_string$2(cst_Stack_top_of_empty_stack);
    function top(t){return is_empty$5(t)?0:[0,top_nonempty(t)]}
    function top_exn(t){return is_empty$5(t)?raise(top_error):top_nonempty(t)}
    function copy$4(param)
     {var length=param[1],elts=param[2];return [0,length,copy$3(elts)]}
    function clear$0(t)
     {var _w9_=0 < t[1]?1:0;
      if(_w9_)
       {var _w$_=t[1] - 1 | 0,_w__=0;
        if(_w$_ >= 0)
         {var i=_w__;
          for(;;)
           {set_none(t[2],i);
            var _xb_=i + 1 | 0;
            if(_w$_ !== i){var i=_xb_;continue}
            break}}
        t[1] = 0;
        var _xa_=0}
      else
       var _xa_=_w9_;
      return _xa_}
    function until_empty(t,f)
     {for(;;)
       {var _w8_=0 < t[1]?1:0;
        if(! _w8_)return _w8_;
        caml_call1(f,pop_nonempty(t))}}
    function singleton$2(x){var t=create$11(0);push(t,x);return t}
    var
     Base_Stack=
      [0,
       t_of_sexp$24,
       sexp_of_t$39,
       t_sexp_grammar$24,
       invariant$16,
       _dL_,
       length$10,
       is_empty$5,
       iter$9,
       fold$7,
       _dW_,
       _dX_,
       _dM_,
       _dN_,
       _dO_,
       _dP_,
       _dQ_,
       _dR_,
       _dS_,
       _dT_,
       _dU_,
       _dV_,
       of_list$3,
       create$11,
       singleton$2,
       push,
       pop,
       pop_exn,
       top,
       top_exn,
       clear$0,
       copy$4,
       until_empty,
       capacity,
       set_capacity];
    caml_register_global(1100,Base_Stack,"Base__Stack");
    function hash$15(param)
     {var
       pos_cnum=param[4],
       pos_bol=param[3],
       pos_lnum=param[2],
       pos_fname=param[1],
       _w5_=func$8(pos_cnum),
       _w6_=func$8(pos_bol),
       _w7_=func$8(pos_lnum);
      return runtime.Base_hash_string(pos_fname) ^ _w7_ ^ _w6_ ^ _w5_}
    var
     include$56=Make_using_comparator([0,sexp_of_t$15,comparator$0]),
     symbol$146=include$56[1],
     symbol$147=include$56[2],
     symbol$148=include$56[3],
     symbol$149=include$56[4],
     symbol$150=include$56[5],
     symbol$151=include$56[6],
     equal$27=include$56[7],
     compare$41=include$56[8],
     min$27=include$56[9],
     max$27=include$56[10],
     ascending$21=include$56[11],
     descending$21=include$56[12],
     between$7=include$56[13],
     clamp_exn$7=include$56[14],
     clamp$7=include$56[15],
     comparator$9=include$56[16];
    function of_pos(param)
     {var pos_cnum=param[3],pos_lnum=param[2],pos_fname=param[1];
      return [0,pos_fname,pos_lnum,0,pos_cnum]}
    var
     Base_Source_code_position=
      [0,
       hash_fold_t$12,
       hash$15,
       sexp_of_t$15,
       symbol$146,
       symbol$147,
       symbol$148,
       symbol$149,
       symbol$150,
       symbol$151,
       equal$27,
       compare$41,
       min$27,
       max$27,
       ascending$21,
       descending$21,
       between$7,
       clamp_exn$7,
       clamp$7,
       comparator$9,
       to_string$3,
       of_pos];
    caml_register_global
     (1101,Base_Source_code_position,"Base__Source_code_position");
    function t_of_sexp$25(sexp_004)
     {if(0 === sexp_004[0])
       {var _w1_=sexp_004[1],switch$0=0;
        if(caml_string_notequal(_w1_,cst_Nan))
         {var switch$1=0;
          if(caml_string_notequal(_w1_,cst_Neg$1))
           {var switch$2=0;
            if(caml_string_notequal(_w1_,cst_Pos$1))
             {var switch$3=0;
              if(caml_string_notequal(_w1_,cst_Zero$1))
               if(caml_string_notequal(_w1_,cst_nan))
                if(caml_string_notequal(_w1_,cst_neg$1))
                 if(caml_string_notequal(_w1_,cst_pos$3))
                  {if(caml_string_notequal(_w1_,cst_zero$1))
                    {switch$0 = 1;switch$1 = 1;switch$2 = 1;switch$3 = 1}}
                 else
                  switch$3 = 1;
                else
                 {switch$2 = 1;switch$3 = 1}
               else
                {switch$1 = 1;switch$2 = 1;switch$3 = 1}
              if(! switch$3)return 1}
            if(! switch$2)return 2}
          if(! switch$1)return 0}
        if(! switch$0)return 3}
      else
       {var _w2_=sexp_004[1];
        if(! _w2_)
         return caml_call2
                 (Sexplib0_Sexp_conv_error[7],error_source_003$0,sexp_004);
        var _w3_=_w2_[1];
        if(0 !== _w3_[0])
         return caml_call2
                 (Sexplib0_Sexp_conv_error[6],error_source_003$0,sexp_004);
        var _w4_=_w3_[1],switch$4=0;
        if(caml_string_notequal(_w4_,cst_Nan$0))
         {var switch$5=0;
          if(caml_string_notequal(_w4_,cst_Neg$2))
           {var switch$6=0;
            if(caml_string_notequal(_w4_,cst_Pos$2))
             {var switch$7=0;
              if(caml_string_notequal(_w4_,cst_Zero$2))
               if(caml_string_notequal(_w4_,cst_nan$0))
                if(caml_string_notequal(_w4_,cst_neg$2))
                 if(caml_string_notequal(_w4_,cst_pos$4))
                  {if(caml_string_notequal(_w4_,cst_zero$2))
                    {switch$4 = 1;switch$5 = 1;switch$6 = 1;switch$7 = 1}}
                 else
                  switch$7 = 1;
                else
                 {switch$6 = 1;switch$7 = 1}
               else
                {switch$5 = 1;switch$6 = 1;switch$7 = 1}
              if(! switch$7)
               return caml_call2
                       (Sexplib0_Sexp_conv_error[3],error_source_003$0,sexp_004)}
            if(! switch$6)
             return caml_call2
                     (Sexplib0_Sexp_conv_error[3],error_source_003$0,sexp_004)}
          if(! switch$5)
           return caml_call2
                   (Sexplib0_Sexp_conv_error[3],error_source_003$0,sexp_004)}
        if(! switch$4)
         return caml_call2
                 (Sexplib0_Sexp_conv_error[3],error_source_003$0,sexp_004)}
      return caml_call2
              (Sexplib0_Sexp_conv_error[8],error_source_003$0,sexp_004)}
    function sexp_of_t$40(param)
     {switch(param)
       {case 0:return _dZ_;
        case 1:return _d0_;
        case 2:return _d1_;
        default:return _d2_}}
    var compare$42=caml_int_compare;
    function hash_fold_t$25(hsv,arg)
     {switch(arg)
       {case 0:return runtime.Base_internalhash_fold_int(hsv,0);
        case 1:return runtime.Base_internalhash_fold_int(hsv,1);
        case 2:return runtime.Base_internalhash_fold_int(hsv,2);
        default:return runtime.Base_internalhash_fold_int(hsv,3)}}
    function hash$16(x)
     {var hsv=create$0(0,0);
      return runtime.Base_internalhash_get_hash_value(hash_fold_t$25(hsv,x))}
    function of_string$11(s){return t_of_sexp$25(caml_call1(sexp_of_t$2,s))}
    function to_string$12(t){return caml_call1(t_of_sexp$2,sexp_of_t$40(t))}
    function symbol$152(x,y){return x < y?1:0}
    function symbol$153(x,y){return x <= y?1:0}
    function symbol$154(x,y){return x !== y?1:0}
    function symbol$155(x,y){return x === y?1:0}
    function symbol$156(x,y){return y < x?1:0}
    function symbol$157(x,y){return y <= x?1:0}
    var ascending$22=caml_compare;
    function descending$22(x,y){return caml_compare(y,x)}
    var compare$43=caml_int_compare;
    function equal$28(x,y){return x === y?1:0}
    function max$28(x,y){return y <= x?x:y}
    function min$28(x,y){return x <= y?x:y}
    var
     _d3_=
      _a1_
       ([0,
         compare$42,
         hash_fold_t$25,
         hash$16,
         t_of_sexp$25,
         sexp_of_t$40,
         of_string$11,
         to_string$12,
         module_name$9]),
     hash_fold_t$26=_d3_[1],
     hash$17=_d3_[2],
     t_of_sexp$26=_d3_[3],
     sexp_of_t$41=_d3_[4],
     of_string$12=_d3_[5],
     to_string$13=_d3_[6],
     between$8=_d3_[19],
     clamp_exn$8=_d3_[20],
     clamp$8=_d3_[21],
     comparator$10=_d3_[22],
     pp$13=_d3_[23],
     hashable$4=_d3_[24];
    function of_sign(param)
     {switch(param){case 0:return 0;case 1:return 1;default:return 2}}
    function to_sign_exn(param)
     {switch(param)
       {case 0:return 0;
        case 1:return 1;
        case 2:return 2;
        default:
         return caml_call1(invalid_arg$0,cst_Base_Sign_or_nan_to_sign_e)}}
    function of_int$4(n){return of_sign(sign(n))}
    function to_int_exn$0(t){return to_int$1(to_sign_exn(t))}
    function flip$1(param)
     {switch(param)
       {case 0:return 2;case 1:return 1;case 2:return 0;default:return 3}}
    function symbol$158(t$0,t)
     {if(3 > t$0 && 3 > t)
       {var _w0_=to_sign_exn(t);
        return of_sign(symbol$128(to_sign_exn(t$0),_w0_))}
      return 3}
    var
     Base_Sign_or_nan=
      [0,
       all$14,
       t_sexp_grammar$25,
       hash_fold_t$26,
       hash$17,
       t_of_sexp$26,
       sexp_of_t$41,
       of_string$12,
       to_string$13,
       symbol$157,
       symbol$153,
       symbol$155,
       symbol$156,
       symbol$152,
       symbol$154,
       equal$28,
       compare$43,
       min$28,
       max$28,
       ascending$22,
       descending$22,
       between$8,
       clamp_exn$8,
       clamp$8,
       comparator$10,
       pp$13,
       hashable$4,
       of_int$4,
       to_int_exn$0,
       of_sign,
       to_sign_exn,
       flip$1,
       symbol$158];
    caml_register_global(1102,Base_Sign_or_nan,"Base__Sign_or_nan");
    var
     include$57=Make$1([0,compare$7,sexp_of_t]),
     symbol$159=include$57[1],
     symbol$160=include$57[2],
     symbol$161=include$57[3],
     symbol$162=include$57[4],
     symbol$163=include$57[5],
     symbol$164=include$57[6],
     equal$29=include$57[7],
     compare$44=include$57[8],
     min$29=include$57[9],
     max$29=include$57[10],
     ascending$23=include$57[11],
     descending$23=include$57[12],
     between$9=include$57[13],
     clamp_exn$9=include$57[14],
     clamp$9=include$57[15],
     comparator$11=include$57[16],
     include$58=
      [0,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       Not_found_s,
       Of_sexp_error,
       message,
       default_indent,
       pp_hum,
       pp_hum_indent,
       pp_mach,
       pp,
       to_string_hum,
       to_string_mach,
       to_string$0,
       of_float_style,
       of_int_style,
       t_sexp_grammar,
       invariant,
       of_string$0,
       symbol$159,
       symbol$160,
       symbol$161,
       symbol$162,
       symbol$163,
       symbol$164,
       equal$29,
       compare$44,
       min$29,
       max$29,
       ascending$23,
       descending$23,
       between$9,
       clamp_exn$9,
       clamp$9,
       comparator$11];
    caml_register_global(1103,include$58,"Base__Sexp_with_comparable");
    var Base_Hasher=[0];
    caml_register_global(1104,Base_Hasher,"Base__Hasher");
    function all$15(all_of_a)
     {var l=all_of_a,acc=0;
      for(;;)
       {if(l)
         {var
           l$0=l[2],
           enumerate_002=l[1],
           acc$0=[0,[1,enumerate_002],acc],
           l=l$0,
           acc=acc$0;
          continue}
        var l$1=all_of_a,acc$1=0,_wZ_=append$0(rev(acc),_d4_);
        for(;;)
         {if(! l$1)return append$0(rev(acc$1),_wZ_);
          var
           l$2=l$1[2],
           enumerate_001=l$1[1],
           acc$2=[0,[0,enumerate_001],acc$1],
           l$1=l$2,
           acc$1=acc$2}}}
    function t_of_sexp$27(of_a_003,sexp_008)
     {if(0 === sexp_008[0])
       {var _wV_=sexp_008[1],switch$0=0;
        if(caml_string_notequal(_wV_,cst_Excl))
         {var switch$1=0;
          if(caml_string_notequal(_wV_,cst_Incl))
           {var switch$2=0;
            if(caml_string_notequal(_wV_,cst_Unbounded))
             if(caml_string_notequal(_wV_,cst_excl))
              if(caml_string_notequal(_wV_,cst_incl))
               {if(caml_string_notequal(_wV_,cst_unbounded))
                 {switch$0 = 1;switch$1 = 1;switch$2 = 1}}
              else
               switch$2 = 1;
             else
              {switch$1 = 1;switch$2 = 1}
            if(! switch$2)return 0}
          if(! switch$1)
           return caml_call2
                   (Sexplib0_Sexp_conv_error[5],error_source_006,sexp_008)}
        if(! switch$0)
         return caml_call2
                 (Sexplib0_Sexp_conv_error[5],error_source_006,sexp_008)}
      else
       {var _wW_=sexp_008[1];
        if(! _wW_)
         return caml_call2
                 (Sexplib0_Sexp_conv_error[7],error_source_006,sexp_008);
        var _wX_=_wW_[1];
        if(0 !== _wX_[0])
         return caml_call2
                 (Sexplib0_Sexp_conv_error[6],error_source_006,sexp_008);
        var _wY_=_wX_[1],switch$3=0;
        if(caml_string_notequal(_wY_,cst_Excl$0))
         {var switch$4=0;
          if(caml_string_notequal(_wY_,cst_Incl$0))
           {var switch$5=0;
            if(caml_string_notequal(_wY_,cst_Unbounded$0))
             if(caml_string_notequal(_wY_,cst_excl$0))
              if(caml_string_notequal(_wY_,cst_incl$0))
               {if(caml_string_notequal(_wY_,cst_unbounded$0))
                 {switch$3 = 1;switch$4 = 1;switch$5 = 1}}
              else
               switch$5 = 1;
             else
              {switch$4 = 1;switch$5 = 1}
            if(! switch$5)
             return caml_call2
                     (Sexplib0_Sexp_conv_error[3],error_source_006,sexp_008)}
          if(! switch$4)
           {var sexp_args_010=_wW_[2];
            if(sexp_args_010 && ! sexp_args_010[2])
             {var
               arg0_011=sexp_args_010[1],
               res0_012=caml_call1(of_a_003,arg0_011);
              return [0,res0_012]}
            return caml_call3
                    (Sexplib0_Sexp_conv_error[4],error_source_006,_wY_,sexp_008)}}
        if(! switch$3)
         {var sexp_args_015=_wW_[2];
          if(sexp_args_015 && ! sexp_args_015[2])
           {var
             arg0_016=sexp_args_015[1],
             res0_017=caml_call1(of_a_003,arg0_016);
            return [1,res0_017]}
          return caml_call3
                  (Sexplib0_Sexp_conv_error[4],error_source_006,_wY_,sexp_008)}}
      return caml_call2(Sexplib0_Sexp_conv_error[8],error_source_006,sexp_008)}
    function sexp_of_t$42(of_a_019,param)
     {if(typeof param === "number")return _d5_;
      if(0 === param[0])
       {var arg0_020=param[1],res0_021=caml_call1(of_a_019,arg0_020);
        return [1,[0,_d6_,[0,res0_021,0]]]}
      var arg0_022=param[1],res0_023=caml_call1(of_a_019,arg0_022);
      return [1,[0,_d7_,[0,res0_023,0]]]}
    function t_sexp_grammar$26(a_sexp_grammar)
     {return [3,
              [0,
               2,
               [0,
                [1,[0,cst_Incl$1,[0,[0,a_sexp_grammar,0]]]],
                [0,[1,[0,cst_Excl$1,[0,[0,a_sexp_grammar,0]]]],_d8_]]]]}
    function interval_comparison_of_sexp(sexp_028)
     {if(0 === sexp_028[0])
       {var _wR_=sexp_028[1],switch$0=0;
        if(caml_string_notequal(_wR_,cst_Above_upper_bound))
         {var switch$1=0;
          if(caml_string_notequal(_wR_,cst_Below_lower_bound))
           {var switch$2=0;
            if(caml_string_notequal(_wR_,cst_In_range))
             if(caml_string_notequal(_wR_,cst_above_upper_bound))
              if(caml_string_notequal(_wR_,cst_below_lower_bound))
               {if(caml_string_notequal(_wR_,cst_in_range))
                 {switch$0 = 1;switch$1 = 1;switch$2 = 1}}
              else
               switch$2 = 1;
             else
              {switch$1 = 1;switch$2 = 1}
            if(! switch$2)return 1}
          if(! switch$1)return 0}
        if(! switch$0)return 2}
      else
       {var _wS_=sexp_028[1];
        if(! _wS_)
         return caml_call2
                 (Sexplib0_Sexp_conv_error[7],error_source_027,sexp_028);
        var _wT_=_wS_[1];
        if(0 !== _wT_[0])
         return caml_call2
                 (Sexplib0_Sexp_conv_error[6],error_source_027,sexp_028);
        var _wU_=_wT_[1],switch$3=0;
        if(caml_string_notequal(_wU_,cst_Above_upper_bound$0))
         {var switch$4=0;
          if(caml_string_notequal(_wU_,cst_Below_lower_bound$0))
           {var switch$5=0;
            if(caml_string_notequal(_wU_,cst_In_range$0))
             if(caml_string_notequal(_wU_,cst_above_upper_bound$0))
              if(caml_string_notequal(_wU_,cst_below_lower_bound$0))
               {if(caml_string_notequal(_wU_,cst_in_range$0))
                 {switch$3 = 1;switch$4 = 1;switch$5 = 1}}
              else
               switch$5 = 1;
             else
              {switch$4 = 1;switch$5 = 1}
            if(! switch$5)
             return caml_call2
                     (Sexplib0_Sexp_conv_error[3],error_source_027,sexp_028)}
          if(! switch$4)
           return caml_call2
                   (Sexplib0_Sexp_conv_error[3],error_source_027,sexp_028)}
        if(! switch$3)
         return caml_call2
                 (Sexplib0_Sexp_conv_error[3],error_source_027,sexp_028)}
      return caml_call2(Sexplib0_Sexp_conv_error[8],error_source_027,sexp_028)}
    function sexp_of_interval_comparison(param)
     {switch(param){case 0:return _d9_;case 1:return _d__;default:return _d$_}}
    var compare_interval_comparison=caml_int_compare;
    function hash_fold_interval_comparison(hsv,arg)
     {switch(arg)
       {case 0:return runtime.Base_internalhash_fold_int(hsv,0);
        case 1:return runtime.Base_internalhash_fold_int(hsv,1);
        default:return runtime.Base_internalhash_fold_int(hsv,2)}}
    function hash_interval_comparison(x)
     {var hsv=create$0(0,0);
      return runtime.Base_internalhash_get_hash_value
              (hash_fold_interval_comparison(hsv,x))}
    function map$26(t,f)
     {if(typeof t === "number")return 0;
      if(0 === t[0]){var incl=t[1];return [0,caml_call1(f,incl)]}
      var excl=t[1];
      return [1,caml_call1(f,excl)]}
    function is_lower_bound(t,a,compare)
     {if(typeof t === "number")return 1;
      if(0 === t[0]){var incl=t[1];return caml_call2(compare,incl,a) <= 0?1:0}
      var excl=t[1];
      return caml_call2(compare,excl,a) < 0?1:0}
    function is_upper_bound(t,a,compare)
     {if(typeof t === "number")return 1;
      if(0 === t[0]){var incl=t[1];return caml_call2(compare,a,incl) <= 0?1:0}
      var excl=t[1];
      return caml_call2(compare,a,excl) < 0?1:0}
    function bounds_crossed(lower,upper,compare)
     {if(typeof lower === "number")return 0;
      var lower$0=lower[1];
      if(typeof upper === "number")return 0;
      var upper$0=upper[1];
      return 0 < caml_call2(compare,lower$0,upper$0)?1:0}
    function compare_to_interval_exn(lower,upper,a,compare)
     {if(bounds_crossed(lower,upper,compare))
       caml_call1(failwith$0,cst_Maybe_bound_compare_to_int);
      return is_lower_bound(lower,a,compare)
              ?is_upper_bound(upper,a,compare)?1:2
              :0}
    function interval_contains_exn(lower,upper,a,compare)
     {var match=compare_to_interval_exn(lower,upper,a,compare);
      return 1 === match?1:0}
    var
     Base_Maybe_bound=
      [0,
       all$15,
       t_of_sexp$27,
       sexp_of_t$42,
       t_sexp_grammar$26,
       map$26,
       is_lower_bound,
       is_upper_bound,
       interval_contains_exn,
       bounds_crossed,
       sexp_of_interval_comparison,
       interval_comparison_of_sexp,
       interval_comparison_sexp_gramm,
       compare_interval_comparison,
       hash_fold_interval_comparison,
       hash_interval_comparison,
       compare_to_interval_exn];
    caml_register_global(1105,Base_Maybe_bound,"Base__Maybe_bound");
    function compare$45(cmp_a,a_001,b_002)
     {if(a_001 === b_002)return 0;
      if(typeof a_001 === "number")
       {if(-1024851605 === b_002)return 0}
      else
       if(typeof b_002 !== "number" && 17724 === b_002[1])
        {var right_004=b_002[2],left_003=a_001[2];
         return caml_call2(cmp_a,left_003,right_004)}
      return caml_compare(a_001,b_002)}
    function equal$30(cmp_a,a_005,b_006)
     {if(a_005 === b_006)return 1;
      if(typeof a_005 === "number")
       {if(-1024851605 === b_006)return 1}
      else
       if(typeof b_006 !== "number" && 17724 === b_006[1])
        {var right_008=b_006[2],left_007=a_005[2];
         return caml_call2(cmp_a,left_007,right_008)}
      return caml_equal(a_005,b_006)}
    function sexp_of_t$43(of_a_009,param)
     {if(typeof param === "number")return _ea_;
      var v_010=param[2];
      return [1,[0,_eb_,[0,caml_call1(of_a_009,v_010),0]]]}
    var
     Or_duplicate=[0,compare$45,equal$30,sexp_of_t$43],
     Without_comparator=[0],
     With_comparator=[0],
     With_first_class_module=[0];
    function compare$46(cmp_k,cmp_v,a_011,b_012)
     {var
       t_014=a_011[2],
       t_013=a_011[1],
       t_016=b_012[2],
       t_015=b_012[1],
       n=caml_call2(cmp_k,t_013,t_015);
      if(0 !== n)return n;
      if(t_014 === t_016)return 0;
      var _wQ_=t_014[1];
      if(847852583 === _wQ_)
       {if(typeof t_016 !== "number" && 847852583 === t_016[1])
         {var right_018=t_016[2],left_017=t_014[2];
          return caml_call2(cmp_v,left_017,right_018)}}
      else
       if(1013247643 <= _wQ_)
        {if(typeof t_016 !== "number" && 1013247643 === t_016[1])
          {var
            right_022=t_016[2],
            left_021=t_014[2],
            t_024=left_021[2],
            t_023=left_021[1],
            t_026=right_022[2],
            t_025=right_022[1],
            n$0=caml_call2(cmp_v,t_023,t_025);
           return 0 === n$0?caml_call2(cmp_v,t_024,t_026):n$0}}
       else
        if(typeof t_016 !== "number" && -57574468 === t_016[1])
         {var right_020=t_016[2],left_019=t_014[2];
          return caml_call2(cmp_v,left_019,right_020)}
      return caml_compare(t_014,t_016)}
    function equal$31(cmp_k,cmp_v,a_027,b_028)
     {var
       t_030=a_027[2],
       t_029=a_027[1],
       t_032=b_028[2],
       t_031=b_028[1],
       _wM_=caml_call2(cmp_k,t_029,t_031);
      if(_wM_)
       {if(t_030 === t_032)return 1;
        var _wN_=t_030[1];
        if(847852583 === _wN_)
         {if(typeof t_032 !== "number" && 847852583 === t_032[1])
           {var right_034=t_032[2],left_033=t_030[2];
            return caml_call2(cmp_v,left_033,right_034)}}
        else
         if(1013247643 <= _wN_)
          {if(typeof t_032 !== "number" && 1013247643 === t_032[1])
            {var
              right_038=t_032[2],
              left_037=t_030[2],
              t_040=left_037[2],
              t_039=left_037[1],
              t_042=right_038[2],
              t_041=right_038[1],
              _wP_=caml_call2(cmp_v,t_039,t_041);
             return _wP_?caml_call2(cmp_v,t_040,t_042):_wP_}}
         else
          if(typeof t_032 !== "number" && -57574468 === t_032[1])
           {var right_036=t_032[2],left_035=t_030[2];
            return caml_call2(cmp_v,left_035,right_036)}
        var _wO_=caml_equal(t_030,t_032)}
      else
       var _wO_=_wM_;
      return _wO_}
    function t_of_sexp$28(of_k_043,of_v_044,sexp_071)
     {if(1 === sexp_071[0])
       {var _wx_=sexp_071[1];
        if(_wx_)
         {var _wy_=_wx_[2];
          if(_wy_ && ! _wy_[2])
           {var
             arg1_068=_wy_[1],
             arg0_067=_wx_[1],
             res0_069=caml_call1(of_k_043,arg0_067);
            try
             {if(0 === arg1_068[0])
               var
                atom_047=arg1_068[1],
                _wz_=
                 caml_string_notequal(atom_047,cst_Left$2)
                  ?caml_string_notequal(atom_047,cst_Right$2)
                    ?caml_string_notequal(atom_047,cst_Unequal)
                      ?caml_call1(Sexplib0_Sexp_conv_error[19],0)
                      :caml_call2
                        (Sexplib0_Sexp_conv_error[23],error_source_057,arg1_068)
                    :caml_call2
                      (Sexplib0_Sexp_conv_error[23],error_source_057,arg1_068)
                  :caml_call2
                    (Sexplib0_Sexp_conv_error[23],error_source_057,arg1_068),
                _wA_=_wz_;
              else
               {var _wB_=arg1_068[1];
                if(_wB_)
                 {var _wC_=_wB_[1];
                  if(0 === _wC_[0])
                   {var sexp_args_050=_wB_[2],atom_047$0=_wC_[1];
                    if(caml_string_notequal(atom_047$0,cst_Left$3))
                     if(caml_string_notequal(atom_047$0,cst_Right$3))
                      if(caml_string_notequal(atom_047$0,cst_Unequal$0))
                       var _wD_=caml_call1(Sexplib0_Sexp_conv_error[19],0);
                      else
                       {var switch$0=0;
                        if(sexp_args_050 && ! sexp_args_050[2])
                         {var arg0_058=sexp_args_050[1],switch$1=0;
                          if(1 === arg0_058[0])
                           {var _wH_=arg0_058[1];
                            if(_wH_)
                             {var _wI_=_wH_[2];
                              if(_wI_ && ! _wI_[2])
                               {var
                                 arg1_053=_wI_[1],
                                 arg0_052=_wH_[1],
                                 res0_054=caml_call1(of_v_044,arg0_052),
                                 res1_055=caml_call1(of_v_044,arg1_053),
                                 res0_059=[0,res0_054,res1_055];
                                switch$1 = 1}}}
                          if(! switch$1)
                           var
                            res0_059=
                             caml_call3
                              (Sexplib0_Sexp_conv_error[2],error_source_057,2,arg0_058);
                          var _wG_=[0,1013247643,res0_059];
                          switch$0 = 1}
                        if(! switch$0)
                         var
                          _wG_=
                           caml_call3
                            (Sexplib0_Sexp_conv_error[22],
                             error_source_057,
                             atom_047$0,
                             arg1_068);
                        var _wD_=_wG_}
                     else
                      {var switch$2=0;
                       if(sexp_args_050 && ! sexp_args_050[2])
                        {var
                          arg0_061=sexp_args_050[1],
                          res0_062=caml_call1(of_v_044,arg0_061),
                          _wJ_=[0,-57574468,res0_062];
                         switch$2 = 1}
                       if(! switch$2)
                        var
                         _wJ_=
                          caml_call3
                           (Sexplib0_Sexp_conv_error[22],
                            error_source_057,
                            atom_047$0,
                            arg1_068);
                       var _wD_=_wJ_}
                    else
                     {var switch$3=0;
                      if(sexp_args_050 && ! sexp_args_050[2])
                       {var
                         arg0_064=sexp_args_050[1],
                         res0_065=caml_call1(of_v_044,arg0_064),
                         _wK_=[0,847852583,res0_065];
                        switch$3 = 1}
                      if(! switch$3)
                       var
                        _wK_=
                         caml_call3
                          (Sexplib0_Sexp_conv_error[22],
                           error_source_057,
                           atom_047$0,
                           arg1_068);
                      var _wD_=_wK_}
                    var _wE_=_wD_}
                  else
                   var
                    _wE_=
                     caml_call2
                      (Sexplib0_Sexp_conv_error[24],error_source_057,arg1_068);
                  var _wF_=_wE_}
                else
                 var
                  _wF_=
                   caml_call2
                    (Sexplib0_Sexp_conv_error[25],error_source_057,arg1_068);
                var _wA_=_wF_}
              var res1_070=_wA_}
            catch(_wL_)
             {_wL_ = caml_wrap_exception(_wL_);
              if(_wL_ !== Sexplib0_Sexp_conv_error[18])throw _wL_;
              var
               res1_070=
                caml_call2
                 (Sexplib0_Sexp_conv_error[20],error_source_057,arg1_068)}
            return [0,res0_069,res1_070]}}}
      return caml_call3
              (Sexplib0_Sexp_conv_error[2],error_source_057,2,sexp_071)}
    function sexp_of_t$44(of_k_072,of_v_073,param)
     {var
       arg1_082=param[2],
       arg0_081=param[1],
       res0_083=caml_call1(of_k_072,arg0_081),
       _ww_=arg1_082[1];
      if(847852583 === _ww_)
       var
        v_074=arg1_082[2],
        res1_084=[1,[0,_ec_,[0,caml_call1(of_v_073,v_074),0]]];
      else
       if(1013247643 <= _ww_)
        var
         v_076=arg1_082[2],
         arg1_078=v_076[2],
         arg0_077=v_076[1],
         res0_079=caml_call1(of_v_073,arg0_077),
         res1_080=caml_call1(of_v_073,arg1_078),
         res1_084=[1,[0,_ed_,[0,[1,[0,res0_079,[0,res1_080,0]]],0]]];
       else
        var
         v_075=arg1_082[2],
         res1_084=[1,[0,_ee_,[0,caml_call1(of_v_073,v_075),0]]];
      return [1,[0,res0_083,[0,res1_084,0]]]}
    function t_sexp_grammar$27(k_sexp_grammar,v_sexp_grammar)
     {return [2,
              [0,
               k_sexp_grammar,
               [0,
                [3,
                 [0,
                  1,
                  [0,
                   [1,[0,cst_Left$4,[0,[0,v_sexp_grammar,0]]]],
                   [0,
                    [1,[0,cst_Right$4,[0,[0,v_sexp_grammar,0]]]],
                    [0,
                     [1,
                      [0,
                       cst_Unequal$1,
                       [0,[0,[2,[0,v_sexp_grammar,[0,v_sexp_grammar,0]]],0]]]],
                     0]]]]],
                0]]]}
    var
     Symmetric_diff_element=
      [0,compare$46,equal$31,t_of_sexp$28,sexp_of_t$44,t_sexp_grammar$27];
    function compare$47(cmp_left,cmp_right,a_085,b_086)
     {if(a_085 === b_086)return 0;
      var _wv_=a_085[1];
      if(737457313 === _wv_)
       {if(typeof b_086 !== "number" && 737457313 === b_086[1])
         {var
           right_092=b_086[2],
           left_091=a_085[2],
           t_094=left_091[2],
           t_093=left_091[1],
           t_096=right_092[2],
           t_095=right_092[1],
           n=caml_call2(cmp_left,t_093,t_095);
          return 0 === n?caml_call2(cmp_right,t_094,t_096):n}}
      else
       if(847852583 <= _wv_)
        {if(typeof b_086 !== "number" && 847852583 === b_086[1])
          {var right_088=b_086[2],left_087=a_085[2];
           return caml_call2(cmp_left,left_087,right_088)}}
       else
        if(typeof b_086 !== "number" && -57574468 === b_086[1])
         {var right_090=b_086[2],left_089=a_085[2];
          return caml_call2(cmp_right,left_089,right_090)}
      return caml_compare(a_085,b_086)}
    function equal$32(cmp_left,cmp_right,a_097,b_098)
     {if(a_097 === b_098)return 1;
      var _wt_=a_097[1];
      if(737457313 === _wt_)
       {if(typeof b_098 !== "number" && 737457313 === b_098[1])
         {var
           right_104=b_098[2],
           left_103=a_097[2],
           t_106=left_103[2],
           t_105=left_103[1],
           t_108=right_104[2],
           t_107=right_104[1],
           _wu_=caml_call2(cmp_left,t_105,t_107);
          return _wu_?caml_call2(cmp_right,t_106,t_108):_wu_}}
      else
       if(847852583 <= _wt_)
        {if(typeof b_098 !== "number" && 847852583 === b_098[1])
          {var right_100=b_098[2],left_099=a_097[2];
           return caml_call2(cmp_left,left_099,right_100)}}
       else
        if(typeof b_098 !== "number" && -57574468 === b_098[1])
         {var right_102=b_098[2],left_101=a_097[2];
          return caml_call2(cmp_right,left_101,right_102)}
      return caml_equal(a_097,b_098)}
    function sexp_of_t$45(of_left_109,of_right_110,param)
     {var _ws_=param[1];
      if(737457313 === _ws_)
       {var
         v_113=param[2],
         arg1_115=v_113[2],
         arg0_114=v_113[1],
         res0_116=caml_call1(of_left_109,arg0_114),
         res1_117=caml_call1(of_right_110,arg1_115);
        return [1,[0,_ef_,[0,[1,[0,res0_116,[0,res1_117,0]]],0]]]}
      if(847852583 <= _ws_)
       {var v_111=param[2];
        return [1,[0,_eg_,[0,caml_call1(of_left_109,v_111),0]]]}
      var v_112=param[2];
      return [1,[0,_eh_,[0,caml_call1(of_right_110,v_112),0]]]}
    var
     include$59=[0,compare$47,equal$32,sexp_of_t$45],
     compare$48=caml_int_compare;
    function equal$33(_wr_,_wq_){return _wr_ === _wq_?1:0}
    function sexp_of_t$46(param){return param?_ei_:_ej_}
    var
     Continue_or_stop$1=[0,compare$48,all$16,equal$33,sexp_of_t$46],
     compare$49=caml_int_compare;
    function equal$34(_wp_,_wo_){return _wp_ === _wo_?1:0}
    function sexp_of_t$47(param){return param?_ek_:_el_}
    var include$60=[0,compare$49,all$17,equal$34,sexp_of_t$47];
    function Check_accessors(T,Tree,Key,Cmp,Options,symbol){return [0]}
    function Check_accessors1(M){return [0]}
    function Check_accessors2(M){return [0]}
    function Check_accessors3(M){return [0]}
    function Check_accessors3_with_comparat(M){return [0]}
    function Check_creators(T,Tree,Key,Cmp,Options,symbol){return [0]}
    function Check_creators1(M){return [0]}
    function Check_creators2(M){return [0]}
    function Check_creators3_with_comparato(M){return [0]}
    var
     include$61=
      [0,
       Or_duplicate,
       Without_comparator,
       With_comparator,
       With_first_class_module,
       Symmetric_diff_element,
       include$59,
       Continue_or_stop$1,
       include$60,
       Check_accessors,
       Check_accessors1,
       Check_accessors2,
       Check_accessors3,
       Check_accessors3_with_comparat,
       Check_creators,
       Check_creators1,
       Check_creators2,
       Check_creators3_with_comparato];
    caml_register_global(1106,include$61,"Base__Map_intf");
    function Check_accessors$0(T,Tree,Elt,Named,Cmp,Options,symbol)
     {return [0]}
    function Check_accessors0(M){return [0]}
    function Check_accessors1$0(M){return [0]}
    function Check_accessors2$0(M){return [0]}
    function Check_accessors2_with_comparat(M){return [0]}
    function Check_creators$0(T,Tree,Elt,Cmp,Options,symbol){return [0]}
    function Check_creators0(M){return [0]}
    function Check_creators1$0(M){return [0]}
    function Check_creators2$0(M){return [0]}
    function Check_creators2_with_comparato(M){return [0]}
    var
     Base_Set_intf=
      [0,
       Check_accessors$0,
       Check_accessors0,
       Check_accessors1$0,
       Check_accessors2$0,
       Check_accessors2_with_comparat,
       Check_creators$0,
       Check_creators0,
       Check_creators1$0,
       Check_creators2$0,
       Check_creators2_with_comparato];
    caml_register_global(1107,Base_Set_intf,"Base__Set_intf");
    function height(param)
     {if(typeof param === "number")return 0;
      if(0 === param[0])return 1;
      var h=param[4];
      return h}
    function length$12(param)
     {if(typeof param === "number")return 0;
      if(0 === param[0])return 1;
      var s=param[5];
      return s}
    function in_range(lower,upper,compare_elt,v)
     {if(lower)
       var lower$0=lower[1],_wm_=caml_call2(compare_elt,lower$0,v) < 0?1:0;
      else
       var _wm_=1;
      if(_wm_)
       {if(upper)
         {var upper$0=upper[1];
          return caml_call2(compare_elt,v,upper$0) < 0?1:0}
        var _wn_=1}
      else
       var _wn_=_wm_;
      return _wn_}
    function loop(lower,upper,compare_elt,t)
     {var lower$0=lower,t$0=t;
      for(;;)
       {if(typeof t$0 === "number")return 1;
        if(0 === t$0[0])
         {var v=t$0[1];return in_range(lower$0,upper,compare_elt,v)}
        var
         n=t$0[5],
         h=t$0[4],
         r=t$0[3],
         v$0=t$0[2],
         l=t$0[1],
         hl=height(l),
         hr=height(r),
         _wf_=caml_call1(abs$0,hl - hr | 0) <= 2?1:0;
        if(_wf_)
         {var _wg_=h === (caml_call2(max$2,hl,hr) + 1 | 0)?1:0;
          if(_wg_)
           {var
             _wh_=length$12(r),
             _wi_=n === ((length$12(l) + _wh_ | 0) + 1 | 0)?1:0;
            if(_wi_)
             {var _wj_=in_range(lower$0,upper,compare_elt,v$0);
              if(_wj_)
               {var _wk_=loop(lower$0,[0,v$0],compare_elt,l);
                if(_wk_){var lower$1=[0,v$0],lower$0=lower$1,t$0=r;continue}
                var _wl_=_wk_}
              else
               var _wl_=_wj_}
            else
             var _wl_=_wi_}
          else
           var _wl_=_wg_}
        else
         var _wl_=_wf_;
        return _wl_}}
    function invariants(t,compare_elt){return loop(0,0,compare_elt,t)}
    function is_empty$6(param){return typeof param === "number"?1:0}
    function create$12(l,v,r)
     {if(typeof l === "number")
       var hl=0;
      else
       if(0 === l[0])var hl=1;else var h$1=l[4],hl=h$1;
      if(typeof r === "number")
       var hr=0;
      else
       if(0 === r[0])var hr=1;else var h$0=r[4],hr=h$0;
      var h=hr <= hl?hl + 1 | 0:hr + 1 | 0;
      if(1 === h)return [0,v];
      if(typeof l === "number")
       var sl=0;
      else
       if(0 === l[0])var sl=1;else var s$0=l[5],sl=s$0;
      if(typeof r === "number")
       var sr=0;
      else
       if(0 === r[0])var sr=1;else var s=r[5],sr=s;
      return [1,l,v,r,h,(sl + sr | 0) + 1 | 0]}
    function of_increasing_iterator_uncheck(len,f)
     {function loop(n,f,i)
       {if(3 >= n >>> 0)
         switch(n)
          {case 0:return 0;
           case 1:var k$0=caml_call1(f,i);return [0,k$0];
           case 2:
            var kl=caml_call1(f,i),k$1=caml_call1(f,i + 1 | 0);
            return create$12([0,kl],k$1,0);
           default:
            var
             kl$0=caml_call1(f,i),
             k$2=caml_call1(f,i + 1 | 0),
             kr=caml_call1(f,i + 2 | 0);
            return create$12([0,kl$0],k$2,[0,kr])}
        var
         left_length=n >>> 1 | 0,
         right_length=(n - left_length | 0) - 1 | 0,
         left=loop(left_length,f,i),
         k=caml_call1(f,i + left_length | 0),
         right=loop(right_length,f,(i + left_length | 0) + 1 | 0);
        return create$12(left,k,right)}
      return loop(len,f,0)}
    function of_sorted_array_unchecked(array,compare_elt)
     {var array_length=array.length - 1,switch$0=0;
      if(2 <= array_length)
       {var _wd_=caml_check_bound(array,1)[2];
        if(0 <= caml_call2(compare_elt,caml_check_bound(array,0)[1],_wd_))
         {var
           next=
            function(i)
             {var _we_=(array_length - 1 | 0) - i | 0;
              return caml_check_bound(array,_we_)[1 + _we_]};
          switch$0 = 1}}
      if(! switch$0)
       var next=function(i){return caml_check_bound(array,i)[1 + i]};
      return of_increasing_iterator_uncheck(array_length,next)}
    function of_sorted_array(array,compare_elt)
     {var len=array.length - 1;
      if(1 !== len && len)
       return with_return
               (function(r)
                 {var
                   _v9_=caml_check_bound(array,1)[2],
                   i=caml_call2(compare_elt,caml_check_bound(array,0)[1],_v9_),
                   increasing=
                    0 === i
                     ?caml_call1(r,error_string(cst_of_sorted_array_duplicated))
                     :i < 0?1:0,
                   _v$_=array.length - 1 - 2 | 0,
                   _v__=1;
                  if(_v$_ >= 1)
                   {var i$0=_v__;
                    for(;;)
                     {var
                       _wa_=i$0 + 1 | 0,
                       _wb_=caml_check_bound(array,_wa_)[1 + _wa_],
                       i$1=
                        caml_call2
                         (compare_elt,caml_check_bound(array,i$0)[1 + i$0],_wb_);
                      if(0 === i$1)
                       caml_call1(r,error_string(cst_of_sorted_array_duplicated$0));
                      else
                       if((i$1 < 0?1:0) !== increasing)
                        caml_call1(r,error_string(cst_of_sorted_array_elements_a));
                      var _wc_=i$0 + 1 | 0;
                      if(_v$_ !== i$0){var i$0=_wc_;continue}
                      break}}
                  return [0,of_sorted_array_unchecked(array,compare_elt)]});
      return [0,of_sorted_array_unchecked(array,compare_elt)]}
    function bal(l,v,r)
     {if(typeof l === "number")
       var hl=0;
      else
       if(0 === l[0])var hl=1;else var h$1=l[4],hl=h$1;
      if(typeof r === "number")
       var hr=0;
      else
       if(0 === r[0])var hr=1;else var h$0=r[4],hr=h$0;
      if((hr + 2 | 0) < hl)
       {if(typeof l === "number")throw [0,Assert_failure$0,_em_];
        if(0 === l[0])throw [0,Assert_failure$0,_en_];
        var lr=l[3],lv=l[2],ll=l[1],_v3_=height(lr);
        if(_v3_ <= height(ll))return create$12(ll,lv,create$12(lr,v,r));
        if(typeof lr === "number")throw [0,Assert_failure$0,_eo_];
        if(0 !== lr[0])
         {var lrr=lr[3],lrv$0=lr[2],lrl=lr[1],_v5_=create$12(lrr,v,r);
          return create$12(create$12(ll,lv,lrl),lrv$0,_v5_)}
        var lrv=lr[1];
        if(! is_empty$6(ll))throw [0,Assert_failure$0,_ep_];
        var _v4_=create$12(0,v,r);
        return create$12(create$12(ll,lv,0),lrv,_v4_)}
      if((hl + 2 | 0) < hr)
       {if(typeof r === "number")throw [0,Assert_failure$0,_eq_];
        if(0 === r[0])throw [0,Assert_failure$0,_er_];
        var rr=r[3],rv=r[2],rl=r[1],_v6_=height(rl);
        if(_v6_ <= height(rr))return create$12(create$12(l,v,rl),rv,rr);
        if(typeof rl === "number")throw [0,Assert_failure$0,_es_];
        if(0 !== rl[0])
         {var rlr=rl[3],rlv$0=rl[2],rll=rl[1],_v8_=create$12(rlr,rv,rr);
          return create$12(create$12(l,v,rll),rlv$0,_v8_)}
        var rlv=rl[1];
        if(! is_empty$6(rr))throw [0,Assert_failure$0,_et_];
        var _v7_=create$12(0,rv,rr);
        return create$12(create$12(l,v,0),rlv,_v7_)}
      var h=hr <= hl?hl + 1 | 0:hr + 1 | 0;
      if(typeof l === "number")
       var sl=0;
      else
       if(0 === l[0])var sl=1;else var s$0=l[5],sl=s$0;
      if(typeof r === "number")
       var sr=0;
      else
       if(0 === r[0])var sr=1;else var s=r[5],sr=s;
      return 1 === h?[0,v]:[1,l,v,r,h,(sl + sr | 0) + 1 | 0]}
    var Same=[248,cst_Base_Set_Tree0_Same,caml_fresh_oo_id(0)];
    function add$1(t,x,compare_elt)
     {function aux(param)
       {if(typeof param === "number")return [0,x];
        if(0 === param[0])
         {var v=param[1],c=caml_call2(compare_elt,x,v);
          if(0 === c)throw Same;
          return 0 <= c?create$12(0,v,[0,x]):create$12([0,x],v,0)}
        var
         r=param[3],
         v$0=param[2],
         l=param[1],
         c$0=caml_call2(compare_elt,x,v$0);
        if(0 === c$0)throw Same;
        return 0 <= c$0?bal(l,v$0,aux(r)):bal(aux(l),v$0,r)}
      try
       {var _v1_=aux(t);return _v1_}
      catch(_v2_)
       {_v2_ = caml_wrap_exception(_v2_);if(_v2_ === Same)return t;throw _v2_}}
    function join$6(l,v,r,compare_elt)
     {if(typeof l === "number")return add$1(r,v,compare_elt);
      if(1 === l[0])
       {var _vX_=l[4],_vY_=l[3],_vZ_=l[2],_v0_=l[1];
        if(typeof r !== "number")
         {if(0 === r[0])
           {var rv=r[1];return add$1(add$1(l,v,compare_elt),rv,compare_elt)}
          var rh=r[4],rr=r[3],rv$0=r[2],rl=r[1];
          return (rh + 2 | 0) < _vX_
                  ?bal(_v0_,_vZ_,join$6(_vY_,v,r,compare_elt))
                  :(_vX_ + 2 | 0) < rh
                    ?bal(join$6(l,v,rl,compare_elt),rv$0,rr)
                    :create$12(l,v,r)}}
      if(typeof r === "number")return add$1(l,v,compare_elt);
      var lv=l[1];
      return add$1(add$1(r,v,compare_elt),lv,compare_elt)}
    function min_elt$7(param)
     {var param$0=param;
      for(;;)
       {if(typeof param$0 === "number")return 0;
        if(0 === param$0[0])
         var v=param$0[1];
        else
         {var _vW_=param$0[1];
          if(typeof _vW_ !== "number"){var param$0=_vW_;continue}
          var v=param$0[2]}
        return [0,v]}}
    var
     Set_min_elt_exn_of_empty_set=
      [248,cst_Base_Set_Tree0_Set_min_elt,caml_fresh_oo_id(0)];
    function _eu_(param)
     {if(param === Set_min_elt_exn_of_empty_set)return _ev_;
      throw [0,Assert_failure$0,_ew_]}
    caml_call4
     (Sexplib0_Sexp_conv[70][1],0,0,Set_min_elt_exn_of_empty_set,_eu_);
    var
     Set_max_elt_exn_of_empty_set=
      [248,cst_Base_Set_Tree0_Set_max_elt,caml_fresh_oo_id(0)];
    function _ex_(param)
     {if(param === Set_max_elt_exn_of_empty_set)return _ey_;
      throw [0,Assert_failure$0,_ez_]}
    caml_call4
     (Sexplib0_Sexp_conv[70][1],0,0,Set_max_elt_exn_of_empty_set,_ex_);
    function min_elt_exn(t)
     {var match=min_elt$7(t);
      if(! match)throw Set_min_elt_exn_of_empty_set;
      var v=match[1];
      return v}
    function fold_until$6(t,init,f,finish)
     {function fold_until_helper(f,t,acc)
       {var t$0=t,acc$0=acc;
        for(;;)
         {if(typeof t$0 === "number")return [0,acc$0];
          if(0 === t$0[0]){var value=t$0[1];return caml_call2(f,acc$0,value)}
          var
           right=t$0[3],
           value$0=t$0[2],
           left=t$0[1],
           x=fold_until_helper(f,left,acc$0);
          if(0 !== x[0])return x;
          var acc$1=x[1],x$0=caml_call2(f,acc$1,value$0);
          if(0 !== x$0[0])return x$0;
          var acc$2=x$0[1],t$0=right,acc$0=acc$2}}
      var match=fold_until_helper(f,t,init);
      if(0 === match[0]){var x=match[1];return caml_call1(finish,x)}
      var x$0=match[1];
      return x$0}
    function max_elt$7(param)
     {var param$0=param;
      for(;;)
       {if(typeof param$0 === "number")return 0;
        if(0 === param$0[0])
         var v=param$0[1];
        else
         {if(typeof param$0[3] !== "number")
           {var param$1=param$0[3],param$0=param$1;continue}
          var v=param$0[2]}
        return [0,v]}}
    function max_elt_exn(t)
     {var match=max_elt$7(t);
      if(! match)throw Set_max_elt_exn_of_empty_set;
      var v=match[1];
      return v}
    function remove_min_elt(param)
     {if(typeof param === "number")
       return caml_call1(invalid_arg$0,cst_Set_remove_min_elt);
      if(0 === param[0])return 0;
      var _vV_=param[1];
      if(typeof _vV_ === "number"){var r=param[3];return r}
      var r$0=param[3],v=param[2];
      return bal(remove_min_elt(_vV_),v,r$0)}
    function merge$2(t1,t2)
     {if(typeof t1 === "number")return t2;
      if(typeof t2 === "number")return t1;
      var _vU_=remove_min_elt(t2);
      return bal(t1,min_elt_exn(t2),_vU_)}
    function concat$3(t1,t2,compare_elt)
     {if(typeof t1 === "number")
       var t=t2;
      else
       {if(typeof t2 !== "number")
         {var _vT_=remove_min_elt(t2);
          return join$6(t1,min_elt_exn(t2),_vT_,compare_elt)}
        var t=t1}
      return t}
    function split$1(t,x,compare_elt)
     {function split(t)
       {if(typeof t === "number")return _eA_;
        if(0 === t[0])
         {var v=t[1],c=caml_call2(compare_elt,x,v);
          return 0 === c?[0,0,[0,v],0]:0 <= c?[0,[0,v],0,0]:[0,0,0,[0,v]]}
        var r=t[3],v$0=t[2],l=t[1],c$0=caml_call2(compare_elt,x,v$0);
        if(0 === c$0)return [0,l,[0,v$0],r];
        if(0 <= c$0)
         {var match=split(r),rr=match[3],maybe_elt=match[2],lr=match[1];
          return [0,join$6(l,v$0,lr,compare_elt),maybe_elt,rr]}
        var
         match$0=split(l),
         rl=match$0[3],
         maybe_elt$0=match$0[2],
         ll=match$0[1];
        return [0,ll,maybe_elt$0,join$6(rl,v$0,r,compare_elt)]}
      return split(t)}
    var already_seen=0;
    function mem$5(t,x,compare_elt)
     {var t$0=t;
      for(;;)
       {if(typeof t$0 === "number")return 0;
        if(0 === t$0[0])
         {var v=t$0[1],c=caml_call2(compare_elt,x,v);return 0 === c?1:0}
        var
         r=t$0[3],
         v$0=t$0[2],
         l=t$0[1],
         c$0=caml_call2(compare_elt,x,v$0),
         _vS_=0 === c$0?1:0;
        if(_vS_)return _vS_;
        var t$1=0 <= c$0?r:l,t$0=t$1}}
    function remove$0(t,x,compare_elt)
     {function aux(t)
       {if(typeof t === "number")throw Same;
        if(0 !== t[0])
         {var r=t[3],v$0=t[2],l=t[1],c=caml_call2(compare_elt,x,v$0);
          return 0 === c
                  ?merge$2(l,r)
                  :0 <= c?bal(l,v$0,aux(r)):bal(aux(l),v$0,r)}
        var v=t[1];
        if(0 === caml_call2(compare_elt,x,v))return 0;
        throw Same}
      try
       {var _vQ_=aux(t);return _vQ_}
      catch(_vR_)
       {_vR_ = caml_wrap_exception(_vR_);if(_vR_ === Same)return t;throw _vR_}}
    function remove_index(t,i,param)
     {function aux(t,i)
       {if(typeof t === "number")throw Same;
        if(0 !== t[0])
         {var
           r=t[3],
           v=t[2],
           l=t[1],
           l_size=length$12(l),
           c=caml_int_compare(i,l_size);
          return 0 === c
                  ?merge$2(l,r)
                  :0 <= c
                    ?bal(l,v,aux(r,(i - l_size | 0) - 1 | 0))
                    :bal(aux(l,i),v,r)}
        if(0 === i)return 0;
        throw Same}
      try
       {var _vO_=aux(t,i);return _vO_}
      catch(_vP_)
       {_vP_ = caml_wrap_exception(_vP_);if(_vP_ === Same)return t;throw _vP_}}
    function union(s1,s2,compare_elt)
     {function union(s1,s2)
       {var s1$0=s1,s2$0=s2;
        for(;;)
         {if(s1$0 === s2$0)return s1$0;
          var switch$0=0;
          if(typeof s1$0 === "number")
           {var t=s2$0;switch$0 = 1}
          else
           if(1 === s1$0[0])
            {var _vI_=s1$0[4],_vK_=s1$0[2],_vJ_=s1$0[3],_vL_=s1$0[1];
             if(typeof s2$0 !== "number")
              {if(0 === s2$0[0])
                {var v2=s2$0[1],s2$1=[1,0,v2,0,1,1],s2$0=s2$1;continue}
               var h2=s2$0[4],r2=s2$0[3],v2$0=s2$0[2],l2=s2$0[1];
               if(h2 <= _vI_)
                {if(1 === h2)return add$1(s1$0,v2$0,compare_elt);
                 var
                  match=split$1(s2$0,_vK_,compare_elt),
                  r2$0=match[3],
                  l2$0=match[1],
                  _vM_=union(_vJ_,r2$0);
                 return join$6(union(_vL_,l2$0),_vK_,_vM_,compare_elt)}
               if(1 === _vI_)return add$1(s2$0,_vK_,compare_elt);
               var
                match$0=split$1(s1$0,v2$0,compare_elt),
                r1=match$0[3],
                l1=match$0[1],
                _vN_=union(r1,r2);
               return join$6(union(l1,l2),v2$0,_vN_,compare_elt)}}
          if(! switch$0)
           {if(typeof s2$0 !== "number")
             {var v1=s1$0[1],s1$1=[1,0,v1,0,1,1],s1$0=s1$1;continue}
            var t=s1$0}
          return t}}
      return union(s1,s2)}
    function union_list(comparator,to_tree,xs)
     {var compare_elt=comparator[1];
      return fold_left
              (xs,
               already_seen,
               function(ac,x)
                {return union(ac,caml_call1(to_tree,x),compare_elt)})}
    function inter(s1,s2,compare_elt)
     {function inter(s1,s2)
       {if(s1 === s2)return s1;
        if(typeof s1 !== "number" && typeof s2 !== "number")
         {var switch$0=0;
          if(typeof s1 !== "number" && 0 !== s1[0])
           {if(typeof s2 !== "number" && 0 !== s2[0])
             {var
               r1=s1[3],
               v1=s1[2],
               l1=s1[1],
               _vD_=split$1(s2,v1,compare_elt),
               _vE_=_vD_[2],
               _vF_=_vD_[1];
              if(_vE_)
               {var r2=_vD_[3],v1$0=_vE_[1],_vG_=inter(r1,r2);
                return join$6(inter(l1,_vF_),v1$0,_vG_,compare_elt)}
              var r2$0=_vD_[3],_vH_=inter(r1,r2$0);
              return concat$3(inter(l1,_vF_),_vH_,compare_elt)}
            var other_set=s1,singleton=s2,elt=s2[1];
            switch$0 = 1}
          if(! switch$0)var other_set=s2,singleton=s1,elt=s1[1];
          return mem$5(other_set,elt,compare_elt)?singleton:0}
        return 0}
      return inter(s1,s2)}
    function diff(s1,s2,compare_elt)
     {function diff(s1,s2)
       {var s1$0=s1;
        for(;;)
         {if(s1$0 === s2)return 0;
          if(typeof s1$0 === "number")return 0;
          if(typeof s2 === "number")return s1$0;
          if(typeof s1$0 !== "number" && 0 !== s1$0[0])
           {var
             r1=s1$0[3],
             v1$0=s1$0[2],
             l1=s1$0[1],
             _vz_=split$1(s2,v1$0,compare_elt),
             _vA_=_vz_[1];
            if(_vz_[2])
             {var r2=_vz_[3],_vB_=diff(r1,r2);
              return concat$3(diff(l1,_vA_),_vB_,compare_elt)}
            var r2$0=_vz_[3],_vC_=diff(r1,r2$0);
            return join$6(diff(l1,_vA_),v1$0,_vC_,compare_elt)}
          var v1=s1$0[1],s1$1=[1,0,v1,0,1,1],s1$0=s1$1}}
      return diff(s1,s2)}
    function cons$0(s,e)
     {var s$0=s,e$0=e;
      for(;;)
       {if(typeof s$0 === "number")return e$0;
        if(0 === s$0[0]){var v=s$0[1];return [0,v,0,e$0]}
        var r=s$0[3],v$0=s$0[2],s$1=s$0[1],e$1=[0,v$0,r,e$0],s$0=s$1,e$0=e$1}}
    function cons_right(s,e)
     {var s$0=s,e$0=e;
      for(;;)
       {if(typeof s$0 === "number")return e$0;
        if(0 === s$0[0]){var v=s$0[1];return [0,v,0,e$0]}
        var s$1=s$0[3],v$0=s$0[2],l=s$0[1],e$1=[0,v$0,l,e$0],s$0=s$1,e$0=e$1}}
    function of_set(s){return cons$0(s,0)}
    function iter$11(f,param)
     {var param$0=param;
      for(;;)
       {if(! param$0)return 0;
        var enum$0=param$0[3],tree=param$0[2],a=param$0[1];
        caml_call1(f,a);
        var param$1=cons$0(tree,enum$0),param$0=param$1}}
    function symmetric_diff(t1,t2,compare_elt)
     {function step(state)
       {var _vs_=state[1];
        if(! _vs_)
         {var _vy_=state[2];
          if(! _vy_)return 0;
          var enum$0=_vy_[3],tree=_vy_[2],elt=_vy_[1];
          return [1,[1,elt],[0,0,cons$0(tree,enum$0)]]}
        var _vt_=state[2],_vu_=_vs_[3],_vv_=_vs_[2],_vw_=_vs_[1];
        if(! _vt_)return [1,[0,_vw_],[0,cons$0(_vv_,_vu_),0]];
        var
         enum2=_vt_[3],
         tree2=_vt_[2],
         a2=_vt_[1],
         compare_result=caml_call2(compare_elt,_vw_,a2);
        if(0 !== compare_result)
         return 0 <= compare_result
                 ?[1,[1,a2],[0,_vs_,cons$0(tree2,enum2)]]
                 :[1,[0,_vw_],[0,cons$0(_vv_,_vu_),_vt_]];
        if(_vv_ === tree2)
         var next_state=[0,_vu_,enum2];
        else
         var _vx_=cons$0(tree2,enum2),next_state=[0,cons$0(_vv_,_vu_),_vx_];
        return [0,next_state]}
      var _vr_=of_set(t2);
      return [0,[0,of_set(t1),_vr_],step]}
    function to_sequence$0
     (comparator,opt,greater_or_equal_to,less_or_equal_to,t$4)
     {if(opt)var sth=opt[1],order=sth;else var order=608542111;
      function inclusive_bound(side,t,bound)
       {var
         compare_elt=comparator[1],
         match=split$1(t,bound,compare_elt),
         r=match[3],
         maybe=match[2],
         l=match[1],
         t$0=caml_call1(side,[0,l,r]);
        if(! maybe)return t$0;
        var elt=maybe[1];
        return add$1(t$0,elt,compare_elt)}
      if(608542111 <= order)
       {var
         t$5=
          fold$0
           (less_or_equal_to,
            t$4,
            function(_vp_,_vq_){return inclusive_bound(get_key,_vp_,_vq_)}),
         next=
          function(enum$0)
           {if(! enum$0)return 0;
            var e=enum$0[3],t=enum$0[2],k=enum$0[1];
            return [1,k,cons$0(t,e)]};
        if(greater_or_equal_to)
         {var key=greater_or_equal_to[1],t=t$5,e=0,_vl_=comparator[1];
          for(;;)
           {if(typeof t !== "number")
             {if(0 === t[0]){var v=t[1],t$0=[1,0,v,0,1,1],t=t$0;continue}
              var l=t[1],r=t[3],v$0=t[2];
              if(0 <= caml_call2(_vl_,v$0,key))
               {var r$0=t[3],v$1=t[2],e$0=[0,v$1,r$0,e],t=l,e=e$0;continue}
              var t=r;
              continue}
            var init=e;
            break}}
        else
         var init=of_set(t$5);
        return [0,init,next]}
      var
       t$6=
        fold$0
         (greater_or_equal_to,
          t$4,
          function(_vn_,_vo_){return inclusive_bound(get_data,_vn_,_vo_)});
      function next$0(enum$0)
       {if(! enum$0)return 0;
        var e=enum$0[3],t=enum$0[2],k=enum$0[1];
        return [1,k,cons_right(t,e)]}
      if(less_or_equal_to)
       {var key$0=less_or_equal_to[1],t$1=t$6,e$1=0,_vm_=comparator[1];
        for(;;)
         {if(typeof t$1 !== "number")
           {if(0 === t$1[0])
             {var v$2=t$1[1],t$2=[1,0,v$2,0,1,1],t$1=t$2;continue}
            var l$0=t$1[1],v$3=t$1[2];
            if(0 < caml_call2(_vm_,v$3,key$0)){var t$1=l$0;continue}
            var t$3=t$1[3],v$4=t$1[2],e$2=[0,v$4,l$0,e$1],t$1=t$3,e$1=e$2;
            continue}
          var init$0=e$1;
          break}}
      else
       var init$0=cons_right(t$6,0);
      return [0,init$0,next$0]}
    function find_first_satisfying$0(t,f)
     {var t$0=t;
      for(;;)
       {if(typeof t$0 === "number")return 0;
        if(0 === t$0[0]){var v=t$0[1];return caml_call1(f,v)?[0,v]:0}
        var r=t$0[3],v$0=t$0[2],l=t$0[1];
        if(caml_call1(f,v$0))
         {var x=find_first_satisfying$0(l,f);return x?x:[0,v$0]}
        var t$0=r}}
    function find_last_satisfying$0(t,f)
     {var t$0=t;
      for(;;)
       {if(typeof t$0 === "number")return 0;
        if(0 === t$0[0]){var v=t$0[1];return caml_call1(f,v)?[0,v]:0}
        var r=t$0[3],v$0=t$0[2],l=t$0[1];
        if(caml_call1(f,v$0))
         {var x=find_last_satisfying$0(r,f);return x?x:[0,v$0]}
        var t$0=l}}
    function binary_search$1(t,compare,how,v)
     {if(-839473056 <= how)
       return 200870407 <= how
               ?926943384 <= how
                 ?find_first_satisfying$0
                   (t,function(x){return 0 <= caml_call2(compare,x,v)?1:0})
                 :find_last_satisfying$0
                   (t,function(x){return caml_call2(compare,x,v) < 0?1:0})
               :-253007807 <= how
                 ?find_last_satisfying$0
                   (t,function(x){return caml_call2(compare,x,v) <= 0?1:0})
                 :find_first_satisfying$0
                   (t,function(x){return 0 < caml_call2(compare,x,v)?1:0});
      if(-1055410545 <= how)
       {var
         elt=
          find_last_satisfying$0
           (t,function(x){return caml_call2(compare,x,v) <= 0?1:0});
        if(elt){var x=elt[1];if(0 === caml_call2(compare,x,v))return elt}
        return 0}
      var
       elt$0=
        find_first_satisfying$0
         (t,function(x){return 0 <= caml_call2(compare,x,v)?1:0});
      if(elt$0)
       {var x$0=elt$0[1];if(0 === caml_call2(compare,x$0,v))return elt$0}
      return 0}
    function binary_search_segmented$1(t,segment_of,how)
     {function is_left(x)
       {var match=caml_call1(segment_of,x);return 847852583 <= match?1:0}
      function is_right(x){return 1 - is_left(x)}
      return 125585502 <= how
              ?find_last_satisfying$0(t,is_left)
              :find_first_satisfying$0(t,is_right)}
    function merge_to_sequence
     (comparator,opt,greater_or_equal_to,less_or_equal_to,t$0,t)
     {if(opt)var sth=opt[1],order=sth;else var order=608542111;
      if(608542111 <= order)
       var _vg_=comparator[1];
      else
       var
        _vi_=comparator[1],
        _vg_=function(_vj_,_vk_){return flip(_vi_,_vj_,_vk_)};
      var
       _vh_=
        to_sequence$0
         (comparator,[0,order],greater_or_equal_to,less_or_equal_to,t);
      return merge_with_duplicates
              (to_sequence$0
                (comparator,
                 [0,order],
                 greater_or_equal_to,
                 less_or_equal_to,
                 t$0),
               _vh_,
               _vg_)}
    function compare$50(compare_elt,s1,s2)
     {var e2$2=of_set(s2),e1$2=of_set(s1),e1=e1$2,e2=e2$2;
      for(;;)
       {if(! e1)return e2?-1:0;
        if(! e2)return 1;
        var
         e2$0=e2[3],
         r2=e2[2],
         v2=e2[1],
         e1$0=e1[3],
         r1=e1[2],
         v1=e1[1],
         c=caml_call2(compare_elt,v1,v2);
        if(0 !== c)return c;
        if(r1 === r2){var e1=e1$0,e2=e2$0;continue}
        var e2$1=cons$0(r2,e2$0),e1$1=cons$0(r1,e1$0),e1=e1$1,e2=e2$1}}
    function iter2$0(s1,s2,compare_elt)
     {var t2=of_set(s2),t1=of_set(s1);
      return function(f)
       {var t1$0=t1,t2$0=t2;
        for(;;)
         {if(! t1$0)
           return t2$0
                   ?iter$11
                     (function(a){return caml_call1(f,[0,-57574468,a])},t2$0)
                   :0;
          if(! t2$0)
           return iter$11
                   (function(a){return caml_call1(f,[0,847852583,a])},t1$0);
          var
           enum2=t2$0[3],
           tree2=t2$0[2],
           a2=t2$0[1],
           enum1=t1$0[3],
           tree1=t1$0[2],
           a1=t1$0[1],
           compare_result=caml_call2(compare_elt,a1,a2);
          if(0 === compare_result)
           {caml_call1(f,[0,737457313,[0,a1,a2]]);
            var
             t2$1=cons$0(tree2,enum2),
             t1$1=cons$0(tree1,enum1),
             t1$0=t1$1,
             t2$0=t2$1;
            continue}
          if(0 <= compare_result)
           {caml_call1(f,[0,-57574468,a2]);
            var t2$2=cons$0(tree2,enum2),t2$0=t2$2;
            continue}
          caml_call1(f,[0,847852583,a1]);
          var t1$2=cons$0(tree1,enum1),t1$0=t1$2}}}
    function equal$35(s1,s2,compare_elt)
     {return 0 === compare$50(compare_elt,s1,s2)?1:0}
    function is_subset(s1,s2,compare_elt)
     {function is_subset(s1,s2)
       {var s1$0=s1,s2$0=s2;
        for(;;)
         {if(typeof s1$0 === "number")return 1;
          if(1 === s1$0[0])
           {var _u__=s1$0[3],_u$_=s1$0[2],_va_=s1$0[1];
            if(typeof s2$0 !== "number")
             {if(0 === s2$0[0])
               {var v2=s2$0[1];
                if(typeof _va_ === "number" && typeof _u__ === "number")
                 return 0 === caml_call2(compare_elt,_u$_,v2)?1:0;
                return 0}
              var
               r2=s2$0[3],
               v2$0=s2$0[2],
               l2=s2$0[1],
               c=caml_call2(compare_elt,_u$_,v2$0);
              if(0 !== c)
               {if(0 <= c)
                 {var _ve_=is_subset([1,0,_u$_,_u__,0,0],r2);
                  if(! _ve_)return _ve_;
                  var s1$0=_va_;
                  continue}
                var _vf_=is_subset([1,_va_,_u$_,0,0,0],l2);
                if(! _vf_)return _vf_;
                var s1$0=_u__;
                continue}
              var _vb_=s1$0 === s2$0?1:0;
              if(_vb_)
               var _vc_=_vb_;
              else
               {var _vd_=is_subset(_va_,l2);
                if(_vd_){var s1$0=_u__,s2$0=r2;continue}
                var _vc_=_vd_}
              return _vc_}}
          if(typeof s2$0 === "number")return 0;
          var v1=s1$0[1];
          return mem$5(s2$0,v1,compare_elt)}}
      return is_subset(s1,s2)}
    function are_disjoint(s1,s2,compare_elt)
     {var s1$0=s1,s2$0=s2;
      for(;;)
       {if(typeof s1$0 !== "number" && typeof s2$0 !== "number")
         {var switch$0=0;
          if(typeof s1$0 !== "number" && 0 !== s1$0[0])
           {if(typeof s2$0 !== "number" && 0 !== s2$0[0])
             {var r1=s1$0[3],v1=s1$0[2],l1=s1$0[1];
              if(s1$0 === s2$0)return 0;
              var _u7_=split$1(s2$0,v1,compare_elt),_u8_=_u7_[1];
              if(_u7_[2])return 0;
              var r2=_u7_[3],_u9_=are_disjoint(l1,_u8_,compare_elt);
              if(! _u9_)return _u9_;
              var s1$0=r1,s2$0=r2;
              continue}
            var other_set=s1$0,elt=s2$0[1];
            switch$0 = 1}
          if(! switch$0)var other_set=s2$0,elt=s1$0[1];
          return 1 - mem$5(other_set,elt,compare_elt)}
        return 1}}
    function iter$12(t,f)
     {function iter(param)
       {var param$0=param;
        for(;;)
         {if(typeof param$0 === "number")return 0;
          if(0 === param$0[0]){var v=param$0[1];return caml_call1(f,v)}
          var r=param$0[3],v$0=param$0[2],l=param$0[1];
          iter(l);
          caml_call1(f,v$0);
          var param$0=r}}
      return iter(t)}
    function fold$8(s,accu,f)
     {var s$0=s,accu$0=accu;
      for(;;)
       {if(typeof s$0 === "number")return accu$0;
        if(0 === s$0[0]){var v=s$0[1];return caml_call2(f,accu$0,v)}
        var
         r=s$0[3],
         v$0=s$0[2],
         l=s$0[1],
         accu$1=caml_call2(f,fold$8(l,accu$0,f),v$0),
         s$0=r,
         accu$0=accu$1}}
    function count$6(t,f){return count(fold$8,t,f)}
    function sum$6(m,t,f){return caml_call2(sum(fold$8,m),t,f)}
    function fold_right$1(s,accu,f)
     {var s$0=s,accu$0=accu;
      for(;;)
       {if(typeof s$0 === "number")return accu$0;
        if(0 === s$0[0]){var v=s$0[1];return caml_call2(f,v,accu$0)}
        var
         r=s$0[3],
         v$0=s$0[2],
         l=s$0[1],
         accu$1=caml_call2(f,v$0,fold_right$1(r,accu$0,f)),
         s$0=l,
         accu$0=accu$1}}
    function for_all$7(t,p)
     {var t$0=t;
      for(;;)
       {if(typeof t$0 === "number")return 1;
        if(0 === t$0[0]){var v=t$0[1];return caml_call1(p,v)}
        var r=t$0[3],v$0=t$0[2],l=t$0[1],_u4_=caml_call1(p,v$0);
        if(_u4_)
         {var _u5_=for_all$7(l,p);if(_u5_){var t$0=r;continue}var _u6_=_u5_}
        else
         var _u6_=_u4_;
        return _u6_}}
    function exists$7(t,p)
     {var t$0=t;
      for(;;)
       {if(typeof t$0 === "number")return 0;
        if(0 === t$0[0]){var v=t$0[1];return caml_call1(p,v)}
        var r=t$0[3],v$0=t$0[2],l=t$0[1],_u1_=caml_call1(p,v$0);
        if(_u1_)
         var _u2_=_u1_;
        else
         {var _u3_=exists$7(l,p);if(! _u3_){var t$0=r;continue}var _u2_=_u3_}
        return _u2_}}
    function filter$4(s,p,compare_elt)
     {function filt(accu,param)
       {var accu$0=accu,param$0=param;
        for(;;)
         {if(typeof param$0 === "number")return accu$0;
          if(0 === param$0[0])
           {var v=param$0[1];
            return caml_call1(p,v)?add$1(accu$0,v,compare_elt):accu$0}
          var
           r=param$0[3],
           v$0=param$0[2],
           l=param$0[1],
           _u0_=caml_call1(p,v$0)?add$1(accu$0,v$0,compare_elt):accu$0,
           accu$1=filt(_u0_,l),
           accu$0=accu$1,
           param$0=r}}
      return filt(0,s)}
    function filter_map$2(s,p,compare_elt)
     {function filt(accu,param)
       {var accu$0=accu,param$0=param;
        for(;;)
         {if(typeof param$0 === "number")return accu$0;
          if(0 === param$0[0])
           {var v=param$0[1],match=caml_call1(p,v);
            if(! match)return accu$0;
            var v$0=match[1];
            return add$1(accu$0,v$0,compare_elt)}
          var
           r=param$0[3],
           v$1=param$0[2],
           l=param$0[1],
           match$0=caml_call1(p,v$1);
          if(match$0)
           var v$2=match$0[1],_uZ_=add$1(accu$0,v$2,compare_elt);
          else
           var _uZ_=accu$0;
          var accu$1=filt(_uZ_,l),accu$0=accu$1,param$0=r}}
      return filt(0,s)}
    function partition_tf$1(s,p,compare_elt)
     {function part(accu,param)
       {var accu$0=accu,param$0=param;
        for(;;)
         {var _uW_=accu$0[2],_uX_=accu$0[1];
          if(typeof param$0 === "number")return accu$0;
          if(0 === param$0[0])
           {var v=param$0[1];
            return caml_call1(p,v)
                    ?[0,add$1(_uX_,v,compare_elt),_uW_]
                    :[0,_uX_,add$1(_uW_,v,compare_elt)]}
          var
           r=param$0[3],
           v$0=param$0[2],
           l=param$0[1],
           _uY_=
            caml_call1(p,v$0)
             ?[0,add$1(_uX_,v$0,compare_elt),_uW_]
             :[0,_uX_,add$1(_uW_,v$0,compare_elt)],
           accu$1=part(_uY_,l),
           accu$0=accu$1,
           param$0=r}}
      return part(_eB_,s)}
    function elements_aux(accu,param)
     {var accu$0=accu,param$0=param;
      for(;;)
       {if(typeof param$0 === "number")return accu$0;
        if(0 === param$0[0]){var v=param$0[1];return [0,v,accu$0]}
        var
         r=param$0[3],
         v$0=param$0[2],
         l=param$0[1],
         accu$1=[0,v$0,elements_aux(accu$0,r)],
         accu$0=accu$1,
         param$0=l}}
    function elements(s){return elements_aux(0,s)}
    function choose(t)
     {if(typeof t === "number")return 0;
      if(0 === t[0]){var v=t[1];return [0,v]}
      var v$0=t[2];
      return [0,v$0]}
    var not_found$12=[0,Not_found_s,_eC_];
    function choose_exn(t)
     {var match=choose(t);
      if(! match)throw not_found$12;
      var v=match[1];
      return v}
    function of_list$4(lst,compare_elt)
     {return fold_left
              (lst,already_seen,function(t,x){return add$1(t,x,compare_elt)})}
    function of_sequence$0(sequence,compare_elt)
     {return fold$1
              (sequence,
               already_seen,
               function(t,x){return add$1(t,x,compare_elt)})}
    function to_list$8(s){return elements(s)}
    function of_array$1(a,compare_elt)
     {return fold(a,already_seen,function(t,x){return add$1(t,x,compare_elt)})}
    function to_array$7(param)
     {if(typeof param === "number")return [0];
      if(0 === param[0]){var v=param[1];return [0,v]}
      var
       s=param[5],
       r=param[3],
       v$0=param[2],
       l=param[1],
       res=caml_make_vect(s,v$0),
       pos_ref=[0,0];
      function loop(param)
       {var param$0=param;
        for(;;)
         {if(typeof param$0 === "number")return 0;
          if(0 === param$0[0])
           {var v=param$0[1],_uU_=pos_ref[1];
            caml_check_bound(res,_uU_)[1 + _uU_] = v;
            return incr(pos_ref)}
          var r=param$0[3],v$0=param$0[2],l=param$0[1];
          loop(l);
          var _uV_=pos_ref[1];
          caml_check_bound(res,_uV_)[1 + _uV_] = v$0;
          incr(pos_ref);
          var param$0=r}}
      loop(l);
      incr(pos_ref);
      loop(r);
      return res}
    function map$27(t,f,compare_elt)
     {return fold$8
              (t,
               already_seen,
               function(t,x){return add$1(t,caml_call1(f,x),compare_elt)})}
    function group_by(set,equiv,compare_elt)
     {var set$0=set,equiv_classes=0;
      for(;;)
       {if(is_empty$6(set$0))return equiv_classes;
        var
         x=choose_exn(set$0),
         match=
          partition_tf$1
           (set$0,
            function(x)
              {return function(elt)
                {var _uT_=x === elt?1:0;
                 return _uT_?_uT_:caml_call2(equiv,x,elt)}}
             (x),
            compare_elt),
         set$1=match[2],
         equiv_x=match[1],
         equiv_classes$0=[0,equiv_x,equiv_classes],
         set$0=set$1,
         equiv_classes=equiv_classes$0}}
    function find$7(t,f)
     {var t$0=t;
      for(;;)
       {if(typeof t$0 === "number")return 0;
        if(0 === t$0[0]){var v=t$0[1];return caml_call1(f,v)?[0,v]:0}
        var r=t$0[3],v$0=t$0[2],l=t$0[1];
        if(caml_call1(f,v$0))return [0,v$0];
        var r$0=find$7(l,f);
        if(r$0)return r$0;
        var t$0=r}}
    function find_map$6(t,f)
     {var t$0=t;
      for(;;)
       {if(typeof t$0 === "number")return 0;
        if(0 === t$0[0]){var v=t$0[1];return caml_call1(f,v)}
        var r=t$0[3],v$0=t$0[2],l=t$0[1],r$0=caml_call1(f,v$0);
        if(r$0)return r$0;
        var r$1=find_map$6(l,f);
        if(r$1)return r$1;
        var t$0=r}}
    function find_exn$3(t,f)
     {var match=find$7(t,f);
      if(! match)return caml_call1(failwith$0,cst_Set_find_exn_failed_to_fin);
      var e=match[1];
      return e}
    function nth$1(t,i)
     {var t$0=t,i$0=i;
      for(;;)
       {if(typeof t$0 === "number")return 0;
        if(0 === t$0[0]){var v=t$0[1];return 0 === i$0?[0,v]:0}
        var s=t$0[5],r=t$0[3],v$0=t$0[2],l=t$0[1];
        if(s <= i$0)return 0;
        var l_size=length$12(l),c=caml_int_compare(i$0,l_size);
        if(0 > c){var t$0=l;continue}
        if(0 === c)return [0,v$0];
        var i$1=(i$0 - l_size | 0) - 1 | 0,t$0=r,i$0=i$1}}
    function stable_dedup_list(xs,compare_elt)
     {var xs$0=xs,leftovers=0,already_seen$0=already_seen;
      for(;;)
       {if(! xs$0)return rev(leftovers);
        var tl=xs$0[2],hd=xs$0[1];
        if(mem$5(already_seen$0,hd,compare_elt)){var xs$0=tl;continue}
        var
         already_seen$1=add$1(already_seen$0,hd,compare_elt),
         leftovers$0=[0,hd,leftovers],
         xs$0=tl,
         leftovers=leftovers$0,
         already_seen$0=already_seen$1}}
    function t_of_sexp_direct(a_of_sexp,sexp,compare_elt)
     {if(0 === sexp[0])
       return caml_call2(of_sexp_error,cst_Set_t_of_sexp_list_needed,sexp);
      var
       lst=sexp[1],
       elt_lst=map$9(lst,a_of_sexp),
       set=of_list$4(elt_lst,compare_elt),
       _uS_=caml_call1(length,lst);
      if(length$12(set) === _uS_)return set;
      var set$0=[0,already_seen];
      iter2_exn
       (lst,
        elt_lst,
        function(el_sexp,el)
         {return mem$5(set$0[1],el,compare_elt)
                  ?caml_call2
                    (of_sexp_error,cst_Set_t_of_sexp_duplicate_el,el_sexp)
                  :(set$0[1] = add$1(set$0[1],el,compare_elt),0)});
      throw [0,Assert_failure$0,_eD_]}
    function sexp_of_t$48(sexp_of_a,t)
     {return [1,
              fold_right$1
               (t,0,function(el,acc){return [0,caml_call1(sexp_of_a,el),acc]})]}
    function is_subset$0(subset,superset,sexp_of_elt,compare_elt)
     {var invalid_elements=diff(subset[1],superset[1],compare_elt);
      if(is_empty$6(invalid_elements))return _eE_;
      var
       invalid_elements_sexp=sexp_of_t$48(sexp_of_elt,invalid_elements),
       _uR_=caml_call2(symbol$59,cst_is_not_a_subset_of,superset[2]);
      return error_s
              (caml_call2
                (message,
                 caml_call2(symbol$59,subset[2],_uR_),
                 [0,[0,cst_invalid_elements,invalid_elements_sexp],0]))}
    function like(param,tree)
     {var comparator=param[1];return [0,comparator,tree]}
    function compare_elt(t){return t[1][1]}
    function comparator$12(t){return t[1]}
    function invariants$0(t)
     {var _uQ_=compare_elt(t);return invariants(t[2],_uQ_)}
    function length$13(t){return length$12(t[2])}
    function is_empty$7(t){return is_empty$6(t[2])}
    function elements$0(t){return elements(t[2])}
    function min_elt$8(t){return min_elt$7(t[2])}
    function min_elt_exn$0(t){return min_elt_exn(t[2])}
    function max_elt$8(t){return max_elt$7(t[2])}
    function max_elt_exn$0(t){return max_elt_exn(t[2])}
    function choose$0(t){return choose(t[2])}
    function choose_exn$0(t){return choose_exn(t[2])}
    function to_list$9(t){return to_list$8(t[2])}
    function to_array$8(t){return to_array$7(t[2])}
    function fold$9(t,init,f){return fold$8(t[2],init,f)}
    function fold_until$7(t,init,f)
     {var _uO_=t[2];
      return function(_uP_){return fold_until$6(_uO_,init,f,_uP_)}}
    function fold_right$2(t,init,f){return fold_right$1(t[2],init,f)}
    function fold_result$6(t,init,f){return fold_result(fold$9,init,f,t)}
    function iter$13(t,f){return iter$12(t[2],f)}
    function iter2$1(a,b,f)
     {var _uN_=compare_elt(a);return caml_call1(iter2$0(a[2],b[2],_uN_),f)}
    function exists$8(t,f){return exists$7(t[2],f)}
    function for_all$8(t,f){return for_all$7(t[2],f)}
    function count$7(t,f){return count$6(t[2],f)}
    function sum$7(m,t,f){return sum$6(m,t[2],f)}
    function find$8(t,f){return find$7(t[2],f)}
    function find_exn$4(t,f){return find_exn$3(t[2],f)}
    function find_map$7(t,f){return find_map$6(t[2],f)}
    function mem$6(t,a){var _uM_=compare_elt(t);return mem$5(t[2],a,_uM_)}
    function filter$5(t,f)
     {var _uL_=compare_elt(t);return like(t,filter$4(t[2],f,_uL_))}
    function add$2(t,a)
     {var _uK_=compare_elt(t);return like(t,add$1(t[2],a,_uK_))}
    function remove$1(t,a)
     {var _uJ_=compare_elt(t);return like(t,remove$0(t[2],a,_uJ_))}
    function union$0(t1,t2)
     {var _uI_=compare_elt(t1);return like(t1,union(t1[2],t2[2],_uI_))}
    function inter$0(t1,t2)
     {var _uH_=compare_elt(t1);return like(t1,inter(t1[2],t2[2],_uH_))}
    function diff$0(t1,t2)
     {var _uG_=compare_elt(t1);return like(t1,diff(t1[2],t2[2],_uG_))}
    function symmetric_diff$0(t1,t2)
     {var _uF_=compare_elt(t1);return symmetric_diff(t1[2],t2[2],_uF_)}
    function compare_direct(t1,t2)
     {var _uD_=t2[2],_uE_=t1[2];return compare$50(compare_elt(t1),_uE_,_uD_)}
    function equal$36(t1,t2)
     {var _uC_=compare_elt(t1);return equal$35(t1[2],t2[2],_uC_)}
    function is_subset$1(t,of)
     {var _uB_=compare_elt(t);return is_subset(t[2],of[2],_uB_)}
    function are_disjoint$0(t1,t2)
     {var _uA_=compare_elt(t1);return are_disjoint(t1[2],t2[2],_uA_)}
    function to_named_tree(param)
     {var name=param[2],set=param[1];return [0,set[2],name]}
    function is_subset$2(subset,superset)
     {var
       _ux_=compare_elt(subset[1]),
       _uy_=subset[1][1][2],
       _uz_=to_named_tree(superset);
      return is_subset$0(to_named_tree(subset),_uz_,_uy_,_ux_)}
    function equal$37(t1,t2)
     {var _uw_=[0,is_subset$2(t2,t1),0];
      return combine_errors_unit$0([0,is_subset$2(t1,t2),_uw_])}
    function partition_tf$2(t,f)
     {var
       _uu_=compare_elt(t),
       match=partition_tf$1(t[2],f,_uu_),
       tree_f=match[2],
       tree_t=match[1],
       _uv_=like(t,tree_f);
      return [0,like(t,tree_t),_uv_]}
    function split$2(t,a)
     {var
       _us_=compare_elt(t),
       match=split$1(t[2],a,_us_),
       tree2=match[3],
       b=match[2],
       tree1=match[1],
       _ut_=like(t,tree2);
      return [0,like(t,tree1),b,_ut_]}
    function group_by$0(t,equiv)
     {function _up_(_ur_){return like(t,_ur_)}
      var _uq_=compare_elt(t);
      return map$9(group_by(t[2],equiv,_uq_),_up_)}
    function nth$2(t,i){return nth$1(t[2],i)}
    function remove_index$0(t,i)
     {var _uo_=compare_elt(t);return like(t,remove_index(t[2],i,_uo_))}
    function sexp_of_t$49(sexp_of_a,param,t)
     {return sexp_of_t$48(sexp_of_a,t[2])}
    function to_sequence$1(order,greater_or_equal_to,less_or_equal_to,t)
     {return to_sequence$0
              (t[1],order,greater_or_equal_to,less_or_equal_to,t[2])}
    function binary_search$2(t,compare,how,v)
     {return binary_search$1(t[2],compare,how,v)}
    function binary_search_segmented$2(t,segment_of,how)
     {return binary_search_segmented$1(t[2],segment_of,how)}
    function merge_to_sequence$0
     (order,greater_or_equal_to,less_or_equal_to,t$0,t)
     {return merge_to_sequence
              (t$0[1],order,greater_or_equal_to,less_or_equal_to,t$0[2],t[2])}
    function hash_fold_direct(hash_fold_key,state,t)
     {var _un_=t[2];
      return fold$8
              (_un_,
               caml_call2(hash_fold_t$4,state,length$12(_un_)),
               hash_fold_key)}
    function compare$51(param,_um_,t1,t2){return compare_direct(t1,t2)}
    function t_of_sexp_direct$0(comparator,a_of_sexp,sexp)
     {return t_of_sexp_direct(a_of_sexp,sexp,comparator[1])}
    function empty$1(param){return already_seen}
    function singleton$3(param,e){return [0,e]}
    function length$14(t){return length$12(t)}
    function invariants$1(comparator,t){return invariants(t,comparator[1])}
    function is_empty$8(t){return is_empty$6(t)}
    function elements$1(t){return elements(t)}
    function min_elt$9(t){return min_elt$7(t)}
    function min_elt_exn$1(t){return min_elt_exn(t)}
    function max_elt$9(t){return max_elt$7(t)}
    function max_elt_exn$1(t){return max_elt_exn(t)}
    function choose$1(t){return choose(t)}
    function choose_exn$1(t){return choose_exn(t)}
    function to_list$10(t){return to_list$8(t)}
    function to_array$9(t){return to_array$7(t)}
    function iter$14(t,f){return iter$12(t,f)}
    function exists$9(t,f){return exists$7(t,f)}
    function for_all$9(t,f){return for_all$7(t,f)}
    function count$8(t,f){return count$6(t,f)}
    function sum$8(m,t,f){return sum$6(m,t,f)}
    function find$9(t,f){return find$7(t,f)}
    function find_exn$5(t,f){return find_exn$3(t,f)}
    function find_map$8(t,f){return find_map$6(t,f)}
    function fold$10(t,init,f){return fold$8(t,init,f)}
    function fold_until$8(t,init,f)
     {return function(_ul_){return fold_until$6(t,init,f,_ul_)}}
    function fold_right$3(t,init,f){return fold_right$1(t,init,f)}
    function map$28(comparator,t,f){return map$27(t,f,comparator[1])}
    function filter$6(comparator,t,f){return filter$4(t,f,comparator[1])}
    function filter_map$3(comparator,t,f)
     {return filter_map$2(t,f,comparator[1])}
    function partition_tf$3(comparator,t,f)
     {return partition_tf$1(t,f,comparator[1])}
    function iter2$2(comparator,a,b,f)
     {return caml_call1(iter2$0(a,b,comparator[1]),f)}
    function mem$7(comparator,t,a){return mem$5(t,a,comparator[1])}
    function add$3(comparator,t,a){return add$1(t,a,comparator[1])}
    function remove$2(comparator,t,a){return remove$0(t,a,comparator[1])}
    function union$1(comparator,t1,t2){return union(t1,t2,comparator[1])}
    function inter$1(comparator,t1,t2){return inter(t1,t2,comparator[1])}
    function diff$1(comparator,t1,t2){return diff(t1,t2,comparator[1])}
    function symmetric_diff$1(comparator,t1,t2)
     {return symmetric_diff(t1,t2,comparator[1])}
    function compare_direct$0(comparator,t1,t2)
     {return compare$50(comparator[1],t1,t2)}
    function equal$38(comparator,t1,t2){return equal$35(t1,t2,comparator[1])}
    function is_subset$3(comparator,t,of)
     {return is_subset(t,of,comparator[1])}
    function are_disjoint$1(comparator,t1,t2)
     {return are_disjoint(t1,t2,comparator[1])}
    function of_list$5(comparator,l){return of_list$4(l,comparator[1])}
    function of_sequence$1(comparator,s)
     {return of_sequence$0(s,comparator[1])}
    function of_array$2(comparator,a){return of_array$1(a,comparator[1])}
    function of_sorted_array_unchecked$0(comparator,a)
     {return of_sorted_array_unchecked(a,comparator[1])}
    function of_increasing_iterator_uncheck$0(param,len,f)
     {return of_increasing_iterator_uncheck(len,f)}
    function of_sorted_array$0(comparator,a)
     {return of_sorted_array(a,comparator[1])}
    function union_list$0(comparator,l)
     {return union_list(comparator,function(_uk_){return _uk_},l)}
    function stable_dedup_list$0(comparator,xs)
     {return stable_dedup_list(xs,comparator[1])}
    function group_by$1(comparator,t,equiv)
     {return group_by(t,equiv,comparator[1])}
    function split$3(comparator,t,a){return split$1(t,a,comparator[1])}
    function nth$3(t,i){return nth$1(t,i)}
    function remove_index$1(comparator,t,i)
     {return remove_index(t,i,comparator[1])}
    function sexp_of_t$50(sexp_of_a,param,t){return sexp_of_t$48(sexp_of_a,t)}
    function to_tree(t){return t}
    function of_tree(param,t){return t}
    function to_sequence$2
     (comparator,order,greater_or_equal_to,less_or_equal_to,t)
     {return to_sequence$0
              (comparator,order,greater_or_equal_to,less_or_equal_to,t)}
    function binary_search$3(param,t,compare,how,v)
     {return binary_search$1(t,compare,how,v)}
    function binary_search_segmented$3(param,t,segment_of,how)
     {return binary_search_segmented$1(t,segment_of,how)}
    function merge_to_sequence$1
     (comparator,order,greater_or_equal_to,less_or_equal_to,t$0,t)
     {return merge_to_sequence
              (comparator,order,greater_or_equal_to,less_or_equal_to,t$0,t)}
    function fold_result$7(t,init,f){return fold_result(fold$10,init,f,t)}
    function is_subset$4(comparator,t1,t2)
     {return is_subset$0(t1,t2,comparator[2],comparator[1])}
    function equal$39(comparator,t1,t2)
     {var
       _ui_=comparator[1],
       _uj_=comparator[2],
       _uh_=[0,is_subset$0(t2,t1,_uj_,_ui_),0];
      return combine_errors_unit$0([0,is_subset$0(t1,t2,_uj_,_ui_),_uh_])}
    var Named=[0,is_subset$4,equal$39];
    function to_tree$0(t){return t[2]}
    function of_tree$0(comparator,tree){return [0,comparator,tree]}
    function t_of_sexp_direct$1(comparator,a_of_sexp,sexp)
     {return [0,comparator,t_of_sexp_direct(a_of_sexp,sexp,comparator[1])]}
    function empty$2(comparator){return [0,comparator,already_seen]}
    function Empty_without_value_restrictio(Elt)
     {var empty=[0,Elt[1],already_seen];return [0,empty]}
    function singleton$4(comparator,e){return [0,comparator,[0,e]]}
    function union_list$1(comparator,l)
     {return [0,comparator,union_list(comparator,to_tree$0,l)]}
    function of_sorted_array_unchecked$1(comparator,array)
     {var tree=of_sorted_array_unchecked(array,comparator[1]);
      return [0,comparator,tree]}
    function of_increasing_iterator_uncheck$1(comparator,len,f)
     {return [0,comparator,of_increasing_iterator_uncheck(len,f)]}
    function of_sorted_array$1(comparator,array)
     {function _uf_(tree){return [0,comparator,tree]}
      var _ug_=of_sorted_array(array,comparator[1]);
      return caml_call2(include$26[2],_ug_,_uf_)}
    function of_list$6(comparator,l)
     {return [0,comparator,of_list$4(l,comparator[1])]}
    function of_sequence$2(comparator,s)
     {return [0,comparator,of_sequence$0(s,comparator[1])]}
    function of_array$3(comparator,a)
     {return [0,comparator,of_array$1(a,comparator[1])]}
    function stable_dedup_list$1(comparator,xs)
     {return stable_dedup_list(xs,comparator[1])}
    function map$29(comparator,t,f)
     {return [0,comparator,map$27(t[2],f,comparator[1])]}
    function filter_map$4(comparator,t,f)
     {return [0,comparator,filter_map$2(t[2],f,comparator[1])]}
    function comparator_s(t){var comparator=t[1];return [0,comparator]}
    function empty$3(m){return empty$2(m[1])}
    function singleton$5(m,a){return singleton$4(m[1],a)}
    function union_list$2(m,a){return union_list$1(m[1],a)}
    function of_sorted_array_unchecked$2(m,a)
     {return of_sorted_array_unchecked$1(m[1],a)}
    function of_increasing_iterator_uncheck$2(m,len,f)
     {return of_increasing_iterator_uncheck$1(m[1],len,f)}
    function of_sorted_array$2(m,a){return of_sorted_array$1(m[1],a)}
    function of_list$7(m,a){return of_list$6(m[1],a)}
    function of_sequence$3(m,a){return of_sequence$2(m[1],a)}
    function of_array$4(m,a){return of_array$3(m[1],a)}
    function stable_dedup_list$2(m,a){return stable_dedup_list$1(m[1],a)}
    function map$30(m,a,f){return map$29(m[1],a,f)}
    function filter_map$5(m,a,f){return filter_map$4(m[1],a,f)}
    function M(Elt){return [0]}
    function sexp_of_m_t(Elt)
     {return function(t)
       {function _ue_(param){return _eF_}return sexp_of_t$49(Elt[1],_ue_,t)}}
    function m_t_of_sexp(Elt)
     {return function(sexp){return t_of_sexp_direct$1(Elt[2],Elt[1],sexp)}}
    function m_t_sexp_grammar(Elt)
     {var _ud_=caml_call1(list_sexp_grammar,Elt[1]);
      return caml_call1(Sexplib0_Sexp_grammar[1],_ud_)}
    function compare_m_t(param,t1,t2){return compare_direct(t1,t2)}
    function equal_m_t(param,t1,t2){return equal$36(t1,t2)}
    function hash_fold_m_t(Elt)
     {return function(state)
       {var _ub_=Elt[1];
        return function(_uc_){return hash_fold_direct(_ub_,state,_uc_)}}}
    function hash_m_t(folder,t)
     {var _ua_=create$0(0,0),state=caml_call2(hash_fold_m_t(folder),_ua_,t);
      return runtime.Base_internalhash_get_hash_value(state)}
    var
     comparator$13=Poly[1],
     include$62=Empty_without_value_restrictio(Poly),
     empty$4=include$62[1];
    function singleton$6(a){return singleton$4(comparator$13,a)}
    function union_list$3(a){return union_list$1(comparator$13,a)}
    function of_sorted_array_unchecked$3(a)
     {return of_sorted_array_unchecked$1(comparator$13,a)}
    function of_increasing_iterator_uncheck$3(len,f)
     {return of_increasing_iterator_uncheck$1(comparator$13,len,f)}
    function of_sorted_array$3(a){return of_sorted_array$1(comparator$13,a)}
    function of_list$8(a){return of_list$6(comparator$13,a)}
    function of_sequence$4(a){return of_sequence$2(comparator$13,a)}
    function of_array$5(a){return of_array$3(comparator$13,a)}
    function stable_dedup_list$3(a)
     {return stable_dedup_list$1(comparator$13,a)}
    function map$31(a,f){return map$29(comparator$13,a,f)}
    function filter_map$6(a,f){return filter_map$4(comparator$13,a,f)}
    function of_tree$1(tree){return [0,comparator$13,tree]}
    function to_tree$1(t){return t[2]}
    var
     Base_Set=
      [0,
       compare$51,
       invariants$0,
       comparator_s,
       comparator$12,
       empty$3,
       singleton$5,
       length$13,
       is_empty$7,
       mem$6,
       add$2,
       remove$1,
       union$0,
       union_list$2,
       inter$0,
       diff$0,
       symmetric_diff$0,
       compare_direct,
       hash_fold_direct,
       equal$36,
       exists$8,
       for_all$8,
       count$7,
       sum$7,
       find$8,
       find_map$7,
       find_exn$4,
       nth$2,
       remove_index$0,
       is_subset$1,
       are_disjoint$0,
       [0,is_subset$2,equal$37],
       of_list$7,
       of_sequence$3,
       of_array$4,
       to_list$9,
       to_array$8,
       of_sorted_array$2,
       of_sorted_array_unchecked$2,
       of_increasing_iterator_uncheck$2,
       stable_dedup_list$2,
       map$30,
       filter_map$5,
       filter$5,
       fold$9,
       fold_result$6,
       fold_until$7,
       fold_right$2,
       iter$13,
       iter2$1,
       partition_tf$2,
       elements$0,
       min_elt$8,
       min_elt_exn$0,
       max_elt$8,
       max_elt_exn$0,
       choose$0,
       choose_exn$0,
       split$2,
       group_by$0,
       to_sequence$1,
       binary_search$2,
       binary_search_segmented$2,
       [0,
        Merge_with_duplicates_element[1],
        Merge_with_duplicates_element[3],
        Merge_with_duplicates_element[4]],
       merge_to_sequence$0,
       M,
       sexp_of_m_t,
       m_t_of_sexp,
       m_t_sexp_grammar,
       compare_m_t,
       equal_m_t,
       hash_fold_m_t,
       hash_m_t,
       [0,
        length$13,
        is_empty$7,
        iter$13,
        fold$9,
        fold_result$6,
        exists$8,
        for_all$8,
        count$7,
        sum$7,
        find$8,
        find_map$7,
        to_list$9,
        to_array$8,
        invariants$0,
        mem$6,
        add$2,
        remove$1,
        union$0,
        inter$0,
        diff$0,
        symmetric_diff$0,
        compare_direct,
        equal$36,
        is_subset$1,
        are_disjoint$0,
        [0,is_subset$2,equal$37],
        fold_until$7,
        fold_right$2,
        iter2$1,
        filter$5,
        partition_tf$2,
        elements$0,
        min_elt$8,
        min_elt_exn$0,
        max_elt$8,
        max_elt_exn$0,
        choose$0,
        choose_exn$0,
        split$2,
        group_by$0,
        find_exn$4,
        nth$2,
        remove_index$0,
        to_tree$1,
        to_sequence$1,
        binary_search$2,
        binary_search_segmented$2,
        merge_to_sequence$0,
        empty$4,
        singleton$6,
        union_list$3,
        of_list$8,
        of_sequence$4,
        of_array$5,
        of_sorted_array$3,
        of_sorted_array_unchecked$3,
        of_increasing_iterator_uncheck$3,
        stable_dedup_list$3,
        map$31,
        filter_map$6,
        of_tree$1],
       [0,
        sexp_of_t$49,
        t_of_sexp_direct$1,
        [0,
         sexp_of_t$50,
         t_of_sexp_direct$0,
         Named,
         length$14,
         is_empty$8,
         iter$14,
         fold$10,
         fold_result$7,
         exists$9,
         for_all$9,
         count$8,
         sum$8,
         find$9,
         find_map$8,
         to_list$10,
         to_array$9,
         invariants$1,
         mem$7,
         add$3,
         remove$2,
         union$1,
         inter$1,
         diff$1,
         symmetric_diff$1,
         compare_direct$0,
         equal$38,
         is_subset$3,
         are_disjoint$1,
         fold_until$8,
         fold_right$3,
         iter2$2,
         filter$6,
         partition_tf$3,
         elements$1,
         min_elt$9,
         min_elt_exn$1,
         max_elt$9,
         max_elt_exn$1,
         choose$1,
         choose_exn$1,
         split$3,
         group_by$1,
         find_exn$5,
         nth$3,
         remove_index$1,
         to_tree,
         to_sequence$2,
         binary_search$3,
         binary_search_segmented$3,
         merge_to_sequence$1,
         empty$1,
         singleton$3,
         union_list$0,
         of_list$5,
         of_sequence$1,
         of_array$2,
         of_sorted_array$0,
         of_sorted_array_unchecked$0,
         of_increasing_iterator_uncheck$0,
         stable_dedup_list$0,
         map$28,
         filter_map$3,
         of_tree,
         already_seen],
        length$13,
        is_empty$7,
        iter$13,
        fold$9,
        fold_result$6,
        exists$8,
        for_all$8,
        count$7,
        sum$7,
        find$8,
        find_map$7,
        to_list$9,
        to_array$8,
        invariants$0,
        mem$6,
        add$2,
        remove$1,
        union$0,
        inter$0,
        diff$0,
        symmetric_diff$0,
        compare_direct,
        equal$36,
        is_subset$1,
        are_disjoint$0,
        [0,is_subset$2,equal$37],
        fold_until$7,
        fold_right$2,
        iter2$1,
        filter$5,
        partition_tf$2,
        elements$0,
        min_elt$8,
        min_elt_exn$0,
        max_elt$8,
        max_elt_exn$0,
        choose$0,
        choose_exn$0,
        split$2,
        group_by$0,
        find_exn$4,
        nth$2,
        remove_index$0,
        to_tree$0,
        to_sequence$1,
        binary_search$2,
        binary_search_segmented$2,
        merge_to_sequence$0,
        empty$2,
        singleton$4,
        union_list$1,
        of_list$6,
        of_sequence$2,
        of_array$3,
        of_sorted_array$1,
        of_sorted_array_unchecked$1,
        of_increasing_iterator_uncheck$1,
        stable_dedup_list$1,
        map$29,
        filter_map$4,
        of_tree$0,
        comparator$12,
        hash_fold_direct,
        Empty_without_value_restrictio]];
    caml_register_global(1108,Base_Set,"Base__Set");
    function t_sexp_grammar$28(a_sexp_grammar)
     {return caml_call1(ref_sexp_grammar,a_sexp_grammar)}
    function swap$5(t1,t2){var tmp=t1[1];t1[1] = t2[1];t2[1] = tmp;return 0}
    function replace(t,f){t[1] = caml_call1(f,t[1]);return 0}
    function set_temporarily(t,a,f)
     {var restore_to=t[1];
      t[1] = a;
      return protect(f,function(param){t[1] = restore_to;return 0})}
    function set$3(param){var a=param[2],r=param[1];r[1] = a;return 0}
    function sets(ts){return iter$0(ts,set$3)}
    function snapshot(param){var r=param[1];return [0,r,r[1]]}
    function sets_temporarily(and_values,f)
     {var restore_to=map$9(and_values,snapshot);
      sets(and_values);
      return protect(f,function(param){return sets(restore_to)})}
    var
     Base_Ref=
      [0,
       compare_ref$0,
       equal_ref$0,
       ref_of_sexp,
       sexp_of_ref,
       t_sexp_grammar$28,
       swap$5,
       replace,
       set_temporarily,
       [0,set$3,sets,snapshot],
       sets_temporarily];
    caml_register_global(1109,Base_Ref,"Base__Ref");
    var Base_Queue_intf=[0];
    caml_register_global(1110,Base_Queue_intf,"Base__Queue_intf");
    function inc_num_mutations(t){t[1] = t[1] + 1 | 0;return 0}
    function capacity$0(t){return t[3] + 1 | 0}
    function elts_index(t,i){return (t[2] + i | 0) & t[3]}
    function unsafe_get$2(t,i)
     {var _t$_=elts_index(t,i);return unsafe_get_some_exn(t[5],_t$_)}
    function unsafe_set$2(t,i,a)
     {var _t__=elts_index(t,i);return unsafe_set_some(t[5],_t__,a)}
    function check_index_exn(t,i)
     {var _t7_=i < 0?1:0,_t8_=_t7_ || (t[4] <= i?1:0);
      if(! _t8_)return _t8_;
      var _t9_=[0,[0,cst_length,caml_call1(sexp_of_t$33,t[4])],0];
      return raise_s
              (caml_call2
                (message,
                 cst_Queue_index_out_of_bounds,
                 [0,[0,cst_index,caml_call1(sexp_of_t$33,i)],_t9_]))}
    function get$5(t,i){check_index_exn(t,i);return unsafe_get$2(t,i)}
    function set$4(t,i,a)
     {check_index_exn(t,i);inc_num_mutations(t);return unsafe_set$2(t,i,a)}
    function is_empty$9(t){return 0 === t[4]?1:0}
    function length$15(param){var length=param[4];return length}
    function ensure_no_mutation(t,num_mutations)
     {var _t5_=t[1] !== num_mutations?1:0;
      if(! _t5_)return _t5_;
      var _t6_=0;
      function of_a_001(param){return _eL_}
      var
       num_mutations_003=t[1],
       front_005=t[2],
       mask_007=t[3],
       length_009=t[4],
       elts_011=t[5],
       arg_012=sexp_of_t$38(of_a_001,elts_011),
       bnds_002=[0,[1,[0,_eG_,[0,arg_012,0]]],0],
       arg_010=caml_call1(sexp_of_t$4,length_009),
       bnds_002$0=[0,[1,[0,_eH_,[0,arg_010,0]]],bnds_002],
       arg_008=caml_call1(sexp_of_t$4,mask_007),
       bnds_002$1=[0,[1,[0,_eI_,[0,arg_008,0]]],bnds_002$0],
       arg_006=caml_call1(sexp_of_t$4,front_005),
       bnds_002$2=[0,[1,[0,_eJ_,[0,arg_006,0]]],bnds_002$1],
       arg_004=caml_call1(sexp_of_t$4,num_mutations_003),
       bnds_002$3=[0,[1,[0,_eK_,[0,arg_004,0]]],bnds_002$2];
      return raise_s
              (caml_call2
                (message,
                 cst_mutation_of_queue_during_i,
                 [0,[0,cst$29,[1,bnds_002$3]],_t6_]))}
    function compare$52(compare_elt,t1,t2)
     {if(t1 === t2)return 0;
      var pos=0,_t1_=t2[1],_t2_=t1[1],_t3_=t2[4],_t4_=t1[4];
      for(;;)
       {var match=pos === _t3_?1:0;
        if(pos === _t4_)return match?0:-1;
        if(match)return 1;
        var
         _t0_=unsafe_get$2(t2,pos),
         x=caml_call2(compare_elt,unsafe_get$2(t1,pos),_t0_);
        ensure_no_mutation(t1,_t2_);
        ensure_no_mutation(t2,_t1_);
        if(0 !== x)return x;
        var pos$0=pos + 1 | 0,pos=pos$0}}
    function equal$40(equal_elt,t1,t2)
     {var _tV_=t1 === t2?1:0;
      if(_tV_)
       var _tW_=_tV_;
      else
       {var len1=t1[4],len2=t2[4],_tX_=len1 === len2?1:0;
        if(_tX_)
         {var pos=0,_tY_=t2[1],_tZ_=t1[1];
          for(;;)
           {var _tS_=pos === len1?1:0;
            if(_tS_)
             var _tT_=_tS_;
            else
             {var
               _tU_=unsafe_get$2(t2,pos),
               b=caml_call2(equal_elt,unsafe_get$2(t1,pos),_tU_);
              ensure_no_mutation(t1,_tZ_);
              ensure_no_mutation(t2,_tY_);
              if(b){var pos$0=pos + 1 | 0,pos=pos$0;continue}
              var _tT_=b}
            return _tT_}}
        var _tW_=_tX_}
      return _tW_}
    function invariant$17(invariant_a,t)
     {var num_mutations=t[1],front=t[2],length=t[4],elts=t[5];
      if(0 > front)throw [0,Assert_failure$0,_eT_];
      if(front >= capacity$0(t))throw [0,Assert_failure$0,_eS_];
      var capacity=capacity$0(t);
      if(capacity !== caml_call1(length$9,elts))
       throw [0,Assert_failure$0,_eR_];
      if(1 > capacity)throw [0,Assert_failure$0,_eQ_];
      if(! is_pow2(capacity))throw [0,Assert_failure$0,_eP_];
      if(0 > length)throw [0,Assert_failure$0,_eO_];
      if(length > capacity)throw [0,Assert_failure$0,_eN_];
      var _tQ_=capacity - 1 | 0,_tP_=0;
      if(_tQ_ >= 0)
       {var i=_tP_;
        for(;;)
         {if(i < t[4])
           {caml_call1(invariant_a,unsafe_get$2(t,i));
            ensure_no_mutation(t,num_mutations)}
          else
           {var _tO_=elts_index(t,i);
            if(unsafe_is_some(t[5],_tO_))throw [0,Assert_failure$0,_eM_]}
          var _tR_=i + 1 | 0;
          if(_tQ_ !== i){var i=_tR_;continue}
          break}}
      return 0}
    function create$13(capacity,param)
     {if(capacity)
       var
        capacity$0=capacity[1],
        _tN_=
         0 <= capacity$0
          ?0 === capacity$0?1:ceil_pow2(capacity$0)
          :raise_s
            (caml_call2
              (message,
               cst_cannot_have_queue_with_neg,
               [0,[0,cst_capacity,caml_call1(sexp_of_t$33,capacity$0)],0])),
        capacity$1=_tN_;
      else
       var capacity$1=1;
      return [0,0,0,capacity$1 - 1 | 0,0,create$10(capacity$1)]}
    function blit_to_array(src,dst)
     {var _tK_=caml_call1(length$9,dst);
      if(src[4] > _tK_)throw [0,Assert_failure$0,_eU_];
      var
       _tL_=src[2],
       _tM_=capacity$0(src) - _tL_ | 0,
       front_len=caml_call2(min$25,src[4],_tM_),
       rest_len=src[4] - front_len | 0;
      caml_call5(blit$5,src[5],src[2],dst,0,front_len);
      return caml_call5(blit$5,src[5],0,dst,front_len,rest_len)}
    function set_capacity$0(t,desired_capacity)
     {inc_num_mutations(t);
      var
       new_capacity=
        ceil_pow2(caml_call2(max$2,1,caml_call2(max$2,desired_capacity,t[4]))),
       _tI_=new_capacity !== capacity$0(t)?1:0;
      if(_tI_)
       {var dst=create$10(new_capacity);
        blit_to_array(t,dst);
        t[2] = 0;
        t[3] = new_capacity - 1 | 0;
        t[5] = dst;
        var _tJ_=0}
      else
       var _tJ_=_tI_;
      return _tJ_}
    function enqueue(t,a)
     {inc_num_mutations(t);
      var _tH_=capacity$0(t);
      if(t[4] === _tH_)set_capacity$0(t,2 * t[4] | 0);
      unsafe_set$2(t,t[4],a);
      t[4] = t[4] + 1 | 0;
      return 0}
    function dequeue_nonempty(t)
     {inc_num_mutations(t);
      var elts=t[5],front=t[2],res=get_some_exn(elts,front);
      set_none(elts,front);
      t[2] = elts_index(t,1);
      t[4] = t[4] - 1 | 0;
      return res}
    function dequeue_exn(t)
     {if(is_empty$9(t))throw Stdlib_Queue[1];return dequeue_nonempty(t)}
    function dequeue(t){return is_empty$9(t)?0:[0,dequeue_nonempty(t)]}
    function front_nonempty(t){return unsafe_get_some_exn(t[5],t[2])}
    function last_nonempty(t){return unsafe_get$2(t,t[4] - 1 | 0)}
    function peek(t){return is_empty$9(t)?0:[0,front_nonempty(t)]}
    function peek_exn(t)
     {if(is_empty$9(t))throw Stdlib_Queue[1];return front_nonempty(t)}
    function last$1(t){return is_empty$9(t)?0:[0,last_nonempty(t)]}
    function last_exn$0(t)
     {if(is_empty$9(t))throw Stdlib_Queue[1];return last_nonempty(t)}
    function clear$1(t)
     {inc_num_mutations(t);
      var _tC_=0 < t[4]?1:0;
      if(_tC_)
       {var _tE_=t[4] - 1 | 0,_tD_=0;
        if(_tE_ >= 0)
         {var i=_tD_;
          for(;;)
           {var _tB_=elts_index(t,i);
            unsafe_set_none(t[5],_tB_);
            var _tG_=i + 1 | 0;
            if(_tE_ !== i){var i=_tG_;continue}
            break}}
        t[4] = 0;
        t[2] = 0;
        var _tF_=0}
      else
       var _tF_=_tC_;
      return _tF_}
    function blit_transfer(src,dst,len,param)
     {inc_num_mutations(src);
      inc_num_mutations(dst);
      if(len)
       {var len$0=len[1];
        if(len$0 < 0)
         raise_s
          (caml_call2
            (message,
             cst_Queue_blit_transfer_negati,
             [0,[0,cst_length$0,caml_call1(sexp_of_t$33,len$0)],0]));
        var len$1=caml_call2(min$2,len$0,src[4])}
      else
       var len$1=src[4];
      var _tu_=0 < len$1?1:0;
      if(_tu_)
       {var _tv_=dst[4] + len$1 | 0;
        set_capacity$0(dst,caml_call2(max$2,capacity$0(dst),_tv_));
        var dst_start=dst[2] + dst[4] | 0,_tx_=len$1 - 1 | 0,_tw_=0;
        if(_tx_ >= 0)
         {var i=_tw_;
          for(;;)
           {var
             src_i=(src[2] + i | 0) & src[3],
             dst_i=(dst_start + i | 0) & dst[3],
             _tz_=unsafe_get_some_exn(src[5],src_i);
            unsafe_set_some(dst[5],dst_i,_tz_);
            unsafe_set_none(src[5],src_i);
            var _tA_=i + 1 | 0;
            if(_tx_ !== i){var i=_tA_;continue}
            break}}
        dst[4] = dst[4] + len$1 | 0;
        src[2] = (src[2] + len$1 | 0) & src[3];
        src[4] = src[4] - len$1 | 0;
        var _ty_=0}
      else
       var _ty_=_tu_;
      return _ty_}
    function enqueue_all(t,l)
     {var _ts_=caml_call1(length,l),_tt_=t[4] + _ts_ | 0;
      set_capacity$0(t,caml_call2(max$25,capacity$0(t),_tt_));
      return iter$0(l,function(x){return enqueue(t,x)})}
    function fold$11(t,init,f)
     {if(0 === t[4])return init;
      var num_mutations=t[1],r=[0,init],_tp_=t[4] - 1 | 0,_to_=0;
      if(_tp_ >= 0)
       {var i=_to_;
        for(;;)
         {var _tq_=unsafe_get$2(t,i);
          r[1] = caml_call2(f,r[1],_tq_);
          ensure_no_mutation(t,num_mutations);
          var _tr_=i + 1 | 0;
          if(_tp_ !== i){var i=_tr_;continue}
          break}}
      return r[1]}
    function foldi$8(t,init,f)
     {var i=[0,0];
      return fold$11
              (t,
               init,
               function(acc,a)
                {var acc$0=caml_call3(f,i[1],acc,a);
                 i[1] = i[1] + 1 | 0;
                 return acc$0})}
    function iter$15(t,f)
     {var num_mutations=t[1],_tm_=t[4] - 1 | 0,_tl_=0;
      if(_tm_ >= 0)
       {var i=_tl_;
        for(;;)
         {caml_call1(f,unsafe_get$2(t,i));
          ensure_no_mutation(t,num_mutations);
          var _tn_=i + 1 | 0;
          if(_tm_ !== i){var i=_tn_;continue}
          break}}
      return 0}
    function iteri$7(t,f)
     {var num_mutations=t[1],_tj_=t[4] - 1 | 0,_ti_=0;
      if(_tj_ >= 0)
       {var i=_ti_;
        for(;;)
         {caml_call2(f,i,unsafe_get$2(t,i));
          ensure_no_mutation(t,num_mutations);
          var _tk_=i + 1 | 0;
          if(_tj_ !== i){var i=_tk_;continue}
          break}}
      return 0}
    function to_list$11(t)
     {var result=[0,0],_tf_=t[4] - 1 | 0;
      if(_tf_ >= 0)
       {var i=_tf_;
        for(;;)
         {var _tg_=result[1];
          result[1] = [0,unsafe_get$2(t,i),_tg_];
          var _th_=i - 1 | 0;
          if(0 !== i){var i=_th_;continue}
          break}}
      return result[1]}
    var
     iter$16=[0,-198771759,iter$15],
     length$16=[0,-198771759,length$15],
     foldi$9=[0,-198771759,foldi$8],
     iteri$8=[0,-198771759,iteri$7],
     C$0=_a__([0,fold$11,iter$16,length$16,iteri$8,foldi$9]),
     count$9=C$0[10],
     exists$10=C$0[8],
     find$10=C$0[12],
     find_map$9=C$0[13],
     fold_result$8=C$0[6],
     fold_until$9=C$0[7],
     for_all$10=C$0[9],
     max_elt$10=C$0[17],
     mem$8=C$0[1],
     min_elt$10=C$0[16],
     sum$9=C$0[11],
     counti$5=C$0[22],
     existsi$5=C$0[20],
     find_mapi$5=C$0[24],
     findi$5=C$0[23],
     for_alli$5=C$0[21];
    function concat_map$2(t,f)
     {var t_result=create$13(0,0);
      iter$15
       (t,
        function(a)
         {function _te_(b){return enqueue(t_result,b)}
          return iter$0(caml_call1(f,a),_te_)});
      return t_result}
    function concat_mapi$2(t,f)
     {var t_result=create$13(0,0);
      iteri$7
       (t,
        function(i,a)
         {function _td_(b){return enqueue(t_result,b)}
          return iter$0(caml_call2(f,i,a),_td_)});
      return t_result}
    function filter_map$7(t,f)
     {var t_result=create$13(0,0);
      iter$15
       (t,
        function(a)
         {var match=caml_call1(f,a);
          if(! match)return 0;
          var b=match[1];
          return enqueue(t_result,b)});
      return t_result}
    function filter_mapi$2(t,f)
     {var t_result=create$13(0,0);
      iteri$7
       (t,
        function(i,a)
         {var match=caml_call2(f,i,a);
          if(! match)return 0;
          var b=match[1];
          return enqueue(t_result,b)});
      return t_result}
    function filter$7(t,f)
     {var t_result=create$13(0,0);
      iter$15
       (t,
        function(a)
         {var _tc_=caml_call1(f,a);return _tc_?enqueue(t_result,a):_tc_});
      return t_result}
    function filteri$3(t,f)
     {var t_result=create$13(0,0);
      iteri$7
       (t,
        function(i,a)
         {var _tb_=caml_call2(f,i,a);return _tb_?enqueue(t_result,a):_tb_});
      return t_result}
    function filter_inplace(t,f)
     {var t2=filter$7(t,f);clear$1(t);return blit_transfer(t2,t,0,0)}
    function filteri_inplace(t,f)
     {var t2=filteri$3(t,f);clear$1(t);return blit_transfer(t2,t,0,0)}
    function copy$5(src)
     {var dst=create$13([0,src[4]],0);
      blit_to_array(src,dst[5]);
      dst[4] = src[4];
      return dst}
    function of_list$9(l)
     {var t=create$13([0,caml_call1(length,l)],0);
      iter$0(l,function(x){return enqueue(t,x)});
      return t}
    function init$7(len,f)
     {if(len < 0)
       raise_s
        (caml_call2
          (message,
           cst_Queue_init_negative_length,
           [0,[0,cst_length$1,caml_call1(sexp_of_t$33,len)],0]));
      var t=create$13([0,len],0);
      if(len > caml_call1(length$9,t[5]))throw [0,Assert_failure$0,_eV_];
      var _s__=len - 1 | 0,_s9_=0;
      if(_s__ >= 0)
       {var i=_s9_;
        for(;;)
         {var _s$_=caml_call1(f,i);
          unsafe_set_some(t[5],i,_s$_);
          var _ta_=i + 1 | 0;
          if(_s__ !== i){var i=_ta_;continue}
          break}}
      t[4] = len;
      return t}
    function of_array$6(a)
     {return init$7(a.length - 1,function(_s8_){return a[1 + _s8_]})}
    function to_array$10(t)
     {function _s7_(i){return unsafe_get$2(t,i)}
      return caml_call2(init,t[4],_s7_)}
    function map$32(ta,f)
     {var num_mutations=ta[1],tb=create$13([0,ta[4]],0);
      tb[4] = ta[4];
      var _s5_=ta[4] - 1 | 0,_s4_=0;
      if(_s5_ >= 0)
       {var i=_s4_;
        for(;;)
         {var b=caml_call1(f,unsafe_get$2(ta,i));
          ensure_no_mutation(ta,num_mutations);
          unsafe_set_some(tb[5],i,b);
          var _s6_=i + 1 | 0;
          if(_s5_ !== i){var i=_s6_;continue}
          break}}
      return tb}
    function mapi$6(t,f)
     {var i=[0,0];
      return map$32
              (t,
               function(a)
                {var result=caml_call2(f,i[1],a);
                 i[1] = i[1] + 1 | 0;
                 return result})}
    function singleton$7(x){var t=create$13(0,0);enqueue(t,x);return t}
    function sexp_of_t$51(sexp_of_a,t)
     {var _s3_=to_list$11(t);
      return caml_call1(caml_call1(sexp_of_t$10,sexp_of_a),_s3_)}
    function t_of_sexp$29(a_of_sexp,sexp)
     {return of_list$9(caml_call2(t_of_sexp$10,a_of_sexp,sexp))}
    function t_sexp_grammar$29(grammar)
     {var _s2_=t_sexp_grammar$12(grammar);
      return caml_call1(Sexplib0_Sexp_grammar[1],_s2_)}
    var
     Base_Queue=
      [0,
       compare$52,
       t_of_sexp$29,
       sexp_of_t$51,
       t_sexp_grammar$29,
       mem$8,
       length$15,
       is_empty$9,
       iter$15,
       fold$11,
       fold_result$8,
       fold_until$9,
       exists$10,
       for_all$10,
       count$9,
       sum$9,
       find$10,
       find_map$9,
       to_list$11,
       to_array$10,
       min_elt$10,
       max_elt$10,
       foldi$8,
       iteri$7,
       existsi$5,
       for_alli$5,
       counti$5,
       findi$5,
       find_mapi$5,
       singleton$7,
       of_list$9,
       of_array$6,
       init$7,
       enqueue,
       enqueue_all,
       dequeue,
       dequeue_exn,
       peek,
       peek_exn,
       clear$1,
       copy$5,
       map$32,
       mapi$6,
       concat_map$2,
       concat_mapi$2,
       filter_map$7,
       filter_mapi$2,
       filter$7,
       filteri$3,
       filter_inplace,
       filteri_inplace,
       equal$40,
       invariant$17,
       create$13,
       last$1,
       last_exn$0,
       blit_transfer,
       get$5,
       set$4,
       capacity$0,
       set_capacity$0];
    caml_register_global(1112,Base_Queue,"Base__Queue");
    function to_string$14(param){throw [0,Match_failure$0,_eW_]}
    var all$18=0;
    function hash_fold_t$27(param,t){return to_string$14(t)}
    function compare$53(a,param){return to_string$14(a)}
    function t_of_sexp$30(sexp)
     {return caml_call2(Sexplib0_Sexp_conv_error[26],cst_Base_Nothing_t,sexp)}
    function of_string$13(param)
     {return caml_call1(failwith$0,cst_Base_Nothing_of_string_not)}
    var
     include$63=
      _a1_
       ([0,
         compare$53,
         hash_fold_t$27,
         to_string$14,
         t_of_sexp$30,
         to_string$14,
         of_string$13,
         to_string$14,
         module_name$10]),
     hash_fold_t$28=include$63[1],
     hash$18=include$63[2],
     t_of_sexp$31=include$63[3],
     sexp_of_t$52=include$63[4],
     of_string$14=include$63[5],
     to_string$15=include$63[6],
     symbol$165=include$63[7],
     symbol$166=include$63[8],
     symbol$167=include$63[9],
     symbol$168=include$63[10],
     symbol$169=include$63[11],
     symbol$170=include$63[12],
     equal$41=include$63[13],
     compare$54=include$63[14],
     min$30=include$63[15],
     max$30=include$63[16],
     ascending$24=include$63[17],
     descending$24=include$63[18],
     between$10=include$63[19],
     clamp_exn$10=include$63[20],
     clamp$10=include$63[21],
     comparator$14=include$63[22],
     pp$14=include$63[23],
     hashable$5=include$63[24],
     Base_Nothing=
      [0,
       all$18,
       t_sexp_grammar$30,
       to_string$14,
       hash_fold_t$28,
       hash$18,
       t_of_sexp$31,
       sexp_of_t$52,
       of_string$14,
       to_string$15,
       symbol$165,
       symbol$166,
       symbol$167,
       symbol$168,
       symbol$169,
       symbol$170,
       equal$41,
       compare$54,
       min$30,
       max$30,
       ascending$24,
       descending$24,
       between$10,
       clamp_exn$10,
       clamp$10,
       comparator$14,
       pp$14,
       hashable$5];
    caml_register_global(1114,Base_Nothing,"Base__Nothing");
    var compare$55=include$3[9];
    function func$9(x){return caml_call1(func,x)}
    var
     hashable$6=[0,func$9,compare$55,sexp_of_t$8],
     compare$56=include$3[9],
     to_string$16=Stdlib_Nativeint[15],
     of_string$15=caml_int_of_string,
     comparator$15=_P_([0,compare$56,sexp_of_t$8])[1],
     zero$0=Stdlib_Nativeint[1],
     _eX_=_aY_([0,compare$56,sexp_of_t$8,zero$0]),
     is_positive$0=_eX_[1],
     is_non_negative$0=_eX_[2],
     is_negative$0=_eX_[3],
     is_non_positive$0=_eX_[4],
     sign$0=_eX_[5],
     include$64=_cH_([0,to_string$16]),
     to_string_hum$2=include$64[1],
     sexp_of_t$53=include$64[2];
    function hash$19(x){return caml_call1(func,x)}
    var zero$1=Stdlib_Nativeint[1];
    function neg$1(_s1_){return - _s1_ | 0}
    var symbol$171=include$3[1];
    function to_string$17(i){return caml_call2(sprintf,_eY_,i)}
    function of_string$16(s)
     {function _sZ_(_s0_){return _s0_}
      return caml_call3(Stdlib_Scanf[4],s,_eZ_,_sZ_)}
    var
     include$65=
      _cG_
       ([0,
         compare$13,
         hash_fold_t$0,
         hash$19,
         to_string$17,
         of_string$16,
         zero$1,
         symbol$171,
         neg$1,
         module_name$11]),
     Hex$0=include$65[1],
     include$66=_w_([0,module_name$12,to_string$16]),
     _e0_=include$66[1];
    function invariant$18(param){return 0}
    var
     num_bits$1=num_bits$0(word_size),
     float_lower_bound$0=lower_bound_for_int(num_bits$1),
     float_upper_bound$0=upper_bound_for_int(num_bits$1);
    function lsr$0(_sY_,_sX_){return _sY_ >>> _sX_ | 0}
    function asr$0(_sW_,_sV_){return _sW_ >> _sV_}
    function lsl$0(_sU_,_sT_){return _sU_ << _sT_}
    var lnot$1=Stdlib_Nativeint[12];
    function lxor$0(_sS_,_sR_){return _sS_ ^ _sR_}
    function lor$0(_sQ_,_sP_){return _sQ_ | _sP_}
    function land$0(_sO_,_sN_){return _sO_ & _sN_}
    var
     min_value$3=Stdlib_Nativeint[11],
     max_value$3=Stdlib_Nativeint[10],
     abs$3=Stdlib_Nativeint[8],
     pred$2=Stdlib_Nativeint[7],
     succ$3=Stdlib_Nativeint[6],
     rem$0=caml_mod;
    function neg$2(_sM_){return - _sM_ | 0}
    var
     minus_one$0=Stdlib_Nativeint[3],
     one$0=Stdlib_Nativeint[2],
     zero$2=Stdlib_Nativeint[1];
    function to_float$1(_sL_){return _sL_}
    function of_float_unchecked$0(_sK_){return _sK_ | 0}
    function of_float$0(f)
     {if
       (caml_call2(include$7[6],f,float_lower_bound$0)
        &&
        caml_call2(include$7[2],f,float_upper_bound$0))
       return f | 0;
      return caml_call2(invalid_argf(_e1_),f + 0.,0)}
    function non_positive_argument$0(param)
     {return caml_call1(invalid_argf(_e2_),0)}
    function ceil_pow2$0(x)
     {if(caml_call2(include$3[2],x,0))non_positive_argument$0(0);
      var
       x$0=caml_call1(Stdlib_Nativeint[7],x),
       x$1=x$0 | x$0 >>> 1 | 0,
       x$2=x$1 | x$1 >>> 2 | 0,
       x$3=x$2 | x$2 >>> 4 | 0,
       x$4=x$3 | x$3 >>> 8 | 0,
       x$5=x$4 | x$4 >>> 16 | 0,
       x$6=x$5 | x$5 >>> 32 | 0;
      return caml_call1(Stdlib_Nativeint[6],x$6)}
    function floor_pow2$0(x)
     {if(caml_call2(include$3[2],x,0))non_positive_argument$0(0);
      var
       x$0=x | x >>> 1 | 0,
       x$1=x$0 | x$0 >>> 2 | 0,
       x$2=x$1 | x$1 >>> 4 | 0,
       x$3=x$2 | x$2 >>> 8 | 0,
       x$4=x$3 | x$3 >>> 16 | 0,
       x$5=x$4 | x$4 >>> 32 | 0;
      return x$5 - (x$5 >>> 1 | 0) | 0}
    function is_pow2$0(x)
     {if(caml_call2(include$3[2],x,0))non_positive_argument$0(0);
      var _sJ_=x & caml_call1(Stdlib_Nativeint[7],x);
      return caml_call2(include$3[4],_sJ_,0)}
    function floor_log2$0(i)
     {if(caml_lessequal(i,Stdlib_Nativeint[1]))
       raise_s
        (caml_call2
          (message,
           cst_Nativeint_floor_log2_got_i,
           [0,[0,cst$30,caml_call1(sexp_of_t$8,i)],0]));
      return (num_bits$1 - 1 | 0) - runtime.Base_int_math_nativeint_clz(i) | 0}
    function ceil_log2$0(i)
     {if(caml_lessequal(i,Stdlib_Nativeint[1]))
       raise_s
        (caml_call2
          (message,
           cst_Nativeint_ceil_log2_got_in,
           [0,[0,cst$31,caml_call1(sexp_of_t$8,i)],0]));
      return caml_call2(Stdlib_Nativeint[18],i,Stdlib_Nativeint[2])
              ?0
              :num_bits$1
               -
               runtime.Base_int_math_nativeint_clz
                (caml_call1(Stdlib_Nativeint[7],i))
               |
               0}
    function between$11(t,low,high)
     {var _sI_=caml_call2(include$3[2],low,t);
      return _sI_?caml_call2(include$3[2],t,high):_sI_}
    function clamp_unchecked$3(t,min,max)
     {return caml_call2(include$3[1],t,min)
              ?min
              :caml_call2(include$3[2],t,max)?t:max}
    function clamp_exn$11(t,min,max)
     {if(caml_call2(include$3[2],min,max))return clamp_unchecked$3(t,min,max);
      throw [0,Assert_failure$0,_e3_]}
    function clamp$11(t,min,max)
     {if(! caml_call2(include$3[5],min,max))
       return [0,clamp_unchecked$3(t,min,max)];
      var _sH_=[0,[0,cst_max$4,caml_call1(sexp_of_t$8,max)],0];
      return error_s
              (caml_call2
                (message,
                 cst_clamp_requires_min_max$4,
                 [0,[0,cst_min$4,caml_call1(sexp_of_t$8,min)],_sH_]))}
    var symbol$172=caml_div,symbol$173=caml_mul;
    function symbol$174(_sG_,_sF_){return _sG_ - _sF_ | 0}
    function symbol$175(_sE_,_sD_){return _sE_ + _sD_ | 0}
    function incr$1(r){r[1] = r[1] + one$0 | 0;return 0}
    function decr$1(r){r[1] = r[1] - one$0 | 0;return 0}
    function of_nativeint(t){return t}
    function to_nativeint$0(t){return t}
    function pow$0(b,e)
     {var _sB_=nativeint_to_int_exn(e),_sC_=nativeint_to_int_exn(b);
      return caml_call2(Private$3[1],_sC_,_sB_)}
    function symbol$176(b,e){return pow$0(b,e)}
    var
     symbol$177=include$3[3],
     symbol$178=include$3[1],
     symbol$179=include$3[5],
     symbol$180=include$3[4],
     symbol$181=include$3[2],
     symbol$182=include$3[6],
     include$67=
      _c2_
       ([0,
         of_float$0,
         to_float$1,
         of_string$15,
         to_string$16,
         symbol$175,
         symbol$174,
         symbol$173,
         symbol$172,
         neg$2,
         symbol$182,
         symbol$181,
         symbol$180,
         symbol$179,
         symbol$178,
         symbol$177,
         abs$3,
         neg$2,
         zero$2,
         int_to_nativeint,
         rem$0]),
     symbol$183=include$67[1],
     symbol$184=include$67[2],
     symbol$185=include$67[3],
     round$0=include$67[4],
     round_towards_zero$0=include$67[5],
     round_down$0=include$67[6],
     round_up$0=include$67[7],
     round_nearest$0=include$67[8],
     symbol$186=include$3[1],
     symbol$187=include$3[2],
     symbol$188=include$3[3],
     symbol$189=include$3[4],
     symbol$190=include$3[5],
     symbol$191=include$3[6],
     ascending$25=include$3[7],
     descending$25=include$3[8],
     compare_nativeint$0=include$3[9],
     equal_nativeint$1=include$3[10],
     max$31=include$3[11],
     min$31=include$3[12],
     _e4_=caml_int32_bswap,
     _e5_=
      [0,
       symbol$175,
       symbol$174,
       symbol$173,
       symbol$172,
       neg$2,
       symbol$176,
       symbol$182,
       symbol$181,
       symbol$180,
       symbol$179,
       symbol$178,
       symbol$177,
       abs$3,
       neg$2,
       zero$2,
       symbol$183,
       symbol$184,
       symbol$185,
       land$0,
       lor$0,
       lxor$0,
       lnot$1,
       lsl$0,
       asr$0,
       lsr$0];
    function _e6_(_sA_){return runtime.Base_int_math_nativeint_ctz(_sA_)}
    var
     Base_Nativeint=
      [0,
       t_sexp_grammar$7,
       of_float$0,
       to_float$1,
       int_to_nativeint,
       nativeint_to_int_exn,
       hash_fold_t$0,
       func$9,
       t_of_sexp$8,
       sexp_of_t$53,
       of_string$15,
       to_string$16,
       symbol$191,
       symbol$187,
       symbol$189,
       symbol$190,
       symbol$186,
       symbol$188,
       equal_nativeint$1,
       compare_nativeint$0,
       min$31,
       max$31,
       ascending$25,
       descending$25,
       between$11,
       clamp_exn$11,
       clamp$11,
       comparator$15,
       _e0_,
       hashable$6,
       is_positive$0,
       is_non_negative$0,
       is_negative$0,
       is_non_positive$0,
       sign$0,
       invariant$18,
       Hex$0,
       to_string_hum$2,
       zero$2,
       one$0,
       minus_one$0,
       symbol$175,
       symbol$174,
       symbol$173,
       symbol$176,
       neg$2,
       neg$2,
       symbol$184,
       symbol$183,
       symbol$172,
       rem$0,
       symbol$185,
       land$0,
       lor$0,
       lxor$0,
       lnot$1,
       lsl$0,
       asr$0,
       round$0,
       round_towards_zero$0,
       round_down$0,
       round_up$0,
       round_nearest$0,
       abs$3,
       succ$3,
       pred$2,
       pow$0,
       land$0,
       lor$0,
       lxor$0,
       lnot$1,
       popcount,
       lsl$0,
       asr$0,
       decr$1,
       incr$1,
       int32_to_nativeint,
       nativeint_to_int32_exn,
       to_nativeint_exn,
       nativeint_to_int64,
       of_nativeint,
       to_nativeint$0,
       of_float_unchecked$0,
       num_bits$1,
       max_value$3,
       min_value$3,
       lsr$0,
       lsr$0,
       ceil_pow2$0,
       floor_pow2$0,
       ceil_log2$0,
       floor_log2$0,
       is_pow2$0,
       function(_sz_){return runtime.Base_int_math_nativeint_clz(_sz_)},
       _e6_,
       _e5_,
       int_to_nativeint,
       nativeint_to_int,
       int32_to_nativeint,
       nativeint_to_int32,
       of_nativeint,
       to_nativeint$0,
       to_nativeint,
       nativeint_to_int_trunc,
       nativeint_to_int32_trunc,
       int64_to_nativeint_trunc,
       _e4_];
    caml_register_global(1115,Base_Nativeint,"Base__Nativeint");
    var
     compare$57=include$60[1],
     all$19=include$60[2],
     equal$42=include$60[3],
     sexp_of_t$54=include$60[4];
    function of_continue_or_stop(_sy_){return _sy_}
    function to_continue_or_stop(_sx_){return _sx_}
    var
     Finished_or_unfinished=
      [0,
       compare$57,
       all$19,
       equal$42,
       sexp_of_t$54,
       of_continue_or_stop,
       to_continue_or_stop],
     compare$58=include$59[1],
     equal$43=include$59[2],
     sexp_of_t$55=include$59[3];
    function left(param)
     {var _sw_=param[1];
      if(737457313 === _sw_)
       var left=param[2][1];
      else
       {if(847852583 > _sw_)return 0;var left=param[2]}
      return [0,left]}
    function right(param)
     {var _sv_=param[1];
      if(737457313 === _sv_)
       var right=param[2][2];
      else
       {if(847852583 <= _sv_)return 0;var right=param[2]}
      return [0,right]}
    function left_value(t,default$0)
     {var _su_=t[1];
      if(737457313 === _su_)
       var left=t[2][1];
      else
       {if(847852583 > _su_)return default$0;var left=t[2]}
      return left}
    function right_value(t,default$0)
     {var _st_=t[1];
      if(737457313 === _st_)
       var right=t[2][2];
      else
       {if(847852583 <= _st_)return default$0;var right=t[2]}
      return right}
    function values(t,left_default,right_default)
     {var _ss_=t[1];
      if(737457313 === _ss_)
       {var match=t[2],right=match[2],left=match[1];return [0,left,right]}
      if(847852583 <= _ss_){var left$0=t[2];return [0,left$0,right_default]}
      var right$0=t[2];
      return [0,left_default,right$0]}
    var
     Merge_element=
      [0,
       compare$58,
       equal$43,
       sexp_of_t$55,
       left,
       right,
       left_value,
       right_value,
       values],
     Duplicate=[248,cst_Base_Map_Duplicate,caml_fresh_oo_id(0)];
    function _e7_(param)
     {if(param === Duplicate)return _e8_;throw [0,Assert_failure$0,_e9_]}
    caml_call4(Sexplib0_Sexp_conv[70][1],0,0,Duplicate,_e7_);
    function height$0(param)
     {if(typeof param === "number")return 0;
      if(0 === param[0])return 1;
      var h=param[5];
      return h}
    function in_range$0(lower,upper,compare_key,k)
     {if(lower)
       var lower$0=lower[1],_sq_=caml_call2(compare_key,lower$0,k) < 0?1:0;
      else
       var _sq_=1;
      if(_sq_)
       {if(upper)
         {var upper$0=upper[1];
          return caml_call2(compare_key,k,upper$0) < 0?1:0}
        var _sr_=1}
      else
       var _sr_=_sq_;
      return _sr_}
    function loop$0(lower,upper,compare_key,t)
     {var lower$0=lower,t$0=t;
      for(;;)
       {if(typeof t$0 === "number")return 1;
        if(0 === t$0[0])
         {var k=t$0[1];return in_range$0(lower$0,upper,compare_key,k)}
        var
         h=t$0[5],
         r=t$0[4],
         k$0=t$0[2],
         l=t$0[1],
         hl=height$0(l),
         hr=height$0(r),
         _sl_=caml_call1(abs$0,hl - hr | 0) <= 2?1:0;
        if(_sl_)
         {var _sm_=h === (caml_call2(max$2,hl,hr) + 1 | 0)?1:0;
          if(_sm_)
           {var _sn_=in_range$0(lower$0,upper,compare_key,k$0);
            if(_sn_)
             {var _so_=loop$0(lower$0,[0,k$0],compare_key,l);
              if(_so_){var lower$1=[0,k$0],lower$0=lower$1,t$0=r;continue}
              var _sp_=_so_}
            else
             var _sp_=_sn_}
          else
           var _sp_=_sm_}
        else
         var _sp_=_sl_;
        return _sp_}}
    function invariants$2(t,compare_key){return loop$0(0,0,compare_key,t)}
    function create$14(l,x,d,r)
     {var hl=height$0(l),hr=height$0(r);
      if(0 === hl && 0 === hr)return [0,x,d];
      var _sk_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
      return [1,l,x,d,r,_sk_]}
    function of_increasing_iterator_uncheck$4(len,f)
     {function loop(n,f,i)
       {if(3 >= n >>> 0)
         switch(n)
          {case 0:return 0;
           case 1:
            var match$0=caml_call1(f,i),v$0=match$0[2],k$0=match$0[1];
            return [0,k$0,v$0];
           case 2:
            var
             match$1=caml_call1(f,i),
             vl=match$1[2],
             kl=match$1[1],
             match$2=caml_call1(f,i + 1 | 0),
             v$1=match$2[2],
             k$1=match$2[1];
            return [1,[0,kl,vl],k$1,v$1,0,2];
           default:
            var
             match$3=caml_call1(f,i),
             vl$0=match$3[2],
             kl$0=match$3[1],
             match$4=caml_call1(f,i + 1 | 0),
             v$2=match$4[2],
             k$2=match$4[1],
             match$5=caml_call1(f,i + 2 | 0),
             vr=match$5[2],
             kr=match$5[1];
            return [1,[0,kl$0,vl$0],k$2,v$2,[0,kr,vr],2]}
        var
         left_length=n >>> 1 | 0,
         right_length=(n - left_length | 0) - 1 | 0,
         left=loop(left_length,f,i),
         match=caml_call1(f,i + left_length | 0),
         v=match[2],
         k=match[1],
         right=loop(right_length,f,(i + left_length | 0) + 1 | 0);
        return create$14(left,k,v,right)}
      return loop(len,f,0)}
    function of_sorted_array_unchecked$4(array,compare_key)
     {var array_length=array.length - 1,switch$0=0;
      if(2 <= array_length)
       {var
         match=caml_check_bound(array,0)[1],
         k0=match[1],
         match$0=caml_check_bound(array,1)[2],
         k1=match$0[1];
        if(caml_call2(compare_key,k0,k1) >= 0)
         {var
           next=
            function(i)
             {var _sj_=(array_length - 1 | 0) - i | 0;
              return caml_check_bound(array,_sj_)[1 + _sj_]};
          switch$0 = 1}}
      if(! switch$0)
       var next=function(i){return caml_check_bound(array,i)[1 + i]};
      return [0,
              of_increasing_iterator_uncheck$4(array_length,next),
              array_length]}
    function of_sorted_array$4(array,compare_key)
     {var len=array.length - 1;
      if(1 !== len && len)
       return with_return
               (function(r)
                 {var
                   _sd_=caml_check_bound(array,1)[2][1],
                   i=
                    caml_call2(compare_key,caml_check_bound(array,0)[1][1],_sd_),
                   increasing=
                    0 === i
                     ?caml_call1
                       (r,error_string(cst_of_sorted_array_duplicated$1))
                     :i < 0?1:0,
                   _sf_=array.length - 1 - 2 | 0,
                   _se_=1;
                  if(_sf_ >= 1)
                   {var i$0=_se_;
                    for(;;)
                     {var
                       _sg_=i$0 + 1 | 0,
                       _sh_=caml_check_bound(array,_sg_)[1 + _sg_][1],
                       i$1=
                        caml_call2
                         (compare_key,caml_check_bound(array,i$0)[1 + i$0][1],_sh_);
                      if(0 === i$1)
                       caml_call1(r,error_string(cst_of_sorted_array_duplicated$2));
                      else
                       if((i$1 < 0?1:0) !== increasing)
                        caml_call1(r,error_string(cst_of_sorted_array_elements_a$0));
                      var _si_=i$0 + 1 | 0;
                      if(_sf_ !== i$0){var i$0=_si_;continue}
                      break}}
                  return [0,of_sorted_array_unchecked$4(array,compare_key)]});
      return [0,of_sorted_array_unchecked$4(array,compare_key)]}
    function bal$0(l,x,d,r)
     {var hl=height$0(l),hr=height$0(r);
      if((hr + 2 | 0) < hl)
       {if(typeof l === "number")return caml_call1(invalid_arg$0,cst_Map_bal);
        if(0 === l[0])throw [0,Assert_failure$0,_e__];
        var lr=l[4],ld=l[3],lv=l[2],ll=l[1],_r9_=height$0(lr);
        if(_r9_ <= height$0(ll))
         return create$14(ll,lv,ld,create$14(lr,x,d,r));
        if(typeof lr === "number")
         return caml_call1(invalid_arg$0,cst_Map_bal$0);
        if(0 === lr[0])
         {var lrd=lr[2],lrv=lr[1],_r__=create$14(0,x,d,r);
          return create$14(create$14(ll,lv,ld,0),lrv,lrd,_r__)}
        var
         lrr=lr[4],
         lrd$0=lr[3],
         lrv$0=lr[2],
         lrl=lr[1],
         _r$_=create$14(lrr,x,d,r);
        return create$14(create$14(ll,lv,ld,lrl),lrv$0,lrd$0,_r$_)}
      if((hl + 2 | 0) >= hr)return create$14(l,x,d,r);
      if(typeof r === "number")return caml_call1(invalid_arg$0,cst_Map_bal$1);
      if(0 === r[0])throw [0,Assert_failure$0,_e$_];
      var rr=r[4],rd=r[3],rv=r[2],rl=r[1],_sa_=height$0(rl);
      if(_sa_ <= height$0(rr))return create$14(create$14(l,x,d,rl),rv,rd,rr);
      if(typeof rl === "number")
       return caml_call1(invalid_arg$0,cst_Map_bal$2);
      if(0 === rl[0])
       {var rld=rl[2],rlv=rl[1],_sb_=create$14(0,rv,rd,rr);
        return create$14(create$14(l,x,d,0),rlv,rld,_sb_)}
      var
       rlr=rl[4],
       rld$0=rl[3],
       rlv$0=rl[2],
       rll=rl[1],
       _sc_=create$14(rlr,rv,rd,rr);
      return create$14(create$14(l,x,d,rll),rlv$0,rld$0,_sc_)}
    var empty_without_value_restrictio=0;
    function is_empty$10(param){return typeof param === "number"?1:0}
    function raise_key_already_present(key,sexp_of_key)
     {return raise_s
              (caml_call2
                (message,
                 cst_Map_add_exn_got_key_alread,
                 [0,[0,cst_key,caml_call1(sexp_of_key,key)],0]))}
    function find_and_add_or_set
     (t,length,x,data,compare_key,sexp_of_key,add_or_set)
     {if(typeof t === "number")return [0,[0,x,data],length + 1 | 0];
      if(0 === t[0])
       {var d=t[2],v=t[1],c=caml_call2(compare_key,x,v);
        if(0 === c)
         switch(add_or_set)
          {case 0:return raise_without_backtrace(Duplicate);
           case 1:return raise_key_already_present(x,sexp_of_key);
           default:return [0,[0,x,data],length]}
        return 0 <= c
                ?[0,[1,0,v,d,[0,x,data],2],length + 1 | 0]
                :[0,[1,[0,x,data],v,d,0,2],length + 1 | 0]}
      var
       h=t[5],
       r=t[4],
       d$0=t[3],
       v$0=t[2],
       l=t[1],
       c$0=caml_call2(compare_key,x,v$0);
      if(0 === c$0)
       switch(add_or_set)
        {case 0:return raise_without_backtrace(Duplicate);
         case 1:return raise_key_already_present(x,sexp_of_key);
         default:return [0,[1,l,x,data,r,h],length]}
      if(0 <= c$0)
       {var
         match=
          find_and_add_or_set
           (r,length,x,data,compare_key,sexp_of_key,add_or_set),
         length$0=match[2],
         r$0=match[1];
        return [0,bal$0(l,v$0,d$0,r$0),length$0]}
      var
       match$0=
        find_and_add_or_set
         (l,length,x,data,compare_key,sexp_of_key,add_or_set),
       length$1=match$0[2],
       l$0=match$0[1];
      return [0,bal$0(l$0,v$0,d$0,r),length$1]}
    function add_exn(t,length,key,data,compare_key,sexp_of_key)
     {return find_and_add_or_set(t,length,key,data,compare_key,sexp_of_key,1)}
    function add_exn_internal(t,length,key,data,compare_key,sexp_of_key)
     {return find_and_add_or_set(t,length,key,data,compare_key,sexp_of_key,0)}
    function set$5(t,length,key,data,compare_key)
     {var _r8_=2;
      return find_and_add_or_set
              (t,
               length,
               key,
               data,
               compare_key,
               function(param){return _fa_},
               _r8_)}
    function set$6(t,key,data,compare_key)
     {return set$5(t,0,key,data,compare_key)[1]}
    function singleton_to_tree_exn(param)
     {if(typeof param[1] !== "number")
       return caml_call1(failwith$0,cst_Map_singleton_to_tree_exn_);
      var data=param[3],key=param[2];
      return [0,key,data]}
    function collapse(l,r){return create$14(l[1],l[2],l[3],r)}
    function join$7(l,r)
     {var _r6_=r[3],_r7_=r[2];return [0,collapse(l,r[1]),_r7_,_r6_]}
    function go(t,x)
     {switch(t[0])
       {case 0:return [1,t,x];
        case 1:var y=t[2],t$0=t[1];return [2,t$0,y,x];
        default:
         var y$0=t[3],z=t[2],t$1=t[1];return [1,go(t$1,join$7(z,y$0)),x]}}
    function add_unchecked(t,key,data){return go(t,[0,0,key,data])}
    function go$0(t,r)
     {var t$0=t,r$0=r;
      for(;;)
       switch(t$0[0])
        {case 0:return r$0;
         case 1:
          var l=t$0[2],t$1=t$0[1],r$1=collapse(l,r$0),t$0=t$1,r$0=r$1;
          continue;
         default:
          var
           l$0=t$0[3],
           ll=t$0[2],
           t$2=t$0[1],
           r$2=collapse(join$7(ll,l$0),r$0),
           t$0=t$2,
           r$0=r$2;
          continue}}
    function to_tree_unchecked(param)
     {switch(param[0])
       {case 0:return 0;
        case 1:
         var r=param[2],t=param[1];return go$0(t,singleton_to_tree_exn(r));
        default:
         var r$0=param[3],l=param[2],t$0=param[1];
         return go$0([1,t$0,l],singleton_to_tree_exn(r$0))}}
    function max_key(param)
     {switch(param[0])
       {case 0:return 0;case 1:var r=param[2];break;default:var r=param[3]}
      return [0,r[2]]}
    function of_increasing_sequence(seq,compare_key)
     {return with_return
              (function(param)
                {var
                  match=
                   fold$1
                    (seq,
                     [0,empty$5,0],
                     function(param$0,_r5_)
                      {var
                        data=_r5_[2],
                        key=_r5_[1],
                        length=param$0[2],
                        builder=param$0[1],
                        match=max_key(builder);
                       if(match)
                        {var prev_key=match[1];
                         if(0 <= caml_call2(compare_key,prev_key,key))
                          return caml_call1
                                  (param,error_string(cst_of_increasing_sequence_non))}
                       return [0,add_unchecked(builder,key,data),length + 1 | 0]}),
                  length=match[2],
                  builder=match[1];
                 return [0,[0,to_tree_unchecked(builder),length]]})}
    function join$8(l,k,d,r,compare_key)
     {if(typeof l === "number")return set$6(r,k,d,compare_key);
      if(1 === l[0])
       {var _r0_=l[5],_r1_=l[4],_r2_=l[3],_r3_=l[2],_r4_=l[1];
        if(typeof r !== "number")
         {if(0 === r[0])
           {var rd=r[2],rk=r[1];
            return set$6(set$6(l,k,d,compare_key),rk,rd,compare_key)}
          var rh=r[5],rr=r[4],rd$0=r[3],rk$0=r[2],rl=r[1];
          return (rh + 3 | 0) < _r0_
                  ?bal$0(_r4_,_r3_,_r2_,join$8(_r1_,k,d,r,compare_key))
                  :(_r0_ + 3 | 0) < rh
                    ?bal$0(join$8(l,k,d,rl,compare_key),rk$0,rd$0,rr)
                    :bal$0(l,k,d,r)}}
      if(typeof r === "number")return set$6(l,k,d,compare_key);
      var ld=l[2],lk=l[1];
      return set$6(set$6(r,k,d,compare_key),lk,ld,compare_key)}
    function split$4(t,x,compare_key)
     {if(typeof t === "number")return _fb_;
      if(0 === t[0])
       {var d=t[2],k=t[1],cmp=caml_call2(compare_key,x,k);
        return 0 === cmp?[0,0,[0,[0,k,d]],0]:0 <= cmp?[0,t,0,0]:[0,0,0,t]}
      var r=t[4],d$0=t[3],k$0=t[2],l=t[1],cmp$0=caml_call2(compare_key,x,k$0);
      if(0 === cmp$0)return [0,l,[0,[0,k$0,d$0]],r];
      if(0 <= cmp$0)
       {var
         match=split$4(r,x,compare_key),
         rr=match[3],
         maybe=match[2],
         rl=match[1];
        return [0,join$8(l,k$0,d$0,rl,compare_key),maybe,rr]}
      var
       match$0=split$4(l,x,compare_key),
       lr=match$0[3],
       maybe$0=match$0[2],
       ll=match$0[1];
      return [0,ll,maybe$0,join$8(lr,k$0,d$0,r,compare_key)]}
    function split_and_reinsert_boundary(t,into,x,compare_key)
     {var
       match=split$4(t,x,compare_key),
       right=match[3],
       boundary_opt=match[2],
       left=match[1];
      if(! boundary_opt)return [0,left,right];
      var match$0=boundary_opt[1],data=match$0[2],key=match$0[1];
      function insert_into(tree){return set$5(tree,0,key,data,compare_key)[1]}
      return 847852583 <= into
              ?[0,insert_into(left),right]
              :[0,left,insert_into(right)]}
    function split_range(t,lower_bound,upper_bound,compare_key)
     {if(bounds_crossed(lower_bound,upper_bound,compare_key))
       return [0,
               empty_without_value_restrictio,
               empty_without_value_restrictio,
               empty_without_value_restrictio];
      if(typeof lower_bound === "number")
       var mid_and_right=t,left=empty_without_value_restrictio;
      else
       if(0 === lower_bound[0])
        var
         lb$1=lower_bound[1],
         _rY_=split_and_reinsert_boundary(t,-57574468,lb$1,compare_key),
         mid_and_right=_rY_[2],
         left=_rY_[1];
       else
        var
         lb$2=lower_bound[1],
         _rZ_=split_and_reinsert_boundary(t,847852583,lb$2,compare_key),
         mid_and_right$0=_rZ_[2],
         left$0=_rZ_[1],
         mid_and_right=mid_and_right$0,
         left=left$0;
      if(typeof upper_bound === "number")
       var right=empty_without_value_restrictio,mid=mid_and_right;
      else
       if(0 === upper_bound[0])
        var
         lb=upper_bound[1],
         _rW_=
          split_and_reinsert_boundary(mid_and_right,847852583,lb,compare_key),
         right=_rW_[2],
         mid=_rW_[1];
       else
        var
         lb$0=upper_bound[1],
         _rX_=
          split_and_reinsert_boundary
           (mid_and_right,-57574468,lb$0,compare_key),
         right$0=_rX_[2],
         mid$0=_rX_[1],
         right=right$0,
         mid=mid$0;
      return [0,left,mid,right]}
    function find$11(t,x,compare_key)
     {var t$0=t;
      for(;;)
       {if(typeof t$0 === "number")return 0;
        if(0 === t$0[0])
         {var d=t$0[2],v=t$0[1];
          return 0 === caml_call2(compare_key,x,v)?[0,d]:0}
        var
         r=t$0[4],
         d$0=t$0[3],
         v$0=t$0[2],
         l=t$0[1],
         c=caml_call2(compare_key,x,v$0);
        if(0 === c)return [0,d$0];
        var t$1=0 <= c?r:l,t$0=t$1}}
    function add_multi(t,length,key,data,compare_key)
     {var data$0=[0,data,value(find$11(t,key,compare_key),0)];
      return set$5(t,length,key,data$0,compare_key)}
    function find_multi(t,x,compare_key)
     {var match=find$11(t,x,compare_key);
      if(! match)return 0;
      var l=match[1];
      return l}
    function if_not_found(key,sexp_of_key)
     {throw [0,Not_found_s,[1,[0,_fc_,[0,caml_call1(sexp_of_key,key),0]]]]}
    function find_exn$6(t,x,compare_key,sexp_of_key)
     {var t$0=t;
      for(;;)
       {if(typeof t$0 === "number")return if_not_found(x,sexp_of_key);
        if(0 === t$0[0])
         {var d=t$0[2],v=t$0[1];
          return 0 === caml_call2(compare_key,x,v)
                  ?d
                  :if_not_found(x,sexp_of_key)}
        var
         r=t$0[4],
         d$0=t$0[3],
         v$0=t$0[2],
         l=t$0[1],
         c=caml_call2(compare_key,x,v$0);
        if(0 === c)return d$0;
        var t$1=0 <= c?r:l,t$0=t$1}}
    function mem$9(t,x,compare_key){return is_some(find$11(t,x,compare_key))}
    function min_elt$11(param)
     {var param$0=param;
      for(;;)
       {if(typeof param$0 === "number")return 0;
        if(0 === param$0[0]){var d=param$0[2],k=param$0[1];return [0,[0,k,d]]}
        var _rV_=param$0[1];
        if(typeof _rV_ === "number")
         {var d$0=param$0[3],k$0=param$0[2];return [0,[0,k$0,d$0]]}
        var param$0=_rV_}}
    var
     Map_min_elt_exn_of_empty_map=
      [248,cst_Base_Map_Tree0_Map_min_elt,caml_fresh_oo_id(0)];
    function _fd_(param)
     {if(param === Map_min_elt_exn_of_empty_map)return _fe_;
      throw [0,Assert_failure$0,_ff_]}
    caml_call4
     (Sexplib0_Sexp_conv[70][1],0,0,Map_min_elt_exn_of_empty_map,_fd_);
    var
     Map_max_elt_exn_of_empty_map=
      [248,cst_Base_Map_Tree0_Map_max_elt,caml_fresh_oo_id(0)];
    function _fg_(param)
     {if(param === Map_max_elt_exn_of_empty_map)return _fh_;
      throw [0,Assert_failure$0,_fi_]}
    caml_call4
     (Sexplib0_Sexp_conv[70][1],0,0,Map_max_elt_exn_of_empty_map,_fg_);
    function min_elt_exn$2(t)
     {var match=min_elt$11(t);
      if(! match)throw Map_min_elt_exn_of_empty_map;
      var v=match[1];
      return v}
    function max_elt$11(param)
     {var param$0=param;
      for(;;)
       {if(typeof param$0 === "number")return 0;
        if(0 === param$0[0]){var d=param$0[2],k=param$0[1];return [0,[0,k,d]]}
        if(typeof param$0[4] === "number")
         {var d$0=param$0[3],k$0=param$0[2];return [0,[0,k$0,d$0]]}
        var param$1=param$0[4],param$0=param$1}}
    function max_elt_exn$2(t)
     {var match=max_elt$11(t);
      if(! match)throw Map_max_elt_exn_of_empty_map;
      var v=match[1];
      return v}
    function remove_min_elt$0(t)
     {if(typeof t === "number")
       return caml_call1(invalid_arg$0,cst_Map_remove_min_elt);
      if(0 === t[0])return 0;
      var _rU_=t[1];
      if(typeof _rU_ === "number"){var r=t[4];return r}
      var r$0=t[4],d=t[3],x=t[2];
      return bal$0(remove_min_elt$0(_rU_),x,d,r$0)}
    function append$2(lower_part,upper_part,compare_key)
     {var match=max_elt$11(lower_part),match$0=min_elt$11(upper_part);
      if(! match)return [0,17724,upper_part];
      if(! match$0)return [0,17724,lower_part];
      var
       _rT_=match$0[1],
       v=_rT_[2],
       min_upper=_rT_[1],
       match$1=match[1],
       max_lower=match$1[1];
      if(0 <= caml_call2(compare_key,max_lower,min_upper))return 838882908;
      var upper_part_without_min=remove_min_elt$0(upper_part);
      return [0,
              17724,
              join$8
               (lower_part,min_upper,v,upper_part_without_min,compare_key)]}
    function go$1(t,min,max,init,f,compare_key)
     {var t$0=t,init$0=init;
      for(;;)
       {if(typeof t$0 === "number")return init$0;
        if(0 === t$0[0])
         {var d=t$0[2],k=t$0[1];
          if
           (0
            <=
            caml_call2(compare_key,k,min)
            &&
            0
            >=
            caml_call2(compare_key,k,max))
           return caml_call3(f,k,d,init$0);
          return init$0}
        var
         r=t$0[4],
         d$0=t$0[3],
         k$0=t$0[2],
         l=t$0[1],
         c_min=caml_call2(compare_key,k$0,min);
        if(0 > c_min){var t$0=r;continue}
        if(0 === c_min)
         {var init$1=caml_call3(f,k$0,d$0,init$0),t$0=r,init$0=init$1;
          continue}
        var
         z=go$1(l,min,max,init$0,f,compare_key),
         c_max=caml_call2(compare_key,k$0,max);
        if(0 < c_max)return z;
        var init$2=caml_call3(f,k$0,d$0,z);
        if(0 === c_max)return init$2;
        var t$0=r,init$0=init$2}}
    function fold_range_inclusive(t,min,max,init,f,compare_key)
     {return 0 < caml_call2(compare_key,min,max)
              ?init
              :go$1(t,min,max,init,f,compare_key)}
    function range_to_alist(t,min,max,compare_key)
     {return rev
              (fold_range_inclusive
                (t,
                 min,
                 max,
                 0,
                 function(key,data,l){return [0,[0,key,data],l]},
                 compare_key))}
    function concat_unchecked(t1,t2)
     {if(typeof t1 === "number")return t2;
      if(typeof t2 === "number")return t1;
      var match=min_elt_exn$2(t2),d=match[2],x=match[1];
      return bal$0(t1,x,d,remove_min_elt$0(t2))}
    var Remove_no_op=[248,cst_Base_Map_Tree0_Remove_no_o,caml_fresh_oo_id(0)];
    function remove$3(t,x,length,compare_key)
     {function remove_loop(t,x,length,compare_key)
       {if(typeof t === "number")return raise_without_backtrace(Remove_no_op);
        if(0 === t[0])
         {var v=t[1];
          return 0 === caml_call2(compare_key,x,v)
                  ?[0,0,length - 1 | 0]
                  :raise_without_backtrace(Remove_no_op)}
        var r=t[4],d=t[3],v$0=t[2],l=t[1],c=caml_call2(compare_key,x,v$0);
        if(0 === c)return [0,concat_unchecked(l,r),length - 1 | 0];
        if(0 <= c)
         {var
           match=remove_loop(r,x,length,compare_key),
           length$0=match[2],
           r$0=match[1];
          return [0,bal$0(l,v$0,d,r$0),length$0]}
        var
         match$0=remove_loop(l,x,length,compare_key),
         length$1=match$0[2],
         l$0=match$0[1];
        return [0,bal$0(l$0,v$0,d,r),length$1]}
      try
       {var _rR_=remove_loop(t,x,length,compare_key);return _rR_}
      catch(_rS_)
       {_rS_ = caml_wrap_exception(_rS_);
        if(_rS_ === Remove_no_op)return [0,t,length];
        throw _rS_}}
    var Change_no_op=[248,cst_Base_Map_Tree0_Change_no_o,caml_fresh_oo_id(0)];
    function change(t,key,f,length,compare_key)
     {function change_core(t,key,f)
       {if(typeof t === "number")
         {var match=caml_call1(f,0);
          if(! match)throw Change_no_op;
          var data=match[1];
          return [0,[0,key,data],length + 1 | 0]}
        if(0 === t[0])
         {var d=t[2],v=t[1],c=caml_call2(compare_key,key,v);
          if(0 === c)
           {var match$0=caml_call1(f,[0,d]);
            if(! match$0)return [0,0,length - 1 | 0];
            var d$0=match$0[1];
            return [0,[0,v,d$0],length]}
          if(0 <= c)
           {var match$1=change_core(0,key,f),length$0=match$1[2],r=match$1[1];
            return [0,bal$0(0,v,d,r),length$0]}
          var match$2=change_core(0,key,f),length$1=match$2[2],l=match$2[1];
          return [0,bal$0(l,v,d,0),length$1]}
        var
         h=t[5],
         r$0=t[4],
         d$1=t[3],
         v$0=t[2],
         l$0=t[1],
         c$0=caml_call2(compare_key,key,v$0);
        if(0 === c$0)
         {var match$3=caml_call1(f,[0,d$1]);
          if(! match$3)return [0,concat_unchecked(l$0,r$0),length - 1 | 0];
          var data$0=match$3[1];
          return [0,[1,l$0,key,data$0,r$0,h],length]}
        if(0 <= c$0)
         {var
           match$4=change_core(r$0,key,f),
           length$2=match$4[2],
           r$1=match$4[1];
          return [0,bal$0(l$0,v$0,d$1,r$1),length$2]}
        var match$5=change_core(l$0,key,f),length$3=match$5[2],l$1=match$5[1];
        return [0,bal$0(l$1,v$0,d$1,r$0),length$3]}
      try
       {var _rP_=change_core(t,key,f);return _rP_}
      catch(_rQ_)
       {_rQ_ = caml_wrap_exception(_rQ_);
        if(_rQ_ === Change_no_op)return [0,t,length];
        throw _rQ_}}
    function update(t,key,f,length,compare_key)
     {function update_core(t,key,f)
       {if(typeof t === "number")
         {var data=caml_call1(f,0);return [0,[0,key,data],length + 1 | 0]}
        if(0 === t[0])
         {var d=t[2],v=t[1],c=caml_call2(compare_key,key,v);
          if(0 === c){var d$0=caml_call1(f,[0,d]);return [0,[0,v,d$0],length]}
          if(0 <= c)
           {var match=update_core(0,key,f),length$0=match[2],r=match[1];
            return [0,bal$0(0,v,d,r),length$0]}
          var match$0=update_core(0,key,f),length$1=match$0[2],l=match$0[1];
          return [0,bal$0(l,v,d,0),length$1]}
        var
         h=t[5],
         r$0=t[4],
         d$1=t[3],
         v$0=t[2],
         l$0=t[1],
         c$0=caml_call2(compare_key,key,v$0);
        if(0 === c$0)
         {var data$0=caml_call1(f,[0,d$1]);
          return [0,[1,l$0,key,data$0,r$0,h],length]}
        if(0 <= c$0)
         {var
           match$1=update_core(r$0,key,f),
           length$2=match$1[2],
           r$1=match$1[1];
          return [0,bal$0(l$0,v$0,d$1,r$1),length$2]}
        var match$2=update_core(l$0,key,f),length$3=match$2[2],l$1=match$2[1];
        return [0,bal$0(l$1,v$0,d$1,r$0),length$3]}
      return update_core(t,key,f)}
    function remove_multi(t,key,length,compare_key)
     {return change
              (t,
               key,
               function(param)
                {if(param)
                  {var _rN_=param[1];
                   if(_rN_){var _rO_=_rN_[2];if(_rO_)return [0,_rO_]}}
                 return 0},
               length,
               compare_key)}
    function iter_keys(t,f)
     {var t$0=t;
      for(;;)
       {if(typeof t$0 === "number")return 0;
        if(0 === t$0[0]){var v=t$0[1];return caml_call1(f,v)}
        var r=t$0[4],v$0=t$0[2],l=t$0[1];
        iter_keys(l,f);
        caml_call1(f,v$0);
        var t$0=r}}
    function iter$17(t,f)
     {var t$0=t;
      for(;;)
       {if(typeof t$0 === "number")return 0;
        if(0 === t$0[0]){var d=t$0[2];return caml_call1(f,d)}
        var r=t$0[4],d$0=t$0[3],l=t$0[1];
        iter$17(l,f);
        caml_call1(f,d$0);
        var t$0=r}}
    function iteri$9(t,f)
     {var t$0=t;
      for(;;)
       {if(typeof t$0 === "number")return 0;
        if(0 === t$0[0]){var d=t$0[2],v=t$0[1];return caml_call2(f,v,d)}
        var r=t$0[4],d$0=t$0[3],v$0=t$0[2],l=t$0[1];
        iteri$9(l,f);
        caml_call2(f,v$0,d$0);
        var t$0=r}}
    function iteri_until_loop(t,f)
     {var t$0=t;
      for(;;)
       {if(typeof t$0 === "number")return 0;
        if(0 === t$0[0]){var d=t$0[2],v=t$0[1];return caml_call2(f,v,d)}
        var
         r=t$0[4],
         d$0=t$0[3],
         v$0=t$0[2],
         l=t$0[1],
         match=iteri_until_loop(l,f);
        if(match)return 1;
        var match$0=caml_call2(f,v$0,d$0);
        if(match$0)return 1;
        var t$0=r}}
    function iteri_until(t,f)
     {var _rM_=iteri_until_loop(t,f);
      return caml_call1(Finished_or_unfinished[5],_rM_)}
    function map$33(t,f)
     {if(typeof t === "number")return 0;
      if(0 === t[0]){var d=t[2],v=t[1];return [0,v,caml_call1(f,d)]}
      var
       h=t[5],
       r=t[4],
       d$0=t[3],
       v$0=t[2],
       l=t[1],
       l$0=map$33(l,f),
       d$1=caml_call1(f,d$0),
       r$0=map$33(r,f);
      return [1,l$0,v$0,d$1,r$0,h]}
    function mapi$7(t,f)
     {if(typeof t === "number")return 0;
      if(0 === t[0]){var d=t[2],v=t[1];return [0,v,caml_call2(f,v,d)]}
      var
       h=t[5],
       r=t[4],
       d$0=t[3],
       v$0=t[2],
       l=t[1],
       l$0=mapi$7(l,f),
       d$1=caml_call2(f,v$0,d$0),
       r$0=mapi$7(r,f);
      return [1,l$0,v$0,d$1,r$0,h]}
    function fold$12(t,accu,f)
     {var t$0=t,accu$0=accu;
      for(;;)
       {if(typeof t$0 === "number")return accu$0;
        if(0 === t$0[0])
         {var d=t$0[2],v=t$0[1];return caml_call3(f,v,d,accu$0)}
        var
         r=t$0[4],
         d$0=t$0[3],
         v$0=t$0[2],
         l=t$0[1],
         accu$1=caml_call3(f,v$0,d$0,fold$12(l,accu$0,f)),
         t$0=r,
         accu$0=accu$1}}
    function fold_until$10(t,init,f,finish)
     {function fold_until_loop(t,acc,f)
       {var t$0=t,acc$0=acc;
        for(;;)
         {if(typeof t$0 === "number")return [0,acc$0];
          if(0 === t$0[0])
           {var d=t$0[2],v=t$0[1];return caml_call3(f,v,d,acc$0)}
          var
           r=t$0[4],
           d$0=t$0[3],
           v$0=t$0[2],
           l=t$0[1],
           match=fold_until_loop(l,acc$0,f);
          if(0 !== match[0]){var final$1=match[1];return [1,final$1]}
          var acc$1=match[1],match$0=caml_call3(f,v$0,d$0,acc$1);
          if(0 === match$0[0])
           {var acc$2=match$0[1],t$0=r,acc$0=acc$2;continue}
          var final$0=match$0[1];
          return [1,final$0]}}
      var match=fold_until_loop(t,init,f);
      if(0 === match[0]){var acc=match[1];return caml_call1(finish,acc)}
      var stop=match[1];
      return stop}
    function fold_right$4(t,accu,f)
     {var t$0=t,accu$0=accu;
      for(;;)
       {if(typeof t$0 === "number")return accu$0;
        if(0 === t$0[0])
         {var d=t$0[2],v=t$0[1];return caml_call3(f,v,d,accu$0)}
        var
         r=t$0[4],
         d$0=t$0[3],
         v$0=t$0[2],
         l=t$0[1],
         accu$1=caml_call3(f,v$0,d$0,fold_right$4(r,accu$0,f)),
         t$0=l,
         accu$0=accu$1}}
    function filter_keys(t,f,compare_key)
     {return fold$12
              (t,
               _fj_,
               function(key,data,param)
                {var length=param[2],accu=param[1];
                 return caml_call1(f,key)
                         ?set$5(accu,length,key,data,compare_key)
                         :[0,accu,length]})}
    function filter$8(t,f,compare_key)
     {return fold$12
              (t,
               _fk_,
               function(key,data,param)
                {var length=param[2],accu=param[1];
                 return caml_call1(f,data)
                         ?set$5(accu,length,key,data,compare_key)
                         :[0,accu,length]})}
    function filteri$4(t,f,compare_key)
     {return fold$12
              (t,
               _fl_,
               function(key,data,param)
                {var length=param[2],accu=param[1];
                 return caml_call2(f,key,data)
                         ?set$5(accu,length,key,data,compare_key)
                         :[0,accu,length]})}
    function filter_map$8(t,f,compare_key)
     {return fold$12
              (t,
               _fm_,
               function(key,data,param)
                {var length=param[2],accu=param[1],match=caml_call1(f,data);
                 if(! match)return [0,accu,length];
                 var b=match[1];
                 return set$5(accu,length,key,b,compare_key)})}
    function filter_mapi$3(t,f,compare_key)
     {return fold$12
              (t,
               _fn_,
               function(key,data,param)
                {var
                  length=param[2],
                  accu=param[1],
                  match=caml_call2(f,key,data);
                 if(! match)return [0,accu,length];
                 var b=match[1];
                 return set$5(accu,length,key,b,compare_key)})}
    function partition_mapi(t,f,compare_key)
     {return fold$12
              (t,
               _fo_,
               function(key,data,param)
                {var
                  pair2=param[2],
                  pair1=param[1],
                  match=caml_call2(f,key,data);
                 if(0 === match[0])
                  {var x=match[1],length=pair1[2],t=pair1[1];
                   return [0,set$5(t,length,key,x,compare_key),pair2]}
                 var y=match[1],length$0=pair2[2],t$0=pair2[1];
                 return [0,pair1,set$5(t$0,length$0,key,y,compare_key)]})}
    function partition_map$0(t,f,compare_key)
     {return partition_mapi
              (t,function(param,data){return caml_call1(f,data)},compare_key)}
    function partitioni_tf$0(t,f,compare_key)
     {return partition_mapi
              (t,
               function(key,data)
                {return caml_call2(f,key,data)?[0,data]:[1,data]},
               compare_key)}
    function partition_tf$4(t,f,compare_key)
     {return partition_mapi
              (t,
               function(param,data)
                {return caml_call1(f,data)?[0,data]:[1,data]},
               compare_key)}
    function cons$1(t,e)
     {var t$0=t,e$0=e;
      for(;;)
       {if(typeof t$0 === "number")return e$0;
        if(0 === t$0[0]){var d=t$0[2],v=t$0[1];return [0,v,d,0,e$0]}
        var
         r=t$0[4],
         d$0=t$0[3],
         v$0=t$0[2],
         t$1=t$0[1],
         e$1=[0,v$0,d$0,r,e$0],
         t$0=t$1,
         e$0=e$1}}
    function cons_right$0(t,e)
     {var t$0=t,e$0=e;
      for(;;)
       {if(typeof t$0 === "number")return e$0;
        if(0 === t$0[0]){var d=t$0[2],v=t$0[1];return [0,v,d,0,e$0]}
        var
         t$1=t$0[4],
         d$0=t$0[3],
         v$0=t$0[2],
         l=t$0[1],
         e$1=[0,v$0,d$0,l,e$0],
         t$0=t$1,
         e$0=e$1}}
    function of_tree$2(tree){return cons$1(tree,0)}
    function fold$13(init,f,param)
     {var init$0=init,param$0=param;
      for(;;)
       {if(! param$0)return init$0;
        var
         enum$0=param$0[4],
         tree=param$0[3],
         data=param$0[2],
         key=param$0[1],
         init$1=caml_call3(f,key,data,init$0),
         param$1=cons$1(tree,enum$0),
         init$0=init$1,
         param$0=param$1}}
    function fold2$0(compare_key,t1,t2,curr,f)
     {var t1$0=t1,t2$0=t2,curr$0=curr;
      for(;;)
       {if(! t1$0)
         return t2$0
                 ?fold$13
                   (curr$0,
                    function(key,data,acc)
                     {return caml_call3(f,key,[0,-57574468,data],acc)},
                    t2$0)
                 :curr$0;
        if(! t2$0)
         return fold$13
                 (curr$0,
                  function(key,data,acc)
                   {return caml_call3(f,key,[0,847852583,data],acc)},
                  t1$0);
        var
         enum2=t2$0[4],
         tree2=t2$0[3],
         v2=t2$0[2],
         k2=t2$0[1],
         enum1=t1$0[4],
         tree1=t1$0[3],
         v1=t1$0[2],
         k1=t1$0[1],
         compare_result=caml_call2(compare_key,k1,k2);
        if(0 === compare_result)
         {var
           curr$1=caml_call3(f,k1,[0,737457313,[0,v1,v2]],curr$0),
           t2$1=cons$1(tree2,enum2),
           t1$1=cons$1(tree1,enum1),
           t1$0=t1$1,
           t2$0=t2$1,
           curr$0=curr$1;
          continue}
        if(0 <= compare_result)
         {var
           curr$2=caml_call3(f,k2,[0,-57574468,v2],curr$0),
           t2$2=cons$1(tree2,enum2),
           t2$0=t2$2,
           curr$0=curr$2;
          continue}
        var
         curr$3=caml_call3(f,k1,[0,847852583,v1],curr$0),
         t1$2=cons$1(tree1,enum1),
         t1$0=t1$2,
         curr$0=curr$3}}
    function symmetric_diff$2(t1,t2,compare_key,data_equal)
     {function step(state)
       {var _rE_=state[1];
        if(! _rE_)
         {var _rL_=state[2];
          if(! _rL_)return 0;
          var enum$0=_rL_[4],tree=_rL_[3],data=_rL_[2],key=_rL_[1];
          return [1,[0,key,[0,-57574468,data]],[0,0,cons$1(tree,enum$0)]]}
        var _rF_=state[2],_rG_=_rE_[4],_rH_=_rE_[3],_rI_=_rE_[2],_rJ_=_rE_[1];
        if(! _rF_)
         return [1,[0,_rJ_,[0,847852583,_rI_]],[0,cons$1(_rH_,_rG_),0]];
        var
         enum2=_rF_[4],
         tree2=_rF_[3],
         v2=_rF_[2],
         k2=_rF_[1],
         compare_result=caml_call2(compare_key,_rJ_,k2);
        if(0 !== compare_result)
         return 0 <= compare_result
                 ?[1,[0,k2,[0,-57574468,v2]],[0,_rE_,cons$1(tree2,enum2)]]
                 :[1,[0,_rJ_,[0,847852583,_rI_]],[0,cons$1(_rH_,_rG_),_rF_]];
        if(_rH_ === tree2)
         var next_state=[0,_rG_,enum2];
        else
         var _rK_=cons$1(tree2,enum2),next_state=[0,cons$1(_rH_,_rG_),_rK_];
        return caml_call2(data_equal,_rI_,v2)
                ?[0,next_state]
                :[1,[0,_rJ_,[0,1013247643,[0,_rI_,v2]]],next_state]}
      var _rD_=of_tree$2(t2);
      return [0,[0,of_tree$2(t1),_rD_],step]}
    function to_sequence$3
     (comparator,opt,keys_greater_or_equal_to,keys_less_or_equal_to,t$4)
     {if(opt)var sth=opt[1],order=sth;else var order=-542431297;
      function inclusive_bound(side,t,bound)
       {var
         compare_key=comparator[1],
         match=split$4(t,bound,compare_key),
         r=match[3],
         maybe=match[2],
         l=match[1],
         t$0=caml_call1(side,[0,l,r]);
        if(! maybe)return t$0;
        var match$0=maybe[1],data=match$0[2],key=match$0[1];
        return set$6(t$0,key,data,compare_key)}
      if(511974747 <= order)
       {var
         t$5=
          fold$0
           (keys_greater_or_equal_to,
            t$4,
            function(_rB_,_rC_){return inclusive_bound(get_data,_rB_,_rC_)}),
         next$0=
          function(enum$0)
           {if(! enum$0)return 0;
            var e=enum$0[4],t=enum$0[3],v=enum$0[2],k=enum$0[1];
            return [1,[0,k,v],cons_right$0(t,e)]};
        if(keys_less_or_equal_to)
         {var key$0=keys_less_or_equal_to[1],t$1=t$5,e$1=0,_ry_=comparator[1];
          for(;;)
           {if(typeof t$1 !== "number")
             {if(0 === t$1[0])
               {var d$1=t$1[2],v$2=t$1[1],t$2=[1,0,v$2,d$1,0,1],t$1=t$2;
                continue}
              var l$0=t$1[1],v$3=t$1[2];
              if(0 < caml_call2(_ry_,v$3,key$0)){var t$1=l$0;continue}
              var
               t$3=t$1[4],
               d$2=t$1[3],
               v$4=t$1[2],
               e$2=[0,v$4,d$2,l$0,e$1],
               t$1=t$3,
               e$1=e$2;
              continue}
            var init$0=e$1;
            break}}
        else
         var init$0=cons_right$0(t$5,0);
        return [0,init$0,next$0]}
      var
       t$6=
        fold$0
         (keys_less_or_equal_to,
          t$4,
          function(_rz_,_rA_){return inclusive_bound(get_key,_rz_,_rA_)});
      function next(enum$0)
       {if(! enum$0)return 0;
        var e=enum$0[4],t=enum$0[3],v=enum$0[2],k=enum$0[1];
        return [1,[0,k,v],cons$1(t,e)]}
      if(keys_greater_or_equal_to)
       {var key=keys_greater_or_equal_to[1],t=t$6,e=0,_rx_=comparator[1];
        for(;;)
         {if(typeof t !== "number")
           {if(0 === t[0]){var d=t[2],v=t[1],t$0=[1,0,v,d,0,1],t=t$0;continue}
            var l=t[1],r=t[4],v$0=t[2];
            if(0 <= caml_call2(_rx_,v$0,key))
             {var r$0=t[4],d$0=t[3],v$1=t[2],e$0=[0,v$1,d$0,r$0,e],t=l,e=e$0;
              continue}
            var t=r;
            continue}
          var init=e;
          break}}
      else
       var init=of_tree$2(t$6);
      return [0,init,next]}
    function compare$59(compare_key,compare_data,t1$1,t2$1)
     {var t2$2=of_tree$2(t2$1),t1$2=of_tree$2(t1$1),t1=t1$2,t2=t2$2;
      for(;;)
       {if(! t1)return t2?-1:0;
        if(! t2)return 1;
        var
         e2=t2[4],
         r2=t2[3],
         d2=t2[2],
         v2=t2[1],
         e1=t1[4],
         r1=t1[3],
         d1=t1[2],
         v1=t1[1],
         c=caml_call2(compare_key,v1,v2);
        if(0 !== c)return c;
        var c$0=caml_call2(compare_data,d1,d2);
        if(0 !== c$0)return c$0;
        if(r1 === r2){var t1=e1,t2=e2;continue}
        var t2$0=cons$1(r2,e2),t1$0=cons$1(r1,e1),t1=t1$0,t2=t2$0}}
    function equal$44(compare_key,compare_data,t1$1,t2$1)
     {var t2$2=of_tree$2(t2$1),t1$2=of_tree$2(t1$1),t1=t1$2,t2=t2$2;
      for(;;)
       {if(t1)
         {if(t2)
           {var
             e2=t2[4],
             r2=t2[3],
             d2=t2[2],
             v2=t2[1],
             e1=t1[4],
             r1=t1[3],
             d1=t1[2],
             v1=t1[1],
             _ru_=0 === caml_call2(compare_key,v1,v2)?1:0;
            if(_ru_)
             {var _rv_=caml_call2(compare_data,d1,d2);
              if(_rv_)
               {if(r1 === r2){var t1=e1,t2=e2;continue}
                var t2$0=cons$1(r2,e2),t1$0=cons$1(r1,e1),t1=t1$0,t2=t2$0;
                continue}
              var _rw_=_rv_}
            else
             var _rw_=_ru_;
            return _rw_}}
        else
         if(! t2)return 1;
        return 0}}
    function iter2$3(t1,t2,f,compare_key)
     {function _rs_(key,data,param){return caml_call2(f,key,data)}
      var _rt_=of_tree$2(t2);
      return fold2$0(compare_key,of_tree$2(t1),_rt_,0,_rs_)}
    function fold2$1(t1,t2,init,f,compare_key)
     {var _rr_=of_tree$2(t2);
      return fold2$0(compare_key,of_tree$2(t1),_rr_,init,f)}
    function fold_symmetric_diff(t1,t2,compare_key,data_equal,init,f)
     {function add(acc,k,v){return caml_call2(f,acc,[0,k,[0,-57574468,v]])}
      function remove(acc,k,v){return caml_call2(f,acc,[0,k,[0,847852583,v]])}
      function delta(acc,k,v$0,v)
       {return caml_call2(data_equal,v$0,v)
                ?acc
                :caml_call2(f,acc,[0,k,[0,1013247643,[0,v$0,v]]])}
      function loop(t$0,t,acc$3)
       {var t$2=t$0,t$1=t,acc$4=acc$3;
        for(;;)
         {if(t$2 === t$1)return acc$4;
          var switch$0=0;
          if(typeof t$2 === "number")
           return fold$12
                   (t$1,acc$4,function(key,data,acc){return add(acc,key,data)});
          if(0 === t$2[0])
           {var _rl_=t$2[2],_rm_=t$2[1];
            if(typeof t$1 === "number")
             switch$0 = 1;
            else
             if(0 === t$1[0])
              {var v=t$1[2],k=t$1[1],x=caml_call2(compare_key,_rm_,k);
               if(0 === x)return delta(acc$4,_rm_,_rl_,v);
               if(0 <= x)
                {var acc$5=add(acc$4,k,v);return remove(acc$5,_rm_,_rl_)}
               var acc$6=remove(acc$4,_rm_,_rl_);
               return add(acc$6,k,v)}}
          else
           {var _rp_=t$2[2],_rn_=t$2[4],_ro_=t$2[3],_rq_=t$2[1];
            if(typeof t$1 === "number")
             switch$0 = 1;
            else
             if(0 !== t$1[0])
              {var l=t$1[1],r=t$1[4],v$0=t$1[3],k$0=t$1[2];
               if(0 === caml_call2(compare_key,_rp_,k$0))
                {var
                  acc$7=loop(_rq_,l,acc$4),
                  acc$8=delta(acc$7,_rp_,_ro_,v$0),
                  t$2=_rn_,
                  t$1=r,
                  acc$4=acc$8;
                 continue}}}
          if(switch$0)
           return fold$12
                   (t$2,
                    acc$4,
                    function(key,data,acc){return remove(acc,key,data)});
          var
           add$0=
            function(acc,k,v){return caml_call2(f,acc,[0,k,[0,-57574468,v]])},
           remove$0=
            function(acc,k,v){return caml_call2(f,acc,[0,k,[0,847852583,v]])},
           right$2=of_tree$2(t$1),
           left$2=of_tree$2(t$2),
           left=left$2,
           right=right$2,
           acc=acc$4;
          for(;;)
           {if(! left)
             return fold$13
                     (acc,
                      function(key,data,acc){return add$0(acc,key,data)},
                      right);
            if(! right)
             return fold$13
                     (acc,
                      function(key,data,acc){return remove$0(acc,key,data)},
                      left);
            var
             enum2=right[4],
             tree2=right[3],
             v2=right[2],
             k2=right[1],
             enum1=left[4],
             tree1=left[3],
             v1=left[2],
             k1=left[1],
             compare_result=caml_call2(compare_key,k1,k2);
            if(0 === compare_result)
             {var
               acc$0=
                caml_call2(data_equal,v1,v2)
                 ?acc
                 :caml_call2(f,acc,[0,k1,[0,1013247643,[0,v1,v2]]]);
              if(tree1 === tree2)
               {var left=enum1,right=enum2,acc=acc$0;continue}
              var
               right$0=cons$1(tree2,enum2),
               left$0=cons$1(tree1,enum1),
               left=left$0,
               right=right$0,
               acc=acc$0;
              continue}
            if(0 <= compare_result)
             {var
               acc$1=add$0(acc,k2,v2),
               right$1=cons$1(tree2,enum2),
               right=right$1,
               acc=acc$1;
              continue}
            var
             acc$2=remove$0(acc,k1,v1),
             left$1=cons$1(tree1,enum1),
             left=left$1,
             acc=acc$2}}}
      return loop(t1,t2,init)}
    function length$17(param)
     {if(typeof param === "number")return 0;
      if(0 === param[0])return 1;
      var r=param[4],l=param[1],_rk_=length$17(r);
      return (length$17(l) + _rk_ | 0) + 1 | 0}
    function keys(t)
     {return fold_right$4(t,0,function(key,param,list){return [0,key,list]})}
    function data(t)
     {return fold_right$4(t,0,function(param,data,list){return [0,data,list]})}
    function Of_foldable(M)
     {function of_foldable_fold(foldable,init,f,compare_key)
       {function _ri_(param,_rj_)
         {var
           data=_rj_[2],
           key=_rj_[1],
           length=param[2],
           accum=param[1],
           match=find$11(accum,key,compare_key);
          if(match)var prev=match[1],prev_data=prev;else var prev_data=init;
          var data$0=caml_call2(f,prev_data,data);
          return set$5(accum,length,key,data$0,compare_key)}
        return caml_call3
                (M[2],foldable,[0,empty_without_value_restrictio,0],_ri_)}
      function of_foldable_reduce(foldable,f,compare_key)
       {function _rg_(param,_rh_)
         {var
           data=_rh_[2],
           key=_rh_[1],
           length=param[2],
           accum=param[1],
           match=find$11(accum,key,compare_key);
          if(match)
           var prev=match[1],new_data=caml_call2(f,prev,data);
          else
           var new_data=data;
          return set$5(accum,length,key,new_data,compare_key)}
        return caml_call3
                (M[2],foldable,[0,empty_without_value_restrictio,0],_rg_)}
      function of_foldable(foldable,compare_key)
       {return with_return
                (function(r)
                  {function _re_(param,_rf_)
                    {var
                      data=_rf_[2],
                      key=_rf_[1],
                      length=param[2],
                      t=param[1],
                      acc=set$5(t,length,key,data,compare_key),
                      length$0=acc[2];
                     return length === length$0
                             ?caml_call1(r,[0,-1048878709,key])
                             :acc}
                   var
                    map=
                     caml_call3
                      (M[2],foldable,[0,empty_without_value_restrictio,0],_re_);
                   return [0,17724,map]})}
      function of_foldable_or_error(foldable,comparator)
       {var match=of_foldable(foldable,comparator[1]);
        if(17724 <= match[1]){var x=match[2];return [0,x]}
        var key=match[2],_rd_=comparator[2];
        return error$0
                (0,
                 0,
                 caml_call2
                  (symbol$59,
                   cst_Map_of,
                   caml_call2(symbol$59,M[1],cst_or_error_duplicate_key)),
                 key,
                 _rd_)}
      function of_foldable_exn(foldable,comparator)
       {var match=of_foldable(foldable,comparator[1]);
        if(17724 <= match[1]){var x=match[2];return x}
        var key=match[2],_rc_=comparator[2];
        return raise
                (create$2
                  (0,
                   0,
                   caml_call2
                    (symbol$59,
                     cst_Map_of$0,
                     caml_call2(symbol$59,M[1],cst_exn_duplicate_key)),
                   key,
                   _rc_))}
      return [0,
              of_foldable_fold,
              of_foldable_reduce,
              of_foldable,
              of_foldable_or_error,
              of_foldable_exn]}
    var
     Of_alist=Of_foldable([0,name$1,fold_left]),
     of_alist_fold=Of_alist[1],
     of_alist_reduce=Of_alist[2],
     of_alist=Of_alist[3],
     of_alist_or_error=Of_alist[4],
     of_alist_exn=Of_alist[5];
    function of_foldable_multi(foldable,fold,compare_key)
     {var alist=caml_call3(fold,foldable,0,function(l,x){return [0,x,l]});
      return caml_call4
              (of_alist_fold,
               alist,
               0,
               function(l,x){return [0,x,l]},
               compare_key)}
    function of_alist_multi(alist,compare_key)
     {return of_foldable_multi(alist,fold_left,compare_key)}
    var
     Of_sequence=Of_foldable([0,name$2,fold$1]),
     of_sequence_fold=Of_sequence[1],
     of_sequence_reduce=Of_sequence[2],
     of_sequence$5=Of_sequence[3],
     of_sequence_or_error=Of_sequence[4],
     of_sequence_exn=Of_sequence[5];
    function of_sequence_multi(sequence,compare_key)
     {return of_foldable_multi(sequence,fold$1,compare_key)}
    function for_all$11(t,f)
     {return with_return
              (function(r)
                {iter$17
                  (t,
                   function(data)
                    {var _rb_=1 - caml_call1(f,data);
                     return _rb_?caml_call1(r,0):_rb_});
                 return 1})}
    function for_alli$6(t,f)
     {return with_return
              (function(r)
                {iteri$9
                  (t,
                   function(key,data)
                    {var _ra_=1 - caml_call2(f,key,data);
                     return _ra_?caml_call1(r,0):_ra_});
                 return 1})}
    function exists$11(t,f)
     {return with_return
              (function(r)
                {iter$17
                  (t,
                   function(data)
                    {var _q$_=caml_call1(f,data);
                     return _q$_?caml_call1(r,1):_q$_});
                 return 0})}
    function existsi$6(t,f)
     {return with_return
              (function(r)
                {iteri$9
                  (t,
                   function(key,data)
                    {var _q__=caml_call2(f,key,data);
                     return _q__?caml_call1(r,1):_q__});
                 return 0})}
    function count$10(t,f)
     {return fold$12
              (t,
               0,
               function(param,data,acc)
                {return caml_call1(f,data)?acc + 1 | 0:acc})}
    function counti$6(t,f)
     {return fold$12
              (t,
               0,
               function(key,data,acc)
                {return caml_call2(f,key,data)?acc + 1 | 0:acc})}
    function to_alist(opt,t)
     {if(opt)var sth=opt[1],key_order=sth;else var key_order=608542111;
      return 608542111 <= key_order
              ?fold_right$4
                (t,0,function(key,data,x){return [0,[0,key,data],x]})
              :fold$12(t,0,function(key,data,x){return [0,[0,key,data],x]})}
    function merge$3(t1,t2,f,compare_key)
     {var
       _q9_=length$17(t2),
       elts=caml_make_vect(length$17(t1) + _q9_ | 0,0),
       i=[0,0];
      iter2$3
       (t1,
        t2,
        function(key,values)
         {var match=caml_call2(f,key,values);
          if(! match)return 0;
          var value=match[1];
          set$1(elts,i[1],[0,key,value]);
          return incr(i)},
        compare_key);
      var len=i[1];
      function get(i){return get$3(elts,i)}
      var tree=of_increasing_iterator_uncheck$4(len,get);
      return [0,tree,len]}
    function merge_large_first
     (length_large,t_large,t_small,call,combine,compare_key)
     {return fold$12
              (t_small,
               [0,t_large,length_large],
               function(key,data,param)
                {var length=param[2],t=param[1];
                 return update
                         (t,
                          key,
                          function(param)
                           {if(! param)return data;
                            var data$0=param[1];
                            return caml_call4(call,combine,key,data$0,data)},
                          length,
                          compare_key)})}
    function call$0(f,key,x,y){return caml_call3(f,key,x,y)}
    function swap$6(f,key,x,y){return caml_call3(f,key,y,x)}
    function merge_skewed(t1,t2,length1,length2,combine,compare_key)
     {return length2 <= length1
              ?merge_large_first(length1,t1,t2,call$0,combine,compare_key)
              :merge_large_first(length2,t2,t1,swap$6,combine,compare_key)}
    function repackage(marker,k,v){return marker?[0,[0,k,v]]:0}
    function closest_key(t$0,dir,k$1,compare_key)
     {var t=t$0,found_marker=0,found_key=0,found_value=0;
      for(;;)
       {if(typeof t === "number")
         return repackage(found_marker,found_key,found_value);
        if(0 === t[0])
         {var
           v=t[2],
           k=t[1],
           c=caml_call2(compare_key,k,k$1),
           _q8_=
            521507869 <= dir
             ?927731004 <= dir?c <= 0?1:0:0 <= c?1:0
             :-640801497 <= dir?c < 0?1:0:0 < c?1:0;
          return _q8_
                  ?[0,[0,k,v]]
                  :repackage(found_marker,found_key,found_value)}
        var
         r=t[4],
         v$0=t[3],
         k$0=t[2],
         l=t[1],
         c$0=caml_call2(compare_key,k$0,k$1);
        if(0 === c$0)
         return -640801497 === dir
                 ?is_empty$10(l)
                   ?repackage(found_marker,found_key,found_value)
                   :max_elt$11(l)
                 :-779285465 <= dir
                   ?[0,[0,k$0,v$0]]
                   :is_empty$10(r)
                     ?repackage(found_marker,found_key,found_value)
                     :min_elt$11(r);
        if(-640801497 !== dir && 927731004 > dir)
         {if(0 < c$0)
           {var t=l,found_marker=1,found_key=k$0,found_value=v$0;continue}
          var t=r;
          continue}
        if(0 <= c$0){var t=l;continue}
        var t=r,found_marker=1,found_key=k$0,found_value=v$0}}
    function rank(t,k,compare_key)
     {var t$0=t;
      for(;;)
       {if(typeof t$0 === "number")return 0;
        if(0 === t$0[0])
         {var k$0=t$0[1];return 0 === caml_call2(compare_key,k$0,k)?_fp_:0}
        var r=t$0[4],k$1=t$0[2],l=t$0[1],c=caml_call2(compare_key,k$1,k);
        if(0 === c)return [0,length$17(l)];
        if(0 < c){var t$0=l;continue}
        var _q7_=function(rank){return (rank + 1 | 0) + length$17(l) | 0};
        return caml_call2(map$16,rank(r,k,compare_key),_q7_)}}
    function nth$4(num_to_search,param)
     {var param$0=param;
      for(;;)
       {if(typeof param$0 === "number")return 0;
        if(0 === param$0[0])
         {var v=param$0[2],k=param$0[1];
          return 0 === num_to_search[1]?[0,[0,k,v]]:(decr(num_to_search),0)}
        var
         r=param$0[4],
         v$0=param$0[3],
         k$0=param$0[2],
         l=param$0[1],
         some=nth$4(num_to_search,l);
        if(some)return some;
        if(0 === num_to_search[1])return [0,[0,k$0,v$0]];
        decr(num_to_search);
        var param$0=r}}
    function nth$5(t,n){return nth$4([0,n],t)}
    function find_first_satisfying$1(t,f)
     {var t$0=t;
      for(;;)
       {if(typeof t$0 === "number")return 0;
        if(0 === t$0[0])
         {var v=t$0[2],k=t$0[1];return caml_call2(f,k,v)?[0,[0,k,v]]:0}
        var r=t$0[4],v$0=t$0[3],k$0=t$0[2],l=t$0[1];
        if(caml_call2(f,k$0,v$0))
         {var x=find_first_satisfying$1(l,f);return x?x:[0,[0,k$0,v$0]]}
        var t$0=r}}
    function find_last_satisfying$1(t,f)
     {var t$0=t;
      for(;;)
       {if(typeof t$0 === "number")return 0;
        if(0 === t$0[0])
         {var v=t$0[2],k=t$0[1];return caml_call2(f,k,v)?[0,[0,k,v]]:0}
        var r=t$0[4],v$0=t$0[3],k$0=t$0[2],l=t$0[1];
        if(caml_call2(f,k$0,v$0))
         {var x=find_last_satisfying$1(r,f);return x?x:[0,[0,k$0,v$0]]}
        var t$0=l}}
    function binary_search$4(t,compare,how,v)
     {if(-839473056 <= how)
       return 200870407 <= how
               ?926943384 <= how
                 ?find_first_satisfying$1
                   (t,
                    function(key,data)
                     {return 0 <= caml_call3(compare,key,data,v)?1:0})
                 :find_last_satisfying$1
                   (t,
                    function(key,data)
                     {return caml_call3(compare,key,data,v) < 0?1:0})
               :-253007807 <= how
                 ?find_last_satisfying$1
                   (t,
                    function(key,data)
                     {return caml_call3(compare,key,data,v) <= 0?1:0})
                 :find_first_satisfying$1
                   (t,
                    function(key,data)
                     {return 0 < caml_call3(compare,key,data,v)?1:0});
      if(-1055410545 <= how)
       {var
         pair=
          find_last_satisfying$1
           (t,
            function(key,data){return caml_call3(compare,key,data,v) <= 0?1:0});
        if(pair)
         {var match=pair[1],data=match[2],key=match[1];
          if(0 === caml_call3(compare,key,data,v))return pair}
        return 0}
      var
       pair$0=
        find_first_satisfying$1
         (t,
          function(key,data){return 0 <= caml_call3(compare,key,data,v)?1:0});
      if(pair$0)
       {var match$0=pair$0[1],data$0=match$0[2],key$0=match$0[1];
        if(0 === caml_call3(compare,key$0,data$0,v))return pair$0}
      return 0}
    function binary_search_segmented$4(t,segment_of,how)
     {function is_left(key,data)
       {var match=caml_call2(segment_of,key,data);
        return 847852583 <= match?1:0}
      function is_right(key,data){return 1 - is_left(key,data)}
      return 125585502 <= how
              ?find_last_satisfying$1(t,is_left)
              :find_first_satisfying$1(t,is_right)}
    function binary_search_one_sided_bound
     (t,maybe_bound,compare,if_exclusive,if_inclusive)
     {function find_bound(t,how,bound,compare)
       {var match=binary_search$4(t,compare,how,bound);
        if(! match)return 0;
        var match$0=match[1],bound$0=match$0[1];
        return [0,[0,bound$0]]}
      if(typeof maybe_bound === "number")return _fq_;
      if(0 === maybe_bound[0])
       {var bound=maybe_bound[1];
        return find_bound(t,if_inclusive,bound,compare)}
      var bound$0=maybe_bound[1];
      return find_bound(t,if_exclusive,bound$0,compare)}
    function binary_search_two_sided_bounds(t,compare,lower_bound,upper_bound)
     {var
       match=
        binary_search_one_sided_bound
         (t,lower_bound,compare,-839473056,926943384);
      if(! match)return 0;
      var
       lower_bound$0=match[1],
       match$0=
        binary_search_one_sided_bound
         (t,upper_bound,compare,200870407,-253007807);
      if(! match$0)return 0;
      var upper_bound$0=match$0[1];
      return [0,[0,lower_bound$0,upper_bound$0]]}
    function of_iteri(iteri,compare_key)
     {var acc=[0,0,[0,empty_without_value_restrictio,0]];
      caml_call1
       (iteri,
        function(key,data)
         {var
           match=acc[2],
           length=match[2],
           map=match[1],
           pair=set$5(map,length,key,data,compare_key),
           length$0=pair[2];
          if(length === length$0 && is_none(acc[1]))
           {acc[1] = [0,key];return 0}
          acc[2] = pair;
          return 0});
      var _q6_=acc[1];
      if(! _q6_)return [0,17724,acc[2]];
      var key=_q6_[1];
      return [0,-1048878709,key]}
    function of_iteri_exn(iteri,comparator)
     {var match=of_iteri(iteri,comparator[1]);
      if(17724 <= match[1]){var v=match[2];return v}
      var key=match[2];
      return raise
              (create$2(0,0,cst_Map_of_iteri_exn_duplicate,key,comparator[2]))}
    function t_of_sexp_direct$2(key_of_sexp,value_of_sexp,sexp,comparator)
     {var
       alist=
        caml_call2
         (t_of_sexp$10,
          caml_call2(pair_of_sexp,key_of_sexp,value_of_sexp),
          sexp),
       compare_key=comparator[1],
       match=caml_call2(of_alist,alist,compare_key);
      if(17724 <= match[1]){var v=match[2];return v}
      var k=match[2];
      function _q0_(_q5_){return _q5_}
      var
       alist_sexps=
        caml_call2
         (t_of_sexp$10,
          caml_call2(pair_of_sexp,function(_q4_){return _q4_},_q0_),
          sexp),
       found_first_k=[0,0];
      iter2_ok
       (alist,
        alist_sexps,
        function(param,_q1_)
         {var
           k2_sexp=_q1_[1],
           k2=param[1],
           _q2_=0 === caml_call2(compare_key,k,k2)?1:0;
          if(_q2_)
           {if(found_first_k[1])
             return caml_call2
                     (of_sexp_error,cst_Map_t_of_sexp_direct_dupli,k2_sexp);
            found_first_k[1] = 1;
            var _q3_=0}
          else
           var _q3_=_q2_;
          return _q3_});
      throw [0,Assert_failure$0,_fr_]}
    function sexp_of_t$56(sexp_of_key,sexp_of_value,t)
     {function f(key,data,acc)
       {var _qZ_=[0,caml_call1(sexp_of_value,data),0];
        return [0,[1,[0,caml_call1(sexp_of_key,key),_qZ_]],acc]}
      return [1,fold_right$4(t,0,f)]}
    function combine_errors$1(t,compare_key,sexp_of_key)
     {var
       _qY_=partition_map$0(t,to_either,compare_key),
       match=_qY_[2],
       error_tree=match[1],
       oks=_qY_[1];
      return is_empty$10(error_tree)
              ?[0,oks]
              :error_s(sexp_of_t$56(sexp_of_key,sexp_of_t$22,error_tree))}
    function map_keys(t1,f,param)
     {var sexp_of_key=param[2],compare_key=param[1];
      return with_return
              (function(param)
                {return [0,
                         17724,
                         fold$12
                          (t1,
                           [0,empty_without_value_restrictio,0],
                           function(key,data,param$0)
                            {var
                              length=param$0[2],
                              t2=param$0[1],
                              key$0=caml_call1(f,key);
                             try
                              {var
                                _qW_=
                                 add_exn_internal
                                  (t2,length,key$0,data,compare_key,sexp_of_key);
                               return _qW_}
                             catch(_qX_)
                              {_qX_ = caml_wrap_exception(_qX_);
                               if(_qX_ === Duplicate)
                                return caml_call1(param,[0,-1048878709,key$0]);
                               throw _qX_}})]})}
    function map_keys_exn(t,f,comparator)
     {var match=map_keys(t,f,comparator);
      if(17724 <= match[1]){var result=match[2];return result}
      var key=match[2],sexp_of_key=comparator[2];
      return raise_s
              (caml_call2
                (message,
                 cst_Map_map_keys_exn_duplicate,
                 [0,[0,cst_key$0,caml_call1(sexp_of_key,key)],0]))}
    function compare_key(t){return t[1][1]}
    function like$0(param,_qV_)
     {var length=_qV_[2],tree=_qV_[1],comparator=param[1];
      return [0,comparator,tree,length]}
    function like2(x,param)
     {var z=param[2],y=param[1],_qU_=like$0(x,z);return [0,like$0(x,y),_qU_]}
    function like_maybe_no_op(old_t,param)
     {var length=param[2],tree=param[1],old_tree=old_t[2],comparator=old_t[1];
      return old_tree === tree?old_t:[0,comparator,tree,length]}
    function with_same_length(param,tree)
     {var length=param[3],comparator=param[1];
      return [0,comparator,tree,length]}
    function of_tree$3(comparator,tree)
     {return [0,comparator,tree,length$17(tree)]}
    function comparator$16(t){return t[1]}
    function to_tree$2(t){return t[2]}
    function invariants$3(t)
     {var _qQ_=compare_key(t),_qR_=invariants$2(t[2],_qQ_);
      if(_qR_)
       var _qS_=t[3],_qT_=length$17(t[2]) === _qS_?1:0;
      else
       var _qT_=_qR_;
      return _qT_}
    function is_empty$11(t){return is_empty$10(t[2])}
    function length$18(t){return t[3]}
    function set$7(t,key,data)
     {var _qP_=compare_key(t);return like$0(t,set$5(t[2],t[3],key,data,_qP_))}
    function add_exn$0(t,key,data)
     {var _qN_=t[1][2],_qO_=compare_key(t);
      return like$0(t,add_exn(t[2],t[3],key,data,_qO_,_qN_))}
    function add_exn_internal$0(t,key,data)
     {var _qL_=t[1][2],_qM_=compare_key(t);
      return like$0(t,add_exn_internal(t[2],t[3],key,data,_qM_,_qL_))}
    function add$4(t,key,data)
     {try
       {var result=add_exn_internal$0(t,key,data)}
      catch(_qK_)
       {_qK_ = caml_wrap_exception(_qK_);
        if(_qK_ === Duplicate)return -1024851605;
        throw _qK_}
      return [0,17724,result]}
    function add_multi$0(t,key,data)
     {var _qJ_=compare_key(t);
      return like$0(t,add_multi(t[2],t[3],key,data,_qJ_))}
    function remove_multi$0(t,key)
     {var _qI_=compare_key(t);
      return like$0(t,remove_multi(t[2],key,t[3],_qI_))}
    function find_multi$0(t,key)
     {var _qH_=compare_key(t);return find_multi(t[2],key,_qH_)}
    function change$0(t,key,f)
     {var _qG_=compare_key(t);return like$0(t,change(t[2],key,f,t[3],_qG_))}
    function update$0(t,key,f)
     {var _qF_=compare_key(t);return like$0(t,update(t[2],key,f,t[3],_qF_))}
    function find_exn$7(t,key)
     {var _qD_=t[1][2],_qE_=compare_key(t);
      return find_exn$6(t[2],key,_qE_,_qD_)}
    function find$12(t,key)
     {var _qC_=compare_key(t);return find$11(t[2],key,_qC_)}
    function remove$4(t,key)
     {var _qB_=compare_key(t);
      return like_maybe_no_op(t,remove$3(t[2],key,t[3],_qB_))}
    function mem$10(t,key)
     {var _qA_=compare_key(t);return mem$9(t[2],key,_qA_)}
    function iter_keys$0(t,f){return iter_keys(t[2],f)}
    function iter$18(t,f){return iter$17(t[2],f)}
    function iteri$10(t,f){return iteri$9(t[2],f)}
    function iteri_until$0(t,f){return iteri_until(t[2],f)}
    function iter2$4(t1,t2,f)
     {var _qz_=compare_key(t1);return iter2$3(t1[2],t2[2],f,_qz_)}
    function map$34(t,f){return with_same_length(t,map$33(t[2],f))}
    function mapi$8(t,f){return with_same_length(t,mapi$7(t[2],f))}
    function fold$14(t,init,f){return fold$12(t[2],init,f)}
    function fold_until$11(t,init,f)
     {var _qx_=t[2];
      return function(_qy_){return fold_until$10(_qx_,init,f,_qy_)}}
    function fold_right$5(t,init,f){return fold_right$4(t[2],init,f)}
    function fold2$2(t1,t2,init,f)
     {var _qw_=compare_key(t1);return fold2$1(t1[2],t2[2],init,f,_qw_)}
    function filter_keys$0(t,f)
     {var _qv_=compare_key(t);return like$0(t,filter_keys(t[2],f,_qv_))}
    function filter$9(t,f)
     {var _qu_=compare_key(t);return like$0(t,filter$8(t[2],f,_qu_))}
    function filteri$5(t,f)
     {var _qt_=compare_key(t);return like$0(t,filteri$4(t[2],f,_qt_))}
    function filter_map$9(t,f)
     {var _qs_=compare_key(t);return like$0(t,filter_map$8(t[2],f,_qs_))}
    function filter_mapi$4(t,f)
     {var _qr_=compare_key(t);return like$0(t,filter_mapi$3(t[2],f,_qr_))}
    function partition_mapi$0(t,f)
     {var _qq_=compare_key(t);return like2(t,partition_mapi(t[2],f,_qq_))}
    function partition_map$1(t,f)
     {var _qp_=compare_key(t);return like2(t,partition_map$0(t[2],f,_qp_))}
    function partitioni_tf$1(t,f)
     {var _qo_=compare_key(t);return like2(t,partitioni_tf$0(t[2],f,_qo_))}
    function partition_tf$5(t,f)
     {var _qn_=compare_key(t);return like2(t,partition_tf$4(t[2],f,_qn_))}
    function combine_errors$2(t)
     {function _qj_(_qm_){return like$0(t,_qm_)}
      var _qk_=t[1][2],_ql_=compare_key(t);
      return caml_call2(map$5,combine_errors$1(t[2],_ql_,_qk_),_qj_)}
    function compare_direct$1(compare_data,t1,t2)
     {var _qh_=t2[2],_qi_=t1[2];
      return compare$59(compare_key(t1),compare_data,_qi_,_qh_)}
    function equal$45(compare_data,t1,t2)
     {var _qf_=t2[2],_qg_=t1[2];
      return equal$44(compare_key(t1),compare_data,_qg_,_qf_)}
    function keys$0(t){return keys(t[2])}
    function data$0(t){return data(t[2])}
    function to_alist$0(key_order,t){return to_alist(key_order,t[2])}
    function symmetric_diff$3(t1,t2,data_equal)
     {var _qe_=compare_key(t1);
      return symmetric_diff$2(t1[2],t2[2],_qe_,data_equal)}
    function fold_symmetric_diff$0(t1,t2,data_equal,init,f)
     {var _qd_=compare_key(t1);
      return fold_symmetric_diff(t1[2],t2[2],_qd_,data_equal,init,f)}
    function merge$4(t1,t2,f)
     {var _qc_=compare_key(t1);return like$0(t1,merge$3(t1[2],t2[2],f,_qc_))}
    function merge_skewed$0(t1,t2,combine)
     {var
       _qa_=compare_key(t1),
       _qb_=merge_skewed(t1[2],t2[2],t1[3],t2[3],combine,_qa_),
       t1$0=t2[3] <= t1[3]?t1:t2;
      return like_maybe_no_op(t1$0,_qb_)}
    function min_elt$12(t){return min_elt$11(t[2])}
    function min_elt_exn$3(t){return min_elt_exn$2(t[2])}
    function max_elt$12(t){return max_elt$11(t[2])}
    function max_elt_exn$3(t){return max_elt_exn$2(t[2])}
    function for_all$12(t,f){return for_all$11(t[2],f)}
    function for_alli$7(t,f){return for_alli$6(t[2],f)}
    function exists$12(t,f){return exists$11(t[2],f)}
    function existsi$7(t,f){return existsi$6(t[2],f)}
    function count$11(t,f){return count$10(t[2],f)}
    function counti$7(t,f){return counti$6(t[2],f)}
    function split$5(t,k)
     {var
       _p__=compare_key(t),
       match=split$4(t[2],k,_p__),
       r=match[3],
       maybe=match[2],
       l=match[1],
       comparator=t[1],
       both_len=is_some(maybe)?t[3] - 1 | 0:t[3],
       _p$_=height$0(r);
      if(height$0(l) < _p$_)
       {var l$0=of_tree$3(comparator,l);
        return [0,l$0,maybe,[0,comparator,r,both_len - l$0[3] | 0]]}
      var r$0=of_tree$3(comparator,r);
      return [0,[0,comparator,l,both_len - r$0[3] | 0],maybe,r$0]}
    function subrange(t,lower_bound,upper_bound)
     {var
       _p7_=compare_key(t),
       match=split_range(t[2],lower_bound,upper_bound,_p7_),
       right=match[3],
       mid=match[2],
       left=match[1],
       h_l=height$0(left),
       h_r=height$0(right),
       outer_joined_height=h_l === h_r?h_l + 1 | 0:caml_call2(max$2,h_l,h_r);
      if(outer_joined_height >= height$0(mid))return of_tree$3(t[1],mid);
      var
       _p8_=length$17(right),
       _p9_=length$17(left) + _p8_ | 0,
       mid_length=t[3] - _p9_ | 0;
      return [0,t[1],mid,mid_length]}
    function append$3(lower_part,upper_part)
     {var
       _p6_=compare_key(lower_part),
       match=append$2(lower_part[2],upper_part[2],_p6_);
      if(typeof match === "number")return 838882908;
      var tree=match[2];
      return [0,
              17724,
              [0,lower_part[1],tree,lower_part[3] + upper_part[3] | 0]]}
    function fold_range_inclusive$0(t,min,max,init,f)
     {var _p5_=compare_key(t);
      return fold_range_inclusive(t[2],min,max,init,f,_p5_)}
    function range_to_alist$0(t,min,max)
     {var _p4_=compare_key(t);return range_to_alist(t[2],min,max,_p4_)}
    function closest_key$0(t,dir,key)
     {var _p3_=compare_key(t);return closest_key(t[2],dir,key,_p3_)}
    function nth$6(t,n){return nth$5(t[2],n)}
    function nth_exn$1(t,n){return value_exn(0,0,0,nth$6(t,n))}
    function rank$0(t,key){var _p2_=compare_key(t);return rank(t[2],key,_p2_)}
    function sexp_of_t$57(sexp_of_k,sexp_of_v,param,t)
     {return sexp_of_t$56(sexp_of_k,sexp_of_v,t[2])}
    function to_sequence$4
     (order,keys_greater_or_equal_to,keys_less_or_equal_to,t)
     {return to_sequence$3
              (t[1],order,keys_greater_or_equal_to,keys_less_or_equal_to,t[2])}
    function binary_search$5(t,compare,how,v)
     {return binary_search$4(t[2],compare,how,v)}
    function binary_search_segmented$5(t,segment_of,how)
     {return binary_search_segmented$4(t[2],segment_of,how)}
    function hash_fold_direct$0(hash_fold_key,hash_fold_data,state,t)
     {var _p1_=t[2];
      function _p0_(key,data,state)
       {return caml_call2
                (hash_fold_data,caml_call2(hash_fold_key,state,key),data)}
      return fold$12
              (_p1_,caml_call2(hash_fold_t$4,state,length$17(_p1_)),_p0_)}
    function binary_search_subrange(t,compare,lower_bound,upper_bound)
     {var
       match=
        binary_search_two_sided_bounds(t[2],compare,lower_bound,upper_bound);
      if(! match)return like_maybe_no_op(t,_fs_);
      var match$0=match[1],upper_bound$0=match$0[2],lower_bound$0=match$0[1];
      return subrange(t,lower_bound$0,upper_bound$0)}
    function empty$6(param){return empty_without_value_restrictio}
    function of_tree$4(param,tree){return tree}
    function singleton$8(param,k,v){return [0,k,v]}
    function of_sorted_array_unchecked$5(comparator,array)
     {return of_sorted_array_unchecked$4(array,comparator[1])[1]}
    function of_sorted_array$5(comparator,array)
     {return caml_call2(map$5,of_sorted_array$4(array,comparator[1]),get_key)}
    function of_alist$0(comparator,alist)
     {var d=caml_call2(of_alist,alist,comparator[1]);
      if(17724 > d[1])return d;
      var match=d[2],tree=match[1];
      return [0,17724,tree]}
    function of_alist_or_error$0(comparator,alist)
     {return caml_call2
              (map$5,caml_call2(of_alist_or_error,alist,comparator),get_key)}
    function of_alist_exn$0(comparator,alist)
     {return caml_call2(of_alist_exn,alist,comparator)[1]}
    function of_alist_multi$0(comparator,alist)
     {return of_alist_multi(alist,comparator[1])[1]}
    function of_alist_fold$0(comparator,alist,init,f)
     {return caml_call4(of_alist_fold,alist,init,f,comparator[1])[1]}
    function of_alist_reduce$0(comparator,alist,f)
     {return caml_call3(of_alist_reduce,alist,f,comparator[1])[1]}
    function of_iteri$0(comparator,iteri)
     {var d=of_iteri(iteri,comparator[1]);
      if(17724 > d[1])return d;
      var match=d[2],tree=match[1];
      return [0,17724,tree]}
    function of_iteri_exn$0(comparator,iteri)
     {return of_iteri_exn(iteri,comparator)[1]}
    function of_increasing_iterator_uncheck$5(required_by_intf,len,f)
     {return of_increasing_iterator_uncheck$4(len,f)}
    function of_increasing_sequence$0(comparator,seq)
     {return caml_call2
              (map$5,of_increasing_sequence(seq,comparator[1]),get_key)}
    function of_sequence$6(comparator,seq)
     {var d=caml_call2(of_sequence$5,seq,comparator[1]);
      if(17724 > d[1])return d;
      var match=d[2],tree=match[1];
      return [0,17724,tree]}
    function of_sequence_or_error$0(comparator,seq)
     {return caml_call2
              (map$5,caml_call2(of_sequence_or_error,seq,comparator),get_key)}
    function of_sequence_exn$0(comparator,seq)
     {return caml_call2(of_sequence_exn,seq,comparator)[1]}
    function of_sequence_multi$0(comparator,seq)
     {return of_sequence_multi(seq,comparator[1])[1]}
    function of_sequence_fold$0(comparator,seq,init,f)
     {return caml_call4(of_sequence_fold,seq,init,f,comparator[1])[1]}
    function of_sequence_reduce$0(comparator,seq,f)
     {return caml_call3(of_sequence_reduce,seq,f,comparator[1])[1]}
    function to_tree$3(t){return t}
    function invariants$4(comparator,t){return invariants$2(t,comparator[1])}
    function is_empty$12(t){return is_empty$10(t)}
    function length$19(t){return length$17(t)}
    function set$8(comparator,t,key,data)
     {return set$5(t,0,key,data,comparator[1])[1]}
    function add_exn$1(comparator,t,key,data)
     {return add_exn(t,0,key,data,comparator[1],comparator[2])[1]}
    function add$5(comparator,t,key,data)
     {try
       {var _pY_=[0,17724,add_exn$1(comparator,t,key,data)];return _pY_}
      catch(_pZ_){return -1024851605}}
    function add_multi$1(comparator,t,key,data)
     {return add_multi(t,0,key,data,comparator[1])[1]}
    function remove_multi$1(comparator,t,key)
     {return remove_multi(t,key,0,comparator[1])[1]}
    function find_multi$1(comparator,t,key)
     {return find_multi(t,key,comparator[1])}
    function change$1(comparator,t,key,f)
     {return change(t,key,f,0,comparator[1])[1]}
    function update$1(comparator,t,key,f)
     {return change$1
              (comparator,t,key,function(data){return [0,caml_call1(f,data)]})}
    function find_exn$8(comparator,t,key)
     {return find_exn$6(t,key,comparator[1],comparator[2])}
    function find$13(comparator,t,key){return find$11(t,key,comparator[1])}
    function remove$5(comparator,t,key)
     {return remove$3(t,key,0,comparator[1])[1]}
    function mem$11(comparator,t,key){return mem$9(t,key,comparator[1])}
    function iter_keys$1(t,f){return iter_keys(t,f)}
    function iter$19(t,f){return iter$17(t,f)}
    function iteri$11(t,f){return iteri$9(t,f)}
    function iteri_until$1(t,f){return iteri_until(t,f)}
    function iter2$5(comparator,t1,t2,f)
     {return iter2$3(t1,t2,f,comparator[1])}
    function map$35(t,f){return map$33(t,f)}
    function mapi$9(t,f){return mapi$7(t,f)}
    function fold$15(t,init,f){return fold$12(t,init,f)}
    function fold_until$12(t,init,f,finish)
     {return fold_until$10(t,init,f,finish)}
    function fold_right$6(t,init,f){return fold_right$4(t,init,f)}
    function fold2$3(comparator,t1,t2,init,f)
     {return fold2$1(t1,t2,init,f,comparator[1])}
    function filter_keys$1(comparator,t,f)
     {return filter_keys(t,f,comparator[1])[1]}
    function filter$10(comparator,t,f){return filter$8(t,f,comparator[1])[1]}
    function filteri$6(comparator,t,f){return filteri$4(t,f,comparator[1])[1]}
    function filter_map$10(comparator,t,f)
     {return filter_map$8(t,f,comparator[1])[1]}
    function filter_mapi$5(comparator,t,f)
     {return filter_mapi$3(t,f,comparator[1])[1]}
    function partition_mapi$1(comparator,t,f)
     {var
       _pX_=partition_mapi(t,f,comparator[1]),
       b=_pX_[2][1],
       match=_pX_[1],
       a=match[1];
      return [0,a,b]}
    function partition_map$2(comparator,t,f)
     {var
       _pW_=partition_map$0(t,f,comparator[1]),
       b=_pW_[2][1],
       match=_pW_[1],
       a=match[1];
      return [0,a,b]}
    function partitioni_tf$2(comparator,t,f)
     {var
       _pV_=partitioni_tf$0(t,f,comparator[1]),
       b=_pV_[2][1],
       match=_pV_[1],
       a=match[1];
      return [0,a,b]}
    function partition_tf$6(comparator,t,f)
     {var
       _pU_=partition_tf$4(t,f,comparator[1]),
       b=_pU_[2][1],
       match=_pU_[1],
       a=match[1];
      return [0,a,b]}
    function combine_errors$3(comparator,t)
     {return caml_call2
              (map$5,combine_errors$1(t,comparator[1],comparator[2]),get_key)}
    function compare_direct$2(comparator,compare_data,t1,t2)
     {return compare$59(comparator[1],compare_data,t1,t2)}
    function equal$46(comparator,compare_data,t1,t2)
     {return equal$44(comparator[1],compare_data,t1,t2)}
    function keys$1(t){return keys(t)}
    function data$1(t){return data(t)}
    function to_alist$1(key_order,t){return to_alist(key_order,t)}
    function symmetric_diff$4(comparator,t1,t2,data_equal)
     {return symmetric_diff$2(t1,t2,comparator[1],data_equal)}
    function fold_symmetric_diff$1(comparator,t1,t2,data_equal,init,f)
     {return fold_symmetric_diff(t1,t2,comparator[1],data_equal,init,f)}
    function merge$5(comparator,t1,t2,f)
     {return merge$3(t1,t2,f,comparator[1])[1]}
    function merge_skewed$1(comparator,t1,t2,combine)
     {var _pS_=comparator[1],_pT_=length$19(t2);
      return merge_skewed(t1,t2,length$19(t1),_pT_,combine,_pS_)[1]}
    function min_elt$13(t){return min_elt$11(t)}
    function min_elt_exn$4(t){return min_elt_exn$2(t)}
    function max_elt$13(t){return max_elt$11(t)}
    function max_elt_exn$4(t){return max_elt_exn$2(t)}
    function for_all$13(t,f){return for_all$11(t,f)}
    function for_alli$8(t,f){return for_alli$6(t,f)}
    function exists$13(t,f){return exists$11(t,f)}
    function existsi$8(t,f){return existsi$6(t,f)}
    function count$12(t,f){return count$10(t,f)}
    function counti$8(t,f){return counti$6(t,f)}
    function split$6(comparator,t,k){return split$4(t,k,comparator[1])}
    function append$4(comparator,lower_part,upper_part)
     {return append$2(lower_part,upper_part,comparator[1])}
    function subrange$0(comparator,t,lower_bound,upper_bound)
     {var
       match=split_range(t,lower_bound,upper_bound,comparator[1]),
       ret=match[2];
      return ret}
    function fold_range_inclusive$1(comparator,t,min,max,init,f)
     {return fold_range_inclusive(t,min,max,init,f,comparator[1])}
    function range_to_alist$1(comparator,t,min,max)
     {return range_to_alist(t,min,max,comparator[1])}
    function closest_key$1(comparator,t,dir,key)
     {return closest_key(t,dir,key,comparator[1])}
    function nth$7(t,n){return nth$5(t,n)}
    function nth_exn$2(t,n){return value_exn(0,0,0,nth$7(t,n))}
    function rank$1(comparator,t,key){return rank(t,key,comparator[1])}
    function sexp_of_t$58(sexp_of_k,sexp_of_v,param,t)
     {return sexp_of_t$56(sexp_of_k,sexp_of_v,t)}
    function t_of_sexp_direct$3(comparator,k_of_sexp,v_of_sexp,sexp)
     {return t_of_sexp_direct$2(k_of_sexp,v_of_sexp,sexp,comparator)[1]}
    function to_sequence$5
     (comparator,order,keys_greater_or_equal_to,keys_less_or_equal_to,t)
     {return to_sequence$3
              (comparator,
               order,
               keys_greater_or_equal_to,
               keys_less_or_equal_to,
               t)}
    function binary_search$6(param,t,compare,how,v)
     {return binary_search$4(t,compare,how,v)}
    function binary_search_segmented$6(param,t,segment_of,how)
     {return binary_search_segmented$4(t,segment_of,how)}
    function binary_search_subrange$0
     (comparator,t,compare,lower_bound,upper_bound)
     {var
       match=
        binary_search_two_sided_bounds(t,compare,lower_bound,upper_bound);
      if(! match)return 0;
      var match$0=match[1],upper_bound$0=match$0[2],lower_bound$0=match$0[1];
      return subrange$0(comparator,t,lower_bound$0,upper_bound$0)}
    function map_keys$0(comparator,t,f)
     {var dup=map_keys(t,f,comparator);
      if(17724 > dup[1])return dup;
      var match=dup[2],t$0=match[1];
      return [0,17724,t$0]}
    function map_keys_exn$0(comparator,t,f)
     {return map_keys_exn(t,f,comparator)[1]}
    function add_exn$2(t,comparator,key,data)
     {var match=max_key(t);
      if(match)
       {var prev_key=match[1];
        if(0 <= caml_call2(comparator[1],prev_key,key))return raise_s(_ft_)}
      return add_unchecked(t,key,data)}
    function to_tree$4(t){return to_tree_unchecked(t)}
    var Build_increasing=[0,empty$5,add_exn$2,to_tree$4];
    function empty$7(comparator)
     {return [0,comparator,empty_without_value_restrictio,0]}
    function singleton$9(comparator,k,v){return [0,comparator,[0,k,v],1]}
    function of_tree0(comparator,param)
     {var length=param[2],tree=param[1];return [0,comparator,tree,length]}
    function of_tree$5(comparator,tree)
     {return of_tree0(comparator,[0,tree,length$17(tree)])}
    function of_sorted_array_unchecked$6(comparator,array)
     {return of_tree0
              (comparator,of_sorted_array_unchecked$4(array,comparator[1]))}
    function of_sorted_array$6(comparator,array)
     {function _pR_(tree){return of_tree0(comparator,tree)}
      return caml_call2(map$5,of_sorted_array$4(array,comparator[1]),_pR_)}
    function of_alist$1(comparator,alist)
     {var z=caml_call2(of_alist,alist,comparator[1]);
      if(17724 > z[1])return z;
      var match=z[2],length=match[2],tree=match[1];
      return [0,17724,[0,comparator,tree,length]]}
    function of_alist_or_error$1(comparator,alist)
     {function _pQ_(tree){return of_tree0(comparator,tree)}
      return caml_call2
              (map$5,caml_call2(of_alist_or_error,alist,comparator),_pQ_)}
    function of_alist_exn$1(comparator,alist)
     {return of_tree0(comparator,caml_call2(of_alist_exn,alist,comparator))}
    function of_alist_multi$1(comparator,alist)
     {return of_tree0(comparator,of_alist_multi(alist,comparator[1]))}
    function of_alist_fold$1(comparator,alist,init,f)
     {return of_tree0
              (comparator,
               caml_call4(of_alist_fold,alist,init,f,comparator[1]))}
    function of_alist_reduce$1(comparator,alist,f)
     {return of_tree0
              (comparator,caml_call3(of_alist_reduce,alist,f,comparator[1]))}
    function of_iteri$1(comparator,iteri)
     {var z=of_iteri(iteri,comparator[1]);
      if(17724 > z[1])return z;
      var tree_length=z[2];
      return [0,17724,of_tree0(comparator,tree_length)]}
    function of_iteri_exn$1(comparator,iteri)
     {return of_tree0(comparator,of_iteri_exn(iteri,comparator))}
    function of_increasing_iterator_uncheck$6(comparator,len,f)
     {return of_tree0
              (comparator,[0,of_increasing_iterator_uncheck$4(len,f),len])}
    function of_increasing_sequence$1(comparator,seq)
     {function _pO_(_pP_){return of_tree0(comparator,_pP_)}
      return caml_call2(map$5,of_increasing_sequence(seq,comparator[1]),_pO_)}
    function of_sequence$7(comparator,seq)
     {var z=caml_call2(of_sequence$5,seq,comparator[1]);
      if(17724 > z[1])return z;
      var match=z[2],length=match[2],tree=match[1];
      return [0,17724,[0,comparator,tree,length]]}
    function of_sequence_or_error$1(comparator,seq)
     {function _pN_(tree){return of_tree0(comparator,tree)}
      return caml_call2
              (map$5,caml_call2(of_sequence_or_error,seq,comparator),_pN_)}
    function of_sequence_exn$1(comparator,seq)
     {return of_tree0(comparator,caml_call2(of_sequence_exn,seq,comparator))}
    function of_sequence_multi$1(comparator,seq)
     {return of_tree0(comparator,of_sequence_multi(seq,comparator[1]))}
    function of_sequence_fold$1(comparator,seq,init,f)
     {return of_tree0
              (comparator,
               caml_call4(of_sequence_fold,seq,init,f,comparator[1]))}
    function of_sequence_reduce$1(comparator,seq,f)
     {return of_tree0
              (comparator,caml_call3(of_sequence_reduce,seq,f,comparator[1]))}
    function t_of_sexp_direct$4(comparator,k_of_sexp,v_of_sexp,sexp)
     {return of_tree0
              (comparator,
               t_of_sexp_direct$2(k_of_sexp,v_of_sexp,sexp,comparator))}
    function map_keys$1(comparator,t,f)
     {var dup=map_keys(t[2],f,comparator);
      if(17724 > dup[1])return dup;
      var pair=dup[2];
      return [0,17724,of_tree0(comparator,pair)]}
    function map_keys_exn$1(comparator,t,f)
     {return of_tree0(comparator,map_keys_exn(t[2],f,comparator))}
    function Empty_without_value_restrictio$0(K)
     {var empty=[0,K[1],empty_without_value_restrictio,0];return [0,empty]}
    function comparator_s$0(t){var comparator=t[1];return [0,comparator]}
    function of_tree$6(M){return function(tree){return of_tree$3(M[1],tree)}}
    function empty$8(m){return empty$7(m[1])}
    function singleton$10(m,a)
     {var _pL_=m[1];return function(_pM_){return singleton$9(_pL_,a,_pM_)}}
    function of_alist$2(m,a){return of_alist$1(m[1],a)}
    function of_alist_or_error$2(m,a){return of_alist_or_error$1(m[1],a)}
    function of_alist_exn$2(m,a){return of_alist_exn$1(m[1],a)}
    function of_alist_multi$2(m,a){return of_alist_multi$1(m[1],a)}
    function of_alist_fold$2(m,a,init,f)
     {return of_alist_fold$1(m[1],a,init,f)}
    function of_alist_reduce$2(m,a,f){return of_alist_reduce$1(m[1],a,f)}
    function of_sorted_array_unchecked$7(m,a)
     {return of_sorted_array_unchecked$6(m[1],a)}
    function of_sorted_array$7(m,a){return of_sorted_array$6(m[1],a)}
    function of_iteri$2(m,iteri){return of_iteri$1(m[1],iteri)}
    function of_iteri_exn$2(m,iteri){return of_iteri_exn$1(m[1],iteri)}
    function of_increasing_iterator_uncheck$7(m,len,f)
     {return of_increasing_iterator_uncheck$6(m[1],len,f)}
    function of_increasing_sequence$2(m,seq)
     {return of_increasing_sequence$1(m[1],seq)}
    function of_sequence$8(m,s){return of_sequence$7(m[1],s)}
    function of_sequence_or_error$2(m,s)
     {return of_sequence_or_error$1(m[1],s)}
    function of_sequence_exn$2(m,s){return of_sequence_exn$1(m[1],s)}
    function of_sequence_multi$2(m,s){return of_sequence_multi$1(m[1],s)}
    function of_sequence_fold$2(m,s,init,f)
     {return of_sequence_fold$1(m[1],s,init,f)}
    function of_sequence_reduce$2(m,s,f)
     {return of_sequence_reduce$1(m[1],s,f)}
    function map_keys$2(m,t,f){return map_keys$1(m[1],t,f)}
    function map_keys_exn$2(m,t,f){return map_keys_exn$1(m[1],t,f)}
    function M$0(K){return [0]}
    function sexp_of_m_t$0(K)
     {return function(sexp_of_v,t)
       {function _pK_(param){return _fu_}
        return sexp_of_t$57(K[1],sexp_of_v,_pK_,t)}}
    function m_t_of_sexp$0(K)
     {return function(v_of_sexp,sexp)
       {return t_of_sexp_direct$4(K[2],K[1],v_of_sexp,sexp)}}
    function m_t_sexp_grammar$0(K)
     {return function(v_grammar){return [2,[1,[2,[0,K[1],[0,v_grammar,0]]]]]}}
    function compare_m_t$0(param,compare_v,t1,t2)
     {return compare_direct$1(compare_v,t1,t2)}
    function equal_m_t$0(param,equal_v,t1,t2){return equal$45(equal_v,t1,t2)}
    function hash_fold_m_t$0(K)
     {return function(hash_fold_v,state)
       {var _pI_=K[1];
        return function(_pJ_)
         {return hash_fold_direct$0(_pI_,hash_fold_v,state,_pJ_)}}}
    var comparator$17=Poly[1];
    function of_tree$7(tree){return [0,comparator$17,tree,length$17(tree)]}
    var
     include$68=Empty_without_value_restrictio$0(Poly),
     empty$9=include$68[1];
    function singleton$11(a)
     {return function(_pH_){return singleton$9(comparator$17,a,_pH_)}}
    function of_alist$3(a){return of_alist$1(comparator$17,a)}
    function of_alist_or_error$3(a)
     {return of_alist_or_error$1(comparator$17,a)}
    function of_alist_exn$3(a){return of_alist_exn$1(comparator$17,a)}
    function of_alist_multi$3(a){return of_alist_multi$1(comparator$17,a)}
    function of_alist_fold$3(a,init,f)
     {return of_alist_fold$1(comparator$17,a,init,f)}
    function of_alist_reduce$3(a,f)
     {return of_alist_reduce$1(comparator$17,a,f)}
    function of_sorted_array_unchecked$8(a)
     {return of_sorted_array_unchecked$6(comparator$17,a)}
    function of_sorted_array$8(a){return of_sorted_array$6(comparator$17,a)}
    function of_iteri$3(iteri){return of_iteri$1(comparator$17,iteri)}
    function of_iteri_exn$3(iteri){return of_iteri_exn$1(comparator$17,iteri)}
    function of_increasing_iterator_uncheck$8(len,f)
     {return of_increasing_iterator_uncheck$6(comparator$17,len,f)}
    function of_increasing_sequence$3(seq)
     {return of_increasing_sequence$1(comparator$17,seq)}
    function of_sequence$9(s){return of_sequence$7(comparator$17,s)}
    function of_sequence_or_error$3(s)
     {return of_sequence_or_error$1(comparator$17,s)}
    function of_sequence_exn$3(s){return of_sequence_exn$1(comparator$17,s)}
    function of_sequence_multi$3(s)
     {return of_sequence_multi$1(comparator$17,s)}
    function of_sequence_fold$3(s,init,f)
     {return of_sequence_fold$1(comparator$17,s,init,f)}
    function of_sequence_reduce$3(s,f)
     {return of_sequence_reduce$1(comparator$17,s,f)}
    function map_keys$3(t,f){return map_keys$1(comparator$17,t,f)}
    function map_keys_exn$3(t,f){return map_keys_exn$1(comparator$17,t,f)}
    var
     Base_Map=
      [0,
       Finished_or_unfinished,
       Merge_element,
       invariants$3,
       comparator_s$0,
       comparator$16,
       empty$8,
       singleton$10,
       of_alist$2,
       of_alist_or_error$2,
       of_alist_exn$2,
       of_alist_multi$2,
       of_alist_fold$2,
       of_alist_reduce$2,
       of_iteri$2,
       of_iteri_exn$2,
       of_sorted_array$7,
       of_sorted_array_unchecked$7,
       of_increasing_iterator_uncheck$7,
       of_increasing_sequence$2,
       of_sequence$8,
       of_sequence_or_error$2,
       of_sequence_exn$2,
       of_sequence_multi$2,
       of_sequence_fold$2,
       of_sequence_reduce$2,
       is_empty$11,
       length$18,
       set$7,
       add$4,
       add_exn$0,
       add_multi$0,
       remove_multi$0,
       find_multi$0,
       change$0,
       update$0,
       find$12,
       find_exn$7,
       remove$4,
       mem$10,
       iter_keys$0,
       iter$18,
       iteri$10,
       iteri_until$0,
       iter2$4,
       map$34,
       mapi$8,
       map_keys$2,
       map_keys_exn$2,
       fold$14,
       fold_until$11,
       fold_right$5,
       fold2$2,
       filter_keys$0,
       filter$9,
       filteri$5,
       filter_map$9,
       filter_mapi$4,
       partition_mapi$0,
       partition_map$1,
       partitioni_tf$1,
       partition_tf$5,
       combine_errors$2,
       compare_direct$1,
       hash_fold_direct$0,
       equal$45,
       keys$0,
       data$0,
       to_alist$0,
       merge$4,
       merge_skewed$0,
       Symmetric_diff_element,
       symmetric_diff$3,
       fold_symmetric_diff$0,
       min_elt$12,
       min_elt_exn$3,
       max_elt$12,
       max_elt_exn$3,
       for_all$12,
       for_alli$7,
       exists$12,
       existsi$7,
       count$11,
       counti$7,
       split$5,
       append$3,
       subrange,
       fold_range_inclusive$0,
       range_to_alist$0,
       closest_key$0,
       nth$6,
       nth_exn$1,
       rank$0,
       to_sequence$4,
       binary_search$5,
       binary_search_segmented$5,
       binary_search_subrange,
       M$0,
       sexp_of_m_t$0,
       m_t_of_sexp$0,
       m_t_sexp_grammar$0,
       compare_m_t$0,
       equal_m_t$0,
       hash_fold_m_t$0,
       [0,
        sexp_of_t$57,
        t_of_sexp_direct$4,
        [0,
         sexp_of_t$58,
         t_of_sexp_direct$3,
         empty$6,
         singleton$8,
         map_keys$0,
         map_keys_exn$0,
         of_alist$0,
         of_alist_or_error$0,
         of_alist_exn$0,
         of_alist_multi$0,
         of_alist_fold$0,
         of_alist_reduce$0,
         of_sorted_array$5,
         of_sorted_array_unchecked$5,
         of_increasing_iterator_uncheck$5,
         of_increasing_sequence$0,
         of_sequence$6,
         of_sequence_or_error$0,
         of_sequence_exn$0,
         of_sequence_multi$0,
         of_sequence_fold$0,
         of_sequence_reduce$0,
         of_iteri$0,
         of_iteri_exn$0,
         of_tree$4,
         invariants$4,
         is_empty$12,
         length$19,
         add$5,
         add_exn$1,
         set$8,
         add_multi$1,
         remove_multi$1,
         find_multi$1,
         change$1,
         update$1,
         find$13,
         find_exn$8,
         remove$5,
         mem$11,
         iter_keys$1,
         iter$19,
         iteri$11,
         iteri_until$1,
         iter2$5,
         map$35,
         mapi$9,
         fold$15,
         fold_until$12,
         fold_right$6,
         fold2$3,
         filter_keys$1,
         filter$10,
         filteri$6,
         filter_map$10,
         filter_mapi$5,
         partition_mapi$1,
         partition_map$2,
         partitioni_tf$2,
         partition_tf$6,
         combine_errors$3,
         compare_direct$2,
         equal$46,
         keys$1,
         data$1,
         to_alist$1,
         merge$5,
         merge_skewed$1,
         symmetric_diff$4,
         fold_symmetric_diff$1,
         min_elt$13,
         min_elt_exn$4,
         max_elt$13,
         max_elt_exn$4,
         for_all$13,
         for_alli$8,
         exists$13,
         existsi$8,
         count$12,
         counti$8,
         split$6,
         append$4,
         subrange$0,
         fold_range_inclusive$1,
         range_to_alist$1,
         closest_key$1,
         nth$7,
         nth_exn$2,
         rank$1,
         to_tree$3,
         to_sequence$5,
         binary_search$6,
         binary_search_segmented$6,
         binary_search_subrange$0,
         empty_without_value_restrictio,
         Build_increasing],
        invariants$3,
        is_empty$11,
        length$18,
        add$4,
        add_exn$0,
        set$7,
        add_multi$0,
        remove_multi$0,
        find_multi$0,
        change$0,
        update$0,
        find$12,
        find_exn$7,
        remove$4,
        mem$10,
        iter_keys$0,
        iter$18,
        iteri$10,
        iteri_until$0,
        iter2$4,
        map$34,
        mapi$8,
        fold$14,
        fold_until$11,
        fold_right$5,
        fold2$2,
        filter_keys$0,
        filter$9,
        filteri$5,
        filter_map$9,
        filter_mapi$4,
        partition_mapi$0,
        partition_map$1,
        partitioni_tf$1,
        partition_tf$5,
        combine_errors$2,
        compare_direct$1,
        equal$45,
        keys$0,
        data$0,
        to_alist$0,
        merge$4,
        merge_skewed$0,
        symmetric_diff$3,
        fold_symmetric_diff$0,
        min_elt$12,
        min_elt_exn$3,
        max_elt$12,
        max_elt_exn$3,
        for_all$12,
        for_alli$7,
        exists$12,
        existsi$7,
        count$11,
        counti$7,
        split$5,
        append$3,
        subrange,
        fold_range_inclusive$0,
        range_to_alist$0,
        closest_key$0,
        nth$6,
        nth_exn$1,
        rank$0,
        to_tree$2,
        to_sequence$4,
        binary_search$5,
        binary_search_segmented$5,
        binary_search_subrange,
        empty$7,
        singleton$9,
        map_keys$1,
        map_keys_exn$1,
        of_alist$1,
        of_alist_or_error$1,
        of_alist_exn$1,
        of_alist_multi$1,
        of_alist_fold$1,
        of_alist_reduce$1,
        of_sorted_array$6,
        of_sorted_array_unchecked$6,
        of_increasing_iterator_uncheck$6,
        of_increasing_sequence$1,
        of_sequence$7,
        of_sequence_or_error$1,
        of_sequence_exn$1,
        of_sequence_multi$1,
        of_sequence_fold$1,
        of_sequence_reduce$1,
        of_iteri$1,
        of_iteri_exn$1,
        of_tree$5,
        comparator$16,
        hash_fold_direct$0,
        Empty_without_value_restrictio$0],
       [0,
        empty$9,
        singleton$11,
        map_keys$3,
        map_keys_exn$3,
        of_alist$3,
        of_alist_or_error$3,
        of_alist_exn$3,
        of_alist_multi$3,
        of_alist_fold$3,
        of_alist_reduce$3,
        of_sorted_array$8,
        of_sorted_array_unchecked$8,
        of_increasing_iterator_uncheck$8,
        of_increasing_sequence$3,
        of_sequence$9,
        of_sequence_or_error$3,
        of_sequence_exn$3,
        of_sequence_multi$3,
        of_sequence_fold$3,
        of_sequence_reduce$3,
        of_iteri$3,
        of_iteri_exn$3,
        of_tree$7,
        invariants$3,
        is_empty$11,
        length$18,
        add$4,
        add_exn$0,
        set$7,
        add_multi$0,
        remove_multi$0,
        find_multi$0,
        change$0,
        update$0,
        find$12,
        find_exn$7,
        remove$4,
        mem$10,
        iter_keys$0,
        iter$18,
        iteri$10,
        iteri_until$0,
        iter2$4,
        map$34,
        mapi$8,
        fold$14,
        fold_until$11,
        fold_right$5,
        fold2$2,
        filter_keys$0,
        filter$9,
        filteri$5,
        filter_map$9,
        filter_mapi$4,
        partition_mapi$0,
        partition_map$1,
        partitioni_tf$1,
        partition_tf$5,
        combine_errors$2,
        compare_direct$1,
        equal$45,
        keys$0,
        data$0,
        to_alist$0,
        merge$4,
        merge_skewed$0,
        symmetric_diff$3,
        fold_symmetric_diff$0,
        min_elt$12,
        min_elt_exn$3,
        max_elt$12,
        max_elt_exn$3,
        for_all$12,
        for_alli$7,
        exists$12,
        existsi$7,
        count$11,
        counti$7,
        split$5,
        append$3,
        subrange,
        fold_range_inclusive$0,
        range_to_alist$0,
        closest_key$0,
        nth$6,
        nth_exn$1,
        rank$0,
        to_tree$2,
        to_sequence$4,
        binary_search$5,
        binary_search_segmented$5,
        binary_search_subrange],
       of_tree$6,
       to_tree$2];
    caml_register_global(1116,Base_Map,"Base__Map");
    var
     create$15=Stdlib_Queue[2],
     clear$2=Stdlib_Queue[11],
     copy$6=Stdlib_Queue[12],
     is_empty$13=Stdlib_Queue[13],
     length$20=Stdlib_Queue[14],
     peek_exn$0=Stdlib_Queue[8],
     dequeue_exn$0=Stdlib_Queue[7],
     push$0=Stdlib_Queue[4],
     transfer=Stdlib_Queue[17];
    function iter$20(t,f){return caml_call2(Stdlib_Queue[15],f,t)}
    function fold$16(t,init,f){return caml_call3(Stdlib_Queue[16],f,init,t)}
    var
     include$69=
      [0,
       create$15,
       clear$2,
       copy$6,
       is_empty$13,
       length$20,
       peek_exn$0,
       dequeue_exn$0,
       push$0,
       transfer,
       iter$20,
       fold$16];
    caml_register_global(1117,include$69,"Base__Linked_queue0");
    function enqueue$0(t,x){return caml_call2(push$0,x,t)}
    function dequeue$0(t)
     {return caml_call1(is_empty$13,t)?0:[0,caml_call1(dequeue_exn$0,t)]}
    function peek$0(t)
     {return caml_call1(is_empty$13,t)?0:[0,caml_call1(peek_exn$0,t)]}
    var
     iter$21=[0,-198771759,iter$20],
     length$21=[0,-198771759,length$20],
     C$1=_a__([0,fold$16,iter$21,length$21,-304398144,-304398144]),
     count$13=C$1[10],
     exists$14=C$1[8],
     find$14=C$1[12],
     find_map$10=C$1[13],
     fold_result$9=C$1[6],
     fold_until$13=C$1[7],
     for_all$14=C$1[9],
     max_elt$14=C$1[17],
     mem$12=C$1[1],
     min_elt$14=C$1[16],
     sum$10=C$1[11],
     to_list$12=C$1[14],
     counti$9=C$1[22],
     existsi$9=C$1[20],
     find_mapi$6=C$1[24],
     findi$6=C$1[23],
     foldi$10=C$1[18],
     for_alli$9=C$1[21],
     iteri$12=C$1[19];
    function transfer$0(src,dst){return caml_call2(transfer,src,dst)}
    function concat_map$3(t,f)
     {var res=caml_call1(create$15,0);
      iter$20
       (t,
        function(a)
         {function _pG_(b){return enqueue$0(res,b)}
          return iter$0(caml_call1(f,a),_pG_)});
      return res}
    function concat_mapi$3(t,f)
     {var res=caml_call1(create$15,0);
      caml_call2
       (iteri$12,
        t,
        function(i,a)
         {function _pF_(b){return enqueue$0(res,b)}
          return iter$0(caml_call2(f,i,a),_pF_)});
      return res}
    function filter_map$11(t,f)
     {var res=caml_call1(create$15,0);
      iter$20
       (t,
        function(a)
         {var match=caml_call1(f,a);
          if(! match)return 0;
          var b=match[1];
          return enqueue$0(res,b)});
      return res}
    function filter_mapi$6(t,f)
     {var res=caml_call1(create$15,0);
      caml_call2
       (iteri$12,
        t,
        function(i,a)
         {var match=caml_call2(f,i,a);
          if(! match)return 0;
          var b=match[1];
          return enqueue$0(res,b)});
      return res}
    function filter$11(t,f)
     {var res=caml_call1(create$15,0);
      iter$20
       (t,
        function(a)
         {var _pE_=caml_call1(f,a);return _pE_?enqueue$0(res,a):_pE_});
      return res}
    function filteri$7(t,f)
     {var res=caml_call1(create$15,0);
      caml_call2
       (iteri$12,
        t,
        function(i,a)
         {var _pD_=caml_call2(f,i,a);return _pD_?enqueue$0(res,a):_pD_});
      return res}
    function map$36(t,f)
     {var res=caml_call1(create$15,0);
      iter$20(t,function(a){return enqueue$0(res,caml_call1(f,a))});
      return res}
    function mapi$10(t,f)
     {var res=caml_call1(create$15,0);
      caml_call2
       (iteri$12,t,function(i,a){return enqueue$0(res,caml_call2(f,i,a))});
      return res}
    function filter_inplace$0(q,f)
     {var q$0=filter$11(q,f);caml_call1(clear$2,q);return transfer$0(q$0,q)}
    function filteri_inplace$0(q,f)
     {var q$0=filteri$7(q,f);caml_call1(clear$2,q);return transfer$0(q$0,q)}
    function enqueue_all$0(t,list)
     {return iter$0(list,function(x){return enqueue$0(t,x)})}
    function of_list$10(list)
     {var t=caml_call1(create$15,0);
      iter$0(list,function(x){return enqueue$0(t,x)});
      return t}
    function of_array$7(array)
     {var t=caml_call1(create$15,0);
      iter(array,function(x){return enqueue$0(t,x)});
      return t}
    function init$8(len,f)
     {var t=caml_call1(create$15,0),_pB_=len - 1 | 0,_pA_=0;
      if(_pB_ >= 0)
       {var i=_pA_;
        for(;;)
         {enqueue$0(t,caml_call1(f,i));
          var _pC_=i + 1 | 0;
          if(_pB_ !== i){var i=_pC_;continue}
          break}}
      return t}
    function to_array$11(t)
     {var len=caml_call1(length$20,t);
      if(0 === len)return [0];
      var arr=caml_make_vect(len,caml_call1(peek_exn$0,t)),i=[0,0];
      iter$20
       (t,
        function(v)
         {var _pz_=i[1];
          caml_check_bound(arr,_pz_)[1 + _pz_] = v;
          return incr(i)});
      return arr}
    function t_of_sexp$32(a_of_sexp,sexp)
     {return of_list$10(caml_call2(t_of_sexp$10,a_of_sexp,sexp))}
    function sexp_of_t$59(sexp_of_a,t)
     {return caml_call2(sexp_of_t$10,sexp_of_a,caml_call1(to_list$12,t))}
    function t_sexp_grammar$31(grammar)
     {var _py_=t_sexp_grammar$12(grammar);
      return caml_call1(Sexplib0_Sexp_grammar[1],_py_)}
    function singleton$12(a)
     {var t=caml_call1(create$15,0);enqueue$0(t,a);return t}
    var
     Base_Linked_queue=
      [0,
       t_of_sexp$32,
       sexp_of_t$59,
       t_sexp_grammar$31,
       mem$12,
       length$20,
       is_empty$13,
       iter$20,
       fold$16,
       fold_result$9,
       fold_until$13,
       exists$14,
       for_all$14,
       count$13,
       sum$10,
       find$14,
       find_map$10,
       to_list$12,
       to_array$11,
       min_elt$14,
       max_elt$14,
       foldi$10,
       iteri$12,
       existsi$9,
       for_alli$9,
       counti$9,
       findi$6,
       find_mapi$6,
       singleton$12,
       of_list$10,
       of_array$7,
       init$8,
       enqueue$0,
       enqueue_all$0,
       dequeue$0,
       dequeue_exn$0,
       peek$0,
       peek_exn$0,
       clear$2,
       copy$6,
       map$36,
       mapi$10,
       concat_map$3,
       concat_mapi$3,
       filter_map$11,
       filter_mapi$6,
       filter$11,
       filteri$7,
       filter_inplace$0,
       filteri_inplace$0,
       create$15,
       transfer$0];
    caml_register_global(1118,Base_Linked_queue,"Base__Linked_queue");
    function func$10(x){return caml_call1(func$0,x)}
    var hashable$7=[0,func$10,Stdlib_Int64[15],sexp_of_t$7];
    function compare$60(_px_,_pw_){return caml_int64_compare(_px_,_pw_)}
    var
     to_string$18=Stdlib_Int64[14],
     of_string$17=caml_int64_of_string,
     include$70=_P_([0,compare$60,sexp_of_t$7]),
     _fv_=include$70[1],
     float_lower_bound$1=lower_bound_for_int(64),
     float_upper_bound$1=upper_bound_for_int(64),
     float_of_bits=caml_int64_float_of_bits,
     bits_of_float=caml_int64_bits_of_float,
     shift_right_logical$0=caml_int64_shift_right_unsigne,
     shift_right$1=caml_int64_shift_right,
     shift_left$0=caml_int64_shift_left,
     lnot$2=Stdlib_Int64[11],
     bit_xor$0=caml_int64_xor,
     bit_or$0=caml_int64_or,
     bit_and$0=caml_int64_and,
     min_value$4=Stdlib_Int64[10],
     max_value$4=Stdlib_Int64[9],
     abs$4=Stdlib_Int64[8],
     pred$3=Stdlib_Int64[7],
     succ$4=Stdlib_Int64[6],
     pow$1=Private$3[2],
     rem$1=caml_int64_mod,
     neg$3=caml_int64_neg,
     minus_one$1=Stdlib_Int64[3],
     one$1=Stdlib_Int64[2],
     zero$3=Stdlib_Int64[1],
     to_float$2=caml_int64_to_float,
     of_float_unchecked$1=caml_int64_of_float,
     num_bits$2=64;
    function of_float$1(f)
     {if
       (caml_call2(include$7[6],f,float_lower_bound$1)
        &&
        caml_call2(include$7[2],f,float_upper_bound$1))
       return caml_int64_of_float(f);
      return caml_call2(invalid_argf(_fw_),f + 0.,0)}
    function symbol$192(b,e){return caml_call2(pow$1,b,e)}
    function bswap16(x)
     {return caml_int64_shift_right_unsigne(caml_int64_bswap(x),48)}
    function bswap32(x)
     {return caml_int64_shift_right_unsigne(caml_int64_bswap(x),32)}
    function bswap48(x)
     {return caml_int64_shift_right_unsigne(caml_int64_bswap(x),16)}
    var
     include$71=_aY_([0,compare$60,sexp_of_t$7,zero$3]),
     is_positive$1=include$71[1],
     is_non_negative$1=include$71[2],
     is_negative$1=include$71[3],
     is_non_positive$1=include$71[4],
     sign$1=include$71[5];
    function invariant$19(param){return 0}
    function between$12(t,low,high)
     {var _pu_=caml_lessequal(low,t),_pv_=_pu_?caml_lessequal(t,high):_pu_;
      return _pv_}
    function clamp_unchecked$4(t,min,max)
     {return caml_lessthan(t,min)?min:caml_lessequal(t,max)?t:max}
    function clamp_exn$12(t,min,max)
     {if(caml_lessequal(min,max))return clamp_unchecked$4(t,min,max);
      throw [0,Assert_failure$0,_fx_]}
    function clamp$12(t,min,max)
     {if(! caml_greaterthan(min,max))return [0,clamp_unchecked$4(t,min,max)];
      var _pt_=[0,[0,cst_max$5,caml_call1(sexp_of_t$7,max)],0];
      return error_s
              (caml_call2
                (message,
                 cst_clamp_requires_min_max$5,
                 [0,[0,cst_min$5,caml_call1(sexp_of_t$7,min)],_pt_]))}
    function incr$2(r){r[1] = caml_int64_add(r[1],one$1);return 0}
    function decr$2(r){r[1] = caml_int64_sub(r[1],one$1);return 0}
    function of_int64_exn(_ps_){return _ps_}
    function to_int64(t){return t}
    var of_int_exn$0=caml_int64_of_int32,of_int32_exn=caml_int64_of_int32;
    function non_positive_argument$1(param)
     {return caml_call1(invalid_argf(_fy_),0)}
    function ceil_pow2$1(x)
     {if(caml_lessequal(x,Stdlib_Int64[1]))non_positive_argument$1(0);
      var
       x$0=caml_call1(Stdlib_Int64[7],x),
       x$1=caml_int64_or(x$0,caml_int64_shift_right_unsigne(x$0,1)),
       x$2=caml_int64_or(x$1,caml_int64_shift_right_unsigne(x$1,2)),
       x$3=caml_int64_or(x$2,caml_int64_shift_right_unsigne(x$2,4)),
       x$4=caml_int64_or(x$3,caml_int64_shift_right_unsigne(x$3,8)),
       x$5=caml_int64_or(x$4,caml_int64_shift_right_unsigne(x$4,16)),
       x$6=caml_int64_or(x$5,caml_int64_shift_right_unsigne(x$5,32));
      return caml_call1(Stdlib_Int64[6],x$6)}
    function floor_pow2$1(x)
     {if(caml_lessequal(x,Stdlib_Int64[1]))non_positive_argument$1(0);
      var
       x$0=caml_int64_or(x,caml_int64_shift_right_unsigne(x,1)),
       x$1=caml_int64_or(x$0,caml_int64_shift_right_unsigne(x$0,2)),
       x$2=caml_int64_or(x$1,caml_int64_shift_right_unsigne(x$1,4)),
       x$3=caml_int64_or(x$2,caml_int64_shift_right_unsigne(x$2,8)),
       x$4=caml_int64_or(x$3,caml_int64_shift_right_unsigne(x$3,16)),
       x$5=caml_int64_or(x$4,caml_int64_shift_right_unsigne(x$4,32));
      return caml_int64_sub(x$5,caml_int64_shift_right_unsigne(x$5,1))}
    function is_pow2$1(x)
     {if(caml_lessequal(x,Stdlib_Int64[1]))non_positive_argument$1(0);
      var _pr_=Stdlib_Int64[1];
      return caml_equal(caml_int64_and(x,caml_call1(Stdlib_Int64[7],x)),_pr_)}
    function floor_log2$1(i)
     {if(caml_lessequal(i,Stdlib_Int64[1]))
       raise_s
        (caml_call2
          (message,
           cst_Int64_floor_log2_got_inval,
           [0,[0,cst$32,caml_call1(sexp_of_t$7,i)],0]));
      return 63 - runtime.Base_int_math_int64_clz(i) | 0}
    function ceil_log2$1(i)
     {if(caml_lessequal(i,Stdlib_Int64[1]))
       raise_s
        (caml_call2
          (message,
           cst_Int64_ceil_log2_got_invali,
           [0,[0,cst$33,caml_call1(sexp_of_t$7,i)],0]));
      return caml_call2(Stdlib_Int64[17],i,Stdlib_Int64[2])
              ?0
              :64
               -
               runtime.Base_int_math_int64_clz(caml_call1(Stdlib_Int64[7],i))
               |
               0}
    var
     include$72=_cH_([0,to_string$18]),
     to_string_hum$3=include$72[1],
     sexp_of_int64=include$72[2];
    function hash$20(x){return caml_call1(func$0,x)}
    var symbol$193=caml_lessthan;
    function to_string$19(i){return caml_call2(sprintf,_fz_,i)}
    function of_string$18(s)
     {function _pp_(_pq_){return _pq_}
      return caml_call3(Stdlib_Scanf[4],s,_fA_,_pp_)}
    var
     include$73=
      _cG_
       ([0,
         compare$12,
         hash_fold_t$1,
         hash$20,
         to_string$19,
         of_string$18,
         zero$3,
         symbol$193,
         neg$3,
         module_name$13]),
     Hex$1=include$73[1],
     pp$15=_w_([0,module_name$14,to_string$18])[1],
     include$74=
      _c2_
       ([0,
         of_float$1,
         to_float$2,
         of_string$17,
         to_string$18,
         caml_int64_add,
         caml_int64_sub,
         caml_int64_mul,
         caml_int64_div,
         caml_int64_neg,
         caml_greaterequal,
         caml_lessequal,
         caml_equal,
         caml_greaterthan,
         caml_lessthan,
         caml_notequal,
         abs$4,
         caml_int64_neg,
         zero$3,
         of_int_exn$0,
         rem$1]),
     symbol$194=include$74[1],
     symbol$195=include$74[2],
     symbol$196=include$74[3],
     round$1=include$74[4],
     round_towards_zero$1=include$74[5],
     round_down$1=include$74[6],
     round_up$1=include$74[7],
     round_nearest$1=include$74[8],
     ascending$26=include$2[1],
     descending$26=include$2[2],
     max$32=include$2[3],
     min$32=include$2[4],
     _fB_=[0,symbol$192,lnot$2,abs$4,zero$3,symbol$194,symbol$195,symbol$196];
    function _fC_(_po_){return runtime.Base_int_math_int64_ctz(_po_)}
    function _fD_(_pn_){return runtime.Base_int_math_int64_clz(_pn_)}
    function compare_int64$0(_pm_,_pl_){return caml_int64_compare(_pm_,_pl_)}
    var
     equal_int64$1=caml_equal,
     Base_Int64=
      [0,
       t_sexp_grammar$6,
       of_float$1,
       to_float$2,
       of_int_exn$0,
       int64_to_int_exn,
       hash_fold_t$1,
       func$10,
       t_of_sexp$7,
       sexp_of_int64,
       of_string$17,
       to_string$18,
       equal_int64$1,
       compare_int64$0,
       min$32,
       max$32,
       ascending$26,
       descending$26,
       between$12,
       clamp_exn$12,
       clamp$12,
       _fv_,
       pp$15,
       hashable$7,
       is_positive$1,
       is_non_negative$1,
       is_negative$1,
       is_non_positive$1,
       sign$1,
       invariant$19,
       Hex$1,
       to_string_hum$3,
       one$1,
       minus_one$1,
       rem$1,
       round$1,
       round_towards_zero$1,
       round_down$1,
       round_up$1,
       round_nearest$1,
       succ$4,
       pred$3,
       pow$1,
       bit_and$0,
       bit_or$0,
       bit_xor$0,
       lnot$2,
       int64_popcount,
       shift_left$0,
       shift_right$1,
       decr$2,
       incr$2,
       of_int32_exn,
       int64_to_int32_exn,
       of_int64_exn,
       to_int64,
       nativeint_to_int64,
       to_nativeint_exn,
       of_float_unchecked$1,
       num_bits$2,
       max_value$4,
       min_value$4,
       shift_right_logical$0,
       ceil_pow2$1,
       floor_pow2$1,
       ceil_log2$1,
       floor_log2$1,
       is_pow2$1,
       _fD_,
       _fC_,
       _fB_,
       symbol$192,
       lnot$2,
       abs$4,
       zero$3,
       symbol$194,
       symbol$195,
       symbol$196,
       int64_to_int,
       int64_to_int32,
       nativeint_to_int64,
       to_nativeint,
       bits_of_float,
       float_of_bits,
       bswap16,
       bswap32,
       bswap48];
    caml_register_global(1119,Base_Int64,"Base__Int64");
    var
     include$75=_P_([0,compare$12,sexp_of_t$7]),
     comparator$18=include$75[1];
    function wrap_exn(x)
     {int64_fit_on_int63_exn(x);return caml_int64_mul(x,_fE_)}
    function wrap_modulo(x){return caml_int64_mul(x,_fG_)}
    function unwrap(x){return caml_int64_shift_right(x,1)}
    function m(x){return caml_int64_and(x,mask$0)}
    function invariant$20(t)
     {if(caml_equal(m(t),t))return 0;throw [0,Assert_failure$0,_fI_]}
    function symbol$197(x,y){return caml_int64_add(x,y)}
    function symbol$198(x,y){return caml_int64_sub(x,y)}
    function neg$4(x){return caml_int64_neg(x)}
    function abs$5(x){return caml_call1(Stdlib_Int64[8],x)}
    var one$2=wrap_exn(_fJ_);
    function succ$5(a){return caml_int64_add(a,one$2)}
    function pred$4(a){return caml_int64_sub(a,one$2)}
    var min_value$5=m(Stdlib_Int64[10]),max_value$5=m(Stdlib_Int64[9]);
    function lnot$3(x){return m(caml_call1(Stdlib_Int64[11],x))}
    var land$1=caml_int64_and,lxor$1=caml_int64_xor,lor$1=caml_int64_or;
    function lsl$1(x,i){return caml_int64_shift_left(x,i)}
    function asr$1(x,i){return m(caml_int64_shift_right(x,i))}
    function lsr$1(x,i){return m(caml_int64_shift_right_unsigne(x,i))}
    var _fK_=Private$3[3];
    function pow$2(a,b)
     {return caml_int64_mul
              (caml_call2
                (_fK_,caml_int64_shift_right(a,1),caml_int64_shift_right(b,1)),
               _fH_)}
    function symbol$199(a,b)
     {return caml_int64_mul(a,caml_int64_shift_right(b,1))}
    function symbol$200(a,b){return wrap_modulo(caml_int64_div(a,b))}
    function rem$2(a,b){return caml_int64_mod(a,b)}
    function popcount$1(x){return int64_popcount(x)}
    function to_int64$0(t){return caml_int64_shift_right(t,1)}
    function of_int64(t)
     {return int64_is_representable_as_int6(t)?[0,caml_int64_mul(t,_fF_)]:0}
    function of_int64_exn$0(t){return wrap_exn(t)}
    function of_int64_trunc(t){return wrap_modulo(t)}
    function t_of_sexp$33(x){return wrap_exn(caml_call1(t_of_sexp$7,x))}
    function sexp_of_t$60(x)
     {return caml_call1(sexp_of_t$7,caml_int64_shift_right(x,1))}
    function compare$61(x,y){return caml_call2(compare$12,x,y)}
    function is_pow2$2(x){return is_pow2$1(caml_int64_shift_right(x,1))}
    function clz$0(x){return runtime.Base_int_math_int64_clz(x)}
    function ctz$0(x)
     {return runtime.Base_int_math_int64_ctz(caml_int64_shift_right(x,1))}
    function floor_pow2$2(x)
     {return wrap_exn(floor_pow2$1(caml_int64_shift_right(x,1)))}
    function ceil_pow2$2(x)
     {return wrap_exn(floor_pow2$1(caml_int64_shift_right(x,1)))}
    function floor_log2$2(x){return floor_log2$1(caml_int64_shift_right(x,1))}
    function ceil_log2$2(x){return ceil_log2$1(caml_int64_shift_right(x,1))}
    function func$11(x){return caml_call1(Stdlib_MoreLabels[1][28],x)}
    var hashable$8=[0,func$11,compare$61,sexp_of_t$60];
    function invalid_str(x){return caml_call2(failwithf(_fL_),x,0)}
    function sign_and_signedness(x)
     {var len=caml_ml_string_length(x);
      if(0 < len)
       {var match=caml_string_get(x,0),switcher=match - 43 | 0,switch$0=0;
        if(2 < switcher >>> 0)
         switch$0 = 1;
        else
         switch(switcher)
          {case 0:var sign=4003188,pos=1;break;
           case 1:switch$0 = 1;break;
           default:var sign=3901488,pos=1}
        if(switch$0)var sign=4003188,pos=0}
      else
       var sign=4003188,pos=0;
      if((pos + 2 | 0) >= len)return [0,sign,1];
      var c1=caml_string_get(x,pos),c2=caml_string_get(x,pos + 1 | 0);
      return 48 === c1?9 < c2 - 48 >>> 0?[0,sign,0]:[0,sign,1]:[0,sign,1]}
    function to_string$20(x)
     {return caml_call1(Stdlib_Int64[14],caml_int64_shift_right(x,1))}
    function of_string$19(str)
     {try
       {var match=sign_and_signedness(str),signedness=match[2],sign=match[1];
        if(signedness)
         var _pj_=of_int64_exn$0(caml_int64_of_string(str));
        else
         {var
           pos_str=
            4003188 <= sign
             ?str
             :sub$8(str,1,caml_ml_string_length(str) - 1 | 0),
           int64=caml_int64_of_string(pos_str);
          if(caml_lessthan(int64,_fM_))invalid_str(str);
          var
           int63=wrap_modulo(int64),
           int63$0=4003188 <= sign?int63:caml_int64_neg(int63),
           _pj_=int63$0}
        return _pj_}
      catch(_pk_){return invalid_str(str)}}
    function bswap16$0(t)
     {return wrap_modulo(bswap16(caml_int64_shift_right(t,1)))}
    function bswap32$0(t)
     {return wrap_modulo(bswap32(caml_int64_shift_right(t,1)))}
    function bswap48$0(t)
     {return wrap_modulo(bswap48(caml_int64_shift_right(t,1)))}
    var
     float_lower_bound$2=lower_bound_for_int(63),
     float_upper_bound$2=upper_bound_for_int(63),
     minus_one$2=wrap_exn(Stdlib_Int64[3]),
     one$3=wrap_exn(Stdlib_Int64[2]),
     zero$4=wrap_exn(Stdlib_Int64[1]),
     num_bits$3=63;
    function to_float$3(x)
     {return caml_int64_to_float(caml_int64_shift_right(x,1))}
    function of_float_unchecked$2(x)
     {return wrap_modulo(caml_int64_of_float(x))}
    function of_float$2(t)
     {if
       (caml_call2(include$7[6],t,float_lower_bound$2)
        &&
        caml_call2(include$7[2],t,float_upper_bound$2))
       return wrap_modulo(caml_int64_of_float(t));
      return caml_call2(invalid_argf(_fN_),t + 0.,0)}
    var
     _fO_=_aY_([0,compare$61,sexp_of_t$60,zero$4]),
     is_positive$2=_fO_[1],
     is_non_negative$2=_fO_[2],
     is_negative$2=_fO_[3],
     is_non_positive$2=_fO_[4],
     sign$2=_fO_[5];
    function between$13(t,low,high)
     {var _ph_=caml_lessequal(low,t),_pi_=_ph_?caml_lessequal(t,high):_ph_;
      return _pi_}
    function clamp_unchecked$5(t,min,max)
     {return caml_lessthan(t,min)?min:caml_lessequal(t,max)?t:max}
    function clamp_exn$13(t,min,max)
     {if(caml_lessequal(min,max))return clamp_unchecked$5(t,min,max);
      throw [0,Assert_failure$0,_fP_]}
    function clamp$13(t,min,max)
     {if(! caml_greaterthan(min,max))return [0,clamp_unchecked$5(t,min,max)];
      var _pg_=[0,[0,cst_max$6,sexp_of_t$60(max)],0];
      return error_s
              (caml_call2
                (message,
                 cst_clamp_requires_min_max$6,
                 [0,[0,cst_min$6,sexp_of_t$60(min)],_pg_]))}
    function symbol$201(b,e){return pow$2(b,e)}
    function incr$3(r){r[1] = caml_int64_add(r[1],one$3);return 0}
    function decr$3(r){r[1] = caml_int64_sub(r[1],one$3);return 0}
    function of_int$5(x){return wrap_exn(caml_int64_of_int32(x))}
    function of_int_exn$1(x){return of_int$5(x)}
    function to_int$4(x){return int64_to_int(caml_int64_shift_right(x,1))}
    function to_int_exn$1(x)
     {return int64_to_int_exn(caml_int64_shift_right(x,1))}
    function to_int_trunc(x)
     {return caml_int64_to_int32(caml_int64_shift_right(x,1))}
    function of_int32(x){return wrap_exn(caml_int64_of_int32(x))}
    function of_int32_exn$0(x){return of_int32(x)}
    function to_int32(x){return int64_to_int32(caml_int64_shift_right(x,1))}
    function to_int32_exn(x)
     {return int64_to_int32_exn(caml_int64_shift_right(x,1))}
    function to_int32_trunc(x)
     {return caml_int64_to_int32(caml_int64_shift_right(x,1))}
    function of_nativeint$0(x){return of_int64(caml_int64_of_int32(x))}
    function of_nativeint_exn(x){return wrap_exn(caml_int64_of_int32(x))}
    function of_nativeint_trunc(x)
     {return of_int64_trunc(caml_int64_of_int32(x))}
    function to_nativeint$1(x)
     {return to_nativeint(caml_int64_shift_right(x,1))}
    function to_nativeint_exn$0(x)
     {return to_nativeint_exn(caml_int64_shift_right(x,1))}
    function to_nativeint_trunc(x)
     {return caml_int64_to_int32(caml_int64_shift_right(x,1))}
    var
     include$76=_cH_([0,to_string$20]),
     to_string_hum$4=include$76[1],
     sexp_of_t$61=include$76[2];
    function hash$21(x){return func$11(x)}
    var symbol$202=caml_lessthan;
    function to_string$21(i)
     {return caml_call2(sprintf,_fQ_,caml_int64_shift_right_unsigne(i,1))}
    function of_string$20(s)
     {return of_string$19(caml_call2(symbol$59,cst_0x$1,s))}
    var
     include$77=
      _cG_
       ([0,
         compare$61,
         hash_fold_t$1,
         hash$21,
         to_string$21,
         of_string$20,
         zero$4,
         symbol$202,
         neg$4,
         module_name$15]),
     Hex$2=include$77[1];
    function to_string$22(x){return to_string$20(x)}
    var
     pp$16=_w_([0,module_name$16,to_string$22])[1],
     symbol$203=caml_notequal,
     symbol$204=caml_lessthan,
     symbol$205=caml_greaterthan,
     symbol$206=caml_equal,
     symbol$207=caml_lessequal,
     symbol$208=caml_greaterequal,
     include$78=
      _c2_
       ([0,
         of_float$2,
         to_float$3,
         of_string$19,
         to_string$20,
         symbol$197,
         symbol$198,
         symbol$199,
         symbol$200,
         neg$4,
         symbol$208,
         symbol$207,
         symbol$206,
         symbol$205,
         symbol$204,
         symbol$203,
         abs$5,
         neg$4,
         zero$4,
         of_int_exn$1,
         rem$2]),
     symbol$209=include$78[1],
     symbol$210=include$78[2],
     symbol$211=include$78[3],
     round$2=include$78[4],
     round_towards_zero$2=include$78[5],
     round_down$2=include$78[6],
     round_up$2=include$78[7],
     round_nearest$2=include$78[8],
     Repr$0=[0],
     ascending$27=include$2[1],
     descending$27=include$2[2],
     max$33=include$2[3],
     min$33=include$2[4],
     _fS_=
      [0,
       symbol$197,
       symbol$198,
       symbol$199,
       symbol$200,
       neg$4,
       symbol$201,
       symbol$208,
       symbol$207,
       symbol$206,
       symbol$205,
       symbol$204,
       symbol$203,
       abs$5,
       neg$4,
       zero$4,
       symbol$209,
       symbol$210,
       symbol$211,
       land$1,
       lor$1,
       lxor$1,
       lnot$3,
       lsl$1,
       asr$1,
       lsr$1],
     repr=1,
     _fR_=[0,wrap_exn,unwrap];
    function _fT_(_pf_,_pe_){return caml_int64_compare(_pf_,_pe_)}
    var
     _fU_=caml_equal,
     _fV_=caml_notequal,
     _fW_=caml_lessthan,
     _fX_=caml_greaterthan,
     _fY_=caml_equal,
     _fZ_=caml_lessequal,
     _f0_=caml_greaterequal,
     Base_Int63_emul=
      [0,
       t_sexp_grammar$6,
       of_float$2,
       to_float$3,
       of_int_exn$1,
       to_int_exn$1,
       hash_fold_t$1,
       func$11,
       t_of_sexp$33,
       sexp_of_t$61,
       of_string$19,
       to_string$20,
       _f0_,
       _fZ_,
       _fY_,
       _fX_,
       _fW_,
       _fV_,
       _fU_,
       _fT_,
       min$33,
       max$33,
       ascending$27,
       descending$27,
       between$13,
       clamp_exn$13,
       clamp$13,
       comparator$18,
       pp$16,
       hashable$8,
       is_positive$2,
       is_non_negative$2,
       is_negative$2,
       is_non_positive$2,
       sign$2,
       invariant$20,
       Hex$2,
       to_string_hum$4,
       zero$4,
       one$3,
       minus_one$2,
       symbol$197,
       symbol$198,
       symbol$199,
       symbol$201,
       neg$4,
       neg$4,
       symbol$210,
       symbol$209,
       symbol$200,
       rem$2,
       symbol$211,
       land$1,
       lor$1,
       lxor$1,
       lnot$3,
       lsl$1,
       asr$1,
       round$2,
       round_towards_zero$2,
       round_down$2,
       round_up$2,
       round_nearest$2,
       abs$5,
       succ$5,
       pred$4,
       pow$2,
       land$1,
       lor$1,
       lxor$1,
       lnot$3,
       popcount$1,
       lsl$1,
       asr$1,
       decr$3,
       incr$3,
       of_int32_exn$0,
       to_int32_exn,
       of_int64_exn$0,
       to_int64$0,
       of_nativeint_exn,
       to_nativeint_exn$0,
       of_float_unchecked$2,
       num_bits$3,
       max_value$5,
       min_value$5,
       lsr$1,
       lsr$1,
       ceil_pow2$2,
       floor_pow2$2,
       ceil_log2$2,
       floor_log2$2,
       is_pow2$2,
       clz$0,
       ctz$0,
       _fS_,
       of_int$5,
       to_int$4,
       to_int_trunc,
       of_int32,
       to_int32,
       to_int32_trunc,
       of_int64,
       of_int64_trunc,
       of_nativeint$0,
       to_nativeint$1,
       of_nativeint_trunc,
       to_nativeint_trunc,
       bswap16$0,
       bswap32$0,
       bswap48$0,
       _fR_,
       Repr$0,
       repr];
    caml_register_global(1120,Base_Int63_emul,"Base__Int63_emul");
    function hash$22(x){return caml_call1(func$4,x)}
    var hashable$9=[0,hash$22,compare$8,sexp_of_t$1];
    function of_string$21(s)
     {return caml_string_notequal(s,cst_false)
              ?caml_string_notequal(s,cst_true)
                ?caml_call2(invalid_argf(_f1_),s,0)
                :1
              :0}
    var
     to_string$23=Caml$0[29],
     include$79=_P_([0,compare$8,sexp_of_t$1]),
     comparator$19=include$79[1],
     include$80=_w_([0,module_name$17,to_string$23]),
     pp$17=include$80[1];
    function invariant$21(param){return 0}
    function between$14(t,low,high)
     {var _pd_=caml_call2(include$4[2],low,t);
      return _pd_?caml_call2(include$4[2],t,high):_pd_}
    function clamp_unchecked$6(t,min,max)
     {return caml_call2(include$4[1],t,min)
              ?min
              :caml_call2(include$4[2],t,max)?t:max}
    function clamp_exn$14(t,min,max)
     {if(caml_call2(include$4[2],min,max))return clamp_unchecked$6(t,min,max);
      throw [0,Assert_failure$0,_f2_]}
    function clamp$14(t,min,max)
     {if(! caml_call2(include$4[5],min,max))
       return [0,clamp_unchecked$6(t,min,max)];
      var _pc_=[0,[0,cst_max$7,caml_call1(sexp_of_t$1,max)],0];
      return error_s
              (caml_call2
                (message,
                 cst_clamp_requires_min_max$7,
                 [0,[0,cst_min$7,caml_call1(sexp_of_t$1,min)],_pc_]))}
    function to_int$5(x){return x}
    function symbol$212(a,b){return a | b}
    function symbol$213(a,b){return a & b}
    var
     symbol$214=include$4[1],
     symbol$215=include$4[2],
     symbol$216=include$4[3],
     symbol$217=include$4[4],
     symbol$218=include$4[5],
     symbol$219=include$4[6],
     ascending$28=include$4[7],
     descending$28=include$4[8],
     compare_bool$0=include$4[9],
     equal_bool$1=include$4[10],
     max$34=include$4[11],
     min$34=include$4[12],
     Base_Bool=
      [0,
       all$20,
       t_sexp_grammar$0,
       hash_fold_t$5,
       hash$22,
       t_of_sexp$1,
       sexp_of_t$1,
       of_string$21,
       to_string$23,
       symbol$219,
       symbol$215,
       symbol$217,
       symbol$218,
       symbol$214,
       symbol$216,
       equal_bool$1,
       compare_bool$0,
       min$34,
       max$34,
       ascending$28,
       descending$28,
       between$14,
       clamp_exn$14,
       clamp$14,
       comparator$19,
       pp$17,
       hashable$9,
       invariant$21,
       to_int$5,
       [0,symbol$213,symbol$212]];
    caml_register_global(1121,Base_Bool,"Base__Bool");
    function func$12(x){return caml_call1(func$1,x)}
    var hashable$10=[0,func$12,Stdlib_Int32[15],sexp_of_t$6];
    function compare_int32$0(x,y){return caml_call2(Stdlib_Int32[15],x,y)}
    var
     to_string$24=Stdlib_Int32[14],
     of_string$22=caml_int_of_string,
     include$81=_P_([0,compare_int32$0,sexp_of_t$6]),
     _f3_=include$81[1],
     float_lower_bound$3=lower_bound_for_int(32),
     float_upper_bound$3=upper_bound_for_int(32),
     float_of_bits$0=runtime.caml_int32_float_of_bits,
     bits_of_float$0=runtime.caml_int32_bits_of_float,
     num_bits$4=32;
    function lsr$2(_pb_,_pa_){return _pb_ >>> _pa_ | 0}
    function asr$2(_o$_,_o__){return _o$_ >> _o__}
    function lsl$2(_o9_,_o8_){return _o9_ << _o8_}
    var lnot$4=Stdlib_Int32[11];
    function lxor$2(_o7_,_o6_){return _o7_ ^ _o6_}
    function lor$2(_o5_,_o4_){return _o5_ | _o4_}
    function land$2(_o3_,_o2_){return _o3_ & _o2_}
    var
     min_value$6=Stdlib_Int32[10],
     max_value$6=Stdlib_Int32[9],
     abs$6=Stdlib_Int32[8],
     pred$5=Stdlib_Int32[7],
     succ$6=Stdlib_Int32[6],
     rem$3=caml_mod;
    function neg$5(_o1_){return - _o1_ | 0}
    var
     minus_one$3=Stdlib_Int32[3],
     one$4=Stdlib_Int32[2],
     zero$5=Stdlib_Int32[1];
    function to_float$4(_o0_){return _o0_}
    function of_float_unchecked$3(_oZ_){return _oZ_ | 0}
    function of_float$3(f)
     {if
       (caml_call2(include$7[6],f,float_lower_bound$3)
        &&
        caml_call2(include$7[2],f,float_upper_bound$3))
       return f | 0;
      return caml_call2(invalid_argf(_f4_),f + 0.,0)}
    var
     include$82=_aY_([0,compare_int32$0,sexp_of_t$6,zero$5]),
     is_positive$3=include$82[1],
     is_non_negative$3=include$82[2],
     is_negative$3=include$82[3],
     is_non_positive$3=include$82[4],
     sign$3=include$82[5];
    function symbol$220(x,y){return caml_greaterequal(x,y)}
    function symbol$221(x,y){return caml_lessequal(x,y)}
    function symbol$222(x,y){return caml_equal(x,y)}
    function symbol$223(x,y){return caml_greaterthan(x,y)}
    function symbol$224(x,y){return caml_lessthan(x,y)}
    function symbol$225(x,y){return caml_notequal(x,y)}
    function descending$29(x,y){return compare_int32$0(y,x)}
    function min$35(x,y){return caml_lessthan(x,y)?x:y}
    function max$35(x,y){return caml_greaterthan(x,y)?x:y}
    var equal_int32$1=caml_equal;
    function between$15(t,low,high)
     {var _oY_=caml_lessequal(low,t);return _oY_?caml_lessequal(t,high):_oY_}
    function clamp_unchecked$7(t,min,max)
     {return caml_lessthan(t,min)?min:caml_lessequal(t,max)?t:max}
    function clamp_exn$15(t,min,max)
     {if(caml_lessequal(min,max))return clamp_unchecked$7(t,min,max);
      throw [0,Assert_failure$0,_f5_]}
    function clamp$15(t,min,max)
     {if(! caml_greaterthan(min,max))return [0,clamp_unchecked$7(t,min,max)];
      var _oX_=[0,[0,cst_max$8,caml_call1(sexp_of_t$6,max)],0];
      return error_s
              (caml_call2
                (message,
                 cst_clamp_requires_min_max$8,
                 [0,[0,cst_min$8,caml_call1(sexp_of_t$6,min)],_oX_]))}
    function invariant$22(param){return 0}
    var symbol$226=caml_div,symbol$227=caml_mul;
    function symbol$228(_oW_,_oV_){return _oW_ - _oV_ | 0}
    function symbol$229(_oU_,_oT_){return _oU_ + _oT_ | 0}
    function incr$4(r){r[1] = r[1] + one$4 | 0;return 0}
    function decr$4(r){r[1] = r[1] - one$4 | 0;return 0}
    function of_int32$0(t){return t}
    function to_int32$0(t){return t}
    function pow$3(b,e)
     {var _oR_=int32_to_int_exn(e),_oS_=int32_to_int_exn(b);
      return int_to_int32_exn(caml_call2(Private$3[1],_oS_,_oR_))}
    function symbol$230(b,e){return pow$3(b,e)}
    function bswap16$1(x){return caml_int32_bswap(x) >>> 16 | 0}
    function non_positive_argument$2(param)
     {return caml_call1(invalid_argf(_f6_),0)}
    function ceil_pow2$3(x)
     {if(caml_call2(Int32_replace_polymorphic_comp[2],x,Stdlib_Int32[1]))
       non_positive_argument$2(0);
      var
       x$0=caml_call1(Stdlib_Int32[7],x),
       x$1=x$0 | x$0 >>> 1 | 0,
       x$2=x$1 | x$1 >>> 2 | 0,
       x$3=x$2 | x$2 >>> 4 | 0,
       x$4=x$3 | x$3 >>> 8 | 0,
       x$5=x$4 | x$4 >>> 16 | 0;
      return caml_call1(Stdlib_Int32[6],x$5)}
    function floor_pow2$3(x)
     {if(caml_call2(Int32_replace_polymorphic_comp[2],x,Stdlib_Int32[1]))
       non_positive_argument$2(0);
      var
       x$0=x | x >>> 1 | 0,
       x$1=x$0 | x$0 >>> 2 | 0,
       x$2=x$1 | x$1 >>> 4 | 0,
       x$3=x$2 | x$2 >>> 8 | 0,
       x$4=x$3 | x$3 >>> 16 | 0;
      return x$4 - (x$4 >>> 1 | 0) | 0}
    function is_pow2$3(x)
     {if(caml_call2(Int32_replace_polymorphic_comp[2],x,Stdlib_Int32[1]))
       non_positive_argument$2(0);
      var _oP_=Stdlib_Int32[1],_oQ_=x & caml_call1(Stdlib_Int32[7],x);
      return caml_call2(Int32_replace_polymorphic_comp[4],_oQ_,_oP_)}
    function floor_log2$3(i)
     {if(caml_call2(Int32_replace_polymorphic_comp[2],i,Stdlib_Int32[1]))
       raise_s
        (caml_call2
          (message,
           cst_Int32_floor_log2_got_inval,
           [0,[0,cst$34,caml_call1(sexp_of_t$6,i)],0]));
      return 31 - runtime.Base_int_math_int32_clz(i) | 0}
    function ceil_log2$3(i)
     {if(caml_call2(Int32_replace_polymorphic_comp[2],i,Stdlib_Int32[1]))
       raise_s
        (caml_call2
          (message,
           cst_Int32_ceil_log2_got_invali,
           [0,[0,cst$35,caml_call1(sexp_of_t$6,i)],0]));
      return caml_call2(Stdlib_Int32[17],i,Stdlib_Int32[2])
              ?0
              :32
               -
               runtime.Base_int_math_int32_clz(caml_call1(Stdlib_Int32[7],i))
               |
               0}
    var
     include$83=_cH_([0,to_string$24]),
     to_string_hum$5=include$83[1],
     sexp_of_int32=include$83[2];
    function hash$23(x){return caml_call1(func$1,x)}
    function to_string$25(i){return caml_call2(sprintf,_f7_,i)}
    function of_string$23(s)
     {function _oN_(_oO_){return _oO_}
      return caml_call3(Stdlib_Scanf[4],s,_f8_,_oN_)}
    var
     include$84=
      _cG_
       ([0,
         compare$11,
         hash_fold_t$2,
         hash$23,
         to_string$25,
         of_string$23,
         zero$5,
         symbol$224,
         neg$5,
         module_name$18]),
     Hex$3=include$84[1],
     pp$18=_w_([0,module_name$19,to_string$24])[1],
     include$85=
      _c2_
       ([0,
         of_float$3,
         to_float$4,
         of_string$22,
         to_string$24,
         symbol$229,
         symbol$228,
         symbol$227,
         symbol$226,
         neg$5,
         symbol$220,
         symbol$221,
         symbol$222,
         symbol$223,
         symbol$224,
         symbol$225,
         abs$6,
         neg$5,
         zero$5,
         int_to_int32_exn,
         rem$3]),
     symbol$231=include$85[1],
     symbol$232=include$85[2],
     symbol$233=include$85[3],
     round$3=include$85[4],
     round_towards_zero$3=include$85[5],
     round_down$3=include$85[6],
     round_up$3=include$85[7],
     round_nearest$3=include$85[8],
     _f9_=caml_int32_bswap,
     _f__=
      [0,
       symbol$229,
       symbol$228,
       symbol$227,
       symbol$226,
       neg$5,
       symbol$230,
       symbol$220,
       symbol$221,
       symbol$222,
       symbol$223,
       symbol$224,
       symbol$225,
       abs$6,
       neg$5,
       zero$5,
       symbol$231,
       symbol$232,
       symbol$233,
       land$2,
       lor$2,
       lxor$2,
       lnot$4,
       lsl$2,
       asr$2,
       lsr$2];
    function _f$_(_oM_){return runtime.Base_int_math_int32_ctz(_oM_)}
    var
     Base_Int32=
      [0,
       t_sexp_grammar$5,
       of_float$3,
       to_float$4,
       int_to_int32_exn,
       int32_to_int_exn,
       hash_fold_t$2,
       func$12,
       t_of_sexp$6,
       sexp_of_int32,
       of_string$22,
       to_string$24,
       symbol$220,
       symbol$221,
       symbol$222,
       symbol$223,
       symbol$224,
       symbol$225,
       equal_int32$1,
       compare_int32$0,
       min$35,
       max$35,
       compare_int32$0,
       descending$29,
       between$15,
       clamp_exn$15,
       clamp$15,
       _f3_,
       pp$18,
       hashable$10,
       is_positive$3,
       is_non_negative$3,
       is_negative$3,
       is_non_positive$3,
       sign$3,
       invariant$22,
       Hex$3,
       to_string_hum$5,
       zero$5,
       one$4,
       minus_one$3,
       symbol$229,
       symbol$228,
       symbol$227,
       symbol$230,
       neg$5,
       neg$5,
       symbol$232,
       symbol$231,
       symbol$226,
       rem$3,
       symbol$233,
       land$2,
       lor$2,
       lxor$2,
       lnot$4,
       lsl$2,
       asr$2,
       round$3,
       round_towards_zero$3,
       round_down$3,
       round_up$3,
       round_nearest$3,
       abs$6,
       succ$6,
       pred$5,
       pow$3,
       land$2,
       lor$2,
       lxor$2,
       lnot$4,
       int32_popcount,
       lsl$2,
       asr$2,
       decr$4,
       incr$4,
       of_int32$0,
       to_int32$0,
       int64_to_int32_exn,
       int32_to_int64,
       nativeint_to_int32_exn,
       int32_to_nativeint,
       of_float_unchecked$3,
       num_bits$4,
       max_value$6,
       min_value$6,
       lsr$2,
       lsr$2,
       ceil_pow2$3,
       floor_pow2$3,
       ceil_log2$3,
       floor_log2$3,
       is_pow2$3,
       function(_oL_){return runtime.Base_int_math_int32_clz(_oL_)},
       _f$_,
       _f__,
       int_to_int32,
       int32_to_int,
       of_int32$0,
       to_int32$0,
       nativeint_to_int32,
       int32_to_nativeint,
       int64_to_int32,
       int_to_int32_trunc,
       int32_to_int_trunc,
       nativeint_to_int32_trunc,
       int64_to_int32_trunc,
       bits_of_float$0,
       float_of_bits$0,
       bswap16$1,
       _f9_];
    caml_register_global(1122,Base_Int32,"Base__Int32");
    var repr$0=word_size?0:1;
    function to_int$6(x){return [0,x]}
    function to_int_trunc$0(x){return x}
    function to_nativeint_trunc$0(x){return x}
    function to_nativeint$2(x){return [0,x]}
    var repr$1=0;
    function bswap32$1(t)
     {return caml_int64_to_int32(bswap32(caml_int64_of_int32(t)))}
    function bswap48$1(t)
     {return caml_int64_to_int32(bswap48(caml_int64_of_int32(t)))}
    if(repr$0)
     var
      impl=
       [0,
        t_sexp_grammar$6,
        of_float$2,
        to_float$3,
        of_int_exn$1,
        to_int_exn$1,
        hash_fold_t$1,
        func$11,
        t_of_sexp$33,
        sexp_of_t$61,
        of_string$19,
        to_string$20,
        _f0_,
        _fZ_,
        _fY_,
        _fX_,
        _fW_,
        _fV_,
        _fU_,
        _fT_,
        min$33,
        max$33,
        ascending$27,
        descending$27,
        between$13,
        clamp_exn$13,
        clamp$13,
        comparator$18,
        pp$16,
        hashable$8,
        is_positive$2,
        is_non_negative$2,
        is_negative$2,
        is_non_positive$2,
        sign$2,
        invariant$20,
        Hex$2,
        to_string_hum$4,
        zero$4,
        one$3,
        minus_one$2,
        symbol$197,
        symbol$198,
        symbol$199,
        symbol$201,
        neg$4,
        neg$4,
        symbol$210,
        symbol$209,
        symbol$200,
        rem$2,
        symbol$211,
        land$1,
        lor$1,
        lxor$1,
        lnot$3,
        lsl$1,
        asr$1,
        round$2,
        round_towards_zero$2,
        round_down$2,
        round_up$2,
        round_nearest$2,
        abs$5,
        succ$5,
        pred$4,
        pow$2,
        land$1,
        lor$1,
        lxor$1,
        lnot$3,
        popcount$1,
        lsl$1,
        asr$1,
        decr$3,
        incr$3,
        of_int32_exn$0,
        to_int32_exn,
        of_int64_exn$0,
        to_int64$0,
        of_nativeint_exn,
        to_nativeint_exn$0,
        num_bits$3,
        max_value$5,
        min_value$5,
        lsr$1,
        lsr$1,
        ceil_pow2$2,
        floor_pow2$2,
        ceil_log2$2,
        floor_log2$2,
        is_pow2$2,
        clz$0,
        ctz$0,
        _fS_,
        of_int$5,
        to_int$4,
        to_int_trunc,
        of_int32,
        to_int32,
        to_int32_trunc,
        of_int64,
        of_int64_trunc,
        of_nativeint$0,
        to_nativeint$1,
        of_nativeint_trunc,
        to_nativeint_trunc,
        of_float_unchecked$2,
        repr,
        bswap16$0,
        bswap32$0,
        bswap48$0];
    else
     var
      _kM_=runtime.caml_bswap16,
      _kN_=function(_oK_){return _oK_},
      _kO_=caml_int64_to_int32,
      _kP_=function(_oJ_){return _oJ_},
      _kQ_=function(_oI_,_oH_){return _oI_ >>> _oH_ | 0},
      _kR_=function(_oG_,_oF_){return _oG_ >> _oF_},
      _kS_=function(_oE_,_oD_){return _oE_ << _oD_},
      _kT_=O$0[2],
      _kU_=function(_oC_,_oB_){return _oC_ ^ _oB_},
      _kV_=function(_oA_,_oz_){return _oA_ | _oz_},
      _kW_=function(_oy_,_ox_){return _oy_ & _ox_},
      _kX_=O$0[7],
      _kY_=O$0[6],
      _kZ_=O$0[5],
      _k0_=O$0[4],
      _k1_=function(_ow_){return - _ow_ | 0},
      _k2_=O$0[3],
      _k3_=function(_ov_,_ou_){return _ov_ !== _ou_?1:0},
      _k4_=function(_ot_,_os_){return _ot_ < _os_?1:0},
      _k5_=function(_or_,_oq_){return _oq_ < _or_?1:0},
      _k6_=function(_op_,_oo_){return _op_ === _oo_?1:0},
      _k7_=function(_on_,_om_){return _on_ <= _om_?1:0},
      _k8_=function(_ol_,_ok_){return _ok_ <= _ol_?1:0},
      _k9_=O$0[1],
      _k__=function(_oj_){return - _oj_ | 0},
      _k$_=caml_div,
      _la_=caml_mul,
      _lb_=function(_oi_,_oh_){return _oi_ - _oh_ | 0},
      _lc_=
       [0,
        function(_og_,_of_){return _og_ + _of_ | 0},
        _lb_,
        _la_,
        _k$_,
        _k__,
        _k9_,
        _k8_,
        _k7_,
        _k6_,
        _k5_,
        _k4_,
        _k3_,
        _k2_,
        _k1_,
        _k0_,
        _kZ_,
        _kY_,
        _kX_,
        _kW_,
        _kV_,
        _kU_,
        _kT_,
        _kS_,
        _kR_,
        _kQ_],
      _ld_=function(_oe_,_od_){return _oe_ >>> _od_ | 0},
      _le_=function(_oc_,_ob_){return _oc_ >> _ob_},
      _lf_=function(_oa_,_n$_){return _oa_ << _n$_},
      _lg_=function(_n__,_n9_){return _n__ ^ _n9_},
      _lh_=function(_n8_,_n7_){return _n8_ | _n7_},
      _li_=function(_n6_,_n5_){return _n6_ & _n5_},
      _lj_=caml_div,
      _lk_=function(_n4_){return - _n4_ | 0},
      _ll_=function(_n3_){return - _n3_ | 0},
      _lm_=caml_mul,
      _ln_=function(_n2_,_n1_){return _n2_ - _n1_ | 0},
      _lo_=function(_n0_,_nZ_){return _n0_ + _nZ_ | 0},
      _lp_=function(_nY_,_nX_){return _nY_ !== _nX_?1:0},
      _lq_=function(_nW_,_nV_){return _nW_ < _nV_?1:0},
      _lr_=function(_nU_,_nT_){return _nT_ < _nU_?1:0},
      _ls_=function(_nS_,_nR_){return _nS_ === _nR_?1:0},
      _lt_=function(_nQ_,_nP_){return _nQ_ <= _nP_?1:0},
      impl=
       [0,
        t_sexp_grammar$3,
        to_int$3,
        of_int$2,
        of_int$3,
        to_int_exn,
        hash_fold_t$4,
        func$8,
        t_of_sexp$4,
        sexp_of_t$33,
        of_string$9,
        to_string,
        function(_nO_,_nN_){return _nN_ <= _nO_?1:0},
        _lt_,
        _ls_,
        _lr_,
        _lq_,
        _lp_,
        equal_int$1,
        compare_int$0,
        min$25,
        max$25,
        ascending$19,
        descending$19,
        between$5,
        clamp_exn$5,
        clamp$5,
        comparator$7,
        pp$11,
        hashable$3,
        is_positive,
        is_non_negative,
        is_negative,
        is_non_positive,
        sign,
        invariant$14,
        Hex,
        to_string_hum$1,
        zero,
        one,
        minus_one,
        _lo_,
        _ln_,
        _lm_,
        symbol$136,
        _ll_,
        _lk_,
        symbol$138,
        symbol$137,
        _lj_,
        rem,
        symbol$139,
        _li_,
        _lh_,
        _lg_,
        lnot$0,
        _lf_,
        _le_,
        round,
        round_towards_zero,
        round_down,
        round_up,
        round_nearest,
        abs$2,
        succ$1,
        pred$0,
        pow,
        bit_and,
        bit_or,
        bit_xor,
        bit_not,
        popcount$0,
        shift_left,
        shift_right$0,
        decr$0,
        incr$0,
        int32_to_int_exn,
        int_to_int32_exn,
        int64_to_int_exn,
        int_to_int64,
        nativeint_to_int_exn,
        int_to_nativeint,
        num_bits,
        max_value$2,
        min_value$2,
        _ld_,
        shift_right_logical,
        ceil_pow2,
        floor_pow2,
        ceil_log2,
        floor_log2,
        is_pow2,
        clz,
        ctz,
        _lc_,
        of_int$3,
        to_int$6,
        to_int_trunc$0,
        int32_to_int_exn,
        int_to_int32,
        _kP_,
        int64_to_int,
        _kO_,
        nativeint_to_int,
        to_nativeint$2,
        _kN_,
        to_nativeint_trunc$0,
        of_float_unchecked,
        repr$1,
        _kM_,
        bswap32$1,
        bswap48$1];
    var
     _gc_=impl[3],
     _ge_=impl[5],
     _gi_=impl[9],
     _gk_=impl[11],
     _gm_=impl[13],
     _gn_=impl[14],
     _go_=impl[15],
     _gp_=impl[16],
     _gq_=impl[17],
     _gr_=impl[18],
     _gD_=impl[30],
     _gL_=impl[38],
     _gM_=impl[39],
     _gO_=impl[41],
     _gP_=impl[42],
     _gQ_=impl[43],
     _gS_=impl[45],
     _gW_=impl[49],
     _g__=impl[63],
     _hc_=impl[67],
     _hd_=impl[68],
     _he_=impl[69],
     _hf_=impl[70],
     _hh_=impl[72],
     _hn_=impl[78],
     _ho_=impl[79],
     _hr_=impl[82],
     _ht_=impl[84],
     _hD_=impl[95],
     _hP_=impl[107],
     _ga_=impl[1],
     _gb_=impl[2],
     _gd_=impl[4],
     _gf_=impl[6],
     _gg_=impl[7],
     _gh_=impl[8],
     _gj_=impl[10],
     _gl_=impl[12],
     _gs_=impl[19],
     _gt_=impl[20],
     _gu_=impl[21],
     _gv_=impl[22],
     _gw_=impl[23],
     _gx_=impl[24],
     _gy_=impl[25],
     _gz_=impl[26],
     _gA_=impl[27],
     _gB_=impl[28],
     _gC_=impl[29],
     _gE_=impl[31],
     _gF_=impl[32],
     _gG_=impl[33],
     _gH_=impl[34],
     _gI_=impl[35],
     _gJ_=impl[36],
     _gK_=impl[37],
     _gN_=impl[40],
     _gR_=impl[44],
     _gT_=impl[46],
     _gU_=impl[47],
     _gV_=impl[48],
     _gX_=impl[50],
     _gY_=impl[51],
     _gZ_=impl[52],
     _g0_=impl[53],
     _g1_=impl[54],
     _g2_=impl[55],
     _g3_=impl[56],
     _g4_=impl[57],
     _g5_=impl[58],
     _g6_=impl[59],
     _g7_=impl[60],
     _g8_=impl[61],
     _g9_=impl[62],
     _g$_=impl[64],
     _ha_=impl[65],
     _hb_=impl[66],
     _hg_=impl[71],
     _hi_=impl[73],
     _hj_=impl[74],
     _hk_=impl[75],
     _hl_=impl[76],
     _hm_=impl[77],
     _hp_=impl[80],
     _hq_=impl[81],
     _hs_=impl[83],
     _hu_=impl[85],
     _hv_=impl[86],
     _hw_=impl[87],
     _hx_=impl[88],
     _hy_=impl[89],
     _hz_=impl[91],
     _hA_=impl[92],
     _hB_=impl[93],
     _hC_=impl[94],
     _hE_=impl[96],
     _hF_=impl[97],
     _hG_=impl[98],
     _hH_=impl[99],
     _hI_=impl[100],
     _hJ_=impl[101],
     _hK_=impl[102],
     _hL_=impl[103],
     _hM_=impl[104],
     _hN_=impl[105],
     _hO_=impl[106],
     _hQ_=impl[108],
     _hR_=impl[109],
     _hS_=impl[110],
     _hT_=impl[111];
    function symbol$234(t,u)
     {var sum=_gO_(t,u),_nK_=_he_(t,_hf_(sum));
      if(_gp_(_hd_(_he_(t,u),_nK_),_gL_))return sum;
      var
       _nL_=[0,[0,cst_sum,caml_call1(_gi_,sum)],0],
       _nM_=[0,[0,cst_u,caml_call1(_gi_,u)],_nL_];
      return raise_s
              (caml_call2
                (message,cst_overflow,[0,[0,cst_t,caml_call1(_gi_,t)],_nM_]))}
    function symbol$235(t,u)
     {var diff=_gP_(t,u),pos_diff=_go_(t,u);
      if(_gq_(t,u) && caml_call2(symbol$216,pos_diff,caml_call1(_gD_,diff)))
       {var
         _nI_=[0,[0,cst_diff,caml_call1(_gi_,diff)],0],
         _nJ_=[0,[0,cst_u$0,caml_call1(_gi_,u)],_nI_];
        return raise_s
                (caml_call2
                  (message,
                   cst_overflow$0,
                   [0,[0,cst_t$0,caml_call1(_gi_,t)],_nJ_]))}
      return diff}
    var negative_one=_hD_(-1);
    function div_would_overflow(t,u)
     {var _nH_=_gn_(t,_ht_);return _nH_?_gn_(u,negative_one):_nH_}
    function symbol$236(t,u)
     {var product=_gQ_(t,u);
      if(_gq_(u,_gL_))
       {var switch$0=0;
        if(! div_would_overflow(product,u) && ! _gq_(_gW_(product,u),t))
         switch$0 = 1;
        if(! switch$0)
         {var
           _nF_=[0,[0,cst_product,caml_call1(_gi_,product)],0],
           _nG_=[0,[0,cst_u$1,caml_call1(_gi_,u)],_nF_];
          return raise_s
                  (caml_call2
                    (message,
                     cst_overflow$1,
                     [0,[0,cst_t$1,caml_call1(_gi_,t)],_nG_]))}}
      return product}
    function symbol$237(t,u)
     {if(! div_would_overflow(t,u))return _gW_(t,u);
      var
       _nD_=[0,[0,cst_product$0,caml_call1(_gi_,_gW_(t,u))],0],
       _nE_=[0,[0,cst_u$2,caml_call1(_gi_,u)],_nD_];
      return raise_s
              (caml_call2
                (message,
                 cst_overflow$2,
                 [0,[0,cst_t$2,caml_call1(_gi_,t)],_nE_]))}
    function abs$7(t)
     {return _gn_(t,_ht_)?caml_call1(failwith$0,cst_abs_overflow):_g__(t)}
    function neg$6(t)
     {return _gn_(t,_ht_)?caml_call1(failwith$0,cst_neg_overflow):_gS_(t)}
    if(63 !== _hr_)throw [0,Assert_failure$0,_kL_];
    function random_of_int(opt,bound)
     {if(opt)var sth=opt[1],state=sth;else var state=_ag_[1];
      var _nC_=_ge_(bound);
      return _hD_(caml_call2(_ag_[6],state,_nC_))}
    function random_of_int64(opt,bound)
     {if(opt)var sth=opt[1],state=sth;else var state=_ag_[1];
      var _nB_=_ho_(bound);
      return _hn_(caml_call2(_ag_[9],state,_nB_))}
    var random_of_int$0=word_size?random_of_int:random_of_int64;
    function random_incl_of_int(opt,lo,hi)
     {if(opt)var sth=opt[1],state=sth;else var state=_ag_[1];
      var _nz_=_ge_(hi),_nA_=_ge_(lo);
      return _hD_(caml_call3(_ag_[11],state,_nA_,_nz_))}
    function random_incl_of_int64(opt,lo,hi)
     {if(opt)var sth=opt[1],state=sth;else var state=_ag_[1];
      var _nx_=_ho_(hi),_ny_=_ho_(lo);
      return _hn_(caml_call3(_ag_[14],state,_ny_,_nx_))}
    var random_incl=word_size?random_incl_of_int:random_incl_of_int64;
    function floor_log2$4(t)
     {if(word_size)return floor_log2(_ge_(t));
      if(_gm_(t,_gL_))
       raise_s
        (caml_call2
          (message,
           cst_Int_floor_log2_got_invalid$0,
           [0,[0,cst$36,caml_call1(_gi_,t)],0]));
      var floor_log2$0=[0,_hr_ - 2 | 0];
      for(;;)
       {if(! _gr_(_gL_,_hc_(t,_hh_(_gM_,floor_log2$0[1]))))
         return floor_log2$0[1];
        floor_log2$0[1] = floor_log2$0[1] - 1 | 0}}
    var
     Base_Int63=
      [0,
       _ga_,
       _gb_,
       _gc_,
       _gd_,
       _ge_,
       _gf_,
       _gg_,
       _gh_,
       _gi_,
       _gj_,
       _gk_,
       _gl_,
       _gm_,
       _gn_,
       _go_,
       _gp_,
       _gq_,
       _gr_,
       _gs_,
       _gt_,
       _gu_,
       _gv_,
       _gw_,
       _gx_,
       _gy_,
       _gz_,
       _gA_,
       _gB_,
       _gC_,
       _gD_,
       _gE_,
       _gF_,
       _gG_,
       _gH_,
       _gI_,
       _gJ_,
       _gK_,
       _gL_,
       _gM_,
       _gN_,
       _gO_,
       _gP_,
       _gQ_,
       _gR_,
       _gS_,
       _gT_,
       _gU_,
       _gV_,
       _gW_,
       _gX_,
       _gY_,
       _gZ_,
       _g0_,
       _g1_,
       _g2_,
       _g3_,
       _g4_,
       _g5_,
       _g6_,
       _g7_,
       _g8_,
       _g9_,
       _g__,
       _g$_,
       _ha_,
       _hb_,
       _hc_,
       _hd_,
       _he_,
       _hf_,
       _hg_,
       _hh_,
       _hi_,
       _hj_,
       _hk_,
       _hl_,
       _hm_,
       _hn_,
       _ho_,
       _hp_,
       _hq_,
       _hP_,
       _hr_,
       _hs_,
       _ht_,
       _hu_,
       _hv_,
       _hw_,
       _hx_,
       _hy_,
       _hz_,
       _hA_,
       _hB_,
       _hC_,
       [0,symbol$234,symbol$235,symbol$236,symbol$237,abs$7,neg$6],
       _hD_,
       _hE_,
       _hG_,
       _hH_,
       _hJ_,
       _hL_,
       _hM_,
       _hF_,
       _hI_,
       _hK_,
       _hN_,
       _hO_,
       _hR_,
       _hS_,
       _hT_,
       random_of_int$0,
       random_incl,
       floor_log2$4,
       [0,Repr$0,_hQ_]];
    caml_register_global(1123,Base_Int63,"Base__Int63");
    var
     Key=[0],
     Merge_into_action=[0],
     Base_Hashtbl_intf=[0,Key,Merge_into_action];
    caml_register_global(1124,Base_Hashtbl_intf,"Base__Hashtbl_intf");
    function max$36(x,y){return y < x?x:y}
    var empty$10=0;
    function is_empty$14(param){return typeof param === "number"?1:0}
    function height$1(param)
     {if(typeof param === "number")return 0;
      if(0 !== param[0])return 1;
      var height=param[4];
      return height}
    function invariant$23(t,compare)
     {function inv(param)
       {if(typeof param !== "number" && 0 === param[0])
         {var
           left=param[1],
           k=param[2],
           h=param[4],
           right=param[5],
           hr=height$1(right),
           hl=height$1(left);
          inv(left);
          inv(right);
          var switch$0=0;
          if(typeof left === "number")
           switch$0 = 1;
          else
           var left_key=0 === left[0]?left[2]:left[1];
          if(! switch$0 && 0 <= caml_call2(compare,left_key,k))
           throw [0,Assert_failure$0,_hU_];
          var switch$1=0;
          if(typeof right === "number")
           switch$1 = 1;
          else
           var right_key=0 === right[0]?right[2]:right[1];
          if(! switch$1 && 0 >= caml_call2(compare,right_key,k))
           throw [0,Assert_failure$0,_hV_];
          if(h !== (max$36(hl,hr) + 1 | 0))throw [0,Assert_failure$0,_hX_];
          if(2 < caml_call1(abs$0,hl - hr | 0))
           throw [0,Assert_failure$0,_hW_];
          return 0}
        return 0}
      return inv(t)}
    function update_height(x)
     {if(typeof x !== "number" && 0 === x[0])
       {var
         left=x[1],
         old_height=x[4],
         right=x[5],
         _nu_=height$1(right),
         new_height=max$36(height$1(left),_nu_) + 1 | 0,
         _nv_=new_height !== old_height?1:0,
         _nw_=_nv_?(x[4] = new_height,0):_nv_;
        return _nw_}
      throw [0,Assert_failure$0,_hY_]}
    function balance(tree)
     {if(typeof tree !== "number" && 0 === tree[0])
       {var left=tree[1],right=tree[5],hl=height$1(left),hr=height$1(right);
        if((hr + 2 | 0) < hl)
         {if(typeof left !== "number" && 0 === left[0])
           {var
             left_node_left=left[1],
             left_node_right=left[5],
             _ns_=height$1(left_node_right);
            if(_ns_ <= height$1(left_node_left))
             {tree[1] = left_node_right;
              left[5] = tree;
              update_height(tree);
              update_height(left);
              return left}
            if
             (typeof left_node_right !== "number" && 0 === left_node_right[0])
             {var lr_left=left_node_right[1],lr_right=left_node_right[5];
              left[5] = lr_left;
              tree[1] = lr_right;
              left_node_right[5] = tree;
              left_node_right[1] = left;
              update_height(left);
              update_height(tree);
              update_height(left_node_right);
              return left_node_right}
            throw [0,Assert_failure$0,_h0_]}
          throw [0,Assert_failure$0,_hZ_]}
        if((hl + 2 | 0) >= hr){update_height(tree);return tree}
        if(typeof right !== "number" && 0 === right[0])
         {var
           right_node_left=right[1],
           right_node_right=right[5],
           _nt_=height$1(right_node_left);
          if(_nt_ <= height$1(right_node_right))
           {tree[5] = right_node_left;
            right[1] = tree;
            update_height(tree);
            update_height(right);
            return right}
          if(typeof right_node_left !== "number" && 0 === right_node_left[0])
           {var rl_left=right_node_left[1],rl_right=right_node_left[5];
            right[1] = rl_right;
            tree[5] = rl_left;
            right_node_left[1] = tree;
            right_node_left[5] = right;
            update_height(right);
            update_height(tree);
            update_height(right_node_left);
            return right_node_left}
          throw [0,Assert_failure$0,_h2_]}
        throw [0,Assert_failure$0,_h1_]}
      return tree}
    function set_left(r,tree)
     {var tree$0=balance(tree);
      if(typeof r !== "number" && 0 === r[0])
       {var left=r[1];
        if(left !== tree$0)r[1] = tree$0;
        return update_height(r)}
      throw [0,Assert_failure$0,_h3_]}
    function set_right(r,tree)
     {var tree$0=balance(tree);
      if(typeof r !== "number" && 0 === r[0])
       {var right=r[5];
        if(right !== tree$0)r[5] = tree$0;
        return update_height(r)}
      throw [0,Assert_failure$0,_h4_]}
    function add$6(t,replace,added,compare,k,v)
     {if(typeof t === "number"){added[1] = 1;return [1,k,v]}
      if(0 !== t[0])
       {var k$1=t[1],c$0=caml_call2(compare,k$1,k);
        if(0 !== c$0)
         {added[1] = 1;return 0 <= c$0?[0,0,k,v,2,t]:[0,t,k,v,2,0]}
        added[1] = 0;
        if(replace)t[2] = v;
        return t}
      var left=t[1],k$0=t[2],right=t[5],c=caml_call2(compare,k,k$0);
      if(0 === c)
       {added[1] = 0;if(replace)t[3] = v}
      else
       if(0 <= c)
        set_right(t,add$6(right,replace,added,compare,k,v));
       else
        set_left(t,add$6(left,replace,added,compare,k,v));
      return t}
    function add$7(t,replace,compare,added,key,data)
     {var t$0=add$6(t,replace,added,compare,key,data);
      return added[1]?balance(t$0):t$0}
    function first$0(t)
     {var t$0=t;
      for(;;)
       {if(typeof t$0 === "number")return 0;
        if(0 === t$0[0])
         {var _nr_=t$0[1];
          if(typeof _nr_ !== "number"){var t$0=_nr_;continue}
          var v=t$0[3],k=t$0[2]}
        else
         var k$0=t$0[1],v$0=t$0[2],v=v$0,k=k$0;
        return [0,[0,k,v]]}}
    function last$2(t)
     {var t$0=t;
      for(;;)
       {if(typeof t$0 === "number")return 0;
        if(0 === t$0[0])
         {var _np_=t$0[2],_nq_=t$0[3];
          if(typeof t$0[5] !== "number"){var t$1=t$0[5],t$0=t$1;continue}
          var v=_nq_,k=_np_}
        else
         var k$0=t$0[1],v$0=t$0[2],v=v$0,k=k$0;
        return [0,[0,k,v]]}}
    function findi_and_call_impl
     (t,
      compare,
      k,
      arg1,
      arg2,
      call_if_found,
      call_if_not_found,
      if_found,
      if_not_found)
     {var t$0=t;
      for(;;)
       {if(typeof t$0 === "number")
         return caml_call4(call_if_not_found,if_not_found,k,arg1,arg2);
        if(0 !== t$0[0])
         {var k$1=t$0[1],v$0=t$0[2];
          return 0 === caml_call2(compare,k,k$1)
                  ?caml_call5(call_if_found,if_found,k$1,v$0,arg1,arg2)
                  :caml_call4(call_if_not_found,if_not_found,k,arg1,arg2)}
        var
         left=t$0[1],
         k$0=t$0[2],
         v=t$0[3],
         right=t$0[5],
         c=caml_call2(compare,k,k$0);
        if(0 === c)return caml_call5(call_if_found,if_found,k$0,v,arg1,arg2);
        var t$1=0 <= c?right:left,t$0=t$1}}
    function call_if_found(if_found,param,data,_no_,_nn_)
     {return caml_call1(if_found,data)}
    function call_if_not_found(if_not_found,key,param,_nm_)
     {return caml_call1(if_not_found,key)}
    function find_and_call(t,compare,k,if_found,if_not_found)
     {return findi_and_call_impl
              (t,
               compare,
               k,
               0,
               0,
               call_if_found,
               call_if_not_found,
               if_found,
               if_not_found)}
    function call_if_found$0(if_found,key,data,param,_nl_)
     {return caml_call2(if_found,key,data)}
    function call_if_not_found$0(if_not_found,key,param,_nk_)
     {return caml_call1(if_not_found,key)}
    function findi_and_call(t,compare,k,if_found,if_not_found)
     {return findi_and_call_impl
              (t,
               compare,
               k,
               0,
               0,
               call_if_found$0,
               call_if_not_found$0,
               if_found,
               if_not_found)}
    function call_if_found$1(if_found,param,data,arg,_nj_)
     {return caml_call2(if_found,data,arg)}
    function call_if_not_found$1(if_not_found,key,arg,param)
     {return caml_call2(if_not_found,key,arg)}
    function find_and_call1(t,compare,k,a,if_found,if_not_found)
     {return findi_and_call_impl
              (t,
               compare,
               k,
               a,
               0,
               call_if_found$1,
               call_if_not_found$1,
               if_found,
               if_not_found)}
    function call_if_found$2(if_found,key,data,arg,param)
     {return caml_call3(if_found,key,data,arg)}
    function call_if_not_found$2(if_not_found,key,arg,param)
     {return caml_call2(if_not_found,key,arg)}
    function findi_and_call1(t,compare,k,a,if_found,if_not_found)
     {return findi_and_call_impl
              (t,
               compare,
               k,
               a,
               0,
               call_if_found$2,
               call_if_not_found$2,
               if_found,
               if_not_found)}
    function call_if_found$3(if_found,param,data,arg1,arg2)
     {return caml_call3(if_found,data,arg1,arg2)}
    function call_if_not_found$3(if_not_found,key,arg1,arg2)
     {return caml_call3(if_not_found,key,arg1,arg2)}
    function find_and_call2(t,compare,k,a,b,if_found,if_not_found)
     {return findi_and_call_impl
              (t,
               compare,
               k,
               a,
               b,
               call_if_found$3,
               call_if_not_found$3,
               if_found,
               if_not_found)}
    function call_if_found$4(if_found,key,data,arg1,arg2)
     {return caml_call4(if_found,key,data,arg1,arg2)}
    function call_if_not_found$4(if_not_found,key,arg1,arg2)
     {return caml_call3(if_not_found,key,arg1,arg2)}
    function findi_and_call2(t,compare,k,a,b,if_found,if_not_found)
     {return findi_and_call_impl
              (t,
               compare,
               k,
               a,
               b,
               call_if_found$4,
               call_if_not_found$4,
               if_found,
               if_not_found)}
    function if_found(v){return [0,v]}
    function if_not_found$0(param){return 0}
    function find$15(t,compare,k)
     {return find_and_call(t,compare,k,if_found,if_not_found$0)}
    function if_found$0(param){return 1}
    function if_not_found$1(param){return 0}
    function mem$13(t,compare,k)
     {return find_and_call(t,compare,k,if_found$0,if_not_found$1)}
    function remove_min_elt$1(tree)
     {if(typeof tree === "number")throw [0,Assert_failure$0,_h5_];
      if(0 !== tree[0])return 0;
      var _ng_=tree[1];
      if(typeof _ng_ === "number"){var right=tree[5];return right}
      if(0 === _ng_[0]){set_left(tree,remove_min_elt$1(_ng_));return tree}
      var _nh_=tree[2],_ni_=tree[3];
      return typeof tree[5] === "number"?[1,_nh_,_ni_]:(set_left(tree,0),tree)}
    function remove$6(t,removed,compare,k$0)
     {if(typeof t === "number"){removed[1] = 0;return 0}
      if(0 !== t[0])
       {var k$2=t[1];
        return 0 === caml_call2(compare,k$0,k$2)
                ?(removed[1] = 1,0)
                :(removed[1] = 0,t)}
      var left=t[1],k$1=t[2],right=t[5],c=caml_call2(compare,k$0,k$1);
      if(0 !== c)
       return 0 <= c
               ?(set_right(t,remove$6(right,removed,compare,k$0)),t)
               :(set_left(t,remove$6(left,removed,compare,k$0)),t);
      removed[1] = 1;
      if(typeof left === "number")return right;
      if(typeof right === "number")return left;
      var tree=right;
      for(;;)
       {if(typeof tree === "number")
         var tree$0=0;
        else
         if(0 === tree[0])
          {var _ne_=tree[1];
           if(typeof _ne_ !== "number"){var tree=_ne_;continue}
           var tree$0=tree}
         else
          var tree$0=tree;
        if(typeof tree$0 === "number")throw [0,Assert_failure$0,_h6_];
        if(0 === tree$0[0])
         {set_right(tree$0,remove_min_elt$1(right));
          set_left(tree$0,left);
          return tree$0}
        var
         k=tree$0[1],
         v=tree$0[2],
         t2=balance(remove_min_elt$1(right)),
         _nf_=height$1(t2);
        return [0,left,k,v,max$36(height$1(left),_nf_) + 1 | 0,t2]}}
    function remove$7(t,removed,compare,k)
     {return balance(remove$6(t,removed,compare,k))}
    function fold$17(t,init,f)
     {var t$0=t,init$0=init;
      for(;;)
       {if(typeof t$0 === "number")return init$0;
        if(0 !== t$0[0])
         {var key$1=t$0[1],data$1=t$0[2];
          return caml_call3(f,key$1,data$1,init$0)}
        var _m4_=t$0[1],switch$0=0;
        if(typeof _m4_ === "number")
         {var _m7_=t$0[5],_m5_=t$0[2],_m6_=t$0[3];
          if(typeof _m7_ !== "number" && 0 !== _m7_[0])
           {var rkey=_m7_[1],rdata=_m7_[2];
            return caml_call3(f,rkey,rdata,caml_call3(f,_m5_,_m6_,init$0))}}
        else
         if(0 === _m4_[0])
          {var _m__=t$0[5],_m8_=t$0[2],_m9_=t$0[3];
           if(typeof _m__ !== "number" && 0 !== _m__[0])
            {var rkey$0=_m__[1],rdata$0=_m__[2];
             return caml_call3
                     (f,
                      rkey$0,
                      rdata$0,
                      caml_call3(f,_m8_,_m9_,fold$17(_m4_,init$0,f)))}
           switch$0 = 1}
         else
          {var _m$_=_m4_[1],_na_=_m4_[2],_nb_=t$0[2],_nc_=t$0[3],_nd_=t$0[5];
           if(typeof _nd_ === "number")
            return caml_call3(f,_nb_,_nc_,caml_call3(f,_m$_,_na_,init$0));
           if(0 !== _nd_[0])
            {var rkey$1=_nd_[1],rdata$1=_nd_[2];
             return caml_call3
                     (f,
                      rkey$1,
                      rdata$1,
                      caml_call3(f,_nb_,_nc_,caml_call3(f,_m$_,_na_,init$0)))}
           switch$0 = 1}
        if(switch$0 && typeof _m4_ !== "number" && 1 === _m4_[0])
         {var
           lkey=_m4_[1],
           ldata=_m4_[2],
           key$0=t$0[2],
           data$0=t$0[3],
           right$0=t$0[5],
           init$2=caml_call3(f,key$0,data$0,caml_call3(f,lkey,ldata,init$0)),
           t$0=right$0,
           init$0=init$2;
          continue}
        var
         key=t$0[2],
         data=t$0[3],
         right=t$0[5],
         init$1=caml_call3(f,key,data,fold$17(_m4_,init$0,f)),
         t$0=right,
         init$0=init$1}}
    function iter$22(t,f)
     {var t$0=t;
      for(;;)
       {if(typeof t$0 === "number")return 0;
        if(0 === t$0[0])
         {var left=t$0[1],key=t$0[2],data=t$0[3],right=t$0[5];
          iter$22(left,f);
          caml_call2(f,key,data);
          var t$0=right;
          continue}
        var key$0=t$0[1],data$0=t$0[2];
        return caml_call2(f,key$0,data$0)}}
    function mapi_inplace(t,f)
     {var t$0=t;
      for(;;)
       {if(typeof t$0 === "number")return 0;
        if(0 === t$0[0])
         {var left=t$0[1],key=t$0[2],value=t$0[3],right=t$0[5];
          mapi_inplace(left,f);
          t$0[3] = caml_call2(f,key,value);
          var t$0=right;
          continue}
        var key$0=t$0[1],value$0=t$0[2];
        t$0[2] = caml_call2(f,key$0,value$0);
        return 0}}
    function choose_exn$2(param)
     {if(typeof param === "number")
       return raise_s(caml_call2(message,cst_Avltree_choose_exn_of_empt,0));
      if(0 === param[0])
       var value=param[3],key=param[2];
      else
       var key$0=param[1],value$0=param[2],value=value$0,key=key$0;
      return [0,key,value]}
    var
     Base_Avltree=
      [0,
       empty$10,
       is_empty$14,
       invariant$23,
       add$7,
       first$0,
       last$2,
       find$15,
       find_and_call,
       find_and_call1,
       find_and_call2,
       findi_and_call,
       findi_and_call1,
       findi_and_call2,
       mem$13,
       remove$7,
       fold$17,
       iter$22,
       mapi_inplace,
       choose_exn$2];
    caml_register_global(1125,Base_Avltree,"Base__Avltree");
    function sexp_of_key(t){return t[5][3]}
    function compare_key$0(t){return t[5][2]}
    function ensure_mutation_allowed(t)
     {var _m3_=1 - t[6];
      return _m3_?caml_call1(failwith$0,cst_Hashtbl_mutation_not_allow):_m3_}
    function without_mutating(t,f)
     {if(! t[6])return caml_call1(f,0);
      t[6] = 0;
      try
       {var x=caml_call1(f,0)}
      catch(exn){exn = caml_wrap_exception(exn);t[6] = 1;throw exn}
      t[6] = 1;
      return x}
    var max_table_length=floor_pow2(max_length$0);
    function create$16(opt,_m2_,hashable,param)
     {if(opt)var sth=opt[1],growth_allowed=sth;else var growth_allowed=1;
      if(_m2_)var sth$0=_m2_[1],size=sth$0;else var size=0;
      var
       size$0=caml_call2(min$25,caml_call2(max$25,1,size),max_table_length),
       size$1=ceil_pow2(size$0);
      return [0,caml_make_vect(size$1,0),0,[0,0],growth_allowed,hashable,1]}
    function slot(t,key)
     {var hash=caml_call1(t[5][1],key);
      return hash & (t[1].length - 1 - 1 | 0)}
    function add_worker(t,replace,key,data)
     {var i=slot(t,key),root=caml_check_bound(t[1],i)[1 + i],added=t[3];
      added[1] = 0;
      var new_root=add$7(root,replace,compare_key$0(t),added,key,data);
      if(added[1])t[2] = t[2] + 1 | 0;
      var
       _m0_=1 - (new_root === root?1:0),
       _m1_=_m0_?(caml_check_bound(t[1],i)[1 + i] = new_root,0):_m0_;
      return _m1_}
    function maybe_resize_table(t)
     {var
       len=t[1].length - 1,
       should_grow=len < t[2]?1:0,
       _mT_=should_grow?t[4]:should_grow;
      if(_mT_)
       {var
         new_array_length=caml_call2(min$25,len * 2 | 0,max_table_length),
         _mU_=len < new_array_length?1:0;
        if(_mU_)
         {var new_table=caml_make_vect(new_array_length,0),old_table=t[1];
          t[1] = new_table;
          t[2] = 0;
          var
           f=function(key,data){return add_worker(t,1,key,data)},
           _mW_=old_table.length - 1 - 1 | 0,
           _mV_=0;
          if(_mW_ >= 0)
           {var i=_mV_;
            for(;;)
             {iter$22(caml_check_bound(old_table,i)[1 + i],f);
              var _mZ_=i + 1 | 0;
              if(_mW_ !== i){var i=_mZ_;continue}
              break}}
          var _mX_=0}
        else
         var _mX_=_mU_;
        var _mY_=_mX_}
      else
       var _mY_=_mT_;
      return _mY_}
    function set$9(t,key,data)
     {ensure_mutation_allowed(t);
      add_worker(t,1,key,data);
      return maybe_resize_table(t)}
    function add$8(t,key,data)
     {ensure_mutation_allowed(t);
      add_worker(t,0,key,data);
      return t[3][1]?(maybe_resize_table(t),17724):-1024851605}
    function add_exn$3(t,key,data)
     {var match=add$8(t,key,data);
      if(17724 <= match)return 0;
      var
       sexp_of_key$0=sexp_of_key(t),
       error=create$2(0,0,cst_Hashtbl_add_exn_got_key_al,key,sexp_of_key$0);
      return raise(error)}
    function clear$3(t)
     {ensure_mutation_allowed(t);
      var _mR_=t[1].length - 1 - 1 | 0,_mQ_=0;
      if(_mR_ >= 0)
       {var i=_mQ_;
        for(;;)
         {caml_check_bound(t[1],i)[1 + i] = empty$10;
          var _mS_=i + 1 | 0;
          if(_mR_ !== i){var i=_mS_;continue}
          break}}
      t[2] = 0;
      return 0}
    function find_and_call$0(t,key,if_found,if_not_found)
     {var _mP_=slot(t,key),tree=caml_check_bound(t[1],_mP_)[1 + _mP_];
      if(typeof tree === "number")return caml_call1(if_not_found,key);
      if(0 === tree[0])
       return find_and_call(tree,compare_key$0(t),key,if_found,if_not_found);
      var k=tree[1],v=tree[2];
      return 0 === caml_call2(compare_key$0(t),k,key)
              ?caml_call1(if_found,v)
              :caml_call1(if_not_found,key)}
    function find_and_call1$0(t,key,a,if_found,if_not_found)
     {var _mO_=slot(t,key),tree=caml_check_bound(t[1],_mO_)[1 + _mO_];
      if(typeof tree === "number")return caml_call2(if_not_found,key,a);
      if(0 === tree[0])
       return find_and_call1
               (tree,compare_key$0(t),key,a,if_found,if_not_found);
      var k=tree[1],v=tree[2];
      return 0 === caml_call2(compare_key$0(t),k,key)
              ?caml_call2(if_found,v,a)
              :caml_call2(if_not_found,key,a)}
    function find_and_call2$0(t,key,a,b,if_found,if_not_found)
     {var _mN_=slot(t,key),tree=caml_check_bound(t[1],_mN_)[1 + _mN_];
      if(typeof tree === "number")return caml_call3(if_not_found,key,a,b);
      if(0 === tree[0])
       return find_and_call2
               (tree,compare_key$0(t),key,a,b,if_found,if_not_found);
      var k=tree[1],v=tree[2];
      return 0 === caml_call2(compare_key$0(t),k,key)
              ?caml_call3(if_found,v,a,b)
              :caml_call3(if_not_found,key,a,b)}
    function findi_and_call$0(t,key,if_found,if_not_found)
     {var _mM_=slot(t,key),tree=caml_check_bound(t[1],_mM_)[1 + _mM_];
      if(typeof tree === "number")return caml_call1(if_not_found,key);
      if(0 === tree[0])
       return findi_and_call(tree,compare_key$0(t),key,if_found,if_not_found);
      var k=tree[1],v=tree[2];
      return 0 === caml_call2(compare_key$0(t),k,key)
              ?caml_call2(if_found,k,v)
              :caml_call1(if_not_found,key)}
    function findi_and_call1$0(t,key,a,if_found,if_not_found)
     {var _mL_=slot(t,key),tree=caml_check_bound(t[1],_mL_)[1 + _mL_];
      if(typeof tree === "number")return caml_call2(if_not_found,key,a);
      if(0 === tree[0])
       return findi_and_call1
               (tree,compare_key$0(t),key,a,if_found,if_not_found);
      var k=tree[1],v=tree[2];
      return 0 === caml_call2(compare_key$0(t),k,key)
              ?caml_call3(if_found,k,v,a)
              :caml_call2(if_not_found,key,a)}
    function findi_and_call2$0(t,key,a,b,if_found,if_not_found)
     {var _mK_=slot(t,key),tree=caml_check_bound(t[1],_mK_)[1 + _mK_];
      if(typeof tree === "number")return caml_call3(if_not_found,key,a,b);
      if(0 === tree[0])
       return findi_and_call2
               (tree,compare_key$0(t),key,a,b,if_found,if_not_found);
      var k=tree[1],v=tree[2];
      return 0 === caml_call2(compare_key$0(t),k,key)
              ?caml_call4(if_found,k,v,a,b)
              :caml_call3(if_not_found,key,a,b)}
    function if_found$1(v){return [0,v]}
    function if_not_found$2(param){return 0}
    function find$16(t,key)
     {return find_and_call$0(t,key,if_found$1,if_not_found$2)}
    function mem$14(t,key)
     {var _mJ_=slot(t,key),tree=caml_check_bound(t[1],_mJ_)[1 + _mJ_];
      if(typeof tree === "number")return 0;
      if(0 === tree[0])return mem$13(tree,compare_key$0(t),key);
      var k=tree[1];
      return 0 === caml_call2(compare_key$0(t),k,key)?1:0}
    function remove$8(t,key)
     {ensure_mutation_allowed(t);
      var
       i=slot(t,key),
       root=caml_check_bound(t[1],i)[1 + i],
       added_or_removed=t[3];
      added_or_removed[1] = 0;
      var new_root=remove$7(root,added_or_removed,compare_key$0(t),key);
      if(1 - (root === new_root?1:0))
       caml_check_bound(t[1],i)[1 + i] = new_root;
      var _mH_=added_or_removed[1],_mI_=_mH_?(t[2] = t[2] - 1 | 0,0):_mH_;
      return _mI_}
    function length$22(t){return t[2]}
    function is_empty$15(t){return 0 === t[2]?1:0}
    function fold$18(t,init,f)
     {if(0 === t[2])return init;
      var n=t[1].length - 1,acc=[0,init],m=t[6];
      try
       {t[6] = 0;
        var _mF_=n - 1 | 0,_mE_=0;
        if(_mF_ >= 0)
         {var i=_mE_;
          for(;;)
           {var bucket=t[1][1 + i];
            if(typeof bucket !== "number")
             if(0 === bucket[0])
              acc[1] = fold$17(bucket,acc[1],f);
             else
              {var key=bucket[1],data=bucket[2];
               acc[1] = caml_call3(f,key,data,acc[1])}
            var _mG_=i + 1 | 0;
            if(_mF_ !== i){var i=_mG_;continue}
            break}}}
      catch(exn){exn = caml_wrap_exception(exn);t[6] = m;throw exn}
      t[6] = m;
      return acc[1]}
    function iteri$13(t,f)
     {if(0 === t[2])return 0;
      var n=t[1].length - 1,m=t[6];
      try
       {t[6] = 0;
        var _mC_=n - 1 | 0,_mB_=0;
        if(_mC_ >= 0)
         {var i=_mB_;
          for(;;)
           {var bucket=t[1][1 + i];
            if(typeof bucket !== "number")
             if(0 === bucket[0])
              iter$22(bucket,f);
             else
              {var key=bucket[1],data=bucket[2];caml_call2(f,key,data)}
            var _mD_=i + 1 | 0;
            if(_mC_ !== i){var i=_mD_;continue}
            break}}}
      catch(exn){exn = caml_wrap_exception(exn);t[6] = m;throw exn}
      t[6] = m;
      return 0}
    function iter$23(t,f)
     {return iteri$13(t,function(param,data){return caml_call1(f,data)})}
    function iter_keys$2(t,f)
     {return iteri$13(t,function(key,param){return caml_call1(f,key)})}
    function choose_nonempty(table,i)
     {var i$0=i;
      for(;;)
       {var avltree=caml_check_bound(table,i$0)[1 + i$0];
        if(! is_empty$14(avltree))return choose_exn$2(avltree);
        var i$1=i$0 + 1 | 0,i$0=i$1}}
    function choose_exn$3(t)
     {if(0 === t[2])
       raise_s(caml_call2(message,cst_Hashtbl_choose_exn_of_empt,0));
      return choose_nonempty(t[1],0)}
    function choose$2(t){return is_empty$15(t)?0:[0,choose_nonempty(t[1],0)]}
    function invariant$24(invariant_key,invariant_data,t)
     {var _my_=t[1].length - 1 - 1 | 0,_mx_=0;
      if(_my_ >= 0)
       {var i=_mx_;
        for(;;)
         {var _mz_=compare_key$0(t);
          invariant$23(caml_check_bound(t[1],i)[1 + i],_mz_);
          var _mA_=i + 1 | 0;
          if(_my_ !== i){var i=_mA_;continue}
          break}}
      var
       real_len=
        fold$18
         (t,
          0,
          function(key,data,i)
           {caml_call1(invariant_key,key);
            caml_call1(invariant_data,data);
            return i + 1 | 0});
      if(real_len === t[2])return 0;
      throw [0,Assert_failure$0,_h7_]}
    function if_found$2(v,param){return v}
    function if_not_found$3(k,t)
     {throw [0,Not_found_s,[1,[0,_h8_,[0,caml_call1(t[5][3],k),0]]]]}
    function find_exn$9(t,key)
     {return find_and_call1$0(t,key,t,if_found$2,if_not_found$3)}
    function existsi$10(t,f)
     {return with_return
              (function(r)
                {iteri$13
                  (t,
                   function(key,data)
                    {var _mw_=caml_call2(f,key,data);
                     return _mw_?caml_call1(r,1):_mw_});
                 return 0})}
    function exists$15(t,f)
     {return existsi$10(t,function(param,data){return caml_call1(f,data)})}
    function for_alli$10(t,f)
     {return 1
             -
             existsi$10
              (t,function(key,data){return 1 - caml_call2(f,key,data)})}
    function for_all$15(t,f)
     {return 1
             -
             existsi$10(t,function(param,data){return 1 - caml_call1(f,data)})}
    function counti$10(t,f)
     {return fold$18
              (t,
               0,
               function(key,data,acc)
                {return caml_call2(f,key,data)?acc + 1 | 0:acc})}
    function count$14(t,f)
     {return fold$18
              (t,
               0,
               function(param,data,acc)
                {return caml_call1(f,data)?acc + 1 | 0:acc})}
    function mapi$11(t,f)
     {var new_t=create$16([0,t[4]],[0,t[2]],t[5],0);
      iteri$13
       (t,function(key,data){return set$9(new_t,key,caml_call2(f,key,data))});
      return new_t}
    function map$37(t,f)
     {return mapi$11(t,function(param,data){return caml_call1(f,data)})}
    function copy$7(t){return map$37(t,function(_mv_){return _mv_})}
    function filter_mapi$7(t,f)
     {var new_t=create$16([0,t[4]],[0,t[2]],t[5],0);
      iteri$13
       (t,
        function(key,data)
         {var match=caml_call2(f,key,data);
          if(! match)return 0;
          var new_data=match[1];
          return set$9(new_t,key,new_data)});
      return new_t}
    function filter_map$12(t,f)
     {return filter_mapi$7(t,function(param,data){return caml_call1(f,data)})}
    function filteri$8(t,f)
     {return filter_mapi$7
              (t,function(key,data){return caml_call2(f,key,data)?[0,data]:0})}
    function filter$12(t,f)
     {return filteri$8(t,function(param,data){return caml_call1(f,data)})}
    function filter_keys$2(t,f)
     {return filteri$8(t,function(key,param){return caml_call1(f,key)})}
    function partition_mapi$2(t,f)
     {var
       t0=create$16([0,t[4]],[0,t[2]],t[5],0),
       t1=create$16([0,t[4]],[0,t[2]],t[5],0);
      iteri$13
       (t,
        function(key,data)
         {var match=caml_call2(f,key,data);
          if(0 === match[0])
           {var new_data=match[1];return set$9(t0,key,new_data)}
          var new_data$0=match[1];
          return set$9(t1,key,new_data$0)});
      return [0,t0,t1]}
    function partition_map$3(t,f)
     {return partition_mapi$2
              (t,function(param,data){return caml_call1(f,data)})}
    function partitioni_tf$3(t,f)
     {return partition_mapi$2
              (t,
               function(key,data)
                {return caml_call2(f,key,data)?[0,data]:[1,data]})}
    function partition_tf$7(t,f)
     {return partitioni_tf$3
              (t,function(param,data){return caml_call1(f,data)})}
    function find_or_add(t,id,default$0)
     {function _mt_(key,t,default$0)
       {var default$1=caml_call1(default$0,0);
        set$9(t,key,default$1);
        return default$1}
      return find_and_call2$0
              (t,id,t,default$0,function(data,param,_mu_){return data},_mt_)}
    function findi_or_add(t,id,default$0)
     {function _mr_(key,t,default$0)
       {var default$1=caml_call1(default$0,key);
        set$9(t,key,default$1);
        return default$1}
      return find_and_call2$0
              (t,id,t,default$0,function(data,param,_ms_){return data},_mr_)}
    function find_and_remove(t,id)
     {var result=find$16(t,id);
      if(is_some(result))remove$8(t,id);
      return result}
    function change$2(t,id,f)
     {var match=caml_call1(f,find$16(t,id));
      if(! match)return remove$8(t,id);
      var data=match[1];
      return set$9(t,id,data)}
    function update_and_return(t,id,f)
     {var data=caml_call1(f,find$16(t,id));set$9(t,id,data);return data}
    function update$2(t,id,f){update_and_return(t,id,f);return 0}
    function incr_by(remove_if_zero,t,key,by)
     {return remove_if_zero
              ?change$2
                (t,
                 key,
                 function(opt)
                  {var n=by + value(opt,0) | 0;return 0 === n?0:[0,n]})
              :update$2
                (t,
                 key,
                 function(param)
                  {if(! param)return by;var i=param[1];return by + i | 0})}
    function incr$5(opt,_mq_,t,key)
     {if(opt)var sth=opt[1],by=sth;else var by=1;
      if(_mq_)
       var sth$0=_mq_[1],remove_if_zero=sth$0;
      else
       var remove_if_zero=0;
      return incr_by(remove_if_zero,t,key,by)}
    function decr$5(opt,_mp_,t,key)
     {if(opt)var sth=opt[1],by=sth;else var by=1;
      if(_mp_)
       var sth$0=_mp_[1],remove_if_zero=sth$0;
      else
       var remove_if_zero=0;
      return incr_by(remove_if_zero,t,key,- by | 0)}
    function add_multi$2(t,key,data)
     {return update$2
              (t,
               key,
               function(param)
                {if(! param)return [0,data,0];
                 var l=param[1];
                 return [0,data,l]})}
    function remove_multi$2(t,key)
     {var match=find$16(t,key);
      if(! match)return 0;
      var _mo_=match[1];
      if(_mo_ && _mo_[2]){var tl=_mo_[2];return set$9(t,key,tl)}
      return remove$8(t,key)}
    function find_multi$2(t,key)
     {var match=find$16(t,key);if(! match)return 0;var l=match[1];return l}
    function create_mapped(growth_allowed,size,hashable,get_key,get_data,rows)
     {if(size)var s=size[1],size$0=s;else var size$0=caml_call1(length,rows);
      var res=create$16(growth_allowed,[0,size$0],hashable,0),dupes=[0,0];
      iter$0
       (rows,
        function(r)
         {var key=caml_call1(get_key,r),data=caml_call1(get_data,r);
          return mem$14(res,key)
                  ?(dupes[1] = [0,key,dupes[1]],0)
                  :set$9(res,key,data)});
      var _mn_=dupes[1];
      return _mn_?[0,175765640,dedup_and_sort(_mn_,hashable[2])]:[0,17724,res]}
    function of_alist$4(growth_allowed,size,hashable,lst)
     {var
       match=
        create_mapped(growth_allowed,size,hashable,get_key,get_data,lst);
      if(175765640 <= match[1])
       {var k=match[2];return [0,-1048878709,caml_call1(hd_exn,k)]}
      var t=match[2];
      return [0,17724,t]}
    function of_alist_report_all_dups(growth_allowed,size,hashable,lst)
     {return create_mapped(growth_allowed,size,hashable,get_key,get_data,lst)}
    function of_alist_or_error$4(growth_allowed,size,hashable,lst)
     {var match=of_alist$4(growth_allowed,size,hashable,lst);
      if(17724 <= match[1]){var v=match[2];return [0,v]}
      var key=match[2],sexp_of_key=hashable[3];
      return error$0(0,0,cst_Hashtbl_of_alist_exn_dupli,key,sexp_of_key)}
    function of_alist_exn$4(growth_allowed,size,hashable,lst)
     {var match=of_alist_or_error$4(growth_allowed,size,hashable,lst);
      if(0 === match[0]){var v=match[1];return v}
      var e=match[1];
      return raise(e)}
    function of_alist_multi$4(growth_allowed,size$0,hashable,lst)
     {if(size$0)var s=size$0[1],size=s;else var size=caml_call1(length,lst);
      var res=create$16(growth_allowed,[0,size],hashable,0);
      iter$0
       (lst,
        function(r){var key=r[1],data=r[2];return add_multi$2(res,key,data)});
      return res}
    function to_alist$2(t)
     {return fold$18
              (t,0,function(key,data,list){return [0,[0,key,data],list]})}
    function sexp_of_t$62(sexp_of_key,sexp_of_data,t)
     {var
       _mk_=to_alist$2(t),
       _ml_=
        sort
         (_mk_,
          function(param,_mm_)
           {var k2=_mm_[1],k1=param[1];return caml_call2(t[5][2],k1,k2)});
      return caml_call1
              (caml_call1
                (sexp_of_t$10,
                 caml_call2(sexp_of_pair,sexp_of_key,sexp_of_data)),
               _ml_)}
    function t_of_sexp$34(hashable,k_of_sexp,d_of_sexp,sexp)
     {var
       alist=
        caml_call2
         (t_of_sexp$10,caml_call2(pair_of_sexp,k_of_sexp,d_of_sexp),sexp),
       match=of_alist$4(0,[0,caml_call1(length,alist)],hashable,alist);
      if(17724 <= match[1]){var v=match[2];return v}
      var k=match[2];
      function _me_(_mj_){return _mj_}
      var
       alist_sexps=
        caml_call2
         (t_of_sexp$10,
          caml_call2(pair_of_sexp,function(_mi_){return _mi_},_me_),
          sexp),
       found_first_k=[0,0];
      iter2_exn
       (alist,
        alist_sexps,
        function(param,_mf_)
         {var
           k2_sexp=_mf_[1],
           k2=param[1],
           _mg_=0 === caml_call2(hashable[2],k,k2)?1:0;
          if(_mg_)
           {if(found_first_k[1])
             return caml_call2
                     (of_sexp_error,cst_Hashtbl_t_of_sexp_duplicat,k2_sexp);
            found_first_k[1] = 1;
            var _mh_=0}
          else
           var _mh_=_mg_;
          return _mh_});
      throw [0,Assert_failure$0,_h9_]}
    function t_sexp_grammar$32(k_grammar,v_grammar)
     {var _md_=caml_call2(_aE_[3],k_grammar,v_grammar);
      return caml_call1(Sexplib0_Sexp_grammar[1],_md_)}
    function to_list$13(t)
     {return fold$18(t,0,function(key,param,acc){return [0,key,acc]})}
    function data$2(t)
     {return fold$18(t,0,function(param,data,list){return [0,data,list]})}
    function group$2
     (growth_allowed,size,hashable,get_key,get_data,combine,rows)
     {var groups=create$16(growth_allowed,size,hashable,0);
      iter$0
       (rows,
        function(row)
         {var
           key=caml_call1(get_key,row),
           data=caml_call1(get_data,row),
           match=find$16(groups,key);
          if(match)
           var old=match[1],data$0=caml_call2(combine,old,data);
          else
           var data$0=data;
          return set$9(groups,key,data$0)});
      return groups}
    function create_with_key(growth_allowed,size,hashable,get_key,rows)
     {return create_mapped
              (growth_allowed,
               size,
               hashable,
               get_key,
               function(_mc_){return _mc_},
               rows)}
    function create_with_key_or_error
     (growth_allowed,size,hashable,get_key,rows)
     {var match=create_with_key(growth_allowed,size,hashable,get_key,rows);
      if(175765640 <= match[1])
       {var keys=match[2],sexp_of_key=hashable[3];
        return error_s
                (caml_call2
                  (message,
                   cst_Hashtbl_create_with_key_du,
                   [0,[0,cst_keys,caml_call2(sexp_of_t$10,sexp_of_key,keys)],0]))}
      var t=match[2];
      return [0,t]}
    function create_with_key_exn(growth_allowed,size,hashable,get_key,rows)
     {return ok_exn$0
              (create_with_key_or_error
                (growth_allowed,size,hashable,get_key,rows))}
    function maybe_set(t,key,f,d)
     {var match=caml_call2(f,key,d);
      if(! match)return 0;
      var v=match[1];
      return set$9(t,key,v)}
    function merge$6(t_left,t_right,f)
     {if(1 - caml_call2(equal$17,t_left[5],t_right[5]))
       caml_call1(invalid_arg$0,cst_Hashtbl_merge_different_ha);
      var new_t=create$16([0,t_left[4]],[0,t_left[2]],t_left[5],0);
      without_mutating
       (t_left,
        function(param)
         {return without_mutating
                  (t_right,
                   function(param)
                    {iteri$13
                      (t_left,
                       function(key,left)
                        {var match=find$16(t_right,key);
                         if(! match)return maybe_set(new_t,key,f,[0,847852583,left]);
                         var right=match[1];
                         return maybe_set(new_t,key,f,[0,737457313,[0,left,right]])});
                     return iteri$13
                             (t_right,
                              function(key,right)
                               {var match=find$16(t_left,key);
                                return match?0:maybe_set(new_t,key,f,[0,-57574468,right])})})});
      return new_t}
    function merge_into(src,dst,f)
     {return iteri$13
              (src,
               function(key,data)
                {var
                  dst_data=find$16(dst,key),
                  action=
                   without_mutating
                    (dst,
                     function(param){return caml_call3(f,key,data,dst_data)});
                 if(! action)return remove$8(dst,key);
                 var data$0=action[1];
                 if(! dst_data)return set$9(dst,key,data$0);
                 var
                  dst_data$0=dst_data[1],
                  _mb_=1 - (dst_data$0 === data$0?1:0);
                 return _mb_?set$9(dst,key,data$0):_mb_})}
    function filteri_inplace$1(t,f)
     {var
       to_remove=
        fold$18
         (t,
          0,
          function(key,data,ac){return caml_call2(f,key,data)?ac:[0,key,ac]});
      return iter$0(to_remove,function(key){return remove$8(t,key)})}
    function filter_inplace$1(t,f)
     {return filteri_inplace$1
              (t,function(param,data){return caml_call1(f,data)})}
    function filter_keys_inplace(t,f)
     {return filteri_inplace$1
              (t,function(key,param){return caml_call1(f,key)})}
    function filter_mapi_inplace(t,f)
     {var
       map_results=
        fold$18
         (t,
          0,
          function(key,data,ac){return [0,[0,key,caml_call2(f,key,data)],ac]});
      return iter$0
              (map_results,
               function(param)
                {var result=param[2],key=param[1];
                 if(! result)return remove$8(t,key);
                 var data=result[1];
                 return set$9(t,key,data)})}
    function filter_map_inplace(t,f)
     {return filter_mapi_inplace
              (t,function(param,data){return caml_call1(f,data)})}
    function mapi_inplace$0(t,f)
     {ensure_mutation_allowed(t);
      return without_mutating
              (t,
               function(param)
                {function _l$_(_ma_){return mapi_inplace(_ma_,f)}
                 return iter(t[1],_l$_)})}
    function map_inplace$0(t,f)
     {return mapi_inplace$0(t,function(param,data){return caml_call1(f,data)})}
    function similar(equal,t$0,t)
     {var _l9_=t$0[2] === t[2]?1:0;
      return _l9_
              ?with_return
                (function(r)
                  {without_mutating
                    (t,
                     function(param)
                      {return iteri$13
                               (t$0,
                                function(key,data)
                                 {var match=find$16(t,key);
                                  if(! match)return caml_call1(r,0);
                                  var data$0=match[1],_l__=1 - caml_call2(equal,data,data$0);
                                  return _l__?caml_call1(r,0):_l__})});
                   return 1})
              :_l9_}
    function Creators(Key)
     {var hashable=Key[1];
      function create(growth_allowed,size,param)
       {return create$16(growth_allowed,size,hashable,0)}
      function of_alist(growth_allowed,size,l)
       {return of_alist$4(growth_allowed,size,hashable,l)}
      function of_alist_report_all_dups$0(growth_allowed,size,l)
       {return of_alist_report_all_dups(growth_allowed,size,hashable,l)}
      function of_alist_or_error(growth_allowed,size,l)
       {return of_alist_or_error$4(growth_allowed,size,hashable,l)}
      function of_alist_exn(growth_allowed,size,l)
       {return of_alist_exn$4(growth_allowed,size,hashable,l)}
      function t_of_sexp(k_of_sexp,d_of_sexp,sexp)
       {return t_of_sexp$34(hashable,k_of_sexp,d_of_sexp,sexp)}
      function of_alist_multi(growth_allowed,size,l)
       {return of_alist_multi$4(growth_allowed,size,hashable,l)}
      function create_mapped$0(growth_allowed,size,get_key,get_data,l)
       {return create_mapped(growth_allowed,size,hashable,get_key,get_data,l)}
      function create_with_key$0(growth_allowed,size,get_key,l)
       {return create_with_key(growth_allowed,size,hashable,get_key,l)}
      function create_with_key_or_error$0(growth_allowed,size,get_key,l)
       {return create_with_key_or_error
                (growth_allowed,size,hashable,get_key,l)}
      function create_with_key_exn$0(growth_allowed,size,get_key,l)
       {return create_with_key_exn(growth_allowed,size,hashable,get_key,l)}
      function group(growth_allowed,size,get_key,get_data,combine,l)
       {return group$2
                (growth_allowed,size,hashable,get_key,get_data,combine,l)}
      return [0,
              t_of_sexp,
              create,
              of_alist,
              of_alist_report_all_dups$0,
              of_alist_or_error,
              of_alist_exn,
              of_alist_multi,
              create_mapped$0,
              create_with_key$0,
              create_with_key_or_error$0,
              create_with_key_exn$0,
              group]}
    var
     _h__=Creators([0,hashable]),
     t_of_sexp$35=_h__[1],
     create$17=_h__[2],
     of_alist$5=_h__[3],
     of_alist_report_all_dups$0=_h__[4],
     of_alist_or_error$5=_h__[5],
     of_alist_exn$5=_h__[6],
     of_alist_multi$5=_h__[7],
     create_mapped$0=_h__[8],
     create_with_key$0=_h__[9],
     create_with_key_or_error$0=_h__[10],
     create_with_key_exn$0=_h__[11],
     group$3=_h__[12];
    function hashable$11(t){return t[5]}
    var Private$5=[0,hashable$11];
    function create$18(growth_allowed,size,m)
     {return create$16(growth_allowed,size,caml_call1(of_key$0,m),0)}
    function of_alist$6(growth_allowed,size,m,l)
     {return of_alist$4(growth_allowed,size,caml_call1(of_key$0,m),l)}
    function of_alist_report_all_dups$1(growth_allowed,size,m,l)
     {return of_alist_report_all_dups
              (growth_allowed,size,caml_call1(of_key$0,m),l)}
    function of_alist_or_error$6(growth_allowed,size,m,l)
     {return of_alist_or_error$4(growth_allowed,size,caml_call1(of_key$0,m),l)}
    function of_alist_exn$6(growth_allowed,size,m,l)
     {return of_alist_exn$4(growth_allowed,size,caml_call1(of_key$0,m),l)}
    function of_alist_multi$6(growth_allowed,size,m,l)
     {return of_alist_multi$4(growth_allowed,size,caml_call1(of_key$0,m),l)}
    function create_mapped$1(growth_allowed,size,m,get_key,get_data,l)
     {return create_mapped
              (growth_allowed,size,caml_call1(of_key$0,m),get_key,get_data,l)}
    function create_with_key$1(growth_allowed,size,m,get_key,l)
     {return create_with_key
              (growth_allowed,size,caml_call1(of_key$0,m),get_key,l)}
    function create_with_key_or_error$1(growth_allowed,size,m,get_key,l)
     {return create_with_key_or_error
              (growth_allowed,size,caml_call1(of_key$0,m),get_key,l)}
    function create_with_key_exn$1(growth_allowed,size,m,get_key,l)
     {return create_with_key_exn
              (growth_allowed,size,caml_call1(of_key$0,m),get_key,l)}
    function group$4(growth_allowed,size,m,get_key,get_data,combine,l)
     {return group$2
              (growth_allowed,
               size,
               caml_call1(of_key$0,m),
               get_key,
               get_data,
               combine,
               l)}
    function hashable_s(t){return caml_call1(to_key$0,t[5])}
    function M$1(K){return [0]}
    function sexp_of_m_t$1(K)
     {return function(sexp_of_v,t){return sexp_of_t$62(K[1],sexp_of_v,t)}}
    function m_t_of_sexp$1(K)
     {return function(v_of_sexp,sexp)
       {var _l8_=K[1];
        return t_of_sexp$34
                (caml_call1(of_key$0,[0,K[2],K[3],K[4]]),_l8_,v_of_sexp,sexp)}}
    function m_t_sexp_grammar$1(K)
     {return function(v_grammar){return t_sexp_grammar$32(K[1],v_grammar)}}
    function equal_m_t$1(param,equal_v,t1,t2){return similar(equal_v,t1,t2)}
    var
     _h$_=
      [0,
       t_of_sexp$35,
       sexp_of_t$62,
       t_sexp_grammar$32,
       hashable,
       invariant$24,
       create$17,
       of_alist$5,
       of_alist_report_all_dups$0,
       of_alist_or_error$5,
       of_alist_exn$5,
       of_alist_multi$5,
       create_mapped$0,
       create_with_key$0,
       create_with_key_or_error$0,
       create_with_key_exn$0,
       group$3,
       sexp_of_key,
       clear$3,
       copy$7,
       fold$18,
       iter_keys$2,
       iter$23,
       iteri$13,
       existsi$10,
       exists$15,
       for_alli$10,
       for_all$15,
       counti$10,
       count$14,
       length$22,
       is_empty$15,
       mem$14,
       remove$8,
       choose$2,
       choose_exn$3,
       set$9,
       add$8,
       add_exn$3,
       change$2,
       update$2,
       update_and_return,
       map$37,
       mapi$11,
       filter_map$12,
       filter_mapi$7,
       filter_keys$2,
       filter$12,
       filteri$8,
       partition_map$3,
       partition_mapi$2,
       partition_tf$7,
       partitioni_tf$3,
       find_or_add,
       findi_or_add,
       find$16,
       find_exn$9,
       find_and_call$0,
       find_and_call1$0,
       find_and_call2$0,
       findi_and_call$0,
       findi_and_call1$0,
       findi_and_call2$0,
       find_and_remove,
       merge$6,
       merge_into,
       to_list$13,
       data$2,
       filter_keys_inplace,
       filter_inplace$1,
       filteri_inplace$1,
       map_inplace$0,
       mapi_inplace$0,
       filter_map_inplace,
       filter_mapi_inplace,
       similar,
       similar,
       to_alist$2,
       incr$5,
       decr$5,
       add_multi$2,
       remove_multi$2,
       find_multi$2],
     Base_Hashtbl=
      [0,
       hash$5,
       hash_param$0,
       sexp_of_t$62,
       create$18,
       of_alist$6,
       of_alist_report_all_dups$1,
       of_alist_or_error$6,
       of_alist_exn$6,
       of_alist_multi$6,
       create_mapped$1,
       create_with_key$1,
       create_with_key_or_error$1,
       create_with_key_exn$1,
       group$4,
       sexp_of_key,
       clear$3,
       copy$7,
       fold$18,
       iter_keys$2,
       iter$23,
       iteri$13,
       existsi$10,
       exists$15,
       for_alli$10,
       for_all$15,
       counti$10,
       count$14,
       length$22,
       is_empty$15,
       mem$14,
       remove$8,
       choose$2,
       choose_exn$3,
       set$9,
       add$8,
       add_exn$3,
       change$2,
       update$2,
       update_and_return,
       map$37,
       mapi$11,
       filter_map$12,
       filter_mapi$7,
       filter_keys$2,
       filter$12,
       filteri$8,
       partition_map$3,
       partition_mapi$2,
       partition_tf$7,
       partitioni_tf$3,
       find_or_add,
       findi_or_add,
       find$16,
       find_exn$9,
       find_and_call$0,
       find_and_call1$0,
       find_and_call2$0,
       findi_and_call$0,
       findi_and_call1$0,
       findi_and_call2$0,
       find_and_remove,
       merge$6,
       merge_into,
       to_list$13,
       data$2,
       filter_keys_inplace,
       filter_inplace$1,
       filteri_inplace$1,
       map_inplace$0,
       mapi_inplace$0,
       filter_map_inplace,
       filter_mapi_inplace,
       similar,
       similar,
       to_alist$2,
       incr$5,
       decr$5,
       add_multi$2,
       remove_multi$2,
       find_multi$2,
       hashable_s,
       invariant$24,
       Creators,
       _h$_,
       M$1,
       sexp_of_m_t$1,
       m_t_of_sexp$1,
       m_t_sexp_grammar$1,
       equal_m_t$1,
       Private$5];
    caml_register_global(1126,Base_Hashtbl,"Base__Hashtbl");
    var Base_Hash_set_intf=[0];
    caml_register_global(1127,Base_Hash_set_intf,"Base__Hash_set_intf");
    var hashable$12=Private$5[1],poly_hashable=_h$_[4];
    function is_empty$16(t){return is_empty$15(t)}
    function find_map$11(t,f)
     {return with_return
              (function(r)
                {iter_keys$2
                  (t,
                   function(elt)
                    {var o=caml_call1(f,elt);return o?caml_call1(r,o):0});
                 return 0})}
    function find$17(t,f)
     {return find_map$11(t,function(a){return caml_call1(f,a)?[0,a]:0})}
    function add$9(t,k){return set$9(t,k,0)}
    function strict_add(t,k)
     {return mem$14(t,k)
              ?error_string(cst_element_already_exists)
              :(set$9(t,k,0),_ia_)}
    function strict_add_exn(t,k){return ok_exn$0(strict_add(t,k))}
    function strict_remove(t,k)
     {return mem$14(t,k)
              ?(remove$8(t,k),_ib_)
              :error$0(0,0,cst_element_not_in_set,k,sexp_of_key(t))}
    function strict_remove_exn(t,k){return ok_exn$0(strict_remove(t,k))}
    function fold$19(t,init,f)
     {return fold$18
              (t,init,function(key,param,acc){return caml_call2(f,acc,key)})}
    function iter$24(t,f){return iter_keys$2(t,f)}
    function count$15(t,f){return count(fold$19,t,f)}
    function sum$11(m,t,f){return caml_call2(sum(fold$19,m),t,f)}
    function min_elt$15(t,compare){return min_elt(fold$19,t,compare)}
    function max_elt$15(t,compare){return max_elt(fold$19,t,compare)}
    function fold_result$10(t,init,f){return fold_result(fold$19,init,f,t)}
    function fold_until$14(t,init,f)
     {return function(_l7_){return fold_until(fold$19,init,f,_l7_,t)}}
    function sexp_of_t$63(sexp_of_e,t)
     {var _l6_=to_list$13(t);
      return caml_call2
              (sexp_of_t$10,sexp_of_e,sort(_l6_,caml_call1(hashable$12,t)[2]))}
    function to_array$12(t)
     {var len=t[2],index=[0,len - 1 | 0];
      return fold$19
              (t,
               [0],
               function(acc,key)
                {if(0 === acc.length - 1)return caml_make_vect(len,key);
                 index[1] = index[1] - 1 | 0;
                 var _l5_=index[1];
                 caml_check_bound(acc,_l5_)[1 + _l5_] = key;
                 return acc})}
    function exists$16(t,f)
     {return existsi$10(t,function(key,param){return caml_call1(f,key)})}
    function for_all$16(t,f)
     {return 1
             -
             existsi$10(t,function(key,param){return 1 - caml_call1(f,key)})}
    function equal$47(t1,t2)
     {return similar(function(param,_l4_){return 1},t1,t2)}
    function copy$8(t){return copy$7(t)}
    function filter$13(t,f)
     {return filteri$8(t,function(key,param){return caml_call1(f,key)})}
    function union$2(t1,t2)
     {return merge$6(t1,t2,function(param,_l3_){return _ic_})}
    function diff$2(t1,t2)
     {return filter$13(t1,function(key){return 1 - mem$14(t2,key)})}
    function inter$2(t1,t2)
     {if(t2[2] < t1[2])var larger=t1,smaller=t2;else var larger=t2,smaller=t1;
      return filteri$8(smaller,function(key,param){return mem$14(larger,key)})}
    function filter_inplace$2(t,f)
     {var
       to_remove=
        fold$19(t,0,function(ac,x){return caml_call1(f,x)?ac:[0,x,ac]});
      return iter$0(to_remove,function(x){return remove$8(t,x)})}
    function of_hashtbl_keys(hashtbl)
     {return map$37(hashtbl,function(_l2_){return 0})}
    function to_hashtbl(t,f)
     {return mapi$11(t,function(key,param){return caml_call1(f,key)})}
    function create$19(growth_allowed,size,m)
     {return create$18(growth_allowed,size,m)}
    function of_list$11(growth_allowed,size,m,l)
     {if(size)var x=size[1],size$0=x;else var size$0=caml_call1(length,l);
      var t=create$18(growth_allowed,[0,size$0],m);
      iter$0(l,function(k){return add$9(t,k)});
      return t}
    function t_of_sexp$36(m,e_of_sexp,sexp)
     {if(0 === sexp[0])
       return caml_call2(of_sexp_error,cst_Hash_set_t_of_sexp_require,sexp);
      var list=sexp[1],t=create$19(0,[0,caml_call1(length,list)],m);
      iter$0
       (list,
        function(sexp)
         {var e=caml_call1(e_of_sexp,sexp),match=strict_add(t,e);
          return 0 === match[0]
                  ?0
                  :caml_call2
                    (of_sexp_error,cst_Hash_set_t_of_sexp_got_a_d,sexp)});
      return t}
    function Creators$0(Elt)
     {function create(growth_allowed,size,param)
       {return create$19(growth_allowed,size,caml_call1(to_key$0,Elt[1]))}
      function of_list(growth_allowed,size,l)
       {return of_list$11(growth_allowed,size,caml_call1(to_key$0,Elt[1]),l)}
      function t_of_sexp(e_of_sexp,sexp)
       {return t_of_sexp$36(caml_call1(to_key$0,Elt[1]),e_of_sexp,sexp)}
      return [0,t_of_sexp,create,of_list]}
    var
     _id_=Creators$0([0,poly_hashable]),
     t_of_sexp$37=_id_[1],
     create$20=_id_[2],
     of_list$12=_id_[3];
    function t_sexp_grammar$33(grammar)
     {var _l1_=t_sexp_grammar$12(grammar);
      return caml_call1(Sexplib0_Sexp_grammar[1],_l1_)}
    function M$2(Elt){return [0]}
    function sexp_of_m_t$2(Elt)
     {return function(t){return sexp_of_t$63(Elt[1],t)}}
    function m_t_of_sexp$2(Elt)
     {return function(sexp)
       {return t_of_sexp$36([0,Elt[2],Elt[3],Elt[4]],Elt[1],sexp)}}
    function m_t_sexp_grammar$2(Elt)
     {var _l0_=caml_call1(list_sexp_grammar,Elt[1]);
      return caml_call1(Sexplib0_Sexp_grammar[1],_l0_)}
    function equal_m_t$2(param,t1,t2){return equal$47(t1,t2)}
    var
     hashable$13=Private$5[1],
     Private$6=[0,hashable$13],
     Base_Hash_set=
      [0,
       sexp_of_t$63,
       create$19,
       of_list$11,
       length$22,
       is_empty$16,
       iter$24,
       fold$19,
       fold_result$10,
       fold_until$14,
       exists$16,
       for_all$16,
       count$15,
       sum$11,
       find$17,
       find_map$11,
       to_list$13,
       to_array$12,
       min_elt$15,
       max_elt$15,
       mem$14,
       copy$8,
       add$9,
       strict_add,
       strict_add_exn,
       remove$8,
       strict_remove,
       strict_remove_exn,
       clear$3,
       equal$47,
       filter$13,
       filter_inplace$2,
       inter$2,
       union$2,
       diff$2,
       of_hashtbl_keys,
       to_hashtbl,
       hashable_s,
       [0,
        t_of_sexp$37,
        sexp_of_t$63,
        t_sexp_grammar$33,
        create$20,
        of_list$12,
        length$22,
        is_empty$16,
        iter$24,
        fold$19,
        fold_result$10,
        fold_until$14,
        exists$16,
        for_all$16,
        count$15,
        sum$11,
        find$17,
        find_map$11,
        to_list$13,
        to_array$12,
        min_elt$15,
        max_elt$15,
        mem$14,
        copy$8,
        add$9,
        strict_add,
        strict_add_exn,
        remove$8,
        strict_remove,
        strict_remove_exn,
        clear$3,
        equal$47,
        filter$13,
        filter_inplace$2,
        inter$2,
        union$2,
        diff$2,
        of_hashtbl_keys,
        to_hashtbl],
       Creators$0,
       M$2,
       sexp_of_m_t$2,
       m_t_of_sexp$2,
       m_t_sexp_grammar$2,
       equal_m_t$2,
       Private$6];
    caml_register_global(1128,Base_Hash_set,"Base__Hash_set");
    function hash$24(x){return caml_call1(specialized_hash,x)}
    var
     hashable$14=[0,hash$24,compare$33,sexp_of_t$5],
     compare$62=include$7[9],
     include$86=_P_([0,compare$62,sexp_of_t$5]),
     _ie_=include$86[1];
    function invariant$25(param){return 0}
    function to_float$5(x){return x}
    function of_float$4(x){return x}
    function of_string$24(s)
     {try
       {var _lY_=caml_float_of_string(s);return _lY_}
      catch(_lZ_){return caml_call2(invalid_argf(_if_),s,0)}}
    function to_string$26(x)
     {var
       y=caml_format_float(cst_15g,x),
       _lX_=caml_float_of_string(y),
       y$0=caml_call2(include$7[4],_lX_,x)?y:caml_format_float(cst_17g,x),
       l=caml_ml_string_length(y$0),
       i=0;
      for(;;)
       {if(l <= i)return caml_call2(symbol$59,y$0,cst$37);
        var match=caml_string_get(y$0,i),switch$0=0;
        if(48 <= match)
         {if(58 > match)switch$0 = 1}
        else
         if(45 === match)switch$0 = 1;
        if(! switch$0)return y$0;
        var i$0=i + 1 | 0,i=i$0}}
    var
     min_positive_subnormal_value=4.94065645841e-324,
     min_positive_normal_value=2.22507385850720138e-308,
     zero$6=0.,
     one$5=1.,
     minus_one$4=-1.,
     pi=3.14159265358979312,
     sqrt_pi=1.7724538509055161,
     sqrt_2pi=2.50662827463100069,
     euler=0.577215664901532866;
    function of_int63(i){return _gc_(i)}
    function of_int64$0(i){return caml_int64_to_float(i)}
    var
     to_int64$1=caml_int64_of_float,
     iround_lbound=lower_bound_for_int(num_bits),
     iround_ubound=upper_bound_for_int(num_bits);
    function iround_up(t)
     {if(! caml_call2(include$7[5],t,0.))
       return caml_call2(include$7[6],t,iround_lbound)?[0,t | 0]:0;
      var t$0=Math.ceil(t);
      return caml_call2(include$7[2],t$0,iround_ubound)?[0,t$0 | 0]:0}
    function iround_up_exn(t)
     {if(! caml_call2(include$7[5],t,0.))
       return caml_call2(include$7[6],t,iround_lbound)
               ?t | 0
               :caml_call2(invalid_argf(_ih_),t + 0.,0);
      var t$0=Math.ceil(t);
      return caml_call2(include$7[2],t$0,iround_ubound)
              ?t$0 | 0
              :caml_call2(invalid_argf(_ig_),t + 0.,0)}
    function iround_down(t)
     {if(caml_call2(include$7[6],t,0.))
       return caml_call2(include$7[2],t,iround_ubound)?[0,t | 0]:0;
      var t$0=Math.floor(t);
      return caml_call2(include$7[6],t$0,iround_lbound)?[0,t$0 | 0]:0}
    function iround_down_exn(t)
     {if(caml_call2(include$7[6],t,0.))
       return caml_call2(include$7[2],t,iround_ubound)
               ?t | 0
               :caml_call2(invalid_argf(_ii_),t + 0.,0);
      var t$0=Math.floor(t);
      return caml_call2(include$7[6],t$0,iround_lbound)
              ?t$0 | 0
              :caml_call2(invalid_argf(_ij_),t + 0.,0)}
    function iround_towards_zero(t)
     {if
       (caml_call2(include$7[6],t,iround_lbound)
        &&
        caml_call2(include$7[2],t,iround_ubound))
       return [0,t | 0];
      return 0}
    function iround_towards_zero_exn(t)
     {if
       (caml_call2(include$7[6],t,iround_lbound)
        &&
        caml_call2(include$7[2],t,iround_ubound))
       return t | 0;
      return caml_call2(invalid_argf(_ik_),t + 0.,0)}
    var
     one_ulp_less_than_half=one_ulp(759637122,0.5),
     round_nearest_lb=-4503599627370496.,
     round_nearest_ub=4503599627370496.;
    function add_half_for_round_nearest(t)
     {var
       _lW_=
        caml_call2(include$7[4],t,one_ulp_less_than_half)
         ?one_ulp_less_than_half
         :0.5;
      return t + _lW_}
    function iround_nearest_32(t)
     {if(caml_call2(include$7[6],t,0.))
       {var t$0=add_half_for_round_nearest(t);
        return caml_call2(include$7[2],t$0,iround_ubound)?[0,t$0 | 0]:0}
      var t$1=Math.floor(t + 0.5);
      return caml_call2(include$7[6],t$1,iround_lbound)?[0,t$1 | 0]:0}
    function iround_nearest_64(t)
     {return caml_call2(include$7[6],t,0.)
              ?caml_call2(include$7[1],t,round_nearest_ub)
                ?[0,add_half_for_round_nearest(t) | 0]
                :caml_call2(include$7[2],t,iround_ubound)?[0,t | 0]:0
              :caml_call2(include$7[5],t,round_nearest_lb)
                ?[0,Math.floor(t + 0.5) | 0]
                :caml_call2(include$7[6],t,iround_lbound)?[0,t | 0]:0}
    var iround_nearest_64$0=word_size?iround_nearest_64:iround_nearest_32;
    function iround_nearest_exn_32(t)
     {if(caml_call2(include$7[6],t,0.))
       {var t$0=add_half_for_round_nearest(t);
        return caml_call2(include$7[2],t$0,iround_ubound)
                ?t$0 | 0
                :caml_call2(invalid_argf(_il_),t + 0.,0)}
      var t$1=Math.floor(t + 0.5);
      return caml_call2(include$7[6],t$1,iround_lbound)
              ?t$1 | 0
              :caml_call2(invalid_argf(_im_),t + 0.,0)}
    function iround_nearest_exn_64(t)
     {return caml_call2(include$7[6],t,0.)
              ?caml_call2(include$7[1],t,round_nearest_ub)
                ?add_half_for_round_nearest(t) | 0
                :caml_call2(include$7[2],t,iround_ubound)
                  ?t | 0
                  :caml_call2(invalid_argf(_in_),t + 0.,0)
              :caml_call2(include$7[5],t,round_nearest_lb)
                ?Math.floor(t + 0.5) | 0
                :caml_call2(include$7[6],t,iround_lbound)
                  ?t | 0
                  :caml_call2(invalid_argf(_io_),t + 0.,0)}
    var
     iround_nearest_exn=
      word_size?iround_nearest_exn_64:iround_nearest_exn_32;
    function iround_exn(opt,t)
     {if(opt)var sth=opt[1],dir=sth;else var dir=857423934;
      return 857423934 <= dir
              ?1003109192 <= dir
                ?iround_towards_zero_exn(t)
                :iround_nearest_exn(t)
              :759637122 <= dir?iround_down_exn(t):iround_up_exn(t)}
    function iround(opt,t)
     {if(opt)var sth=opt[1],dir=sth;else var dir=857423934;
      try
       {var _lU_=[0,iround_exn([0,dir],t)];return _lU_}
      catch(_lV_){return 0}}
    function is_inf(t){return caml_call2(include$7[4],1. / t,0.)}
    function is_finite(t){return caml_call2(include$7[4],t - t,0.)}
    function min_inan(x,y)
     {return is_nan(y)?x:is_nan(x)?y:caml_call2(include$7[1],x,y)?x:y}
    function max_inan(x,y)
     {return is_nan(y)?x:is_nan(x)?y:caml_call2(include$7[5],x,y)?x:y}
    function square(x){return x * x}
    function fractional(t){return t[1]}
    function integral(t){return t[2]}
    function round_towards_zero$4(t)
     {return caml_call2(include$7[6],t,0.)?Math.floor(t):Math.ceil(t)}
    function round_nearest_inline(t)
     {if
       (caml_call2(include$7[5],t,round_nearest_lb)
        &&
        caml_call2(include$7[1],t,round_nearest_ub))
       return Math.floor(add_half_for_round_nearest(t));
      return t + 0.}
    function round_nearest$4(t){return round_nearest_inline(t)}
    function round_nearest_half_to_even(t)
     {if
       (!
        caml_call2(include$7[2],t,round_nearest_lb)
        &&
        !
        caml_call2(include$7[6],t,round_nearest_ub))
       {var
         floor=Math.floor(t),
         ceil_or_succ=floor + 1.,
         diff_floor=t - floor,
         diff_ceil=ceil_or_succ - t;
        return caml_call2(include$7[1],diff_floor,diff_ceil)
                ?floor
                :caml_call2(include$7[5],diff_floor,diff_ceil)
                  ?ceil_or_succ
                  :caml_call2(include$7[4],floor % 2.,0.)?floor:ceil_or_succ}
      return t + 0.}
    var
     int63_round_lbound=lower_bound_for_int(_hr_),
     int63_round_ubound=upper_bound_for_int(_hr_);
    function int63_round_up_exn(t)
     {if(! caml_call2(include$7[5],t,0.))
       return caml_call2(include$7[6],t,int63_round_lbound)
               ?_hP_(t)
               :caml_call2(invalid_argf(_iq_),t + 0.,0);
      var t$0=Math.ceil(t);
      return caml_call2(include$7[2],t$0,int63_round_ubound)
              ?_hP_(t$0)
              :caml_call2(invalid_argf(_ip_),t + 0.,0)}
    function int63_round_down_exn(t)
     {if(caml_call2(include$7[6],t,0.))
       return caml_call2(include$7[2],t,int63_round_ubound)
               ?_hP_(t)
               :caml_call2(invalid_argf(_ir_),t + 0.,0);
      var t$0=Math.floor(t);
      return caml_call2(include$7[6],t$0,int63_round_lbound)
              ?_hP_(t$0)
              :caml_call2(invalid_argf(_is_),t + 0.,0)}
    function int63_round_nearest_portable_a(t0)
     {var t=round_nearest_inline(t0);
      return caml_call2(include$7[5],t,0.)
              ?caml_call2(include$7[2],t,int63_round_ubound)
                ?_hP_(t)
                :caml_call2(invalid_argf(_it_),t0 + 0.,0)
              :caml_call2(include$7[6],t,int63_round_lbound)
                ?_hP_(t)
                :caml_call2(invalid_argf(_iu_),t0 + 0.,0)}
    function int63_round_nearest_arch64_noa(f)
     {return _hD_(iround_nearest_exn(f))}
    var
     int63_round_nearest_exn=
      word_size?int63_round_nearest_arch64_noa:int63_round_nearest_portable_a;
    function round$4(opt,t)
     {if(opt)var sth=opt[1],dir=sth;else var dir=857423934;
      return 857423934 <= dir
              ?1003109192 <= dir?round_towards_zero$4(t):round_nearest$4(t)
              :759637122 <= dir?Math.floor(t):Math.ceil(t)}
    var compare$63=caml_int_compare;
    function t_of_sexp$38(sexp_007)
     {if(0 === sexp_007[0])
       {var
         _lO_=sexp_007[1],
         _lP_=caml_string_compare(_lO_,cst_infinite),
         switch$0=0;
        if(0 <= _lP_)
         if(0 < _lP_)
          if(caml_string_notequal(_lO_,cst_nan$1))
           if(caml_string_notequal(_lO_,cst_normal))
            if(caml_string_notequal(_lO_,cst_subnormal))
             {if(! caml_string_notequal(_lO_,cst_zero$3))switch$0 = 5}
            else
             switch$0 = 4;
           else
            switch$0 = 3;
          else
           switch$0 = 2;
         else
          switch$0 = 1;
        else
         if(caml_string_notequal(_lO_,cst_Infinite))
          if(caml_string_notequal(_lO_,cst_Nan$1))
           if(caml_string_notequal(_lO_,cst_Normal))
            if(caml_string_notequal(_lO_,cst_Subnormal))
             {if(! caml_string_notequal(_lO_,cst_Zero$3))switch$0 = 5}
            else
             switch$0 = 4;
           else
            switch$0 = 3;
          else
           switch$0 = 2;
         else
          switch$0 = 1;
        switch(switch$0)
         {case 1:return 0;
          case 2:return 1;
          case 3:return 2;
          case 4:return 3;
          case 5:return 4
          }}
      else
       {var _lQ_=sexp_007[1];
        if(! _lQ_)
         return caml_call2
                 (Sexplib0_Sexp_conv_error[7],error_source_006$0,sexp_007);
        var _lR_=_lQ_[1];
        if(0 !== _lR_[0])
         return caml_call2
                 (Sexplib0_Sexp_conv_error[6],error_source_006$0,sexp_007);
        var
         _lS_=_lR_[1],
         _lT_=caml_string_compare(_lS_,cst_infinite$0),
         switch$1=0;
        if(0 <= _lT_)
         if(0 < _lT_)
          if(caml_string_notequal(_lS_,cst_nan$2))
           if(caml_string_notequal(_lS_,cst_normal$0))
            if(caml_string_notequal(_lS_,cst_subnormal$0))
             {if(! caml_string_notequal(_lS_,cst_zero$4))switch$1 = 5}
            else
             switch$1 = 4;
           else
            switch$1 = 3;
          else
           switch$1 = 2;
         else
          switch$1 = 1;
        else
         if(caml_string_notequal(_lS_,cst_Infinite$0))
          if(caml_string_notequal(_lS_,cst_Nan$2))
           if(caml_string_notequal(_lS_,cst_Normal$0))
            if(caml_string_notequal(_lS_,cst_Subnormal$0))
             {if(! caml_string_notequal(_lS_,cst_Zero$4))switch$1 = 5}
            else
             switch$1 = 4;
           else
            switch$1 = 3;
          else
           switch$1 = 2;
         else
          switch$1 = 1;
        switch(switch$1)
         {case 1:
           return caml_call2
                   (Sexplib0_Sexp_conv_error[3],error_source_006$0,sexp_007);
          case 2:
           return caml_call2
                   (Sexplib0_Sexp_conv_error[3],error_source_006$0,sexp_007);
          case 3:
           return caml_call2
                   (Sexplib0_Sexp_conv_error[3],error_source_006$0,sexp_007);
          case 4:
           return caml_call2
                   (Sexplib0_Sexp_conv_error[3],error_source_006$0,sexp_007);
          case 5:
           return caml_call2
                   (Sexplib0_Sexp_conv_error[3],error_source_006$0,sexp_007)
          }}
      return caml_call2
              (Sexplib0_Sexp_conv_error[8],error_source_006$0,sexp_007)}
    function sexp_of_t$64(param)
     {switch(param)
       {case 0:return _iv_;
        case 1:return _iw_;
        case 2:return _ix_;
        case 3:return _iy_;
        default:return _iz_}}
    function to_string$27(t){return caml_call1(t_of_sexp$2,sexp_of_t$64(t))}
    function of_string$25(s){return t_of_sexp$38(caml_call1(sexp_of_t$2,s))}
    function classify(t)
     {var match=caml_classify_float(t);
      switch(match)
       {case 0:return 2;
        case 1:return 3;
        case 2:return 4;
        case 3:return 0;
        default:return 1}}
    function insert_underscores$0(opt,_lN_,string)
     {if(opt)var sth=opt[1],delimiter=sth;else var delimiter=95;
      if(_lN_)var sth$0=_lN_[1],strip_zero=sth$0;else var strip_zero=0;
      var match=lsplit2(string,46);
      if(! match)return insert_delimiter(string,delimiter);
      var
       match$0=match[1],
       right=match$0[2],
       left=match$0[1],
       left$0=insert_delimiter(left,delimiter),
       right$0=
        strip_zero
         ?rstrip([0,function(c){return caml_call2(symbol$107,c,48)}],right)
         :right;
      return caml_string_notequal(right$0,cst$38)
              ?caml_call2
                (symbol$59,left$0,caml_call2(symbol$59,cst$39,right$0))
              :left$0}
    function to_string_hum$6(delimiter,opt,strip_zero,_lM_,f)
     {if(opt)var sth=opt[1],decimals=sth;else var decimals=3;
      if(_lM_)var sth$0=_lM_[1],explicit_plus=sth$0;else var explicit_plus=0;
      if(decimals < 0)caml_call2(invalid_argf(_iA_),decimals,0);
      var match=classify(f);
      if(1 === match)return cst_nan$3;
      if(! match)return caml_call2(include$7[5],f,0.)?cst_inf:cst_inf$0;
      var
       s=
        explicit_plus
         ?caml_call3(sprintf,_iB_,decimals,f)
         :caml_call3(sprintf,_iC_,decimals,f);
      return insert_underscores$0(delimiter,strip_zero,s)}
    function sexp_of_float(t)
     {var sexp=caml_call1(sexp_of_t$5,t);
      if(1009018843 <= of_float_style[1])return sexp;
      if(0 !== sexp[0])
       return raise_s
               (caml_call2
                 (message,
                  cst_sexp_of_float_produced_str,
                  [0,[0,cst_sexp,caml_call1(sexp_of_t,sexp)],0]));
      var string=sexp[1];
      return contains(0,0,string,69)?sexp:[0,insert_underscores$0(0,0,string)]}
    function to_padded_compact_string_custo
     (t,opt,kilo,mega,giga,tera,peta,param)
     {if(opt)var sth=opt[1],prefix=sth;else var prefix=cst$41;
      var match=classify(t);
      if(1 === match)return cst_nan$4;
      if(! match)return caml_call2(include$7[1],t,0.)?cst_inf$1:cst_inf$2;
      function go(t)
       {function conv(mag,t,denominator)
         {var switch$0=0;
          if
           (caml_call2(include$7[4],denominator,100.)
            &&
            caml_call2(include$7[6],t,999.95))
           switch$0 = 1;
          if(! switch$0)
           {var switch$1=0;
            if(caml_call2(include$7[6],denominator,100000.))
             {var _lL_=round_nearest$4(denominator * 9.9995);
              if(! caml_call2(include$7[6],t,_lL_))switch$1 = 1}
            else
             switch$1 = 1;
            if(switch$1)throw [0,Assert_failure$0,_iJ_]}
          var _lK_=round_nearest$4(denominator * 9999.5);
          if(! caml_call2(include$7[1],t,_lK_))
           throw [0,Assert_failure$0,_iI_];
          var
           k=Math.floor(t / denominator),
           lower=denominator * k,
           higher=denominator * (k + 1.),
           diff_right=higher - t,
           diff_left=t - lower,
           k$0=iround_nearest_exn(k),
           k$1=
            caml_call2(include$7[1],diff_right,diff_left)
             ?k$0 + 1 | 0
             :caml_call2(include$7[5],diff_right,diff_left)
               ?k$0
               :0 === (k$0 % 2 | 0)?k$0:k$0 + 1 | 0,
           d=k$1 % 10 | 0,
           i=k$1 / 10 | 0;
          if(0 <= i && 1000 > i)
           {if(0 <= d && 10 > d)
             return 0 === d
                     ?caml_call4(sprintf,_iG_,prefix,i,mag)
                     :caml_call5(sprintf,_iH_,prefix,i,mag,d);
            throw [0,Assert_failure$0,_iF_]}
          throw [0,Assert_failure$0,_iE_]}
        if(! caml_call2(include$7[1],t,999.95))
         {if(caml_call2(include$7[1],t,999950.))return conv(kilo,t,100.);
          if(caml_call2(include$7[1],t,999950000.))
           return conv(mega,t,100000.);
          if(caml_call2(include$7[1],t,999950000000.))
           return conv(giga,t,100000000.);
          if(caml_call2(include$7[1],t,999950000000000.))
           return conv(tera,t,100000000000.);
          if(! peta)return caml_call3(sprintf,_iL_,prefix,t);
          var peta$0=peta[1];
          return caml_call2(include$7[1],t,999950000000000000.)
                  ?conv(peta$0,t,100000000000000.)
                  :caml_call3(sprintf,_iK_,prefix,t)}
        if(caml_call2(include$7[2],0.,t) && caml_call2(include$7[1],t,999.95))
         {var x=caml_call2(symbol$59,prefix,caml_format_float(cst_1f,t));
          if(! is_suffix$1(x,cst_0))return x;
          var x$0=caml_call1(of_string$1,x),n=caml_ml_bytes_length(x$0);
          caml_bytes_set(x$0,n - 1 | 0,32);
          caml_bytes_set(x$0,n - 2 | 0,32);
          return unsafe_to_string(x$0)}
        throw [0,Assert_failure$0,_iD_]}
      return caml_call2(include$7[6],t,0.)
              ?go(t)
              :caml_call2(symbol$59,cst$40,go(- t))}
    function to_padded_compact_string(t)
     {return to_padded_compact_string_custo
              (t,0,cst_k,cst_m,cst_g,cst_t$3,_iM_,0)}
    function int_pow$0(x,n)
     {if(0 === n)return 1.;
      var x$0=[0,x - 0.],n$0=[0,n],accum=[0,1.];
      if(n$0[1] < 0)
       {x$0[1] = 1. / x$0[1];
        n$0[1] = - n$0[1] | 0;
        if(n$0[1] < 0){accum[1] = x$0[1];decr(n$0)}}
      for(;;)
       {if(1 >= n$0[1])return x$0[1] * accum[1];
        if(0 !== (n$0[1] & 1))accum[1] = x$0[1] * accum[1];
        x$0[1] = x$0[1] * x$0[1];
        n$0[1] = n$0[1] >>> 1 | 0}}
    function round_gen(x,how)
     {if(caml_call2(include$7[4],x,0.))return 0.;
      if(! is_finite(x))return x;
      if(555917426 <= how[1])
       var
        sd=how[2],
        dd=sd - to_int$3(Math.ceil(caml_log10_float(Math.abs(x)))) | 0,
        dd$0=dd,
        sd$0=sd;
      else
       var
        dd$1=how[2],
        sd$1=dd$1 + to_int$3(Math.ceil(caml_log10_float(Math.abs(x)))) | 0,
        dd$0=dd$1,
        sd$0=sd$1;
      if(0 > sd$0)return 0.;
      if(17 <= sd$0)return x;
      var abs_dd=abs$2(dd$0);
      if(22 >= abs_dd && 16 > sd$0)
       {var order=int_pow$0(10.,abs_dd);
        return 0 <= dd$0
                ?round_nearest_half_to_even(x * order) / order
                :round_nearest_half_to_even(x / order) * order}
      return of_string$24(caml_call3(sprintf,_iN_,sd$0,x))}
    function round_significant(x,significant_digits)
     {return 0 < significant_digits
              ?round_gen(x,[0,555917426,significant_digits])
              :caml_call2(invalid_argf(_iO_),significant_digits,0)}
    function round_decimal(x,decimal_digits)
     {return round_gen(x,[0,-352548012,decimal_digits])}
    function between$16(t,low,high)
     {var _lJ_=caml_call2(include$7[2],low,t);
      return _lJ_?caml_call2(include$7[2],t,high):_lJ_}
    function clamp_exn$16(t,min,max)
     {if(caml_call2(include$7[2],min,max))return clamp_unchecked(t,min,max);
      throw [0,Assert_failure$0,_iP_]}
    function clamp$16(t,min,max)
     {if(caml_call2(include$7[2],min,max))
       return [0,clamp_unchecked(t,min,max)];
      var _lI_=[0,[0,cst_max$9,caml_call1(sexp_of_t$5,max)],0];
      return error_s
              (caml_call2
                (message,
                 cst_clamp_requires_min_max$9,
                 [0,[0,cst_min$9,caml_call1(sexp_of_t$5,min)],_lI_]))}
    function sign_exn(t)
     {return caml_call2(include$7[5],t,0.)
              ?2
              :caml_call2(include$7[1],t,0.)
                ?0
                :caml_call2(include$7[4],t,0.)
                  ?1
                  :raise_s
                    (caml_call2
                      (message,
                       cst_Float_sign_exn_of_NAN,
                       [0,[0,cst$42,sexp_of_float(t)],0]))}
    function sign_or_nan(t)
     {return caml_call2(include$7[5],t,0.)
              ?2
              :caml_call2(include$7[1],t,0.)
                ?0
                :caml_call2(include$7[4],t,0.)?1:3}
    function ieee_negative(t)
     {var bits=caml_int64_bits_of_float(t);
      return caml_lessthan(bits,Stdlib_Int64[1])}
    var
     exponent_mask64=caml_int64_sub(caml_int64_shift_left(one$1,11),one$1),
     exponent_mask=int64_to_int_exn(exponent_mask64),
     mantissa_mask=_gP_(_hh_(_gM_,52),_gM_),
     mantissa_mask64=_ho_(mantissa_mask);
    function ieee_exponent(t)
     {var bits=caml_int64_bits_of_float(t);
      return caml_int64_to_int32
              (caml_int64_and
                (caml_int64_shift_right_unsigne(bits,52),exponent_mask64))}
    function ieee_mantissa(t)
     {var bits=caml_int64_bits_of_float(t);
      return _hn_(caml_int64_and(bits,mantissa_mask64))}
    function create_ieee_exn(negative,exponent,mantissa)
     {if((exponent & exponent_mask) !== exponent)
       return caml_call3(failwithf(_iQ_),exponent,exponent_mask,0);
      if(_gq_(_hc_(mantissa,mantissa_mask),mantissa))
       {var
         _lG_=caml_call1(_gk_,mantissa_mask),
         _lH_=caml_call1(_gk_,mantissa);
        return caml_call3(failwithf(_iR_),_lH_,_lG_,0)}
      var
       sign_bits=negative?Stdlib_Int64[10]:Stdlib_Int64[1],
       expt_bits=caml_int64_shift_left(caml_int64_of_int32(exponent),52),
       mant_bits=_ho_(mantissa),
       bits=caml_int64_or(sign_bits,caml_int64_or(expt_bits,mant_bits));
      return caml_int64_float_of_bits(bits)}
    function create_ieee(negative,exponent,mantissa)
     {return try_with$0
              (0,
               function(param)
                {return create_ieee_exn(negative,exponent,mantissa)})}
    function to_string$28(x){return caml_call2(sprintf,_iS_,x)}
    function sexp_of_t$65(x){return [0,to_string$28(x)]}
    function of_string$26(x){return of_string$24(x)}
    var
     include$87=_aY_([0,compare$62,sexp_of_t$5,zero$6]),
     sign$4=include$87[5];
    function is_positive$4(t){return caml_call2(include$7[5],t,0.)}
    function is_non_negative$4(t){return caml_call2(include$7[6],t,0.)}
    function is_negative$4(t){return caml_call2(include$7[1],t,0.)}
    function is_non_positive$4(t){return caml_call2(include$7[2],t,0.)}
    var
     include$88=_w_([0,module_name$20,to_string$26]),
     pp$19=include$88[1],
     symbol$238=include$7[3],
     symbol$239=include$7[1],
     symbol$240=include$7[5],
     symbol$241=include$7[4],
     symbol$242=include$7[2],
     symbol$243=include$7[6];
    function of_float$5(x){return x}
    var
     Private$7=
      [0,
       box,
       clamp_unchecked,
       lower_bound_for_int,
       upper_bound_for_int,
       specialized_hash,
       one_ulp_less_than_half,
       int63_round_nearest_portable_a,
       int63_round_nearest_arch64_noa,
       iround_nearest_exn_64],
     symbol$244=include$7[1],
     symbol$245=include$7[2],
     symbol$246=include$7[3],
     symbol$247=include$7[4],
     symbol$248=include$7[5],
     symbol$249=include$7[6],
     ascending$29=include$7[7],
     descending$30=include$7[8],
     compare_float$1=include$7[9],
     equal_float$1=include$7[10];
    function min$36(x,y)
     {if(! caml_call2(symbol$244,x,y) && ! is_nan(x))return y;return x}
    function max$37(x,y)
     {if(! caml_call2(symbol$248,x,y) && ! is_nan(x))return y;return x}
    var
     include$89=[0,add,sub,scale,symbol$9,symbol$85,symbol$84,neg$0],
     Base_Float=
      [0,
       t_sexp_grammar$4,
       of_float$4,
       to_float$5,
       hash_fold_t$7,
       hash$24,
       t_of_sexp$5,
       sexp_of_float,
       of_string$24,
       symbol$249,
       symbol$245,
       symbol$247,
       symbol$248,
       symbol$244,
       symbol$246,
       equal_float$1,
       compare_float$1,
       min$36,
       max$37,
       ascending$29,
       descending$30,
       between$16,
       clamp_exn$16,
       clamp$16,
       _ie_,
       pp$19,
       hashable$14,
       is_positive$4,
       is_non_negative$4,
       is_negative$4,
       is_non_positive$4,
       invariant$25,
       nan$1,
       infinity$1,
       neg_infinity$1,
       infinity$1,
       neg_infinity$1,
       zero$6,
       one$5,
       minus_one$4,
       pi,
       sqrt_pi,
       sqrt_2pi,
       euler,
       epsilon_float$1,
       max_finite_value,
       min_positive_subnormal_value,
       min_positive_normal_value,
       to_int64_preserve_order,
       to_int64_preserve_order_exn,
       of_int64_preserve_order,
       one_ulp,
       of_int$2,
       to_int$3,
       of_int63,
       of_int64$0,
       to_int64$1,
       round$4,
       iround,
       iround_exn,
       round_towards_zero$4,
       floor,
       ceil,
       round_nearest$4,
       round_nearest_half_to_even,
       iround_towards_zero,
       iround_down,
       iround_up,
       iround_nearest_64$0,
       iround_towards_zero_exn,
       iround_down_exn,
       iround_up_exn,
       iround_nearest_exn,
       int63_round_down_exn,
       int63_round_up_exn,
       int63_round_nearest_exn,
       iround_lbound,
       iround_ubound,
       int63_round_lbound,
       int63_round_ubound,
       round_significant,
       round_decimal,
       is_nan,
       is_inf,
       is_finite,
       is_integer,
       min_inan,
       max_inan,
       add,
       sub,
       symbol$9,
       symbol$85,
       scale,
       symbol$84,
       neg$0,
       [0,fractional,integral],
       modf,
       mod_float,
       add,
       sub,
       neg$0,
       scale,
       abs_float,
       [0,
        add,
        sub,
        scale,
        symbol$9,
        symbol$85,
        symbol$84,
        neg$0,
        symbol$243,
        symbol$242,
        symbol$241,
        symbol$240,
        symbol$239,
        symbol$238,
        abs_float,
        neg$0,
        zero$6,
        of_int$2,
        of_float$5],
       include$89,
       to_string$26,
       to_string_hum$6,
       to_padded_compact_string,
       to_padded_compact_string_custo,
       int_pow$0,
       square,
       ldexp,
       frexp,
       [0,
        compare$63,
        all$21,
        t_of_sexp$38,
        sexp_of_t$64,
        t_sexp_grammar$34,
        of_string$25,
        to_string$27],
       classify,
       sign$4,
       sign_exn,
       sign_or_nan,
       create_ieee,
       create_ieee_exn,
       ieee_negative,
       ieee_exponent,
       ieee_mantissa,
       [0,t_of_sexp$5,sexp_of_t$65,t_sexp_grammar$4,of_string$26,to_string$28],
       Private$7];
    caml_register_global(1129,Base_Float,"Base__Float");
    var Base_Fieldslib=[0];
    caml_register_global(1130,Base_Fieldslib,"Base__Fieldslib");
    var Base_Buffer_intf=[0];
    caml_register_global(1131,Base_Buffer_intf,"Base__Buffer_intf");
    var
     create$21=Stdlib_Buffer[1],
     contents=Stdlib_Buffer[2],
     to_bytes=Stdlib_Buffer[3],
     nth$8=Stdlib_Buffer[6],
     length$23=Stdlib_Buffer[7],
     clear$4=Stdlib_Buffer[8],
     reset$0=Stdlib_Buffer[9],
     add_char=Stdlib_Buffer[12],
     add_string=Stdlib_Buffer[16],
     add_bytes=Stdlib_Buffer[17],
     add_buffer=Stdlib_Buffer[21],
     _iT_=Stdlib_Buffer[18],
     _iU_=Stdlib_Buffer[19];
    function add_substring(t,s,pos,len){return caml_call4(_iT_,t,s,pos,len)}
    function add_subbytes(t,s,pos,len){return caml_call4(_iU_,t,s,pos,len)}
    function sexp_of_t$66(t)
     {return caml_call1(sexp_of_t$2,caml_call1(contents,t))}
    var create$22=caml_create_bytes,length$24=caml_ml_bytes_length;
    function unsafe_blit$9(src,src_pos,dst,dst_pos,len)
     {return caml_call5(Stdlib_Buffer[5],src,src_pos,dst,dst_pos,len)}
    var
     To_bytes$0=_a5_([0,length$23],[0,length$24,create$22,unsafe_blit$9]),
     blit$6=To_bytes$0[1],
     blito$4=To_bytes$0[2],
     unsafe_blit$10=To_bytes$0[3],
     sub$11=To_bytes$0[4],
     subo$5=To_bytes$0[5],
     To_string$0=Make_to_string([0],To_bytes$0),
     Base_Buffer=
      [0,
       sexp_of_t$66,
       create$21,
       contents,
       to_bytes,
       blit$6,
       blito$4,
       unsafe_blit$10,
       sub$11,
       subo$5,
       To_string$0,
       nth$8,
       length$23,
       clear$4,
       reset$0,
       add_char,
       add_string,
       add_substring,
       add_bytes,
       add_subbytes,
       add_buffer];
    caml_register_global(1133,Base_Buffer,"Base__Buffer");
    var elide=[0,0];
    function get$6(opt,param)
     {if(opt)
       var sth=opt[1],at_most_num_frames=sth;
      else
       var at_most_num_frames=max_value$2;
      return runtime.caml_get_current_callstack(at_most_num_frames)}
    function to_string$29(t)
     {return elide[1]?elided_message:caml_call1(Stdlib_Printexc[14],t)}
    function to_string_list(t){return split_lines(to_string$29(t))}
    function sexp_of_t$67(t)
     {function _lF_(x){return [0,x]}return [1,map$9(to_string_list(t),_lF_)]}
    var set_recording=Stdlib_Printexc[7],am_recording=Stdlib_Printexc[8];
    function most_recent(param){return caml_call1(Stdlib_Printexc[12],0)}
    function most_recent_for_exn(exn)
     {return runtime.Base_caml_exn_is_most_recent_exn(exn)
              ?[0,most_recent(0)]
              :0}
    function with_recording(b,f)
     {var saved=caml_call1(am_recording,0);
      caml_call1(set_recording,b);
      return protect
              (f,function(param){return caml_call1(set_recording,saved)})}
    function initialize_module$0(param)
     {var match=getenv(cst_OCAMLRUNPARAM);
      if(match)
       var
        x=match[1],
        _lC_=function(_lE_){return is_prefix$1(_lE_,cst_b)},
        ocamlrunparam_mentions_backtra=exists(split(x,44),_lC_);
      else
       var ocamlrunparam_mentions_backtra=0;
      var _lD_=1 - ocamlrunparam_mentions_backtra;
      return _lD_?caml_call1(set_recording,1):_lD_}
    var
     Base_Backtrace=
      [0,
       sexp_of_t$67,
       get$6,
       to_string$29,
       to_string_list,
       elide,
       [0,
        am_recording,
        set_recording,
        with_recording,
        most_recent,
        most_recent_for_exn],
       initialize_module$0];
    caml_register_global(1134,Base_Backtrace,"Base__Backtrace");
    var
     Exit$1=include$0[3],
     Not_found$1=include$0[4],
     max_int$1=include$0[8],
     min_int$1=include$0[9],
     infinity$2=include$0[11],
     neg_infinity$2=include$0[12],
     nan$2=include$0[13],
     max_float$1=include$0[14],
     min_float$1=include$0[15],
     epsilon_float$2=include$0[16],
     char_of_int$1=include$0[18],
     string_of_bool$1=include$0[19],
     bool_of_string_opt$1=include$0[20],
     bool_of_string$1=include$0[21],
     string_of_int$1=include$0[22],
     int_of_string_opt$1=include$0[23],
     string_of_float$1=include$0[24],
     float_of_string_opt$1=include$0[25],
     stdin$1=include$0[27],
     stdout$1=include$0[28],
     stderr$1=include$0[29],
     print_char$1=include$0[30],
     print_string$1=include$0[31],
     print_bytes$1=include$0[32],
     print_int$1=include$0[33],
     print_float$1=include$0[34],
     print_endline$1=include$0[35],
     print_newline$1=include$0[36],
     prerr_char$1=include$0[37],
     prerr_string$1=include$0[38],
     prerr_bytes$1=include$0[39],
     prerr_int$1=include$0[40],
     prerr_float$1=include$0[41],
     prerr_endline$1=include$0[42],
     prerr_newline$1=include$0[43],
     read_line$1=include$0[44],
     read_int_opt$1=include$0[45],
     read_int$1=include$0[46],
     read_float_opt$1=include$0[47],
     read_float$1=include$0[48],
     open_out$1=include$0[49],
     open_out_bin$1=include$0[50],
     open_out_gen$1=include$0[51],
     flush$1=include$0[52],
     flush_all$1=include$0[53],
     output_char$1=include$0[54],
     output_string$1=include$0[55],
     output_bytes$1=include$0[56],
     output$1=include$0[57],
     output_substring$1=include$0[58],
     output_byte$1=include$0[59],
     output_binary_int$1=include$0[60],
     output_value$1=include$0[61],
     seek_out$1=include$0[62],
     pos_out$1=include$0[63],
     out_channel_length$1=include$0[64],
     close_out$1=include$0[65],
     close_out_noerr$1=include$0[66],
     set_binary_mode_out$1=include$0[67],
     open_in$1=include$0[68],
     open_in_bin$1=include$0[69],
     open_in_gen$1=include$0[70],
     input_char$1=include$0[71],
     input_line$1=include$0[72],
     input$1=include$0[73],
     really_input$1=include$0[74],
     really_input_string$1=include$0[75],
     input_byte$1=include$0[76],
     input_binary_int$1=include$0[77],
     input_value$1=include$0[78],
     seek_in$1=include$0[79],
     pos_in$1=include$0[80],
     in_channel_length$1=include$0[81],
     close_in$1=include$0[82],
     close_in_noerr$1=include$0[83],
     set_binary_mode_in$1=include$0[84],
     string_of_format$1=include$0[85],
     symbol$250=include$0[86],
     exit$1=include$0[87],
     at_exit$1=include$0[88],
     valid_float_lexem$1=include$0[89],
     unsafe_really_input$1=include$0[90],
     do_at_exit$1=include$0[91],
     Sexp$0=
      [0,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       Not_found_s,
       Of_sexp_error,
       message,
       default_indent,
       pp_hum,
       pp_hum_indent,
       pp_mach,
       pp,
       to_string_hum,
       to_string_mach,
       to_string$0,
       of_float_style,
       of_int_style,
       t_sexp_grammar,
       invariant,
       of_string$0,
       symbol$159,
       symbol$160,
       symbol$161,
       symbol$162,
       symbol$163,
       symbol$164,
       equal$29,
       compare$44,
       min$29,
       max$29,
       ascending$23,
       descending$23,
       between$9,
       clamp_exn$9,
       clamp$9,
       comparator$11],
     Exported_for_specific_uses=[0,am_testing];
    function array_sexp_grammar$0(a_sexp_grammar)
     {return t_sexp_grammar$20(a_sexp_grammar)}
    function hash_bool$0(x){return hash$22(x)}
    function hash_char(x){return caml_call1(_bE_,x)}
    function hash_float(x){return hash$24(x)}
    function hash_int$0(x){return func$8(x)}
    function hash_int32$0(x){return func$12(x)}
    function hash_int64$0(x){return func$10(x)}
    function list_sexp_grammar$0(a_sexp_grammar)
     {return t_sexp_grammar$12(a_sexp_grammar)}
    function hash_nativeint$0(x){return func$9(x)}
    function option_sexp_grammar$0(a_sexp_grammar)
     {return t_sexp_grammar$18(a_sexp_grammar)}
    function ref_sexp_grammar$0(a_sexp_grammar)
     {return t_sexp_grammar$28(a_sexp_grammar)}
    function hash_string$0(x){return runtime.Base_hash_string(x)}
    function hash_unit$0(x){return caml_call1(func$7,x)}
    var
     symbol$251=Infix[1],
     symbol$252=O$0[1],
     lnot$5=O$0[2],
     abs$8=O$0[3],
     zero$7=O$0[4],
     symbol$253=O$0[5],
     symbol$254=O$0[6],
     symbol$255=O$0[7],
     ascending$30=include$1[1],
     descending$31=include$1[2],
     max$38=include$1[3],
     min$37=include$1[4],
     symbol$256=include$89[1],
     symbol$257=include$89[2],
     symbol$258=include$89[3],
     symbol$259=include$89[4],
     symbol$260=include$89[5],
     symbol$261=include$89[6],
     symbol$262=include$89[7],
     Export$1=
      [0,
       compare_array$0,
       equal_array$1,
       array_of_sexp,
       sexp_of_array,
       array_sexp_grammar$0,
       compare_bool$0,
       equal_bool$1,
       hash_fold_t$5,
       hash_bool$0,
       t_of_sexp$1,
       sexp_of_t$1,
       t_sexp_grammar$0,
       compare_char$0,
       equal_char$1,
       _bD_,
       hash_char,
       _bF_,
       _bG_,
       t_sexp_grammar$2,
       sexp_of_exn,
       compare_float$1,
       equal_float$1,
       hash_fold_t$7,
       hash_float,
       t_of_sexp$5,
       sexp_of_float,
       t_sexp_grammar$4,
       compare_int$0,
       equal_int$1,
       hash_fold_t$4,
       hash_int$0,
       t_of_sexp$4,
       sexp_of_t$33,
       t_sexp_grammar$3,
       compare_int32$0,
       equal_int32$1,
       hash_fold_t$2,
       hash_int32$0,
       t_of_sexp$6,
       sexp_of_int32,
       t_sexp_grammar$5,
       compare_int64$0,
       equal_int64$1,
       hash_fold_t$1,
       hash_int64$0,
       t_of_sexp$7,
       sexp_of_int64,
       t_sexp_grammar$6,
       compare_list$1,
       equal_list$1,
       hash_fold_t$9,
       t_of_sexp$10,
       sexp_of_t$10,
       list_sexp_grammar$0,
       compare_nativeint$0,
       equal_nativeint$1,
       hash_fold_t$0,
       hash_nativeint$0,
       t_of_sexp$8,
       sexp_of_t$53,
       t_sexp_grammar$7,
       compare_option$0,
       equal_option$1,
       hash_fold_option$0,
       option_of_sexp,
       sexp_of_option,
       option_sexp_grammar$0,
       compare_ref$0,
       equal_ref$0,
       ref_of_sexp,
       sexp_of_ref,
       ref_sexp_grammar$0,
       compare_string$1,
       equal_string$1,
       hash_fold_t$6,
       hash_string$0,
       t_of_sexp$2,
       sexp_of_t$2,
       t_sexp_grammar$1,
       compare_bytes,
       equal_bytes,
       bytes_of_sexp,
       sexp_of_bytes,
       bytes_sexp_grammar,
       compare_unit$1,
       equal_unit$1,
       hash_fold_unit$0,
       hash_unit$0,
       unit_of_sexp,
       sexp_of_unit,
       unit_sexp_grammar,
       symbol$251,
       symbol$252,
       lnot$5,
       abs$8,
       zero$7,
       symbol$253,
       symbol$254,
       symbol$255,
       ascending$30,
       descending$31,
       max$38,
       min$37,
       symbol$256,
       symbol$257,
       symbol$258,
       symbol$259,
       symbol$260,
       symbol$261,
       symbol$262,
       symbol$59,
       get_key,
       get_data,
       failwith$0,
       invalid_arg$0,
       raise_s,
       phys_equal],
     _iV_=Export$1[1],
     _iW_=Export$1[2],
     _iX_=Export$1[3],
     _iY_=Export$1[4],
     _iZ_=Export$1[5],
     _i0_=Export$1[6],
     _i1_=Export$1[7],
     _i2_=Export$1[8],
     _i3_=Export$1[9],
     _i4_=Export$1[10],
     _i5_=Export$1[11],
     _i6_=Export$1[12],
     _i7_=Export$1[13],
     _i8_=Export$1[14],
     _i9_=Export$1[15],
     _i__=Export$1[16],
     _i$_=Export$1[17],
     _ja_=Export$1[18],
     _jb_=Export$1[19],
     _jc_=Export$1[20],
     _jd_=Export$1[21],
     _je_=Export$1[22],
     _jf_=Export$1[23],
     _jg_=Export$1[24],
     _jh_=Export$1[25],
     _ji_=Export$1[26],
     _jj_=Export$1[27],
     _jk_=Export$1[28],
     _jl_=Export$1[29],
     _jm_=Export$1[30],
     _jn_=Export$1[31],
     _jo_=Export$1[32],
     _jp_=Export$1[33],
     _jq_=Export$1[34],
     _jr_=Export$1[35],
     _js_=Export$1[36],
     _jt_=Export$1[37],
     _ju_=Export$1[38],
     _jv_=Export$1[39],
     _jw_=Export$1[40],
     _jx_=Export$1[41],
     _jy_=Export$1[42],
     _jz_=Export$1[43],
     _jA_=Export$1[44],
     _jB_=Export$1[45],
     _jC_=Export$1[46],
     _jD_=Export$1[47],
     _jE_=Export$1[48],
     _jF_=Export$1[49],
     _jG_=Export$1[50],
     _jH_=Export$1[51],
     _jI_=Export$1[52],
     _jJ_=Export$1[53],
     _jK_=Export$1[54],
     _jL_=Export$1[55],
     _jM_=Export$1[56],
     _jN_=Export$1[57],
     _jO_=Export$1[58],
     _jP_=Export$1[59],
     _jQ_=Export$1[60],
     _jR_=Export$1[61],
     _jS_=Export$1[62],
     _jT_=Export$1[63],
     _jU_=Export$1[64],
     _jV_=Export$1[65],
     _jW_=Export$1[66],
     _jX_=Export$1[67],
     _jY_=Export$1[68],
     _jZ_=Export$1[69],
     _j0_=Export$1[70],
     _j1_=Export$1[71],
     _j2_=Export$1[72],
     _j3_=Export$1[73],
     _j4_=Export$1[74],
     _j5_=Export$1[75],
     _j6_=Export$1[76],
     _j7_=Export$1[77],
     _j8_=Export$1[78],
     _j9_=Export$1[79],
     _j__=Export$1[80],
     _j$_=Export$1[81],
     _ka_=Export$1[82],
     _kb_=Export$1[83],
     _kc_=Export$1[84],
     _kd_=Export$1[85],
     _ke_=Export$1[86],
     _kf_=Export$1[87],
     _kg_=Export$1[88],
     _kh_=Export$1[89],
     _ki_=Export$1[90],
     _kj_=Export$1[91],
     _kk_=Export$1[92],
     _kl_=Export$1[93],
     _km_=Export$1[94],
     _kn_=Export$1[95],
     _ko_=Export$1[96],
     _kp_=Export$1[97],
     _kq_=Export$1[98],
     _kr_=Export$1[99],
     _ks_=Export$1[100],
     _kt_=Export$1[101],
     _ku_=Export$1[102],
     _kv_=Export$1[103],
     _kw_=Export$1[104],
     _kx_=Export$1[105],
     _ky_=Export$1[106],
     _kz_=Export$1[107],
     _kA_=Export$1[108],
     _kB_=Export$1[109],
     _kC_=Export$1[110],
     _kD_=Export$1[111],
     _kE_=Export$1[112],
     _kF_=Export$1[113],
     _kG_=Export$1[114],
     _kH_=Export$1[115],
     _kI_=Export$1[116],
     _kJ_=Export$1[117],
     _kK_=include$27[1];
    initialize_module$0(0);
    var
     Base$0=
      [0,
       Exit$1,
       Not_found$1,
       max_int$1,
       min_int$1,
       infinity$2,
       neg_infinity$2,
       nan$2,
       max_float$1,
       min_float$1,
       epsilon_float$2,
       char_of_int$1,
       string_of_bool$1,
       bool_of_string_opt$1,
       bool_of_string$1,
       string_of_int$1,
       int_of_string_opt$1,
       string_of_float$1,
       float_of_string_opt$1,
       stdin$1,
       stdout$1,
       stderr$1,
       print_char$1,
       print_string$1,
       print_bytes$1,
       print_int$1,
       print_float$1,
       print_endline$1,
       print_newline$1,
       prerr_char$1,
       prerr_string$1,
       prerr_bytes$1,
       prerr_int$1,
       prerr_float$1,
       prerr_endline$1,
       prerr_newline$1,
       read_line$1,
       read_int_opt$1,
       read_int$1,
       read_float_opt$1,
       read_float$1,
       open_out$1,
       open_out_bin$1,
       open_out_gen$1,
       flush$1,
       flush_all$1,
       output_char$1,
       output_string$1,
       output_bytes$1,
       output$1,
       output_substring$1,
       output_byte$1,
       output_binary_int$1,
       output_value$1,
       seek_out$1,
       pos_out$1,
       out_channel_length$1,
       close_out$1,
       close_out_noerr$1,
       set_binary_mode_out$1,
       open_in$1,
       open_in_bin$1,
       open_in_gen$1,
       input_char$1,
       input_line$1,
       input$1,
       really_input$1,
       really_input_string$1,
       input_byte$1,
       input_binary_int$1,
       input_value$1,
       seek_in$1,
       pos_in$1,
       in_channel_length$1,
       close_in$1,
       close_in_noerr$1,
       set_binary_mode_in$1,
       string_of_format$1,
       symbol$250,
       exit$1,
       at_exit$1,
       valid_float_lexem$1,
       unsafe_really_input$1,
       do_at_exit$1,
       Sexp$0,
       Exported_for_specific_uses,
       Export$1,
       _iV_,
       _iW_,
       _iX_,
       _iY_,
       _iZ_,
       _i0_,
       _i1_,
       _i2_,
       _i3_,
       _i4_,
       _i5_,
       _i6_,
       _i7_,
       _i8_,
       _i9_,
       _i__,
       _i$_,
       _ja_,
       _jb_,
       _jc_,
       _jd_,
       _je_,
       _jf_,
       _jg_,
       _jh_,
       _ji_,
       _jj_,
       _jk_,
       _jl_,
       _jm_,
       _jn_,
       _jo_,
       _jp_,
       _jq_,
       _jr_,
       _js_,
       _jt_,
       _ju_,
       _jv_,
       _jw_,
       _jx_,
       _jy_,
       _jz_,
       _jA_,
       _jB_,
       _jC_,
       _jD_,
       _jE_,
       _jF_,
       _jG_,
       _jH_,
       _jI_,
       _jJ_,
       _jK_,
       _jL_,
       _jM_,
       _jN_,
       _jO_,
       _jP_,
       _jQ_,
       _jR_,
       _jS_,
       _jT_,
       _jU_,
       _jV_,
       _jW_,
       _jX_,
       _jY_,
       _jZ_,
       _j0_,
       _j1_,
       _j2_,
       _j3_,
       _j4_,
       _j5_,
       _j6_,
       _j7_,
       _j8_,
       _j9_,
       _j__,
       _j$_,
       _ka_,
       _kb_,
       _kc_,
       _kd_,
       _ke_,
       _kf_,
       _kg_,
       _kh_,
       _ki_,
       _kj_,
       _kk_,
       _kl_,
       _km_,
       _kn_,
       _ko_,
       _kp_,
       _kq_,
       _kr_,
       _ks_,
       _kt_,
       _ku_,
       _kv_,
       _kw_,
       _kx_,
       _ky_,
       _kz_,
       _kA_,
       _kB_,
       _kC_,
       _kD_,
       _kE_,
       _kF_,
       _kG_,
       _kH_,
       _kI_,
       _kJ_,
       _kK_,
       Not_found_s];
    caml_register_global(1135,Base$0,"Base");
    return}
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJiYXNlLmNtYS5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJtb2R1bGVfbmFtZSIsImVycm9yX3NvdXJjZV8wMTEiLCJlcnJvcl9zb3VyY2VfMDA1IiwiYWxsJDMiLCJlcnJvcl9zb3VyY2VfMDA1JDAiLCJ0X3NleHBfZ3JhbW1hciQxMSIsImVycm9yX3NvdXJjZV8wMjIiLCJ0X3NleHBfZ3JhbW1hciQxNCIsIm1vZHVsZV9uYW1lJDAiLCJ0X3NleHBfZ3JhbW1hciQxNSIsIm1vZHVsZV9uYW1lJDEiLCJlcnJvcl9zb3VyY2VfMDAzIiwidF9zZXhwX2dyYW1tYXIkMTciLCJhbGwkNiIsIm1vZHVsZV9uYW1lJDIiLCJhbGwkNyIsIm1vZHVsZV9uYW1lJDMiLCJhbGwkOCIsImFsbCQ5IiwiZXJyb3Jfc291cmNlXzAyNSIsIm1vZHVsZV9uYW1lJDQiLCJtb2R1bGVfbmFtZSQ1Iiwib2NhbWxfbGV4X3RhYmxlcyIsIm92ZXJmbG93X2JvdW5kX21heF9pbnQ2M19vbl9pbiIsIm92ZXJmbG93X2JvdW5kX21heF9pbnQ2NF92YWx1ZSIsIm0xIiwibTIiLCJtNCIsImgwMSIsIm1hc2siLCJtb2R1bGVfbmFtZSQ2IiwibW9kdWxlX25hbWUkNyIsIm1vZHVsZV9uYW1lJDgiLCJzb21lX3QiLCJlcnJvcl9zb3VyY2VfMDAzJDAiLCJ0X3NleHBfZ3JhbW1hciQyNSIsImFsbCQxNCIsIm1vZHVsZV9uYW1lJDkiLCJlcnJvcl9zb3VyY2VfMDA2IiwiZXJyb3Jfc291cmNlXzAyNyIsImludGVydmFsX2NvbXBhcmlzb25fc2V4cF9ncmFtbSIsImVycm9yX3NvdXJjZV8wNTciLCJhbGwkMTYiLCJhbGwkMTciLCJ0X3NleHBfZ3JhbW1hciQzMCIsIm1vZHVsZV9uYW1lJDEwIiwibW9kdWxlX25hbWUkMTEiLCJtb2R1bGVfbmFtZSQxMiIsImVtcHR5JDUiLCJuYW1lJDEiLCJuYW1lJDIiLCJtb2R1bGVfbmFtZSQxMyIsIm1vZHVsZV9uYW1lJDE0IiwibWFzayQwIiwibW9kdWxlX25hbWUkMTUiLCJtb2R1bGVfbmFtZSQxNiIsImFsbCQyMCIsIm1vZHVsZV9uYW1lJDE3IiwibW9kdWxlX25hbWUkMTgiLCJtb2R1bGVfbmFtZSQxOSIsImFsbCQyMSIsImVycm9yX3NvdXJjZV8wMDYkMCIsInRfc2V4cF9ncmFtbWFyJDM0IiwibW9kdWxlX25hbWUkMjAiLCJlbGlkZWRfbWVzc2FnZSIsIngiLCJ5Iiwic2NhbGUiLCJhZGQiLCJzdWIiLCJzeW1ib2wkOSIsInN5bWJvbCQ1OSIsIm5lZyIsIm5lZyQwIiwiZmFpbHdpdGgkMCIsImdldF9rZXkiLCJpbnZhbGlkX2FyZyQwIiwiZ2V0X2RhdGEiLCJwaHlzX2VxdWFsIiwiYW1fdGVzdGluZyIsImZhaWx3aXRoZiIsImZtdCIsInMiLCJpbnZhbGlkX2FyZ2YiLCJiYWNrZW5kX3R5cGUiLCJpbnRlcmFjdGl2ZSIsIm9zX3R5cGUiLCJ1bml4Iiwid2luMzIiLCJjeWd3aW4iLCJ3b3JkX3NpemVfaW5fYml0cyIsImJpZ19lbmRpYW4iLCJtYXhfbGVuZ3RoJDAiLCJydW50aW1lX3ZhcmlhbnQiLCJydW50aW1lX3BhcmFtZXRlcnMiLCJhcmd2IiwiZ2V0X2FyZ3YiLCJvY2FtbF92ZXJzaW9uIiwiZW5hYmxlX3J1bnRpbWVfd2FybmluZ3MiLCJydW50aW1lX3dhcm5pbmdzX2VuYWJsZWQiLCJnZXRlbnZfZXhuIiwidmFyJDAiLCJnZXRlbnYiLCJjcmVhdGUiLCJsZW4iLCJjcmVhdGVfZmxvYXRfdW5pbml0aWFsaXplZCIsImFwcGVuZCIsImJsaXQiLCJjb25jYXQiLCJjb3B5IiwiZmlsbCIsImluaXQiLCJtYWtlX21hdHJpeCIsIm9mX2xpc3QiLCJzdWIkMCIsInRvX2xpc3QiLCJmb2xkIiwidCIsImYiLCJmb2xkX3JpZ2h0IiwiaXRlciIsIml0ZXJpIiwibWFwIiwibWFwaSIsInN0YWJsZV9zb3J0IiwiY29tcGFyZSIsInN3YXAiLCJpIiwiaiIsImVsdF9pIiwiZWx0X2oiLCJ0b19pbnQiLCJ1bnNhZmVfb2ZfaW50IiwiaW50X2lzX29rIiwibWluX3ZhbHVlIiwibWF4X3ZhbHVlIiwib2ZfaW50Iiwib2ZfaW50X2V4biIsImVxdWFsJDciLCJ0MSIsInQyIiwib2Zfc3RyaW5nIiwidG9fZmxvYXQiLCJvZl9mbG9hdCIsIm1heF92YWx1ZSQwIiwibWluX3ZhbHVlJDAiLCJzdWNjIiwiaGRfZXhuIiwibGVuZ3RoIiwicmV2X2FwcGVuZCIsInRsX2V4biIsInVuemlwIiwiZXhpc3RzIiwiZXhpc3RzMl9vayIsImwxIiwibDIiLCJmb2xkX2xlZnQiLCJmb2xkMl9vayIsImZvcl9hbGwiLCJmb3JfYWxsMl9vayIsIml0ZXIkMCIsIml0ZXIyX29rIiwibm9udGFpbF9tYXAiLCJub250YWlsX21hcGkiLCJwYXJ0aXRpb24iLCJyZXZfbWFwIiwicmV2X21hcDJfb2siLCJzb3J0IiwibCIsInN0YWJsZV9zb3J0JDAiLCJyZXYiLCJyZXMiLCJyZXN0IiwiZm9sZF9yaWdodCQwIiwiYSIsImIiLCJoYXNoX2ZvbGRfdW5pdCIsImFzX2ludCIsImhhc2hfZm9sZF9pbnQzMiIsImhhc2hfZm9sZF9jaGFyIiwiaGFzaF9mb2xkX2Jvb2wiLCJoYXNoX2ZvbGRfbmF0aXZlaW50IiwiaGFzaF9mb2xkX29wdGlvbiIsImhhc2hfZm9sZF9lbGVtIiwiaGFzaF9mb2xkX2xpc3QiLCJzJDEiLCJsaXN0JDAiLCJzJDIiLCJsaXN0IiwieHMiLCJzJDAiLCJoYXNoX2ZvbGRfbGF6eV90IiwiaGFzaF9mb2xkX3JlZl9mcm96ZW4iLCJoYXNoX2ZvbGRfYXJyYXlfZnJvemVuIiwiYXJyYXkiLCJlIiwiaSQwIiwiaGFzaF9uYXRpdmVpbnQiLCJoYXNoX2ludDY0IiwiaGFzaF9pbnQzMiIsImhhc2hfY2hhciIsImhhc2hfaW50IiwiaGFzaF9ib29sIiwiaGFzaF9zdHJpbmciLCJoYXNoX2Zsb2F0IiwiaGFzaF91bml0Iiwic2VlZCIsIm9mX2ZvbGQiLCJoYXNoX2ZvbGRfdCIsInJ1biIsImZvbGRlciIsIm9wdCIsInN0aCIsImNvbXBhcmVfc3RhdGUiLCJzdGF0ZV90b19zdHJpbmciLCJzdGF0ZSIsImNyZWF0ZSQwIiwidCQwIiwidCQxIiwidCQyIiwidCQzIiwidCQ0IiwidCQ1IiwiY29tcGFyZV9hYnN0cmFjdCIsInR5cGVfbmFtZSIsImVxdWFsX2Fic3RyYWN0IiwiY29tcGFyZV9ib29sIiwiY29tcGFyZV9jaGFyIiwiY29tcGFyZV9mbG9hdCIsImNvbXBhcmVfaW50IiwiY29tcGFyZV9pbnQzMiIsImNvbXBhcmVfaW50NjQiLCJjb21wYXJlX25hdGl2ZWludCIsImNvbXBhcmVfc3RyaW5nIiwiY29tcGFyZV91bml0IiwiY29tcGFyZV9hcnJheSIsImNvbXBhcmVfZWx0IiwibGVuX2EiLCJsZW5fYiIsInJldCIsInIiLCJjb21wYXJlX2xpc3QiLCJhJDAiLCJiJDAiLCJ5cyIsImNvbXBhcmVfb3B0aW9uIiwiY29tcGFyZV9yZWYiLCJlcXVhbF9ib29sIiwiZXF1YWxfY2hhciIsImVxdWFsX2ludCIsImVxdWFsX2ludDMyIiwiZXF1YWxfaW50NjQiLCJlcXVhbF9uYXRpdmVpbnQiLCJlcXVhbF9zdHJpbmciLCJlcXVhbF91bml0IiwiZXF1YWxfZmxvYXQiLCJlcXVhbF9hcnJheSIsImVxdWFsX2VsdCIsImVxdWFsX2xpc3QiLCJlcXVhbF9vcHRpb24iLCJlcXVhbF9yZWYiLCJjb21wYXJlJDciLCJhXzAwMSIsImJfMDAyIiwiYl8wMDQiLCJiXzAwNiIsImhzdiIsImFyZyIsImEwIiwiaHN2JDAiLCJhMCQwIiwiaHN2JDEiLCJzZXhwX29mX3QkMCIsInNleHBfb2ZfdCQxIiwic2V4cF9vZl90JDIiLCJzZXhwX29mX2J5dGVzIiwic2V4cF9vZl90JDMiLCJzZXhwX29mX3QkNCIsInNleHBfb2ZfdCQ1Iiwic2V4cF9vZl90JDYiLCJzZXhwX29mX3QkNyIsInNleHBfb2ZfdCQ4Iiwic2V4cF9vZl9yZWYiLCJzZXhwX29mX3QkOSIsInNleHBfb2Zfb3B0aW9uIiwic2V4cF9vZl90JDEwIiwic2V4cF9vZl9hcnJheSIsInRfb2Zfc2V4cCQwIiwidF9vZl9zZXhwJDEiLCJ0X29mX3NleHAkMiIsImJ5dGVzX29mX3NleHAiLCJ0X29mX3NleHAkMyIsInRfb2Zfc2V4cCQ1IiwidF9vZl9zZXhwJDYiLCJ0X29mX3NleHAkNyIsInRfb2Zfc2V4cCQ4IiwicmVmX29mX3NleHAiLCJ0X29mX3NleHAkOSIsIm9wdGlvbl9vZl9zZXhwIiwidF9vZl9zZXhwJDEwIiwiYXJyYXlfb2Zfc2V4cCIsInVuaXRfc2V4cF9ncmFtbWFyIiwidF9zZXhwX2dyYW1tYXIkMCIsInRfc2V4cF9ncmFtbWFyJDEiLCJieXRlc19zZXhwX2dyYW1tYXIiLCJ0X3NleHBfZ3JhbW1hciQyIiwidF9zZXhwX2dyYW1tYXIkNCIsInRfc2V4cF9ncmFtbWFyJDUiLCJ0X3NleHBfZ3JhbW1hciQ2IiwidF9zZXhwX2dyYW1tYXIkNyIsInNleHBfb2ZfZXhuIiwiaGFzaF9mb2xkX3QkMCIsImhhc2hfZm9sZF90JDEiLCJoYXNoX2ZvbGRfdCQyIiwiaGFzaF9mb2xkX3QkMyIsImhhc2hfZm9sZF90JDUiLCJoYXNoX2ZvbGRfdCQ2IiwiaGFzaF9mb2xkX3QkNyIsImhhc2hfZm9sZF90JDgiLCJoYXNoX2ZvbGRfb3B0aW9uJDAiLCJoYXNoX2ZvbGRfdCQ5IiwiZnVuYyIsImZ1bmMkMCIsImZ1bmMkMSIsImZ1bmMkMiIsImZ1bmMkMyIsImZ1bmMkNCIsImZ1bmMkNSIsInNwZWNpYWxpemVkX2hhc2giLCJmdW5jJDYiLCJjb21wYXJlJDgiLCJjb21wYXJlJDkiLCJjb21wYXJlJDEwIiwiY29tcGFyZSQxMSIsImNvbXBhcmUkMTIiLCJjb21wYXJlJDEzIiwiY29tcGFyZV9hcnJheSQwIiwiY29tcGFyZV9vcHRpb24kMCIsImNvbXBhcmVfcmVmJDAiLCJlcXVhbF9yZWYkMCIsInNleHBfb2ZfdCQxMSIsIm51bV9iaXRzJDAiLCJ3b3JkX3NpemUiLCJhbGwiLCJyZWdpc3RlciIsInAiLCJwcCIsImZvcm1hdHRlciIsImFyZzFfMDAyIiwiYXJnMF8wMDEiLCJyZXMwXzAwMyIsInJlczFfMDA0IiwiYXJnMV8wMDYiLCJhcmcwXzAwNSIsInJlczBfMDA3IiwicmVzMV8wMDgiLCJjcmVhdGVfcyIsInNleHAiLCJyYWlzZV93aXRoX29yaWdpbmFsX2JhY2t0cmFjZSIsImJhY2t0cmFjZSIsInJlcmFpc2UiLCJleG4iLCJzdHIiLCJleG4kMCIsImJ0IiwicmVyYWlzZWYiLCJleGMiLCJmb3JtYXQiLCJ0b19zdHJpbmckMSIsInRvX3N0cmluZ19tYWNoJDAiLCJwcm90ZWN0eCIsImZpbmFsbHkkMCIsImZpbmFsX2V4biIsInByb3RlY3QiLCJkb2VzX3JhaXNlIiwicHAkMCIsInBwZiIsInByaW50X3dpdGhfYmFja3RyYWNlIiwicmF3X2JhY2t0cmFjZSIsImhhbmRsZV91bmNhdWdodF9hdXgiLCJkb19hdF9leGl0IiwiZXhpdCIsImhhbmRsZV91bmNhdWdodF9hbmRfZXhpdCIsImhhbmRsZV91bmNhdWdodCIsIm11c3RfZXhpdCIsInJlcmFpc2VfdW5jYXVnaHQiLCJyYWlzZV93aXRob3V0X2JhY2t0cmFjZSIsImluaXRpYWxpemVfbW9kdWxlIiwiY2xlYXJfYmFja3RyYWNlIiwid2l0aF9yZXR1cm4iLCJpc19hbGl2ZSIsInJldHVybiQwIiwid2l0aF9yZXR1cm5fb3B0aW9uIiwicHJlcGVuZCIsInBhcmFtIiwic3ltYm9sX2JpbmQiLCJzeW1ib2xfbWFwIiwiYmluZCIsImpvaW4iLCJpZ25vcmVfbSIsImFsbF91bml0IiwibWFwX3ZpYV9iaW5kIiwibWEiLCJzeW1ib2xfYmluZCQwIiwic3ltYm9sX21hcCQwIiwic3ltYm9sX2JpbmQkMSIsInN5bWJvbF9tYXAkMSIsImJvdGgiLCJsb29wIiwidnMiLCJ0cyIsInYiLCJtYXAkMCIsImJpbmQkMCIsInJldHVybiQxIiwibWFwJDEiLCJhbGwkMCIsInRvX21vbmFkIiwib2ZfbW9uYWQiLCJkZXJpdmVkX21hcCIsIm1hcDIiLCJ0YSIsInRiIiwibWFwMyIsInRjIiwic3ltYm9sIiwidSIsInN5bWJvbCQwIiwidGYiLCJmYWIiLCJjIiwic3ltYm9sJDEiLCJhcHBseSIsIm1mIiwibXgiLCJ0eCIsImN1c3RvbV9tYXAiLCJhcHBseSQwIiwibWFrZSQwIiwic2V4cF9vZl90IiwiY29tcGFyYXRvciIsImNvbXBhcmUkMTUiLCJzZXhwX29mX3QkMTIiLCJjb21wYXJlJDE2IiwiY21wX2YiLCJjbXBfcyIsImhhc2hfZm9sZF90JDEwIiwiaGFzaF9mb2xkX2YiLCJoYXNoX2ZvbGRfcyIsInRfb2Zfc2V4cCQxMSIsIm9mX2ZfMDA3Iiwib2Zfc18wMDgiLCJzZXhwXzAxMyIsInNleHBfYXJnc18wMjAiLCJhcmcwXzAyMSIsInJlczBfMDIyIiwic2V4cF9hcmdzXzAxNSIsImFyZzBfMDE2IiwicmVzMF8wMTciLCJzZXhwX29mX3QkMTMiLCJvZl9mXzAyNSIsIm9mX3NfMDI2IiwiYXJnMF8wMjciLCJyZXMwXzAyOCIsImFyZzBfMDI5IiwicmVzMF8wMzAiLCJ0X3NleHBfZ3JhbW1hciQ4IiwiZl9zZXhwX2dyYW1tYXIiLCJzX3NleHBfZ3JhbW1hciIsIm9wYXF1ZV9pZGVudGl0eSIsIm5hbWUiLCJnZXQiLCJmc2V0Iiwic2V0dGVyIiwibWFwJDMiLCJmaWVsZCIsInVwZGF0ZXIiLCJjYXBpdGFsaXplIiwiY29tcGFyZSQxNyIsImNvcHkkMSIsImVzY2FwZWQiLCJsb3dlcmNhc2UiLCJtYWtlJDEiLCJzdWIkMiIsInVuY2FwaXRhbGl6ZSIsInVuc2FmZV9ibGl0JDAiLCJ1cHBlcmNhc2UiLCJjb25jYXQkMCIsInNlcCIsIml0ZXIkMSIsImNvbXBhcmUkMTgiLCJuIiwibiQwIiwibiQxIiwiaGFzaF9mb2xkX3QkMTEiLCJoc3YkMiIsImhhc2gkMCIsInNleHBfb2ZfdCQxNCIsInBvc19jbnVtXzAxMCIsInBvc19ib2xfMDA4IiwicG9zX2xudW1fMDA2IiwicG9zX2ZuYW1lXzAwNCIsImFyZ18wMTEiLCJibmRzXzAwMyIsImFyZ18wMDkiLCJibmRzXzAwMyQwIiwiYXJnXzAwNyIsImJuZHNfMDAzJDEiLCJhcmdfMDA1IiwiYm5kc18wMDMkMiIsImNvbXBhcmUkMTkiLCJoYXNoX2ZvbGRfdCQxMiIsImhhc2gkMSIsIm1ha2VfbG9jYXRpb25fc3RyaW5nIiwicG9zX2ZuYW1lIiwicG9zX2xudW0iLCJwb3NfY251bSIsInBvc19ib2wiLCJ0b19zdHJpbmckMyIsInNleHBfb2ZfdCQxNSIsImlzX2VtcHR5IiwicGFydGl0aW9uX21hcCIsImZzdCIsInNuZCIsImZzdCQwIiwieSQwIiwic25kJDAiLCJ0X29mX3NleHAkMTIiLCJvZl9hXzAwMSIsIm9mX2JfMDAyIiwic2V4cF8wMDciLCJzZXhwX2FyZ3NfMDA5IiwiYXJnMF8wMTAiLCJyZXMwXzAxMSIsInNleHBfYXJnc18wMTQiLCJhcmcwXzAxNSIsInJlczBfMDE2Iiwic2V4cF9vZl90JDE2Iiwib2ZfYV8wMTkiLCJvZl9iXzAyMCIsImFyZzBfMDIzIiwicmVzMF8wMjQiLCJ0X3NleHBfZ3JhbW1hciQ5IiwiYV9zZXhwX2dyYW1tYXIiLCJiX3NleHBfZ3JhbW1hciIsImNvbXBhcmUkMjAiLCJjbXBfYSIsImNtcF9iIiwiYV8wMjciLCJiXzAyOCIsImJfMDMwIiwiYl8wMzIiLCJlcXVhbCQ5IiwiYV8wMzMiLCJiXzAzNCIsImJfMDM2IiwiYl8wMzgiLCJoYXNoX2ZvbGRfdCQxMyIsImhhc2hfZm9sZF9hIiwiaGFzaF9mb2xkX2IiLCJiaW5kJDEiLCJ4JDAiLCJtYXAkNCIsInJldHVybiQyIiwiYmluZCQyIiwicmV0dXJuJDMiLCJtYXAkNSIsImpvaW4kMCIsImlnbm9yZV9tJDAiLCJhbGwkMSIsImFsbF91bml0JDAiLCJpbnZhcmlhbnQkMCIsImNoZWNrX29rIiwiY2hlY2tfZXJyb3IiLCJvayIsImVycm9yIiwiZmFpbCIsImZhaWxmIiwibWFwX2Vycm9yIiwiYmluZCQzIiwibWFwJDYiLCJyZXR1cm4kNCIsImlzX29rIiwiaXNfZXJyb3IiLCJvZl9vcHRpb24iLCJpdGVyJDIiLCJpdGVyX2Vycm9yIiwidG9fZWl0aGVyIiwib2ZfZWl0aGVyIiwib2tfaWZfdHJ1ZSIsImJvb2wiLCJ0cnlfd2l0aCIsIm9rX2V4biIsIm9rX29yX2ZhaWx3aXRoIiwiY29tYmluZSIsImVyciIsIm9rMiIsImVycjIiLCJjb21iaW5lX2Vycm9ycyIsImVycnMiLCJjb21iaW5lX2Vycm9yc191bml0IiwiaXRlciQzIiwiY291bnQiLCJzdW0iLCJNIiwiZm9sZF9yZXN1bHQiLCJhY2MiLCJpdGVtIiwiZm9sZF91bnRpbCIsImZpbmlzaCIsIm1pbl9lbHQiLCJlbHQiLCJtaW4iLCJtYXhfZWx0IiwibWF4IiwibGVuZ3RoJDAiLCJpc19lbXB0eSQwIiwiZXhpc3RzJDAiLCJmb3JfYWxsJDAiLCJmaW5kX21hcCIsImZpbmQiLCJ0b19saXN0JDAiLCJ0b19hcnJheSIsImxlbmd0aCQxIiwic3VtJDAiLCJtIiwiY291bnQkMCIsImZpbmRfbWFwJDAiLCJmaW5kJDAiLCJ0b19hcnJheSQwIiwibWluX2VsdCQwIiwibWF4X2VsdCQwIiwiZm9sZF9yZXN1bHQkMCIsImZvbGRfdW50aWwkMCIsImZvbGQkMCIsIm1lbSIsImVxdWFsIiwidF9zZXhwX2dyYW1tYXIkMTAiLCJjb21wYXJlJDIxIiwiY29tcGFyZV9hIiwiZXF1YWwkMTAiLCJlcXVhbF9hIiwiaGFzaF9mb2xkX3QkMTQiLCJyZXR1cm4kNSIsImJpbmQkNCIsIm1hcCQ3IiwiYmluZCQ1IiwicmV0dXJuJDYiLCJtYXAkOCIsImpvaW4kMSIsImlnbm9yZV9tJDEiLCJhbGwkMiIsImFsbF91bml0JDEiLCJzZXhwX29mX3QkMTciLCJzZXhwX29mX2EiLCJzbG93X2NoZWNrX3Bvc19sZW5fZXhuIiwicG9zIiwidG90YWxfbGVuZ3RoIiwic3RvcCIsImxlbiQwIiwib2Zfc3RhdGUiLCJhc3NpZ24iLCJ0MSQwIiwidDIkMCIsIm1ha2VfZGVmYXVsdCIsImRlZmF1bHQkMCIsImdldF9zdGF0ZSIsImZvcmJpZF9ub25kZXRlcm1pbmlzbV9pbl90ZXN0cyIsImFsbG93X2luX3Rlc3RzIiwiYml0cyIsImludCQwIiwiaW50MzIiLCJpbnQ2NCIsIm5hdGl2ZWludCIsIm1ha2UkMiIsImNvcHkkMiIsImNoYXIkMCIsImFzY2lpIiwibWFrZV9zZWxmX2luaXQiLCJpbnRfb25fNjRiaXRzIiwiYm91bmQiLCJpbnRfb25fMzJiaXRzIiwiaW50JDEiLCJiaXRzJDAiLCJmdWxsX3JhbmdlX2ludDY0IiwiYml0cyQxIiwiZnVsbF9yYW5nZV9pbnQzMiIsImZ1bGxfcmFuZ2VfaW50X29uXzY0Yml0cyIsImZ1bGxfcmFuZ2VfaW50X29uXzMyYml0cyIsImZ1bGxfcmFuZ2VfaW50X29uXzY0Yml0cyQwIiwiZnVsbF9yYW5nZV9uYXRpdmVpbnRfb25fNjRiaXRzIiwiZnVsbF9yYW5nZV9uYXRpdmVpbnRfb25fMzJiaXRzIiwiZnVsbF9yYW5nZV9uYXRpdmVpbnQiLCJyYWlzZV9jcm9zc2VkX2JvdW5kcyIsImxvd2VyX2JvdW5kIiwidXBwZXJfYm91bmQiLCJzdHJpbmdfb2ZfYm91bmQiLCJpbnRfaW5jbCIsImxvIiwiaGkiLCJkaWZmIiwiaW50MzJfaW5jbCIsIm5hdGl2ZWludF9pbmNsIiwiaW50NjRfaW5jbCIsImZsb2F0JDAiLCJyMSIsInIyIiwicmVzdWx0IiwiZmxvYXRfcmFuZ2UiLCJiaXRzJDIiLCJpbnQkMiIsImludDMyJDAiLCJuYXRpdmVpbnQkMCIsImludDY0JDAiLCJmbG9hdCQxIiwiaW50X2luY2wkMCIsImludDMyX2luY2wkMCIsIm5hdGl2ZWludF9pbmNsJDAiLCJpbnQ2NF9pbmNsJDAiLCJmbG9hdF9yYW5nZSQwIiwiYm9vbCQwIiwiY2hhciQxIiwiYXNjaWkkMCIsImZ1bGxfaW5pdCIsImluaXQkMCIsInNlbGZfaW5pdCIsInNldF9zdGF0ZSIsInBlcm11dGUiLCJyYW5kb21fc3RhdGUiLCJzdGgkMCIsIm51bV9zd2FwcyIsInRoaXNfaSIsInJhbmRvbV9pIiwiY29uc3QkMCIsIm5vbiIsImZvcmV2ZXIiLCJjb21wb3NlIiwiZyIsImZsaXAiLCJhcHBseV9uX3RpbWVzIiwieCQxIiwiY29tcGFyZSQyMiIsImhhc2hfZm9sZF90JDE1IiwiaGFzaCQyIiwidF9vZl9zZXhwJDEzIiwic2V4cF8wMDYiLCJzZXhwX29mX3QkMTgiLCJlcXVhbCQxMSIsIm9mX2ludCQwIiwidG9faW50JDAiLCJ0X3NleHBfZ3JhbW1hciQxMiIsImNvbXBhcmUkMjMiLCJhXzAwNiIsImJfMDA3IiwiYl8wMDkiLCJzZXhwX29mX3QkMTkiLCJvZl9hXzAxMCIsImFyZzBfMDExIiwicmVzMF8wMTIiLCJpbnZhcmlhbnQkMSIsIm9mX2xpc3QkMCIsInJhbmdlIiwic3RyaWRlIiwic3RhcnRfaSIsInN0b3BfaSIsInN0YXJ0IiwibmV4dF9pIiwib3JkZXIiLCJyYWlzZV9zdHJpZGVfY2Fubm90X3JldHVybl9zYW0iLCJpbml0aWFsX3N0cmlkZV9vcmRlciIsInN0YXJ0X2kkMCIsImFjY3VtIiwiaV90b19zdG9wX29yZGVyIiwibmV4dF9pJDAiLCJhY2N1bSQwIiwicmFuZ2UkMCIsInN0aCQxIiwiaGQiLCJ0bCIsIm50aCIsIm50aF9leG4iLCJ1bm9yZGVyZWRfYXBwZW5kIiwib2ZfbGlzdHMiLCJzaGFyZWRfbGVuZ3RoIiwiYiQxIiwiYSQxIiwic2hhcmVkX2xlbmd0aCQwIiwiY2hlY2tfbGVuZ3RoMl9leG4iLCJ0YWlsX29mX2IiLCJ0YWlsX29mX2EiLCJjaGVja19sZW5ndGgyIiwib2ZfbGlzdHMkMCIsImMkMCIsImMkMSIsImNoZWNrX2xlbmd0aDNfZXhuIiwibDMiLCJ0YWlsX29mX2MiLCJuMSIsIm4yIiwibjMiLCJjaGVja19sZW5ndGgzIiwiaXRlcjIiLCJpdGVyMl9leG4iLCJyZXZfbWFwMiIsInJldl9tYXAyX2V4biIsImZvbGQyIiwiZm9sZDJfZXhuIiwiZm9yX2FsbDIiLCJmb3JfYWxsMl9leG4iLCJleGlzdHMyIiwiZXhpc3RzMl9leG4iLCJicyIsInJldl9maWx0ZXIiLCJmaWx0ZXIiLCJub3RfZm91bmQiLCJmaW5kX21hcF9leG4iLCJub3RfZm91bmQkMCIsImZpbmRfZXhuIiwiZmluZGkiLCJub3RfZm91bmQkMSIsImZpbmRpX2V4biIsImZpbmRfbWFwaSIsIm5vdF9mb3VuZCQyIiwiZmluZF9tYXBpX2V4biIsImZvcl9hbGxpIiwiZXhpc3RzaSIsInRvX2xpc3QkMSIsIm1heF9ub25fdGFpbGNhbGwiLCJjb3VudF9hcHBlbmQiLCJ4NSIsImFwcGVuZCQwIiwiY291bnRfbWFwIiwiY3RyIiwiZjEkMyIsImYxJDIiLCJmMiQyIiwiZjEkMSIsImYyJDEiLCJmMyQxIiwiZjEkMCIsImYyJDAiLCJmMyQwIiwiZjQkMCIsIng1JDAiLCJmMSIsImYyIiwiZjMiLCJmNCIsImY1IiwieHMkMCIsIng4IiwieDciLCJ4NiIsIng0IiwieDMiLCJ4MiIsIngxIiwieDAiLCJ5MCQwIiwieTEkMCIsInkyJDAiLCJ5MyQwIiwieTQkMCIsInk1JDAiLCJ5NiQwIiwieTckMCIsInk4JDAiLCJwYXJhbSQwIiwieTgiLCJ5NyIsInk2IiwieTUiLCJ5NCIsInkzIiwieTIiLCJ5MSIsInkwIiwibWFwJDkiLCJmb2xkaW5nX21hcCIsIm5ld19hY2MiLCJmb2xkX21hcCIsInN5bWJvbF9tYXAkMiIsIm1hcDJfb2siLCJtYXAyX2V4biIsInJldl9tYXAzX29rIiwibDEkMCIsImwyJDAiLCJsMyQwIiwiYWMiLCJsMyQxIiwibDIkMSIsImwxJDEiLCJhYyQwIiwicmV2X21hcDMiLCJyZXZfbWFwM19leG4iLCJtYXAzX29rIiwibWFwM19leG4iLCJyZXZfbWFwX2FwcGVuZCIsImgiLCJ1bnppcCQwIiwibGlzdCQyIiwibGlzdCQxIiwidW56aXAzIiwieiIsInppcF9leG4iLCJ6aXAiLCJyZXZfbWFwaSIsIm1hcGkkMSIsImZvbGRpbmdfbWFwaSIsImZvbGRfbWFwaSIsIml0ZXJpJDAiLCJmb2xkaSIsImZpbHRlcmkiLCJyZWR1Y2UiLCJyZWR1Y2VfZXhuIiwicmVkdWNlX2JhbGFuY2VkIiwic3RlcF9hY2N1bSIsIm51bSIsIm51bSQwIiwiYWNjJDAiLCJudW0kMSIsInJlZHVjZV9iYWxhbmNlZF9leG4iLCJncm91cGkiLCJicmVhayQwIiwiZ3JvdXBzIiwiY3VycmVudF9ncm91cCIsImdyb3VwIiwic29ydF9hbmRfZ3JvdXAiLCJiaW5kJDYiLCJjb25jYXRfbWFwaSIsIm1lcmdlIiwiaDIiLCJoMSIsImFjYyQxIiwibWFwMiQwIiwicmV0dXJuJDciLCJzeW1ib2xfYmluZCQyIiwibWFwJDEwIiwibWFwJDExIiwiYWxsJDQiLCJhbGxfdW5pdCQyIiwiaWdub3JlX20kMiIsImpvaW4kMiIsIm1hcDMkMCIsInN5bWJvbCQ2MCIsInN5bWJvbCQ2MSIsInN5bWJvbCQ2MiIsInN5bWJvbCQ2MyIsInN5bWJvbCQ2NCIsInN5bWJvbCQ2NSIsImxhc3RfZXhuIiwibGFzdCIsImlzX3ByZWZpeCIsInByZWZpeCIsInByZWZpeCQwIiwidGwkMCIsImhkJDAiLCJmaW5kX2NvbnNlY3V0aXZlX2R1cGxpY2F0ZSIsImExIiwiYTEkMCIsImEyIiwicmVtb3ZlX2NvbnNlY3V0aXZlX2R1cGxpY2F0ZXMiLCJ3aGljaF90b19rZWVwIiwidG9fa2VlcCQwIiwiZGVkdXBfYW5kX3NvcnQiLCJzb3J0ZWQiLCJmaW5kX2FfZHVwIiwibCQwIiwibCQxIiwiaGQyIiwiaGQxIiwiY29udGFpbnNfZHVwIiwibHN0IiwiZmluZF9hbGxfZHVwcyIsImNvbXBhcmUkMCIsInNvcnRlZCQwIiwicHJldiIsImFscmVhZHlfcmVjb3JkZWQiLCJhbGxfZXF1YWwiLCJjb3VudGkiLCJpZHgiLCJpbml0JDEiLCJpJDEiLCJyZXZfZmlsdGVyX21hcCIsImZpbHRlcl9tYXAiLCJyZXZfZmlsdGVyX21hcGkiLCJmaWx0ZXJfbWFwaSIsImZpbHRlcl9vcHQiLCJwYXJ0aXRpb24zX21hcCIsInRyZCIsInRyZCQwIiwieSQxIiwicGFydGl0aW9uX3RmIiwiZiQwIiwicGFydGl0aW9uX3Jlc3VsdCIsInRfb2Zfc2V4cCQxNCIsIm9mX2FfMDE0Iiwib2ZfYl8wMTUiLCJ4XzAyMyIsInNleHBfMDIxIiwiYXJnMV8wMTgiLCJhcmcwXzAxNyIsInJlczBfMDE5IiwicmVzMV8wMjAiLCJzZXhwX29mX3QkMjAiLCJvZl9hXzAyNCIsIm9mX2JfMDI1IiwieF8wMzAiLCJhcmcxXzAyNyIsImFyZzBfMDI2IiwicmVzMV8wMjkiLCJ0X3NleHBfZ3JhbW1hciQxMyIsInBhaXJfb2ZfZ3JvdXAiLCJrIiwiZ3JvdXAkMCIsImFsaXN0Iiwic29ydF9hbmRfZ3JvdXAkMCIsImZpbmQkMSIsImtleSIsImtleSQwIiwibm90X2ZvdW5kJDMiLCJmaW5kX2V4biQwIiwidmFsdWUiLCJtZW0kMCIsInJlbW92ZSIsImFkZCQwIiwiaW52ZXJzZSIsIm1hcCQxMiIsInN1YiQzIiwiZWwiLCJzcGxpdF9uIiwidF9vcmlnIiwidGFrZSIsImRyb3AiLCJjaHVua3Nfb2YiLCJzdWJsaXN0Iiwic3BsaXRfd2hpbGUiLCJ0YWtlX3doaWxlIiwiZHJvcF93aGlsZSIsImRyb3BfbGFzdCIsImRyb3BfbGFzdF9leG4iLCJjYXJ0ZXNpYW5fcHJvZHVjdCIsImxpc3QxIiwibGlzdDIiLCJjb25jYXQkMSIsImNvbmNhdF9ub19vcmRlciIsImNvbnMiLCJpc19zb3J0ZWQiLCJpc19zb3J0ZWRfc3RyaWN0bHkiLCJwZXJtdXRlJDAiLCJhcnIiLCJyYW5kb21fZWxlbWVudF9leG4iLCJyYW5kb21fZWxlbWVudCIsImNvbXBhcmVfbGlzdCQxIiwiY21wIiwiZXF1YWxfbGlzdCQxIiwidDIkMSIsInQxJDEiLCJ0cmFuc3Bvc2UiLCJyb3dzIiwiY29sdW1ucyIsImRvX3JldiIsImNvbHVtbl9hY2MiLCJ0cmltbWVkX3Jvd3MiLCJmb3VuZF9lbXB0eSIsImNvbHVtbiIsImRvX3JldiQwIiwiY29sdW1ucyQwIiwidHJpbW1lZCIsImNvbHVtbl9hY2MkMCIsImFyZzBfMDMxIiwicmVzMF8wMzIiLCJ0cmFuc3Bvc2VfZXhuIiwiaW50ZXJzcGVyc2UiLCJpc19zdWZmaXgiLCJzdWZmaXgiLCJsaXN0X2xlbiIsInN1ZmZpeF9sZW4iLCJzZXhwX29mX3QkMjEiLCJyZXMwXzAwMiIsImFyZzBfMDAzIiwicmVzMF8wMDQiLCJyZXMwXzAwNiIsImFyZzBfMDA3IiwicmVzMF8wMDgiLCJhcmcyXzAxMSIsImFyZzFfMDEwIiwiYXJnMF8wMDkiLCJyZXMxXzAxMyIsInJlczJfMDE0IiwiYXJnMV8wMTYiLCJyZXMxXzAxOCIsImFyZzJfMDIxIiwiYXJnMV8wMjAiLCJhcmcwXzAxOSIsInJlczFfMDIzIiwicmVzMl8wMjQiLCJhcmcxXzAyNiIsImFyZzBfMDI1IiwicmVzMF8wMjciLCJyZXMxXzAyOCIsImFyZzFfMDMwIiwicmVzMF8wMzEiLCJyZXMxXzAzMiIsInRvX3N0cmluZ3NfaHVtIiwic3RyaW5nIiwic2V4cCQwIiwic2V4cCQxIiwidGFnIiwidGFnJDAiLCJzZXhwJDIiLCJ0YWckMSIsImJvZHkiLCJ0cnVuY19hZnRlciIsInRzJDAiLCJ0cyQxIiwiYWMkMSIsInRvX3NleHBzX2h1bSIsImhlcmUiLCJoZXJlJDAiLCJ0b19zZXhwX2h1bSIsInNleHBzIiwicHJvdGVjdCQwIiwidG9fbWVzc2FnZSIsImluZm8iLCJvZl9tZXNzYWdlIiwibWVzc2FnZSIsImxhenlfdCIsInN0cmljdCIsInNleHBfb2ZfeCIsImJhY2t0cmFjZSQwIiwiYmFja3RyYWNlJDEiLCJiYWNrdHJhY2UkMiIsInBwJDIiLCJwcCQzIiwicmFpc2UiLCJyYWlzZV9zIiwidG9faW5mbyIsIm9mX2luZm8iLCJpbnZhcmlhbnQkMyIsImNoZWNrX2ZpZWxkIiwiY29tcGFyZSQyNSIsImVxdWFsJDEzIiwiYV8wMDciLCJiXzAwOCIsImhhc2hfZm9sZF90JDE3IiwidF9vZl9zZXhwJDE2Iiwib2ZfYV8wMTMiLCJ4XzAxNSIsInNleHBfb2ZfdCQyMyIsIm9mX2FfMDE2IiwieF8wMTciLCJ0X3NleHBfZ3JhbW1hciQxNiIsImludmFyaWFudCQ0IiwiaW52YXJpYW50X2EiLCJlMSIsImUyIiwibWFwJDEzIiwidHJ5X3dpdGgkMCIsInRyeV93aXRoX2pvaW4iLCJva19leG4kMCIsIm9mX2V4biQwIiwib2ZfZXhuX3Jlc3VsdCIsImVycm9yJDAiLCJlcnJvcl9zIiwiZXJyb3Jfc3RyaW5nIiwiZXJyb3JmIiwidGFnX3MkMCIsInRhZ19zX2xhenkkMCIsInRhZ19hcmckMCIsInVuaW1wbGVtZW50ZWQiLCJjb21iaW5lX2Vycm9ycyQwIiwiY29tYmluZV9lcnJvcnNfdW5pdCQwIiwiZmlsdGVyX29rX2F0X2xlYXN0X29uZSIsImZpbmRfb2siLCJmaW5kX21hcF9vayIsInRfb2Zfc2V4cCQxNyIsInNleHBfMDA0Iiwic2V4cF9vZl90JDI0IiwiY29tcGFyZSQyNiIsImhhc2hfZm9sZF90JDE4Iiwic3ltYm9sJDY5Iiwic3ltYm9sJDcwIiwic3ltYm9sJDcxIiwic3ltYm9sJDcyIiwic3ltYm9sJDczIiwic3ltYm9sJDc0IiwiYXNjZW5kaW5nJDEwIiwiZGVzY2VuZGluZyQxMCIsImNvbXBhcmUkMjciLCJlcXVhbCQxNCIsIm1heCQxMiIsIm1pbiQxMiIsIm9mX3N0cmluZyQzIiwidG9fc3RyaW5nJDQiLCJ0b19pbnQkMSIsImdlcSIsImxlcSIsImVxdWFsJDE1IiwibWluJDEzIiwibWF4JDEzIiwic3ltYm9sJDIiLCJzeW1ib2wkMyIsInN5bWJvbCQ0IiwiZGVzY2VuZGluZyIsImJldHdlZW4iLCJsb3ciLCJoaWdoIiwiY2xhbXBfdW5jaGVja2VkIiwiY2xhbXBfZXhuIiwiY2xhbXAiLCJsZXhpY29ncmFwaGljIiwiY21wcyIsImxpZnQiLCJyZXZlcnNlIiwiaXNfcG9zaXRpdmUiLCJpc19ub25fbmVnYXRpdmUiLCJpc19uZWdhdGl2ZSIsImlzX25vbl9wb3NpdGl2ZSIsInNpZ24kMCIsImVxdWFsJDE2IiwiaGFzaF9wYXJhbSIsImhhc2gkNCIsInBvbHkiLCJvZl9rZXkiLCJLZXkiLCJ0b19rZXkiLCJoYXNoIiwiZXF1YWwkMTciLCJoYXNoX3BhcmFtJDAiLCJoYXNoJDUiLCJoYXNoYWJsZSIsIm9mX2tleSQwIiwidG9fa2V5JDAiLCJoYXNoJDYiLCJjb21wYXJlJDI4Iiwib2Zfc3RyaW5nJDQiLCJ0b19zdHJpbmckNSIsImhhc2hfZm9sZF91bml0JDAiLCJmdW5jJDciLCJ1bml0X29mX3NleHAiLCJzZXhwX29mX3VuaXQiLCJlcXVhbF91bml0JDEiLCJjb21wYXJlX3VuaXQkMSIsImludmFyaWFudCQ1IiwiZ2V0X3Bvc19sZW4iLCJmaW5kX2ZpcnN0X3NhdGlzZnlpbmciLCJwcmVkIiwicG9zJDAiLCJoaSQwIiwibG8kMSIsIm1pZCIsImxvJDIiLCJsbyQwIiwiZmluZF9sYXN0X3NhdGlzZnlpbmciLCJiaW5hcnlfc2VhcmNoIiwiaG93IiwiYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQiLCJzZWdtZW50X29mIiwiaXNfbGVmdCIsImlzX3JpZ2h0IiwiYmluYXJ5X3NlYXJjaCQwIiwiYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQkMCIsInVuc2FmZV9ibGl0Iiwic3JjIiwic3JjX3BvcyIsImRzdCIsImRzdF9wb3MiLCJibGl0byIsInNyY19sZW4iLCJzdWJvIiwiY3JlYXRlX2xpa2UiLCJ0X3NleHBfZ3JhbW1hciQxOCIsImlzX25vbmUiLCJpc19zb21lIiwidmFsdWVfbWFwIiwibyIsIml0ZXIkNCIsImludmFyaWFudCQ2IiwiY2FsbCIsInZhbHVlX2V4biIsIm0kMCIsIm0kMSIsInZhbHVlX29yX3RodW5rIiwidG9fbGlzdCQyIiwibWluX2VsdCQxIiwibWF4X2VsdCQxIiwic3VtJDEiLCJmb3JfYWxsJDEiLCJleGlzdHMkMSIsIm1lbSQxIiwiY291bnQkMSIsImZpbmQkMiIsImZpbmRfbWFwJDEiLCJlcXVhbF9vcHRpb24kMSIsInNvbWUiLCJmaXJzdF9zb21lIiwic29tZV9pZiIsImNvbmQiLCJtZXJnZSQwIiwiZmlsdGVyJDAiLCJ0cnlfd2l0aCQxIiwidHJ5X3dpdGhfam9pbiQwIiwiYXBwbHkkMiIsInJldHVybiQ5IiwibWFwJDE1IiwiYmluZCQ3Iiwic3ltYm9sX2JpbmQkNCIsImJpbmQkOCIsImpvaW4kMyIsImlnbm9yZV9tJDMiLCJmb2xkX3Jlc3VsdCQxIiwiZm9sZF91bnRpbCQxIiwidF9vZl9zZXhwIiwiYV9vZl9zZXhwIiwiYl9vZl9zZXhwIiwic2V4cF9vZl9iIiwiY19vZl9zZXhwIiwic2V4cF9vZl9jIiwic3dhcCQwIiwiaXNfZmlyc3QiLCJpc19zZWNvbmQiLCJ2YWx1ZSQwIiwidmFsdWVfbWFwJDAiLCJmaXJzdCIsInNlY29uZCIsIm1hcCQxNyIsImVxdWFsJDE4IiwiZXExIiwiZXEyIiwiaW52YXJpYW50JDciLCJvdGhlciIsImVpdGhlciIsIm90aGVyX2xvb3AiLCJyZXR1cm5fbG9vcCIsImNvbWJpbmVfYWxsIiwib3RoZXJfbG9vcCQwIiwicmV0dXJuX2xvb3AkMCIsImNvbWJpbmVfYWxsX3VuaXQiLCJ0b19vcHRpb24iLCJ3aXRoX3JldHVybiQwIiwiY29tYmluZSQwIiwiYmluZCQ5IiwiZWl0aGVyJDAiLCJjb21iaW5lJDEiLCJiaW5kJDEwIiwiaXRlcmkkMSIsImZvbGRpJDAiLCJjb3VudGkkMCIsImV4aXN0c2kkMCIsImZvcl9hbGxpJDAiLCJmaW5kX21hcGkkMCIsImZpbmRpJDAiLCJmb2xkaSQxIiwic2V4cF9vZl90JDI1Iiwib2Zfc18wMDIiLCJuZXh0X3N0ZXAiLCJkZWxheWVkX2ZvbGRfc3RlcCIsIm5leHQiLCJ1bmZvbGRfc3RlcCIsInVuZm9sZCIsInVuZm9sZF93aXRoIiwic2VlZCQwIiwic2VlZCQxIiwidW5mb2xkX3dpdGhfYW5kX2ZpbmlzaCIsInJ1bm5pbmdfc3RlcCIsImlubmVyX2ZpbmlzaGVkIiwiZmluaXNoaW5nX3N0ZXAiLCJzdGF0ZSQwIiwic3RhdGUkMSIsInN0YXRlJDIiLCJpbm5lcl9zdGF0ZSIsInN0YXRlJDMiLCJpbm5lcl9zdGF0ZSQwIiwiaW5uZXJfc3RhdGUkMSIsInN0YXRlJDQiLCJzdGF0ZSQ1Iiwib2ZfbGlzdCQxIiwiZm9sZCQxIiwidiQwIiwidiQxIiwidG9fbGlzdF9yZXYiLCJ0b19saXN0JDMiLCJzZXhwX29mX3QkMjYiLCJyYW5nZSQxIiwic3RhcnRfdiIsInN0b3BfdiIsInN0ZXAiLCJvZl9sYXp5JDAiLCJ0X2xhenkiLCJtYXBpJDIiLCJmb2xkaW5nX21hcCQwIiwiZm9sZGluZ19tYXBpJDAiLCJmaWx0ZXIkMSIsImZpbHRlcmkkMCIsImxlbmd0aCQyIiwidG9fYXJyYXkkMSIsImwkMiIsImZpbmQkMyIsImZpbmRfbWFwJDIiLCJzb21lX2IiLCJmaW5kX21hcGkkMSIsImZvcl9hbGwkMiIsImZvcl9hbGxpJDEiLCJleGlzdHMkMiIsImV4aXN0c2kkMSIsIml0ZXIkNSIsImlzX2VtcHR5JDEiLCJtZW0kMiIsImVtcHR5IiwiYmluZCQxMSIsIm5leHQkMCIsInJldHVybiQxMSIsIm1hcCQxOCIsInN5bWJvbF9iaW5kJDUiLCJzeW1ib2xfbWFwJDYiLCJiaW5kJDEyIiwicmV0dXJuJDEyIiwibWFwJDE5Iiwiam9pbiQ0IiwiaWdub3JlX20kNCIsImFsbCQxMSIsImFsbF91bml0JDUiLCJudGgkMCIsInMkMyIsIm50aF9leG4kMCIsImNvbXBhcmUkMjkiLCJhXzAxMSIsImJfMDEyIiwiYl8wMTQiLCJiXzAxNiIsImJfMDIwIiwiYl8wMTgiLCJoYXNoX2ZvbGRfdCQxOSIsImEwJDEiLCJoc3YkMyIsInRfb2Zfc2V4cCQxOCIsIm9mX2FfMDIxIiwib2ZfYl8wMjIiLCJzZXhwXzAyNyIsInNleHBfYXJnc18wMzQiLCJhcmcwXzAzNSIsInJlczBfMDM2Iiwic2V4cF9hcmdzXzAyOSIsImFyZzBfMDMwIiwic2V4cF9hcmdzXzAzOSIsImFyZzFfMDQxIiwiYXJnMF8wNDAiLCJyZXMwXzA0MiIsInJlczFfMDQzIiwic2V4cF9vZl90JDI3Iiwib2ZfYV8wNDYiLCJvZl9iXzA0NyIsImFyZzBfMDQ4IiwicmVzMF8wNDkiLCJhcmcwXzA1MCIsInJlczBfMDUxIiwiYXJnMV8wNTMiLCJhcmcwXzA1MiIsInJlczBfMDU0IiwicmVzMV8wNTUiLCJ0X3NleHBfZ3JhbW1hciQxOSIsIm1lcmdlX3dpdGhfZHVwbGljYXRlcyIsIm5leHQyIiwiczIiLCJuZXh0MSIsInMxIiwiczIkMCIsInMyJDEiLCJzMiQyIiwiY29tcGFyaXNvbiIsIm1lcmdlX2RlZHVwZWRfYW5kX3NvcnRlZCIsIm1lcmdlX3NvcnRlZCIsImhkX2V4biQwIiwidGxfZWFnZXJseV9leG4iLCJsaWZ0X2lkZW50aXR5IiwiZmlsdGVyX29wdCQwIiwiZmlsdGVyX21hcCQwIiwiZmlsdGVyX21hcGkkMCIsInNwbGl0X24kMCIsImNodW5rc19leG4iLCJmaW5kaSQxIiwiZmluZF9leG4kMSIsImFwcGVuZCQxIiwiczEkMCIsInMxJDEiLCJjb25jYXRfbWFwIiwiY29uY2F0JDIiLCJjb25jYXRfbWFwaSQwIiwiemlwJDAiLCJ6aXBfZnVsbCIsImJvdW5kZWRfbGVuZ3RoIiwiYXRfbW9zdCIsInNlZWQkMiIsImxlbmd0aF9pc19ib3VuZGVkX2J5IiwibWF4JDAiLCJpdGVyaSQyIiwicmVkdWNlJDAiLCJyZWR1Y2VfZXhuJDAiLCJncm91cCQxIiwiY3VyIiwiY3VyJDAiLCJmaW5kX2NvbnNlY3V0aXZlX2R1cGxpY2F0ZSQwIiwibGFzdF9lbHQiLCJsYXN0X2VsdCQwIiwicmVtb3ZlX2NvbnNlY3V0aXZlX2R1cGxpY2F0ZXMkMCIsImNvdW50JDIiLCJjb3VudGkkMSIsInN1bSQyIiwibWluX2VsdCQyIiwibWF4X2VsdCQyIiwiaW5pdCQyIiwic3ViJDQiLCJ0YWtlJDAiLCJkcm9wJDAiLCJ0YWtlX3doaWxlJDAiLCJkcm9wX3doaWxlJDAiLCJzaGlmdF9yaWdodCIsInNoaWZ0X3JpZ2h0X3dpdGhfbGlzdCIsImludGVyc3BlcnNlJDAiLCJzJDUiLCJzJDQiLCJyZXBlYXQiLCJjeWNsZV9saXN0X2V4biIsImNhcnRlc2lhbl9wcm9kdWN0JDAiLCJzYSIsInNiIiwic2luZ2xldG9uIiwiZGVsYXllZF9mb2xkIiwib3B0aW9uIiwiZm9sZF9tIiwiaXRlcl9tIiwiZm9sZF91bnRpbCQyIiwiZm9sZF9yZXN1bHQkMiIsImZvcmNlX2VhZ2VybHkiLCJtZW1vaXplIiwiZHJvcF9lYWdlcmx5IiwiZHJvcF93aGlsZV9vcHRpb24iLCJjb21wYXJlJDMwIiwidjIiLCJ2MSIsImVxdWFsJDE5Iiwicm91bmRfcm9iaW4iLCJkb25lX3N0YWNrIiwidG9kb19zdGFjayIsInRvZG9fc3RhY2skMCIsImludGVybGVhdmUiLCJpbnRlcmxlYXZlZF9jYXJ0ZXNpYW5fcHJvZHVjdCIsIm9mX3NlcSIsInNlcSIsInRvX3NlcSIsInJldHVybiQxMyIsImJpbmQkMTMiLCJtYXAkMjAiLCJzeW1ib2xfYmluZCQ2Iiwic3ltYm9sX21hcCQ3IiwiYmluZCQxNCIsInJldHVybiQxNCIsIm1hcCQyMSIsImpvaW4kNSIsImlnbm9yZV9tJDUiLCJhbGwkMTIiLCJhbGxfdW5pdCQ2IiwieWllbGQkMCIsIm9mX3NlcXVlbmNlIiwic2VxdWVuY2UiLCJydW4kMCIsInRodW5rIiwidF9zZXhwX2dyYW1tYXIkMjAiLCJnZXQkMCIsInNldCIsInN3YXAkMSIsInRtcCIsInNvcnQkMCIsImxlZnQiLCJyaWdodCIsImlfbmV4dCIsImhlYXBpZnkiLCJyb290Iiwicm9vdCQwIiwicmVsYXRpdmVfcm9vdCIsImxlZnRfY2hpbGQiLCJyaWdodF9jaGlsZCIsImxhcmdlc3QiLCJsYXJnZXN0JDAiLCJzb3J0JDEiLCJmaXZlX2VsZW1lbnRfc29ydCIsIm0zIiwibTUiLCJjb21wYXJlX2FuZF9zd2FwIiwiaW50cm9fc29ydCIsIm1heF9kZXB0aCIsInIkMyIsIm1heF9kZXB0aCQwIiwibGVmdCQwIiwibWF4X2RlcHRoJDEiLCJzaXh0aCIsIm0yX3ZhbCIsIm0zX3ZhbCIsIm00X3ZhbCIsIm1pZGRsZV9zb3J0ZWQiLCJwaXZvdDIiLCJwaXZvdDEiLCJwJDEiLCJyJDIiLCJsZWZ0JDEiLCJwdiIsInAkMCIsInIkMCIsInIkMSIsInNvcnQkMiIsInNvcnQkMyIsInRvX2FycmF5JDIiLCJpc19lbXB0eSQyIiwiaXNfc29ydGVkJDAiLCJlbHRfaV9taW51c18xIiwiaXNfc29ydGVkX3N0cmljdGx5JDAiLCJtZXJnZSQxIiwibWVyZ2VkIiwiYTFfaW5kZXgiLCJhMl9pbmRleCIsInVzZV9hMSIsImNvcHlfbWF0cml4IiwiZm9sZGluZ19tYXAkMSIsImZvbGRfbWFwJDAiLCJmb2xkX3Jlc3VsdCQzIiwiZm9sZF91bnRpbCQzIiwiY291bnQkMyIsInN1bSQzIiwibWluX2VsdCQzIiwibWF4X2VsdCQzIiwiZm9sZGkkMiIsImZvbGRpbmdfbWFwaSQxIiwiZm9sZF9tYXBpJDAiLCJjb3VudGkkMiIsImNvbmNhdF9tYXAkMCIsImNvbmNhdF9tYXBpJDEiLCJyZXZfaW5wbGFjZSIsInJldiQwIiwib2ZfbGlzdF9yZXYiLCJvZl9saXN0X21hcCIsIm9mX2xpc3RfbWFwaSIsIm9mX2xpc3RfcmV2X21hcCIsIm9mX2xpc3RfcmV2X21hcGkiLCJmaWx0ZXJfbWFwaSQxIiwiZmlsdGVyX21hcCQxIiwiZmlsdGVyX29wdCQxIiwiY2hlY2tfbGVuZ3RoMl9leG4kMCIsIml0ZXIyX2V4biQwIiwibWFwMl9leG4kMCIsImZvbGQyX2V4biQwIiwiZmlsdGVyJDIiLCJmaWx0ZXJpJDEiLCJleGlzdHMkMyIsImV4aXN0c2kkMiIsIm1lbSQzIiwiZm9yX2FsbCQzIiwiZm9yX2FsbGkkMiIsImV4aXN0czJfZXhuJDAiLCJmb3JfYWxsMl9leG4kMCIsImVxdWFsX2FycmF5JDEiLCJtYXBfaW5wbGFjZSIsImZpbmRpX2ludGVybmFsIiwiaWZfZm91bmQiLCJpZl9ub3RfZm91bmQiLCJmb3VuZCIsInZhbHVlX2ZvdW5kIiwiZmluZGkkMiIsImZpbmRpX2V4biQwIiwiZmluZF9leG4kMiIsImZpbmQkNCIsImZpbmRfbWFwJDMiLCJub3RfZm91bmQkNCIsImZpbmRfbWFwX2V4biQwIiwiZmluZF9tYXBpJDIiLCJub3RfZm91bmQkNSIsImZpbmRfbWFwaV9leG4kMCIsImZpbmRfY29uc2VjdXRpdmVfZHVwbGljYXRlJDEiLCJyZWR1Y2UkMSIsInJlZHVjZV9leG4kMSIsInJhbmRvbV9lbGVtZW50X2V4biQwIiwicmFuZG9tX2VsZW1lbnQkMCIsInppcCQxIiwiemlwX2V4biQwIiwidW56aXAkMSIsInJlczEiLCJyZXMyIiwic29ydGVkX2NvcHkiLCJwYXJ0aXRpb25pX3RmIiwidHJ1ZXMiLCJmYWxzZXMiLCJwYXJ0aXRpb25fdGYkMCIsImxhc3QkMCIsInRvX3NlcXVlbmNlX211dGFibGUiLCJ0b19zZXF1ZW5jZSIsImNhcnRlc2lhbl9wcm9kdWN0JDEiLCJpMSIsImkyIiwidHJhbnNwb3NlJDAiLCJ0dCIsIndpZHRoIiwiZGVwdGgiLCJkIiwidyIsInRyYW5zcG9zZV9leG4kMCIsInR0JDAiLCJnZXQkMSIsImxlbmd0aCQzIiwibGVuZ3RoJDQiLCJ1bnNhZmVfYmxpdCQxIiwiaW52YXJpYW50JDgiLCJpbnZhcmlhbnQkOSIsImxlbmd0aCQ1Iiwic2V4cF9vZl90JDI4IiwiY3JlYXRlX3plcm8iLCJlbXB0eSQwIiwiZ2V0JDIiLCJ1bnNhZmVfZ2V0IiwidW5zYWZlX3NldF93aXRoX2NhbWxfbW9kaWZ5Iiwib2JqIiwic2V0X3dpdGhfY2FtbF9tb2RpZnkiLCJ1bnNhZmVfc2V0X2ludF9hc3N1bWluZ19jdXJyZW4iLCJzZXQkMCIsIm9sZF9vYmoiLCJ1bnNhZmVfc2V0IiwidW5zYWZlX3NldF9vbWl0X3BoeXNfZXF1YWxfY2hlIiwic3dhcCQyIiwiY3JlYXRlJDMiLCJzaW5nbGV0b24kMCIsInVuc2FmZV9zZXRfYXNzdW1pbmdfY3VycmVudGx5XyIsInVuc2FmZV9zZXRfaW50IiwidW5zYWZlX2NsZWFyX2lmX3BvaW50ZXIiLCJ1bnNhZmVfYmxpdCQzIiwidW5zYWZlX2JsaXQkNCIsImNvcHkkMyIsInVuc2FmZV9jcmVhdGVfdW5pbml0aWFsaXplZCIsImNyZWF0ZV9vYmpfYXJyYXkiLCJjcmVhdGUkNCIsInNpbmdsZXRvbiQxIiwic3dhcCQzIiwiZ2V0JDMiLCJzZXQkMSIsInVuc2FmZV9nZXQkMCIsInVuc2FmZV9zZXQkMCIsInVuc2FmZV9zZXRfaW50JDAiLCJ1bnNhZmVfc2V0X2ludF9hc3N1bWluZ19jdXJyZW4kMCIsInVuc2FmZV9zZXRfYXNzdW1pbmdfY3VycmVudGx5XyQwIiwidW5zYWZlX3NldF9vbWl0X3BoeXNfZXF1YWxfY2hlJDAiLCJ1bnNhZmVfc2V0X3dpdGhfY2FtbF9tb2RpZnkkMCIsInNldF93aXRoX2NhbWxfbW9kaWZ5JDAiLCJpbnZhcmlhbnQkMTAiLCJpbml0JDMiLCJvZl9hcnJheSIsIm1hcCQyMiIsIm1hcGkkMyIsIml0ZXIkNiIsIml0ZXJpJDMiLCJmb2xkaSQzIiwidG9fbGlzdCQ0Iiwib2ZfbGlzdCQyIiwidG9fYXJyYXkkMyIsImV4aXN0cyQ0IiwiZm9yX2FsbCQ0IiwibWFwMl9leG4kMSIsInRfc2V4cF9ncmFtbWFyJDIxIiwiZ3JhbW1hciIsImNyZWF0ZV9saWtlJDAiLCJ1bnNhZmVfYmxpdCQ1IiwiZm9sZCQyIiwibWluX2VsdCQ0IiwibWF4X2VsdCQ0IiwiY29tcGFyZSQzMSIsImNlaWwiLCJmbG9vciIsIm1vZF9mbG9hdCIsIm1vZGYiLCJmbG9hdF9vZl9zdHJpbmckMCIsIm5hbiQxIiwiaW5maW5pdHkkMSIsIm5lZ19pbmZpbml0eSQxIiwibWF4X2Zpbml0ZV92YWx1ZSIsImVwc2lsb25fZmxvYXQkMSIsImNsYXNzaWZ5X2Zsb2F0IiwiYWJzX2Zsb2F0IiwiaXNfaW50ZWdlciIsInN5bWJvbCQ4NCIsInN5bWJvbCQ4NSIsImZyZXhwIiwibGRleHAiLCJpc19uYW4iLCJ0b19pbnQ2NF9wcmVzZXJ2ZV9vcmRlciIsInRvX2ludDY0X3ByZXNlcnZlX29yZGVyX2V4biIsIm9mX2ludDY0X3ByZXNlcnZlX29yZGVyIiwib25lX3VscCIsImRpciIsInVwcGVyX2JvdW5kX2Zvcl9pbnQiLCJudW1fYml0cyIsImV4cCIsImlzX3hfbWludXNfb25lX2V4YWN0IiwibG93ZXJfYm91bmRfZm9yX2ludCIsIm1pbl9pbnRfYXNfZmxvYXQiLCJib3giLCJoYXNoJDciLCJ0b19zdHJpbmckNyIsIm9mX3N0cmluZyQ2IiwicHAkNiIsImludmFyaWFudCQxMSIsImFsbCQxMyIsImlzX2xvd2VyY2FzZSIsImlzX3VwcGVyY2FzZSIsImlzX3ByaW50IiwiaXNfd2hpdGVzcGFjZSIsImlzX2RpZ2l0IiwiaXNfYWxwaGEiLCJpc19hbHBoYW51bSIsImdldF9kaWdpdF9leG4iLCJnZXRfZGlnaXQiLCJpc19oZXhfZGlnaXQiLCJpc19oZXhfZGlnaXRfbG93ZXIiLCJpc19oZXhfZGlnaXRfdXBwZXIiLCJnZXRfaGV4X2RpZ2l0X2V4biIsImdldF9oZXhfZGlnaXQiLCJzeW1ib2wkOTIiLCJzeW1ib2wkOTMiLCJzeW1ib2wkOTQiLCJzeW1ib2wkOTUiLCJzeW1ib2wkOTYiLCJzeW1ib2wkOTciLCJjb21wYXJlJDM0IiwiYzEiLCJjMiIsImhhc2hfZm9sZF90JDIwIiwiaGFzaCQ4IiwiY29tcGFyZV9jaGFyJDAiLCJlcXVhbF9jaGFyJDEiLCJ0cl9jcmVhdGVfbWFwIiwidGFyZ2V0IiwicmVwbGFjZW1lbnQiLCJ0cl9tYXAiLCJpJDMiLCJpJDIiLCJpbmRleCQwIiwibGFzdF9yZXBsYWNlbWVudCIsImluZGV4IiwiZmlyc3RfdGFyZ2V0Iiwic3RhZ2UiLCJ1bnN0YWdlIiwiaGFzaCQ5IiwiaGFzaGFibGUkMSIsImludmFyaWFudCQxMiIsInN1YiQ4Iiwic3VibyQyIiwiY29udGFpbnMiLCJwb3MkMSIsImVuZCIsImlzX2VtcHR5JDMiLCJpbmRleF9mcm9tX2V4bl9pbnRlcm5hbCIsImluZGV4X2V4bl9pbnRlcm5hbCIsIm5vdF9mb3VuZCQ2IiwiaW5kZXhfZXhuIiwibm90X2ZvdW5kJDciLCJpbmRleF9mcm9tX2V4biIsInJpbmRleF9mcm9tX2V4bl9pbnRlcm5hbCIsInJpbmRleF9leG5faW50ZXJuYWwiLCJub3RfZm91bmQkOCIsInJpbmRleF9leG4iLCJub3RfZm91bmQkOSIsInJpbmRleF9mcm9tX2V4biIsInJpbmRleCIsImluZGV4X2Zyb20iLCJyaW5kZXhfZnJvbSIsInNleHBfb2ZfdCQzMCIsImNhc2Vfc2Vuc2l0aXZlIiwicGF0dGVybiIsImttcF9pbnRlcm5hbF9sb29wIiwibWF0Y2hlZF9jaGFycyIsIm5leHRfdGV4dF9jaGFyIiwia21wX2FycmF5IiwiY2hhcl9lcXVhbCIsIm1hdGNoZWRfY2hhcnMkMCIsImdldF9jaGFyX2VxdWFsIiwiY3JlYXRlJDUiLCJpbmRleF9pbnRlcm5hbCIsInRleHQiLCJtYXRjaGVzIiwiaW4kMCIsImluZGV4X2V4biQwIiwiaW5kZXhfYWxsIiwibWF5X292ZXJsYXAiLCJyZXBsYWNlX2ZpcnN0Iiwid2l0aCQwIiwibGVuX3MiLCJsZW5fdCIsImxlbl93aXRoIiwicmVwbGFjZV9hbGwiLCJudW1fbWF0Y2hlcyIsIm5leHRfZHN0X3BvcyIsIm5leHRfc3JjX3BvcyIsInNwbGl0X29uIiwicGF0dGVybl9sZW4iLCJlcXVhbCQyMyIsImFfMDAyIiwiYl8wMDMiLCJzZXhwX29mX3QkMzEiLCJrbXBfYXJyYXlfMDExIiwiY2FzZV9zZW5zaXRpdmVfMDA5IiwicGF0dGVybl8wMDciLCJhcmdfMDEyIiwiYm5kc18wMDYiLCJhcmdfMDEwIiwiYm5kc18wMDYkMCIsImFyZ18wMDgiLCJibmRzXzAwNiQxIiwicmVwcmVzZW50YXRpb24iLCJzdWJzdHJfaW5kZXhfZ2VuIiwic3Vic3RyX2luZGV4X2V4bl9nZW4iLCJzdWJzdHJfaW5kZXhfYWxsX2dlbiIsInN1YnN0cl9yZXBsYWNlX2ZpcnN0X2dlbiIsInN1YnN0cl9yZXBsYWNlX2FsbF9nZW4iLCJpc19zdWJzdHJpbmdfZ2VuIiwic3Vic3RyaW5nIiwic3Vic3RyX2luZGV4Iiwic3Vic3RyX2luZGV4X2V4biIsInN1YnN0cl9pbmRleF9hbGwiLCJzdWJzdHJfcmVwbGFjZV9maXJzdCIsInN1YnN0cl9yZXBsYWNlX2FsbCIsImlzX3N1YnN0cmluZyIsImlzX3N1YnN0cmluZ19hdF9nZW4iLCJzdHJfcG9zJDEiLCJzdHJfbGVuIiwic3ViX2xlbiIsInN0cl9wb3MiLCJzdWJfcG9zIiwic3ViX3BvcyQwIiwic3RyX3BvcyQwIiwiaXNfc3VmZml4X2dlbiIsInN0cmluZ19sZW4iLCJpc19wcmVmaXhfZ2VuIiwicHJlZml4X2xlbiIsImNvbXBhcmUkMzYiLCJzdHJpbmcxIiwic3RyaW5nMiIsImxlbjIiLCJsZW4xIiwiaGFzaF9mb2xkX3QkMjEiLCJoYXNoJDEwIiwiaXNfc3VmZml4JDAiLCJpc19wcmVmaXgkMCIsInN1YnN0cl9pbmRleCQwIiwic3Vic3RyX2luZGV4X2V4biQwIiwic3Vic3RyX2luZGV4X2FsbCQwIiwic3Vic3RyX3JlcGxhY2VfZmlyc3QkMCIsInN1YnN0cl9yZXBsYWNlX2FsbCQwIiwiaXNfc3Vic3RyaW5nJDAiLCJpc19zdWJzdHJpbmdfYXQiLCJvZl9zdHJpbmckNyIsInRvX3N0cmluZyQ4IiwiaW5pdCQ0IiwidG9fbGlzdCQ1IiwidG9fbGlzdF9yZXYkMCIsInJldiQxIiwibm90X2ZvdW5kJDEwIiwibHNwbGl0Ml9leG4iLCJsaW5lIiwiZGVsaW0iLCJub3RfZm91bmQkMTEiLCJyc3BsaXQyX2V4biIsImxzcGxpdDIiLCJvbiIsInJzcGxpdDIiLCJjaGFyX2xpc3RfbWVtIiwic3BsaXRfZ2VuIiwiaXNfZGVsaW0iLCJsYXN0X3BvcyIsInBvcyQyIiwibGFzdF9wb3MkMCIsInBvczEiLCJzdWJfc3RyIiwic3BsaXQiLCJzcGxpdF9vbl9jaGFycyIsImNoYXJzIiwiYmFja191cF9hdF9uZXdsaW5lIiwiZW9sIiwic3BsaXRfbGluZXMiLCJpc19zdWZmaXgkMSIsImlzX3ByZWZpeCQxIiwiaXNfc3Vic3RyaW5nX2F0JDAiLCJ3cmFwX3N1Yl9uIiwib25fZXJyb3IiLCJkcm9wX3ByZWZpeCIsImRyb3Bfc3VmZml4IiwibGZpbmRpIiwiZmluZCQ1IiwiZmluZF9tYXAkNCIsInJmaW5kaSIsImxhc3Rfbm9uX2Ryb3AiLCJyc3RyaXAiLCJmaXJzdF9ub25fZHJvcCIsImxzdHJpcCIsInN0cmlwIiwibWFwaSQ0IiwibWFwJDIzIiwidG9fYXJyYXkkNCIsImV4aXN0cyQ1IiwiZm9yX2FsbCQ1IiwiZm9sZCQzIiwiZm9sZGkkNCIsIml0ZXJpJDQiLCJjb3VudCQ0Iiwic3VtJDQiLCJtaW5fZWx0JDUiLCJtYXhfZWx0JDUiLCJmb2xkX3Jlc3VsdCQ0IiwiZm9sZF91bnRpbCQ0IiwiZmluZF9tYXBpJDMiLCJmaW5kaSQzIiwiY291bnRpJDMiLCJmb3JfYWxsaSQzIiwiZXhpc3RzaSQzIiwibWVtJDQiLCJ0ciIsInRyX211bHRpIiwiY29uY2F0X2FycmF5IiwiYXIiLCJjb25jYXRfbWFwJDEiLCJmaWx0ZXIkMyIsIm91dCIsIm91dF9wb3MiLCJvdXQkMCIsImZpbHRlcmkkMiIsImNob3BfcHJlZml4IiwiY2hvcF9wcmVmaXhfaWZfZXhpc3RzIiwiY2hvcF9wcmVmaXhfZXhuIiwiY2hvcF9zdWZmaXgiLCJjaG9wX3N1ZmZpeF9pZl9leGlzdHMiLCJjaG9wX3N1ZmZpeF9leG4iLCJzaG9ydGVyIiwic2hvcnRlc3QiLCJwb3NfZnJvbV9sZWZ0IiwicG9zX2Zyb21fcmlnaHQiLCJjb21tb25fZ2VuZXJpYzJfbGVuZ3RoX2xvb3AiLCJnZXRfcG9zIiwibWF4X2xlbiIsImxlbl9zb19mYXIiLCJsZW5fc29fZmFyJDAiLCJsZW5fc29fZmFyJDEiLCJjb21tb25fZ2VuZXJpYzJfbGVuZ3RoIiwiY29tbW9uX2dlbmVyaWNfbGVuZ3RoX2xvb3AiLCJmaXJzdCQwIiwibWF4X2xlbiQwIiwibWF4X2xlbiQxIiwiY29tbW9uX2dlbmVyaWNfbGVuZ3RoIiwiY29tbW9uX2dlbmVyaWMyIiwiY29tbW9uX2dlbmVyaWMiLCJjb21tb25fcHJlZml4IiwiY29tbW9uX3N1ZmZpeCIsImNvbW1vbl9wcmVmaXgyIiwiY29tbW9uX3N1ZmZpeDIiLCJjb21tb25fcHJlZml4X2xlbmd0aCIsImNvbW1vbl9zdWZmaXhfbGVuZ3RoIiwiY29tbW9uX3ByZWZpeDJfbGVuZ3RoIiwiY29tbW9uX3N1ZmZpeDJfbGVuZ3RoIiwicHAkNyIsIm9mX2NoYXIkMCIsIm9mX2NoYXJfbGlzdCIsImJ1aWxkX2FuZF92YWxpZGF0ZV9lc2NhcGV3b3J0aCIsImVzY2FwZXdvcnRoeV9tYXAiLCJlc2NhcGVfY2hhciIsImVzY2FwZXdvcnRoeV9tYXAkMCIsInZhbHMiLCJjX3RvIiwiY19mcm9tIiwiZXNjYXBlX2dlbiIsImVzY2FwZXdvcnRoeSIsInRvX2VzY2FwZV9sZW4iLCJsYXN0X2lkeCIsImxhc3RfZHN0X3BvcyIsInRvX2VzY2FwZSIsImVzY2FwZWRfY2hhciIsImxhc3RfZHN0X3BvcyQxIiwiZXNjYXBlX2dlbl9leG4iLCJlc2NhcGUiLCJ1bmVzY2FwZV9nZW4iLCJzdGF0dXMiLCJzdGF0dXMkMCIsInRvX3VuZXNjYXBlIiwiZHN0X3BvcyQwIiwidW5lc2NhcGVfZ2VuX2V4biIsInVuZXNjYXBlIiwicHJlY2VkaW5nX2VzY2FwZV9jaGFycyIsImNudCIsImNudCQwIiwidXBkYXRlX2VzY2FwZV9zdGF0dXMiLCJlc2NhcGVfc3RhdHVzIiwib2RkIiwiY2hlY2tfYm91bmQiLCJmdW5jdGlvbl9uYW1lIiwiaXNfY2hhcl9lc2NhcGluZyIsImlzX2NoYXJfZXNjYXBlZCIsImlzX2NoYXJfbGl0ZXJhbCIsImluZGV4X2Zyb20kMCIsInN0YXR1cyQxIiwiaW5kZXhfZnJvbV9leG4kMCIsImluZGV4JDEiLCJpbmRleF9leG4kMSIsInJpbmRleF9mcm9tJDAiLCJlc2NhcGVfY2hhcnMiLCJyaW5kZXhfZnJvbV9leG4kMCIsInJpbmRleCQwIiwicmluZGV4X2V4biQwIiwic3BsaXRfZ2VuJDAiLCJzcGxpdCQwIiwic3BsaXRfb25fY2hhcnMkMCIsInNwbGl0X2F0IiwibHNwbGl0MiQwIiwicnNwbGl0MiQwIiwibHNwbGl0Ml9leG4kMCIsInJzcGxpdDJfZXhuJDAiLCJsYXN0X25vbl9kcm9wX2xpdGVyYWwiLCJmaXJzdF9ub25fZHJvcF9saXRlcmFsIiwicnN0cmlwX2xpdGVyYWwiLCJsc3RyaXBfbGl0ZXJhbCIsInN0cmlwX2xpdGVyYWwiLCJiZXR3ZWVuJDIiLCJjbGFtcF91bmNoZWNrZWQkMCIsImNsYW1wX2V4biQyIiwiY2xhbXAkMiIsImNyZWF0ZSQ2IiwiY29tcGFyZV9zdHJpbmckMSIsImVxdWFsX3N0cmluZyQxIiwicHAkOCIsImNyZWF0ZSQ3IiwiY3JlYXRlJDgiLCJsZW5ndGgkNiIsInVuc2FmZV9ibGl0JDciLCJsZW5ndGgkNyIsImludmFyaWFudCQxMyIsImluaXQkNSIsIm9mX2NoYXJfbGlzdCQwIiwidG9fbGlzdCQ2IiwidG9fYXJyYXkkNSIsIm1hcCQyNCIsIm1hcGkkNSIsImZvbGQkNCIsImZvbGRpJDUiLCJ0ciQwIiwidHJfbXVsdGkkMCIsImJldHdlZW4kMyIsImNsYW1wX3VuY2hlY2tlZCQxIiwiY2xhbXBfZXhuJDMiLCJjbGFtcCQzIiwiY29udGFpbnMkMCIsImNvbXBhcmVfYnl0ZXMiLCJlcXVhbF9ieXRlcyIsInBhcnNlX2hleCIsImxleGJ1ZiIsIm9jYW1sX2xleF9zdGF0ZSIsIm9jYW1sX2xleF9zdGF0ZSQwIiwiY29udmVydF9mYWlsdXJlIiwidG9fc3RyaW5nIiwibnVtX2JpdHNfbmF0aXZlaW50IiwibnVtX2JpdHNfaW50MzIiLCJudW1fYml0c19pbnQ2NCIsImludDMyX3RvX2ludF90cnVuYyIsImludF90b19pbnQzMl90cnVuYyIsImludF90b19pbnQzMiIsImludDMyX3RvX2ludCIsImludF90b19pbnQzMl9leG4iLCJpbnQzMl90b19pbnRfZXhuIiwiaW50X3RvX2ludDY0IiwiaW50NjRfdG9faW50X3RydW5jIiwibWluJDIxIiwibWF4JDIxIiwiaW50NjRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQiLCJpbnQ2NF90b19pbnQiLCJpbnQ2NF90b19pbnRfZXhuIiwiaW50X3RvX25hdGl2ZWludCIsIm5hdGl2ZWludF90b19pbnRfdHJ1bmMiLCJuYXRpdmVpbnRfdG9faW50IiwibmF0aXZlaW50X3RvX2ludF9leG4iLCJpbnQzMl90b19pbnQ2NCIsImludDY0X3RvX2ludDMyX3RydW5jIiwibWluJDIyIiwibWF4JDIyIiwiaW50NjRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQzIiwiaW50NjRfdG9faW50MzIiLCJpbnQ2NF90b19pbnQzMl9leG4iLCJpbnQzMl90b19uYXRpdmVpbnQiLCJuYXRpdmVpbnRfdG9faW50MzJfdHJ1bmMiLCJuYXRpdmVpbnRfdG9faW50MzIiLCJuYXRpdmVpbnRfdG9faW50MzJfZXhuIiwiaW50NjRfdG9fbmF0aXZlaW50X3RydW5jIiwibmF0aXZlaW50X3RvX2ludDY0IiwibWluJDM4IiwibWF4JDM5IiwidG9fbmF0aXZlaW50IiwidG9fbmF0aXZlaW50X2V4biIsIm1pbiQyMyIsIm1heCQyMyIsImludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfaW50NiIsImludDY0X2ZpdF9vbl9pbnQ2M19leG4iLCJpbnNlcnRfZGVsaW1pdGVyX2V2ZXJ5IiwiaW5wdXQiLCJkZWxpbWl0ZXIiLCJjaGFyc19wZXJfZGVsaW1pdGVyIiwiaW5wdXRfbGVuZ3RoIiwiaGFzX3NpZ24iLCJudW1fZGlnaXRzIiwibnVtX2RlbGltaXRlcnMiLCJvdXRwdXRfbGVuZ3RoIiwib3V0cHV0IiwiaW5wdXRfcG9zIiwib3V0cHV0X3BvcyIsIm51bV9jaGFyc191bnRpbF9kZWxpbWl0ZXIiLCJmaXJzdF9kaWdpdF9wb3MiLCJpbnNlcnRfZGVsaW1pdGVyIiwiaW5zZXJ0X3VuZGVyc2NvcmVzIiwiZGVsaW1pdGVyJDAiLCJtYWtlX3N1ZmZpeCIsInRvX3N0cmluZyQwIiwidG9fc3RyaW5nX2h1bSIsImludmFsaWQiLCJvZl9zdHJpbmdfd2l0aF9kZWxpbWl0ZXIiLCJsZXgiLCJib2R5JDAiLCJ0X3NleHBfZ3JhbW1hciIsImludDMyX3Bvc2l0aXZlX292ZXJmbG93X2JvdW5kcyIsIm92ZXJmbG93X2JvdW5kX21heF9pbnQzMl92YWx1ZSIsIm92ZXJmbG93X2JvdW5kX21heF9pbnRfdmFsdWUiLCJpbnRfcG9zaXRpdmVfb3ZlcmZsb3dfYm91bmRzIiwiaW50NjNfb25faW50NjRfcG9zaXRpdmVfb3ZlcmZsIiwiaW50NjRfcG9zaXRpdmVfb3ZlcmZsb3dfYm91bmRzIiwiaW50NjRfbmVnYXRpdmVfb3ZlcmZsb3dfYm91bmRzIiwibmVnYXRpdmVfZXhwb25lbnQiLCJvdmVyZmxvdyIsImludF9wb3ciLCJiYXNlIiwiZXhwb25lbnQiLCJpbnQ2NF9wb3ciLCJpbnQ2M19wb3dfb25faW50NjQiLCJydmFsIiwib25lIiwicm91bmRfZG93biIsIm1vZHVsdXMiLCJyb3VuZF91cCIsInJlbWFpbmRlciIsInJvdW5kX3Rvd2FyZHNfemVybyIsInRvX211bHRpcGxlX29mIiwicm91bmRfbmVhcmVzdCIsIm1vZHVsdXNfbWludXNfcmVtYWluZGVyIiwicm91bmQiLCJpbnQ2NF9wb3Bjb3VudCIsIngkMiIsImludDMyX3BvcGNvdW50IiwicG9wY291bnQiLCJ0b19mbG9hdCQwIiwiZmxpcCQwIiwic3ltYm9sJDEyOCIsInN5bWJvbCQxMjkiLCJzeW1ib2wkMTMwIiwic3ltYm9sJDEzMSIsInN5bWJvbCQxMzIiLCJzeW1ib2wkMTMzIiwic3ltYm9sJDEzNCIsImFzY2VuZGluZyQxOCIsImRlc2NlbmRpbmckMTgiLCJjb21wYXJlJDM4IiwiZXF1YWwkMjUiLCJtYXgkMjQiLCJtaW4kMjQiLCJmdW5jJDgiLCJjb21wYXJlJDM5IiwiZmxvYXRfbG93ZXJfYm91bmQiLCJmbG9hdF91cHBlcl9ib3VuZCIsIm9mX2ludCQyIiwidG9faW50JDMiLCJoYXNoJDEyIiwic3ltYm9sJDEzNSIsInRvX3N0cmluZyQxMCIsIm9mX3N0cmluZyQxMCIsImNsYW1wX3VuY2hlY2tlZCQyIiwibm9uX3Bvc2l0aXZlX2FyZ3VtZW50IiwieCQzIiwieCQ0IiwieCQ1IiwieCQ2IiwiY29tcGFyZV9pbnQkMCIsImVxdWFsX2ludCQxIiwiaGFzaF9mb2xkX3QkMjMiLCJoYXNoJDEzIiwidG9fc3RyaW5nJDExIiwic2V4cF9vZl90JDM0IiwidF9vZl9zZXhwJDIxIiwidF9zZXhwX2dyYW1tYXIkMjIiLCJpbnZhcmlhbnQkMTUiLCJzdWNjX2V4biIsIm1zZyIsInN1Y2MkMiIsInByZWRfZXhuIiwicHJlZCQxIiwib2Zfc2NhbGFyIiwib2Zfc2NhbGFyX2V4biIsInRvX3NjYWxhciIsInRvX2NoYXIiLCJ0b19jaGFyX2V4biIsInV0ZjhfYnl0ZV9sZW5ndGgiLCJ1Y2hhciIsImNvZGVwb2ludCIsInNleHBfb2ZfdCQzNSIsInJlZmwiLCJzeW0iLCJ0cmFucyIsImNvbnYiLCJkZXR1cGxlMiIsInR1cGxlMiIsInNleHBfb2ZfdCQzNiIsIndpdG5lc3MiLCJ2XzAwNSIsInRvX3NleHAiLCJuYW1lJDAiLCJjcmVhdGUkOSIsInVpZCIsImhhc2gkMTQiLCJoYXNoX2ZvbGRfdCQyNCIsInNhbWVfd2l0bmVzcyIsInNhbWUiLCJzYW1lX3dpdG5lc3NfZXhuIiwibm9uZV9zdWJzdGl0dXRlIiwibm9uZSIsImlzX25vbmUkMCIsImlzX3NvbWUkMCIsInNvbWUkMCIsInZhbHVlX3Vuc2FmZSIsInZhbHVlX2V4biQwIiwib2Zfc2V4cGFibGUiLCJ0b19zZXhwYWJsZSIsInRfb2Zfc2V4cCQyMyIsInhfMDAzIiwic2V4cF9vZl90JDM4Iiwib2ZfYV8wMDQiLCJ4XzAwNSIsInRfc2V4cF9ncmFtbWFyJDIzIiwiY3JlYXRlJDEwIiwiaW5pdCQ2IiwiaW5pdF9zb21lIiwiZ2V0JDQiLCJnZXRfc29tZV9leG4iLCJpc19ub25lJDEiLCJpc19zb21lJDEiLCJzZXQkMiIsInNldF9zb21lIiwic2V0X25vbmUiLCJzd2FwJDQiLCJ1bnNhZmVfZ2V0JDEiLCJ1bnNhZmVfZ2V0X3NvbWVfZXhuIiwidW5zYWZlX2dldF9zb21lX2Fzc3VtaW5nX3NvbWUiLCJ1bnNhZmVfaXNfc29tZSIsInVuc2FmZV9zZXQkMSIsInVuc2FmZV9zZXRfc29tZSIsInVuc2FmZV9zZXRfbm9uZSIsImNsZWFyIiwiZWxlbSIsImZvbGQkNSIsImZvbGRpJDYiLCJpdGVyJDciLCJpdGVyaSQ1IiwibGVuZ3RoJDgiLCJtYXAkMjUiLCJtYXBfc29tZSIsIm9mX2FycmF5JDAiLCJvZl9hcnJheV9zb21lIiwidG9fYXJyYXkkNiIsImNyZWF0ZV9saWtlJDEiLCJjYXBhY2l0eSIsImludmFyaWFudCQxNiIsImVsdHMiLCJsZW5ndGhfMDAzIiwiZWx0c18wMDUiLCJhcmdfMDA2IiwiYm5kc18wMDIiLCJhcmdfMDA0IiwiYm5kc18wMDIkMCIsImNyZWF0ZSQxMSIsImxlbmd0aCQxMCIsImlzX2VtcHR5JDUiLCJmb2xkJDciLCJpdGVyJDkiLCJpdGVyJDEwIiwibGVuZ3RoJDExIiwib2ZfbGlzdCQzIiwic2V4cF9vZl90JDM5IiwidF9vZl9zZXhwJDI0IiwidF9zZXhwX2dyYW1tYXIkMjQiLCJyZXNpemUiLCJzaXplIiwic2V0X2NhcGFjaXR5IiwibmV3X2NhcGFjaXR5IiwibmV3X2NhcGFjaXR5JDAiLCJwdXNoIiwicG9wX25vbmVtcHR5IiwicG9wX2Vycm9yIiwicG9wIiwicG9wX2V4biIsInRvcF9ub25lbXB0eSIsInRvcF9lcnJvciIsInRvcCIsInRvcF9leG4iLCJjb3B5JDQiLCJjbGVhciQwIiwidW50aWxfZW1wdHkiLCJzaW5nbGV0b24kMiIsImhhc2gkMTUiLCJvZl9wb3MiLCJ0X29mX3NleHAkMjUiLCJzZXhwX29mX3QkNDAiLCJjb21wYXJlJDQyIiwiaGFzaF9mb2xkX3QkMjUiLCJoYXNoJDE2Iiwib2Zfc3RyaW5nJDExIiwidG9fc3RyaW5nJDEyIiwic3ltYm9sJDE1MiIsInN5bWJvbCQxNTMiLCJzeW1ib2wkMTU0Iiwic3ltYm9sJDE1NSIsInN5bWJvbCQxNTYiLCJzeW1ib2wkMTU3IiwiYXNjZW5kaW5nJDIyIiwiZGVzY2VuZGluZyQyMiIsImNvbXBhcmUkNDMiLCJlcXVhbCQyOCIsIm1heCQyOCIsIm1pbiQyOCIsIm9mX3NpZ24iLCJ0b19zaWduX2V4biIsIm9mX2ludCQ0IiwidG9faW50X2V4biQwIiwiZmxpcCQxIiwic3ltYm9sJDE1OCIsImFsbCQxNSIsImFsbF9vZl9hIiwiZW51bWVyYXRlXzAwMiIsImVudW1lcmF0ZV8wMDEiLCJhY2MkMiIsInRfb2Zfc2V4cCQyNyIsIm9mX2FfMDAzIiwic2V4cF8wMDgiLCJzZXhwX2FyZ3NfMDEwIiwic2V4cF9vZl90JDQyIiwiYXJnMF8wMjAiLCJyZXMwXzAyMSIsImFyZzBfMDIyIiwicmVzMF8wMjMiLCJ0X3NleHBfZ3JhbW1hciQyNiIsImludGVydmFsX2NvbXBhcmlzb25fb2Zfc2V4cCIsInNleHBfMDI4Iiwic2V4cF9vZl9pbnRlcnZhbF9jb21wYXJpc29uIiwiY29tcGFyZV9pbnRlcnZhbF9jb21wYXJpc29uIiwiaGFzaF9mb2xkX2ludGVydmFsX2NvbXBhcmlzb24iLCJoYXNoX2ludGVydmFsX2NvbXBhcmlzb24iLCJtYXAkMjYiLCJpbmNsIiwiZXhjbCIsImlzX2xvd2VyX2JvdW5kIiwiaXNfdXBwZXJfYm91bmQiLCJib3VuZHNfY3Jvc3NlZCIsImxvd2VyIiwidXBwZXIiLCJsb3dlciQwIiwidXBwZXIkMCIsImNvbXBhcmVfdG9faW50ZXJ2YWxfZXhuIiwiaW50ZXJ2YWxfY29udGFpbnNfZXhuIiwiY29tcGFyZSQ0NSIsInJpZ2h0XzAwNCIsImxlZnRfMDAzIiwiZXF1YWwkMzAiLCJhXzAwNSIsInJpZ2h0XzAwOCIsImxlZnRfMDA3Iiwic2V4cF9vZl90JDQzIiwib2ZfYV8wMDkiLCJ2XzAxMCIsImNvbXBhcmUkNDYiLCJjbXBfayIsImNtcF92IiwidF8wMTQiLCJ0XzAxMyIsInRfMDE2IiwidF8wMTUiLCJyaWdodF8wMTgiLCJsZWZ0XzAxNyIsInJpZ2h0XzAyMiIsImxlZnRfMDIxIiwidF8wMjQiLCJ0XzAyMyIsInRfMDI2IiwidF8wMjUiLCJyaWdodF8wMjAiLCJsZWZ0XzAxOSIsImVxdWFsJDMxIiwidF8wMzAiLCJ0XzAyOSIsInRfMDMyIiwidF8wMzEiLCJyaWdodF8wMzQiLCJsZWZ0XzAzMyIsInJpZ2h0XzAzOCIsImxlZnRfMDM3IiwidF8wNDAiLCJ0XzAzOSIsInRfMDQyIiwidF8wNDEiLCJyaWdodF8wMzYiLCJsZWZ0XzAzNSIsInRfb2Zfc2V4cCQyOCIsIm9mX2tfMDQzIiwib2Zfdl8wNDQiLCJzZXhwXzA3MSIsImFyZzFfMDY4IiwiYXJnMF8wNjciLCJyZXMwXzA2OSIsImF0b21fMDQ3Iiwic2V4cF9hcmdzXzA1MCIsImF0b21fMDQ3JDAiLCJhcmcwXzA1OCIsInJlczBfMDU5IiwiYXJnMF8wNjEiLCJyZXMwXzA2MiIsImFyZzBfMDY0IiwicmVzMF8wNjUiLCJyZXMxXzA3MCIsInNleHBfb2ZfdCQ0NCIsIm9mX2tfMDcyIiwib2Zfdl8wNzMiLCJhcmcxXzA4MiIsImFyZzBfMDgxIiwicmVzMF8wODMiLCJ2XzA3NCIsInJlczFfMDg0Iiwidl8wNzYiLCJhcmcxXzA3OCIsImFyZzBfMDc3IiwicmVzMF8wNzkiLCJyZXMxXzA4MCIsInZfMDc1IiwidF9zZXhwX2dyYW1tYXIkMjciLCJrX3NleHBfZ3JhbW1hciIsInZfc2V4cF9ncmFtbWFyIiwiY29tcGFyZSQ0NyIsImNtcF9sZWZ0IiwiY21wX3JpZ2h0IiwiYV8wODUiLCJiXzA4NiIsInJpZ2h0XzA5MiIsImxlZnRfMDkxIiwidF8wOTQiLCJ0XzA5MyIsInRfMDk2IiwidF8wOTUiLCJyaWdodF8wODgiLCJsZWZ0XzA4NyIsInJpZ2h0XzA5MCIsImxlZnRfMDg5IiwiZXF1YWwkMzIiLCJhXzA5NyIsImJfMDk4IiwicmlnaHRfMTA0IiwibGVmdF8xMDMiLCJ0XzEwNiIsInRfMTA1IiwidF8xMDgiLCJ0XzEwNyIsInJpZ2h0XzEwMCIsImxlZnRfMDk5IiwicmlnaHRfMTAyIiwibGVmdF8xMDEiLCJzZXhwX29mX3QkNDUiLCJvZl9sZWZ0XzEwOSIsIm9mX3JpZ2h0XzExMCIsInZfMTEzIiwiYXJnMV8xMTUiLCJhcmcwXzExNCIsInJlczBfMTE2IiwicmVzMV8xMTciLCJ2XzExMSIsInZfMTEyIiwiY29tcGFyZSQ0OCIsImVxdWFsJDMzIiwic2V4cF9vZl90JDQ2IiwiY29tcGFyZSQ0OSIsImVxdWFsJDM0Iiwic2V4cF9vZl90JDQ3IiwiaGVpZ2h0IiwibGVuZ3RoJDEyIiwiaW5fcmFuZ2UiLCJobCIsImhyIiwibG93ZXIkMSIsImludmFyaWFudHMiLCJpc19lbXB0eSQ2IiwiY3JlYXRlJDEyIiwiaCQxIiwiaCQwIiwic2wiLCJzciIsIm9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVjayIsImskMCIsImtsIiwiayQxIiwia2wkMCIsImskMiIsImtyIiwibGVmdF9sZW5ndGgiLCJyaWdodF9sZW5ndGgiLCJvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIiwiYXJyYXlfbGVuZ3RoIiwib2Zfc29ydGVkX2FycmF5IiwiaW5jcmVhc2luZyIsImJhbCIsImxyIiwibHYiLCJsbCIsImxyciIsImxydiQwIiwibHJsIiwibHJ2IiwicnIiLCJydiIsInJsIiwicmxyIiwicmx2JDAiLCJybGwiLCJybHYiLCJhZGQkMSIsImF1eCIsImpvaW4kNiIsInJoIiwicnYkMCIsIm1pbl9lbHQkNyIsIm1pbl9lbHRfZXhuIiwiZm9sZF91bnRpbCQ2IiwiZm9sZF91bnRpbF9oZWxwZXIiLCJtYXhfZWx0JDciLCJwYXJhbSQxIiwibWF4X2VsdF9leG4iLCJyZW1vdmVfbWluX2VsdCIsIm1lcmdlJDIiLCJjb25jYXQkMyIsInNwbGl0JDEiLCJtYXliZV9lbHQiLCJtYXliZV9lbHQkMCIsImFscmVhZHlfc2VlbiIsIm1lbSQ1IiwicmVtb3ZlJDAiLCJyZW1vdmVfaW5kZXgiLCJsX3NpemUiLCJ1bmlvbiIsInYyJDAiLCJyMiQwIiwidW5pb25fbGlzdCIsInRvX3RyZWUiLCJpbnRlciIsInYxJDAiLCJvdGhlcl9zZXQiLCJjb25zJDAiLCJlJDAiLCJlJDEiLCJjb25zX3JpZ2h0Iiwib2Zfc2V0IiwiaXRlciQxMSIsImVudW0kMCIsInRyZWUiLCJzeW1tZXRyaWNfZGlmZiIsImVudW0yIiwidHJlZTIiLCJjb21wYXJlX3Jlc3VsdCIsIm5leHRfc3RhdGUiLCJ0b19zZXF1ZW5jZSQwIiwiZ3JlYXRlcl9vcl9lcXVhbF90byIsImxlc3Nfb3JfZXF1YWxfdG8iLCJpbmNsdXNpdmVfYm91bmQiLCJzaWRlIiwibWF5YmUiLCJ0JDYiLCJ2JDIiLCJ2JDMiLCJ2JDQiLCJlJDIiLCJmaW5kX2ZpcnN0X3NhdGlzZnlpbmckMCIsImZpbmRfbGFzdF9zYXRpc2Z5aW5nJDAiLCJiaW5hcnlfc2VhcmNoJDEiLCJlbHQkMCIsImJpbmFyeV9zZWFyY2hfc2VnbWVudGVkJDEiLCJtZXJnZV90b19zZXF1ZW5jZSIsImNvbXBhcmUkNTAiLCJlMiQyIiwiZTEkMiIsImUyJDAiLCJlMSQwIiwiZTIkMSIsImUxJDEiLCJpdGVyMiQwIiwiZW51bTEiLCJ0cmVlMSIsInQyJDIiLCJ0MSQyIiwiZXF1YWwkMzUiLCJpc19zdWJzZXQiLCJhcmVfZGlzam9pbnQiLCJpdGVyJDEyIiwiZm9sZCQ4IiwiYWNjdSIsImFjY3UkMCIsImFjY3UkMSIsImNvdW50JDYiLCJzdW0kNiIsImZvbGRfcmlnaHQkMSIsImZvcl9hbGwkNyIsImV4aXN0cyQ3IiwiZmlsdGVyJDQiLCJmaWx0IiwiZmlsdGVyX21hcCQyIiwicGFydGl0aW9uX3RmJDEiLCJwYXJ0IiwiZWxlbWVudHNfYXV4IiwiZWxlbWVudHMiLCJjaG9vc2UiLCJub3RfZm91bmQkMTIiLCJjaG9vc2VfZXhuIiwib2ZfbGlzdCQ0Iiwib2Zfc2VxdWVuY2UkMCIsInRvX2xpc3QkOCIsIm9mX2FycmF5JDEiLCJ0b19hcnJheSQ3IiwicG9zX3JlZiIsIm1hcCQyNyIsImdyb3VwX2J5IiwiZXF1aXYiLCJlcXVpdl9jbGFzc2VzIiwiZXF1aXZfeCIsImVxdWl2X2NsYXNzZXMkMCIsImZpbmQkNyIsImZpbmRfbWFwJDYiLCJmaW5kX2V4biQzIiwibnRoJDEiLCJzdGFibGVfZGVkdXBfbGlzdCIsImxlZnRvdmVycyIsImFscmVhZHlfc2VlbiQwIiwiYWxyZWFkeV9zZWVuJDEiLCJsZWZ0b3ZlcnMkMCIsInRfb2Zfc2V4cF9kaXJlY3QiLCJlbHRfbHN0IiwiZWxfc2V4cCIsInNleHBfb2ZfdCQ0OCIsImlzX3N1YnNldCQwIiwic3Vic2V0Iiwic3VwZXJzZXQiLCJzZXhwX29mX2VsdCIsImludmFsaWRfZWxlbWVudHMiLCJpbnZhbGlkX2VsZW1lbnRzX3NleHAiLCJsaWtlIiwiY29tcGFyYXRvciQxMiIsImludmFyaWFudHMkMCIsImxlbmd0aCQxMyIsImlzX2VtcHR5JDciLCJlbGVtZW50cyQwIiwibWluX2VsdCQ4IiwibWluX2VsdF9leG4kMCIsIm1heF9lbHQkOCIsIm1heF9lbHRfZXhuJDAiLCJjaG9vc2UkMCIsImNob29zZV9leG4kMCIsInRvX2xpc3QkOSIsInRvX2FycmF5JDgiLCJmb2xkJDkiLCJmb2xkX3VudGlsJDciLCJmb2xkX3JpZ2h0JDIiLCJmb2xkX3Jlc3VsdCQ2IiwiaXRlciQxMyIsIml0ZXIyJDEiLCJleGlzdHMkOCIsImZvcl9hbGwkOCIsImNvdW50JDciLCJzdW0kNyIsImZpbmQkOCIsImZpbmRfZXhuJDQiLCJmaW5kX21hcCQ3IiwibWVtJDYiLCJmaWx0ZXIkNSIsImFkZCQyIiwicmVtb3ZlJDEiLCJ1bmlvbiQwIiwiaW50ZXIkMCIsImRpZmYkMCIsInN5bW1ldHJpY19kaWZmJDAiLCJjb21wYXJlX2RpcmVjdCIsImVxdWFsJDM2IiwiaXNfc3Vic2V0JDEiLCJvZiIsImFyZV9kaXNqb2ludCQwIiwidG9fbmFtZWRfdHJlZSIsImlzX3N1YnNldCQyIiwiZXF1YWwkMzciLCJwYXJ0aXRpb25fdGYkMiIsInRyZWVfZiIsInRyZWVfdCIsInNwbGl0JDIiLCJncm91cF9ieSQwIiwibnRoJDIiLCJyZW1vdmVfaW5kZXgkMCIsInNleHBfb2ZfdCQ0OSIsInRvX3NlcXVlbmNlJDEiLCJiaW5hcnlfc2VhcmNoJDIiLCJiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCQyIiwibWVyZ2VfdG9fc2VxdWVuY2UkMCIsImhhc2hfZm9sZF9kaXJlY3QiLCJoYXNoX2ZvbGRfa2V5IiwiY29tcGFyZSQ1MSIsInRfb2Zfc2V4cF9kaXJlY3QkMCIsImVtcHR5JDEiLCJzaW5nbGV0b24kMyIsImxlbmd0aCQxNCIsImludmFyaWFudHMkMSIsImlzX2VtcHR5JDgiLCJlbGVtZW50cyQxIiwibWluX2VsdCQ5IiwibWluX2VsdF9leG4kMSIsIm1heF9lbHQkOSIsIm1heF9lbHRfZXhuJDEiLCJjaG9vc2UkMSIsImNob29zZV9leG4kMSIsInRvX2xpc3QkMTAiLCJ0b19hcnJheSQ5IiwiaXRlciQxNCIsImV4aXN0cyQ5IiwiZm9yX2FsbCQ5IiwiY291bnQkOCIsInN1bSQ4IiwiZmluZCQ5IiwiZmluZF9leG4kNSIsImZpbmRfbWFwJDgiLCJmb2xkJDEwIiwiZm9sZF91bnRpbCQ4IiwiZm9sZF9yaWdodCQzIiwibWFwJDI4IiwiZmlsdGVyJDYiLCJmaWx0ZXJfbWFwJDMiLCJwYXJ0aXRpb25fdGYkMyIsIml0ZXIyJDIiLCJtZW0kNyIsImFkZCQzIiwicmVtb3ZlJDIiLCJ1bmlvbiQxIiwiaW50ZXIkMSIsImRpZmYkMSIsInN5bW1ldHJpY19kaWZmJDEiLCJjb21wYXJlX2RpcmVjdCQwIiwiZXF1YWwkMzgiLCJpc19zdWJzZXQkMyIsImFyZV9kaXNqb2ludCQxIiwib2ZfbGlzdCQ1Iiwib2Zfc2VxdWVuY2UkMSIsIm9mX2FycmF5JDIiLCJvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkJDAiLCJvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2skMCIsIm9mX3NvcnRlZF9hcnJheSQwIiwidW5pb25fbGlzdCQwIiwic3RhYmxlX2RlZHVwX2xpc3QkMCIsImdyb3VwX2J5JDEiLCJzcGxpdCQzIiwibnRoJDMiLCJyZW1vdmVfaW5kZXgkMSIsInNleHBfb2ZfdCQ1MCIsIm9mX3RyZWUiLCJ0b19zZXF1ZW5jZSQyIiwiYmluYXJ5X3NlYXJjaCQzIiwiYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQkMyIsIm1lcmdlX3RvX3NlcXVlbmNlJDEiLCJmb2xkX3Jlc3VsdCQ3IiwiaXNfc3Vic2V0JDQiLCJlcXVhbCQzOSIsInRvX3RyZWUkMCIsIm9mX3RyZWUkMCIsInRfb2Zfc2V4cF9kaXJlY3QkMSIsImVtcHR5JDIiLCJzaW5nbGV0b24kNCIsInVuaW9uX2xpc3QkMSIsIm9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQkMSIsIm9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVjayQxIiwib2Zfc29ydGVkX2FycmF5JDEiLCJvZl9saXN0JDYiLCJvZl9zZXF1ZW5jZSQyIiwib2ZfYXJyYXkkMyIsInN0YWJsZV9kZWR1cF9saXN0JDEiLCJtYXAkMjkiLCJmaWx0ZXJfbWFwJDQiLCJjb21wYXJhdG9yX3MiLCJlbXB0eSQzIiwic2luZ2xldG9uJDUiLCJ1bmlvbl9saXN0JDIiLCJvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkJDIiLCJvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2skMiIsIm9mX3NvcnRlZF9hcnJheSQyIiwib2ZfbGlzdCQ3Iiwib2Zfc2VxdWVuY2UkMyIsIm9mX2FycmF5JDQiLCJzdGFibGVfZGVkdXBfbGlzdCQyIiwibWFwJDMwIiwiZmlsdGVyX21hcCQ1Iiwic2V4cF9vZl9tX3QiLCJFbHQiLCJtX3Rfb2Zfc2V4cCIsIm1fdF9zZXhwX2dyYW1tYXIiLCJjb21wYXJlX21fdCIsImVxdWFsX21fdCIsImhhc2hfZm9sZF9tX3QiLCJoYXNoX21fdCIsImNvbXBhcmF0b3IkMTMiLCJlbXB0eSQ0Iiwic2luZ2xldG9uJDYiLCJ1bmlvbl9saXN0JDMiLCJvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkJDMiLCJvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2skMyIsIm9mX3NvcnRlZF9hcnJheSQzIiwib2ZfbGlzdCQ4Iiwib2Zfc2VxdWVuY2UkNCIsIm9mX2FycmF5JDUiLCJzdGFibGVfZGVkdXBfbGlzdCQzIiwibWFwJDMxIiwiZmlsdGVyX21hcCQ2Iiwib2ZfdHJlZSQxIiwidG9fdHJlZSQxIiwidF9zZXhwX2dyYW1tYXIkMjgiLCJzd2FwJDUiLCJyZXBsYWNlIiwic2V0X3RlbXBvcmFyaWx5IiwicmVzdG9yZV90byIsInNldCQzIiwic2V0cyIsInNuYXBzaG90Iiwic2V0c190ZW1wb3JhcmlseSIsImFuZF92YWx1ZXMiLCJpbmNfbnVtX211dGF0aW9ucyIsImNhcGFjaXR5JDAiLCJlbHRzX2luZGV4IiwidW5zYWZlX2dldCQyIiwidW5zYWZlX3NldCQyIiwiY2hlY2tfaW5kZXhfZXhuIiwiZ2V0JDUiLCJzZXQkNCIsImlzX2VtcHR5JDkiLCJsZW5ndGgkMTUiLCJlbnN1cmVfbm9fbXV0YXRpb24iLCJudW1fbXV0YXRpb25zIiwibnVtX211dGF0aW9uc18wMDMiLCJmcm9udF8wMDUiLCJtYXNrXzAwNyIsImxlbmd0aF8wMDkiLCJlbHRzXzAxMSIsImJuZHNfMDAyJDEiLCJibmRzXzAwMiQyIiwiYm5kc18wMDIkMyIsImNvbXBhcmUkNTIiLCJlcXVhbCQ0MCIsImludmFyaWFudCQxNyIsImZyb250IiwiY3JlYXRlJDEzIiwiY2FwYWNpdHkkMSIsImJsaXRfdG9fYXJyYXkiLCJmcm9udF9sZW4iLCJyZXN0X2xlbiIsInNldF9jYXBhY2l0eSQwIiwiZGVzaXJlZF9jYXBhY2l0eSIsImVucXVldWUiLCJkZXF1ZXVlX25vbmVtcHR5IiwiZGVxdWV1ZV9leG4iLCJkZXF1ZXVlIiwiZnJvbnRfbm9uZW1wdHkiLCJsYXN0X25vbmVtcHR5IiwicGVlayIsInBlZWtfZXhuIiwibGFzdCQxIiwibGFzdF9leG4kMCIsImNsZWFyJDEiLCJibGl0X3RyYW5zZmVyIiwibGVuJDEiLCJkc3Rfc3RhcnQiLCJzcmNfaSIsImRzdF9pIiwiZW5xdWV1ZV9hbGwiLCJmb2xkJDExIiwiZm9sZGkkOCIsIml0ZXIkMTUiLCJpdGVyaSQ3IiwidG9fbGlzdCQxMSIsIml0ZXIkMTYiLCJsZW5ndGgkMTYiLCJmb2xkaSQ5IiwiaXRlcmkkOCIsImNvdW50JDkiLCJleGlzdHMkMTAiLCJmaW5kJDEwIiwiZmluZF9tYXAkOSIsImZvbGRfcmVzdWx0JDgiLCJmb2xkX3VudGlsJDkiLCJmb3JfYWxsJDEwIiwibWF4X2VsdCQxMCIsIm1lbSQ4IiwibWluX2VsdCQxMCIsInN1bSQ5IiwiY291bnRpJDUiLCJleGlzdHNpJDUiLCJmaW5kX21hcGkkNSIsImZpbmRpJDUiLCJmb3JfYWxsaSQ1IiwiY29uY2F0X21hcCQyIiwidF9yZXN1bHQiLCJjb25jYXRfbWFwaSQyIiwiZmlsdGVyX21hcCQ3IiwiZmlsdGVyX21hcGkkMiIsImZpbHRlciQ3IiwiZmlsdGVyaSQzIiwiZmlsdGVyX2lucGxhY2UiLCJmaWx0ZXJpX2lucGxhY2UiLCJjb3B5JDUiLCJvZl9saXN0JDkiLCJpbml0JDciLCJvZl9hcnJheSQ2IiwidG9fYXJyYXkkMTAiLCJtYXAkMzIiLCJtYXBpJDYiLCJzaW5nbGV0b24kNyIsInNleHBfb2ZfdCQ1MSIsInRfb2Zfc2V4cCQyOSIsInRfc2V4cF9ncmFtbWFyJDI5IiwidG9fc3RyaW5nJDE0IiwiYWxsJDE4IiwiaGFzaF9mb2xkX3QkMjciLCJjb21wYXJlJDUzIiwidF9vZl9zZXhwJDMwIiwib2Zfc3RyaW5nJDEzIiwiZnVuYyQ5IiwiaGFzaGFibGUkNiIsImNvbXBhcmUkNTYiLCJ0b19zdHJpbmckMTYiLCJvZl9zdHJpbmckMTUiLCJ6ZXJvJDAiLCJoYXNoJDE5IiwiemVybyQxIiwibmVnJDEiLCJzeW1ib2wkMTcxIiwidG9fc3RyaW5nJDE3Iiwib2Zfc3RyaW5nJDE2IiwiaW52YXJpYW50JDE4IiwibnVtX2JpdHMkMSIsImZsb2F0X2xvd2VyX2JvdW5kJDAiLCJmbG9hdF91cHBlcl9ib3VuZCQwIiwibHNyJDAiLCJhc3IkMCIsImxzbCQwIiwibG5vdCQxIiwibHhvciQwIiwibG9yJDAiLCJsYW5kJDAiLCJtaW5fdmFsdWUkMyIsIm1heF92YWx1ZSQzIiwiYWJzJDMiLCJwcmVkJDIiLCJzdWNjJDMiLCJyZW0kMCIsIm5lZyQyIiwibWludXNfb25lJDAiLCJvbmUkMCIsInplcm8kMiIsInRvX2Zsb2F0JDEiLCJvZl9mbG9hdF91bmNoZWNrZWQkMCIsIm9mX2Zsb2F0JDAiLCJub25fcG9zaXRpdmVfYXJndW1lbnQkMCIsImNlaWxfcG93MiQwIiwiZmxvb3JfcG93MiQwIiwiaXNfcG93MiQwIiwiZmxvb3JfbG9nMiQwIiwiY2VpbF9sb2cyJDAiLCJiZXR3ZWVuJDExIiwiY2xhbXBfdW5jaGVja2VkJDMiLCJjbGFtcF9leG4kMTEiLCJjbGFtcCQxMSIsInN5bWJvbCQxNzIiLCJzeW1ib2wkMTczIiwic3ltYm9sJDE3NCIsInN5bWJvbCQxNzUiLCJpbmNyJDEiLCJkZWNyJDEiLCJvZl9uYXRpdmVpbnQiLCJ0b19uYXRpdmVpbnQkMCIsInBvdyQwIiwic3ltYm9sJDE3NiIsInN5bWJvbCQxNzciLCJzeW1ib2wkMTc4Iiwic3ltYm9sJDE3OSIsInN5bWJvbCQxODAiLCJzeW1ib2wkMTgxIiwic3ltYm9sJDE4MiIsImNvbXBhcmVfbmF0aXZlaW50JDAiLCJlcXVhbF9uYXRpdmVpbnQkMSIsImNvbXBhcmUkNTciLCJhbGwkMTkiLCJlcXVhbCQ0MiIsInNleHBfb2ZfdCQ1NCIsIm9mX2NvbnRpbnVlX29yX3N0b3AiLCJ0b19jb250aW51ZV9vcl9zdG9wIiwiY29tcGFyZSQ1OCIsImVxdWFsJDQzIiwic2V4cF9vZl90JDU1IiwibGVmdF92YWx1ZSIsInJpZ2h0X3ZhbHVlIiwidmFsdWVzIiwibGVmdF9kZWZhdWx0IiwicmlnaHRfZGVmYXVsdCIsInJpZ2h0JDAiLCJoZWlnaHQkMCIsImluX3JhbmdlJDAiLCJjb21wYXJlX2tleSIsImxvb3AkMCIsImludmFyaWFudHMkMiIsImNyZWF0ZSQxNCIsIm9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVjayQ0IiwidmwiLCJ2bCQwIiwidnIiLCJvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkJDQiLCJrMCIsImsxIiwib2Zfc29ydGVkX2FycmF5JDQiLCJiYWwkMCIsImxkIiwibHJkIiwibHJkJDAiLCJyZCIsInJsZCIsInJsZCQwIiwiZW1wdHlfd2l0aG91dF92YWx1ZV9yZXN0cmljdGlvIiwiaXNfZW1wdHkkMTAiLCJyYWlzZV9rZXlfYWxyZWFkeV9wcmVzZW50Iiwic2V4cF9vZl9rZXkiLCJmaW5kX2FuZF9hZGRfb3Jfc2V0IiwiZGF0YSIsImFkZF9vcl9zZXQiLCJkJDAiLCJhZGRfZXhuIiwiYWRkX2V4bl9pbnRlcm5hbCIsInNldCQ1Iiwic2V0JDYiLCJzaW5nbGV0b25fdG9fdHJlZV9leG4iLCJjb2xsYXBzZSIsImpvaW4kNyIsImdvIiwiYWRkX3VuY2hlY2tlZCIsImdvJDAiLCJ0b190cmVlX3VuY2hlY2tlZCIsIm1heF9rZXkiLCJvZl9pbmNyZWFzaW5nX3NlcXVlbmNlIiwiYnVpbGRlciIsInByZXZfa2V5Iiwiam9pbiQ4IiwicmsiLCJyZCQwIiwicmskMCIsImxrIiwic3BsaXQkNCIsImNtcCQwIiwibWF5YmUkMCIsInNwbGl0X2FuZF9yZWluc2VydF9ib3VuZGFyeSIsImludG8iLCJib3VuZGFyeV9vcHQiLCJpbnNlcnRfaW50byIsInNwbGl0X3JhbmdlIiwibWlkX2FuZF9yaWdodCIsImxiJDEiLCJsYiQyIiwibWlkX2FuZF9yaWdodCQwIiwibGIiLCJsYiQwIiwibWlkJDAiLCJmaW5kJDExIiwiYWRkX211bHRpIiwiZGF0YSQwIiwiZmluZF9tdWx0aSIsImZpbmRfZXhuJDYiLCJtZW0kOSIsIm1pbl9lbHQkMTEiLCJtaW5fZWx0X2V4biQyIiwibWF4X2VsdCQxMSIsIm1heF9lbHRfZXhuJDIiLCJyZW1vdmVfbWluX2VsdCQwIiwiYXBwZW5kJDIiLCJsb3dlcl9wYXJ0IiwidXBwZXJfcGFydCIsIm1pbl91cHBlciIsIm1heF9sb3dlciIsInVwcGVyX3BhcnRfd2l0aG91dF9taW4iLCJnbyQxIiwiY19taW4iLCJjX21heCIsImZvbGRfcmFuZ2VfaW5jbHVzaXZlIiwicmFuZ2VfdG9fYWxpc3QiLCJjb25jYXRfdW5jaGVja2VkIiwicmVtb3ZlJDMiLCJyZW1vdmVfbG9vcCIsImNoYW5nZSIsImNoYW5nZV9jb3JlIiwiZCQxIiwidXBkYXRlIiwidXBkYXRlX2NvcmUiLCJyZW1vdmVfbXVsdGkiLCJpdGVyX2tleXMiLCJpdGVyJDE3IiwiaXRlcmkkOSIsIml0ZXJpX3VudGlsX2xvb3AiLCJpdGVyaV91bnRpbCIsIm1hcCQzMyIsIm1hcGkkNyIsImZvbGQkMTIiLCJmb2xkX3VudGlsJDEwIiwiZm9sZF91bnRpbF9sb29wIiwiZmluYWwkMSIsImZpbmFsJDAiLCJmb2xkX3JpZ2h0JDQiLCJmaWx0ZXJfa2V5cyIsImZpbHRlciQ4IiwiZmlsdGVyaSQ0IiwiZmlsdGVyX21hcCQ4IiwiZmlsdGVyX21hcGkkMyIsInBhcnRpdGlvbl9tYXBpIiwicGFpcjIiLCJwYWlyMSIsInBhcnRpdGlvbl9tYXAkMCIsInBhcnRpdGlvbmlfdGYkMCIsInBhcnRpdGlvbl90ZiQ0IiwiY29ucyQxIiwiY29uc19yaWdodCQwIiwib2ZfdHJlZSQyIiwiZm9sZCQxMyIsImZvbGQyJDAiLCJjdXJyIiwiY3VyciQwIiwiazIiLCJjdXJyJDEiLCJjdXJyJDIiLCJjdXJyJDMiLCJzeW1tZXRyaWNfZGlmZiQyIiwiZGF0YV9lcXVhbCIsInRvX3NlcXVlbmNlJDMiLCJrZXlzX2dyZWF0ZXJfb3JfZXF1YWxfdG8iLCJrZXlzX2xlc3Nfb3JfZXF1YWxfdG8iLCJkJDIiLCJjb21wYXJlJDU5IiwiY29tcGFyZV9kYXRhIiwiZDIiLCJkMSIsImVxdWFsJDQ0IiwiaXRlcjIkMyIsImZvbGQyJDEiLCJmb2xkX3N5bW1ldHJpY19kaWZmIiwiZGVsdGEiLCJhY2MkMyIsImFjYyQ0IiwiYWNjJDUiLCJhY2MkNiIsImFjYyQ3IiwiYWNjJDgiLCJyaWdodCQyIiwibGVmdCQyIiwicmlnaHQkMSIsImxlbmd0aCQxNyIsImtleXMiLCJvZl9mb2xkYWJsZV9mb2xkIiwiZm9sZGFibGUiLCJwcmV2X2RhdGEiLCJvZl9mb2xkYWJsZV9yZWR1Y2UiLCJuZXdfZGF0YSIsIm9mX2ZvbGRhYmxlIiwib2ZfZm9sZGFibGVfb3JfZXJyb3IiLCJvZl9mb2xkYWJsZV9leG4iLCJvZl9hbGlzdF9mb2xkIiwib2ZfYWxpc3RfcmVkdWNlIiwib2ZfYWxpc3QiLCJvZl9hbGlzdF9vcl9lcnJvciIsIm9mX2FsaXN0X2V4biIsIm9mX2ZvbGRhYmxlX211bHRpIiwib2ZfYWxpc3RfbXVsdGkiLCJvZl9zZXF1ZW5jZV9mb2xkIiwib2Zfc2VxdWVuY2VfcmVkdWNlIiwib2Zfc2VxdWVuY2UkNSIsIm9mX3NlcXVlbmNlX29yX2Vycm9yIiwib2Zfc2VxdWVuY2VfZXhuIiwib2Zfc2VxdWVuY2VfbXVsdGkiLCJmb3JfYWxsJDExIiwiZm9yX2FsbGkkNiIsImV4aXN0cyQxMSIsImV4aXN0c2kkNiIsImNvdW50JDEwIiwiY291bnRpJDYiLCJ0b19hbGlzdCIsImtleV9vcmRlciIsIm1lcmdlJDMiLCJtZXJnZV9sYXJnZV9maXJzdCIsImxlbmd0aF9sYXJnZSIsInRfbGFyZ2UiLCJ0X3NtYWxsIiwiY2FsbCQwIiwic3dhcCQ2IiwibWVyZ2Vfc2tld2VkIiwibGVuZ3RoMSIsImxlbmd0aDIiLCJyZXBhY2thZ2UiLCJtYXJrZXIiLCJjbG9zZXN0X2tleSIsImZvdW5kX21hcmtlciIsImZvdW5kX2tleSIsImZvdW5kX3ZhbHVlIiwicmFuayIsIm50aCQ0IiwibnVtX3RvX3NlYXJjaCIsIm50aCQ1IiwiZmluZF9maXJzdF9zYXRpc2Z5aW5nJDEiLCJmaW5kX2xhc3Rfc2F0aXNmeWluZyQxIiwiYmluYXJ5X3NlYXJjaCQ0IiwicGFpciIsInBhaXIkMCIsImJpbmFyeV9zZWFyY2hfc2VnbWVudGVkJDQiLCJiaW5hcnlfc2VhcmNoX29uZV9zaWRlZF9ib3VuZCIsIm1heWJlX2JvdW5kIiwiaWZfZXhjbHVzaXZlIiwiaWZfaW5jbHVzaXZlIiwiZmluZF9ib3VuZCIsImJvdW5kJDAiLCJiaW5hcnlfc2VhcmNoX3R3b19zaWRlZF9ib3VuZHMiLCJsb3dlcl9ib3VuZCQwIiwidXBwZXJfYm91bmQkMCIsIm9mX2l0ZXJpIiwib2ZfaXRlcmlfZXhuIiwidF9vZl9zZXhwX2RpcmVjdCQyIiwia2V5X29mX3NleHAiLCJ2YWx1ZV9vZl9zZXhwIiwiYWxpc3Rfc2V4cHMiLCJmb3VuZF9maXJzdF9rIiwiazJfc2V4cCIsInNleHBfb2ZfdCQ1NiIsInNleHBfb2ZfdmFsdWUiLCJjb21iaW5lX2Vycm9ycyQxIiwiZXJyb3JfdHJlZSIsIm9rcyIsIm1hcF9rZXlzIiwibWFwX2tleXNfZXhuIiwibGlrZSQwIiwibGlrZTIiLCJsaWtlX21heWJlX25vX29wIiwib2xkX3QiLCJvbGRfdHJlZSIsIndpdGhfc2FtZV9sZW5ndGgiLCJvZl90cmVlJDMiLCJjb21wYXJhdG9yJDE2IiwidG9fdHJlZSQyIiwiaW52YXJpYW50cyQzIiwiaXNfZW1wdHkkMTEiLCJsZW5ndGgkMTgiLCJzZXQkNyIsImFkZF9leG4kMCIsImFkZF9leG5faW50ZXJuYWwkMCIsImFkZCQ0IiwiYWRkX211bHRpJDAiLCJyZW1vdmVfbXVsdGkkMCIsImZpbmRfbXVsdGkkMCIsImNoYW5nZSQwIiwidXBkYXRlJDAiLCJmaW5kX2V4biQ3IiwiZmluZCQxMiIsInJlbW92ZSQ0IiwibWVtJDEwIiwiaXRlcl9rZXlzJDAiLCJpdGVyJDE4IiwiaXRlcmkkMTAiLCJpdGVyaV91bnRpbCQwIiwiaXRlcjIkNCIsIm1hcCQzNCIsIm1hcGkkOCIsImZvbGQkMTQiLCJmb2xkX3VudGlsJDExIiwiZm9sZF9yaWdodCQ1IiwiZm9sZDIkMiIsImZpbHRlcl9rZXlzJDAiLCJmaWx0ZXIkOSIsImZpbHRlcmkkNSIsImZpbHRlcl9tYXAkOSIsImZpbHRlcl9tYXBpJDQiLCJwYXJ0aXRpb25fbWFwaSQwIiwicGFydGl0aW9uX21hcCQxIiwicGFydGl0aW9uaV90ZiQxIiwicGFydGl0aW9uX3RmJDUiLCJjb21iaW5lX2Vycm9ycyQyIiwiY29tcGFyZV9kaXJlY3QkMSIsImVxdWFsJDQ1Iiwia2V5cyQwIiwidG9fYWxpc3QkMCIsInN5bW1ldHJpY19kaWZmJDMiLCJmb2xkX3N5bW1ldHJpY19kaWZmJDAiLCJtZXJnZSQ0IiwibWVyZ2Vfc2tld2VkJDAiLCJtaW5fZWx0JDEyIiwibWluX2VsdF9leG4kMyIsIm1heF9lbHQkMTIiLCJtYXhfZWx0X2V4biQzIiwiZm9yX2FsbCQxMiIsImZvcl9hbGxpJDciLCJleGlzdHMkMTIiLCJleGlzdHNpJDciLCJjb3VudCQxMSIsImNvdW50aSQ3Iiwic3BsaXQkNSIsImJvdGhfbGVuIiwic3VicmFuZ2UiLCJoX2wiLCJoX3IiLCJvdXRlcl9qb2luZWRfaGVpZ2h0IiwibWlkX2xlbmd0aCIsImFwcGVuZCQzIiwiZm9sZF9yYW5nZV9pbmNsdXNpdmUkMCIsInJhbmdlX3RvX2FsaXN0JDAiLCJjbG9zZXN0X2tleSQwIiwibnRoJDYiLCJudGhfZXhuJDEiLCJyYW5rJDAiLCJzZXhwX29mX3QkNTciLCJzZXhwX29mX2siLCJzZXhwX29mX3YiLCJ0b19zZXF1ZW5jZSQ0IiwiYmluYXJ5X3NlYXJjaCQ1IiwiYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQkNSIsImhhc2hfZm9sZF9kaXJlY3QkMCIsImhhc2hfZm9sZF9kYXRhIiwiYmluYXJ5X3NlYXJjaF9zdWJyYW5nZSIsImVtcHR5JDYiLCJvZl90cmVlJDQiLCJzaW5nbGV0b24kOCIsIm9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQkNSIsIm9mX3NvcnRlZF9hcnJheSQ1Iiwib2ZfYWxpc3QkMCIsIm9mX2FsaXN0X29yX2Vycm9yJDAiLCJvZl9hbGlzdF9leG4kMCIsIm9mX2FsaXN0X211bHRpJDAiLCJvZl9hbGlzdF9mb2xkJDAiLCJvZl9hbGlzdF9yZWR1Y2UkMCIsIm9mX2l0ZXJpJDAiLCJvZl9pdGVyaV9leG4kMCIsIm9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVjayQ1IiwicmVxdWlyZWRfYnlfaW50ZiIsIm9mX2luY3JlYXNpbmdfc2VxdWVuY2UkMCIsIm9mX3NlcXVlbmNlJDYiLCJvZl9zZXF1ZW5jZV9vcl9lcnJvciQwIiwib2Zfc2VxdWVuY2VfZXhuJDAiLCJvZl9zZXF1ZW5jZV9tdWx0aSQwIiwib2Zfc2VxdWVuY2VfZm9sZCQwIiwib2Zfc2VxdWVuY2VfcmVkdWNlJDAiLCJ0b190cmVlJDMiLCJpbnZhcmlhbnRzJDQiLCJpc19lbXB0eSQxMiIsImxlbmd0aCQxOSIsInNldCQ4IiwiYWRkX2V4biQxIiwiYWRkJDUiLCJhZGRfbXVsdGkkMSIsInJlbW92ZV9tdWx0aSQxIiwiZmluZF9tdWx0aSQxIiwiY2hhbmdlJDEiLCJ1cGRhdGUkMSIsImZpbmRfZXhuJDgiLCJmaW5kJDEzIiwicmVtb3ZlJDUiLCJtZW0kMTEiLCJpdGVyX2tleXMkMSIsIml0ZXIkMTkiLCJpdGVyaSQxMSIsIml0ZXJpX3VudGlsJDEiLCJpdGVyMiQ1IiwibWFwJDM1IiwibWFwaSQ5IiwiZm9sZCQxNSIsImZvbGRfdW50aWwkMTIiLCJmb2xkX3JpZ2h0JDYiLCJmb2xkMiQzIiwiZmlsdGVyX2tleXMkMSIsImZpbHRlciQxMCIsImZpbHRlcmkkNiIsImZpbHRlcl9tYXAkMTAiLCJmaWx0ZXJfbWFwaSQ1IiwicGFydGl0aW9uX21hcGkkMSIsInBhcnRpdGlvbl9tYXAkMiIsInBhcnRpdGlvbmlfdGYkMiIsInBhcnRpdGlvbl90ZiQ2IiwiY29tYmluZV9lcnJvcnMkMyIsImNvbXBhcmVfZGlyZWN0JDIiLCJlcXVhbCQ0NiIsImtleXMkMSIsImRhdGEkMSIsInRvX2FsaXN0JDEiLCJzeW1tZXRyaWNfZGlmZiQ0IiwiZm9sZF9zeW1tZXRyaWNfZGlmZiQxIiwibWVyZ2UkNSIsIm1lcmdlX3NrZXdlZCQxIiwibWluX2VsdCQxMyIsIm1pbl9lbHRfZXhuJDQiLCJtYXhfZWx0JDEzIiwibWF4X2VsdF9leG4kNCIsImZvcl9hbGwkMTMiLCJmb3JfYWxsaSQ4IiwiZXhpc3RzJDEzIiwiZXhpc3RzaSQ4IiwiY291bnQkMTIiLCJjb3VudGkkOCIsInNwbGl0JDYiLCJhcHBlbmQkNCIsInN1YnJhbmdlJDAiLCJmb2xkX3JhbmdlX2luY2x1c2l2ZSQxIiwicmFuZ2VfdG9fYWxpc3QkMSIsImNsb3Nlc3Rfa2V5JDEiLCJudGgkNyIsIm50aF9leG4kMiIsInJhbmskMSIsInNleHBfb2ZfdCQ1OCIsInRfb2Zfc2V4cF9kaXJlY3QkMyIsImtfb2Zfc2V4cCIsInZfb2Zfc2V4cCIsInRvX3NlcXVlbmNlJDUiLCJiaW5hcnlfc2VhcmNoJDYiLCJiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCQ2IiwiYmluYXJ5X3NlYXJjaF9zdWJyYW5nZSQwIiwibWFwX2tleXMkMCIsImR1cCIsIm1hcF9rZXlzX2V4biQwIiwiYWRkX2V4biQyIiwidG9fdHJlZSQ0IiwiZW1wdHkkNyIsInNpbmdsZXRvbiQ5Iiwib2ZfdHJlZTAiLCJvZl90cmVlJDUiLCJvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkJDYiLCJvZl9zb3J0ZWRfYXJyYXkkNiIsIm9mX2FsaXN0JDEiLCJvZl9hbGlzdF9vcl9lcnJvciQxIiwib2ZfYWxpc3RfZXhuJDEiLCJvZl9hbGlzdF9tdWx0aSQxIiwib2ZfYWxpc3RfZm9sZCQxIiwib2ZfYWxpc3RfcmVkdWNlJDEiLCJvZl9pdGVyaSQxIiwidHJlZV9sZW5ndGgiLCJvZl9pdGVyaV9leG4kMSIsIm9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVjayQ2Iiwib2ZfaW5jcmVhc2luZ19zZXF1ZW5jZSQxIiwib2Zfc2VxdWVuY2UkNyIsIm9mX3NlcXVlbmNlX29yX2Vycm9yJDEiLCJvZl9zZXF1ZW5jZV9leG4kMSIsIm9mX3NlcXVlbmNlX211bHRpJDEiLCJvZl9zZXF1ZW5jZV9mb2xkJDEiLCJvZl9zZXF1ZW5jZV9yZWR1Y2UkMSIsInRfb2Zfc2V4cF9kaXJlY3QkNCIsIm1hcF9rZXlzJDEiLCJtYXBfa2V5c19leG4kMSIsImNvbXBhcmF0b3JfcyQwIiwib2ZfdHJlZSQ2IiwiZW1wdHkkOCIsInNpbmdsZXRvbiQxMCIsIm9mX2FsaXN0JDIiLCJvZl9hbGlzdF9vcl9lcnJvciQyIiwib2ZfYWxpc3RfZXhuJDIiLCJvZl9hbGlzdF9tdWx0aSQyIiwib2ZfYWxpc3RfZm9sZCQyIiwib2ZfYWxpc3RfcmVkdWNlJDIiLCJvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkJDciLCJvZl9zb3J0ZWRfYXJyYXkkNyIsIm9mX2l0ZXJpJDIiLCJvZl9pdGVyaV9leG4kMiIsIm9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVjayQ3Iiwib2ZfaW5jcmVhc2luZ19zZXF1ZW5jZSQyIiwib2Zfc2VxdWVuY2UkOCIsIm9mX3NlcXVlbmNlX29yX2Vycm9yJDIiLCJvZl9zZXF1ZW5jZV9leG4kMiIsIm9mX3NlcXVlbmNlX211bHRpJDIiLCJvZl9zZXF1ZW5jZV9mb2xkJDIiLCJvZl9zZXF1ZW5jZV9yZWR1Y2UkMiIsIm1hcF9rZXlzJDIiLCJtYXBfa2V5c19leG4kMiIsInNleHBfb2ZfbV90JDAiLCJLIiwibV90X29mX3NleHAkMCIsIm1fdF9zZXhwX2dyYW1tYXIkMCIsInZfZ3JhbW1hciIsImNvbXBhcmVfbV90JDAiLCJjb21wYXJlX3YiLCJlcXVhbF9tX3QkMCIsImVxdWFsX3YiLCJoYXNoX2ZvbGRfbV90JDAiLCJoYXNoX2ZvbGRfdiIsImNvbXBhcmF0b3IkMTciLCJvZl90cmVlJDciLCJlbXB0eSQ5Iiwic2luZ2xldG9uJDExIiwib2ZfYWxpc3QkMyIsIm9mX2FsaXN0X29yX2Vycm9yJDMiLCJvZl9hbGlzdF9leG4kMyIsIm9mX2FsaXN0X211bHRpJDMiLCJvZl9hbGlzdF9mb2xkJDMiLCJvZl9hbGlzdF9yZWR1Y2UkMyIsIm9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQkOCIsIm9mX3NvcnRlZF9hcnJheSQ4Iiwib2ZfaXRlcmkkMyIsIm9mX2l0ZXJpX2V4biQzIiwib2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrJDgiLCJvZl9pbmNyZWFzaW5nX3NlcXVlbmNlJDMiLCJvZl9zZXF1ZW5jZSQ5Iiwib2Zfc2VxdWVuY2Vfb3JfZXJyb3IkMyIsIm9mX3NlcXVlbmNlX2V4biQzIiwib2Zfc2VxdWVuY2VfbXVsdGkkMyIsIm9mX3NlcXVlbmNlX2ZvbGQkMyIsIm9mX3NlcXVlbmNlX3JlZHVjZSQzIiwibWFwX2tleXMkMyIsIm1hcF9rZXlzX2V4biQzIiwiY3JlYXRlJDE1IiwiY2xlYXIkMiIsImNvcHkkNiIsImlzX2VtcHR5JDEzIiwibGVuZ3RoJDIwIiwicGVla19leG4kMCIsImRlcXVldWVfZXhuJDAiLCJwdXNoJDAiLCJ0cmFuc2ZlciIsIml0ZXIkMjAiLCJmb2xkJDE2IiwiZW5xdWV1ZSQwIiwiZGVxdWV1ZSQwIiwicGVlayQwIiwiaXRlciQyMSIsImxlbmd0aCQyMSIsImNvdW50JDEzIiwiZXhpc3RzJDE0IiwiZmluZCQxNCIsImZpbmRfbWFwJDEwIiwiZm9sZF9yZXN1bHQkOSIsImZvbGRfdW50aWwkMTMiLCJmb3JfYWxsJDE0IiwibWF4X2VsdCQxNCIsIm1lbSQxMiIsIm1pbl9lbHQkMTQiLCJzdW0kMTAiLCJ0b19saXN0JDEyIiwiY291bnRpJDkiLCJleGlzdHNpJDkiLCJmaW5kX21hcGkkNiIsImZpbmRpJDYiLCJmb2xkaSQxMCIsImZvcl9hbGxpJDkiLCJpdGVyaSQxMiIsInRyYW5zZmVyJDAiLCJjb25jYXRfbWFwJDMiLCJjb25jYXRfbWFwaSQzIiwiZmlsdGVyX21hcCQxMSIsImZpbHRlcl9tYXBpJDYiLCJmaWx0ZXIkMTEiLCJmaWx0ZXJpJDciLCJtYXAkMzYiLCJtYXBpJDEwIiwiZmlsdGVyX2lucGxhY2UkMCIsInEiLCJxJDAiLCJmaWx0ZXJpX2lucGxhY2UkMCIsImVucXVldWVfYWxsJDAiLCJvZl9saXN0JDEwIiwib2ZfYXJyYXkkNyIsImluaXQkOCIsInRvX2FycmF5JDExIiwidF9vZl9zZXhwJDMyIiwic2V4cF9vZl90JDU5IiwidF9zZXhwX2dyYW1tYXIkMzEiLCJzaW5nbGV0b24kMTIiLCJmdW5jJDEwIiwiaGFzaGFibGUkNyIsImNvbXBhcmUkNjAiLCJ0b19zdHJpbmckMTgiLCJvZl9zdHJpbmckMTciLCJmbG9hdF9sb3dlcl9ib3VuZCQxIiwiZmxvYXRfdXBwZXJfYm91bmQkMSIsImZsb2F0X29mX2JpdHMiLCJiaXRzX29mX2Zsb2F0Iiwic2hpZnRfcmlnaHRfbG9naWNhbCQwIiwic2hpZnRfcmlnaHQkMSIsInNoaWZ0X2xlZnQkMCIsImxub3QkMiIsImJpdF94b3IkMCIsImJpdF9vciQwIiwiYml0X2FuZCQwIiwibWluX3ZhbHVlJDQiLCJtYXhfdmFsdWUkNCIsImFicyQ0IiwicHJlZCQzIiwic3VjYyQ0IiwicG93JDEiLCJyZW0kMSIsIm5lZyQzIiwibWludXNfb25lJDEiLCJvbmUkMSIsInplcm8kMyIsInRvX2Zsb2F0JDIiLCJvZl9mbG9hdF91bmNoZWNrZWQkMSIsIm51bV9iaXRzJDIiLCJvZl9mbG9hdCQxIiwic3ltYm9sJDE5MiIsImJzd2FwMTYiLCJic3dhcDMyIiwiYnN3YXA0OCIsImludmFyaWFudCQxOSIsImJldHdlZW4kMTIiLCJjbGFtcF91bmNoZWNrZWQkNCIsImNsYW1wX2V4biQxMiIsImNsYW1wJDEyIiwiaW5jciQyIiwiZGVjciQyIiwib2ZfaW50NjRfZXhuIiwidG9faW50NjQiLCJvZl9pbnRfZXhuJDAiLCJvZl9pbnQzMl9leG4iLCJub25fcG9zaXRpdmVfYXJndW1lbnQkMSIsImNlaWxfcG93MiQxIiwiZmxvb3JfcG93MiQxIiwiaXNfcG93MiQxIiwiZmxvb3JfbG9nMiQxIiwiY2VpbF9sb2cyJDEiLCJzZXhwX29mX2ludDY0IiwiaGFzaCQyMCIsInN5bWJvbCQxOTMiLCJ0b19zdHJpbmckMTkiLCJvZl9zdHJpbmckMTgiLCJjb21wYXJlX2ludDY0JDAiLCJlcXVhbF9pbnQ2NCQxIiwiY29tcGFyYXRvciQxOCIsIndyYXBfZXhuIiwid3JhcF9tb2R1bG8iLCJ1bndyYXAiLCJpbnZhcmlhbnQkMjAiLCJzeW1ib2wkMTk3Iiwic3ltYm9sJDE5OCIsIm5lZyQ0IiwiYWJzJDUiLCJvbmUkMiIsInN1Y2MkNSIsInByZWQkNCIsIm1pbl92YWx1ZSQ1IiwibWF4X3ZhbHVlJDUiLCJsbm90JDMiLCJsYW5kJDEiLCJseG9yJDEiLCJsb3IkMSIsImxzbCQxIiwiYXNyJDEiLCJsc3IkMSIsInBvdyQyIiwic3ltYm9sJDE5OSIsInN5bWJvbCQyMDAiLCJyZW0kMiIsInBvcGNvdW50JDEiLCJ0b19pbnQ2NCQwIiwib2ZfaW50NjQiLCJvZl9pbnQ2NF9leG4kMCIsIm9mX2ludDY0X3RydW5jIiwidF9vZl9zZXhwJDMzIiwic2V4cF9vZl90JDYwIiwiY29tcGFyZSQ2MSIsImlzX3BvdzIkMiIsImNseiQwIiwiY3R6JDAiLCJmbG9vcl9wb3cyJDIiLCJjZWlsX3BvdzIkMiIsImZsb29yX2xvZzIkMiIsImNlaWxfbG9nMiQyIiwiZnVuYyQxMSIsImhhc2hhYmxlJDgiLCJpbnZhbGlkX3N0ciIsInNpZ25fYW5kX3NpZ25lZG5lc3MiLCJzaWduIiwidG9fc3RyaW5nJDIwIiwib2Zfc3RyaW5nJDE5Iiwic2lnbmVkbmVzcyIsInBvc19zdHIiLCJpbnQ2MyIsImludDYzJDAiLCJic3dhcDE2JDAiLCJic3dhcDMyJDAiLCJic3dhcDQ4JDAiLCJmbG9hdF9sb3dlcl9ib3VuZCQyIiwiZmxvYXRfdXBwZXJfYm91bmQkMiIsIm1pbnVzX29uZSQyIiwib25lJDMiLCJ6ZXJvJDQiLCJudW1fYml0cyQzIiwidG9fZmxvYXQkMyIsIm9mX2Zsb2F0X3VuY2hlY2tlZCQyIiwib2ZfZmxvYXQkMiIsImJldHdlZW4kMTMiLCJjbGFtcF91bmNoZWNrZWQkNSIsImNsYW1wX2V4biQxMyIsImNsYW1wJDEzIiwic3ltYm9sJDIwMSIsImluY3IkMyIsImRlY3IkMyIsIm9mX2ludCQ1Iiwib2ZfaW50X2V4biQxIiwidG9faW50JDQiLCJ0b19pbnRfZXhuJDEiLCJ0b19pbnRfdHJ1bmMiLCJvZl9pbnQzMiIsIm9mX2ludDMyX2V4biQwIiwidG9faW50MzIiLCJ0b19pbnQzMl9leG4iLCJ0b19pbnQzMl90cnVuYyIsIm9mX25hdGl2ZWludCQwIiwib2ZfbmF0aXZlaW50X2V4biIsIm9mX25hdGl2ZWludF90cnVuYyIsInRvX25hdGl2ZWludCQxIiwidG9fbmF0aXZlaW50X2V4biQwIiwidG9fbmF0aXZlaW50X3RydW5jIiwiaGFzaCQyMSIsInN5bWJvbCQyMDIiLCJ0b19zdHJpbmckMjEiLCJvZl9zdHJpbmckMjAiLCJ0b19zdHJpbmckMjIiLCJzeW1ib2wkMjAzIiwic3ltYm9sJDIwNCIsInN5bWJvbCQyMDUiLCJzeW1ib2wkMjA2Iiwic3ltYm9sJDIwNyIsInN5bWJvbCQyMDgiLCJyZXByIiwiaGFzaCQyMiIsImhhc2hhYmxlJDkiLCJvZl9zdHJpbmckMjEiLCJ0b19zdHJpbmckMjMiLCJpbnZhcmlhbnQkMjEiLCJiZXR3ZWVuJDE0IiwiY2xhbXBfdW5jaGVja2VkJDYiLCJjbGFtcF9leG4kMTQiLCJjbGFtcCQxNCIsInRvX2ludCQ1Iiwic3ltYm9sJDIxMiIsInN5bWJvbCQyMTMiLCJjb21wYXJlX2Jvb2wkMCIsImVxdWFsX2Jvb2wkMSIsImZ1bmMkMTIiLCJoYXNoYWJsZSQxMCIsImNvbXBhcmVfaW50MzIkMCIsInRvX3N0cmluZyQyNCIsIm9mX3N0cmluZyQyMiIsImZsb2F0X2xvd2VyX2JvdW5kJDMiLCJmbG9hdF91cHBlcl9ib3VuZCQzIiwiZmxvYXRfb2ZfYml0cyQwIiwiYml0c19vZl9mbG9hdCQwIiwibnVtX2JpdHMkNCIsImxzciQyIiwiYXNyJDIiLCJsc2wkMiIsImxub3QkNCIsImx4b3IkMiIsImxvciQyIiwibGFuZCQyIiwibWluX3ZhbHVlJDYiLCJtYXhfdmFsdWUkNiIsImFicyQ2IiwicHJlZCQ1Iiwic3VjYyQ2IiwicmVtJDMiLCJuZWckNSIsIm1pbnVzX29uZSQzIiwib25lJDQiLCJ6ZXJvJDUiLCJ0b19mbG9hdCQ0Iiwib2ZfZmxvYXRfdW5jaGVja2VkJDMiLCJvZl9mbG9hdCQzIiwic3ltYm9sJDIyMCIsInN5bWJvbCQyMjEiLCJzeW1ib2wkMjIyIiwic3ltYm9sJDIyMyIsInN5bWJvbCQyMjQiLCJzeW1ib2wkMjI1IiwiZGVzY2VuZGluZyQyOSIsIm1pbiQzNSIsIm1heCQzNSIsImVxdWFsX2ludDMyJDEiLCJiZXR3ZWVuJDE1IiwiY2xhbXBfdW5jaGVja2VkJDciLCJjbGFtcF9leG4kMTUiLCJjbGFtcCQxNSIsImludmFyaWFudCQyMiIsInN5bWJvbCQyMjYiLCJzeW1ib2wkMjI3Iiwic3ltYm9sJDIyOCIsInN5bWJvbCQyMjkiLCJpbmNyJDQiLCJkZWNyJDQiLCJvZl9pbnQzMiQwIiwidG9faW50MzIkMCIsInBvdyQzIiwic3ltYm9sJDIzMCIsImJzd2FwMTYkMSIsIm5vbl9wb3NpdGl2ZV9hcmd1bWVudCQyIiwiY2VpbF9wb3cyJDMiLCJmbG9vcl9wb3cyJDMiLCJpc19wb3cyJDMiLCJmbG9vcl9sb2cyJDMiLCJjZWlsX2xvZzIkMyIsInNleHBfb2ZfaW50MzIiLCJoYXNoJDIzIiwidG9fc3RyaW5nJDI1Iiwib2Zfc3RyaW5nJDIzIiwicmVwciQwIiwidG9faW50JDYiLCJ0b19pbnRfdHJ1bmMkMCIsInRvX25hdGl2ZWludF90cnVuYyQwIiwidG9fbmF0aXZlaW50JDIiLCJyZXByJDEiLCJic3dhcDMyJDEiLCJic3dhcDQ4JDEiLCJpbXBsIiwic3ltYm9sJDIzNCIsInN5bWJvbCQyMzUiLCJwb3NfZGlmZiIsIm5lZ2F0aXZlX29uZSIsImRpdl93b3VsZF9vdmVyZmxvdyIsInN5bWJvbCQyMzYiLCJwcm9kdWN0Iiwic3ltYm9sJDIzNyIsImFicyQ3IiwibmVnJDYiLCJyYW5kb21fb2ZfaW50IiwicmFuZG9tX29mX2ludDY0IiwicmFuZG9tX29mX2ludCQwIiwicmFuZG9tX2luY2xfb2ZfaW50IiwicmFuZG9tX2luY2xfb2ZfaW50NjQiLCJyYW5kb21faW5jbCIsImZsb29yX2xvZzIkNCIsIm1heCQzNiIsImVtcHR5JDEwIiwiaXNfZW1wdHkkMTQiLCJoZWlnaHQkMSIsImludmFyaWFudCQyMyIsImludiIsImxlZnRfa2V5IiwicmlnaHRfa2V5IiwidXBkYXRlX2hlaWdodCIsIm9sZF9oZWlnaHQiLCJuZXdfaGVpZ2h0IiwiYmFsYW5jZSIsImxlZnRfbm9kZV9sZWZ0IiwibGVmdF9ub2RlX3JpZ2h0IiwibHJfbGVmdCIsImxyX3JpZ2h0IiwicmlnaHRfbm9kZV9sZWZ0IiwicmlnaHRfbm9kZV9yaWdodCIsInJsX2xlZnQiLCJybF9yaWdodCIsInNldF9sZWZ0IiwidHJlZSQwIiwic2V0X3JpZ2h0IiwiYWRkJDYiLCJhZGRlZCIsImFkZCQ3IiwibGFzdCQyIiwiZmluZGlfYW5kX2NhbGxfaW1wbCIsImFyZzEiLCJhcmcyIiwiY2FsbF9pZl9mb3VuZCIsImNhbGxfaWZfbm90X2ZvdW5kIiwiZmluZF9hbmRfY2FsbCIsImNhbGxfaWZfZm91bmQkMCIsImNhbGxfaWZfbm90X2ZvdW5kJDAiLCJmaW5kaV9hbmRfY2FsbCIsImNhbGxfaWZfZm91bmQkMSIsImNhbGxfaWZfbm90X2ZvdW5kJDEiLCJmaW5kX2FuZF9jYWxsMSIsImNhbGxfaWZfZm91bmQkMiIsImNhbGxfaWZfbm90X2ZvdW5kJDIiLCJmaW5kaV9hbmRfY2FsbDEiLCJjYWxsX2lmX2ZvdW5kJDMiLCJjYWxsX2lmX25vdF9mb3VuZCQzIiwiZmluZF9hbmRfY2FsbDIiLCJjYWxsX2lmX2ZvdW5kJDQiLCJjYWxsX2lmX25vdF9mb3VuZCQ0IiwiZmluZGlfYW5kX2NhbGwyIiwiaWZfbm90X2ZvdW5kJDAiLCJmaW5kJDE1IiwiaWZfZm91bmQkMCIsImlmX25vdF9mb3VuZCQxIiwibWVtJDEzIiwicmVtb3ZlX21pbl9lbHQkMSIsInJlbW92ZSQ2IiwicmVtb3ZlZCIsInJlbW92ZSQ3IiwiZm9sZCQxNyIsImtleSQxIiwicmtleSIsInJkYXRhIiwicmtleSQwIiwicmRhdGEkMCIsInJrZXkkMSIsInJkYXRhJDEiLCJsa2V5IiwibGRhdGEiLCJpdGVyJDIyIiwibWFwaV9pbnBsYWNlIiwiY2hvb3NlX2V4biQyIiwiY29tcGFyZV9rZXkkMCIsImVuc3VyZV9tdXRhdGlvbl9hbGxvd2VkIiwid2l0aG91dF9tdXRhdGluZyIsIm1heF90YWJsZV9sZW5ndGgiLCJjcmVhdGUkMTYiLCJncm93dGhfYWxsb3dlZCIsInNpemUkMCIsInNpemUkMSIsInNsb3QiLCJhZGRfd29ya2VyIiwibmV3X3Jvb3QiLCJtYXliZV9yZXNpemVfdGFibGUiLCJzaG91bGRfZ3JvdyIsIm5ld19hcnJheV9sZW5ndGgiLCJuZXdfdGFibGUiLCJvbGRfdGFibGUiLCJzZXQkOSIsImFkZCQ4IiwiYWRkX2V4biQzIiwic2V4cF9vZl9rZXkkMCIsImNsZWFyJDMiLCJmaW5kX2FuZF9jYWxsJDAiLCJmaW5kX2FuZF9jYWxsMSQwIiwiZmluZF9hbmRfY2FsbDIkMCIsImZpbmRpX2FuZF9jYWxsJDAiLCJmaW5kaV9hbmRfY2FsbDEkMCIsImZpbmRpX2FuZF9jYWxsMiQwIiwiaWZfZm91bmQkMSIsImlmX25vdF9mb3VuZCQyIiwiZmluZCQxNiIsIm1lbSQxNCIsInJlbW92ZSQ4IiwiYWRkZWRfb3JfcmVtb3ZlZCIsImxlbmd0aCQyMiIsImlzX2VtcHR5JDE1IiwiZm9sZCQxOCIsImJ1Y2tldCIsIml0ZXJpJDEzIiwiaXRlciQyMyIsIml0ZXJfa2V5cyQyIiwiY2hvb3NlX25vbmVtcHR5IiwidGFibGUiLCJhdmx0cmVlIiwiY2hvb3NlX2V4biQzIiwiY2hvb3NlJDIiLCJpbnZhcmlhbnQkMjQiLCJpbnZhcmlhbnRfa2V5IiwiaW52YXJpYW50X2RhdGEiLCJyZWFsX2xlbiIsImlmX2ZvdW5kJDIiLCJpZl9ub3RfZm91bmQkMyIsImZpbmRfZXhuJDkiLCJleGlzdHNpJDEwIiwiZXhpc3RzJDE1IiwiZm9yX2FsbGkkMTAiLCJmb3JfYWxsJDE1IiwiY291bnRpJDEwIiwiY291bnQkMTQiLCJtYXBpJDExIiwibmV3X3QiLCJtYXAkMzciLCJjb3B5JDciLCJmaWx0ZXJfbWFwaSQ3IiwiZmlsdGVyX21hcCQxMiIsImZpbHRlcmkkOCIsImZpbHRlciQxMiIsImZpbHRlcl9rZXlzJDIiLCJwYXJ0aXRpb25fbWFwaSQyIiwidDAiLCJuZXdfZGF0YSQwIiwicGFydGl0aW9uX21hcCQzIiwicGFydGl0aW9uaV90ZiQzIiwicGFydGl0aW9uX3RmJDciLCJmaW5kX29yX2FkZCIsImlkIiwiZGVmYXVsdCQxIiwiZmluZGlfb3JfYWRkIiwiZmluZF9hbmRfcmVtb3ZlIiwiY2hhbmdlJDIiLCJ1cGRhdGVfYW5kX3JldHVybiIsInVwZGF0ZSQyIiwiaW5jcl9ieSIsInJlbW92ZV9pZl96ZXJvIiwiYnkiLCJpbmNyJDUiLCJkZWNyJDUiLCJhZGRfbXVsdGkkMiIsInJlbW92ZV9tdWx0aSQyIiwiZmluZF9tdWx0aSQyIiwiY3JlYXRlX21hcHBlZCIsImR1cGVzIiwib2ZfYWxpc3QkNCIsIm9mX2FsaXN0X3JlcG9ydF9hbGxfZHVwcyIsIm9mX2FsaXN0X29yX2Vycm9yJDQiLCJvZl9hbGlzdF9leG4kNCIsIm9mX2FsaXN0X211bHRpJDQiLCJ0b19hbGlzdCQyIiwic2V4cF9vZl90JDYyIiwic2V4cF9vZl9kYXRhIiwidF9vZl9zZXhwJDM0IiwiZF9vZl9zZXhwIiwidF9zZXhwX2dyYW1tYXIkMzIiLCJrX2dyYW1tYXIiLCJ0b19saXN0JDEzIiwiZGF0YSQyIiwiZ3JvdXAkMiIsInJvdyIsIm9sZCIsImNyZWF0ZV93aXRoX2tleSIsImNyZWF0ZV93aXRoX2tleV9vcl9lcnJvciIsImNyZWF0ZV93aXRoX2tleV9leG4iLCJtYXliZV9zZXQiLCJtZXJnZSQ2IiwidF9sZWZ0IiwidF9yaWdodCIsIm1lcmdlX2ludG8iLCJkc3RfZGF0YSIsImFjdGlvbiIsImRzdF9kYXRhJDAiLCJmaWx0ZXJpX2lucGxhY2UkMSIsInRvX3JlbW92ZSIsImZpbHRlcl9pbnBsYWNlJDEiLCJmaWx0ZXJfa2V5c19pbnBsYWNlIiwiZmlsdGVyX21hcGlfaW5wbGFjZSIsIm1hcF9yZXN1bHRzIiwiZmlsdGVyX21hcF9pbnBsYWNlIiwibWFwaV9pbnBsYWNlJDAiLCJtYXBfaW5wbGFjZSQwIiwic2ltaWxhciIsIm9mX2FsaXN0X3JlcG9ydF9hbGxfZHVwcyQwIiwiY3JlYXRlX21hcHBlZCQwIiwiY3JlYXRlX3dpdGhfa2V5JDAiLCJjcmVhdGVfd2l0aF9rZXlfb3JfZXJyb3IkMCIsImNyZWF0ZV93aXRoX2tleV9leG4kMCIsInRfb2Zfc2V4cCQzNSIsImNyZWF0ZSQxNyIsIm9mX2FsaXN0JDUiLCJvZl9hbGlzdF9vcl9lcnJvciQ1Iiwib2ZfYWxpc3RfZXhuJDUiLCJvZl9hbGlzdF9tdWx0aSQ1IiwiZ3JvdXAkMyIsImhhc2hhYmxlJDExIiwiY3JlYXRlJDE4Iiwib2ZfYWxpc3QkNiIsIm9mX2FsaXN0X3JlcG9ydF9hbGxfZHVwcyQxIiwib2ZfYWxpc3Rfb3JfZXJyb3IkNiIsIm9mX2FsaXN0X2V4biQ2Iiwib2ZfYWxpc3RfbXVsdGkkNiIsImNyZWF0ZV9tYXBwZWQkMSIsImNyZWF0ZV93aXRoX2tleSQxIiwiY3JlYXRlX3dpdGhfa2V5X29yX2Vycm9yJDEiLCJjcmVhdGVfd2l0aF9rZXlfZXhuJDEiLCJncm91cCQ0IiwiaGFzaGFibGVfcyIsInNleHBfb2ZfbV90JDEiLCJtX3Rfb2Zfc2V4cCQxIiwibV90X3NleHBfZ3JhbW1hciQxIiwiZXF1YWxfbV90JDEiLCJoYXNoYWJsZSQxMiIsInBvbHlfaGFzaGFibGUiLCJpc19lbXB0eSQxNiIsImZpbmRfbWFwJDExIiwiZmluZCQxNyIsImFkZCQ5Iiwic3RyaWN0X2FkZCIsInN0cmljdF9hZGRfZXhuIiwic3RyaWN0X3JlbW92ZSIsInN0cmljdF9yZW1vdmVfZXhuIiwiZm9sZCQxOSIsIml0ZXIkMjQiLCJjb3VudCQxNSIsInN1bSQxMSIsIm1pbl9lbHQkMTUiLCJtYXhfZWx0JDE1IiwiZm9sZF9yZXN1bHQkMTAiLCJmb2xkX3VudGlsJDE0Iiwic2V4cF9vZl90JDYzIiwic2V4cF9vZl9lIiwidG9fYXJyYXkkMTIiLCJleGlzdHMkMTYiLCJmb3JfYWxsJDE2IiwiZXF1YWwkNDciLCJjb3B5JDgiLCJmaWx0ZXIkMTMiLCJ1bmlvbiQyIiwiZGlmZiQyIiwiaW50ZXIkMiIsImxhcmdlciIsInNtYWxsZXIiLCJmaWx0ZXJfaW5wbGFjZSQyIiwib2ZfaGFzaHRibF9rZXlzIiwiaGFzaHRibCIsInRvX2hhc2h0YmwiLCJjcmVhdGUkMTkiLCJvZl9saXN0JDExIiwidF9vZl9zZXhwJDM2IiwiZV9vZl9zZXhwIiwidF9vZl9zZXhwJDM3IiwiY3JlYXRlJDIwIiwib2ZfbGlzdCQxMiIsInRfc2V4cF9ncmFtbWFyJDMzIiwic2V4cF9vZl9tX3QkMiIsIm1fdF9vZl9zZXhwJDIiLCJtX3Rfc2V4cF9ncmFtbWFyJDIiLCJlcXVhbF9tX3QkMiIsImhhc2hhYmxlJDEzIiwiaGFzaCQyNCIsImhhc2hhYmxlJDE0IiwiY29tcGFyZSQ2MiIsImludmFyaWFudCQyNSIsInRvX2Zsb2F0JDUiLCJvZl9mbG9hdCQ0Iiwib2Zfc3RyaW5nJDI0IiwidG9fc3RyaW5nJDI2IiwibWluX3Bvc2l0aXZlX3N1Ym5vcm1hbF92YWx1ZSIsIm1pbl9wb3NpdGl2ZV9ub3JtYWxfdmFsdWUiLCJ6ZXJvJDYiLCJvbmUkNSIsIm1pbnVzX29uZSQ0IiwicGkiLCJzcXJ0X3BpIiwic3FydF8ycGkiLCJldWxlciIsIm9mX2ludDYzIiwib2ZfaW50NjQkMCIsInRvX2ludDY0JDEiLCJpcm91bmRfbGJvdW5kIiwiaXJvdW5kX3Vib3VuZCIsImlyb3VuZF91cCIsImlyb3VuZF91cF9leG4iLCJpcm91bmRfZG93biIsImlyb3VuZF9kb3duX2V4biIsImlyb3VuZF90b3dhcmRzX3plcm8iLCJpcm91bmRfdG93YXJkc196ZXJvX2V4biIsIm9uZV91bHBfbGVzc190aGFuX2hhbGYiLCJyb3VuZF9uZWFyZXN0X2xiIiwicm91bmRfbmVhcmVzdF91YiIsImFkZF9oYWxmX2Zvcl9yb3VuZF9uZWFyZXN0IiwiaXJvdW5kX25lYXJlc3RfMzIiLCJpcm91bmRfbmVhcmVzdF82NCIsImlyb3VuZF9uZWFyZXN0XzY0JDAiLCJpcm91bmRfbmVhcmVzdF9leG5fMzIiLCJpcm91bmRfbmVhcmVzdF9leG5fNjQiLCJpcm91bmRfbmVhcmVzdF9leG4iLCJpcm91bmRfZXhuIiwiaXJvdW5kIiwiaXNfaW5mIiwiaXNfZmluaXRlIiwibWluX2luYW4iLCJtYXhfaW5hbiIsInNxdWFyZSIsImZyYWN0aW9uYWwiLCJpbnRlZ3JhbCIsInJvdW5kX3Rvd2FyZHNfemVybyQ0Iiwicm91bmRfbmVhcmVzdF9pbmxpbmUiLCJyb3VuZF9uZWFyZXN0JDQiLCJyb3VuZF9uZWFyZXN0X2hhbGZfdG9fZXZlbiIsImNlaWxfb3Jfc3VjYyIsImRpZmZfZmxvb3IiLCJkaWZmX2NlaWwiLCJpbnQ2M19yb3VuZF9sYm91bmQiLCJpbnQ2M19yb3VuZF91Ym91bmQiLCJpbnQ2M19yb3VuZF91cF9leG4iLCJpbnQ2M19yb3VuZF9kb3duX2V4biIsImludDYzX3JvdW5kX25lYXJlc3RfcG9ydGFibGVfYSIsImludDYzX3JvdW5kX25lYXJlc3RfYXJjaDY0X25vYSIsImludDYzX3JvdW5kX25lYXJlc3RfZXhuIiwicm91bmQkNCIsImNvbXBhcmUkNjMiLCJ0X29mX3NleHAkMzgiLCJzZXhwX29mX3QkNjQiLCJ0b19zdHJpbmckMjciLCJvZl9zdHJpbmckMjUiLCJjbGFzc2lmeSIsImluc2VydF91bmRlcnNjb3JlcyQwIiwic3RyaXBfemVybyIsInRvX3N0cmluZ19odW0kNiIsImRlY2ltYWxzIiwiZXhwbGljaXRfcGx1cyIsInNleHBfb2ZfZmxvYXQiLCJ0b19wYWRkZWRfY29tcGFjdF9zdHJpbmdfY3VzdG8iLCJraWxvIiwibWVnYSIsImdpZ2EiLCJ0ZXJhIiwicGV0YSIsIm1hZyIsImRlbm9taW5hdG9yIiwiaGlnaGVyIiwiZGlmZl9yaWdodCIsImRpZmZfbGVmdCIsInBldGEkMCIsInRvX3BhZGRlZF9jb21wYWN0X3N0cmluZyIsImludF9wb3ckMCIsInJvdW5kX2dlbiIsInNkIiwiZGQiLCJkZCQwIiwic2QkMCIsImRkJDEiLCJzZCQxIiwiYWJzX2RkIiwicm91bmRfc2lnbmlmaWNhbnQiLCJzaWduaWZpY2FudF9kaWdpdHMiLCJyb3VuZF9kZWNpbWFsIiwiZGVjaW1hbF9kaWdpdHMiLCJiZXR3ZWVuJDE2IiwiY2xhbXBfZXhuJDE2IiwiY2xhbXAkMTYiLCJzaWduX2V4biIsInNpZ25fb3JfbmFuIiwiaWVlZV9uZWdhdGl2ZSIsImV4cG9uZW50X21hc2s2NCIsImV4cG9uZW50X21hc2siLCJtYW50aXNzYV9tYXNrIiwibWFudGlzc2FfbWFzazY0IiwiaWVlZV9leHBvbmVudCIsImllZWVfbWFudGlzc2EiLCJjcmVhdGVfaWVlZV9leG4iLCJuZWdhdGl2ZSIsIm1hbnRpc3NhIiwic2lnbl9iaXRzIiwiZXhwdF9iaXRzIiwibWFudF9iaXRzIiwiY3JlYXRlX2llZWUiLCJ0b19zdHJpbmckMjgiLCJzZXhwX29mX3QkNjUiLCJvZl9zdHJpbmckMjYiLCJpc19wb3NpdGl2ZSQ0IiwiaXNfbm9uX25lZ2F0aXZlJDQiLCJpc19uZWdhdGl2ZSQ0IiwiaXNfbm9uX3Bvc2l0aXZlJDQiLCJzeW1ib2wkMjM4Iiwic3ltYm9sJDIzOSIsInN5bWJvbCQyNDAiLCJzeW1ib2wkMjQxIiwic3ltYm9sJDI0MiIsInN5bWJvbCQyNDMiLCJvZl9mbG9hdCQ1IiwiY29tcGFyZV9mbG9hdCQxIiwiZXF1YWxfZmxvYXQkMSIsIm1pbiQzNiIsIm1heCQzNyIsImFkZF9zdWJzdHJpbmciLCJhZGRfc3ViYnl0ZXMiLCJzZXhwX29mX3QkNjYiLCJjcmVhdGUkMjIiLCJsZW5ndGgkMjQiLCJ1bnNhZmVfYmxpdCQ5IiwiZWxpZGUiLCJnZXQkNiIsImF0X21vc3RfbnVtX2ZyYW1lcyIsInRvX3N0cmluZyQyOSIsInRvX3N0cmluZ19saXN0Iiwic2V4cF9vZl90JDY3Iiwic2V0X3JlY29yZGluZyIsImFtX3JlY29yZGluZyIsIm1vc3RfcmVjZW50IiwibW9zdF9yZWNlbnRfZm9yX2V4biIsIndpdGhfcmVjb3JkaW5nIiwic2F2ZWQiLCJpbml0aWFsaXplX21vZHVsZSQwIiwib2NhbWxydW5wYXJhbV9tZW50aW9uc19iYWNrdHJhIiwibWF4X2ludCQxIiwibWluX2ludCQxIiwiaW5maW5pdHkkMiIsIm5lZ19pbmZpbml0eSQyIiwibmFuJDIiLCJtYXhfZmxvYXQkMSIsIm1pbl9mbG9hdCQxIiwiZXBzaWxvbl9mbG9hdCQyIiwiY2hhcl9vZl9pbnQkMSIsInN0cmluZ19vZl9ib29sJDEiLCJib29sX29mX3N0cmluZ19vcHQkMSIsImJvb2xfb2Zfc3RyaW5nJDEiLCJzdHJpbmdfb2ZfaW50JDEiLCJpbnRfb2Zfc3RyaW5nX29wdCQxIiwic3RyaW5nX29mX2Zsb2F0JDEiLCJmbG9hdF9vZl9zdHJpbmdfb3B0JDEiLCJzdGRpbiQxIiwic3Rkb3V0JDEiLCJzdGRlcnIkMSIsInByaW50X2NoYXIkMSIsInByaW50X3N0cmluZyQxIiwicHJpbnRfYnl0ZXMkMSIsInByaW50X2ludCQxIiwicHJpbnRfZmxvYXQkMSIsInByaW50X2VuZGxpbmUkMSIsInByaW50X25ld2xpbmUkMSIsInByZXJyX2NoYXIkMSIsInByZXJyX3N0cmluZyQxIiwicHJlcnJfYnl0ZXMkMSIsInByZXJyX2ludCQxIiwicHJlcnJfZmxvYXQkMSIsInByZXJyX2VuZGxpbmUkMSIsInByZXJyX25ld2xpbmUkMSIsInJlYWRfbGluZSQxIiwicmVhZF9pbnRfb3B0JDEiLCJyZWFkX2ludCQxIiwicmVhZF9mbG9hdF9vcHQkMSIsInJlYWRfZmxvYXQkMSIsIm9wZW5fb3V0JDEiLCJvcGVuX291dF9iaW4kMSIsIm9wZW5fb3V0X2dlbiQxIiwiZmx1c2gkMSIsImZsdXNoX2FsbCQxIiwib3V0cHV0X2NoYXIkMSIsIm91dHB1dF9zdHJpbmckMSIsIm91dHB1dF9ieXRlcyQxIiwib3V0cHV0JDEiLCJvdXRwdXRfc3Vic3RyaW5nJDEiLCJvdXRwdXRfYnl0ZSQxIiwib3V0cHV0X2JpbmFyeV9pbnQkMSIsIm91dHB1dF92YWx1ZSQxIiwic2Vla19vdXQkMSIsInBvc19vdXQkMSIsIm91dF9jaGFubmVsX2xlbmd0aCQxIiwiY2xvc2Vfb3V0JDEiLCJjbG9zZV9vdXRfbm9lcnIkMSIsInNldF9iaW5hcnlfbW9kZV9vdXQkMSIsIm9wZW5faW4kMSIsIm9wZW5faW5fYmluJDEiLCJvcGVuX2luX2dlbiQxIiwiaW5wdXRfY2hhciQxIiwiaW5wdXRfbGluZSQxIiwiaW5wdXQkMSIsInJlYWxseV9pbnB1dCQxIiwicmVhbGx5X2lucHV0X3N0cmluZyQxIiwiaW5wdXRfYnl0ZSQxIiwiaW5wdXRfYmluYXJ5X2ludCQxIiwiaW5wdXRfdmFsdWUkMSIsInNlZWtfaW4kMSIsInBvc19pbiQxIiwiaW5fY2hhbm5lbF9sZW5ndGgkMSIsImNsb3NlX2luJDEiLCJjbG9zZV9pbl9ub2VyciQxIiwic2V0X2JpbmFyeV9tb2RlX2luJDEiLCJzdHJpbmdfb2ZfZm9ybWF0JDEiLCJzeW1ib2wkMjUwIiwiZXhpdCQxIiwiYXRfZXhpdCQxIiwidmFsaWRfZmxvYXRfbGV4ZW0kMSIsInVuc2FmZV9yZWFsbHlfaW5wdXQkMSIsImRvX2F0X2V4aXQkMSIsImFycmF5X3NleHBfZ3JhbW1hciQwIiwiaGFzaF9ib29sJDAiLCJoYXNoX2ludCQwIiwiaGFzaF9pbnQzMiQwIiwiaGFzaF9pbnQ2NCQwIiwibGlzdF9zZXhwX2dyYW1tYXIkMCIsImhhc2hfbmF0aXZlaW50JDAiLCJvcHRpb25fc2V4cF9ncmFtbWFyJDAiLCJyZWZfc2V4cF9ncmFtbWFyJDAiLCJoYXNoX3N0cmluZyQwIiwiaGFzaF91bml0JDAiXSwic291cmNlcyI6WyIvVXNlcnMvYXphdC8ub3BhbS80LjE0LjAvbGliL2Jhc2UvZXhuLm1sIiwiL1VzZXJzL2F6YXQvLm9wYW0vNC4xNC4wL2xpYi9iYXNlL2VpdGhlcjAubWwiLCIvVXNlcnMvYXphdC8ub3BhbS80LjE0LjAvbGliL2Jhc2UvcmVzdWx0Lm1sIiwiL1VzZXJzL2F6YXQvLm9wYW0vNC4xNC4wL2xpYi9iYXNlL29yZGVyaW5nLm1sIiwiL1VzZXJzL2F6YXQvLm9wYW0vNC4xNC4wL2xpYi9iYXNlL2xpc3QubWwiLCIvVXNlcnMvYXphdC8ub3BhbS80LjE0LjAvbGliL2Jhc2UvaW5mby5tbCIsIi9Vc2Vycy9hemF0Ly5vcGFtLzQuMTQuMC9saWIvYmFzZS9lcnJvci5tbCIsIi9Vc2Vycy9hemF0Ly5vcGFtLzQuMTQuMC9saWIvYmFzZS9zaWduMC5tbCIsIi9Vc2Vycy9hemF0Ly5vcGFtLzQuMTQuMC9saWIvYmFzZS91bml0Lm1sIiwiL1VzZXJzL2F6YXQvLm9wYW0vNC4xNC4wL2xpYi9iYXNlL2JpbmFyeV9zZWFyY2hhYmxlX2ludGYubWwiLCIvVXNlcnMvYXphdC8ub3BhbS80LjE0LjAvbGliL2Jhc2Uvc2VxdWVuY2UubWwiLCIvVXNlcnMvYXphdC8ub3BhbS80LjE0LjAvbGliL2Jhc2UvY2hhci5tbCIsIi9Vc2Vycy9hemF0Ly5vcGFtLzQuMTQuMC9saWIvYmFzZS9ieXRlcy5tbCIsIi9Vc2Vycy9hemF0Ly5vcGFtLzQuMTQuMC9saWIvYmFzZS9oZXhfbGV4ZXIubWwiLCIvVXNlcnMvYXphdC8ub3BhbS80LjE0LjAvbGliL2Jhc2UvcG93X292ZXJmbG93X2JvdW5kcy5tbCIsIi9Vc2Vycy9hemF0Ly5vcGFtLzQuMTQuMC9saWIvYmFzZS9wb3Bjb3VudC5tbCIsIi9Vc2Vycy9hemF0Ly5vcGFtLzQuMTQuMC9saWIvYmFzZS9pbnQubWwiLCIvVXNlcnMvYXphdC8ub3BhbS80LjE0LjAvbGliL2Jhc2UvdWNoYXIubWwiLCIvVXNlcnMvYXphdC8ub3BhbS80LjE0LjAvbGliL2Jhc2UvdHlwZV9lcXVhbC5tbCIsIi9Vc2Vycy9hemF0Ly5vcGFtLzQuMTQuMC9saWIvYmFzZS9zaWduX29yX25hbi5tbCIsIi9Vc2Vycy9hemF0Ly5vcGFtLzQuMTQuMC9saWIvYmFzZS9tYXliZV9ib3VuZC5tbCIsIi9Vc2Vycy9hemF0Ly5vcGFtLzQuMTQuMC9saWIvYmFzZS9tYXBfaW50Zi5tbCIsIi9Vc2Vycy9hemF0Ly5vcGFtLzQuMTQuMC9saWIvYmFzZS9ub3RoaW5nLm1sIiwiL1VzZXJzL2F6YXQvLm9wYW0vNC4xNC4wL2xpYi9iYXNlL25hdGl2ZWludC5tbCIsIi9Vc2Vycy9hemF0Ly5vcGFtLzQuMTQuMC9saWIvYmFzZS9tYXAubWwiLCIvVXNlcnMvYXphdC8ub3BhbS80LjE0LjAvbGliL2Jhc2UvaW50NjQubWwiLCIvVXNlcnMvYXphdC8ub3BhbS80LjE0LjAvbGliL2Jhc2UvaW50NjNfZW11bC5tbCIsIi9Vc2Vycy9hemF0Ly5vcGFtLzQuMTQuMC9saWIvYmFzZS9ib29sLm1sIiwiL1VzZXJzL2F6YXQvLm9wYW0vNC4xNC4wL2xpYi9iYXNlL2ludDMyLm1sIiwiL1VzZXJzL2F6YXQvLm9wYW0vNC4xNC4wL2xpYi9iYXNlL2Zsb2F0Lm1sIiwiL1VzZXJzL2F6YXQvLm9wYW0vNC4xNC4wL2xpYi9iYXNlL2JhY2t0cmFjZS5tbCIsIi9Vc2Vycy9hemF0Ly5vcGFtLzQuMTQuMC9saWIvYmFzZS9wb2x5MC5tbCIsIi9Vc2Vycy9hemF0Ly5vcGFtLzQuMTQuMC9saWIvYmFzZS9pbXBvcnQwLm1sIiwiL1VzZXJzL2F6YXQvLm9wYW0vNC4xNC4wL2xpYi9iYXNlL3N0cmluZzAubWwiLCIvVXNlcnMvYXphdC8ub3BhbS80LjE0LjAvbGliL2Jhc2UvYmFzZS5tbCIsIi9Vc2Vycy9hemF0Ly5vcGFtLzQuMTQuMC9saWIvYmFzZS9oYXNodGJsLm1sIiwiL1VzZXJzL2F6YXQvLm9wYW0vNC4xNC4wL2xpYi9iYXNlL3ByaW50Zi5tbCIsIi9Vc2Vycy9hemF0Ly5vcGFtLzQuMTQuMC9saWIvYmFzZS9zeXMwLm1sIiwiL1VzZXJzL2F6YXQvLm9wYW0vNC4xNC4wL2xpYi9iYXNlL2FycmF5MC5tbCIsIi9Vc2Vycy9hemF0Ly5vcGFtLzQuMTQuMC9saWIvYmFzZS9jaGFyMC5tbCIsIi9Vc2Vycy9hemF0Ly5vcGFtLzQuMTQuMC9saWIvYmFzZS9pbnQwLm1sIiwiL1VzZXJzL2F6YXQvLm9wYW0vNC4xNC4wL2xpYi9iYXNlL2xpc3QwLm1sIiwiL1VzZXJzL2F6YXQvLm9wYW0vNC4xNC4wL2xpYi9iYXNlL2hhc2gubWwiLCIvVXNlcnMvYXphdC8ub3BhbS80LjE0LjAvbGliL2Jhc2UvcHB4X2NvbXBhcmVfbGliLm1sIiwiL1VzZXJzL2F6YXQvLm9wYW0vNC4xNC4wL2xpYi9iYXNlL3NleHAubWwiLCIvVXNlcnMvYXphdC8ub3BhbS80LjE0LjAvbGliL2Jhc2Uvc3RyaW5nLm1sIiwiL1VzZXJzL2F6YXQvLm9wYW0vNC4xNC4wL2xpYi9iYXNlL2xhenkubWwiLCIvVXNlcnMvYXphdC8ub3BhbS80LjE0LjAvbGliL2Jhc2Uvd29yZF9zaXplLm1sIiwiL1VzZXJzL2F6YXQvLm9wYW0vNC4xNC4wL2xpYi9iYXNlL3ByZXR0eV9wcmludGVyLm1sIiwiL1VzZXJzL2F6YXQvLm9wYW0vNC4xNC4wL2xpYi9iYXNlL3dpdGhfcmV0dXJuLm1sIiwiL1VzZXJzL2F6YXQvLm9wYW0vNC4xNC4wL2xpYi9iYXNlL2hhc2hfc2V0Lm1sIiwiL1VzZXJzL2F6YXQvLm9wYW0vNC4xNC4wL2xpYi9iYXNlL21vbmFkX2ludGYubWwiLCIvVXNlcnMvYXphdC8ub3BhbS80LjE0LjAvbGliL2Jhc2UvbW9uYWQubWwiLCIvVXNlcnMvYXphdC8ub3BhbS80LjE0LjAvbGliL2Jhc2UvYXBwbGljYXRpdmUubWwiLCIvVXNlcnMvYXphdC8ub3BhbS80LjE0LjAvbGliL2Jhc2UvYnl0ZXMwLm1sIiwiL1VzZXJzL2F6YXQvLm9wYW0vNC4xNC4wL2xpYi9iYXNlL2NvbXBhcmF0b3IubWwiLCIvVXNlcnMvYXphdC8ub3BhbS80LjE0LjAvbGliL2Jhc2UvZmllbGQubWwiLCIvVXNlcnMvYXphdC8ub3BhbS80LjE0LjAvbGliL2Jhc2Uvc291cmNlX2NvZGVfcG9zaXRpb24wLm1sIiwiL1VzZXJzL2F6YXQvLm9wYW0vNC4xNC4wL2xpYi9iYXNlL2xpc3QxLm1sIiwiL1VzZXJzL2F6YXQvLm9wYW0vNC4xNC4wL2xpYi9iYXNlL29yX2Vycm9yLm1sIiwiL1VzZXJzL2F6YXQvLm9wYW0vNC4xNC4wL2xpYi9iYXNlL2NvbnRhaW5lci5tbCIsIi9Vc2Vycy9hemF0Ly5vcGFtLzQuMTQuMC9saWIvYmFzZS9jb250YWluZXJfaW50Zi5tbCIsIi9Vc2Vycy9hemF0Ly5vcGFtLzQuMTQuMC9saWIvYmFzZS9vcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uMC5tbCIsIi9Vc2Vycy9hemF0Ly5vcGFtLzQuMTQuMC9saWIvYmFzZS9yYW5kb21fcmVwci5tbCIsIi9Vc2Vycy9hemF0Ly5vcGFtLzQuMTQuMC9saWIvYmFzZS9yYW5kb20ubWwiLCIvVXNlcnMvYXphdC8ub3BhbS80LjE0LjAvbGliL2Jhc2UvYXJyYXkubWwiLCIvVXNlcnMvYXphdC8ub3BhbS80LjE0LjAvbGliL2Jhc2UvYXJyYXlfcGVybXV0ZS5tbCIsIi9Vc2Vycy9hemF0Ly5vcGFtLzQuMTQuMC9saWIvYmFzZS9mbi5tbCIsIi9Vc2Vycy9hemF0Ly5vcGFtLzQuMTQuMC9saWIvYmFzZS9pbnQ2My5tbCIsIi9Vc2Vycy9hemF0Ly5vcGFtLzQuMTQuMC9saWIvYmFzZS9pbnZhcmlhbnQubWwiLCIvVXNlcnMvYXphdC8ub3BhbS80LjE0LjAvbGliL2Jhc2UvY29tcGFyYWJsZS5tbCIsIi9Vc2Vycy9hemF0Ly5vcGFtLzQuMTQuMC9saWIvYmFzZS9oYXNoYWJsZV9pbnRmLm1sIiwiL1VzZXJzL2F6YXQvLm9wYW0vNC4xNC4wL2xpYi9iYXNlL2lkZW50aWZpYWJsZS5tbCIsIi9Vc2Vycy9hemF0Ly5vcGFtLzQuMTQuMC9saWIvYmFzZS9vcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uLm1sIiwiL1VzZXJzL2F6YXQvLm9wYW0vNC4xNC4wL2xpYi9iYXNlL2JpbmFyeV9zZWFyY2gubWwiLCIvVXNlcnMvYXphdC8ub3BhbS80LjE0LjAvbGliL2Jhc2UvYmluYXJ5X3NlYXJjaGFibGUubWwiLCIvVXNlcnMvYXphdC8ub3BhbS80LjE0LjAvbGliL2Jhc2UvYmxpdC5tbCIsIi9Vc2Vycy9hemF0Ly5vcGFtLzQuMTQuMC9saWIvYmFzZS9vcHRpb24ubWwiLCIvVXNlcnMvYXphdC8ub3BhbS80LjE0LjAvbGliL2Jhc2Uvc2V4cGFibGUubWwiLCIvVXNlcnMvYXphdC8ub3BhbS80LjE0LjAvbGliL2Jhc2UvZWl0aGVyLm1sIiwiL1VzZXJzL2F6YXQvLm9wYW0vNC4xNC4wL2xpYi9iYXNlL2luZGV4ZWRfY29udGFpbmVyLm1sIiwiL1VzZXJzL2F6YXQvLm9wYW0vNC4xNC4wL2xpYi9iYXNlL29ial9hcnJheS5tbCIsIi9Vc2Vycy9hemF0Ly5vcGFtLzQuMTQuMC9saWIvYmFzZS91bmlmb3JtX2FycmF5Lm1sIiwiL1VzZXJzL2F6YXQvLm9wYW0vNC4xNC4wL2xpYi9iYXNlL29wdGlvbl9hcnJheS5tbCIsIi9Vc2Vycy9hemF0Ly5vcGFtLzQuMTQuMC9saWIvYmFzZS9mbG9hdDAubWwiLCIvVXNlcnMvYXphdC8ub3BhbS80LjE0LjAvbGliL2Jhc2UvYnl0ZXNfdHIubWwiLCIvVXNlcnMvYXphdC8ub3BhbS80LjE0LjAvbGliL2Jhc2Uvc3RhZ2VkLm1sIiwiL1VzZXJzL2F6YXQvLm9wYW0vNC4xNC4wL2xpYi9iYXNlL2ludF9jb252ZXJzaW9ucy5tbCIsIi9Vc2Vycy9hemF0Ly5vcGFtLzQuMTQuMC9saWIvYmFzZS9pbnRfbWF0aC5tbCIsIi9Vc2Vycy9hemF0Ly5vcGFtLzQuMTQuMC9saWIvYmFzZS9zaWduLm1sIiwiL1VzZXJzL2F6YXQvLm9wYW0vNC4xNC4wL2xpYi9iYXNlL3N0YWNrLm1sIiwiL1VzZXJzL2F6YXQvLm9wYW0vNC4xNC4wL2xpYi9iYXNlL3NvdXJjZV9jb2RlX3Bvc2l0aW9uLm1sIiwiL1VzZXJzL2F6YXQvLm9wYW0vNC4xNC4wL2xpYi9iYXNlL3NldF9pbnRmLm1sIiwiL1VzZXJzL2F6YXQvLm9wYW0vNC4xNC4wL2xpYi9iYXNlL3NldC5tbCIsIi9Vc2Vycy9hemF0Ly5vcGFtLzQuMTQuMC9saWIvYmFzZS9yZWYubWwiLCIvVXNlcnMvYXphdC8ub3BhbS80LjE0LjAvbGliL2Jhc2UvcXVldWUubWwiLCIvVXNlcnMvYXphdC8ub3BhbS80LjE0LjAvbGliL2Jhc2UvbGlua2VkX3F1ZXVlMC5tbCIsIi9Vc2Vycy9hemF0Ly5vcGFtLzQuMTQuMC9saWIvYmFzZS9saW5rZWRfcXVldWUubWwiLCIvVXNlcnMvYXphdC8ub3BhbS80LjE0LjAvbGliL2Jhc2UvYXZsdHJlZS5tbCIsIi9Vc2Vycy9hemF0Ly5vcGFtLzQuMTQuMC9saWIvYmFzZS9idWZmZXIubWwiXSwibWFwcGluZ3MiOiI7Ozs7O0k7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBK0dRQTs7Ozs7Ozs7Ozs7Ozs7O0tDL0RBQzs7Ozs7Ozs7Ozs7Ozs7O0tDakNBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQ2FKQztLQUdHQztLQTJCRkM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0MyNkJHQzs7Ozs7Ozs7Ozs7OztLQzkwQkhDOztLQWlGR0M7S0NqT0pDO0tBU0lDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0NMREM7S0EyQkZDOzs7Ozs7Ozs7S0FpQ0RDO0tBZ0NBQzs7Ozs7Ozs7Ozs7OztLQ2xHRUM7S0F3QkFDO0tDS0FDOzs7Ozs7S0FxQkFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tDcWNJQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0N0ZEZDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tDdEJGQztLQ1RGQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0NvTkFDOztLQXNFQUM7O0tDbFJFQztLQUVBQztLQUVBQztLQUVBQztLQWVBQzs7Ozs7Ozs7Ozs7S0NtREVDO0tBT0FDOzs7Ozs7S0N2RkZDOzs7Ozs7S0N3SEVDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0NwSENDO0tBZ0NGQzs7Ozs7Ozs7Ozs7S0FtQ0RDO0tBTUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0N2REFDO0tBb0ZDQzs7S0E2QkZDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7S0NoQ0dDOztLQW9QRkM7S0FxQkFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tDeFdDQztLQVVDQzs7Ozs7Ozs7Ozs7S0NvQ0FDO0tBT0FDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQ3d0RUFDOzs7Ozs7Ozs7S0FuaUNFQztLQTBCQUM7Ozs7Ozs7Ozs7O0tDcGlDRkM7S0FPQUM7Ozs7OztLQ3ZJRkM7S0FpUkVDO0tBT0FDOzs7Ozs7O0tDL1hGQztLQWtDRUM7Ozs7Ozs7Ozs7O0tDOE1BQztLQU9BQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQ3lSRkM7S0FHR0M7S0FvQ0ZDOzs7Ozs7Ozs7Ozs7O0tBMFlDQzs7O0tDbjhCSkM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3dCQ1VXQyxFQUFFQyxHQUFJLG9CQUFKQSxFQUFGRCxFQUFpQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7NEJDcUhHLFFBQWdCO2lDOzs7YUh1US9DRSxpQjs7YUFKQUMsZTs7YUFDQUMsZTs7YUFxZUFDLG9COzsrQkcxc0IyQiw0QkFB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O1VBR0osT0FISUEsT0FHTSx5Q0FIVkQ7VUFHVSx5QkFDTkcsTUFGQ0Q7UUFLTCxTQVBJRCxPQU9NLHlDQVBWRDtRQU9VLHNDQUNOSyxNQUZDRCxLQUc2Qjs7O2VBU25DN007UUFIVyxJQUFOeU0sSUYySUxsRDtRRTFJQzt3Q0FESWtELElBR0x6TSxHQUFXOzs4QkFPTyxRQUFFOzs7Ozs7Ozs7T0F2Q2xCb007Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLcENNRlc7S21CR0FDO0trQjZkRUM7S1h6QkZDO0t2QjNVRUM7S0s1SEZDO0thR0FDO0tESkFDO0tGU0VDO0tIUkZDO0tXbWFBQztLWTdhRkM7S1p3WkVDOzs7SzlCL1lBQztLOEJrTEFDOzs7Ozs7OztLMUJsTEFDO0ttQkdBQztLa0I2ZEVDO0tYekJGQztLdkIzVUVDOztLa0J6SEZDO0tESkFDO0tIQUFDO0tGQ0FDO0tXZ2FBQztLWTFhRkM7S1pxWkVDOzs7SzlCNVlBQztLOEIrS0FDOzs7O0tBZ1RDQztLUHpkQUM7S2tCNmRFQztLWHpCRkM7S3ZCM1VFQzs7S2tCekhGQztLREpBQztLRjRKQUM7S0gzSkFDOzs7Ozs7Ozs7S1d3T0RDOzs7O0tYbFBDQztLR3FXRUM7S0V0V0ZDO0tqQklBQzs7S2dCQUFDO0trQklBQztLaEJKQUM7S3JCSEFDO0swQnlZREM7SzlCczFCRkM7Ozs7S21CcHJDTUM7S0cvQkFDO0tFME5BQztLakIvTkZDO0tLOERFQztLVzlERkM7S2tCSUFDO0toQjQ5QkZDO0tyQm4rQkVDO0ttQkpGQztLaEJDQUM7O0tLOERFQztLWWlLQUM7S0YxTkFDO0tIK0JBQzs7O0tXOElGQzs7S0E4TUFDO0tBb0NBQzs7Ozs7Ozs7Ozs7OztLQUNBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPTGpDRmhSOztPQUpBQzs7T0FDQUM7O09BcWVBQzs7Ozs7Ozs7Ozs7Ozs7OztPSTkwQkFDO09qQm1ESUM7T2F1VEpDOzs7Ozs7Ozs7O09LaUtFQztPQy9DbURDO09EZ0RuREM7T0NoRDREQztPRHFENURDOzs7O09BaFlBQzs7Ozs7TzFCaktBaU07T21CR0FDO09rQjZkRUM7T1h6QkZDO092QjNVRUM7T0s1SEZDO09hR0FDO09ESkFDO09GU0VDO09IUkZDO09XbWFBQztPWTdhRkM7T1p3WkVDOzs7TzlCL1lBQztPOEJrTEFDOzs7Ozs7OztPMUJsTEFDO09tQkdBQztPa0I2ZEVDO09YekJGQztPdkIzVUVDOztPa0J6SEZDO09ESkFDO09IQUFDO09GQ0FDO09XZ2FBQztPWTFhRkM7T1pxWkVDOzs7TzlCNVlBQztPOEIrS0FDOzs7O09BZ1RDQztPUHpkQUM7T2tCNmRFQztPWHpCRkM7T3ZCM1VFQzs7T2tCekhGQztPREpBQztPRjRKQUM7T0gzSkFDOzs7Ozs7Ozs7T1d3T0RDOzs7O09YbFBDQztPR3FXRUM7T0V0V0ZDO09qQklBQzs7T2dCQUFDO09rQklBQztPaEJKQUM7T3JCSEFDO08wQnlZREM7TzlCczFCRkM7Ozs7T21CcHJDTUM7T0cvQkFDO09FME5BQztPakIvTkZDO09LOERFQztPVzlERkM7T2tCSUFDO09oQjQ5QkZDO09yQm4rQkVDO09tQkpGQztPaEJDQUM7O09LOERFQztPWWlLQUM7T0YxTkFDO09IK0JBQzs7O09XOElGQzs7T0E4TUFDO09Bb0NBQzs7Ozs7Ozs7Ozs7OztPQUNBQzs7O0lhcGFILFNBRENDLG9CQUNELG9CQUVrQztJQUZsQyxTQVFDQyxrQkFBVyxrQkFFRjtJQVZWOzthVmFDM1A7Ozs7VVVJSyxXYmloQkhoQjt1QmFuaUJGMFEsYUFTQUMsV0FLQUM7O0lBYkQ7O1FDUEN0RzthQUNBdUcsV0FBUyxPQURUdkcsSUFDVzthQUNYd0csU0FBU0MsR0FBSSxVQUFKQSxFQUZUekcsTUFFYSxRQUFZOzs7TUFnQmxCLFNBQVMsV2ZZaEJ6SztNZVpPO3VCOztVQU1QdkU7ZUFNSTBWLEdBQUdDLFVBQVV0TztRQUEwQyx5QkFBMUNBO1FBQTBDLG9DQUFwRHNPLGVBQW1FOytCQUF0RUQsR0FOSjFWOytCQXZCQXVWLFlBQ0FDOzs7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O085Qm81QkYvdEI7T0F4dENFckI7T0FDQWQ7TzhCdVZDb2xJO09BU0RuMUM7T0FDQUM7T1h6V0N4dUY7T1dnWEEyakk7T1h4V0Qza0k7O09BRUNjO09XdVhENEI7T0FJQTY3QjtPQUlBLzhCO09BVUFyQjtPQUlBZDtPQUlDdWxJO09BVURqaUk7T0FDQUM7T0FFQTNDO09BSUFkO09BSUMwbEk7T0FRRHB5RTtPQUNBQztPV2xiQ3J4RDtPWHliQXlqSTtPV3dDQ3BsSTtPQUNBZjtPQUNDNkI7T1g3Qkh5ekQ7T0FDQUM7T0FDQXYwRDtPQUNBZjtPQUNDNkI7T0FNRDI2QjtPQUNBRDtPQUVDSjtPQUtBZ3FHO09BS0Q5cEc7T0FDQUM7T0FDQzU2Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0Q3Y0h0TztPRTRkcURJO09BQVNFO09EK0M1REg7T0FDQUU7T2tDMWlCRm9pQztPbEMraUJFbGlDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQWdCRzs7Ozs7O09BamlCTDZzSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFpaUJLO1UiLCJzb3VyY2VzQ29udGVudCI6WyJvcGVuISBJbXBvcnRcblxudHlwZSB0ID0gZXhuIFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG5sZXQgc2V4cF9vZl90ID0gKHNleHBfb2ZfZXhuIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG5cbltAQEBlbmRdXG5cbmxldCBleGl0ID0gQ2FtbC5leGl0XG5cbmV4Y2VwdGlvbiBGaW5hbGx5IG9mIHQgKiB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwXVxuXG5sZXQgKCkgPVxuICBTZXhwbGliMC5TZXhwX2NvbnYuRXhuX2NvbnZlcnRlci5hZGQgWyVleHRlbnNpb25fY29uc3RydWN0b3IgRmluYWxseV0gKGZ1bmN0aW9uXG4gICAgfCBGaW5hbGx5IChhcmcwX18wMDFfLCBhcmcxX18wMDJfKSAtPlxuICAgICAgbGV0IHJlczBfXzAwM18gPSBzZXhwX29mX3QgYXJnMF9fMDAxX1xuICAgICAgYW5kIHJlczFfXzAwNF8gPSBzZXhwX29mX3QgYXJnMV9fMDAyXyBpblxuICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiZXhuLm1sLkZpbmFsbHlcIjsgcmVzMF9fMDAzXzsgcmVzMV9fMDA0XyBdXG4gICAgfCBfIC0+IGFzc2VydCBmYWxzZSlcbjs7XG5cbltAQEBlbmRdXG5cbmV4Y2VwdGlvbiBSZXJhaXNlZCBvZiBzdHJpbmcgKiB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwXVxuXG5sZXQgKCkgPVxuICBTZXhwbGliMC5TZXhwX2NvbnYuRXhuX2NvbnZlcnRlci5hZGQgWyVleHRlbnNpb25fY29uc3RydWN0b3IgUmVyYWlzZWRdIChmdW5jdGlvblxuICAgIHwgUmVyYWlzZWQgKGFyZzBfXzAwNV8sIGFyZzFfXzAwNl8pIC0+XG4gICAgICBsZXQgcmVzMF9fMDA3XyA9IHNleHBfb2Zfc3RyaW5nIGFyZzBfXzAwNV9cbiAgICAgIGFuZCByZXMxX18wMDhfID0gc2V4cF9vZl90IGFyZzFfXzAwNl8gaW5cbiAgICAgIFNleHBsaWIwLlNleHAuTGlzdFxuICAgICAgICBbIFNleHBsaWIwLlNleHAuQXRvbSBcImV4bi5tbC5SZXJhaXNlZFwiOyByZXMwX18wMDdfOyByZXMxX18wMDhfIF1cbiAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlKVxuOztcblxuW0BAQGVuZF1cblxuZXhjZXB0aW9uIFNleHAgb2YgU2V4cC50XG5cbigqIFdlIGluc3RhbGwgYSBjdXN0b20gZXhuLWNvbnZlcnRlciByYXRoZXIgdGhhbiB1c2U6XG5cbiAgIHtbXG4gICAgIGV4Y2VwdGlvbiBTZXhwIG9mIFNleHAudCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF1cbiAgICAgKCogLi4uICopXG4gICAgIFtAQEBlbmRdXG4gICBdfVxuXG4gICB0byBlbGltaW5hdGUgdGhlIGV4dHJhIHdyYXBwaW5nIG9mIFsoU2V4cCAuLi4pXS4gKilcbmxldCAoKSA9XG4gIFNleHBsaWIwLlNleHBfY29udi5FeG5fY29udmVydGVyLmFkZCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBTZXhwXSAoZnVuY3Rpb25cbiAgICB8IFNleHAgdCAtPiB0XG4gICAgfCBfIC0+XG4gICAgICAoKiBSZWFjaGluZyB0aGlzIGJyYW5jaCBpbmRpY2F0ZXMgYSBidWcgaW4gc2V4cGxpYi4gKilcbiAgICAgIGFzc2VydCBmYWxzZSlcbjs7XG5cbmxldCBjcmVhdGVfcyBzZXhwID0gU2V4cCBzZXhwXG5cbmxldCByYWlzZV93aXRoX29yaWdpbmFsX2JhY2t0cmFjZSB0IGJhY2t0cmFjZSA9XG4gIENhbWwuUHJpbnRleGMucmFpc2Vfd2l0aF9iYWNrdHJhY2UgdCBiYWNrdHJhY2Vcbjs7XG5cbmV4dGVybmFsIGlzX3BoeXNfZXF1YWxfbW9zdF9yZWNlbnQgOiB0IC0+IGJvb2wgPSBcIkJhc2VfY2FtbF9leG5faXNfbW9zdF9yZWNlbnRfZXhuXCJcblxubGV0IHJlcmFpc2UgZXhuIHN0ciA9XG4gIGxldCBleG4nID0gUmVyYWlzZWQgKHN0ciwgZXhuKSBpblxuICBpZiBpc19waHlzX2VxdWFsX21vc3RfcmVjZW50IGV4blxuICB0aGVuIChcbiAgICBsZXQgYnQgPSBDYW1sLlByaW50ZXhjLmdldF9yYXdfYmFja3RyYWNlICgpIGluXG4gICAgcmFpc2Vfd2l0aF9vcmlnaW5hbF9iYWNrdHJhY2UgZXhuJyBidClcbiAgZWxzZSByYWlzZSBleG4nXG47O1xuXG5sZXQgcmVyYWlzZWYgZXhjIGZvcm1hdCA9IFByaW50Zi5rc3ByaW50ZiAoZnVuIHN0ciAoKSAtPiByZXJhaXNlIGV4YyBzdHIpIGZvcm1hdFxubGV0IHRvX3N0cmluZyBleGMgPSBTZXhwLnRvX3N0cmluZ19odW0gfmluZGVudDoyIChzZXhwX29mX2V4biBleGMpXG5sZXQgdG9fc3RyaW5nX21hY2ggZXhjID0gU2V4cC50b19zdHJpbmdfbWFjaCAoc2V4cF9vZl9leG4gZXhjKVxubGV0IHNleHBfb2ZfdCA9IHNleHBfb2ZfZXhuXG5cbmxldCBwcm90ZWN0eCB+ZiB4IH4oZmluYWxseSA6IF8gLT4gdW5pdCkgPVxuICBtYXRjaCBmIHggd2l0aFxuICB8IHJlcyAtPlxuICAgIGZpbmFsbHkgeDtcbiAgICByZXNcbiAgfCBleGNlcHRpb24gZXhuIC0+XG4gICAgbGV0IGJ0ID0gQ2FtbC5QcmludGV4Yy5nZXRfcmF3X2JhY2t0cmFjZSAoKSBpblxuICAgIChtYXRjaCBmaW5hbGx5IHggd2l0aFxuICAgICB8ICgpIC0+IHJhaXNlX3dpdGhfb3JpZ2luYWxfYmFja3RyYWNlIGV4biBidFxuICAgICB8IGV4Y2VwdGlvbiBmaW5hbF9leG4gLT5cbiAgICAgICAoKiBVbmZvcnR1bmF0ZWx5LCB0aGUgYmFja3RyYWNlIG9mIHRoZSBbZmluYWxfZXhuXSBpcyBkaXNjYXJkZWQgaGVyZS4gKilcbiAgICAgICByYWlzZV93aXRoX29yaWdpbmFsX2JhY2t0cmFjZSAoRmluYWxseSAoZXhuLCBmaW5hbF9leG4pKSBidClcbjs7XG5cbmxldCBwcm90ZWN0IH5mIH5maW5hbGx5ID0gcHJvdGVjdHggfmYgKCkgfmZpbmFsbHlcblxubGV0IGRvZXNfcmFpc2UgKHR5cGUgYSkgKGYgOiB1bml0IC0+IGEpID1cbiAgdHJ5XG4gICAgaWdub3JlIChmICgpIDogYSk7XG4gICAgZmFsc2VcbiAgd2l0aFxuICB8IF8gLT4gdHJ1ZVxuOztcblxuaW5jbHVkZSBQcmV0dHlfcHJpbnRlci5SZWdpc3Rlcl9wcCAoc3RydWN0XG4gICAgdHlwZSB0ID0gZXhuXG5cbiAgICBsZXQgcHAgcHBmIHQgPVxuICAgICAgbWF0Y2ggc2V4cF9vZl9leG5fb3B0IHQgd2l0aFxuICAgICAgfCBTb21lIHNleHAgLT4gU2V4cC5wcF9odW0gcHBmIHNleHBcbiAgICAgIHwgTm9uZSAtPiBDYW1sLkZvcm1hdC5wcF9wcmludF9zdHJpbmcgcHBmIChDYW1sLlByaW50ZXhjLnRvX3N0cmluZyB0KVxuICAgIDs7XG5cbiAgICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuRXhuXCJcbiAgZW5kKVxuXG5sZXQgcHJpbnRfd2l0aF9iYWNrdHJhY2UgZXhjIHJhd19iYWNrdHJhY2UgPVxuICBDYW1sLkZvcm1hdC5lcHJpbnRmIFwiQFs8Mj5VbmNhdWdodCBleGNlcHRpb246QFxcbkBcXG5AWyVhQF1AXUBcXG5ALlwiIHBwIGV4YztcbiAgaWYgQ2FtbC5QcmludGV4Yy5iYWNrdHJhY2Vfc3RhdHVzICgpXG4gIHRoZW4gQ2FtbC5QcmludGV4Yy5wcmludF9yYXdfYmFja3RyYWNlIENhbWwuc3RkZXJyIHJhd19iYWNrdHJhY2U7XG4gIENhbWwuZmx1c2ggQ2FtbC5zdGRlcnJcbjs7XG5cbmxldCBzZXRfdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIgKCkgPVxuICBDYW1sLlByaW50ZXhjLnNldF91bmNhdWdodF9leGNlcHRpb25faGFuZGxlciBwcmludF93aXRoX2JhY2t0cmFjZVxuOztcblxubGV0IGhhbmRsZV91bmNhdWdodF9hdXggfmRvX2F0X2V4aXQgfmV4aXQgZiA9XG4gIHRyeSBmICgpIHdpdGhcbiAgfCBleGMgLT5cbiAgICBsZXQgcmF3X2JhY2t0cmFjZSA9IENhbWwuUHJpbnRleGMuZ2V0X3Jhd19iYWNrdHJhY2UgKCkgaW5cbiAgICAoKiBPbmUgcmVhc29uIHRvIHJ1biBbZG9fYXRfZXhpdF0gaGFuZGxlcnMgYmVmb3JlIHByaW50aW5nIG91dCB0aGUgZXJyb3IgbWVzc2FnZSBpc1xuICAgICAgIHRoYXQgaXQgaGVscHMgY3Vyc2VzIGFwcGxpY2F0aW9ucyBicmluZyB0aGUgdGVybWluYWwgaW4gYSBnb29kIHN0YXRlLCBvdGhlcndpc2UgdGhlXG4gICAgICAgZXJyb3IgbWVzc2FnZSBtaWdodCBnZXQgY29ycnVwdGVkLiAgQWxzbywgdGhlIE9DYW1sIHRvcC1sZXZlbCB1bmNhdWdodCBleGNlcHRpb25cbiAgICAgICBoYW5kbGVyIGRvZXMgdGhlIHNhbWUuICopXG4gICAgaWYgZG9fYXRfZXhpdFxuICAgIHRoZW4gKFxuICAgICAgdHJ5IENhbWwuZG9fYXRfZXhpdCAoKSB3aXRoXG4gICAgICB8IF8gLT4gKCkpO1xuICAgICh0cnkgcHJpbnRfd2l0aF9iYWNrdHJhY2UgZXhjIHJhd19iYWNrdHJhY2Ugd2l0aFxuICAgICB8IF8gLT5cbiAgICAgICAodHJ5XG4gICAgICAgICAgQ2FtbC5QcmludGYuZXByaW50ZiBcIkV4bi5oYW5kbGVfdW5jYXVnaHQgY291bGQgbm90IHByaW50OyBleGl0aW5nIGFueXdheVxcbiUhXCJcbiAgICAgICAgd2l0aFxuICAgICAgICB8IF8gLT4gKCkpKTtcbiAgICBleGl0IDFcbjs7XG5cbmxldCBoYW5kbGVfdW5jYXVnaHRfYW5kX2V4aXQgZiA9IGhhbmRsZV91bmNhdWdodF9hdXggZiB+ZXhpdCB+ZG9fYXRfZXhpdDp0cnVlXG5cbmxldCBoYW5kbGVfdW5jYXVnaHQgfmV4aXQ6bXVzdF9leGl0IGYgPVxuICBoYW5kbGVfdW5jYXVnaHRfYXV4IGYgfmV4aXQ6KGlmIG11c3RfZXhpdCB0aGVuIGV4aXQgZWxzZSBpZ25vcmUpIH5kb19hdF9leGl0Om11c3RfZXhpdFxuOztcblxubGV0IHJlcmFpc2VfdW5jYXVnaHQgc3RyIGZ1bmMgPVxuICB0cnkgZnVuYyAoKSB3aXRoXG4gIHwgZXhuIC0+XG4gICAgbGV0IGJ0ID0gQ2FtbC5QcmludGV4Yy5nZXRfcmF3X2JhY2t0cmFjZSAoKSBpblxuICAgIHJhaXNlX3dpdGhfb3JpZ2luYWxfYmFja3RyYWNlIChSZXJhaXNlZCAoc3RyLCBleG4pKSBidFxuOztcblxuZXh0ZXJuYWwgY2xlYXJfYmFja3RyYWNlIDogdW5pdCAtPiB1bml0ID0gXCJCYXNlX2NsZWFyX2NhbWxfYmFja3RyYWNlX3Bvc1wiIFtAQG5vYWxsb2NdXG5cbmxldCByYWlzZV93aXRob3V0X2JhY2t0cmFjZSBlID1cbiAgKCogV2UgY2xlYXIgdGhlIGJhY2t0cmFjZSB0byByZWR1Y2UgY29uZnVzaW9uLCBzbyB0aGF0IHBlb3BsZSBkb24ndCB0aGluayB3aGF0ZXZlclxuICAgICBpcyBzdG9yZWQgY29ycmVzcG9uZHMgdG8gdGhpcyByYWlzZS4gKilcbiAgY2xlYXJfYmFja3RyYWNlICgpO1xuICBDYW1sLnJhaXNlX25vdHJhY2UgZVxuOztcblxubGV0IGluaXRpYWxpemVfbW9kdWxlICgpID0gc2V0X3VuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyICgpXG5cbm1vZHVsZSBQcml2YXRlID0gc3RydWN0XG4gIGxldCBjbGVhcl9iYWNrdHJhY2UgPSBjbGVhcl9iYWNrdHJhY2VcbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5cbnR5cGUgKCdmLCAncykgdCA9XG4gIHwgRmlyc3Qgb2YgJ2ZcbiAgfCBTZWNvbmQgb2YgJ3NcbltAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbmxldCBjb21wYXJlIDpcbiAgJ2YgJ3MuICgnZiAtPiAnZiAtPiBpbnQpIC0+ICgncyAtPiAncyAtPiBpbnQpIC0+ICgnZiwgJ3MpIHQgLT4gKCdmLCAncykgdCAtPiBpbnRcbiAgPVxuICBmdW4gX2NtcF9fZiBfY21wX19zIGFfXzAwMV8gYl9fMDAyXyAtPlxuICBpZiBQcHhfY29tcGFyZV9saWIucGh5c19lcXVhbCBhX18wMDFfIGJfXzAwMl9cbiAgdGhlbiAwXG4gIGVsc2UgKFxuICAgIG1hdGNoIGFfXzAwMV8sIGJfXzAwMl8gd2l0aFxuICAgIHwgRmlyc3QgX2FfXzAwM18sIEZpcnN0IF9iX18wMDRfIC0+IF9jbXBfX2YgX2FfXzAwM18gX2JfXzAwNF9cbiAgICB8IEZpcnN0IF8sIF8gLT4gLTFcbiAgICB8IF8sIEZpcnN0IF8gLT4gMVxuICAgIHwgU2Vjb25kIF9hX18wMDVfLCBTZWNvbmQgX2JfXzAwNl8gLT4gX2NtcF9fcyBfYV9fMDA1XyBfYl9fMDA2Xylcbjs7XG5cbmxldCBoYXNoX2ZvbGRfdFxuICA6IHR5cGUgZiBzLlxuICAgIChQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gZiAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gICAgLT4gKFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiBzIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgICAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGVcbiAgICAtPiAoZiwgcykgdFxuICAgIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZVxuICA9XG4gIGZ1biBfaGFzaF9mb2xkX2YgX2hhc2hfZm9sZF9zIGhzdiBhcmcgLT5cbiAgbWF0Y2ggYXJnIHdpdGhcbiAgfCBGaXJzdCBfYTAgLT5cbiAgICBsZXQgaHN2ID0gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50IGhzdiAwIGluXG4gICAgbGV0IGhzdiA9IGhzdiBpblxuICAgIF9oYXNoX2ZvbGRfZiBoc3YgX2EwXG4gIHwgU2Vjb25kIF9hMCAtPlxuICAgIGxldCBoc3YgPSBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDEgaW5cbiAgICBsZXQgaHN2ID0gaHN2IGluXG4gICAgX2hhc2hfZm9sZF9zIGhzdiBfYTBcbjs7XG5cbmxldCB0X29mX3NleHAgOlxuICAnZiAncy5cbiAgKFNleHBsaWIwLlNleHAudCAtPiAnZikgLT4gKFNleHBsaWIwLlNleHAudCAtPiAncykgLT4gU2V4cGxpYjAuU2V4cC50IC0+ICgnZiwgJ3MpIHRcbiAgPVxuICBmdW4gKHR5cGUgZl9fMDIzXyBzX18wMjRfKVxuICAgICAgOiAgKChTZXhwbGliMC5TZXhwLnQgLT4gZl9fMDIzXykgLT4gKFNleHBsaWIwLlNleHAudCAtPiBzX18wMjRfKSAtPiBTZXhwbGliMC5TZXhwLnRcbiAgICAgICAgICAtPiAoZl9fMDIzXywgc19fMDI0XykgdCkgLT5cbiAgICBsZXQgZXJyb3Jfc291cmNlX18wMTFfID0gXCJlaXRoZXIwLm1sLnRcIiBpblxuICAgIGZ1biBfb2ZfZl9fMDA3XyBfb2Zfc19fMDA4XyAtPiBmdW5jdGlvblxuICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3RcbiAgICAgICAgICAoU2V4cGxpYjAuU2V4cC5BdG9tICgoXCJmaXJzdFwiIHwgXCJGaXJzdFwiKSBhcyBfdGFnX18wMTRfKSA6OiBzZXhwX2FyZ3NfXzAxNV8pIGFzXG4gICAgICAgIF9zZXhwX18wMTNfIC0+XG4gICAgICAgIChtYXRjaCBzZXhwX2FyZ3NfXzAxNV8gd2l0aFxuICAgICAgICAgfCBbIGFyZzBfXzAxNl8gXSAtPlxuICAgICAgICAgICBsZXQgcmVzMF9fMDE3XyA9IF9vZl9mX18wMDdfIGFyZzBfXzAxNl8gaW5cbiAgICAgICAgICAgRmlyc3QgcmVzMF9fMDE3X1xuICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX2luY29ycmVjdF9uX2FyZ3NcbiAgICAgICAgICAgICBlcnJvcl9zb3VyY2VfXzAxMV9cbiAgICAgICAgICAgICBfdGFnX18wMTRfXG4gICAgICAgICAgICAgX3NleHBfXzAxM18pXG4gICAgICB8IFNleHBsaWIwLlNleHAuTGlzdFxuICAgICAgICAgIChTZXhwbGliMC5TZXhwLkF0b20gKChcInNlY29uZFwiIHwgXCJTZWNvbmRcIikgYXMgX3RhZ19fMDE5XykgOjogc2V4cF9hcmdzX18wMjBfKSBhc1xuICAgICAgICBfc2V4cF9fMDE4XyAtPlxuICAgICAgICAobWF0Y2ggc2V4cF9hcmdzX18wMjBfIHdpdGhcbiAgICAgICAgIHwgWyBhcmcwX18wMjFfIF0gLT5cbiAgICAgICAgICAgbGV0IHJlczBfXzAyMl8gPSBfb2Zfc19fMDA4XyBhcmcwX18wMjFfIGluXG4gICAgICAgICAgIFNlY29uZCByZXMwX18wMjJfXG4gICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfaW5jb3JyZWN0X25fYXJnc1xuICAgICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDExX1xuICAgICAgICAgICAgIF90YWdfXzAxOV9cbiAgICAgICAgICAgICBfc2V4cF9fMDE4XylcbiAgICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcImZpcnN0XCIgfCBcIkZpcnN0XCIpIGFzIHNleHBfXzAxMl8gLT5cbiAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfdGFrZXNfYXJncyBlcnJvcl9zb3VyY2VfXzAxMV8gc2V4cF9fMDEyX1xuICAgICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwic2Vjb25kXCIgfCBcIlNlY29uZFwiKSBhcyBzZXhwX18wMTJfIC0+XG4gICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX3Rha2VzX2FyZ3MgZXJyb3Jfc291cmNlX18wMTFfIHNleHBfXzAxMl9cbiAgICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkxpc3QgXyA6OiBfKSBhcyBzZXhwX18wMTBfIC0+XG4gICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5uZXN0ZWRfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAxMV8gc2V4cF9fMDEwX1xuICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgW10gYXMgc2V4cF9fMDEwXyAtPlxuICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IuZW1wdHlfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAxMV8gc2V4cF9fMDEwX1xuICAgICAgfCBzZXhwX18wMTBfIC0+XG4gICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci51bmV4cGVjdGVkX3N0YWcgZXJyb3Jfc291cmNlX18wMTFfIHNleHBfXzAxMF9cbjs7XG5cbmxldCBzZXhwX29mX3QgOlxuICAnZiAncy5cbiAgKCdmIC0+IFNleHBsaWIwLlNleHAudCkgLT4gKCdzIC0+IFNleHBsaWIwLlNleHAudCkgLT4gKCdmLCAncykgdCAtPiBTZXhwbGliMC5TZXhwLnRcbiAgPVxuICBmdW4gKHR5cGUgZl9fMDMxXyBzX18wMzJfKVxuICAgICAgOiAgKChmX18wMzFfIC0+IFNleHBsaWIwLlNleHAudCkgLT4gKHNfXzAzMl8gLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgICAgIC0+IChmX18wMzFfLCBzX18wMzJfKSB0IC0+IFNleHBsaWIwLlNleHAudCkgLT5cbiAgICBmdW4gX29mX2ZfXzAyNV8gX29mX3NfXzAyNl8gLT4gZnVuY3Rpb25cbiAgICAgIHwgRmlyc3QgYXJnMF9fMDI3XyAtPlxuICAgICAgICBsZXQgcmVzMF9fMDI4XyA9IF9vZl9mX18wMjVfIGFyZzBfXzAyN18gaW5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiRmlyc3RcIjsgcmVzMF9fMDI4XyBdXG4gICAgICB8IFNlY29uZCBhcmcwX18wMjlfIC0+XG4gICAgICAgIGxldCByZXMwX18wMzBfID0gX29mX3NfXzAyNl8gYXJnMF9fMDI5XyBpblxuICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJTZWNvbmRcIjsgcmVzMF9fMDMwXyBdXG47O1xuXG5sZXQgKHRfc2V4cF9ncmFtbWFyIDpcbiAgICAgICAnZiBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgICAtPiAncyBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgICAtPiAoJ2YsICdzKSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KVxuICA9XG4gIGZ1biBfJ2Zfc2V4cF9ncmFtbWFyIF8nc19zZXhwX2dyYW1tYXIgLT5cbiAgeyB1bnR5cGVkID1cbiAgICAgIFZhcmlhbnRcbiAgICAgICAgeyBjYXNlX3NlbnNpdGl2aXR5ID0gQ2FzZV9zZW5zaXRpdmVfZXhjZXB0X2ZpcnN0X2NoYXJhY3RlclxuICAgICAgICA7IGNsYXVzZXMgPVxuICAgICAgICAgICAgWyBOb190YWdcbiAgICAgICAgICAgICAgICB7IG5hbWUgPSBcIkZpcnN0XCJcbiAgICAgICAgICAgICAgICA7IGNsYXVzZV9raW5kID1cbiAgICAgICAgICAgICAgICAgICAgTGlzdF9jbGF1c2UgeyBhcmdzID0gQ29ucyAoXydmX3NleHBfZ3JhbW1hci51bnR5cGVkLCBFbXB0eSkgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDsgTm9fdGFnXG4gICAgICAgICAgICAgICAgeyBuYW1lID0gXCJTZWNvbmRcIlxuICAgICAgICAgICAgICAgIDsgY2xhdXNlX2tpbmQgPVxuICAgICAgICAgICAgICAgICAgICBMaXN0X2NsYXVzZSB7IGFyZ3MgPSBDb25zIChfJ3Nfc2V4cF9ncmFtbWFyLnVudHlwZWQsIEVtcHR5KSB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9XG4gIH1cbjs7XG5cbltAQEBlbmRdXG4iLCJvcGVuISBJbXBvcnRcbm1vZHVsZSBFaXRoZXIgPSBFaXRoZXIwXG5cbnR5cGUgKCdhLCAnYikgdCA9ICgnYSwgJ2IpIENhbWwucmVzdWx0ID1cbiAgfCBPayBvZiAnYVxuICB8IEVycm9yIG9mICdiXG5bQEBkZXJpdmluZ19pbmxpbmUgc2V4cCwgc2V4cF9ncmFtbWFyLCBjb21wYXJlLCBlcXVhbCwgaGFzaF1cblxubGV0IHRfb2Zfc2V4cCA6XG4gICdhICdiLlxuICAoU2V4cGxpYjAuU2V4cC50IC0+ICdhKSAtPiAoU2V4cGxpYjAuU2V4cC50IC0+ICdiKSAtPiBTZXhwbGliMC5TZXhwLnQgLT4gKCdhLCAnYikgdFxuICA9XG4gIGZ1biAodHlwZSBhX18wMTdfIGJfXzAxOF8pXG4gICAgICA6ICAoKFNleHBsaWIwLlNleHAudCAtPiBhX18wMTdfKSAtPiAoU2V4cGxpYjAuU2V4cC50IC0+IGJfXzAxOF8pIC0+IFNleHBsaWIwLlNleHAudFxuICAgICAgICAgIC0+IChhX18wMTdfLCBiX18wMThfKSB0KSAtPlxuICAgIGxldCBlcnJvcl9zb3VyY2VfXzAwNV8gPSBcInJlc3VsdC5tbC50XCIgaW5cbiAgICBmdW4gX29mX2FfXzAwMV8gX29mX2JfXzAwMl8gLT4gZnVuY3Rpb25cbiAgICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0XG4gICAgICAgICAgKFNleHBsaWIwLlNleHAuQXRvbSAoKFwib2tcIiB8IFwiT2tcIikgYXMgX3RhZ19fMDA4XykgOjogc2V4cF9hcmdzX18wMDlfKSBhc1xuICAgICAgICBfc2V4cF9fMDA3XyAtPlxuICAgICAgICAobWF0Y2ggc2V4cF9hcmdzX18wMDlfIHdpdGhcbiAgICAgICAgIHwgWyBhcmcwX18wMTBfIF0gLT5cbiAgICAgICAgICAgbGV0IHJlczBfXzAxMV8gPSBfb2ZfYV9fMDAxXyBhcmcwX18wMTBfIGluXG4gICAgICAgICAgIE9rIHJlczBfXzAxMV9cbiAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19pbmNvcnJlY3Rfbl9hcmdzXG4gICAgICAgICAgICAgZXJyb3Jfc291cmNlX18wMDVfXG4gICAgICAgICAgICAgX3RhZ19fMDA4X1xuICAgICAgICAgICAgIF9zZXhwX18wMDdfKVxuICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3RcbiAgICAgICAgICAoU2V4cGxpYjAuU2V4cC5BdG9tICgoXCJlcnJvclwiIHwgXCJFcnJvclwiKSBhcyBfdGFnX18wMTNfKSA6OiBzZXhwX2FyZ3NfXzAxNF8pIGFzXG4gICAgICAgIF9zZXhwX18wMTJfIC0+XG4gICAgICAgIChtYXRjaCBzZXhwX2FyZ3NfXzAxNF8gd2l0aFxuICAgICAgICAgfCBbIGFyZzBfXzAxNV8gXSAtPlxuICAgICAgICAgICBsZXQgcmVzMF9fMDE2XyA9IF9vZl9iX18wMDJfIGFyZzBfXzAxNV8gaW5cbiAgICAgICAgICAgRXJyb3IgcmVzMF9fMDE2X1xuICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX2luY29ycmVjdF9uX2FyZ3NcbiAgICAgICAgICAgICBlcnJvcl9zb3VyY2VfXzAwNV9cbiAgICAgICAgICAgICBfdGFnX18wMTNfXG4gICAgICAgICAgICAgX3NleHBfXzAxMl8pXG4gICAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJva1wiIHwgXCJPa1wiKSBhcyBzZXhwX18wMDZfIC0+XG4gICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX3Rha2VzX2FyZ3MgZXJyb3Jfc291cmNlX18wMDVfIHNleHBfXzAwNl9cbiAgICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcImVycm9yXCIgfCBcIkVycm9yXCIpIGFzIHNleHBfXzAwNl8gLT5cbiAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfdGFrZXNfYXJncyBlcnJvcl9zb3VyY2VfXzAwNV8gc2V4cF9fMDA2X1xuICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuTGlzdCBfIDo6IF8pIGFzIHNleHBfXzAwNF8gLT5cbiAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLm5lc3RlZF9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDA1XyBzZXhwX18wMDRfXG4gICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCBbXSBhcyBzZXhwX18wMDRfIC0+XG4gICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5lbXB0eV9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDA1XyBzZXhwX18wMDRfXG4gICAgICB8IHNleHBfXzAwNF8gLT5cbiAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnVuZXhwZWN0ZWRfc3RhZyBlcnJvcl9zb3VyY2VfXzAwNV8gc2V4cF9fMDA0X1xuOztcblxubGV0IHNleHBfb2ZfdCA6XG4gICdhICdiLlxuICAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAoJ2IgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAoJ2EsICdiKSB0IC0+IFNleHBsaWIwLlNleHAudFxuICA9XG4gIGZ1biAodHlwZSBhX18wMjVfIGJfXzAyNl8pXG4gICAgICA6ICAoKGFfXzAyNV8gLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAoYl9fMDI2XyAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAgICAgLT4gKGFfXzAyNV8sIGJfXzAyNl8pIHQgLT4gU2V4cGxpYjAuU2V4cC50KSAtPlxuICAgIGZ1biBfb2ZfYV9fMDE5XyBfb2ZfYl9fMDIwXyAtPiBmdW5jdGlvblxuICAgICAgfCBPayBhcmcwX18wMjFfIC0+XG4gICAgICAgIGxldCByZXMwX18wMjJfID0gX29mX2FfXzAxOV8gYXJnMF9fMDIxXyBpblxuICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJPa1wiOyByZXMwX18wMjJfIF1cbiAgICAgIHwgRXJyb3IgYXJnMF9fMDIzXyAtPlxuICAgICAgICBsZXQgcmVzMF9fMDI0XyA9IF9vZl9iX18wMjBfIGFyZzBfXzAyM18gaW5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiRXJyb3JcIjsgcmVzMF9fMDI0XyBdXG47O1xuXG5sZXQgKHRfc2V4cF9ncmFtbWFyIDpcbiAgICAgICAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgICAtPiAnYiBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgICAtPiAoJ2EsICdiKSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KVxuICA9XG4gIGZ1biBfJ2Ffc2V4cF9ncmFtbWFyIF8nYl9zZXhwX2dyYW1tYXIgLT5cbiAgeyB1bnR5cGVkID1cbiAgICAgIFZhcmlhbnRcbiAgICAgICAgeyBjYXNlX3NlbnNpdGl2aXR5ID0gQ2FzZV9zZW5zaXRpdmVfZXhjZXB0X2ZpcnN0X2NoYXJhY3RlclxuICAgICAgICA7IGNsYXVzZXMgPVxuICAgICAgICAgICAgWyBOb190YWdcbiAgICAgICAgICAgICAgICB7IG5hbWUgPSBcIk9rXCJcbiAgICAgICAgICAgICAgICA7IGNsYXVzZV9raW5kID1cbiAgICAgICAgICAgICAgICAgICAgTGlzdF9jbGF1c2UgeyBhcmdzID0gQ29ucyAoXydhX3NleHBfZ3JhbW1hci51bnR5cGVkLCBFbXB0eSkgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDsgTm9fdGFnXG4gICAgICAgICAgICAgICAgeyBuYW1lID0gXCJFcnJvclwiXG4gICAgICAgICAgICAgICAgOyBjbGF1c2Vfa2luZCA9XG4gICAgICAgICAgICAgICAgICAgIExpc3RfY2xhdXNlIHsgYXJncyA9IENvbnMgKF8nYl9zZXhwX2dyYW1tYXIudW50eXBlZCwgRW1wdHkpIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH1cbiAgfVxuOztcblxubGV0IGNvbXBhcmUgOlxuICAnYSAnYi4gKCdhIC0+ICdhIC0+IGludCkgLT4gKCdiIC0+ICdiIC0+IGludCkgLT4gKCdhLCAnYikgdCAtPiAoJ2EsICdiKSB0IC0+IGludFxuICA9XG4gIGZ1biBfY21wX19hIF9jbXBfX2IgYV9fMDI3XyBiX18wMjhfIC0+XG4gIGlmIFBweF9jb21wYXJlX2xpYi5waHlzX2VxdWFsIGFfXzAyN18gYl9fMDI4X1xuICB0aGVuIDBcbiAgZWxzZSAoXG4gICAgbWF0Y2ggYV9fMDI3XywgYl9fMDI4XyB3aXRoXG4gICAgfCBPayBfYV9fMDI5XywgT2sgX2JfXzAzMF8gLT4gX2NtcF9fYSBfYV9fMDI5XyBfYl9fMDMwX1xuICAgIHwgT2sgXywgXyAtPiAtMVxuICAgIHwgXywgT2sgXyAtPiAxXG4gICAgfCBFcnJvciBfYV9fMDMxXywgRXJyb3IgX2JfXzAzMl8gLT4gX2NtcF9fYiBfYV9fMDMxXyBfYl9fMDMyXylcbjs7XG5cbmxldCBlcXVhbCA6XG4gICdhICdiLiAoJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gKCdiIC0+ICdiIC0+IGJvb2wpIC0+ICgnYSwgJ2IpIHQgLT4gKCdhLCAnYikgdCAtPiBib29sXG4gID1cbiAgZnVuIF9jbXBfX2EgX2NtcF9fYiBhX18wMzNfIGJfXzAzNF8gLT5cbiAgaWYgUHB4X2NvbXBhcmVfbGliLnBoeXNfZXF1YWwgYV9fMDMzXyBiX18wMzRfXG4gIHRoZW4gdHJ1ZVxuICBlbHNlIChcbiAgICBtYXRjaCBhX18wMzNfLCBiX18wMzRfIHdpdGhcbiAgICB8IE9rIF9hX18wMzVfLCBPayBfYl9fMDM2XyAtPiBfY21wX19hIF9hX18wMzVfIF9iX18wMzZfXG4gICAgfCBPayBfLCBfIC0+IGZhbHNlXG4gICAgfCBfLCBPayBfIC0+IGZhbHNlXG4gICAgfCBFcnJvciBfYV9fMDM3XywgRXJyb3IgX2JfXzAzOF8gLT4gX2NtcF9fYiBfYV9fMDM3XyBfYl9fMDM4Xylcbjs7XG5cbmxldCBoYXNoX2ZvbGRfdFxuICA6IHR5cGUgYSBiLlxuICAgIChQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gYSAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gICAgLT4gKFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiBiIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgICAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGVcbiAgICAtPiAoYSwgYikgdFxuICAgIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZVxuICA9XG4gIGZ1biBfaGFzaF9mb2xkX2EgX2hhc2hfZm9sZF9iIGhzdiBhcmcgLT5cbiAgbWF0Y2ggYXJnIHdpdGhcbiAgfCBPayBfYTAgLT5cbiAgICBsZXQgaHN2ID0gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50IGhzdiAwIGluXG4gICAgbGV0IGhzdiA9IGhzdiBpblxuICAgIF9oYXNoX2ZvbGRfYSBoc3YgX2EwXG4gIHwgRXJyb3IgX2EwIC0+XG4gICAgbGV0IGhzdiA9IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludCBoc3YgMSBpblxuICAgIGxldCBoc3YgPSBoc3YgaW5cbiAgICBfaGFzaF9mb2xkX2IgaHN2IF9hMFxuOztcblxuW0BAQGVuZF1cblxuaW5jbHVkZSBNb25hZC5NYWtlMiAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgKCdhLCAnYikgdCA9ICgnYSwgJ2IpIHRcblxuICAgIGxldCBiaW5kIHggfmYgPVxuICAgICAgbWF0Y2ggeCB3aXRoXG4gICAgICB8IEVycm9yIF8gYXMgeCAtPiB4XG4gICAgICB8IE9rIHggLT4gZiB4XG4gICAgOztcblxuICAgIGxldCBtYXAgeCB+ZiA9XG4gICAgICBtYXRjaCB4IHdpdGhcbiAgICAgIHwgRXJyb3IgXyBhcyB4IC0+IHhcbiAgICAgIHwgT2sgeCAtPiBPayAoZiB4KVxuICAgIDs7XG5cbiAgICBsZXQgbWFwID0gYEN1c3RvbSBtYXBcbiAgICBsZXQgcmV0dXJuIHggPSBPayB4XG4gIGVuZClcblxubGV0IGludmFyaWFudCBjaGVja19vayBjaGVja19lcnJvciB0ID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgT2sgb2sgLT4gY2hlY2tfb2sgb2tcbiAgfCBFcnJvciBlcnJvciAtPiBjaGVja19lcnJvciBlcnJvclxuOztcblxubGV0IGZhaWwgeCA9IEVycm9yIHhcbmxldCBmYWlsZiBmb3JtYXQgPSBQcmludGYua3NwcmludGYgZmFpbCBmb3JtYXRcblxubGV0IG1hcF9lcnJvciB0IH5mID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgT2sgXyBhcyB4IC0+IHhcbiAgfCBFcnJvciB4IC0+IEVycm9yIChmIHgpXG47O1xuXG5tb2R1bGUgRXJyb3IgPSBNb25hZC5NYWtlMiAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgKCdhLCAnYikgdCA9ICgnYiwgJ2EpIHRcblxuICAgIGxldCBiaW5kIHggfmYgPVxuICAgICAgbWF0Y2ggeCB3aXRoXG4gICAgICB8IE9rIF8gYXMgb2sgLT4gb2tcbiAgICAgIHwgRXJyb3IgZSAtPiBmIGVcbiAgICA7O1xuXG4gICAgbGV0IG1hcCA9IGBDdXN0b20gbWFwX2Vycm9yXG4gICAgbGV0IHJldHVybiBlID0gRXJyb3IgZVxuICBlbmQpXG5cbmxldCBpc19vayA9IGZ1bmN0aW9uXG4gIHwgT2sgXyAtPiB0cnVlXG4gIHwgRXJyb3IgXyAtPiBmYWxzZVxuOztcblxubGV0IGlzX2Vycm9yID0gZnVuY3Rpb25cbiAgfCBPayBfIC0+IGZhbHNlXG4gIHwgRXJyb3IgXyAtPiB0cnVlXG47O1xuXG5sZXQgb2sgPSBmdW5jdGlvblxuICB8IE9rIHggLT4gU29tZSB4XG4gIHwgRXJyb3IgXyAtPiBOb25lXG47O1xuXG5sZXQgZXJyb3IgPSBmdW5jdGlvblxuICB8IE9rIF8gLT4gTm9uZVxuICB8IEVycm9yIHggLT4gU29tZSB4XG47O1xuXG5sZXQgb2Zfb3B0aW9uIG9wdCB+ZXJyb3IgPVxuICBtYXRjaCBvcHQgd2l0aFxuICB8IFNvbWUgeCAtPiBPayB4XG4gIHwgTm9uZSAtPiBFcnJvciBlcnJvclxuOztcblxubGV0IGl0ZXIgdiB+ZiA9XG4gIG1hdGNoIHYgd2l0aFxuICB8IE9rIHggLT4gZiB4XG4gIHwgRXJyb3IgXyAtPiAoKVxuOztcblxubGV0IGl0ZXJfZXJyb3IgdiB+ZiA9XG4gIG1hdGNoIHYgd2l0aFxuICB8IE9rIF8gLT4gKClcbiAgfCBFcnJvciB4IC0+IGYgeFxuOztcblxubGV0IHRvX2VpdGhlciA6IF8gdCAtPiBfIEVpdGhlci50ID0gZnVuY3Rpb25cbiAgfCBPayB4IC0+IEZpcnN0IHhcbiAgfCBFcnJvciB4IC0+IFNlY29uZCB4XG47O1xuXG5sZXQgb2ZfZWl0aGVyIDogXyBFaXRoZXIudCAtPiBfIHQgPSBmdW5jdGlvblxuICB8IEZpcnN0IHggLT4gT2sgeFxuICB8IFNlY29uZCB4IC0+IEVycm9yIHhcbjs7XG5cbmxldCBva19pZl90cnVlIGJvb2wgfmVycm9yID0gaWYgYm9vbCB0aGVuIE9rICgpIGVsc2UgRXJyb3IgZXJyb3JcblxubGV0IHRyeV93aXRoIGYgPVxuICB0cnkgT2sgKGYgKCkpIHdpdGhcbiAgfCBleG4gLT4gRXJyb3IgZXhuXG47O1xuXG5sZXQgb2tfZXhuID0gZnVuY3Rpb25cbiAgfCBPayB4IC0+IHhcbiAgfCBFcnJvciBleG4gLT4gcmFpc2UgZXhuXG47O1xuXG5sZXQgb2tfb3JfZmFpbHdpdGggPSBmdW5jdGlvblxuICB8IE9rIHggLT4geFxuICB8IEVycm9yIHN0ciAtPiBmYWlsd2l0aCBzdHJcbjs7XG5cbm1vZHVsZSBFeHBvcnQgPSBzdHJ1Y3RcbiAgdHlwZSAoJ29rLCAnZXJyKSBfcmVzdWx0ID0gKCdvaywgJ2VycikgdCA9XG4gICAgfCBPayBvZiAnb2tcbiAgICB8IEVycm9yIG9mICdlcnJcblxuICBsZXQgaXNfZXJyb3IgPSBpc19lcnJvclxuICBsZXQgaXNfb2sgPSBpc19va1xuZW5kXG5cbmxldCBjb21iaW5lIHQxIHQyIH5vayB+ZXJyID1cbiAgbWF0Y2ggdDEsIHQyIHdpdGhcbiAgfCBPayBfLCBFcnJvciBlIHwgRXJyb3IgZSwgT2sgXyAtPiBFcnJvciBlXG4gIHwgT2sgb2sxLCBPayBvazIgLT4gT2sgKG9rIG9rMSBvazIpXG4gIHwgRXJyb3IgZXJyMSwgRXJyb3IgZXJyMiAtPiBFcnJvciAoZXJyIGVycjEgZXJyMilcbjs7XG5cbmxldCBjb21iaW5lX2Vycm9ycyBsID1cbiAgbGV0IG9rLCBlcnJzID0gTGlzdDEucGFydGl0aW9uX21hcCBsIH5mOnRvX2VpdGhlciBpblxuICBtYXRjaCBlcnJzIHdpdGhcbiAgfCBbXSAtPiBPayBva1xuICB8IF8gOjogXyAtPiBFcnJvciBlcnJzXG47O1xuXG5sZXQgY29tYmluZV9lcnJvcnNfdW5pdCBsID0gbWFwIChjb21iaW5lX2Vycm9ycyBsKSB+ZjooZnVuIChfIDogdW5pdCBsaXN0KSAtPiAoKSlcblxuKCogZGVwcmVjYXRlZCBiaW5kaW5nIGZvciBleHBvcnQgb25seSAqKVxubGV0IG9rX2ZzdCA9IHRvX2VpdGhlclxuIiwib3BlbiEgSW1wb3J0XG5cbnR5cGUgdCA9XG4gIHwgTGVzc1xuICB8IEVxdWFsXG4gIHwgR3JlYXRlclxuW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGhhc2gsIGVudW1lcmF0ZSwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG5sZXQgY29tcGFyZSA9IChQcHhfY29tcGFyZV9saWIucG9seW1vcnBoaWNfY29tcGFyZSA6IHQgLT4gdCAtPiBpbnQpXG5cbmxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgKGZ1biBoc3YgYXJnIC0+XG4gICAgIG1hdGNoIGFyZyB3aXRoXG4gICAgIHwgTGVzcyAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDBcbiAgICAgfCBFcXVhbCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDFcbiAgICAgfCBHcmVhdGVyIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludCBoc3YgMlxuICAgICAgICAgICAgICAgICAgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG47O1xuXG5sZXQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gIGxldCBmdW5jIGFyZyA9XG4gICAgUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmdldF9oYXNoX3ZhbHVlXG4gICAgICAobGV0IGhzdiA9IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5jcmVhdGUgKCkgaW5cbiAgICAgICBoYXNoX2ZvbGRfdCBoc3YgYXJnKVxuICBpblxuICBmdW4geCAtPiBmdW5jIHhcbjs7XG5cbmxldCBhbGwgPSAoWyBMZXNzOyBFcXVhbDsgR3JlYXRlciBdIDogdCBsaXN0KVxuXG5sZXQgdF9vZl9zZXhwID1cbiAgKGxldCBlcnJvcl9zb3VyY2VfXzAwNV8gPSBcIm9yZGVyaW5nLm1sLnRcIiBpblxuICAgZnVuY3Rpb25cbiAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcImxlc3NcIiB8IFwiTGVzc1wiKSAtPiBMZXNzXG4gICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJlcXVhbFwiIHwgXCJFcXVhbFwiKSAtPiBFcXVhbFxuICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwiZ3JlYXRlclwiIHwgXCJHcmVhdGVyXCIpIC0+IEdyZWF0ZXJcbiAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gKFwibGVzc1wiIHwgXCJMZXNzXCIpIDo6IF8pIGFzIHNleHBfXzAwNl8gLT5cbiAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAwNV8gc2V4cF9fMDA2X1xuICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJlcXVhbFwiIHwgXCJFcXVhbFwiKSA6OiBfKSBhcyBzZXhwX18wMDZfIC0+XG4gICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMDVfIHNleHBfXzAwNl9cbiAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gKFwiZ3JlYXRlclwiIHwgXCJHcmVhdGVyXCIpIDo6IF8pIGFzIHNleHBfXzAwNl8gLT5cbiAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAwNV8gc2V4cF9fMDA2X1xuICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuTGlzdCBfIDo6IF8pIGFzIHNleHBfXzAwNF8gLT5cbiAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLm5lc3RlZF9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDA1XyBzZXhwX18wMDRfXG4gICB8IFNleHBsaWIwLlNleHAuTGlzdCBbXSBhcyBzZXhwX18wMDRfIC0+XG4gICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5lbXB0eV9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDA1XyBzZXhwX18wMDRfXG4gICB8IHNleHBfXzAwNF8gLT4gU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnVuZXhwZWN0ZWRfc3RhZyBlcnJvcl9zb3VyY2VfXzAwNV8gc2V4cF9fMDA0X1xuICAgICAgICAgICAgICAgICAgIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG47O1xuXG5sZXQgc2V4cF9vZl90ID1cbiAgKGZ1bmN0aW9uXG4gICAgfCBMZXNzIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIkxlc3NcIlxuICAgIHwgRXF1YWwgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiRXF1YWxcIlxuICAgIHwgR3JlYXRlciAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJHcmVhdGVyXCJcbiAgICAgICAgICAgICAgICAgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbjs7XG5cbmxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9XG4gIHsgdW50eXBlZCA9XG4gICAgICBWYXJpYW50XG4gICAgICAgIHsgY2FzZV9zZW5zaXRpdml0eSA9IENhc2Vfc2Vuc2l0aXZlX2V4Y2VwdF9maXJzdF9jaGFyYWN0ZXJcbiAgICAgICAgOyBjbGF1c2VzID1cbiAgICAgICAgICAgIFsgTm9fdGFnIHsgbmFtZSA9IFwiTGVzc1wiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgIDsgTm9fdGFnIHsgbmFtZSA9IFwiRXF1YWxcIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICA7IE5vX3RhZyB7IG5hbWUgPSBcIkdyZWF0ZXJcIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH1cbiAgfVxuOztcblxuW0BAQGVuZF1cblxubGV0IGVxdWFsIGEgYiA9IGNvbXBhcmUgYSBiID0gMFxuXG5tb2R1bGUgRXhwb3J0ID0gc3RydWN0XG4gIHR5cGUgX29yZGVyaW5nID0gdCA9XG4gICAgfCBMZXNzXG4gICAgfCBFcXVhbFxuICAgIHwgR3JlYXRlclxuZW5kXG5cbmxldCBvZl9pbnQgbiA9IGlmIG4gPCAwIHRoZW4gTGVzcyBlbHNlIGlmIG4gPSAwIHRoZW4gRXF1YWwgZWxzZSBHcmVhdGVyXG5cbmxldCB0b19pbnQgPSBmdW5jdGlvblxuICB8IExlc3MgLT4gLTFcbiAgfCBFcXVhbCAtPiAwXG4gIHwgR3JlYXRlciAtPiAxXG47O1xuIiwib3BlbiEgSW1wb3J0XG5tb2R1bGUgQXJyYXkgPSBBcnJheTBcbm1vZHVsZSBFaXRoZXIgPSBFaXRoZXIwXG5cblxuaW5jbHVkZSBMaXN0MVxuXG4oKiBUaGlzIGl0c2VsZiBpbmNsdWRlcyBbTGlzdDBdLiAqKVxuXG5sZXQgaW52YWxpZF9hcmdmID0gUHJpbnRmLmludmFsaWRfYXJnZlxuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSAnYSBsaXN0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IHRfb2Zfc2V4cCA6ICdhLiAoU2V4cGxpYjAuU2V4cC50IC0+ICdhKSAtPiBTZXhwbGliMC5TZXhwLnQgLT4gJ2EgdCA9IGxpc3Rfb2Zfc2V4cFxuICBsZXQgc2V4cF9vZl90IDogJ2EuICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICdhIHQgLT4gU2V4cGxpYjAuU2V4cC50ID0gc2V4cF9vZl9saXN0XG5cbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6ICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50IC0+ICdhIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID1cbiAgICBmdW4gXydhX3NleHBfZ3JhbW1hciAtPiBsaXN0X3NleHBfZ3JhbW1hciBfJ2Ffc2V4cF9ncmFtbWFyXG4gIDs7XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG5tb2R1bGUgT3JfdW5lcXVhbF9sZW5ndGhzID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9XG4gICAgfCBPayBvZiAnYVxuICAgIHwgVW5lcXVhbF9sZW5ndGhzXG4gIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBzZXhwX29mXVxuXG4gIGxldCBjb21wYXJlIDogJ2EuICgnYSAtPiAnYSAtPiBpbnQpIC0+ICdhIHQgLT4gJ2EgdCAtPiBpbnQgPVxuICAgIGZ1biBfY21wX19hIGFfXzAwNl8gYl9fMDA3XyAtPlxuICAgIGlmIFBweF9jb21wYXJlX2xpYi5waHlzX2VxdWFsIGFfXzAwNl8gYl9fMDA3X1xuICAgIHRoZW4gMFxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggYV9fMDA2XywgYl9fMDA3XyB3aXRoXG4gICAgICB8IE9rIF9hX18wMDhfLCBPayBfYl9fMDA5XyAtPiBfY21wX19hIF9hX18wMDhfIF9iX18wMDlfXG4gICAgICB8IE9rIF8sIF8gLT4gLTFcbiAgICAgIHwgXywgT2sgXyAtPiAxXG4gICAgICB8IFVuZXF1YWxfbGVuZ3RocywgVW5lcXVhbF9sZW5ndGhzIC0+IDApXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSB0IC0+IFNleHBsaWIwLlNleHAudCA9XG4gICAgZnVuICh0eXBlIGFfXzAxM18pIDogKChhX18wMTNfIC0+IFNleHBsaWIwLlNleHAudCkgLT4gYV9fMDEzXyB0IC0+IFNleHBsaWIwLlNleHAudCkgLT5cbiAgICBmdW4gX29mX2FfXzAxMF8gLT4gZnVuY3Rpb25cbiAgICAgIHwgT2sgYXJnMF9fMDExXyAtPlxuICAgICAgICBsZXQgcmVzMF9fMDEyXyA9IF9vZl9hX18wMTBfIGFyZzBfXzAxMV8gaW5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiT2tcIjsgcmVzMF9fMDEyXyBdXG4gICAgICB8IFVuZXF1YWxfbGVuZ3RocyAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJVbmVxdWFsX2xlbmd0aHNcIlxuICA7O1xuXG4gIFtAQEBlbmRdXG5lbmRcblxuaW5jbHVkZSBUXG5cbmxldCBpbnZhcmlhbnQgZiB0ID0gaXRlciB0IH5mXG5sZXQgb2ZfbGlzdCB0ID0gdFxuXG5sZXQgcmFuZ2UnIH5jb21wYXJlIH5zdHJpZGUgPyhzdGFydCA9IGBpbmNsdXNpdmUpID8oc3RvcCA9IGBleGNsdXNpdmUpIHN0YXJ0X2kgc3RvcF9pID1cbiAgbGV0IG5leHRfaSA9IHN0cmlkZSBzdGFydF9pIGluXG4gIGxldCBvcmRlciB4IHkgPSBPcmRlcmluZy5vZl9pbnQgKGNvbXBhcmUgeCB5KSBpblxuICBsZXQgcmFpc2Vfc3RyaWRlX2Nhbm5vdF9yZXR1cm5fc2FtZV92YWx1ZSAoKSA9XG4gICAgaW52YWxpZF9hcmcgXCJMaXN0LnJhbmdlJzogc3RyaWRlIGZ1bmN0aW9uIGNhbm5vdCByZXR1cm4gdGhlIHNhbWUgdmFsdWVcIlxuICBpblxuICBsZXQgaW5pdGlhbF9zdHJpZGVfb3JkZXIgPVxuICAgIG1hdGNoIG9yZGVyIHN0YXJ0X2kgbmV4dF9pIHdpdGhcbiAgICB8IEVxdWFsIC0+IHJhaXNlX3N0cmlkZV9jYW5ub3RfcmV0dXJuX3NhbWVfdmFsdWUgKClcbiAgICB8IExlc3MgLT4gYExlc3NcbiAgICB8IEdyZWF0ZXIgLT4gYEdyZWF0ZXJcbiAgaW5cbiAgbGV0IHJlYyBsb29wIGkgYWNjdW0gPVxuICAgIGxldCBpX3RvX3N0b3Bfb3JkZXIgPSBvcmRlciBpIHN0b3BfaSBpblxuICAgIG1hdGNoIGlfdG9fc3RvcF9vcmRlciwgaW5pdGlhbF9zdHJpZGVfb3JkZXIgd2l0aFxuICAgIHwgTGVzcywgYExlc3MgfCBHcmVhdGVyLCBgR3JlYXRlciAtPlxuICAgICAgKCogaGF2ZW4ndCB5ZXQgcmVhY2hlZCBbc3RvcF9pXS4gQ29udGludWUuICopXG4gICAgICBsZXQgbmV4dF9pID0gc3RyaWRlIGkgaW5cbiAgICAgIChtYXRjaCBvcmRlciBpIG5leHRfaSwgaW5pdGlhbF9zdHJpZGVfb3JkZXIgd2l0aFxuICAgICAgIHwgRXF1YWwsIF8gLT4gcmFpc2Vfc3RyaWRlX2Nhbm5vdF9yZXR1cm5fc2FtZV92YWx1ZSAoKVxuICAgICAgIHwgTGVzcywgYEdyZWF0ZXIgfCBHcmVhdGVyLCBgTGVzcyAtPlxuICAgICAgICAgaW52YWxpZF9hcmcgXCJMaXN0LnJhbmdlJzogc3RyaWRlIGZ1bmN0aW9uIGNhbm5vdCBjaGFuZ2UgZGlyZWN0aW9uXCJcbiAgICAgICB8IExlc3MsIGBMZXNzIHwgR3JlYXRlciwgYEdyZWF0ZXIgLT4gbG9vcCBuZXh0X2kgKGkgOjogYWNjdW0pKVxuICAgIHwgTGVzcywgYEdyZWF0ZXIgfCBHcmVhdGVyLCBgTGVzcyAtPlxuICAgICAgKCogc3RlcHBlZCBwYXN0IFtzdG9wX2ldLiAgRmluaXNoZWQuICopXG4gICAgICBhY2N1bVxuICAgIHwgRXF1YWwsIF8gLT5cbiAgICAgICgqIHJlYWNoZWQgW3N0b3BfaV0uICBGaW5pc2hlZC4gKilcbiAgICAgIChtYXRjaCBzdG9wIHdpdGhcbiAgICAgICB8IGBpbmNsdXNpdmUgLT4gaSA6OiBhY2N1bVxuICAgICAgIHwgYGV4Y2x1c2l2ZSAtPiBhY2N1bSlcbiAgaW5cbiAgbGV0IHN0YXJ0X2kgPVxuICAgIG1hdGNoIHN0YXJ0IHdpdGhcbiAgICB8IGBpbmNsdXNpdmUgLT4gc3RhcnRfaVxuICAgIHwgYGV4Y2x1c2l2ZSAtPiBuZXh0X2lcbiAgaW5cbiAgcmV2IChsb29wIHN0YXJ0X2kgW10pXG47O1xuXG5sZXQgcmFuZ2UgPyhzdHJpZGUgPSAxKSA/KHN0YXJ0ID0gYGluY2x1c2l2ZSkgPyhzdG9wID0gYGV4Y2x1c2l2ZSkgc3RhcnRfaSBzdG9wX2kgPVxuICBpZiBzdHJpZGUgPSAwIHRoZW4gaW52YWxpZF9hcmcgXCJMaXN0LnJhbmdlOiBzdHJpZGUgbXVzdCBiZSBub24temVyb1wiO1xuICByYW5nZScgfmNvbXBhcmUgfnN0cmlkZTooZnVuIHggLT4geCArIHN0cmlkZSkgfnN0YXJ0IH5zdG9wIHN0YXJ0X2kgc3RvcF9pXG47O1xuXG5sZXQgaGQgdCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IFtdIC0+IE5vbmVcbiAgfCB4IDo6IF8gLT4gU29tZSB4XG47O1xuXG5sZXQgdGwgdCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IFtdIC0+IE5vbmVcbiAgfCBfIDo6IHQnIC0+IFNvbWUgdCdcbjs7XG5cbmxldCBudGggdCBuID1cbiAgaWYgbiA8IDBcbiAgdGhlbiBOb25lXG4gIGVsc2UgKFxuICAgIGxldCByZWMgbnRoX2F1eCB0IG4gPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IFtdIC0+IE5vbmVcbiAgICAgIHwgYSA6OiB0IC0+IGlmIG4gPSAwIHRoZW4gU29tZSBhIGVsc2UgbnRoX2F1eCB0IChuIC0gMSlcbiAgICBpblxuICAgIG50aF9hdXggdCBuKVxuOztcblxubGV0IG50aF9leG4gdCBuID1cbiAgbWF0Y2ggbnRoIHQgbiB3aXRoXG4gIHwgTm9uZSAtPiBpbnZhbGlkX2FyZ2YgXCJMaXN0Lm50aF9leG4gJWQgY2FsbGVkIG9uIGxpc3Qgb2YgbGVuZ3RoICVkXCIgbiAobGVuZ3RoIHQpICgpXG4gIHwgU29tZSBhIC0+IGFcbjs7XG5cbmxldCB1bm9yZGVyZWRfYXBwZW5kIGwxIGwyID1cbiAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgfCBbXSwgbCB8IGwsIFtdIC0+IGxcbiAgfCBfIC0+IHJldl9hcHBlbmQgbDEgbDJcbjs7XG5cbm1vZHVsZSBDaGVja19sZW5ndGgyID0gc3RydWN0XG4gIHR5cGUgKCdhLCAnYikgdCA9XG4gICAgfCBTYW1lX2xlbmd0aCBvZiBpbnRcbiAgICB8IFVuZXF1YWxfbGVuZ3RocyBvZlxuICAgICAgICB7IHNoYXJlZF9sZW5ndGggOiBpbnRcbiAgICAgICAgOyB0YWlsX29mX2EgOiAnYSBsaXN0XG4gICAgICAgIDsgdGFpbF9vZl9iIDogJ2IgbGlzdFxuICAgICAgICB9XG5cbiAgKCogSW4gdGhlIFtVbmVxdWFsX2xlbmd0aHNdIGNhc2UsIGF0IGxlYXN0IG9uZSBvZiB0aGUgdGFpbHMgd2lsbCBiZSBub24tZW1wdHkuICopXG4gIGxldCBvZl9saXN0cyBsMSBsMiA9XG4gICAgbGV0IHJlYyBsb29wIGEgYiBzaGFyZWRfbGVuZ3RoID1cbiAgICAgIG1hdGNoIGEsIGIgd2l0aFxuICAgICAgfCBbXSwgW10gLT4gU2FtZV9sZW5ndGggc2hhcmVkX2xlbmd0aFxuICAgICAgfCBfIDo6IGEsIF8gOjogYiAtPiBsb29wIGEgYiAoc2hhcmVkX2xlbmd0aCArIDEpXG4gICAgICB8IFtdLCBfIHwgXywgW10gLT4gVW5lcXVhbF9sZW5ndGhzIHsgc2hhcmVkX2xlbmd0aDsgdGFpbF9vZl9hID0gYTsgdGFpbF9vZl9iID0gYiB9XG4gICAgaW5cbiAgICBsb29wIGwxIGwyIDBcbiAgOztcbmVuZFxuXG5sZXQgY2hlY2tfbGVuZ3RoMl9leG4gbmFtZSBsMSBsMiA9XG4gIG1hdGNoIENoZWNrX2xlbmd0aDIub2ZfbGlzdHMgbDEgbDIgd2l0aFxuICB8IFNhbWVfbGVuZ3RoIF8gLT4gKClcbiAgfCBVbmVxdWFsX2xlbmd0aHMgeyBzaGFyZWRfbGVuZ3RoOyB0YWlsX29mX2E7IHRhaWxfb2ZfYiB9IC0+XG4gICAgaW52YWxpZF9hcmdmXG4gICAgICBcImxlbmd0aCBtaXNtYXRjaCBpbiAlczogJWQgPD4gJWRcIlxuICAgICAgbmFtZVxuICAgICAgKHNoYXJlZF9sZW5ndGggKyBsZW5ndGggdGFpbF9vZl9hKVxuICAgICAgKHNoYXJlZF9sZW5ndGggKyBsZW5ndGggdGFpbF9vZl9iKVxuICAgICAgKClcbjs7XG5cbmxldCBjaGVja19sZW5ndGgyIGwxIGwyIH5mID1cbiAgbWF0Y2ggQ2hlY2tfbGVuZ3RoMi5vZl9saXN0cyBsMSBsMiB3aXRoXG4gIHwgU2FtZV9sZW5ndGggXyAtPiBPcl91bmVxdWFsX2xlbmd0aHMuT2sgKGYgbDEgbDIpXG4gIHwgVW5lcXVhbF9sZW5ndGhzIF8gLT4gVW5lcXVhbF9sZW5ndGhzXG47O1xuXG5tb2R1bGUgQ2hlY2tfbGVuZ3RoMyA9IHN0cnVjdFxuICB0eXBlICgnYSwgJ2IsICdjKSB0ID1cbiAgICB8IFNhbWVfbGVuZ3RoIG9mIGludFxuICAgIHwgVW5lcXVhbF9sZW5ndGhzIG9mXG4gICAgICAgIHsgc2hhcmVkX2xlbmd0aCA6IGludFxuICAgICAgICA7IHRhaWxfb2ZfYSA6ICdhIGxpc3RcbiAgICAgICAgOyB0YWlsX29mX2IgOiAnYiBsaXN0XG4gICAgICAgIDsgdGFpbF9vZl9jIDogJ2MgbGlzdFxuICAgICAgICB9XG5cbiAgKCogSW4gdGhlIFtVbmVxdWFsX2xlbmd0aHNdIGNhc2UsIGF0IGxlYXN0IG9uZSBvZiB0aGUgdGFpbHMgd2lsbCBiZSBub24tZW1wdHkuICopXG4gIGxldCBvZl9saXN0cyBsMSBsMiBsMyA9XG4gICAgbGV0IHJlYyBsb29wIGEgYiBjIHNoYXJlZF9sZW5ndGggPVxuICAgICAgbWF0Y2ggYSwgYiwgYyB3aXRoXG4gICAgICB8IFtdLCBbXSwgW10gLT4gU2FtZV9sZW5ndGggc2hhcmVkX2xlbmd0aFxuICAgICAgfCBfIDo6IGEsIF8gOjogYiwgXyA6OiBjIC0+IGxvb3AgYSBiIGMgKHNoYXJlZF9sZW5ndGggKyAxKVxuICAgICAgfCBbXSwgXywgXyB8IF8sIFtdLCBfIHwgXywgXywgW10gLT5cbiAgICAgICAgVW5lcXVhbF9sZW5ndGhzIHsgc2hhcmVkX2xlbmd0aDsgdGFpbF9vZl9hID0gYTsgdGFpbF9vZl9iID0gYjsgdGFpbF9vZl9jID0gYyB9XG4gICAgaW5cbiAgICBsb29wIGwxIGwyIGwzIDBcbiAgOztcbmVuZFxuXG5sZXQgY2hlY2tfbGVuZ3RoM19leG4gbmFtZSBsMSBsMiBsMyA9XG4gIG1hdGNoIENoZWNrX2xlbmd0aDMub2ZfbGlzdHMgbDEgbDIgbDMgd2l0aFxuICB8IFNhbWVfbGVuZ3RoIF8gLT4gKClcbiAgfCBVbmVxdWFsX2xlbmd0aHMgeyBzaGFyZWRfbGVuZ3RoOyB0YWlsX29mX2E7IHRhaWxfb2ZfYjsgdGFpbF9vZl9jIH0gLT5cbiAgICBsZXQgbjEgPSBzaGFyZWRfbGVuZ3RoICsgbGVuZ3RoIHRhaWxfb2ZfYSBpblxuICAgIGxldCBuMiA9IHNoYXJlZF9sZW5ndGggKyBsZW5ndGggdGFpbF9vZl9iIGluXG4gICAgbGV0IG4zID0gc2hhcmVkX2xlbmd0aCArIGxlbmd0aCB0YWlsX29mX2MgaW5cbiAgICBpbnZhbGlkX2FyZ2YgXCJsZW5ndGggbWlzbWF0Y2ggaW4gJXM6ICVkIDw+ICVkIHx8ICVkIDw+ICVkXCIgbmFtZSBuMSBuMiBuMiBuMyAoKVxuOztcblxubGV0IGNoZWNrX2xlbmd0aDMgbDEgbDIgbDMgfmYgPVxuICBtYXRjaCBDaGVja19sZW5ndGgzLm9mX2xpc3RzIGwxIGwyIGwzIHdpdGhcbiAgfCBTYW1lX2xlbmd0aCBfIC0+IE9yX3VuZXF1YWxfbGVuZ3Rocy5PayAoZiBsMSBsMiBsMylcbiAgfCBVbmVxdWFsX2xlbmd0aHMgXyAtPiBVbmVxdWFsX2xlbmd0aHNcbjs7XG5cbmxldCBpdGVyMiBsMSBsMiB+ZiA9IGNoZWNrX2xlbmd0aDIgbDEgbDIgfmY6KGl0ZXIyX29rIH5mKVxuXG5sZXQgaXRlcjJfZXhuIGwxIGwyIH5mID1cbiAgY2hlY2tfbGVuZ3RoMl9leG4gXCJpdGVyMl9leG5cIiBsMSBsMjtcbiAgaXRlcjJfb2sgbDEgbDIgfmZcbjs7XG5cbmxldCByZXZfbWFwMiBsMSBsMiB+ZiA9IGNoZWNrX2xlbmd0aDIgbDEgbDIgfmY6KHJldl9tYXAyX29rIH5mKVxuXG5sZXQgcmV2X21hcDJfZXhuIGwxIGwyIH5mID1cbiAgY2hlY2tfbGVuZ3RoMl9leG4gXCJyZXZfbWFwMl9leG5cIiBsMSBsMjtcbiAgcmV2X21hcDJfb2sgbDEgbDIgfmZcbjs7XG5cbmxldCBmb2xkMiBsMSBsMiB+aW5pdCB+ZiA9IGNoZWNrX2xlbmd0aDIgbDEgbDIgfmY6KGZvbGQyX29rIH5pbml0IH5mKVxuXG5sZXQgZm9sZDJfZXhuIGwxIGwyIH5pbml0IH5mID1cbiAgY2hlY2tfbGVuZ3RoMl9leG4gXCJmb2xkMl9leG5cIiBsMSBsMjtcbiAgZm9sZDJfb2sgbDEgbDIgfmluaXQgfmZcbjs7XG5cbmxldCBmb3JfYWxsMiBsMSBsMiB+ZiA9IGNoZWNrX2xlbmd0aDIgbDEgbDIgfmY6KGZvcl9hbGwyX29rIH5mKVxuXG5sZXQgZm9yX2FsbDJfZXhuIGwxIGwyIH5mID1cbiAgY2hlY2tfbGVuZ3RoMl9leG4gXCJmb3JfYWxsMl9leG5cIiBsMSBsMjtcbiAgZm9yX2FsbDJfb2sgbDEgbDIgfmZcbjs7XG5cbmxldCBleGlzdHMyIGwxIGwyIH5mID0gY2hlY2tfbGVuZ3RoMiBsMSBsMiB+ZjooZXhpc3RzMl9vayB+ZilcblxubGV0IGV4aXN0czJfZXhuIGwxIGwyIH5mID1cbiAgY2hlY2tfbGVuZ3RoMl9leG4gXCJleGlzdHMyX2V4blwiIGwxIGwyO1xuICBleGlzdHMyX29rIGwxIGwyIH5mXG47O1xuXG5sZXQgbWVtIHQgYSB+ZXF1YWwgPVxuICBsZXQgcmVjIGxvb3AgZXF1YWwgYSA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBmYWxzZVxuICAgIHwgYiA6OiBicyAtPiBlcXVhbCBhIGIgfHwgbG9vcCBlcXVhbCBhIGJzXG4gIGluXG4gIGxvb3AgZXF1YWwgYSB0XG47O1xuXG4oKiBUaGlzIGlzIGEgY29weSBvZiB0aGUgY29kZSBmcm9tIHRoZSBzdGFuZGFyZCBsaWJyYXJ5LCB3aXRoIGFuIGV4dHJhIGV0YS1leHBhbnNpb24gdG9cbiAgIGF2b2lkIGNyZWF0aW5nIHBhcnRpYWwgY2xvc3VyZXMgKHNob3dlZCB1cCBmb3IgW2ZpbHRlcl0pIGluIHByb2ZpbGluZykuICopXG5sZXQgcmV2X2ZpbHRlciB0IH5mID1cbiAgbGV0IHJlYyBmaW5kIH5mIGFjY3UgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gYWNjdVxuICAgIHwgeCA6OiBsIC0+IGlmIGYgeCB0aGVuIGZpbmQgfmYgKHggOjogYWNjdSkgbCBlbHNlIGZpbmQgfmYgYWNjdSBsXG4gIGluXG4gIGZpbmQgfmYgW10gdFxuOztcblxubGV0IGZpbHRlciB0IH5mID0gcmV2IChyZXZfZmlsdGVyIHQgfmYpXG5cbmxldCBmaW5kX21hcCB0IH5mID1cbiAgbGV0IHJlYyBsb29wID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IE5vbmVcbiAgICB8IHggOjogbCAtPlxuICAgICAgKG1hdGNoIGYgeCB3aXRoXG4gICAgICAgfCBOb25lIC0+IGxvb3AgbFxuICAgICAgIHwgU29tZSBfIGFzIHIgLT4gcilcbiAgaW5cbiAgbG9vcCB0XG47O1xuXG5sZXQgZmluZF9tYXBfZXhuID1cbiAgbGV0IG5vdF9mb3VuZCA9IE5vdF9mb3VuZF9zIChBdG9tIFwiTGlzdC5maW5kX21hcF9leG46IG5vdCBmb3VuZFwiKSBpblxuICBsZXQgZmluZF9tYXBfZXhuIHQgfmYgPVxuICAgIG1hdGNoIGZpbmRfbWFwIHQgfmYgd2l0aFxuICAgIHwgTm9uZSAtPiByYWlzZSBub3RfZm91bmRcbiAgICB8IFNvbWUgeCAtPiB4XG4gIGluXG4gICgqIG5hbWVkIHRvIHByZXNlcnZlIHN5bWJvbCBpbiBjb21waWxlZCBiaW5hcnkgKilcbiAgZmluZF9tYXBfZXhuXG47O1xuXG5sZXQgZmluZCB0IH5mID1cbiAgbGV0IHJlYyBsb29wID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IE5vbmVcbiAgICB8IHggOjogbCAtPiBpZiBmIHggdGhlbiBTb21lIHggZWxzZSBsb29wIGxcbiAgaW5cbiAgbG9vcCB0XG47O1xuXG5sZXQgZmluZF9leG4gPVxuICBsZXQgbm90X2ZvdW5kID0gTm90X2ZvdW5kX3MgKEF0b20gXCJMaXN0LmZpbmRfZXhuOiBub3QgZm91bmRcIikgaW5cbiAgbGV0IHJlYyBmaW5kX2V4biB0IH5mID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IFtdIC0+IHJhaXNlIG5vdF9mb3VuZFxuICAgIHwgeCA6OiB0IC0+IGlmIGYgeCB0aGVuIHggZWxzZSBmaW5kX2V4biB0IH5mXG4gIGluXG4gICgqIG5hbWVkIHRvIHByZXNlcnZlIHN5bWJvbCBpbiBjb21waWxlZCBiaW5hcnkgKilcbiAgZmluZF9leG5cbjs7XG5cbmxldCBmaW5kaSB0IH5mID1cbiAgbGV0IHJlYyBsb29wIGkgdCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBbXSAtPiBOb25lXG4gICAgfCB4IDo6IGwgLT4gaWYgZiBpIHggdGhlbiBTb21lIChpLCB4KSBlbHNlIGxvb3AgKGkgKyAxKSBsXG4gIGluXG4gIGxvb3AgMCB0XG47O1xuXG5sZXQgZmluZGlfZXhuID1cbiAgbGV0IG5vdF9mb3VuZCA9IE5vdF9mb3VuZF9zIChBdG9tIFwiTGlzdC5maW5kaV9leG46IG5vdCBmb3VuZFwiKSBpblxuICBsZXQgZmluZGlfZXhuIHQgfmYgPVxuICAgIG1hdGNoIGZpbmRpIHQgfmYgd2l0aFxuICAgIHwgTm9uZSAtPiByYWlzZSBub3RfZm91bmRcbiAgICB8IFNvbWUgeCAtPiB4XG4gIGluXG4gIGZpbmRpX2V4blxuOztcblxubGV0IGZpbmRfbWFwaSB0IH5mID1cbiAgbGV0IHJlYyBsb29wIGkgdCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBbXSAtPiBOb25lXG4gICAgfCB4IDo6IGwgLT5cbiAgICAgIChtYXRjaCBmIGkgeCB3aXRoXG4gICAgICAgfCBTb21lIF8gYXMgcmVzdWx0IC0+IHJlc3VsdFxuICAgICAgIHwgTm9uZSAtPiBsb29wIChpICsgMSkgbClcbiAgaW5cbiAgbG9vcCAwIHRcbjs7XG5cbmxldCBmaW5kX21hcGlfZXhuID1cbiAgbGV0IG5vdF9mb3VuZCA9IE5vdF9mb3VuZF9zIChBdG9tIFwiTGlzdC5maW5kX21hcGlfZXhuOiBub3QgZm91bmRcIikgaW5cbiAgbGV0IGZpbmRfbWFwaV9leG4gdCB+ZiA9XG4gICAgbWF0Y2ggZmluZF9tYXBpIHQgfmYgd2l0aFxuICAgIHwgTm9uZSAtPiByYWlzZSBub3RfZm91bmRcbiAgICB8IFNvbWUgeCAtPiB4XG4gIGluXG4gICgqIG5hbWVkIHRvIHByZXNlcnZlIHN5bWJvbCBpbiBjb21waWxlZCBiaW5hcnkgKilcbiAgZmluZF9tYXBpX2V4blxuOztcblxubGV0IGZvcl9hbGxpIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgaSB0ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IFtdIC0+IHRydWVcbiAgICB8IGhkIDo6IHRsIC0+IGYgaSBoZCAmJiBsb29wIChpICsgMSkgdGxcbiAgaW5cbiAgbG9vcCAwIHRcbjs7XG5cbmxldCBleGlzdHNpIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgaSB0ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IFtdIC0+IGZhbHNlXG4gICAgfCBoZCA6OiB0bCAtPiBmIGkgaGQgfHwgbG9vcCAoaSArIDEpIHRsXG4gIGluXG4gIGxvb3AgMCB0XG47O1xuXG4oKiogRm9yIHRoZSBjb250YWluZXIgaW50ZXJmYWNlLiAqKVxubGV0IGZvbGRfbGVmdCA9IGZvbGRcblxubGV0IHRvX2FycmF5ID0gQXJyYXkub2ZfbGlzdFxubGV0IHRvX2xpc3QgdCA9IHRcblxubGV0IG1heF9ub25fdGFpbGNhbGwgPVxuICBtYXRjaCBTeXMuYmFja2VuZF90eXBlIHdpdGhcbiAgfCBTeXMuTmF0aXZlIHwgU3lzLkJ5dGVjb2RlIC0+IDFfMDAwXG4gICgqIFdlIGRvbid0IGtub3cgdGhlIHNpemUgb2YgdGhlIHN0YWNrLCBiZXR0ZXIgYmUgc2FmZSBhbmQgYXNzdW1lIGl0J3Mgc21hbGwuIFRoaXNcbiAgICAgbnVtYmVyIHdhcyB0YWtlbiBmcm9tIG9jYW1sI3N0ZGxpYi9saXN0Lm1sIHdoaWNoIGlzIGFsc28gZXF1YWwgdG8gdGhlIGRlZmF1bHQgbGltaXRcbiAgICAgb2YgcmVjdXJzaXZlIGNhbGwgaW4gdGhlIGpzX29mX29jYW1sIGNvbXBpbGVyIGJlZm9yZSBzd2l0Y2hpbmcgdG8gdHJhbXBvbGluZS4gKilcbiAgfCBTeXMuT3RoZXIgXyAtPiA1MFxuOztcblxuKCoqIFRhaWwgcmVjdXJzaXZlIHZlcnNpb25zIG9mIHN0YW5kYXJkIFtMaXN0XSBtb2R1bGUgKilcblxubGV0IHRhaWxfYXBwZW5kIGwxIGwyID0gcmV2X2FwcGVuZCAocmV2IGwxKSBsMlxuXG4oKiBUaGVyZSBhcmUgYSBmZXcgb3B0aW1pemVkIGxpc3Qgb3BlcmF0aW9ucyBoZXJlLCBpbmNsdWRpbmcgYXBwZW5kIGFuZCBtYXAuICBUaGVyZSBhcmVcbiAgIGJhc2ljYWxseSB0d28gb3B0aW1pemF0aW9ucyBpbiBwbGF5OiBsb29wIHVucm9sbGluZywgYW5kIGR5bmFtaWMgc3dpdGNoaW5nIGJldHdlZW5cbiAgIHN0YWNrIGFuZCBoZWFwIGFsbG9jYXRpb24uXG5cbiAgIFRoZSBsb29wLXVucm9sbGluZyBpcyBzdHJhaWdodGZvcndhcmQsIHdlIGp1c3QgdW5yb2xsIDUgbGV2ZWxzIG9mIHRoZSBsb29wLiAgVGhpcyBtYWtlc1xuICAgZWFjaCBpdGVyYXRpb24gZmFzdGVyLCBhbmQgYWxzbyByZWR1Y2VzIHRoZSBudW1iZXIgb2Ygc3RhY2sgZnJhbWVzIGNvbnN1bWVkIHBlciBsaXN0XG4gICBlbGVtZW50LlxuXG4gICBUaGUgZHluYW1pYyBzd2l0Y2hpbmcgaXMgZG9uZSBieSBjb3VudGluZyB0aGUgbnVtYmVyIG9mIHN0YWNrIGZyYW1lcywgYW5kIHRoZW5cbiAgIHN3aXRjaGluZyB0byB0aGUgXCJzbG93XCIgaW1wbGVtZW50YXRpb24gd2hlbiB3ZSBleGNlZWQgYSBnaXZlbiBsaW1pdC4gIFRoaXMgbWVhbnMgdGhhdFxuICAgc2hvcnQgbGlzdHMgdXNlIHRoZSBmYXN0IHN0YWNrLWFsbG9jYXRpb24gbWV0aG9kLCBhbmQgbG9uZyBsaXN0cyB1c2UgYSBzbG93ZXIgb25lIHRoYXRcbiAgIGRvZXNuJ3QgcmVxdWlyZSBzdGFjayBzcGFjZS4gKilcbmxldCByZWMgY291bnRfYXBwZW5kIGwxIGwyIGNvdW50ID1cbiAgbWF0Y2ggbDIgd2l0aFxuICB8IFtdIC0+IGwxXG4gIHwgXyAtPlxuICAgIChtYXRjaCBsMSB3aXRoXG4gICAgIHwgW10gLT4gbDJcbiAgICAgfCBbIHgxIF0gLT4geDEgOjogbDJcbiAgICAgfCBbIHgxOyB4MiBdIC0+IHgxIDo6IHgyIDo6IGwyXG4gICAgIHwgWyB4MTsgeDI7IHgzIF0gLT4geDEgOjogeDIgOjogeDMgOjogbDJcbiAgICAgfCBbIHgxOyB4MjsgeDM7IHg0IF0gLT4geDEgOjogeDIgOjogeDMgOjogeDQgOjogbDJcbiAgICAgfCB4MSA6OiB4MiA6OiB4MyA6OiB4NCA6OiB4NSA6OiB0bCAtPlxuICAgICAgIHgxXG4gICAgICAgOjogeDJcbiAgICAgICA6OiB4M1xuICAgICAgIDo6IHg0XG4gICAgICAgOjogeDVcbiAgICAgICA6OlxuICAgICAgIChpZiBjb3VudCA+IG1heF9ub25fdGFpbGNhbGxcbiAgICAgICAgdGhlbiB0YWlsX2FwcGVuZCB0bCBsMlxuICAgICAgICBlbHNlIGNvdW50X2FwcGVuZCB0bCBsMiAoY291bnQgKyAxKSkpXG47O1xuXG5sZXQgYXBwZW5kIGwxIGwyID0gY291bnRfYXBwZW5kIGwxIGwyIDBcblxuKCogQW4gb3JkaW5hcnkgdGFpbCByZWN1cnNpdmUgbWFwIGJ1aWxkcyB1cCBhbiBpbnRlcm1lZGlhdGUgKHJldmVyc2VkKSByZXByZXNlbnRhdGlvbixcbiAgIHdpdGggb25lIGhlYXAgYWxsb2NhdGVkIG9iamVjdCBwZXIgZWxlbWVudC4gVGhlIGZvbGxvd2luZyBpbXBsZW1lbnRhdGlvbiBpbnN0ZWFkIGNodW5rc1xuICAgOSBvYmplY3RzIGludG8gb25lIGhlYXAgYWxsb2NhdGVkIG9iamVjdCwgcmVkdWNpbmcgYWxsb2NhdGlvbiBhbmQgcGVyZm9ybWFuY2UgY29zdHNcbiAgIGFjY29yZGluZ2x5LiBOb3RlIHRoYXQgdGhlIHZlcnkgZW5kIG9mIHRoZSBsaXN0IGlzIGRvbmUgYnkgdGhlIHN0ZGxpYidzIG1hcFxuICAgZnVuY3Rpb24uICopXG5sZXQgdGFpbF9tYXAgeHMgfmYgPVxuICBsZXQgcmVjIHJpc2UgeXMgPSBmdW5jdGlvblxuICAgIHwgW10gLT4geXNcbiAgICB8ICh5MCwgeTEsIHkyLCB5MywgeTQsIHk1LCB5NiwgeTcsIHk4KSA6OiBicyAtPlxuICAgICAgcmlzZSAoeTAgOjogeTEgOjogeTIgOjogeTMgOjogeTQgOjogeTUgOjogeTYgOjogeTcgOjogeTggOjogeXMpIGJzXG4gIGluXG4gIGxldCByZWMgZGl2ZSBicyA9IGZ1bmN0aW9uXG4gICAgfCB4MCA6OiB4MSA6OiB4MiA6OiB4MyA6OiB4NCA6OiB4NSA6OiB4NiA6OiB4NyA6OiB4OCA6OiB4cyAtPlxuICAgICAgbGV0IHkwID0gZiB4MCBpblxuICAgICAgbGV0IHkxID0gZiB4MSBpblxuICAgICAgbGV0IHkyID0gZiB4MiBpblxuICAgICAgbGV0IHkzID0gZiB4MyBpblxuICAgICAgbGV0IHk0ID0gZiB4NCBpblxuICAgICAgbGV0IHk1ID0gZiB4NSBpblxuICAgICAgbGV0IHk2ID0gZiB4NiBpblxuICAgICAgbGV0IHk3ID0gZiB4NyBpblxuICAgICAgbGV0IHk4ID0gZiB4OCBpblxuICAgICAgZGl2ZSAoKHkwLCB5MSwgeTIsIHkzLCB5NCwgeTUsIHk2LCB5NywgeTgpIDo6IGJzKSB4c1xuICAgIHwgeHMgLT4gcmlzZSAobm9udGFpbF9tYXAgfmYgeHMpIGJzXG4gIGluXG4gIGRpdmUgW10geHNcbjs7XG5cbmxldCByZWMgY291bnRfbWFwIH5mIGwgY3RyID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT4gW11cbiAgfCBbIHgxIF0gLT5cbiAgICBsZXQgZjEgPSBmIHgxIGluXG4gICAgWyBmMSBdXG4gIHwgWyB4MTsgeDIgXSAtPlxuICAgIGxldCBmMSA9IGYgeDEgaW5cbiAgICBsZXQgZjIgPSBmIHgyIGluXG4gICAgWyBmMTsgZjIgXVxuICB8IFsgeDE7IHgyOyB4MyBdIC0+XG4gICAgbGV0IGYxID0gZiB4MSBpblxuICAgIGxldCBmMiA9IGYgeDIgaW5cbiAgICBsZXQgZjMgPSBmIHgzIGluXG4gICAgWyBmMTsgZjI7IGYzIF1cbiAgfCBbIHgxOyB4MjsgeDM7IHg0IF0gLT5cbiAgICBsZXQgZjEgPSBmIHgxIGluXG4gICAgbGV0IGYyID0gZiB4MiBpblxuICAgIGxldCBmMyA9IGYgeDMgaW5cbiAgICBsZXQgZjQgPSBmIHg0IGluXG4gICAgWyBmMTsgZjI7IGYzOyBmNCBdXG4gIHwgeDEgOjogeDIgOjogeDMgOjogeDQgOjogeDUgOjogdGwgLT5cbiAgICBsZXQgZjEgPSBmIHgxIGluXG4gICAgbGV0IGYyID0gZiB4MiBpblxuICAgIGxldCBmMyA9IGYgeDMgaW5cbiAgICBsZXQgZjQgPSBmIHg0IGluXG4gICAgbGV0IGY1ID0gZiB4NSBpblxuICAgIGYxXG4gICAgOjogZjJcbiAgICA6OiBmM1xuICAgIDo6IGY0XG4gICAgOjogZjVcbiAgICA6OiAoaWYgY3RyID4gbWF4X25vbl90YWlsY2FsbCB0aGVuIHRhaWxfbWFwIH5mIHRsIGVsc2UgY291bnRfbWFwIH5mIHRsIChjdHIgKyAxKSlcbjs7XG5cbmxldCBtYXAgbCB+ZiA9IGNvdW50X21hcCB+ZiBsIDBcblxubGV0IGZvbGRpbmdfbWFwIHQgfmluaXQgfmYgPVxuICBsZXQgYWNjID0gcmVmIGluaXQgaW5cbiAgbWFwIHQgfmY6KGZ1biB4IC0+XG4gICAgbGV0IG5ld19hY2MsIHkgPSBmICFhY2MgeCBpblxuICAgIGFjYyA6PSBuZXdfYWNjO1xuICAgIHkpXG47O1xuXG5sZXQgZm9sZF9tYXAgdCB+aW5pdCB+ZiA9XG4gIGxldCBhY2MgPSByZWYgaW5pdCBpblxuICBsZXQgcmVzdWx0ID1cbiAgICBtYXAgdCB+ZjooZnVuIHggLT5cbiAgICAgIGxldCBuZXdfYWNjLCB5ID0gZiAhYWNjIHggaW5cbiAgICAgIGFjYyA6PSBuZXdfYWNjO1xuICAgICAgeSlcbiAgaW5cbiAgIWFjYywgcmVzdWx0XG47O1xuXG5sZXQgKCA+PnwgKSBsIGYgPSBtYXAgbCB+ZlxubGV0IG1hcDJfb2sgbDEgbDIgfmYgPSByZXYgKHJldl9tYXAyX29rIGwxIGwyIH5mKVxubGV0IG1hcDIgbDEgbDIgfmYgPSBjaGVja19sZW5ndGgyIGwxIGwyIH5mOihtYXAyX29rIH5mKVxuXG5sZXQgbWFwMl9leG4gbDEgbDIgfmYgPVxuICBjaGVja19sZW5ndGgyX2V4biBcIm1hcDJfZXhuXCIgbDEgbDI7XG4gIG1hcDJfb2sgbDEgbDIgfmZcbjs7XG5cbmxldCByZXZfbWFwM19vayBsMSBsMiBsMyB+ZiA9XG4gIGxldCByZWMgbG9vcCBsMSBsMiBsMyBhYyA9XG4gICAgbWF0Y2ggbDEsIGwyLCBsMyB3aXRoXG4gICAgfCBbXSwgW10sIFtdIC0+IGFjXG4gICAgfCB4MSA6OiBsMSwgeDIgOjogbDIsIHgzIDo6IGwzIC0+IGxvb3AgbDEgbDIgbDMgKGYgeDEgeDIgeDMgOjogYWMpXG4gICAgfCBfIC0+IGFzc2VydCBmYWxzZVxuICBpblxuICBsb29wIGwxIGwyIGwzIFtdXG47O1xuXG5sZXQgcmV2X21hcDMgbDEgbDIgbDMgfmYgPSBjaGVja19sZW5ndGgzIGwxIGwyIGwzIH5mOihyZXZfbWFwM19vayB+ZilcblxubGV0IHJldl9tYXAzX2V4biBsMSBsMiBsMyB+ZiA9XG4gIGNoZWNrX2xlbmd0aDNfZXhuIFwicmV2X21hcDNfZXhuXCIgbDEgbDIgbDM7XG4gIHJldl9tYXAzX29rIGwxIGwyIGwzIH5mXG47O1xuXG5sZXQgbWFwM19vayBsMSBsMiBsMyB+ZiA9IHJldiAocmV2X21hcDNfb2sgbDEgbDIgbDMgfmYpXG5sZXQgbWFwMyBsMSBsMiBsMyB+ZiA9IGNoZWNrX2xlbmd0aDMgbDEgbDIgbDMgfmY6KG1hcDNfb2sgfmYpXG5cbmxldCBtYXAzX2V4biBsMSBsMiBsMyB+ZiA9XG4gIGNoZWNrX2xlbmd0aDNfZXhuIFwibWFwM19leG5cIiBsMSBsMiBsMztcbiAgbWFwM19vayBsMSBsMiBsMyB+ZlxuOztcblxubGV0IHJlYyByZXZfbWFwX2FwcGVuZCBsMSBsMiB+ZiA9XG4gIG1hdGNoIGwxIHdpdGhcbiAgfCBbXSAtPiBsMlxuICB8IGggOjogdCAtPiByZXZfbWFwX2FwcGVuZCB+ZiB0IChmIGggOjogbDIpXG47O1xuXG5sZXQgdW56aXAgbGlzdCA9XG4gIGxldCByZWMgbG9vcCBsaXN0IGwxIGwyID1cbiAgICBtYXRjaCBsaXN0IHdpdGhcbiAgICB8IFtdIC0+IGwxLCBsMlxuICAgIHwgKHgsIHkpIDo6IHRsIC0+IGxvb3AgdGwgKHggOjogbDEpICh5IDo6IGwyKVxuICBpblxuICBsb29wIChyZXYgbGlzdCkgW10gW11cbjs7XG5cbmxldCB1bnppcDMgbGlzdCA9XG4gIGxldCByZWMgbG9vcCBsaXN0IGwxIGwyIGwzID1cbiAgICBtYXRjaCBsaXN0IHdpdGhcbiAgICB8IFtdIC0+IGwxLCBsMiwgbDNcbiAgICB8ICh4LCB5LCB6KSA6OiB0bCAtPiBsb29wIHRsICh4IDo6IGwxKSAoeSA6OiBsMikgKHogOjogbDMpXG4gIGluXG4gIGxvb3AgKHJldiBsaXN0KSBbXSBbXSBbXVxuOztcblxubGV0IHppcF9leG4gbDEgbDIgPVxuICB0cnkgbWFwMl9vayB+ZjooZnVuIGEgYiAtPiBhLCBiKSBsMSBsMiB3aXRoXG4gIHwgXyAtPiBpbnZhbGlkX2FyZ2YgXCJsZW5ndGggbWlzbWF0Y2ggaW4gemlwX2V4bjogJWQgPD4gJWRcIiAobGVuZ3RoIGwxKSAobGVuZ3RoIGwyKSAoKVxuOztcblxubGV0IHppcCBsMSBsMiA9IG1hcDIgfmY6KGZ1biBhIGIgLT4gYSwgYikgbDEgbDJcblxuKCoqIEFkZGl0aW9uYWwgbGlzdCBvcGVyYXRpb25zICopXG5cbmxldCByZXZfbWFwaSBsIH5mID1cbiAgbGV0IHJlYyBsb29wIGkgYWNjID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IGFjY1xuICAgIHwgaCA6OiB0IC0+IGxvb3AgKGkgKyAxKSAoZiBpIGggOjogYWNjKSB0XG4gIGluXG4gIGxvb3AgMCBbXSBsXG47O1xuXG5sZXQgbWFwaSBsIH5mID0gcmV2IChyZXZfbWFwaSBsIH5mKVxuXG5sZXQgZm9sZGluZ19tYXBpIHQgfmluaXQgfmYgPVxuICBsZXQgYWNjID0gcmVmIGluaXQgaW5cbiAgbWFwaSB0IH5mOihmdW4gaSB4IC0+XG4gICAgbGV0IG5ld19hY2MsIHkgPSBmIGkgIWFjYyB4IGluXG4gICAgYWNjIDo9IG5ld19hY2M7XG4gICAgeSlcbjs7XG5cbmxldCBmb2xkX21hcGkgdCB+aW5pdCB+ZiA9XG4gIGxldCBhY2MgPSByZWYgaW5pdCBpblxuICBsZXQgcmVzdWx0ID1cbiAgICBtYXBpIHQgfmY6KGZ1biBpIHggLT5cbiAgICAgIGxldCBuZXdfYWNjLCB5ID0gZiBpICFhY2MgeCBpblxuICAgICAgYWNjIDo9IG5ld19hY2M7XG4gICAgICB5KVxuICBpblxuICAhYWNjLCByZXN1bHRcbjs7XG5cbmxldCBpdGVyaSBsIH5mID1cbiAgaWdub3JlXG4gICAgKGZvbGQgbCB+aW5pdDowIH5mOihmdW4gaSB4IC0+XG4gICAgICAgZiBpIHg7XG4gICAgICAgaSArIDEpXG4gICAgIDogaW50KVxuOztcblxubGV0IGZvbGRpIHQgfmluaXQgfmYgPVxuICBzbmQgKGZvbGQgdCB+aW5pdDooMCwgaW5pdCkgfmY6KGZ1biAoaSwgYWNjKSB2IC0+IGkgKyAxLCBmIGkgYWNjIHYpKVxuOztcblxubGV0IGZpbHRlcmkgbCB+ZiA9XG4gIHJldiAoZm9sZGkgbCB+ZjooZnVuIHBvcyBhY2MgeCAtPiBpZiBmIHBvcyB4IHRoZW4geCA6OiBhY2MgZWxzZSBhY2MpIH5pbml0OltdKVxuOztcblxubGV0IHJlZHVjZSBsIH5mID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT4gTm9uZVxuICB8IGhkIDo6IHRsIC0+IFNvbWUgKGZvbGQgfmluaXQ6aGQgfmYgdGwpXG47O1xuXG5sZXQgcmVkdWNlX2V4biBsIH5mID1cbiAgbWF0Y2ggcmVkdWNlIGwgfmYgd2l0aFxuICB8IE5vbmUgLT4gaW52YWxpZF9hcmcgXCJMaXN0LnJlZHVjZV9leG5cIlxuICB8IFNvbWUgdiAtPiB2XG47O1xuXG5sZXQgcmVkdWNlX2JhbGFuY2VkIGwgfmYgPVxuICAoKiBDYWxsIHRoZSBcInNpemVcIiBvZiBhIHZhbHVlIHRoZSBudW1iZXIgb2YgbGlzdCBlbGVtZW50cyB0aGF0IGhhdmUgYmVlbiBjb21iaW5lZCBpbnRvXG4gICAgIGl0IHZpYSBjYWxscyB0byBbZl0uICBXZSBwcm9jZWVkIGJ5IHVzaW5nIFtmXSB0byBjb21iaW5lIGVsZW1lbnRzIGluIHRoZSBhY2N1bXVsYXRvclxuICAgICBvZiB0aGUgc2FtZSBzaXplIHVudGlsIHdlIGNhbid0IGNvbWJpbmUgYW55IG1vcmUsIHRoZW4gZ2V0dGluZyBhIG5ldyBlbGVtZW50IGZyb20gdGhlXG4gICAgIGlucHV0IGxpc3QgYW5kIHJlcGVhdGluZy5cblxuICAgICBXaXRoIHRoaXMgc3RyYXRlZ3ksIGluIHRoZSBhY2N1bXVsYXRvcjpcbiAgICAgLSB3ZSBvbmx5IGV2ZXIgaGF2ZSBlbGVtZW50cyBvZiBzaXplcyBhIHBvd2VyIG9mIHR3b1xuICAgICAtIHdlIG5ldmVyIGhhdmUgbW9yZSB0aGFuIG9uZSBlbGVtZW50IG9mIGVhY2ggc2l6ZVxuICAgICAtIHRoZSBzdW0gb2YgYWxsIHRoZSBlbGVtZW50IHNpemVzIGlzIGVxdWFsIHRvIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgY29uc3VtZWRcblxuICAgICBUaGVzZSBjb25kaXRpb25zIGVuZm9yY2UgdGhhdCBsaXN0IG9mIGVsZW1lbnRzIG9mIGVhY2ggc2l6ZSBpcyBwcmVjaXNlbHkgdGhlIGJpbmFyeVxuICAgICBleHBhbnNpb24gb2YgdGhlIG51bWJlciBvZiBlbGVtZW50cyBjb25zdW1lZDogaWYgeW91J3ZlIGNvbnN1bWVkIDEzID0gMGIxMTAxXG4gICAgIGVsZW1lbnRzLCB5b3UgaGF2ZSBvbmUgZWxlbWVudCBvZiBzaXplIDgsIG9uZSBvZiBzaXplIDQsIGFuZCBvbmUgb2Ygc2l6ZSAxLiAgSGVuY2VcbiAgICAgd2hlbiBhIG5ldyBlbGVtZW50IGNvbWVzIGFsb25nLCB0aGUgbnVtYmVyIG9mIGNvbWJpbmluZ3MgeW91IG5lZWQgdG8gZG8gaXMgdGhlIG51bWJlclxuICAgICBvZiB0cmFpbGluZyAxcyBpbiB0aGUgYmluYXJ5IGV4cGFuc2lvbiBvZiBbbnVtXSwgdGhlIG51bWJlciBvZiBlbGVtZW50cyB0aGF0IGhhdmVcbiAgICAgYWxyZWFkeSBnb25lIGludG8gdGhlIGFjY3VtdWxhdG9yLiAgVGhlIGFjY3VtdWxhdG9yIGlzIGluIGFzY2VuZGluZyBvcmRlciBvZiBzaXplLCBzb1xuICAgICB0aGUgbmV4dCBlbGVtZW50IHRvIGNvbWJpbmUgd2l0aCBpcyBhbHdheXMgdGhlIGhlYWQgb2YgdGhlIGxpc3QuICopXG4gIGxldCByZWMgc3RlcF9hY2N1bSBudW0gYWNjIHggPVxuICAgIGlmIG51bSBsYW5kIDEgPSAwXG4gICAgdGhlbiB4IDo6IGFjY1xuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggYWNjIHdpdGhcbiAgICAgIHwgW10gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAoKiBOZXcgZWxlbWVudHMgZnJvbSBsYXRlciBpbiB0aGUgaW5wdXQgbGlzdCBnbyBvbiB0aGUgZnJvbnQgb2YgdGhlIGFjY3VtdWxhdG9yLCBzb1xuICAgICAgICAgdGhlIGFjY3VtdWxhdG9yIGlzIGluIHJldmVyc2Ugb3JkZXIgd3J0IHRoZSBvcmlnaW5hbCBsaXN0IG9yZGVyLCBoZW5jZSBbZiB5IHhdXG4gICAgICAgICBpbnN0ZWFkIG9mIFtmIHggeV0uICopXG4gICAgICB8IHkgOjogeXMgLT4gc3RlcF9hY2N1bSAobnVtIGFzciAxKSB5cyAoZiB5IHgpKVxuICBpblxuICAoKiBFeHBlcmltZW50YWxseSwgaW5saW5pbmcgW2ZvbGRpXSBhbmQgdW5yb2xsaW5nIHRoaXMgbG9vcCBhIGZldyB0aW1lcyBjYW4gcmVkdWNlXG4gICAgIHJ1bnRpbWUgZG93biB0byBhIHRoaXJkIGFuZCBhbGxvY2F0aW9uIHRvIDEvMTZ0aCBvciBzbyBpbiB0aGUgbWljcm9iZW5jaG1hcmtzIGJlbG93LlxuICAgICBIb3dldmVyLCBpbiBtb3N0IHVzZSBjYXNlcyBbZl0gaXMgbGlrZWx5IHRvIGJlIGV4cGVuc2l2ZSAob3RoZXJ3aXNlIHdoeSBkbyB5b3UgY2FyZVxuICAgICBhYm91dCB0aGUgb3JkZXIgb2YgcmVkdWN0aW9uPykgc28gdGhlIG92ZXJoZWFkIG9mIHRoaXMgZnVuY3Rpb24gaXRzZWxmIGRvZXNuJ3QgcmVhbGx5XG4gICAgIG1hdHRlci4gSWYgeW91IGNvbWUgdXAgd2l0aCBhIHVzZS1jYXNlIHdoZXJlIGl0IGRvZXMsIHRoZW4gdGhhdCdzIHNvbWV0aGluZyB5b3UgbWlnaHRcbiAgICAgd2FudCB0byB0cnk6IHNlZSBoZyBsb2cgLXByIDQ5ZWYwNjVmNDI5ZC4gKilcbiAgbWF0Y2ggZm9sZGkgbCB+aW5pdDpbXSB+ZjpzdGVwX2FjY3VtIHdpdGhcbiAgfCBbXSAtPiBOb25lXG4gIHwgeCA6OiB4cyAtPiBTb21lIChmb2xkIHhzIH5pbml0OnggfmY6KGZ1biB4IHkgLT4gZiB5IHgpKVxuOztcblxubGV0IHJlZHVjZV9iYWxhbmNlZF9leG4gbCB+ZiA9XG4gIG1hdGNoIHJlZHVjZV9iYWxhbmNlZCBsIH5mIHdpdGhcbiAgfCBOb25lIC0+IGludmFsaWRfYXJnIFwiTGlzdC5yZWR1Y2VfYmFsYW5jZWRfZXhuXCJcbiAgfCBTb21lIHYgLT4gdlxuOztcblxubGV0IGdyb3VwaSBsIH5icmVhayA9XG4gIGxldCBncm91cHMgPVxuICAgIGZvbGRpIGwgfmluaXQ6W10gfmY6KGZ1biBpIGFjYyB4IC0+XG4gICAgICBtYXRjaCBhY2Mgd2l0aFxuICAgICAgfCBbXSAtPiBbIFsgeCBdIF1cbiAgICAgIHwgY3VycmVudF9ncm91cCA6OiB0bCAtPlxuICAgICAgICBpZiBicmVhayBpIChoZF9leG4gY3VycmVudF9ncm91cCkgeFxuICAgICAgICB0aGVuIFsgeCBdIDo6IGN1cnJlbnRfZ3JvdXAgOjogdGwgKCogc3RhcnQgbmV3IGdyb3VwICopXG4gICAgICAgIGVsc2UgKHggOjogY3VycmVudF9ncm91cCkgOjogdGwpXG4gICAgKCogZXh0ZW5kIGN1cnJlbnQgZ3JvdXAgKilcbiAgaW5cbiAgbWF0Y2ggZ3JvdXBzIHdpdGhcbiAgfCBbXSAtPiBbXVxuICB8IGwgLT4gcmV2X21hcCBsIH5mOnJldlxuOztcblxubGV0IGdyb3VwIGwgfmJyZWFrID0gZ3JvdXBpIGwgfmJyZWFrOihmdW4gXyB4IHkgLT4gYnJlYWsgeCB5KVxuXG5sZXQgc29ydF9hbmRfZ3JvdXAgbCB+Y29tcGFyZSA9XG4gIGwgfD4gc3RhYmxlX3NvcnQgfmNvbXBhcmUgfD4gZ3JvdXAgfmJyZWFrOihmdW4geCB5IC0+IGNvbXBhcmUgeCB5IDw+IDApXG47O1xuXG5sZXQgY29uY2F0X21hcCBsIH5mID1cbiAgbGV0IHJlYyBhdXggYWNjID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IHJldiBhY2NcbiAgICB8IGhkIDo6IHRsIC0+IGF1eCAocmV2X2FwcGVuZCAoZiBoZCkgYWNjKSB0bFxuICBpblxuICBhdXggW10gbFxuOztcblxubGV0IGNvbmNhdF9tYXBpIGwgfmYgPVxuICBsZXQgcmVjIGF1eCBjb250IGFjYyA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiByZXYgYWNjXG4gICAgfCBoZCA6OiB0bCAtPiBhdXggKGNvbnQgKyAxKSAocmV2X2FwcGVuZCAoZiBjb250IGhkKSBhY2MpIHRsXG4gIGluXG4gIGF1eCAwIFtdIGxcbjs7XG5cbmxldCBtZXJnZSBsMSBsMiB+Y29tcGFyZSA9XG4gIGxldCByZWMgbG9vcCBhY2MgbDEgbDIgPVxuICAgIG1hdGNoIGwxLCBsMiB3aXRoXG4gICAgfCBbXSwgbDIgLT4gcmV2X2FwcGVuZCBhY2MgbDJcbiAgICB8IGwxLCBbXSAtPiByZXZfYXBwZW5kIGFjYyBsMVxuICAgIHwgaDEgOjogdDEsIGgyIDo6IHQyIC0+XG4gICAgICBpZiBjb21wYXJlIGgxIGgyIDw9IDAgdGhlbiBsb29wIChoMSA6OiBhY2MpIHQxIGwyIGVsc2UgbG9vcCAoaDIgOjogYWNjKSBsMSB0MlxuICBpblxuICBsb29wIFtdIGwxIGwyXG47O1xuXG5tb2R1bGUgQ2FydGVzaWFuX3Byb2R1Y3QgPSBzdHJ1Y3RcbiAgKCogV2UgYXJlIGV4cGxpY2l0IGFib3V0IHdoYXQgd2UgZXhwb3J0IGZyb20gZnVuY3RvcnMgc28gdGhhdCB3ZSBkb24ndCBhY2NpZGVudGFsbHlcbiAgICAgcmViaW5kIG1vcmUgZWZmaWNpZW50IGxpc3Qtc3BlY2lmaWMgZnVuY3Rpb25zLiAqKVxuXG4gIGxldCBiaW5kID0gY29uY2F0X21hcFxuICBsZXQgbWFwID0gbWFwXG4gIGxldCBtYXAyIGEgYiB+ZiA9IGNvbmNhdF9tYXAgYSB+ZjooZnVuIHggLT4gbWFwIGIgfmY6KGZ1biB5IC0+IGYgeCB5KSlcbiAgbGV0IHJldHVybiB4ID0gWyB4IF1cbiAgbGV0ICggPj58ICkgPSAoID4+fCApXG4gIGxldCAoID4+PSApIHQgZiA9IGJpbmQgdCB+ZlxuXG4gIG9wZW4gc3RydWN0XG4gICAgbW9kdWxlIEFwcGxpY2F0aXZlID0gQXBwbGljYXRpdmUuTWFrZV91c2luZ19tYXAyIChzdHJ1Y3RcbiAgICAgICAgdHlwZSAnYSB0ID0gJ2EgbGlzdFxuXG4gICAgICAgIGxldCByZXR1cm4gPSByZXR1cm5cbiAgICAgICAgbGV0IG1hcCA9IGBDdXN0b20gbWFwXG4gICAgICAgIGxldCBtYXAyID0gbWFwMlxuICAgICAgZW5kKVxuXG4gICAgbW9kdWxlIE1vbmFkID0gTW9uYWQuTWFrZSAoc3RydWN0XG4gICAgICAgIHR5cGUgJ2EgdCA9ICdhIGxpc3RcblxuICAgICAgICBsZXQgcmV0dXJuID0gcmV0dXJuXG4gICAgICAgIGxldCBtYXAgPSBgQ3VzdG9tIG1hcFxuICAgICAgICBsZXQgYmluZCA9IGJpbmRcbiAgICAgIGVuZClcbiAgZW5kXG5cbiAgbGV0IGFsbCA9IE1vbmFkLmFsbFxuICBsZXQgYWxsX3VuaXQgPSBNb25hZC5hbGxfdW5pdFxuICBsZXQgaWdub3JlX20gPSBNb25hZC5pZ25vcmVfbVxuICBsZXQgam9pbiA9IE1vbmFkLmpvaW5cblxuICBtb2R1bGUgTW9uYWRfaW5maXggPSBzdHJ1Y3RcbiAgICBsZXQgKCA+PnwgKSA9ICggPj58IClcbiAgICBsZXQgKCA+Pj0gKSA9ICggPj49IClcbiAgZW5kXG5cbiAgbGV0IGFwcGx5ID0gQXBwbGljYXRpdmUuYXBwbHlcbiAgbGV0IGJvdGggPSBBcHBsaWNhdGl2ZS5ib3RoXG4gIGxldCBtYXAzID0gQXBwbGljYXRpdmUubWFwM1xuICBsZXQgKCA8Kj4gKSA9IEFwcGxpY2F0aXZlLiggPCo+IClcbiAgbGV0ICggKj4gKSA9IEFwcGxpY2F0aXZlLiggKj4gKVxuICBsZXQgKCA8KiApID0gQXBwbGljYXRpdmUuKCA8KiApXG5cbiAgbW9kdWxlIEFwcGxpY2F0aXZlX2luZml4ID0gc3RydWN0XG4gICAgbGV0ICggPj58ICkgPSAoID4+fCApXG4gICAgbGV0ICggPCo+ICkgPSBBcHBsaWNhdGl2ZS4oIDwqPiApXG4gICAgbGV0ICggKj4gKSA9IEFwcGxpY2F0aXZlLiggKj4gKVxuICAgIGxldCAoIDwqICkgPSBBcHBsaWNhdGl2ZS4oIDwqIClcbiAgZW5kXG5cbiAgbW9kdWxlIExldF9zeW50YXggPSBzdHJ1Y3RcbiAgICBsZXQgcmV0dXJuID0gcmV0dXJuXG4gICAgbGV0ICggPj58ICkgPSAoID4+fCApXG4gICAgbGV0ICggPj49ICkgPSAoID4+PSApXG5cbiAgICBtb2R1bGUgTGV0X3N5bnRheCA9IHN0cnVjdFxuICAgICAgbGV0IHJldHVybiA9IHJldHVyblxuICAgICAgbGV0IGJpbmQgPSBiaW5kXG4gICAgICBsZXQgbWFwID0gbWFwXG4gICAgICBsZXQgYm90aCA9IGJvdGhcblxuICAgICAgbW9kdWxlIE9wZW5fb25fcmhzID0gc3RydWN0IGVuZFxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5pbmNsdWRlIChDYXJ0ZXNpYW5fcHJvZHVjdCA6IE1vbmFkLlMgd2l0aCB0eXBlICdhIHQgOj0gJ2EgdClcblxuKCoqIHJldHVybnMgZmluYWwgZWxlbWVudCBvZiBsaXN0ICopXG5sZXQgcmVjIGxhc3RfZXhuIGxpc3QgPVxuICBtYXRjaCBsaXN0IHdpdGhcbiAgfCBbIHggXSAtPiB4XG4gIHwgXyA6OiB0bCAtPiBsYXN0X2V4biB0bFxuICB8IFtdIC0+IGludmFsaWRfYXJnIFwiTGlzdC5sYXN0XCJcbjs7XG5cbigqKiBvcHRpb25hbGx5IHJldHVybnMgZmluYWwgZWxlbWVudCBvZiBsaXN0ICopXG5sZXQgcmVjIGxhc3QgbGlzdCA9XG4gIG1hdGNoIGxpc3Qgd2l0aFxuICB8IFsgeCBdIC0+IFNvbWUgeFxuICB8IF8gOjogdGwgLT4gbGFzdCB0bFxuICB8IFtdIC0+IE5vbmVcbjs7XG5cbmxldCByZWMgaXNfcHJlZml4IGxpc3QgfnByZWZpeCB+ZXF1YWwgPVxuICBtYXRjaCBwcmVmaXggd2l0aFxuICB8IFtdIC0+IHRydWVcbiAgfCBoZCA6OiB0bCAtPlxuICAgIChtYXRjaCBsaXN0IHdpdGhcbiAgICAgfCBbXSAtPiBmYWxzZVxuICAgICB8IGhkJyA6OiB0bCcgLT4gZXF1YWwgaGQgaGQnICYmIGlzX3ByZWZpeCB0bCcgfnByZWZpeDp0bCB+ZXF1YWwpXG47O1xuXG5sZXQgZmluZF9jb25zZWN1dGl2ZV9kdXBsaWNhdGUgdCB+ZXF1YWwgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBbXSAtPiBOb25lXG4gIHwgYTEgOjogdCAtPlxuICAgIGxldCByZWMgbG9vcCBhMSB0ID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBbXSAtPiBOb25lXG4gICAgICB8IGEyIDo6IHQgLT4gaWYgZXF1YWwgYTEgYTIgdGhlbiBTb21lIChhMSwgYTIpIGVsc2UgbG9vcCBhMiB0XG4gICAgaW5cbiAgICBsb29wIGExIHRcbjs7XG5cbigqIHJldHVybnMgbGlzdCB3aXRob3V0IGFkamFjZW50IGR1cGxpY2F0ZXMgKilcbmxldCByZW1vdmVfY29uc2VjdXRpdmVfZHVwbGljYXRlcyA/KHdoaWNoX3RvX2tlZXAgPSBgTGFzdCkgbGlzdCB+ZXF1YWwgPVxuICBsZXQgcmVjIGxvb3AgdG9fa2VlcCBhY2N1bSA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiB0b19rZWVwIDo6IGFjY3VtXG4gICAgfCBoZCA6OiB0bCAtPlxuICAgICAgaWYgZXF1YWwgaGQgdG9fa2VlcFxuICAgICAgdGhlbiAoXG4gICAgICAgIGxldCB0b19rZWVwID1cbiAgICAgICAgICBtYXRjaCB3aGljaF90b19rZWVwIHdpdGhcbiAgICAgICAgICB8IGBGaXJzdCAtPiB0b19rZWVwXG4gICAgICAgICAgfCBgTGFzdCAtPiBoZFxuICAgICAgICBpblxuICAgICAgICBsb29wIHRvX2tlZXAgYWNjdW0gdGwpXG4gICAgICBlbHNlIGxvb3AgaGQgKHRvX2tlZXAgOjogYWNjdW0pIHRsXG4gIGluXG4gIG1hdGNoIGxpc3Qgd2l0aFxuICB8IFtdIC0+IFtdXG4gIHwgaGQgOjogdGwgLT4gcmV2IChsb29wIGhkIFtdIHRsKVxuOztcblxuKCoqIHJldHVybnMgc29ydGVkIHZlcnNpb24gb2YgbGlzdCB3aXRoIGR1cGxpY2F0ZXMgcmVtb3ZlZCAqKVxubGV0IGRlZHVwX2FuZF9zb3J0IGxpc3QgfmNvbXBhcmUgPVxuICBtYXRjaCBsaXN0IHdpdGhcbiAgfCBbXSB8IFsgXyBdIC0+IGxpc3QgKCogcGVyZm9ybWFuY2UgaGFjayAqKVxuICB8IF8gLT5cbiAgICBsZXQgZXF1YWwgeCB4JyA9IGNvbXBhcmUgeCB4JyA9IDAgaW5cbiAgICBsZXQgc29ydGVkID0gc29ydCB+Y29tcGFyZSBsaXN0IGluXG4gICAgcmVtb3ZlX2NvbnNlY3V0aXZlX2R1cGxpY2F0ZXMgfmVxdWFsIHNvcnRlZFxuOztcblxubGV0IGZpbmRfYV9kdXAgbCB+Y29tcGFyZSA9XG4gIGxldCBzb3J0ZWQgPSBzb3J0IGwgfmNvbXBhcmUgaW5cbiAgbGV0IHJlYyBsb29wIGwgPVxuICAgIG1hdGNoIGwgd2l0aFxuICAgIHwgW10gfCBbIF8gXSAtPiBOb25lXG4gICAgfCBoZDEgOjogKGhkMiA6OiBfIGFzIHRsKSAtPiBpZiBjb21wYXJlIGhkMSBoZDIgPSAwIHRoZW4gU29tZSBoZDEgZWxzZSBsb29wIHRsXG4gIGluXG4gIGxvb3Agc29ydGVkXG47O1xuXG5sZXQgY29udGFpbnNfZHVwIGxzdCB+Y29tcGFyZSA9XG4gIG1hdGNoIGZpbmRfYV9kdXAgbHN0IH5jb21wYXJlIHdpdGhcbiAgfCBTb21lIF8gLT4gdHJ1ZVxuICB8IE5vbmUgLT4gZmFsc2Vcbjs7XG5cbmxldCBmaW5kX2FsbF9kdXBzIGwgfmNvbXBhcmUgPVxuICAoKiBXZSBhZGQgdGhpcyByZXZlcnNhbCwgc28gd2UgY2FuIHNraXAgYSBbcmV2XSBhdCB0aGUgZW5kLiBXZSBjb3VsZCBza2lwXG4gICAgIFtyZXZdIGFueXdheSBzaW5jZSB3ZSBkb24gbm90IGdpdmUgYW55IG9yZGVyaW5nIGd1YXJhbnRlZXMsIGJ1dCBpdCBpc1xuICAgICBuaWNlIHRvIGdldCByZXN1bHRzIGluIG5hdHVyYWwgb3JkZXIuICopXG4gIGxldCBjb21wYXJlIGEgYiA9IC0xICogY29tcGFyZSBhIGIgaW5cbiAgbGV0IHNvcnRlZCA9IHNvcnQgfmNvbXBhcmUgbCBpblxuICAoKiBXYWxrIHRoZSBsaXN0IGFuZCByZWNvcmQgdGhlIGZpcnN0IG9mIGVhY2ggY29uc2VjdXRpdmUgcnVuIG9mIGlkZW50aWNhbCBlbGVtZW50cyAqKVxuICBsZXQgcmVjIGxvb3Agc29ydGVkIHByZXYgfmFscmVhZHlfcmVjb3JkZWQgYWNjID1cbiAgICBtYXRjaCBzb3J0ZWQgd2l0aFxuICAgIHwgW10gLT4gYWNjXG4gICAgfCBoZCA6OiB0bCAtPlxuICAgICAgaWYgY29tcGFyZSBwcmV2IGhkIDw+IDBcbiAgICAgIHRoZW4gbG9vcCB0bCBoZCB+YWxyZWFkeV9yZWNvcmRlZDpmYWxzZSBhY2NcbiAgICAgIGVsc2UgaWYgYWxyZWFkeV9yZWNvcmRlZFxuICAgICAgdGhlbiBsb29wIHRsIGhkIH5hbHJlYWR5X3JlY29yZGVkOnRydWUgYWNjXG4gICAgICBlbHNlIGxvb3AgdGwgaGQgfmFscmVhZHlfcmVjb3JkZWQ6dHJ1ZSAoaGQgOjogYWNjKVxuICBpblxuICBtYXRjaCBzb3J0ZWQgd2l0aFxuICB8IFtdIC0+IFtdXG4gIHwgaGQgOjogdGwgLT4gbG9vcCB0bCBoZCB+YWxyZWFkeV9yZWNvcmRlZDpmYWxzZSBbXVxuOztcblxubGV0IHJlYyBhbGxfZXF1YWxfdG8gdCB2IH5lcXVhbCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IFtdIC0+IHRydWVcbiAgfCB4IDo6IHhzIC0+IGVxdWFsIHggdiAmJiBhbGxfZXF1YWxfdG8geHMgdiB+ZXF1YWxcbjs7XG5cbmxldCBhbGxfZXF1YWwgdCB+ZXF1YWwgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBbXSAtPiBOb25lXG4gIHwgeCA6OiB4cyAtPiBpZiBhbGxfZXF1YWxfdG8geHMgeCB+ZXF1YWwgdGhlbiBTb21lIHggZWxzZSBOb25lXG47O1xuXG5sZXQgY291bnQgdCB+ZiA9IENvbnRhaW5lci5jb3VudCB+Zm9sZCB0IH5mXG5sZXQgc3VtIG0gdCB+ZiA9IENvbnRhaW5lci5zdW0gfmZvbGQgbSB0IH5mXG5sZXQgbWluX2VsdCB0IH5jb21wYXJlID0gQ29udGFpbmVyLm1pbl9lbHQgfmZvbGQgdCB+Y29tcGFyZVxubGV0IG1heF9lbHQgdCB+Y29tcGFyZSA9IENvbnRhaW5lci5tYXhfZWx0IH5mb2xkIHQgfmNvbXBhcmVcblxubGV0IGNvdW50aSB0IH5mID1cbiAgZm9sZGkgdCB+aW5pdDowIH5mOihmdW4gaWR4IGNvdW50IGEgLT4gaWYgZiBpZHggYSB0aGVuIGNvdW50ICsgMSBlbHNlIGNvdW50KVxuOztcblxubGV0IGluaXQgbiB+ZiA9XG4gIGlmIG4gPCAwIHRoZW4gaW52YWxpZF9hcmdmIFwiTGlzdC5pbml0ICVkXCIgbiAoKTtcbiAgbGV0IHJlYyBsb29wIGkgYWNjdW0gPVxuICAgIGFzc2VydCAoaSA+PSAwKTtcbiAgICBpZiBpID0gMCB0aGVuIGFjY3VtIGVsc2UgbG9vcCAoaSAtIDEpIChmIChpIC0gMSkgOjogYWNjdW0pXG4gIGluXG4gIGxvb3AgbiBbXVxuOztcblxubGV0IHJldl9maWx0ZXJfbWFwIGwgfmYgPVxuICBsZXQgcmVjIGxvb3AgbCBhY2N1bSA9XG4gICAgbWF0Y2ggbCB3aXRoXG4gICAgfCBbXSAtPiBhY2N1bVxuICAgIHwgaGQgOjogdGwgLT5cbiAgICAgIChtYXRjaCBmIGhkIHdpdGhcbiAgICAgICB8IFNvbWUgeCAtPiBsb29wIHRsICh4IDo6IGFjY3VtKVxuICAgICAgIHwgTm9uZSAtPiBsb29wIHRsIGFjY3VtKVxuICBpblxuICBsb29wIGwgW11cbjs7XG5cbmxldCBmaWx0ZXJfbWFwIGwgfmYgPSByZXYgKHJldl9maWx0ZXJfbWFwIGwgfmYpXG5cbmxldCByZXZfZmlsdGVyX21hcGkgbCB+ZiA9XG4gIGxldCByZWMgbG9vcCBpIGwgYWNjdW0gPVxuICAgIG1hdGNoIGwgd2l0aFxuICAgIHwgW10gLT4gYWNjdW1cbiAgICB8IGhkIDo6IHRsIC0+XG4gICAgICAobWF0Y2ggZiBpIGhkIHdpdGhcbiAgICAgICB8IFNvbWUgeCAtPiBsb29wIChpICsgMSkgdGwgKHggOjogYWNjdW0pXG4gICAgICAgfCBOb25lIC0+IGxvb3AgKGkgKyAxKSB0bCBhY2N1bSlcbiAgaW5cbiAgbG9vcCAwIGwgW11cbjs7XG5cbmxldCBmaWx0ZXJfbWFwaSBsIH5mID0gcmV2IChyZXZfZmlsdGVyX21hcGkgbCB+ZilcbmxldCBmaWx0ZXJfb3B0IGwgPSBmaWx0ZXJfbWFwIGwgfmY6Rm4uaWRcblxubGV0IHBhcnRpdGlvbjNfbWFwIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgdCBmc3Qgc25kIHRyZCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBbXSAtPiByZXYgZnN0LCByZXYgc25kLCByZXYgdHJkXG4gICAgfCB4IDo6IHQgLT5cbiAgICAgIChtYXRjaCBmIHggd2l0aFxuICAgICAgIHwgYEZzdCB5IC0+IGxvb3AgdCAoeSA6OiBmc3QpIHNuZCB0cmRcbiAgICAgICB8IGBTbmQgeSAtPiBsb29wIHQgZnN0ICh5IDo6IHNuZCkgdHJkXG4gICAgICAgfCBgVHJkIHkgLT4gbG9vcCB0IGZzdCBzbmQgKHkgOjogdHJkKSlcbiAgaW5cbiAgbG9vcCB0IFtdIFtdIFtdXG47O1xuXG5sZXQgcGFydGl0aW9uX3RmIHQgfmYgPVxuICBsZXQgZiB4IDogXyBFaXRoZXIudCA9IGlmIGYgeCB0aGVuIEZpcnN0IHggZWxzZSBTZWNvbmQgeCBpblxuICBwYXJ0aXRpb25fbWFwIHQgfmZcbjs7XG5cbmxldCBwYXJ0aXRpb25fcmVzdWx0IHQgPSBwYXJ0aXRpb25fbWFwIHQgfmY6UmVzdWx0LnRvX2VpdGhlclxuXG5tb2R1bGUgQXNzb2MgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2EsICdiKSB0ID0gKCdhICogJ2IpIGxpc3QgW0BAZGVyaXZpbmdfaW5saW5lIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgdF9vZl9zZXhwIDpcbiAgICAnYSAnYi5cbiAgICAoU2V4cGxpYjAuU2V4cC50IC0+ICdhKVxuICAgIC0+IChTZXhwbGliMC5TZXhwLnQgLT4gJ2IpXG4gICAgLT4gU2V4cGxpYjAuU2V4cC50XG4gICAgLT4gKCdhLCAnYikgdFxuICAgID1cbiAgICBsZXQgZXJyb3Jfc291cmNlX18wMjJfID0gXCJsaXN0Lm1sLkFzc29jLnRcIiBpblxuICAgIGZ1biBfb2ZfYV9fMDE0XyBfb2ZfYl9fMDE1XyB4X18wMjNfIC0+XG4gICAgICBsaXN0X29mX3NleHBcbiAgICAgICAgKGZ1bmN0aW9uXG4gICAgICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgWyBhcmcwX18wMTdfOyBhcmcxX18wMThfIF0gLT5cbiAgICAgICAgICAgIGxldCByZXMwX18wMTlfID0gX29mX2FfXzAxNF8gYXJnMF9fMDE3X1xuICAgICAgICAgICAgYW5kIHJlczFfXzAyMF8gPSBfb2ZfYl9fMDE1XyBhcmcxX18wMThfIGluXG4gICAgICAgICAgICByZXMwX18wMTlfLCByZXMxX18wMjBfXG4gICAgICAgICAgfCBzZXhwX18wMjFfIC0+XG4gICAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IudHVwbGVfb2Zfc2l6ZV9uX2V4cGVjdGVkXG4gICAgICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDIyX1xuICAgICAgICAgICAgICAyXG4gICAgICAgICAgICAgIHNleHBfXzAyMV8pXG4gICAgICAgIHhfXzAyM19cbiAgOztcblxuICBsZXQgc2V4cF9vZl90IDpcbiAgICAnYSAnYi5cbiAgICAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgIC0+ICgnYiAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgLT4gKCdhLCAnYikgdFxuICAgIC0+IFNleHBsaWIwLlNleHAudFxuICAgID1cbiAgICBmdW4gX29mX2FfXzAyNF8gX29mX2JfXzAyNV8geF9fMDMwXyAtPlxuICAgICAgc2V4cF9vZl9saXN0XG4gICAgICAgIChmdW4gKGFyZzBfXzAyNl8sIGFyZzFfXzAyN18pIC0+XG4gICAgICAgICAgIGxldCByZXMwX18wMjhfID0gX29mX2FfXzAyNF8gYXJnMF9fMDI2X1xuICAgICAgICAgICBhbmQgcmVzMV9fMDI5XyA9IF9vZl9iX18wMjVfIGFyZzFfXzAyN18gaW5cbiAgICAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgcmVzMF9fMDI4XzsgcmVzMV9fMDI5XyBdKVxuICAgICAgICB4X18wMzBfXG4gIDs7XG5cbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6XG4gICAgICAgICAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgICAgIC0+ICdiIFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgICAgLT4gKCdhLCAnYikgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudClcbiAgICA9XG4gICAgZnVuIF8nYV9zZXhwX2dyYW1tYXIgXydiX3NleHBfZ3JhbW1hciAtPlxuICAgICAgbGlzdF9zZXhwX2dyYW1tYXJcbiAgICAgICAgeyB1bnR5cGVkID1cbiAgICAgICAgICAgIExpc3QgKENvbnMgKF8nYV9zZXhwX2dyYW1tYXIudW50eXBlZCwgQ29ucyAoXydiX3NleHBfZ3JhbW1hci51bnR5cGVkLCBFbXB0eSkpKVxuICAgICAgICB9XG4gIDs7XG5cbiAgW0BAQGVuZF1cblxuICBsZXQgcGFpcl9vZl9ncm91cCA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBhc3NlcnQgZmFsc2VcbiAgICB8IChrLCBfKSA6OiBfIGFzIGxpc3QgLT4gaywgbWFwIGxpc3QgfmY6c25kXG4gIDs7XG5cbiAgbGV0IGdyb3VwIGFsaXN0IH5lcXVhbCA9XG4gICAgZ3JvdXAgYWxpc3QgfmJyZWFrOihmdW4gKHgsIF8pICh5LCBfKSAtPiBub3QgKGVxdWFsIHggeSkpIHw+IG1hcCB+ZjpwYWlyX29mX2dyb3VwXG4gIDs7XG5cbiAgbGV0IHNvcnRfYW5kX2dyb3VwIGFsaXN0IH5jb21wYXJlID1cbiAgICBzb3J0X2FuZF9ncm91cCBhbGlzdCB+Y29tcGFyZTooZnVuICh4LCBfKSAoeSwgXykgLT4gY29tcGFyZSB4IHkpXG4gICAgfD4gbWFwIH5mOnBhaXJfb2ZfZ3JvdXBcbiAgOztcblxuICBsZXQgZmluZCB0IH5lcXVhbCBrZXkgPVxuICAgIG1hdGNoIGZpbmQgdCB+ZjooZnVuIChrZXknLCBfKSAtPiBlcXVhbCBrZXkga2V5Jykgd2l0aFxuICAgIHwgTm9uZSAtPiBOb25lXG4gICAgfCBTb21lIHggLT4gU29tZSAoc25kIHgpXG4gIDs7XG5cbiAgbGV0IGZpbmRfZXhuID1cbiAgICBsZXQgbm90X2ZvdW5kID0gTm90X2ZvdW5kX3MgKEF0b20gXCJMaXN0LkFzc29jLmZpbmRfZXhuOiBub3QgZm91bmRcIikgaW5cbiAgICBsZXQgZmluZF9leG4gdCB+ZXF1YWwga2V5ID1cbiAgICAgIG1hdGNoIGZpbmQgdCBrZXkgfmVxdWFsIHdpdGhcbiAgICAgIHwgTm9uZSAtPiByYWlzZSBub3RfZm91bmRcbiAgICAgIHwgU29tZSB2YWx1ZSAtPiB2YWx1ZVxuICAgIGluXG4gICAgKCogbmFtZWQgdG8gcHJlc2VydmUgc3ltYm9sIGluIGNvbXBpbGVkIGJpbmFyeSAqKVxuICAgIGZpbmRfZXhuXG4gIDs7XG5cbiAgbGV0IG1lbSB0IH5lcXVhbCBrZXkgPVxuICAgIG1hdGNoIGZpbmQgdCB+ZXF1YWwga2V5IHdpdGhcbiAgICB8IE5vbmUgLT4gZmFsc2VcbiAgICB8IFNvbWUgXyAtPiB0cnVlXG4gIDs7XG5cbiAgbGV0IHJlbW92ZSB0IH5lcXVhbCBrZXkgPSBmaWx0ZXIgdCB+ZjooZnVuIChrZXknLCBfKSAtPiBub3QgKGVxdWFsIGtleSBrZXknKSlcblxuICBsZXQgYWRkIHQgfmVxdWFsIGtleSB2YWx1ZSA9XG4gICAgKCogdGhlIHJlbW92ZSBkb2Vzbid0IGNoYW5nZSB0aGUgbWFwIHNlbWFudGljcywgYnV0IGtlZXBzIHRoZSBsaXN0IHNtYWxsICopXG4gICAgKGtleSwgdmFsdWUpIDo6IHJlbW92ZSB0IH5lcXVhbCBrZXlcbiAgOztcblxuICBsZXQgaW52ZXJzZSB0ID0gbWFwIHQgfmY6KGZ1biAoeCwgeSkgLT4geSwgeClcbiAgbGV0IG1hcCB0IH5mID0gbWFwIHQgfmY6KGZ1biAoa2V5LCB2YWx1ZSkgLT4ga2V5LCBmIHZhbHVlKVxuZW5kXG5cbmxldCBzdWIgbCB+cG9zIH5sZW4gPVxuICAoKiBXZSB1c2UgW3BvcyA+IGxlbmd0aCBsIC0gbGVuXSByYXRoZXIgdGhhbiBbcG9zICsgbGVuID4gbGVuZ3RoIGxdIHRvIGF2b2lkIHRoZVxuICAgICBwb3NzaWJpbGl0eSBvZiBvdmVyZmxvdy4gKilcbiAgaWYgcG9zIDwgMCB8fCBsZW4gPCAwIHx8IHBvcyA+IGxlbmd0aCBsIC0gbGVuIHRoZW4gaW52YWxpZF9hcmcgXCJMaXN0LnN1YlwiO1xuICByZXZcbiAgICAoZm9sZGkgbCB+aW5pdDpbXSB+ZjooZnVuIGkgYWNjIGVsIC0+XG4gICAgICAgaWYgaSA+PSBwb3MgJiYgaSA8IHBvcyArIGxlbiB0aGVuIGVsIDo6IGFjYyBlbHNlIGFjYykpXG47O1xuXG5sZXQgc3BsaXRfbiB0X29yaWcgbiA9XG4gIGlmIG4gPD0gMFxuICB0aGVuIFtdLCB0X29yaWdcbiAgZWxzZSAoXG4gICAgbGV0IHJlYyBsb29wIG4gdCBhY2N1bSA9XG4gICAgICBpZiBuID0gMFxuICAgICAgdGhlbiByZXYgYWNjdW0sIHRcbiAgICAgIGVsc2UgKFxuICAgICAgICBtYXRjaCB0IHdpdGhcbiAgICAgICAgfCBbXSAtPiB0X29yaWcsIFtdICgqIGluIHRoaXMgY2FzZSwgdF9vcmlnID0gcmV2IGFjY3VtICopXG4gICAgICAgIHwgaGQgOjogdGwgLT4gbG9vcCAobiAtIDEpIHRsIChoZCA6OiBhY2N1bSkpXG4gICAgaW5cbiAgICBsb29wIG4gdF9vcmlnIFtdKVxuOztcblxuKCogY29waWVkIGZyb20gW3NwbGl0X25dIHRvIGF2b2lkIGFsbG9jYXRpbmcgYSB0dXBsZSAqKVxubGV0IHRha2UgdF9vcmlnIG4gPVxuICBpZiBuIDw9IDBcbiAgdGhlbiBbXVxuICBlbHNlIChcbiAgICBsZXQgcmVjIGxvb3AgbiB0IGFjY3VtID1cbiAgICAgIGlmIG4gPSAwXG4gICAgICB0aGVuIHJldiBhY2N1bVxuICAgICAgZWxzZSAoXG4gICAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgICB8IFtdIC0+IHRfb3JpZ1xuICAgICAgICB8IGhkIDo6IHRsIC0+IGxvb3AgKG4gLSAxKSB0bCAoaGQgOjogYWNjdW0pKVxuICAgIGluXG4gICAgbG9vcCBuIHRfb3JpZyBbXSlcbjs7XG5cbmxldCByZWMgZHJvcCB0IG4gPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBfIDo6IHRsIHdoZW4gbiA+IDAgLT4gZHJvcCB0bCAobiAtIDEpXG4gIHwgdCAtPiB0XG47O1xuXG5sZXQgY2h1bmtzX29mIGwgfmxlbmd0aCA9XG4gIGlmIGxlbmd0aCA8PSAwIHRoZW4gaW52YWxpZF9hcmdmIFwiTGlzdC5jaHVua3Nfb2Y6IEV4cGVjdGVkIGxlbmd0aCA+IDAsIGdvdCAlZFwiIGxlbmd0aCAoKTtcbiAgbGV0IHJlYyBhdXggb2ZfbGVuZ3RoIGFjYyBsID1cbiAgICBtYXRjaCBsIHdpdGhcbiAgICB8IFtdIC0+IHJldiBhY2NcbiAgICB8IF8gOjogXyAtPlxuICAgICAgbGV0IHN1Ymxpc3QsIGwgPSBzcGxpdF9uIGwgbGVuZ3RoIGluXG4gICAgICBhdXggb2ZfbGVuZ3RoIChzdWJsaXN0IDo6IGFjYykgbFxuICBpblxuICBhdXggbGVuZ3RoIFtdIGxcbjs7XG5cbmxldCBzcGxpdF93aGlsZSB4cyB+ZiA9XG4gIGxldCByZWMgbG9vcCBhY2MgPSBmdW5jdGlvblxuICAgIHwgaGQgOjogdGwgd2hlbiBmIGhkIC0+IGxvb3AgKGhkIDo6IGFjYykgdGxcbiAgICB8IHQgLT4gcmV2IGFjYywgdFxuICBpblxuICBsb29wIFtdIHhzXG47O1xuXG4oKiBjb3BpZWQgZnJvbSBbc3BsaXRfd2hpbGVdIHRvIGF2b2lkIGFsbG9jYXRpbmcgYSB0dXBsZSAqKVxubGV0IHRha2Vfd2hpbGUgeHMgfmYgPVxuICBsZXQgcmVjIGxvb3AgYWNjID0gZnVuY3Rpb25cbiAgICB8IGhkIDo6IHRsIHdoZW4gZiBoZCAtPiBsb29wIChoZCA6OiBhY2MpIHRsXG4gICAgfCBfIC0+IHJldiBhY2NcbiAgaW5cbiAgbG9vcCBbXSB4c1xuOztcblxubGV0IHJlYyBkcm9wX3doaWxlIHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBoZCA6OiB0bCB3aGVuIGYgaGQgLT4gZHJvcF93aGlsZSB0bCB+ZlxuICB8IHQgLT4gdFxuOztcblxubGV0IGRyb3BfbGFzdCB0ID1cbiAgbWF0Y2ggcmV2IHQgd2l0aFxuICB8IFtdIC0+IE5vbmVcbiAgfCBfIDo6IGxzdCAtPiBTb21lIChyZXYgbHN0KVxuOztcblxubGV0IGRyb3BfbGFzdF9leG4gdCA9XG4gIG1hdGNoIGRyb3BfbGFzdCB0IHdpdGhcbiAgfCBOb25lIC0+IGZhaWx3aXRoIFwiTGlzdC5kcm9wX2xhc3RfZXhuOiBlbXB0eSBsaXN0XCJcbiAgfCBTb21lIGxzdCAtPiBsc3Rcbjs7XG5cbmxldCBjYXJ0ZXNpYW5fcHJvZHVjdCBsaXN0MSBsaXN0MiA9XG4gIGlmIGlzX2VtcHR5IGxpc3QyXG4gIHRoZW4gW11cbiAgZWxzZSAoXG4gICAgbGV0IHJlYyBsb29wIGwxIGwyIGFjY3VtID1cbiAgICAgIG1hdGNoIGwxIHdpdGhcbiAgICAgIHwgW10gLT4gYWNjdW1cbiAgICAgIHwgaGQgOjogdGwgLT4gbG9vcCB0bCBsMiAocmV2X2FwcGVuZCAobWFwIH5mOihmdW4geCAtPiBoZCwgeCkgbDIpIGFjY3VtKVxuICAgIGluXG4gICAgcmV2IChsb29wIGxpc3QxIGxpc3QyIFtdKSlcbjs7XG5cbmxldCBjb25jYXQgbCA9IGZvbGRfcmlnaHQgbCB+aW5pdDpbXSB+ZjphcHBlbmRcbmxldCBjb25jYXRfbm9fb3JkZXIgbCA9IGZvbGQgbCB+aW5pdDpbXSB+ZjooZnVuIGFjYyBsIC0+IHJldl9hcHBlbmQgbCBhY2MpXG5sZXQgY29ucyB4IGwgPSB4IDo6IGxcblxubGV0IGlzX3NvcnRlZCBsIH5jb21wYXJlID1cbiAgbGV0IHJlYyBsb29wIGwgPVxuICAgIG1hdGNoIGwgd2l0aFxuICAgIHwgW10gfCBbIF8gXSAtPiB0cnVlXG4gICAgfCB4MSA6OiAoeDIgOjogXyBhcyByZXN0KSAtPiBjb21wYXJlIHgxIHgyIDw9IDAgJiYgbG9vcCByZXN0XG4gIGluXG4gIGxvb3AgbFxuOztcblxubGV0IGlzX3NvcnRlZF9zdHJpY3RseSBsIH5jb21wYXJlID1cbiAgbGV0IHJlYyBsb29wIGwgPVxuICAgIG1hdGNoIGwgd2l0aFxuICAgIHwgW10gfCBbIF8gXSAtPiB0cnVlXG4gICAgfCB4MSA6OiAoeDIgOjogXyBhcyByZXN0KSAtPiBjb21wYXJlIHgxIHgyIDwgMCAmJiBsb29wIHJlc3RcbiAgaW5cbiAgbG9vcCBsXG47O1xuXG5tb2R1bGUgSW5maXggPSBzdHJ1Y3RcbiAgbGV0ICggQCApID0gYXBwZW5kXG5lbmRcblxubGV0IHBlcm11dGUgPyhyYW5kb21fc3RhdGUgPSBSYW5kb20uU3RhdGUuZGVmYXVsdCkgbGlzdCA9XG4gIG1hdGNoIGxpc3Qgd2l0aFxuICAoKiBzcGVjaWFsIGNhc2VzIHRvIHNwZWVkIHRoaW5ncyB1cCBpbiB0cml2aWFsIGNhc2VzICopXG4gIHwgW10gfCBbIF8gXSAtPiBsaXN0XG4gIHwgWyB4OyB5IF0gLT4gaWYgUmFuZG9tLlN0YXRlLmJvb2wgcmFuZG9tX3N0YXRlIHRoZW4gWyB5OyB4IF0gZWxzZSBsaXN0XG4gIHwgXyAtPlxuICAgIGxldCBhcnIgPSBBcnJheS5vZl9saXN0IGxpc3QgaW5cbiAgICBBcnJheV9wZXJtdXRlLnBlcm11dGUgYXJyIH5yYW5kb21fc3RhdGU7XG4gICAgQXJyYXkudG9fbGlzdCBhcnJcbjs7XG5cbmxldCByYW5kb21fZWxlbWVudF9leG4gPyhyYW5kb21fc3RhdGUgPSBSYW5kb20uU3RhdGUuZGVmYXVsdCkgbGlzdCA9XG4gIGlmIGlzX2VtcHR5IGxpc3RcbiAgdGhlbiBmYWlsd2l0aCBcIkxpc3QucmFuZG9tX2VsZW1lbnRfZXhuOiBlbXB0eSBsaXN0XCJcbiAgZWxzZSBudGhfZXhuIGxpc3QgKFJhbmRvbS5TdGF0ZS5pbnQgcmFuZG9tX3N0YXRlIChsZW5ndGggbGlzdCkpXG47O1xuXG5sZXQgcmFuZG9tX2VsZW1lbnQgPyhyYW5kb21fc3RhdGUgPSBSYW5kb20uU3RhdGUuZGVmYXVsdCkgbGlzdCA9XG4gIHRyeSBTb21lIChyYW5kb21fZWxlbWVudF9leG4gfnJhbmRvbV9zdGF0ZSBsaXN0KSB3aXRoXG4gIHwgXyAtPiBOb25lXG47O1xuXG5sZXQgcmVjIGNvbXBhcmUgY21wIGEgYiA9XG4gIG1hdGNoIGEsIGIgd2l0aFxuICB8IFtdLCBbXSAtPiAwXG4gIHwgW10sIF8gLT4gLTFcbiAgfCBfLCBbXSAtPiAxXG4gIHwgeCA6OiB4cywgeSA6OiB5cyAtPlxuICAgIGxldCBuID0gY21wIHggeSBpblxuICAgIGlmIG4gPSAwIHRoZW4gY29tcGFyZSBjbXAgeHMgeXMgZWxzZSBuXG47O1xuXG5sZXQgaGFzaF9mb2xkX3QgPSBoYXNoX2ZvbGRfbGlzdFxuXG5sZXQgZXF1YWwgZXF1YWwgdDEgdDIgPVxuICBsZXQgcmVjIGxvb3AgfmVxdWFsIHQxIHQyID1cbiAgICBtYXRjaCB0MSwgdDIgd2l0aFxuICAgIHwgW10sIFtdIC0+IHRydWVcbiAgICB8IHgxIDo6IHQxLCB4MiA6OiB0MiAtPiBlcXVhbCB4MSB4MiAmJiBsb29wIH5lcXVhbCB0MSB0MlxuICAgIHwgXyAtPiBmYWxzZVxuICBpblxuICBsb29wIH5lcXVhbCB0MSB0MlxuOztcblxubGV0IHRyYW5zcG9zZSA9XG4gIGxldCByZWMgc3BsaXRfb2ZmX2ZpcnN0X2NvbHVtbiB0IGNvbHVtbl9hY2MgdHJpbW1lZCBmb3VuZF9lbXB0eSA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBbXSAtPiBjb2x1bW5fYWNjLCB0cmltbWVkLCBmb3VuZF9lbXB0eVxuICAgIHwgW10gOjogdGwgLT4gc3BsaXRfb2ZmX2ZpcnN0X2NvbHVtbiB0bCBjb2x1bW5fYWNjIHRyaW1tZWQgdHJ1ZVxuICAgIHwgKHggOjogeHMpIDo6IHRsIC0+XG4gICAgICBzcGxpdF9vZmZfZmlyc3RfY29sdW1uIHRsICh4IDo6IGNvbHVtbl9hY2MpICh4cyA6OiB0cmltbWVkKSBmb3VuZF9lbXB0eVxuICBpblxuICBsZXQgc3BsaXRfb2ZmX2ZpcnN0X2NvbHVtbiByb3dzID0gc3BsaXRfb2ZmX2ZpcnN0X2NvbHVtbiByb3dzIFtdIFtdIGZhbHNlIGluXG4gIGxldCByZWMgbG9vcCByb3dzIGNvbHVtbnMgZG9fcmV2ID1cbiAgICBtYXRjaCBzcGxpdF9vZmZfZmlyc3RfY29sdW1uIHJvd3Mgd2l0aFxuICAgIHwgW10sIFtdLCBfIC0+IFNvbWUgKHJldiBjb2x1bW5zKVxuICAgIHwgY29sdW1uLCB0cmltbWVkX3Jvd3MsIGZvdW5kX2VtcHR5IC0+XG4gICAgICBpZiBmb3VuZF9lbXB0eVxuICAgICAgdGhlbiBOb25lXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IGNvbHVtbiA9IGlmIGRvX3JldiB0aGVuIHJldiBjb2x1bW4gZWxzZSBjb2x1bW4gaW5cbiAgICAgICAgbG9vcCB0cmltbWVkX3Jvd3MgKGNvbHVtbiA6OiBjb2x1bW5zKSAobm90IGRvX3JldikpXG4gIGluXG4gIGZ1biB0IC0+IGxvb3AgdCBbXSB0cnVlXG47O1xuXG5leGNlcHRpb24gVHJhbnNwb3NlX2dvdF9saXN0c19vZl9kaWZmZXJlbnRfbGVuZ3RocyBvZiBpbnQgbGlzdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF1cblxubGV0ICgpID1cbiAgU2V4cGxpYjAuU2V4cF9jb252LkV4bl9jb252ZXJ0ZXIuYWRkXG4gICAgWyVleHRlbnNpb25fY29uc3RydWN0b3IgVHJhbnNwb3NlX2dvdF9saXN0c19vZl9kaWZmZXJlbnRfbGVuZ3Roc11cbiAgICAoZnVuY3Rpb25cbiAgICAgIHwgVHJhbnNwb3NlX2dvdF9saXN0c19vZl9kaWZmZXJlbnRfbGVuZ3RocyBhcmcwX18wMzFfIC0+XG4gICAgICAgIGxldCByZXMwX18wMzJfID0gc2V4cF9vZl9saXN0IHNleHBfb2ZfaW50IGFyZzBfXzAzMV8gaW5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0XG4gICAgICAgICAgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJsaXN0Lm1sLlRyYW5zcG9zZV9nb3RfbGlzdHNfb2ZfZGlmZmVyZW50X2xlbmd0aHNcIlxuICAgICAgICAgIDsgcmVzMF9fMDMyX1xuICAgICAgICAgIF1cbiAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UpXG47O1xuXG5bQEBAZW5kXVxuXG5sZXQgdHJhbnNwb3NlX2V4biBsID1cbiAgbWF0Y2ggdHJhbnNwb3NlIGwgd2l0aFxuICB8IFNvbWUgbCAtPiBsXG4gIHwgTm9uZSAtPiByYWlzZSAoVHJhbnNwb3NlX2dvdF9saXN0c19vZl9kaWZmZXJlbnRfbGVuZ3RocyAobWFwIGwgfmY6bGVuZ3RoKSlcbjs7XG5cbmxldCBpbnRlcnNwZXJzZSB0IH5zZXAgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBbXSAtPiBbXVxuICB8IHggOjogeHMgLT4geCA6OiBmb2xkX3JpZ2h0IHhzIH5pbml0OltdIH5mOihmdW4geSBhY2MgLT4gc2VwIDo6IHkgOjogYWNjKVxuOztcblxubGV0IGZvbGRfcmVzdWx0IHQgfmluaXQgfmYgPSBDb250YWluZXIuZm9sZF9yZXN1bHQgfmZvbGQgfmluaXQgfmYgdFxubGV0IGZvbGRfdW50aWwgdCB+aW5pdCB+ZiA9IENvbnRhaW5lci5mb2xkX3VudGlsIH5mb2xkIH5pbml0IH5mIHRcblxubGV0IGlzX3N1ZmZpeCBsaXN0IH5zdWZmaXggfmVxdWFsOmVxdWFsX2VsdCA9XG4gIGxldCBsaXN0X2xlbiA9IGxlbmd0aCBsaXN0IGluXG4gIGxldCBzdWZmaXhfbGVuID0gbGVuZ3RoIHN1ZmZpeCBpblxuICBsaXN0X2xlbiA+PSBzdWZmaXhfbGVuICYmIGVxdWFsIGVxdWFsX2VsdCAoZHJvcCBsaXN0IChsaXN0X2xlbiAtIHN1ZmZpeF9sZW4pKSBzdWZmaXhcbjs7XG4iLCIoKiBUaGlzIG1vZHVsZSBpcyB0cnlpbmcgdG8gbWluaW1pemUgZGVwZW5kZW5jaWVzIG9uIG1vZHVsZXMgaW4gQ29yZSwgc28gYXMgdG8gYWxsb3dcbiAgIFtJbmZvXSwgW0Vycm9yXSwgYW5kIFtPcl9lcnJvcl0gdG8gYmUgdXNlZCBpbiBhcyBtYW55IHBsYWNlcyBhcyBwb3NzaWJsZS4gUGxlYXNlIGF2b2lkXG4gICBhZGRpbmcgbmV3IGRlcGVuZGVuY2llcy4gKilcblxub3BlbiEgSW1wb3J0XG5pbmNsdWRlIEluZm9faW50ZlxubW9kdWxlIFN0cmluZyA9IFN0cmluZzBcblxubW9kdWxlIE1lc3NhZ2UgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB8IENvdWxkX25vdF9jb25zdHJ1Y3Qgb2YgU2V4cC50XG4gICAgfCBTdHJpbmcgb2Ygc3RyaW5nXG4gICAgfCBFeG4gb2YgZXhuXG4gICAgfCBTZXhwIG9mIFNleHAudFxuICAgIHwgVGFnX3NleHAgb2Ygc3RyaW5nICogU2V4cC50ICogU291cmNlX2NvZGVfcG9zaXRpb24wLnQgb3B0aW9uXG4gICAgfCBUYWdfdCBvZiBzdHJpbmcgKiB0XG4gICAgfCBUYWdfYXJnIG9mIHN0cmluZyAqIFNleHAudCAqIHRcbiAgICB8IE9mX2xpc3Qgb2YgaW50IG9wdGlvbiAqIHQgbGlzdFxuICAgIHwgV2l0aF9iYWNrdHJhY2Ugb2YgdCAqIHN0cmluZyAoKiBiYWNrdHJhY2UgKilcbiAgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgbGV0IHJlYyBzZXhwX29mX3QgPVxuICAgIChmdW5jdGlvblxuICAgICAgfCBDb3VsZF9ub3RfY29uc3RydWN0IGFyZzBfXzAwMV8gLT5cbiAgICAgICAgbGV0IHJlczBfXzAwMl8gPSBTZXhwLnNleHBfb2ZfdCBhcmcwX18wMDFfIGluXG4gICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIkNvdWxkX25vdF9jb25zdHJ1Y3RcIjsgcmVzMF9fMDAyXyBdXG4gICAgICB8IFN0cmluZyBhcmcwX18wMDNfIC0+XG4gICAgICAgIGxldCByZXMwX18wMDRfID0gc2V4cF9vZl9zdHJpbmcgYXJnMF9fMDAzXyBpblxuICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJTdHJpbmdcIjsgcmVzMF9fMDA0XyBdXG4gICAgICB8IEV4biBhcmcwX18wMDVfIC0+XG4gICAgICAgIGxldCByZXMwX18wMDZfID0gc2V4cF9vZl9leG4gYXJnMF9fMDA1XyBpblxuICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJFeG5cIjsgcmVzMF9fMDA2XyBdXG4gICAgICB8IFNleHAgYXJnMF9fMDA3XyAtPlxuICAgICAgICBsZXQgcmVzMF9fMDA4XyA9IFNleHAuc2V4cF9vZl90IGFyZzBfXzAwN18gaW5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiU2V4cFwiOyByZXMwX18wMDhfIF1cbiAgICAgIHwgVGFnX3NleHAgKGFyZzBfXzAwOV8sIGFyZzFfXzAxMF8sIGFyZzJfXzAxMV8pIC0+XG4gICAgICAgIGxldCByZXMwX18wMTJfID0gc2V4cF9vZl9zdHJpbmcgYXJnMF9fMDA5X1xuICAgICAgICBhbmQgcmVzMV9fMDEzXyA9IFNleHAuc2V4cF9vZl90IGFyZzFfXzAxMF9cbiAgICAgICAgYW5kIHJlczJfXzAxNF8gPSBzZXhwX29mX29wdGlvbiBTb3VyY2VfY29kZV9wb3NpdGlvbjAuc2V4cF9vZl90IGFyZzJfXzAxMV8gaW5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0XG4gICAgICAgICAgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJUYWdfc2V4cFwiOyByZXMwX18wMTJfOyByZXMxX18wMTNfOyByZXMyX18wMTRfIF1cbiAgICAgIHwgVGFnX3QgKGFyZzBfXzAxNV8sIGFyZzFfXzAxNl8pIC0+XG4gICAgICAgIGxldCByZXMwX18wMTdfID0gc2V4cF9vZl9zdHJpbmcgYXJnMF9fMDE1X1xuICAgICAgICBhbmQgcmVzMV9fMDE4XyA9IHNleHBfb2ZfdCBhcmcxX18wMTZfIGluXG4gICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIlRhZ190XCI7IHJlczBfXzAxN187IHJlczFfXzAxOF8gXVxuICAgICAgfCBUYWdfYXJnIChhcmcwX18wMTlfLCBhcmcxX18wMjBfLCBhcmcyX18wMjFfKSAtPlxuICAgICAgICBsZXQgcmVzMF9fMDIyXyA9IHNleHBfb2Zfc3RyaW5nIGFyZzBfXzAxOV9cbiAgICAgICAgYW5kIHJlczFfXzAyM18gPSBTZXhwLnNleHBfb2ZfdCBhcmcxX18wMjBfXG4gICAgICAgIGFuZCByZXMyX18wMjRfID0gc2V4cF9vZl90IGFyZzJfXzAyMV8gaW5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0XG4gICAgICAgICAgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJUYWdfYXJnXCI7IHJlczBfXzAyMl87IHJlczFfXzAyM187IHJlczJfXzAyNF8gXVxuICAgICAgfCBPZl9saXN0IChhcmcwX18wMjVfLCBhcmcxX18wMjZfKSAtPlxuICAgICAgICBsZXQgcmVzMF9fMDI3XyA9IHNleHBfb2Zfb3B0aW9uIHNleHBfb2ZfaW50IGFyZzBfXzAyNV9cbiAgICAgICAgYW5kIHJlczFfXzAyOF8gPSBzZXhwX29mX2xpc3Qgc2V4cF9vZl90IGFyZzFfXzAyNl8gaW5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiT2ZfbGlzdFwiOyByZXMwX18wMjdfOyByZXMxX18wMjhfIF1cbiAgICAgIHwgV2l0aF9iYWNrdHJhY2UgKGFyZzBfXzAyOV8sIGFyZzFfXzAzMF8pIC0+XG4gICAgICAgIGxldCByZXMwX18wMzFfID0gc2V4cF9vZl90IGFyZzBfXzAyOV9cbiAgICAgICAgYW5kIHJlczFfXzAzMl8gPSBzZXhwX29mX3N0cmluZyBhcmcxX18wMzBfIGluXG4gICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIldpdGhfYmFja3RyYWNlXCI7IHJlczBfXzAzMV87IHJlczFfXzAzMl8gXVxuICAgICAgICA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICA7O1xuXG4gIFtAQEBlbmRdXG5cbiAgbGV0IHJlYyB0b19zdHJpbmdzX2h1bSB0IGFjID1cbiAgICAoKiBXZSB1c2UgW1NleHAudG9fc3RyaW5nX21hY2hdLCBkZXNwaXRlIHRoZSBmYWN0IHRoYXQgd2UgYXJlIGltcGxlbWVudGluZ1xuICAgICAgIFt0b19zdHJpbmdzX2h1bV0sIGJlY2F1c2Ugd2Ugd2FudCB0aGUgaW5mbyB0byBmaXQgb24gYSBzaW5nbGUgbGluZSwgYW5kIG9uY2Ugd2UndmVcbiAgICAgICBoYWQgdG8gcmVzb3J0IHRvIHNleHBzLCB0aGUgbWVzc2FnZSBpcyBnb2luZyB0byBzdGFydCBub3QgbG9va2luZyBzbyBwcmV0dHlcbiAgICAgICBhbnl3YXkuICopXG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBDb3VsZF9ub3RfY29uc3RydWN0IHNleHAgLT5cbiAgICAgIFwiY291bGQgbm90IGNvbnN0cnVjdCBpbmZvOiBcIiA6OiBTZXhwLnRvX3N0cmluZ19tYWNoIHNleHAgOjogYWNcbiAgICB8IFN0cmluZyBzdHJpbmcgLT4gc3RyaW5nIDo6IGFjXG4gICAgfCBFeG4gZXhuIC0+IFNleHAudG9fc3RyaW5nX21hY2ggKEV4bi5zZXhwX29mX3QgZXhuKSA6OiBhY1xuICAgIHwgU2V4cCBzZXhwIC0+IFNleHAudG9fc3RyaW5nX21hY2ggc2V4cCA6OiBhY1xuICAgIHwgVGFnX3NleHAgKHRhZywgc2V4cCwgXykgLT4gdGFnIDo6IFwiOiBcIiA6OiBTZXhwLnRvX3N0cmluZ19tYWNoIHNleHAgOjogYWNcbiAgICB8IFRhZ190ICh0YWcsIHQpIC0+IHRhZyA6OiBcIjogXCIgOjogdG9fc3RyaW5nc19odW0gdCBhY1xuICAgIHwgVGFnX2FyZyAodGFnLCBzZXhwLCB0KSAtPlxuICAgICAgbGV0IGJvZHkgPSBTZXhwLnRvX3N0cmluZ19tYWNoIHNleHAgOjogXCI6IFwiIDo6IHRvX3N0cmluZ3NfaHVtIHQgYWMgaW5cbiAgICAgIGlmIFN0cmluZy5sZW5ndGggdGFnID0gMCB0aGVuIGJvZHkgZWxzZSB0YWcgOjogXCI6IFwiIDo6IGJvZHlcbiAgICB8IFdpdGhfYmFja3RyYWNlICh0LCBiYWNrdHJhY2UpIC0+XG4gICAgICB0b19zdHJpbmdzX2h1bSB0IChcIlxcbkJhY2t0cmFjZTpcXG5cIiA6OiBiYWNrdHJhY2UgOjogYWMpXG4gICAgfCBPZl9saXN0ICh0cnVuY19hZnRlciwgdHMpIC0+XG4gICAgICBsZXQgdHMgPVxuICAgICAgICBtYXRjaCB0cnVuY19hZnRlciB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiB0c1xuICAgICAgICB8IFNvbWUgbWF4IC0+XG4gICAgICAgICAgbGV0IG4gPSBMaXN0Lmxlbmd0aCB0cyBpblxuICAgICAgICAgIGlmIG4gPD0gbWF4XG4gICAgICAgICAgdGhlbiB0c1xuICAgICAgICAgIGVsc2UgTGlzdC50YWtlIHRzIG1heCBAIFsgU3RyaW5nIChQcmludGYuc3ByaW50ZiBcImFuZCAlZCBtb3JlIGluZm9cIiAobiAtIG1heCkpIF1cbiAgICAgIGluXG4gICAgICBMaXN0LmZvbGQgKExpc3QucmV2IHRzKSB+aW5pdDphYyB+ZjooZnVuIGFjIHQgLT5cbiAgICAgICAgdG9fc3RyaW5nc19odW0gdCAoaWYgTGlzdC5pc19lbXB0eSBhYyB0aGVuIGFjIGVsc2UgXCI7IFwiIDo6IGFjKSlcbiAgOztcblxuICBsZXQgdG9fc3RyaW5nX2h1bV9kZXByZWNhdGVkIHQgPSBTdHJpbmcuY29uY2F0ICh0b19zdHJpbmdzX2h1bSB0IFtdKVxuXG4gIGxldCByZWMgdG9fc2V4cHNfaHVtIHQgYWMgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgQ291bGRfbm90X2NvbnN0cnVjdCBfIGFzIHQgLT4gc2V4cF9vZl90IHQgOjogYWNcbiAgICB8IFN0cmluZyBzdHJpbmcgLT4gQXRvbSBzdHJpbmcgOjogYWNcbiAgICB8IEV4biBleG4gLT4gRXhuLnNleHBfb2ZfdCBleG4gOjogYWNcbiAgICB8IFNleHAgc2V4cCAtPiBzZXhwIDo6IGFjXG4gICAgfCBUYWdfc2V4cCAodGFnLCBzZXhwLCBoZXJlKSAtPlxuICAgICAgTGlzdFxuICAgICAgICAoQXRvbSB0YWdcbiAgICAgICAgIDo6IHNleHBcbiAgICAgICAgIDo6XG4gICAgICAgICAobWF0Y2ggaGVyZSB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IFtdXG4gICAgICAgICAgfCBTb21lIGhlcmUgLT4gWyBTb3VyY2VfY29kZV9wb3NpdGlvbjAuc2V4cF9vZl90IGhlcmUgXSkpXG4gICAgICA6OiBhY1xuICAgIHwgVGFnX3QgKHRhZywgdCkgLT4gTGlzdCAoQXRvbSB0YWcgOjogdG9fc2V4cHNfaHVtIHQgW10pIDo6IGFjXG4gICAgfCBUYWdfYXJnICh0YWcsIHNleHAsIHQpIC0+XG4gICAgICBsZXQgYm9keSA9IHNleHAgOjogdG9fc2V4cHNfaHVtIHQgW10gaW5cbiAgICAgIGlmIFN0cmluZy5sZW5ndGggdGFnID0gMCB0aGVuIExpc3QgYm9keSA6OiBhYyBlbHNlIExpc3QgKEF0b20gdGFnIDo6IGJvZHkpIDo6IGFjXG4gICAgfCBXaXRoX2JhY2t0cmFjZSAodCwgYmFja3RyYWNlKSAtPlxuICAgICAgU2V4cC5MaXN0IFsgdG9fc2V4cF9odW0gdDsgU2V4cC5BdG9tIGJhY2t0cmFjZSBdIDo6IGFjXG4gICAgfCBPZl9saXN0IChfLCB0cykgLT5cbiAgICAgIExpc3QuZm9sZCAoTGlzdC5yZXYgdHMpIH5pbml0OmFjIH5mOihmdW4gYWMgdCAtPiB0b19zZXhwc19odW0gdCBhYylcblxuICBhbmQgdG9fc2V4cF9odW0gdCA9XG4gICAgbWF0Y2ggdG9fc2V4cHNfaHVtIHQgW10gd2l0aFxuICAgIHwgWyBzZXhwIF0gLT4gc2V4cFxuICAgIHwgc2V4cHMgLT4gU2V4cC5MaXN0IHNleHBzXG4gIDs7XG5cbiAgKCogV2UgdXNlIFtwcm90ZWN0XSB0byBndWFyZCBhZ2FpbnN0IGV4Y2VwdGlvbnMgcmFpc2VkIGJ5IHVzZXItc3VwcGxpZWQgZnVuY3Rpb25zLCBzb1xuICAgICB0aGF0IGZhaWx1cmUgdG8gcHJvZHVjZSBvbmUgcGFydCBvZiBhbiBpbmZvIGRvZXNuJ3QgaW50ZXJmZXJlIHdpdGggb3RoZXIgcGFydHMuICopXG4gIGxldCBwcm90ZWN0IGYgPVxuICAgIHRyeSBmICgpIHdpdGhcbiAgICB8IGV4biAtPiBDb3VsZF9ub3RfY29uc3RydWN0IChFeG4uc2V4cF9vZl90IGV4bilcbiAgOztcblxuICBsZXQgb2ZfaW5mbyBpbmZvID0gcHJvdGVjdCAoZnVuICgpIC0+IExhenkuZm9yY2UgaW5mbylcbiAgbGV0IHRvX2luZm8gdCA9IGxhenkgdFxuZW5kXG5cbm9wZW4gTWVzc2FnZVxuXG50eXBlIHQgPSBNZXNzYWdlLnQgTGF6eS50XG5cbmxldCBpbnZhcmlhbnQgXyA9ICgpXG5sZXQgdG9fbWVzc2FnZSA9IE1lc3NhZ2Uub2ZfaW5mb1xubGV0IG9mX21lc3NhZ2UgPSBNZXNzYWdlLnRvX2luZm9cblxuKCogSXQgaXMgT0sgdG8gdXNlIFtNZXNzYWdlLnRvX3NleHBfaHVtXSwgd2hpY2ggaXMgbm90IHN0YWJsZSwgYmVjYXVzZSBbdF9vZl9zZXhwXSBiZWxvd1xuICAgY2FuIGhhbmRsZSBhbnkgc2V4cC4gKilcbmxldCBzZXhwX29mX3QgdCA9IE1lc3NhZ2UudG9fc2V4cF9odW0gKHRvX21lc3NhZ2UgdClcbmxldCB0X29mX3NleHAgc2V4cCA9IGxhenkgKE1lc3NhZ2UuU2V4cCBzZXhwKVxubGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0geyB1bnR5cGVkID0gQW55IFwiSW5mby50XCIgfVxubGV0IGNvbXBhcmUgdDEgdDIgPSBTZXhwLmNvbXBhcmUgKHNleHBfb2ZfdCB0MSkgKHNleHBfb2ZfdCB0MilcbmxldCBlcXVhbCB0MSB0MiA9IFNleHAuZXF1YWwgKHNleHBfb2ZfdCB0MSkgKHNleHBfb2ZfdCB0MilcbmxldCBoYXNoX2ZvbGRfdCBzdGF0ZSB0ID0gU2V4cC5oYXNoX2ZvbGRfdCBzdGF0ZSAoc2V4cF9vZl90IHQpXG5sZXQgaGFzaCB0ID0gSGFzaC5ydW4gaGFzaF9mb2xkX3QgdFxuXG5sZXQgdG9fc3RyaW5nX2h1bSB0ID1cbiAgbWF0Y2ggdG9fbWVzc2FnZSB0IHdpdGhcbiAgfCBTdHJpbmcgcyAtPiBzXG4gIHwgbWVzc2FnZSAtPiBTZXhwLnRvX3N0cmluZ19odW0gKE1lc3NhZ2UudG9fc2V4cF9odW0gbWVzc2FnZSlcbjs7XG5cbmxldCB0b19zdHJpbmdfaHVtX2RlcHJlY2F0ZWQgdCA9IE1lc3NhZ2UudG9fc3RyaW5nX2h1bV9kZXByZWNhdGVkICh0b19tZXNzYWdlIHQpXG5sZXQgdG9fc3RyaW5nX21hY2ggdCA9IFNleHAudG9fc3RyaW5nX21hY2ggKHNleHBfb2ZfdCB0KVxubGV0IG9mX2xhenkgbCA9IGxhenkgKHByb3RlY3QgKGZ1biAoKSAtPiBTdHJpbmcgKExhenkuZm9yY2UgbCkpKVxubGV0IG9mX2xhenlfc2V4cCBsID0gbGF6eSAocHJvdGVjdCAoZnVuICgpIC0+IFNleHAgKExhenkuZm9yY2UgbCkpKVxubGV0IG9mX2xhenlfdCBsYXp5X3QgPSBMYXp5LmpvaW4gbGF6eV90XG5sZXQgb2Zfc3RyaW5nIG1lc3NhZ2UgPSBMYXp5LmZyb21fdmFsIChTdHJpbmcgbWVzc2FnZSlcbmxldCBjcmVhdGVmIGZvcm1hdCA9IFByaW50Zi5rc3ByaW50ZiBvZl9zdHJpbmcgZm9ybWF0XG5sZXQgb2ZfdGh1bmsgZiA9IGxhenkgKHByb3RlY3QgKGZ1biAoKSAtPiBTdHJpbmcgKGYgKCkpKSlcblxubGV0IGNyZWF0ZSA/aGVyZSA/c3RyaWN0IHRhZyB4IHNleHBfb2ZfeCA9XG4gIG1hdGNoIHN0cmljdCB3aXRoXG4gIHwgTm9uZSAtPiBsYXp5IChwcm90ZWN0IChmdW4gKCkgLT4gVGFnX3NleHAgKHRhZywgc2V4cF9vZl94IHgsIGhlcmUpKSlcbiAgfCBTb21lICgpIC0+IG9mX21lc3NhZ2UgKFRhZ19zZXhwICh0YWcsIHNleHBfb2ZfeCB4LCBoZXJlKSlcbjs7XG5cbmxldCBjcmVhdGVfcyBzZXhwID0gTGF6eS5mcm9tX3ZhbCAoU2V4cCBzZXhwKVxubGV0IHRhZyB0IH50YWcgPSBsYXp5IChUYWdfdCAodGFnLCB0b19tZXNzYWdlIHQpKVxuXG5sZXQgdGFnX3NfbGF6eSB0IH50YWcgPVxuICBsYXp5IChwcm90ZWN0IChmdW4gKCkgLT4gVGFnX2FyZyAoXCJcIiwgTGF6eS5mb3JjZSB0YWcsIHRvX21lc3NhZ2UgdCkpKVxuOztcblxubGV0IHRhZ19zIHQgfnRhZyA9IHRhZ19zX2xhenkgdCB+dGFnOihMYXp5LmZyb21fdmFsIHRhZylcblxubGV0IHRhZ19hcmcgdCB0YWcgeCBzZXhwX29mX3ggPVxuICBsYXp5IChwcm90ZWN0IChmdW4gKCkgLT4gVGFnX2FyZyAodGFnLCBzZXhwX29mX3ggeCwgdG9fbWVzc2FnZSB0KSkpXG47O1xuXG5sZXQgb2ZfbGlzdCA/dHJ1bmNfYWZ0ZXIgdHMgPSBsYXp5IChPZl9saXN0ICh0cnVuY19hZnRlciwgTGlzdC5tYXAgdHMgfmY6dG9fbWVzc2FnZSkpXG5cbmV4Y2VwdGlvbiBFeG4gb2YgdFxuXG5sZXQgKCkgPVxuICAoKiBXZSBpbnN0YWxsIGEgY3VzdG9tIGV4bi1jb252ZXJ0ZXIgcmF0aGVyIHRoYW4gdXNlXG4gICAgIFtleGNlcHRpb24gRXhuIG9mIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBdIC4uLiBbQEBAZW5kXV0gdG8gZWxpbWluYXRlIHRoZSBleHRyYVxuICAgICB3cmFwcGluZyBvZiBcIihFeG4gLi4uKVwiLiAqKVxuICBTZXhwbGliMC5TZXhwX2NvbnYuRXhuX2NvbnZlcnRlci5hZGQgWyVleHRlbnNpb25fY29uc3RydWN0b3IgRXhuXSAoZnVuY3Rpb25cbiAgICB8IEV4biB0IC0+IHNleHBfb2ZfdCB0XG4gICAgfCBfIC0+XG4gICAgICAoKiBSZWFjaGluZyB0aGlzIGJyYW5jaCBpbmRpY2F0ZXMgYSBidWcgaW4gc2V4cGxpYi4gKilcbiAgICAgIGFzc2VydCBmYWxzZSlcbjs7XG5cbmxldCB0b19leG4gdCA9XG4gIGlmIG5vdCAoTGF6eS5pc192YWwgdClcbiAgdGhlbiBFeG4gdFxuICBlbHNlIChcbiAgICBtYXRjaCBMYXp5LmZvcmNlIHQgd2l0aFxuICAgIHwgTWVzc2FnZS5FeG4gZXhuIC0+IGV4blxuICAgIHwgXyAtPiBFeG4gdClcbjs7XG5cbmxldCBvZl9leG4gP2JhY2t0cmFjZSBleG4gPVxuICBsZXQgYmFja3RyYWNlID1cbiAgICBtYXRjaCBiYWNrdHJhY2Ugd2l0aFxuICAgIHwgTm9uZSAtPiBOb25lXG4gICAgfCBTb21lIGBHZXQgLT4gU29tZSAoQ2FtbC5QcmludGV4Yy5nZXRfYmFja3RyYWNlICgpKVxuICAgIHwgU29tZSAoYFRoaXMgcykgLT4gU29tZSBzXG4gIGluXG4gIG1hdGNoIGV4biwgYmFja3RyYWNlIHdpdGhcbiAgfCBFeG4gdCwgTm9uZSAtPiB0XG4gIHwgRXhuIHQsIFNvbWUgYmFja3RyYWNlIC0+IGxhenkgKFdpdGhfYmFja3RyYWNlICh0b19tZXNzYWdlIHQsIGJhY2t0cmFjZSkpXG4gIHwgXywgTm9uZSAtPiBMYXp5LmZyb21fdmFsIChNZXNzYWdlLkV4biBleG4pXG4gIHwgXywgU29tZSBiYWNrdHJhY2UgLT4gbGF6eSAoV2l0aF9iYWNrdHJhY2UgKFNleHAgKEV4bi5zZXhwX29mX3QgZXhuKSwgYmFja3RyYWNlKSlcbjs7XG5cbmluY2x1ZGUgUHJldHR5X3ByaW50ZXIuUmVnaXN0ZXJfcHAgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuSW5mb1wiXG4gICAgbGV0IHBwIHBwZiB0ID0gQ2FtbC5Gb3JtYXQucHBfcHJpbnRfc3RyaW5nIHBwZiAodG9fc3RyaW5nX2h1bSB0KVxuICBlbmQpXG5cbm1vZHVsZSBJbnRlcm5hbF9yZXByID0gTWVzc2FnZVxuXG4iLCIoKiBUaGlzIG1vZHVsZSBpcyB0cnlpbmcgdG8gbWluaW1pemUgZGVwZW5kZW5jaWVzIG9uIG1vZHVsZXMgaW4gQ29yZSwgc28gYXMgdG8gYWxsb3dcbiAgIFtFcnJvcl0gYW5kIFtPcl9lcnJvcl0gdG8gYmUgdXNlZCBpbiB2YXJpb3VzIHBsYWNlcy4gIFBsZWFzZSBhdm9pZCBhZGRpbmcgbmV3XG4gICBkZXBlbmRlbmNpZXMuICopXG5cbm9wZW4hIEltcG9ydFxuaW5jbHVkZSBJbmZvXG5cbmxldCB0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgPSB7IHVudHlwZWQgPSBBbnkgXCJFcnJvci50XCIgfVxubGV0IHJhaXNlIHQgPSByYWlzZSAodG9fZXhuIHQpXG5sZXQgcmFpc2VfcyBzZXhwID0gcmFpc2UgKGNyZWF0ZV9zIHNleHApXG5sZXQgdG9faW5mbyB0ID0gdFxubGV0IG9mX2luZm8gdCA9IHRcblxuaW5jbHVkZSBQcmV0dHlfcHJpbnRlci5SZWdpc3Rlcl9wcCAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgdCA9IHRcblxuICAgIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5FcnJvclwiXG4gICAgbGV0IHBwID0gcHBcbiAgZW5kKVxuIiwiKCogVGhpcyBpcyBicm9rZW4gb2ZmIHRvIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY3kgYmV0d2VlbiBTaWduIGFuZCBDb21wYXJhYmxlLiAqKVxuXG5vcGVuISBJbXBvcnRcblxudHlwZSB0ID1cbiAgfCBOZWdcbiAgfCBaZXJvXG4gIHwgUG9zXG5bQEBkZXJpdmluZ19pbmxpbmUgc2V4cCwgc2V4cF9ncmFtbWFyLCBjb21wYXJlLCBoYXNoLCBlbnVtZXJhdGVdXG5cbmxldCB0X29mX3NleHAgPVxuICAobGV0IGVycm9yX3NvdXJjZV9fMDAzXyA9IFwic2lnbjAubWwudFwiIGluXG4gICBmdW5jdGlvblxuICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwibmVnXCIgfCBcIk5lZ1wiKSAtPiBOZWdcbiAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcInplcm9cIiB8IFwiWmVyb1wiKSAtPiBaZXJvXG4gICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJwb3NcIiB8IFwiUG9zXCIpIC0+IFBvc1xuICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJuZWdcIiB8IFwiTmVnXCIpIDo6IF8pIGFzIHNleHBfXzAwNF8gLT5cbiAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAwM18gc2V4cF9fMDA0X1xuICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJ6ZXJvXCIgfCBcIlplcm9cIikgOjogXykgYXMgc2V4cF9fMDA0XyAtPlxuICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDAzXyBzZXhwX18wMDRfXG4gICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcInBvc1wiIHwgXCJQb3NcIikgOjogXykgYXMgc2V4cF9fMDA0XyAtPlxuICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDAzXyBzZXhwX18wMDRfXG4gICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5MaXN0IF8gOjogXykgYXMgc2V4cF9fMDAyXyAtPlxuICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IubmVzdGVkX2xpc3RfaW52YWxpZF9zdW0gZXJyb3Jfc291cmNlX18wMDNfIHNleHBfXzAwMl9cbiAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IFtdIGFzIHNleHBfXzAwMl8gLT5cbiAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLmVtcHR5X2xpc3RfaW52YWxpZF9zdW0gZXJyb3Jfc291cmNlX18wMDNfIHNleHBfXzAwMl9cbiAgIHwgc2V4cF9fMDAyXyAtPiBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IudW5leHBlY3RlZF9zdGFnIGVycm9yX3NvdXJjZV9fMDAzXyBzZXhwX18wMDJfXG4gICAgICAgICAgICAgICAgICAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdClcbjs7XG5cbmxldCBzZXhwX29mX3QgPVxuICAoZnVuY3Rpb25cbiAgICB8IE5lZyAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJOZWdcIlxuICAgIHwgWmVybyAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJaZXJvXCJcbiAgICB8IFBvcyAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJQb3NcIlxuICAgICAgICAgICAgIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG47O1xuXG5sZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPVxuICB7IHVudHlwZWQgPVxuICAgICAgVmFyaWFudFxuICAgICAgICB7IGNhc2Vfc2Vuc2l0aXZpdHkgPSBDYXNlX3NlbnNpdGl2ZV9leGNlcHRfZmlyc3RfY2hhcmFjdGVyXG4gICAgICAgIDsgY2xhdXNlcyA9XG4gICAgICAgICAgICBbIE5vX3RhZyB7IG5hbWUgPSBcIk5lZ1wiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgIDsgTm9fdGFnIHsgbmFtZSA9IFwiWmVyb1wiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgIDsgTm9fdGFnIHsgbmFtZSA9IFwiUG9zXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9XG4gIH1cbjs7XG5cbmxldCBjb21wYXJlID0gKFBweF9jb21wYXJlX2xpYi5wb2x5bW9ycGhpY19jb21wYXJlIDogdCAtPiB0IC0+IGludClcblxubGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAoZnVuIGhzdiBhcmcgLT5cbiAgICAgbWF0Y2ggYXJnIHdpdGhcbiAgICAgfCBOZWcgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50IGhzdiAwXG4gICAgIHwgWmVybyAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDFcbiAgICAgfCBQb3MgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50IGhzdiAyXG4gICAgICAgICAgICAgIDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuOztcblxubGV0IChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICBsZXQgZnVuYyBhcmcgPVxuICAgIFBweF9oYXNoX2xpYi5TdGQuSGFzaC5nZXRfaGFzaF92YWx1ZVxuICAgICAgKGxldCBoc3YgPSBQcHhfaGFzaF9saWIuU3RkLkhhc2guY3JlYXRlICgpIGluXG4gICAgICAgaGFzaF9mb2xkX3QgaHN2IGFyZylcbiAgaW5cbiAgZnVuIHggLT4gZnVuYyB4XG47O1xuXG5sZXQgYWxsID0gKFsgTmVnOyBaZXJvOyBQb3MgXSA6IHQgbGlzdClcblxuW0BAQGVuZF1cblxubW9kdWxlIFJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSA9IHN0cnVjdFxuICBsZXQgKCA8ICkgKHggOiB0KSB5ID0gUG9seS4oIDwgKSB4IHlcbiAgbGV0ICggPD0gKSAoeCA6IHQpIHkgPSBQb2x5LiggPD0gKSB4IHlcbiAgbGV0ICggPD4gKSAoeCA6IHQpIHkgPSBQb2x5LiggPD4gKSB4IHlcbiAgbGV0ICggPSApICh4IDogdCkgeSA9IFBvbHkuKCA9ICkgeCB5XG4gIGxldCAoID4gKSAoeCA6IHQpIHkgPSBQb2x5LiggPiApIHggeVxuICBsZXQgKCA+PSApICh4IDogdCkgeSA9IFBvbHkuKCA+PSApIHggeVxuICBsZXQgYXNjZW5kaW5nICh4IDogdCkgeSA9IFBvbHkuYXNjZW5kaW5nIHggeVxuICBsZXQgZGVzY2VuZGluZyAoeCA6IHQpIHkgPSBQb2x5LmRlc2NlbmRpbmcgeCB5XG4gIGxldCBjb21wYXJlICh4IDogdCkgeSA9IFBvbHkuY29tcGFyZSB4IHlcbiAgbGV0IGVxdWFsICh4IDogdCkgeSA9IFBvbHkuZXF1YWwgeCB5XG4gIGxldCBtYXggKHggOiB0KSB5ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIHlcbiAgbGV0IG1pbiAoeCA6IHQpIHkgPSBpZiB4IDw9IHkgdGhlbiB4IGVsc2UgeVxuZW5kXG5cbmxldCBvZl9zdHJpbmcgcyA9IHRfb2Zfc2V4cCAoc2V4cF9vZl9zdHJpbmcgcylcbmxldCB0b19zdHJpbmcgdCA9IHN0cmluZ19vZl9zZXhwIChzZXhwX29mX3QgdClcblxubGV0IHRvX2ludCA9IGZ1bmN0aW9uXG4gIHwgTmVnIC0+IC0xXG4gIHwgWmVybyAtPiAwXG4gIHwgUG9zIC0+IDFcbjs7XG5cbmxldCBfID0gaGFzaFxuXG4oKiBJZ25vcmUgdGhlIGhhc2ggZnVuY3Rpb24gcHJvZHVjZWQgYnkgW0BAZGVyaXZpbmdfaW5saW5lIGhhc2hdICopXG5sZXQgaGFzaCA9IHRvX2ludFxubGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLlNpZ25cIlxubGV0IG9mX2ludCBuID0gaWYgbiA8IDAgdGhlbiBOZWcgZWxzZSBpZiBuID0gMCB0aGVuIFplcm8gZWxzZSBQb3NcbiIsIm9wZW4hIEltcG9ydFxuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICB0eXBlIHQgPSB1bml0IFtAQGRlcml2aW5nX2lubGluZSBlbnVtZXJhdGUsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgYWxsID0gKFsgKCkgXSA6IHQgbGlzdClcblxuICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgaGFzaF9mb2xkX3VuaXRcblxuICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBoYXNoX3VuaXQgaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgdF9vZl9zZXhwID0gKHVuaXRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuICBsZXQgc2V4cF9vZl90ID0gKHNleHBfb2ZfdW5pdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSB1bml0X3NleHBfZ3JhbW1hclxuXG4gIFtAQEBlbmRdXG5cbiAgbGV0IGNvbXBhcmUgXyBfID0gMFxuXG4gIGxldCBvZl9zdHJpbmcgPSBmdW5jdGlvblxuICAgIHwgXCIoKVwiIC0+ICgpXG4gICAgfCBfIC0+IGZhaWx3aXRoIFwiQmFzZS5Vbml0Lm9mX3N0cmluZzogKCkgZXhwZWN0ZWRcIlxuICA7O1xuXG4gIGxldCB0b19zdHJpbmcgKCkgPSBcIigpXCJcbiAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLlVuaXRcIlxuZW5kXG5cbmluY2x1ZGUgVFxuaW5jbHVkZSBJZGVudGlmaWFibGUuTWFrZSAoVClcblxubGV0IGludmFyaWFudCAoKSA9ICgpXG4iLCIoKiogTW9kdWxlIHR5cGVzIGZvciBhIFtiaW5hcnlfc2VhcmNoXSBmdW5jdGlvbiBmb3IgYSBzZXF1ZW5jZSwgYW5kIGZ1bmN0b3JzIGZvciBidWlsZGluZ1xuICAgIFtiaW5hcnlfc2VhcmNoXSBmdW5jdGlvbnMuICopXG5cbm9wZW4hIEltcG9ydFxuXG4oKiogQW4gW0luZGV4YWJsZV0gdHlwZSBpcyBhIGZpbml0ZSBzZXF1ZW5jZSBvZiBlbGVtZW50cyBpbmRleGVkIGJ5IGNvbnNlY3V0aXZlIGludGVnZXJzXG4gICAgWzBdIC4uLiBbbGVuZ3RoIHQgLSAxXS4gIFtnZXRdIGFuZCBbbGVuZ3RoXSBtdXN0IGJlIE8oMSkgZm9yIHRoZSByZXN1bHRpbmdcbiAgICBbYmluYXJ5X3NlYXJjaF0gdG8gYmUgbGcobikuICopXG5tb2R1bGUgdHlwZSBJbmRleGFibGUgPSBzaWdcbiAgdHlwZSBlbHRcbiAgdHlwZSB0XG5cbiAgdmFsIGdldCA6IHQgLT4gaW50IC0+IGVsdFxuICB2YWwgbGVuZ3RoIDogdCAtPiBpbnRcbmVuZFxuXG5tb2R1bGUgdHlwZSBJbmRleGFibGUxID0gc2lnXG4gIHR5cGUgJ2EgdFxuXG4gIHZhbCBnZXQgOiAnYSB0IC0+IGludCAtPiAnYVxuICB2YWwgbGVuZ3RoIDogXyB0IC0+IGludFxuZW5kXG5cbm1vZHVsZSBXaGljaF90YXJnZXRfYnlfa2V5ID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgWyBgTGFzdF9zdHJpY3RseV9sZXNzX3RoYW4gKCoqICAgICAgICB7diB8IDwgZWx0IFggfCAgICAgICAgICAgICAgICAgICAgICAgdn0gKilcbiAgICB8IGBMYXN0X2xlc3NfdGhhbl9vcl9lcXVhbF90byAoKiogICAgIHt2IHwgICAgICA8PSBlbHQgICAgICAgWCB8ICAgICAgICAgICB2fSAqKVxuICAgIHwgYExhc3RfZXF1YWxfdG8gKCoqICAgICAgICAgICAgICAgICAge3YgICAgICAgICAgIHwgICA9IGVsdCBYIHwgICAgICAgICAgIHZ9ICopXG4gICAgfCBgRmlyc3RfZXF1YWxfdG8gKCoqICAgICAgICAgICAgICAgICB7diAgICAgICAgICAgfCBYID0gZWx0ICAgfCAgICAgICAgICAgdn0gKilcbiAgICB8IGBGaXJzdF9ncmVhdGVyX3RoYW5fb3JfZXF1YWxfdG8gKCoqIHt2ICAgICAgICAgICB8IFggICAgICAgPj0gZWx0ICAgICAgfCB2fSAqKVxuICAgIHwgYEZpcnN0X3N0cmljdGx5X2dyZWF0ZXJfdGhhbiAoKiogICAge3YgICAgICAgICAgICAgICAgICAgICAgIHwgWCA+IGVsdCB8IHZ9ICopXG4gICAgXVxuICBbQEBkZXJpdmluZ19pbmxpbmUgZW51bWVyYXRlXVxuXG4gIGxldCBhbGwgPVxuICAgIChbIGBMYXN0X3N0cmljdGx5X2xlc3NfdGhhblxuICAgICA7IGBMYXN0X2xlc3NfdGhhbl9vcl9lcXVhbF90b1xuICAgICA7IGBMYXN0X2VxdWFsX3RvXG4gICAgIDsgYEZpcnN0X2VxdWFsX3RvXG4gICAgIDsgYEZpcnN0X2dyZWF0ZXJfdGhhbl9vcl9lcXVhbF90b1xuICAgICA7IGBGaXJzdF9zdHJpY3RseV9ncmVhdGVyX3RoYW5cbiAgICAgXVxuICAgICA6IHQgbGlzdClcbiAgOztcblxuICBbQEBAZW5kXVxuZW5kXG5cbm1vZHVsZSBXaGljaF90YXJnZXRfYnlfc2VnbWVudCA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIFsgYExhc3Rfb25fbGVmdFxuICAgIHwgYEZpcnN0X29uX3JpZ2h0XG4gICAgXVxuICBbQEBkZXJpdmluZ19pbmxpbmUgZW51bWVyYXRlXVxuXG4gIGxldCBhbGwgPSAoWyBgTGFzdF9vbl9sZWZ0OyBgRmlyc3Rfb25fcmlnaHQgXSA6IHQgbGlzdClcblxuICBbQEBAZW5kXVxuZW5kXG5cbnR5cGUgKCd0LCAnZWx0LCAna2V5KSBiaW5hcnlfc2VhcmNoID1cbiAgP3BvczppbnRcbiAgLT4gP2xlbjppbnRcbiAgLT4gJ3RcbiAgLT4gY29tcGFyZTooJ2VsdCAtPiAna2V5IC0+IGludClcbiAgLT4gV2hpY2hfdGFyZ2V0X2J5X2tleS50XG4gIC0+ICdrZXlcbiAgLT4gaW50IG9wdGlvblxuXG50eXBlICgndCwgJ2VsdCkgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQgPVxuICA/cG9zOmludFxuICAtPiA/bGVuOmludFxuICAtPiAndFxuICAtPiBzZWdtZW50X29mOignZWx0IC0+IFsgYExlZnQgfCBgUmlnaHQgXSlcbiAgLT4gV2hpY2hfdGFyZ2V0X2J5X3NlZ21lbnQudFxuICAtPiBpbnQgb3B0aW9uXG5cbm1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgdHlwZSBlbHRcbiAgdHlwZSB0XG5cbiAgKCoqIFNlZSBbQmluYXJ5X3NlYXJjaC5iaW5hcnlfc2VhcmNoXSBpbiBiaW5hcnlfc2VhcmNoLm1sICopXG4gIHZhbCBiaW5hcnlfc2VhcmNoIDogKHQsIGVsdCwgJ2tleSkgYmluYXJ5X3NlYXJjaFxuXG4gICgqKiBTZWUgW0JpbmFyeV9zZWFyY2guYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWRdIGluIGJpbmFyeV9zZWFyY2gubWwgKilcbiAgdmFsIGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkIDogKHQsIGVsdCkgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWRcbmVuZFxuXG5tb2R1bGUgdHlwZSBTMSA9IHNpZ1xuICB0eXBlICdhIHRcblxuICB2YWwgYmluYXJ5X3NlYXJjaCA6ICgnYSB0LCAnYSwgJ2tleSkgYmluYXJ5X3NlYXJjaFxuICB2YWwgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQgOiAoJ2EgdCwgJ2EpIGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkXG5lbmRcblxubW9kdWxlIHR5cGUgQmluYXJ5X3NlYXJjaGFibGUgPSBzaWdcbiAgbW9kdWxlIHR5cGUgUyA9IFNcbiAgbW9kdWxlIHR5cGUgUzEgPSBTMVxuICBtb2R1bGUgdHlwZSBJbmRleGFibGUgPSBJbmRleGFibGVcbiAgbW9kdWxlIHR5cGUgSW5kZXhhYmxlMSA9IEluZGV4YWJsZTFcblxuICBtb2R1bGUgV2hpY2hfdGFyZ2V0X2J5X2tleSA9IFdoaWNoX3RhcmdldF9ieV9rZXlcbiAgbW9kdWxlIFdoaWNoX3RhcmdldF9ieV9zZWdtZW50ID0gV2hpY2hfdGFyZ2V0X2J5X3NlZ21lbnRcblxuICB0eXBlIG5vbnJlYyAoJ3QsICdlbHQsICdrZXkpIGJpbmFyeV9zZWFyY2ggPSAoJ3QsICdlbHQsICdrZXkpIGJpbmFyeV9zZWFyY2hcbiAgdHlwZSBub25yZWMgKCd0LCAnZWx0KSBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCA9ICgndCwgJ2VsdCkgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWRcblxuICBtb2R1bGUgTWFrZSAoVCA6IEluZGV4YWJsZSkgOiBTIHdpdGggdHlwZSB0IDo9IFQudCB3aXRoIHR5cGUgZWx0IDo9IFQuZWx0XG4gIG1vZHVsZSBNYWtlMSAoVCA6IEluZGV4YWJsZTEpIDogUzEgd2l0aCB0eXBlICdhIHQgOj0gJ2EgVC50XG5lbmRcbiIsIm9wZW4hIEltcG9ydFxub3BlbiBDb250YWluZXJfaW50Zi5FeHBvcnRcbm1vZHVsZSBBcnJheSA9IEFycmF5MFxubW9kdWxlIExpc3QgPSBMaXN0MVxuXG5tb2R1bGUgU3RlcCA9IHN0cnVjdFxuICAoKiAnYSBpcyBhbiBpdGVtIGluIHRoZSBzZXF1ZW5jZSwgJ3MgaXMgdGhlIHN0YXRlIHRoYXQgd2lsbCBwcm9kdWNlIHRoZSByZW1haW5kZXIgb2ZcbiAgICAgdGhlIHNlcXVlbmNlICopXG4gIHR5cGUgKCdhLCAncykgdCA9XG4gICAgfCBEb25lXG4gICAgfCBTa2lwIG9mICdzXG4gICAgfCBZaWVsZCBvZiAnYSAqICdzXG4gIFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gIGxldCBzZXhwX29mX3QgOlxuICAgICdhICdzLlxuICAgICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgLT4gKCdzIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAtPiAoJ2EsICdzKSB0XG4gICAgLT4gU2V4cGxpYjAuU2V4cC50XG4gICAgPVxuICAgIGZ1biAodHlwZSBhX18wMDlfIHNfXzAxMF8pXG4gICAgICAgIDogICgoYV9fMDA5XyAtPiBTZXhwbGliMC5TZXhwLnQpIC0+IChzX18wMTBfIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgICAgICAgIC0+IChhX18wMDlfLCBzX18wMTBfKSB0IC0+IFNleHBsaWIwLlNleHAudCkgLT5cbiAgICAgIGZ1biBfb2ZfYV9fMDAxXyBfb2Zfc19fMDAyXyAtPiBmdW5jdGlvblxuICAgICAgICB8IERvbmUgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiRG9uZVwiXG4gICAgICAgIHwgU2tpcCBhcmcwX18wMDNfIC0+XG4gICAgICAgICAgbGV0IHJlczBfXzAwNF8gPSBfb2Zfc19fMDAyXyBhcmcwX18wMDNfIGluXG4gICAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiU2tpcFwiOyByZXMwX18wMDRfIF1cbiAgICAgICAgfCBZaWVsZCAoYXJnMF9fMDA1XywgYXJnMV9fMDA2XykgLT5cbiAgICAgICAgICBsZXQgcmVzMF9fMDA3XyA9IF9vZl9hX18wMDFfIGFyZzBfXzAwNV9cbiAgICAgICAgICBhbmQgcmVzMV9fMDA4XyA9IF9vZl9zX18wMDJfIGFyZzFfXzAwNl8gaW5cbiAgICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJZaWVsZFwiOyByZXMwX18wMDdfOyByZXMxX18wMDhfIF1cbiAgOztcblxuICBbQEBAZW5kXVxuZW5kXG5cbm9wZW4gU3RlcFxuXG4oKiAnYSBpcyBhbiBpdGVtIGluIHRoZSBzZXF1ZW5jZSwgJ3MgaXMgdGhlIHN0YXRlIHRoYXQgd2lsbCBwcm9kdWNlIHRoZSByZW1haW5kZXIgb2YgdGhlXG4gICBzZXF1ZW5jZSAqKVxudHlwZSArXyB0ID0gU2VxdWVuY2UgOiAncyAqICgncyAtPiAoJ2EsICdzKSBTdGVwLnQpIC0+ICdhIHRcbnR5cGUgJ2Egc2VxdWVuY2UgPSAnYSB0XG5cbm1vZHVsZSBFeHBlcnQgPSBzdHJ1Y3RcbiAgbGV0IG5leHRfc3RlcCAoU2VxdWVuY2UgKHMsIGYpKSA9XG4gICAgbWF0Y2ggZiBzIHdpdGhcbiAgICB8IERvbmUgLT4gRG9uZVxuICAgIHwgU2tpcCBzIC0+IFNraXAgKFNlcXVlbmNlIChzLCBmKSlcbiAgICB8IFlpZWxkIChhLCBzKSAtPiBZaWVsZCAoYSwgU2VxdWVuY2UgKHMsIGYpKVxuICA7O1xuXG4gIGxldCBkZWxheWVkX2ZvbGRfc3RlcCBzIH5pbml0IH5mIH5maW5pc2ggPVxuICAgIGxldCByZWMgbG9vcCBzIG5leHQgZmluaXNoIGYgYWNjID1cbiAgICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgICB8IERvbmUgLT4gZmluaXNoIGFjY1xuICAgICAgfCBTa2lwIHMgLT4gZiBhY2MgTm9uZSB+azoobG9vcCBzIG5leHQgZmluaXNoIGYpXG4gICAgICB8IFlpZWxkIChhLCBzKSAtPiBmIGFjYyAoU29tZSBhKSB+azoobG9vcCBzIG5leHQgZmluaXNoIGYpXG4gICAgaW5cbiAgICBtYXRjaCBzIHdpdGhcbiAgICB8IFNlcXVlbmNlIChzLCBuZXh0KSAtPiBsb29wIHMgbmV4dCBmaW5pc2ggZiBpbml0XG4gIDs7XG5lbmRcblxubGV0IHVuZm9sZF9zdGVwIH5pbml0IH5mID0gU2VxdWVuY2UgKGluaXQsIGYpXG5cbmxldCB1bmZvbGQgfmluaXQgfmYgPVxuICB1bmZvbGRfc3RlcCB+aW5pdCB+ZjooZnVuIHMgLT5cbiAgICBtYXRjaCBmIHMgd2l0aFxuICAgIHwgTm9uZSAtPiBTdGVwLkRvbmVcbiAgICB8IFNvbWUgKGEsIHMpIC0+IFN0ZXAuWWllbGQgKGEsIHMpKVxuOztcblxubGV0IHVuZm9sZF93aXRoIHMgfmluaXQgfmYgPVxuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSAocywgbmV4dCkgLT5cbiAgICBTZXF1ZW5jZVxuICAgICAgKCAoaW5pdCwgcylcbiAgICAgICwgZnVuIChzZWVkLCBzKSAtPlxuICAgICAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgICAgICB8IERvbmUgLT4gRG9uZVxuICAgICAgICB8IFNraXAgcyAtPiBTa2lwIChzZWVkLCBzKVxuICAgICAgICB8IFlpZWxkIChhLCBzKSAtPlxuICAgICAgICAgIChtYXRjaCBmIHNlZWQgYSB3aXRoXG4gICAgICAgICAgIHwgRG9uZSAtPiBEb25lXG4gICAgICAgICAgIHwgU2tpcCBzZWVkIC0+IFNraXAgKHNlZWQsIHMpXG4gICAgICAgICAgIHwgWWllbGQgKGEsIHNlZWQpIC0+IFlpZWxkIChhLCAoc2VlZCwgcykpKSApXG47O1xuXG5sZXQgdW5mb2xkX3dpdGhfYW5kX2ZpbmlzaCBzIH5pbml0IH5ydW5uaW5nX3N0ZXAgfmlubmVyX2ZpbmlzaGVkIH5maW5pc2hpbmdfc3RlcCA9XG4gIG1hdGNoIHMgd2l0aFxuICB8IFNlcXVlbmNlIChzLCBuZXh0KSAtPlxuICAgIFNlcXVlbmNlXG4gICAgICAoIGBJbm5lcl9ydW5uaW5nIChpbml0LCBzKVxuICAgICAgLCBmdW4gc3RhdGUgLT5cbiAgICAgICAgbWF0Y2ggc3RhdGUgd2l0aFxuICAgICAgICB8IGBJbm5lcl9ydW5uaW5nIChzdGF0ZSwgaW5uZXJfc3RhdGUpIC0+XG4gICAgICAgICAgKG1hdGNoIG5leHQgaW5uZXJfc3RhdGUgd2l0aFxuICAgICAgICAgICB8IERvbmUgLT4gU2tpcCAoYElubmVyX2ZpbmlzaGVkIChpbm5lcl9maW5pc2hlZCBzdGF0ZSkpXG4gICAgICAgICAgIHwgU2tpcCBpbm5lcl9zdGF0ZSAtPiBTa2lwIChgSW5uZXJfcnVubmluZyAoc3RhdGUsIGlubmVyX3N0YXRlKSlcbiAgICAgICAgICAgfCBZaWVsZCAoeCwgaW5uZXJfc3RhdGUpIC0+XG4gICAgICAgICAgICAgKG1hdGNoIHJ1bm5pbmdfc3RlcCBzdGF0ZSB4IHdpdGhcbiAgICAgICAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgICAgICAgfCBTa2lwIHN0YXRlIC0+IFNraXAgKGBJbm5lcl9ydW5uaW5nIChzdGF0ZSwgaW5uZXJfc3RhdGUpKVxuICAgICAgICAgICAgICB8IFlpZWxkICh5LCBzdGF0ZSkgLT4gWWllbGQgKHksIGBJbm5lcl9ydW5uaW5nIChzdGF0ZSwgaW5uZXJfc3RhdGUpKSkpXG4gICAgICAgIHwgYElubmVyX2ZpbmlzaGVkIHN0YXRlIC0+XG4gICAgICAgICAgKG1hdGNoIGZpbmlzaGluZ19zdGVwIHN0YXRlIHdpdGhcbiAgICAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgICAgfCBTa2lwIHN0YXRlIC0+IFNraXAgKGBJbm5lcl9maW5pc2hlZCBzdGF0ZSlcbiAgICAgICAgICAgfCBZaWVsZCAoeSwgc3RhdGUpIC0+IFlpZWxkICh5LCBgSW5uZXJfZmluaXNoZWQgc3RhdGUpKSApXG47O1xuXG5sZXQgb2ZfbGlzdCBsID1cbiAgdW5mb2xkX3N0ZXAgfmluaXQ6bCB+ZjooZnVuY3Rpb25cbiAgICB8IFtdIC0+IERvbmVcbiAgICB8IHggOjogbCAtPiBZaWVsZCAoeCwgbCkpXG47O1xuXG5cbmxldCBmb2xkIHQgfmluaXQgfmYgPVxuICBsZXQgcmVjIGxvb3Agc2VlZCB2IG5leHQgZiA9XG4gICAgbWF0Y2ggbmV4dCBzZWVkIHdpdGhcbiAgICB8IERvbmUgLT4gdlxuICAgIHwgU2tpcCBzIC0+IGxvb3AgcyB2IG5leHQgZlxuICAgIHwgWWllbGQgKGEsIHMpIC0+IGxvb3AgcyAoZiB2IGEpIG5leHQgZlxuICBpblxuICBtYXRjaCB0IHdpdGhcbiAgfCBTZXF1ZW5jZSAoc2VlZCwgbmV4dCkgLT4gbG9vcCBzZWVkIGluaXQgbmV4dCBmXG47O1xuXG5sZXQgdG9fbGlzdF9yZXYgdCA9IGZvbGQgdCB+aW5pdDpbXSB+ZjooZnVuIGwgeCAtPiB4IDo6IGwpXG5cblxubGV0IHRvX2xpc3QgKFNlcXVlbmNlIChzLCBuZXh0KSkgPVxuICBsZXQgc2FmZV90b19saXN0IHQgPSBMaXN0LnJldiAodG9fbGlzdF9yZXYgdCkgaW5cbiAgbGV0IHJlYyB0b19saXN0IHMgbmV4dCBpID1cbiAgICBpZiBpID0gMFxuICAgIHRoZW4gc2FmZV90b19saXN0IChTZXF1ZW5jZSAocywgbmV4dCkpXG4gICAgZWxzZSAoXG4gICAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgICAgfCBEb25lIC0+IFtdXG4gICAgICB8IFNraXAgcyAtPiB0b19saXN0IHMgbmV4dCBpXG4gICAgICB8IFlpZWxkIChhLCBzKSAtPiBhIDo6IHRvX2xpc3QgcyBuZXh0IChpIC0gMSkpXG4gIGluXG4gIHRvX2xpc3QgcyBuZXh0IDUwMFxuOztcblxubGV0IHNleHBfb2ZfdCBzZXhwX29mX2EgdCA9IHNleHBfb2ZfbGlzdCBzZXhwX29mX2EgKHRvX2xpc3QgdClcblxubGV0IHJhbmdlID8oc3RyaWRlID0gMSkgPyhzdGFydCA9IGBpbmNsdXNpdmUpID8oc3RvcCA9IGBleGNsdXNpdmUpIHN0YXJ0X3Ygc3RvcF92ID1cbiAgbGV0IHN0ZXAgPVxuICAgIG1hdGNoIHN0b3Agd2l0aFxuICAgIHwgYGluY2x1c2l2ZSB3aGVuIHN0cmlkZSA+PSAwIC0+XG4gICAgICBmdW4gaSAtPiBpZiBpID4gc3RvcF92IHRoZW4gRG9uZSBlbHNlIFlpZWxkIChpLCBpICsgc3RyaWRlKVxuICAgIHwgYGluY2x1c2l2ZSAtPiBmdW4gaSAtPiBpZiBpIDwgc3RvcF92IHRoZW4gRG9uZSBlbHNlIFlpZWxkIChpLCBpICsgc3RyaWRlKVxuICAgIHwgYGV4Y2x1c2l2ZSB3aGVuIHN0cmlkZSA+PSAwIC0+XG4gICAgICBmdW4gaSAtPiBpZiBpID49IHN0b3BfdiB0aGVuIERvbmUgZWxzZSBZaWVsZCAoaSwgaSArIHN0cmlkZSlcbiAgICB8IGBleGNsdXNpdmUgLT4gZnVuIGkgLT4gaWYgaSA8PSBzdG9wX3YgdGhlbiBEb25lIGVsc2UgWWllbGQgKGksIGkgKyBzdHJpZGUpXG4gIGluXG4gIGxldCBpbml0ID1cbiAgICBtYXRjaCBzdGFydCB3aXRoXG4gICAgfCBgaW5jbHVzaXZlIC0+IHN0YXJ0X3ZcbiAgICB8IGBleGNsdXNpdmUgLT4gc3RhcnRfdiArIHN0cmlkZVxuICBpblxuICB1bmZvbGRfc3RlcCB+aW5pdCB+ZjpzdGVwXG47O1xuXG5sZXQgb2ZfbGF6eSB0X2xhenkgPVxuICB1bmZvbGRfc3RlcCB+aW5pdDp0X2xhenkgfmY6KGZ1biB0X2xhenkgLT5cbiAgICBsZXQgKFNlcXVlbmNlIChzLCBuZXh0KSkgPSBMYXp5LmZvcmNlIHRfbGF6eSBpblxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IERvbmVcbiAgICB8IFNraXAgcyAtPlxuICAgICAgU2tpcFxuICAgICAgICAobGV0IHYgPSBTZXF1ZW5jZSAocywgbmV4dCkgaW5cbiAgICAgICAgIGxhenkgdilcbiAgICB8IFlpZWxkICh4LCBzKSAtPlxuICAgICAgWWllbGRcbiAgICAgICAgKCB4XG4gICAgICAgICwgbGV0IHYgPSBTZXF1ZW5jZSAocywgbmV4dCkgaW5cbiAgICAgICAgICBsYXp5IHYgKSlcbjs7XG5cbmxldCBtYXAgdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IFNlcXVlbmNlIChzZWVkLCBuZXh0KSAtPlxuICAgIFNlcXVlbmNlXG4gICAgICAoIHNlZWRcbiAgICAgICwgZnVuIHNlZWQgLT5cbiAgICAgICAgbWF0Y2ggbmV4dCBzZWVkIHdpdGhcbiAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgfCBTa2lwIHMgLT4gU2tpcCBzXG4gICAgICAgIHwgWWllbGQgKGEsIHMpIC0+IFlpZWxkIChmIGEsIHMpIClcbjs7XG5cbmxldCBtYXBpIHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBTZXF1ZW5jZSAocywgbmV4dCkgLT5cbiAgICBTZXF1ZW5jZVxuICAgICAgKCAoMCwgcylcbiAgICAgICwgZnVuIChpLCBzKSAtPlxuICAgICAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgICAgICB8IERvbmUgLT4gRG9uZVxuICAgICAgICB8IFNraXAgcyAtPiBTa2lwIChpLCBzKVxuICAgICAgICB8IFlpZWxkIChhLCBzKSAtPiBZaWVsZCAoZiBpIGEsIChpICsgMSwgcykpIClcbjs7XG5cbmxldCBmb2xkaW5nX21hcCB0IH5pbml0IH5mID1cbiAgdW5mb2xkX3dpdGggdCB+aW5pdCB+ZjooZnVuIGFjYyB4IC0+XG4gICAgbGV0IGFjYywgeCA9IGYgYWNjIHggaW5cbiAgICBZaWVsZCAoeCwgYWNjKSlcbjs7XG5cbmxldCBmb2xkaW5nX21hcGkgdCB+aW5pdCB+ZiA9XG4gIHVuZm9sZF93aXRoIHQgfmluaXQ6KDAsIGluaXQpIH5mOihmdW4gKGksIGFjYykgeCAtPlxuICAgIGxldCBhY2MsIHggPSBmIGkgYWNjIHggaW5cbiAgICBZaWVsZCAoeCwgKGkgKyAxLCBhY2MpKSlcbjs7XG5cbmxldCBmaWx0ZXIgdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IFNlcXVlbmNlIChzZWVkLCBuZXh0KSAtPlxuICAgIFNlcXVlbmNlXG4gICAgICAoIHNlZWRcbiAgICAgICwgZnVuIHNlZWQgLT5cbiAgICAgICAgbWF0Y2ggbmV4dCBzZWVkIHdpdGhcbiAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgfCBTa2lwIHMgLT4gU2tpcCBzXG4gICAgICAgIHwgWWllbGQgKGEsIHMpIHdoZW4gZiBhIC0+IFlpZWxkIChhLCBzKVxuICAgICAgICB8IFlpZWxkIChfLCBzKSAtPiBTa2lwIHMgKVxuOztcblxubGV0IGZpbHRlcmkgdCB+ZiA9XG4gIG1hcCB+ZjpzbmQgKGZpbHRlciAobWFwaSB0IH5mOihmdW4gaSBzIC0+IGksIHMpKSB+ZjooZnVuIChpLCBzKSAtPiBmIGkgcykpXG47O1xuXG5sZXQgbGVuZ3RoIHQgPVxuICBsZXQgcmVjIGxvb3AgaSBzIG5leHQgPVxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IGlcbiAgICB8IFNraXAgcyAtPiBsb29wIGkgcyBuZXh0XG4gICAgfCBZaWVsZCAoXywgcykgLT4gbG9vcCAoaSArIDEpIHMgbmV4dFxuICBpblxuICBtYXRjaCB0IHdpdGhcbiAgfCBTZXF1ZW5jZSAoc2VlZCwgbmV4dCkgLT4gbG9vcCAwIHNlZWQgbmV4dFxuOztcblxubGV0IHRvX2xpc3RfcmV2X3dpdGhfbGVuZ3RoIHQgPSBmb2xkIHQgfmluaXQ6KFtdLCAwKSB+ZjooZnVuIChsLCBpKSB4IC0+IHggOjogbCwgaSArIDEpXG5cbmxldCB0b19hcnJheSB0ID1cbiAgbGV0IGwsIGxlbiA9IHRvX2xpc3RfcmV2X3dpdGhfbGVuZ3RoIHQgaW5cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT4gW3x8XVxuICB8IHggOjogbCAtPlxuICAgIGxldCBhID0gQXJyYXkuY3JlYXRlIH5sZW4geCBpblxuICAgIGxldCByZWMgbG9vcCBpIGwgPVxuICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICB8IFtdIC0+IGFzc2VydCAoaSA9IC0xKVxuICAgICAgfCB4IDo6IGwgLT5cbiAgICAgICAgYS4oaSkgPC0geDtcbiAgICAgICAgbG9vcCAoaSAtIDEpIGxcbiAgICBpblxuICAgIGxvb3AgKGxlbiAtIDIpIGw7XG4gICAgYVxuOztcblxubGV0IGZpbmQgdCB+ZiA9XG4gIGxldCByZWMgbG9vcCBzIG5leHQgZiA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gTm9uZVxuICAgIHwgWWllbGQgKGEsIF8pIHdoZW4gZiBhIC0+IFNvbWUgYVxuICAgIHwgWWllbGQgKF8sIHMpIHwgU2tpcCBzIC0+IGxvb3AgcyBuZXh0IGZcbiAgaW5cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU2VxdWVuY2UgKHNlZWQsIG5leHQpIC0+IGxvb3Agc2VlZCBuZXh0IGZcbjs7XG5cbmxldCBmaW5kX21hcCB0IH5mID1cbiAgbGV0IHJlYyBsb29wIHMgbmV4dCBmID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiBOb25lXG4gICAgfCBZaWVsZCAoYSwgcykgLT5cbiAgICAgIChtYXRjaCBmIGEgd2l0aFxuICAgICAgIHwgTm9uZSAtPiBsb29wIHMgbmV4dCBmXG4gICAgICAgfCBzb21lX2IgLT4gc29tZV9iKVxuICAgIHwgU2tpcCBzIC0+IGxvb3AgcyBuZXh0IGZcbiAgaW5cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU2VxdWVuY2UgKHNlZWQsIG5leHQpIC0+IGxvb3Agc2VlZCBuZXh0IGZcbjs7XG5cblxubGV0IGZpbmRfbWFwaSB0IH5mID1cbiAgbGV0IHJlYyBsb29wIHMgbmV4dCBmIGkgPVxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IE5vbmVcbiAgICB8IFlpZWxkIChhLCBzKSAtPlxuICAgICAgKG1hdGNoIGYgaSBhIHdpdGhcbiAgICAgICB8IE5vbmUgLT4gbG9vcCBzIG5leHQgZiAoaSArIDEpXG4gICAgICAgfCBzb21lX2IgLT4gc29tZV9iKVxuICAgIHwgU2tpcCBzIC0+IGxvb3AgcyBuZXh0IGYgaVxuICBpblxuICBtYXRjaCB0IHdpdGhcbiAgfCBTZXF1ZW5jZSAoc2VlZCwgbmV4dCkgLT4gbG9vcCBzZWVkIG5leHQgZiAwXG47O1xuXG5sZXQgZm9yX2FsbCB0IH5mID1cbiAgbGV0IHJlYyBsb29wIHMgbmV4dCBmID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiB0cnVlXG4gICAgfCBZaWVsZCAoYSwgXykgd2hlbiBub3QgKGYgYSkgLT4gZmFsc2VcbiAgICB8IFlpZWxkIChfLCBzKSB8IFNraXAgcyAtPiBsb29wIHMgbmV4dCBmXG4gIGluXG4gIG1hdGNoIHQgd2l0aFxuICB8IFNlcXVlbmNlIChzZWVkLCBuZXh0KSAtPiBsb29wIHNlZWQgbmV4dCBmXG47O1xuXG5sZXQgZm9yX2FsbGkgdCB+ZiA9XG4gIGxldCByZWMgbG9vcCBzIG5leHQgZiBpID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiB0cnVlXG4gICAgfCBZaWVsZCAoYSwgXykgd2hlbiBub3QgKGYgaSBhKSAtPiBmYWxzZVxuICAgIHwgWWllbGQgKF8sIHMpIC0+IGxvb3AgcyBuZXh0IGYgKGkgKyAxKVxuICAgIHwgU2tpcCBzIC0+IGxvb3AgcyBuZXh0IGYgaVxuICBpblxuICBtYXRjaCB0IHdpdGhcbiAgfCBTZXF1ZW5jZSAoc2VlZCwgbmV4dCkgLT4gbG9vcCBzZWVkIG5leHQgZiAwXG47O1xuXG5sZXQgZXhpc3RzIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgcyBuZXh0IGYgPVxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IGZhbHNlXG4gICAgfCBZaWVsZCAoYSwgXykgd2hlbiBmIGEgLT4gdHJ1ZVxuICAgIHwgWWllbGQgKF8sIHMpIHwgU2tpcCBzIC0+IGxvb3AgcyBuZXh0IGZcbiAgaW5cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU2VxdWVuY2UgKHNlZWQsIG5leHQpIC0+IGxvb3Agc2VlZCBuZXh0IGZcbjs7XG5cbmxldCBleGlzdHNpIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgcyBuZXh0IGYgaSA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gZmFsc2VcbiAgICB8IFlpZWxkIChhLCBfKSB3aGVuIGYgaSBhIC0+IHRydWVcbiAgICB8IFlpZWxkIChfLCBzKSAtPiBsb29wIHMgbmV4dCBmIChpICsgMSlcbiAgICB8IFNraXAgcyAtPiBsb29wIHMgbmV4dCBmIGlcbiAgaW5cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU2VxdWVuY2UgKHNlZWQsIG5leHQpIC0+IGxvb3Agc2VlZCBuZXh0IGYgMFxuOztcblxubGV0IGl0ZXIgdCB+ZiA9XG4gIGxldCByZWMgbG9vcCBzZWVkIG5leHQgZiA9XG4gICAgbWF0Y2ggbmV4dCBzZWVkIHdpdGhcbiAgICB8IERvbmUgLT4gKClcbiAgICB8IFNraXAgcyAtPiBsb29wIHMgbmV4dCBmXG4gICAgfCBZaWVsZCAoYSwgcykgLT5cbiAgICAgIGYgYTtcbiAgICAgIGxvb3AgcyBuZXh0IGZcbiAgaW5cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU2VxdWVuY2UgKHNlZWQsIG5leHQpIC0+IGxvb3Agc2VlZCBuZXh0IGZcbjs7XG5cbmxldCBpc19lbXB0eSB0ID1cbiAgbGV0IHJlYyBsb29wIHMgbmV4dCA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gdHJ1ZVxuICAgIHwgU2tpcCBzIC0+IGxvb3AgcyBuZXh0XG4gICAgfCBZaWVsZCBfIC0+IGZhbHNlXG4gIGluXG4gIG1hdGNoIHQgd2l0aFxuICB8IFNlcXVlbmNlIChzZWVkLCBuZXh0KSAtPiBsb29wIHNlZWQgbmV4dFxuOztcblxubGV0IG1lbSB0IGEgfmVxdWFsID1cbiAgbGV0IHJlYyBsb29wIHMgbmV4dCBhID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiBmYWxzZVxuICAgIHwgWWllbGQgKGIsIF8pIHdoZW4gZXF1YWwgYSBiIC0+IHRydWVcbiAgICB8IFlpZWxkIChfLCBzKSB8IFNraXAgcyAtPiBsb29wIHMgbmV4dCBhXG4gIGluXG4gIG1hdGNoIHQgd2l0aFxuICB8IFNlcXVlbmNlIChzZWVkLCBuZXh0KSAtPiBsb29wIHNlZWQgbmV4dCBhXG47O1xuXG5sZXQgZW1wdHkgPSBTZXF1ZW5jZSAoKCksIGZ1biAoKSAtPiBEb25lKVxuXG5sZXQgYmluZCB0IH5mID1cbiAgdW5mb2xkX3N0ZXBcbiAgICB+ZjooZnVuY3Rpb25cbiAgICAgIHwgU2VxdWVuY2UgKHNlZWQsIG5leHQpLCByZXN0IC0+XG4gICAgICAgIChtYXRjaCBuZXh0IHNlZWQgd2l0aFxuICAgICAgICAgfCBEb25lIC0+XG4gICAgICAgICAgIChtYXRjaCByZXN0IHdpdGhcbiAgICAgICAgICAgIHwgU2VxdWVuY2UgKHNlZWQsIG5leHQpIC0+XG4gICAgICAgICAgICAgIChtYXRjaCBuZXh0IHNlZWQgd2l0aFxuICAgICAgICAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgICAgICAgIHwgU2tpcCBzIC0+IFNraXAgKGVtcHR5LCBTZXF1ZW5jZSAocywgbmV4dCkpXG4gICAgICAgICAgICAgICB8IFlpZWxkIChhLCBzKSAtPiBTa2lwIChmIGEsIFNlcXVlbmNlIChzLCBuZXh0KSkpKVxuICAgICAgICAgfCBTa2lwIHMgLT4gU2tpcCAoU2VxdWVuY2UgKHMsIG5leHQpLCByZXN0KVxuICAgICAgICAgfCBZaWVsZCAoYSwgcykgLT4gWWllbGQgKGEsIChTZXF1ZW5jZSAocywgbmV4dCksIHJlc3QpKSkpXG4gICAgfmluaXQ6KGVtcHR5LCB0KVxuOztcblxubGV0IHJldHVybiB4ID1cbiAgdW5mb2xkX3N0ZXAgfmluaXQ6KFNvbWUgeCkgfmY6KGZ1bmN0aW9uXG4gICAgfCBOb25lIC0+IERvbmVcbiAgICB8IFNvbWUgeCAtPiBZaWVsZCAoeCwgTm9uZSkpXG47O1xuXG5pbmNsdWRlIE1vbmFkLk1ha2UgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgICBsZXQgbWFwID0gYEN1c3RvbSBtYXBcbiAgICBsZXQgYmluZCA9IGJpbmRcbiAgICBsZXQgcmV0dXJuID0gcmV0dXJuXG4gIGVuZClcblxubGV0IG50aCBzIG4gPVxuICBpZiBuIDwgMFxuICB0aGVuIE5vbmVcbiAgZWxzZSAoXG4gICAgbGV0IHJlYyBsb29wIGkgcyBuZXh0ID1cbiAgICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgICB8IERvbmUgLT4gTm9uZVxuICAgICAgfCBTa2lwIHMgLT4gbG9vcCBpIHMgbmV4dFxuICAgICAgfCBZaWVsZCAoYSwgcykgLT4gaWYgcGh5c19lcXVhbCBpIDAgdGhlbiBTb21lIGEgZWxzZSBsb29wIChpIC0gMSkgcyBuZXh0XG4gICAgaW5cbiAgICBtYXRjaCBzIHdpdGhcbiAgICB8IFNlcXVlbmNlIChzLCBuZXh0KSAtPiBsb29wIG4gcyBuZXh0KVxuOztcblxubGV0IG50aF9leG4gcyBuID1cbiAgaWYgbiA8IDBcbiAgdGhlbiBpbnZhbGlkX2FyZyBcIlNlcXVlbmNlLm50aFwiXG4gIGVsc2UgKFxuICAgIG1hdGNoIG50aCBzIG4gd2l0aFxuICAgIHwgTm9uZSAtPiBmYWlsd2l0aCBcIlNlcXVlbmNlLm50aFwiXG4gICAgfCBTb21lIHggLT4geClcbjs7XG5cbm1vZHVsZSBNZXJnZV93aXRoX2R1cGxpY2F0ZXNfZWxlbWVudCA9IHN0cnVjdFxuICB0eXBlICgnYSwgJ2IpIHQgPVxuICAgIHwgTGVmdCBvZiAnYVxuICAgIHwgUmlnaHQgb2YgJ2JcbiAgICB8IEJvdGggb2YgJ2EgKiAnYlxuICBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlIDpcbiAgICAnYSAnYi4gKCdhIC0+ICdhIC0+IGludCkgLT4gKCdiIC0+ICdiIC0+IGludCkgLT4gKCdhLCAnYikgdCAtPiAoJ2EsICdiKSB0IC0+IGludFxuICAgID1cbiAgICBmdW4gX2NtcF9fYSBfY21wX19iIGFfXzAxMV8gYl9fMDEyXyAtPlxuICAgIGlmIFBweF9jb21wYXJlX2xpYi5waHlzX2VxdWFsIGFfXzAxMV8gYl9fMDEyX1xuICAgIHRoZW4gMFxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggYV9fMDExXywgYl9fMDEyXyB3aXRoXG4gICAgICB8IExlZnQgX2FfXzAxM18sIExlZnQgX2JfXzAxNF8gLT4gX2NtcF9fYSBfYV9fMDEzXyBfYl9fMDE0X1xuICAgICAgfCBMZWZ0IF8sIF8gLT4gLTFcbiAgICAgIHwgXywgTGVmdCBfIC0+IDFcbiAgICAgIHwgUmlnaHQgX2FfXzAxNV8sIFJpZ2h0IF9iX18wMTZfIC0+IF9jbXBfX2IgX2FfXzAxNV8gX2JfXzAxNl9cbiAgICAgIHwgUmlnaHQgXywgXyAtPiAtMVxuICAgICAgfCBfLCBSaWdodCBfIC0+IDFcbiAgICAgIHwgQm90aCAoX2FfXzAxN18sIF9hX18wMTlfKSwgQm90aCAoX2JfXzAxOF8sIF9iX18wMjBfKSAtPlxuICAgICAgICAobWF0Y2ggX2NtcF9fYSBfYV9fMDE3XyBfYl9fMDE4XyB3aXRoXG4gICAgICAgICB8IDAgLT4gX2NtcF9fYiBfYV9fMDE5XyBfYl9fMDIwX1xuICAgICAgICAgfCBuIC0+IG4pKVxuICA7O1xuXG4gIGxldCBoYXNoX2ZvbGRfdFxuICAgIDogdHlwZSBhIGIuXG4gICAgICAoUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IGEgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgICAgLT4gKFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiBiIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgICAgIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZVxuICAgICAgLT4gKGEsIGIpIHRcbiAgICAgIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZVxuICAgID1cbiAgICBmdW4gX2hhc2hfZm9sZF9hIF9oYXNoX2ZvbGRfYiBoc3YgYXJnIC0+XG4gICAgICBtYXRjaCBhcmcgd2l0aFxuICAgICAgfCBMZWZ0IF9hMCAtPlxuICAgICAgICBsZXQgaHN2ID0gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50IGhzdiAwIGluXG4gICAgICAgIGxldCBoc3YgPSBoc3YgaW5cbiAgICAgICAgX2hhc2hfZm9sZF9hIGhzdiBfYTBcbiAgICAgIHwgUmlnaHQgX2EwIC0+XG4gICAgICAgIGxldCBoc3YgPSBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDEgaW5cbiAgICAgICAgbGV0IGhzdiA9IGhzdiBpblxuICAgICAgICBfaGFzaF9mb2xkX2IgaHN2IF9hMFxuICAgICAgfCBCb3RoIChfYTAsIF9hMSkgLT5cbiAgICAgICAgbGV0IGhzdiA9IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludCBoc3YgMiBpblxuICAgICAgICBsZXQgaHN2ID1cbiAgICAgICAgICBsZXQgaHN2ID0gaHN2IGluXG4gICAgICAgICAgX2hhc2hfZm9sZF9hIGhzdiBfYTBcbiAgICAgICAgaW5cbiAgICAgICAgX2hhc2hfZm9sZF9iIGhzdiBfYTFcbiAgOztcblxuICBsZXQgdF9vZl9zZXhwIDpcbiAgICAnYSAnYi5cbiAgICAoU2V4cGxpYjAuU2V4cC50IC0+ICdhKVxuICAgIC0+IChTZXhwbGliMC5TZXhwLnQgLT4gJ2IpXG4gICAgLT4gU2V4cGxpYjAuU2V4cC50XG4gICAgLT4gKCdhLCAnYikgdFxuICAgID1cbiAgICBmdW4gKHR5cGUgYV9fMDQ0XyBiX18wNDVfKVxuICAgICAgICA6ICAoKFNleHBsaWIwLlNleHAudCAtPiBhX18wNDRfKSAtPiAoU2V4cGxpYjAuU2V4cC50IC0+IGJfXzA0NV8pXG4gICAgICAgICAgICAtPiBTZXhwbGliMC5TZXhwLnQgLT4gKGFfXzA0NF8sIGJfXzA0NV8pIHQpIC0+XG4gICAgICBsZXQgZXJyb3Jfc291cmNlX18wMjVfID0gXCJzZXF1ZW5jZS5tbC5NZXJnZV93aXRoX2R1cGxpY2F0ZXNfZWxlbWVudC50XCIgaW5cbiAgICAgIGZ1biBfb2ZfYV9fMDIxXyBfb2ZfYl9fMDIyXyAtPiBmdW5jdGlvblxuICAgICAgICB8IFNleHBsaWIwLlNleHAuTGlzdFxuICAgICAgICAgICAgKFNleHBsaWIwLlNleHAuQXRvbSAoKFwibGVmdFwiIHwgXCJMZWZ0XCIpIGFzIF90YWdfXzAyOF8pIDo6IHNleHBfYXJnc19fMDI5XykgYXNcbiAgICAgICAgICBfc2V4cF9fMDI3XyAtPlxuICAgICAgICAgIChtYXRjaCBzZXhwX2FyZ3NfXzAyOV8gd2l0aFxuICAgICAgICAgICB8IFsgYXJnMF9fMDMwXyBdIC0+XG4gICAgICAgICAgICAgbGV0IHJlczBfXzAzMV8gPSBfb2ZfYV9fMDIxXyBhcmcwX18wMzBfIGluXG4gICAgICAgICAgICAgTGVmdCByZXMwX18wMzFfXG4gICAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX2luY29ycmVjdF9uX2FyZ3NcbiAgICAgICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDI1X1xuICAgICAgICAgICAgICAgX3RhZ19fMDI4X1xuICAgICAgICAgICAgICAgX3NleHBfXzAyN18pXG4gICAgICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0XG4gICAgICAgICAgICAoU2V4cGxpYjAuU2V4cC5BdG9tICgoXCJyaWdodFwiIHwgXCJSaWdodFwiKSBhcyBfdGFnX18wMzNfKSA6OiBzZXhwX2FyZ3NfXzAzNF8pIGFzXG4gICAgICAgICAgX3NleHBfXzAzMl8gLT5cbiAgICAgICAgICAobWF0Y2ggc2V4cF9hcmdzX18wMzRfIHdpdGhcbiAgICAgICAgICAgfCBbIGFyZzBfXzAzNV8gXSAtPlxuICAgICAgICAgICAgIGxldCByZXMwX18wMzZfID0gX29mX2JfXzAyMl8gYXJnMF9fMDM1XyBpblxuICAgICAgICAgICAgIFJpZ2h0IHJlczBfXzAzNl9cbiAgICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfaW5jb3JyZWN0X25fYXJnc1xuICAgICAgICAgICAgICAgZXJyb3Jfc291cmNlX18wMjVfXG4gICAgICAgICAgICAgICBfdGFnX18wMzNfXG4gICAgICAgICAgICAgICBfc2V4cF9fMDMyXylcbiAgICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3RcbiAgICAgICAgICAgIChTZXhwbGliMC5TZXhwLkF0b20gKChcImJvdGhcIiB8IFwiQm90aFwiKSBhcyBfdGFnX18wMzhfKSA6OiBzZXhwX2FyZ3NfXzAzOV8pIGFzXG4gICAgICAgICAgX3NleHBfXzAzN18gLT5cbiAgICAgICAgICAobWF0Y2ggc2V4cF9hcmdzX18wMzlfIHdpdGhcbiAgICAgICAgICAgfCBbIGFyZzBfXzA0MF87IGFyZzFfXzA0MV8gXSAtPlxuICAgICAgICAgICAgIGxldCByZXMwX18wNDJfID0gX29mX2FfXzAyMV8gYXJnMF9fMDQwX1xuICAgICAgICAgICAgIGFuZCByZXMxX18wNDNfID0gX29mX2JfXzAyMl8gYXJnMV9fMDQxXyBpblxuICAgICAgICAgICAgIEJvdGggKHJlczBfXzA0Ml8sIHJlczFfXzA0M18pXG4gICAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX2luY29ycmVjdF9uX2FyZ3NcbiAgICAgICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDI1X1xuICAgICAgICAgICAgICAgX3RhZ19fMDM4X1xuICAgICAgICAgICAgICAgX3NleHBfXzAzN18pXG4gICAgICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcImxlZnRcIiB8IFwiTGVmdFwiKSBhcyBzZXhwX18wMjZfIC0+XG4gICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfdGFrZXNfYXJncyBlcnJvcl9zb3VyY2VfXzAyNV8gc2V4cF9fMDI2X1xuICAgICAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJyaWdodFwiIHwgXCJSaWdodFwiKSBhcyBzZXhwX18wMjZfIC0+XG4gICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfdGFrZXNfYXJncyBlcnJvcl9zb3VyY2VfXzAyNV8gc2V4cF9fMDI2X1xuICAgICAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJib3RoXCIgfCBcIkJvdGhcIikgYXMgc2V4cF9fMDI2XyAtPlxuICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX3Rha2VzX2FyZ3MgZXJyb3Jfc291cmNlX18wMjVfIHNleHBfXzAyNl9cbiAgICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuTGlzdCBfIDo6IF8pIGFzIHNleHBfXzAyNF8gLT5cbiAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IubmVzdGVkX2xpc3RfaW52YWxpZF9zdW0gZXJyb3Jfc291cmNlX18wMjVfIHNleHBfXzAyNF9cbiAgICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgW10gYXMgc2V4cF9fMDI0XyAtPlxuICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5lbXB0eV9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDI1XyBzZXhwX18wMjRfXG4gICAgICAgIHwgc2V4cF9fMDI0XyAtPlxuICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci51bmV4cGVjdGVkX3N0YWcgZXJyb3Jfc291cmNlX18wMjVfIHNleHBfXzAyNF9cbiAgOztcblxuICBsZXQgc2V4cF9vZl90IDpcbiAgICAnYSAnYi5cbiAgICAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgIC0+ICgnYiAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgLT4gKCdhLCAnYikgdFxuICAgIC0+IFNleHBsaWIwLlNleHAudFxuICAgID1cbiAgICBmdW4gKHR5cGUgYV9fMDU2XyBiX18wNTdfKVxuICAgICAgICA6ICAoKGFfXzA1Nl8gLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAoYl9fMDU3XyAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAgICAgICAtPiAoYV9fMDU2XywgYl9fMDU3XykgdCAtPiBTZXhwbGliMC5TZXhwLnQpIC0+XG4gICAgICBmdW4gX29mX2FfXzA0Nl8gX29mX2JfXzA0N18gLT4gZnVuY3Rpb25cbiAgICAgICAgfCBMZWZ0IGFyZzBfXzA0OF8gLT5cbiAgICAgICAgICBsZXQgcmVzMF9fMDQ5XyA9IF9vZl9hX18wNDZfIGFyZzBfXzA0OF8gaW5cbiAgICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJMZWZ0XCI7IHJlczBfXzA0OV8gXVxuICAgICAgICB8IFJpZ2h0IGFyZzBfXzA1MF8gLT5cbiAgICAgICAgICBsZXQgcmVzMF9fMDUxXyA9IF9vZl9iX18wNDdfIGFyZzBfXzA1MF8gaW5cbiAgICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJSaWdodFwiOyByZXMwX18wNTFfIF1cbiAgICAgICAgfCBCb3RoIChhcmcwX18wNTJfLCBhcmcxX18wNTNfKSAtPlxuICAgICAgICAgIGxldCByZXMwX18wNTRfID0gX29mX2FfXzA0Nl8gYXJnMF9fMDUyX1xuICAgICAgICAgIGFuZCByZXMxX18wNTVfID0gX29mX2JfXzA0N18gYXJnMV9fMDUzXyBpblxuICAgICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIkJvdGhcIjsgcmVzMF9fMDU0XzsgcmVzMV9fMDU1XyBdXG4gIDs7XG5cbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6XG4gICAgICAgICAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgICAgIC0+ICdiIFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgICAgLT4gKCdhLCAnYikgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudClcbiAgICA9XG4gICAgZnVuIF8nYV9zZXhwX2dyYW1tYXIgXydiX3NleHBfZ3JhbW1hciAtPlxuICAgICAgeyB1bnR5cGVkID1cbiAgICAgICAgICBWYXJpYW50XG4gICAgICAgICAgICB7IGNhc2Vfc2Vuc2l0aXZpdHkgPSBDYXNlX3NlbnNpdGl2ZV9leGNlcHRfZmlyc3RfY2hhcmFjdGVyXG4gICAgICAgICAgICA7IGNsYXVzZXMgPVxuICAgICAgICAgICAgICAgIFsgTm9fdGFnXG4gICAgICAgICAgICAgICAgICAgIHsgbmFtZSA9IFwiTGVmdFwiXG4gICAgICAgICAgICAgICAgICAgIDsgY2xhdXNlX2tpbmQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgTGlzdF9jbGF1c2UgeyBhcmdzID0gQ29ucyAoXydhX3NleHBfZ3JhbW1hci51bnR5cGVkLCBFbXB0eSkgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOyBOb190YWdcbiAgICAgICAgICAgICAgICAgICAgeyBuYW1lID0gXCJSaWdodFwiXG4gICAgICAgICAgICAgICAgICAgIDsgY2xhdXNlX2tpbmQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgTGlzdF9jbGF1c2UgeyBhcmdzID0gQ29ucyAoXydiX3NleHBfZ3JhbW1hci51bnR5cGVkLCBFbXB0eSkgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOyBOb190YWdcbiAgICAgICAgICAgICAgICAgICAgeyBuYW1lID0gXCJCb3RoXCJcbiAgICAgICAgICAgICAgICAgICAgOyBjbGF1c2Vfa2luZCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBMaXN0X2NsYXVzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICB7IGFyZ3MgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIF8nYV9zZXhwX2dyYW1tYXIudW50eXBlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsIENvbnMgKF8nYl9zZXhwX2dyYW1tYXIudW50eXBlZCwgRW1wdHkpIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfVxuICAgICAgfVxuICA7O1xuXG4gIFtAQEBlbmRdXG5lbmRcblxubGV0IG1lcmdlX3dpdGhfZHVwbGljYXRlcyAoU2VxdWVuY2UgKHMxLCBuZXh0MSkpIChTZXF1ZW5jZSAoczIsIG5leHQyKSkgfmNvbXBhcmUgPVxuICBsZXQgdW5zaGFkb3dlZF9jb21wYXJlID0gY29tcGFyZSBpblxuICBsZXQgb3BlbiBNZXJnZV93aXRoX2R1cGxpY2F0ZXNfZWxlbWVudCBpblxuICBsZXQgbmV4dCA9IGZ1bmN0aW9uXG4gICAgfCBTa2lwIHMxLCBzMiAtPiBTa2lwIChuZXh0MSBzMSwgczIpXG4gICAgfCBzMSwgU2tpcCBzMiAtPiBTa2lwIChzMSwgbmV4dDIgczIpXG4gICAgfCAoWWllbGQgKGEsIHMxJykgYXMgczEpLCAoWWllbGQgKGIsIHMyJykgYXMgczIpIC0+XG4gICAgICBsZXQgY29tcGFyaXNvbiA9IHVuc2hhZG93ZWRfY29tcGFyZSBhIGIgaW5cbiAgICAgIGlmIGNvbXBhcmlzb24gPCAwXG4gICAgICB0aGVuIFlpZWxkIChMZWZ0IGEsIChTa2lwIHMxJywgczIpKVxuICAgICAgZWxzZSBpZiBjb21wYXJpc29uID0gMFxuICAgICAgdGhlbiBZaWVsZCAoQm90aCAoYSwgYiksIChTa2lwIHMxJywgU2tpcCBzMicpKVxuICAgICAgZWxzZSBZaWVsZCAoUmlnaHQgYiwgKHMxLCBTa2lwIHMyJykpXG4gICAgfCBEb25lLCBEb25lIC0+IERvbmVcbiAgICB8IFlpZWxkIChhLCBzMSksIERvbmUgLT4gWWllbGQgKExlZnQgYSwgKFNraXAgczEsIERvbmUpKVxuICAgIHwgRG9uZSwgWWllbGQgKGIsIHMyKSAtPiBZaWVsZCAoUmlnaHQgYiwgKERvbmUsIFNraXAgczIpKVxuICBpblxuICBTZXF1ZW5jZSAoKFNraXAgczEsIFNraXAgczIpLCBuZXh0KVxuOztcblxubGV0IG1lcmdlX2RlZHVwZWRfYW5kX3NvcnRlZCBzMSBzMiB+Y29tcGFyZSA9XG4gIG1hcCAobWVyZ2Vfd2l0aF9kdXBsaWNhdGVzIHMxIHMyIH5jb21wYXJlKSB+ZjooZnVuY3Rpb25cbiAgICB8IExlZnQgeCB8IFJpZ2h0IHggfCBCb3RoICh4LCBfKSAtPiB4KVxuOztcblxubGV0IChtZXJnZSBbQGRlcHJlY2F0ZWRcbiAgICAgICBcIltzaW5jZSAyMDIxLTA3XSBGb3IgaWRlbnRpY2FsIGJlaGF2aW9yLCB1c2UgXFxcbiAgICAgICAgW1NlcXVlbmNlLm1lcmdlX2RlZHVwZWRfYW5kX3NvcnRlZF0sIGJ1dCBjb25zaWRlciB1c2luZyBcXFxuICAgICAgICBbU2VxdWVuY2UubWVyZ2Vfc29ydGVkXSBpbnN0ZWFkLlwiXSlcbiAgPVxuICBtZXJnZV9kZWR1cGVkX2FuZF9zb3J0ZWRcbjs7XG5cbmxldCBtZXJnZV9zb3J0ZWQgKFNlcXVlbmNlIChzMSwgbmV4dDEpKSAoU2VxdWVuY2UgKHMyLCBuZXh0MikpIH5jb21wYXJlID1cbiAgbGV0IG5leHQgPSBmdW5jdGlvblxuICAgIHwgU2tpcCBzMSwgczIgLT4gU2tpcCAobmV4dDEgczEsIHMyKVxuICAgIHwgczEsIFNraXAgczIgLT4gU2tpcCAoczEsIG5leHQyIHMyKVxuICAgIHwgKFlpZWxkIChhLCBzMScpIGFzIHMxKSwgKFlpZWxkIChiLCBzMicpIGFzIHMyKSAtPlxuICAgICAgbGV0IGNvbXBhcmlzb24gPSBjb21wYXJlIGEgYiBpblxuICAgICAgaWYgY29tcGFyaXNvbiA8PSAwIHRoZW4gWWllbGQgKGEsIChTa2lwIHMxJywgczIpKSBlbHNlIFlpZWxkIChiLCAoczEsIFNraXAgczInKSlcbiAgICB8IERvbmUsIERvbmUgLT4gRG9uZVxuICAgIHwgWWllbGQgKGEsIHMxKSwgRG9uZSAtPiBZaWVsZCAoYSwgKFNraXAgczEsIERvbmUpKVxuICAgIHwgRG9uZSwgWWllbGQgKGIsIHMyKSAtPiBZaWVsZCAoYiwgKERvbmUsIFNraXAgczIpKVxuICBpblxuICBTZXF1ZW5jZSAoKFNraXAgczEsIFNraXAgczIpLCBuZXh0KVxuOztcblxubGV0IGhkIHMgPVxuICBsZXQgcmVjIGxvb3AgcyBuZXh0ID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiBOb25lXG4gICAgfCBTa2lwIHMgLT4gbG9vcCBzIG5leHRcbiAgICB8IFlpZWxkIChhLCBfKSAtPiBTb21lIGFcbiAgaW5cbiAgbWF0Y2ggcyB3aXRoXG4gIHwgU2VxdWVuY2UgKHMsIG5leHQpIC0+IGxvb3AgcyBuZXh0XG47O1xuXG5sZXQgaGRfZXhuIHMgPVxuICBtYXRjaCBoZCBzIHdpdGhcbiAgfCBOb25lIC0+IGZhaWx3aXRoIFwiaGRfZXhuXCJcbiAgfCBTb21lIGEgLT4gYVxuOztcblxubGV0IHRsIHMgPVxuICBsZXQgcmVjIGxvb3AgcyBuZXh0ID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiBOb25lXG4gICAgfCBTa2lwIHMgLT4gbG9vcCBzIG5leHRcbiAgICB8IFlpZWxkIChfLCBhKSAtPiBTb21lIGFcbiAgaW5cbiAgbWF0Y2ggcyB3aXRoXG4gIHwgU2VxdWVuY2UgKHMsIG5leHQpIC0+XG4gICAgKG1hdGNoIGxvb3AgcyBuZXh0IHdpdGhcbiAgICAgfCBOb25lIC0+IE5vbmVcbiAgICAgfCBTb21lIHMgLT4gU29tZSAoU2VxdWVuY2UgKHMsIG5leHQpKSlcbjs7XG5cbmxldCB0bF9lYWdlcmx5X2V4biBzID1cbiAgbWF0Y2ggdGwgcyB3aXRoXG4gIHwgTm9uZSAtPiBmYWlsd2l0aCBcIlNlcXVlbmNlLnRsX2V4blwiXG4gIHwgU29tZSBzIC0+IHNcbjs7XG5cbmxldCBsaWZ0X2lkZW50aXR5IG5leHQgcyA9XG4gIG1hdGNoIG5leHQgcyB3aXRoXG4gIHwgRG9uZSAtPiBEb25lXG4gIHwgU2tpcCBzIC0+IFNraXAgKGBJZGVudGl0eSBzKVxuICB8IFlpZWxkIChhLCBzKSAtPiBZaWVsZCAoYSwgYElkZW50aXR5IHMpXG47O1xuXG5sZXQgbmV4dCBzID1cbiAgbGV0IHJlYyBsb29wIHMgbmV4dCA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gTm9uZVxuICAgIHwgU2tpcCBzIC0+IGxvb3AgcyBuZXh0XG4gICAgfCBZaWVsZCAoYSwgcykgLT4gU29tZSAoYSwgU2VxdWVuY2UgKHMsIG5leHQpKVxuICBpblxuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSAocywgbmV4dCkgLT4gbG9vcCBzIG5leHRcbjs7XG5cbmxldCBmaWx0ZXJfb3B0IHMgPVxuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSAocywgbmV4dCkgLT5cbiAgICBTZXF1ZW5jZVxuICAgICAgKCBzXG4gICAgICAsIGZ1biBzIC0+XG4gICAgICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgICAgIHwgRG9uZSAtPiBEb25lXG4gICAgICAgIHwgU2tpcCBzIC0+IFNraXAgc1xuICAgICAgICB8IFlpZWxkIChOb25lLCBzKSAtPiBTa2lwIHNcbiAgICAgICAgfCBZaWVsZCAoU29tZSBhLCBzKSAtPiBZaWVsZCAoYSwgcykgKVxuOztcblxubGV0IGZpbHRlcl9tYXAgcyB+ZiA9IGZpbHRlcl9vcHQgKG1hcCBzIH5mKVxubGV0IGZpbHRlcl9tYXBpIHMgfmYgPSBmaWx0ZXJfbWFwIChtYXBpIHMgfmY6KGZ1biBpIHMgLT4gaSwgcykpIH5mOihmdW4gKGksIHMpIC0+IGYgaSBzKVxuXG5sZXQgc3BsaXRfbiBzIG4gPVxuICBsZXQgcmVjIGxvb3AgcyBpIGFjY3VtIG5leHQgPVxuICAgIGlmIGkgPD0gMFxuICAgIHRoZW4gTGlzdC5yZXYgYWNjdW0sIFNlcXVlbmNlIChzLCBuZXh0KVxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICAgIHwgRG9uZSAtPiBMaXN0LnJldiBhY2N1bSwgZW1wdHlcbiAgICAgIHwgU2tpcCBzIC0+IGxvb3AgcyBpIGFjY3VtIG5leHRcbiAgICAgIHwgWWllbGQgKGEsIHMpIC0+IGxvb3AgcyAoaSAtIDEpIChhIDo6IGFjY3VtKSBuZXh0KVxuICBpblxuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSAocywgbmV4dCkgLT4gbG9vcCBzIG4gW10gbmV4dFxuOztcblxubGV0IGNodW5rc19leG4gdCBuID1cbiAgaWYgbiA8PSAwXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJTZXF1ZW5jZS5jaHVua3NfZXhuXCJcbiAgZWxzZVxuICAgIHVuZm9sZF9zdGVwIH5pbml0OnQgfmY6KGZ1biB0IC0+XG4gICAgICBtYXRjaCBzcGxpdF9uIHQgbiB3aXRoXG4gICAgICB8IFtdLCBfZW1wdHkgLT4gRG9uZVxuICAgICAgfCAoXyA6OiBfIGFzIHhzKSwgdCAtPiBZaWVsZCAoeHMsIHQpKVxuOztcblxubGV0IGZpbmRpIHMgfmYgPSBmaW5kIChtYXBpIHMgfmY6KGZ1biBpIHMgLT4gaSwgcykpIH5mOihmdW4gKGksIHMpIC0+IGYgaSBzKVxuXG5sZXQgZmluZF9leG4gcyB+ZiA9XG4gIG1hdGNoIGZpbmQgcyB+ZiB3aXRoXG4gIHwgTm9uZSAtPiBmYWlsd2l0aCBcIlNlcXVlbmNlLmZpbmRfZXhuXCJcbiAgfCBTb21lIHggLT4geFxuOztcblxubGV0IGFwcGVuZCBzMSBzMiA9XG4gIG1hdGNoIHMxLCBzMiB3aXRoXG4gIHwgU2VxdWVuY2UgKHMxLCBuZXh0MSksIFNlcXVlbmNlIChzMiwgbmV4dDIpIC0+XG4gICAgU2VxdWVuY2VcbiAgICAgICggYEZpcnN0X2xpc3QgczFcbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBgRmlyc3RfbGlzdCBzMSAtPlxuICAgICAgICAgIChtYXRjaCBuZXh0MSBzMSB3aXRoXG4gICAgICAgICAgIHwgRG9uZSAtPiBTa2lwIChgU2Vjb25kX2xpc3QgczIpXG4gICAgICAgICAgIHwgU2tpcCBzMSAtPiBTa2lwIChgRmlyc3RfbGlzdCBzMSlcbiAgICAgICAgICAgfCBZaWVsZCAoYSwgczEpIC0+IFlpZWxkIChhLCBgRmlyc3RfbGlzdCBzMSkpXG4gICAgICAgIHwgYFNlY29uZF9saXN0IHMyIC0+XG4gICAgICAgICAgKG1hdGNoIG5leHQyIHMyIHdpdGhcbiAgICAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgICAgfCBTa2lwIHMyIC0+IFNraXAgKGBTZWNvbmRfbGlzdCBzMilcbiAgICAgICAgICAgfCBZaWVsZCAoYSwgczIpIC0+IFlpZWxkIChhLCBgU2Vjb25kX2xpc3QgczIpKSApXG47O1xuXG5sZXQgY29uY2F0X21hcCBzIH5mID0gYmluZCBzIH5mXG5sZXQgY29uY2F0IHMgPSBjb25jYXRfbWFwIHMgfmY6Rm4uaWRcbmxldCBjb25jYXRfbWFwaSBzIH5mID0gY29uY2F0X21hcCAobWFwaSBzIH5mOihmdW4gaSBzIC0+IGksIHMpKSB+ZjooZnVuIChpLCBzKSAtPiBmIGkgcylcblxubGV0IHppcCAoU2VxdWVuY2UgKHMxLCBuZXh0MSkpIChTZXF1ZW5jZSAoczIsIG5leHQyKSkgPVxuICBsZXQgbmV4dCA9IGZ1bmN0aW9uXG4gICAgfCBZaWVsZCAoYSwgczEpLCBZaWVsZCAoYiwgczIpIC0+IFlpZWxkICgoYSwgYiksIChTa2lwIHMxLCBTa2lwIHMyKSlcbiAgICB8IERvbmUsIF8gfCBfLCBEb25lIC0+IERvbmVcbiAgICB8IFNraXAgczEsIHMyIC0+IFNraXAgKG5leHQxIHMxLCBzMilcbiAgICB8IHMxLCBTa2lwIHMyIC0+IFNraXAgKHMxLCBuZXh0MiBzMilcbiAgaW5cbiAgU2VxdWVuY2UgKChTa2lwIHMxLCBTa2lwIHMyKSwgbmV4dClcbjs7XG5cbmxldCB6aXBfZnVsbCAoU2VxdWVuY2UgKHMxLCBuZXh0MSkpIChTZXF1ZW5jZSAoczIsIG5leHQyKSkgPVxuICBsZXQgbmV4dCA9IGZ1bmN0aW9uXG4gICAgfCBZaWVsZCAoYSwgczEpLCBZaWVsZCAoYiwgczIpIC0+IFlpZWxkIChgQm90aCAoYSwgYiksIChTa2lwIHMxLCBTa2lwIHMyKSlcbiAgICB8IERvbmUsIERvbmUgLT4gRG9uZVxuICAgIHwgU2tpcCBzMSwgczIgLT4gU2tpcCAobmV4dDEgczEsIHMyKVxuICAgIHwgczEsIFNraXAgczIgLT4gU2tpcCAoczEsIG5leHQyIHMyKVxuICAgIHwgRG9uZSwgWWllbGQgKGIsIHMyKSAtPiBZaWVsZCAoYFJpZ2h0IGIsIChEb25lLCBuZXh0MiBzMikpXG4gICAgfCBZaWVsZCAoYSwgczEpLCBEb25lIC0+IFlpZWxkIChgTGVmdCBhLCAobmV4dDEgczEsIERvbmUpKVxuICBpblxuICBTZXF1ZW5jZSAoKFNraXAgczEsIFNraXAgczIpLCBuZXh0KVxuOztcblxubGV0IGJvdW5kZWRfbGVuZ3RoIChTZXF1ZW5jZSAoc2VlZCwgbmV4dCkpIH5hdF9tb3N0ID1cbiAgbGV0IHJlYyBsb29wIGkgc2VlZCBuZXh0ID1cbiAgICBpZiBpID4gYXRfbW9zdFxuICAgIHRoZW4gYEdyZWF0ZXJcbiAgICBlbHNlIChcbiAgICAgIG1hdGNoIG5leHQgc2VlZCB3aXRoXG4gICAgICB8IERvbmUgLT4gYElzIGlcbiAgICAgIHwgU2tpcCBzZWVkIC0+IGxvb3AgaSBzZWVkIG5leHRcbiAgICAgIHwgWWllbGQgKF8sIHNlZWQpIC0+IGxvb3AgKGkgKyAxKSBzZWVkIG5leHQpXG4gIGluXG4gIGxvb3AgMCBzZWVkIG5leHRcbjs7XG5cbmxldCBsZW5ndGhfaXNfYm91bmRlZF9ieSA/KG1pbiA9IC0xKSA/bWF4IHQgPVxuICBsZXQgbGVuZ3RoX2lzX2F0X2xlYXN0IChTZXF1ZW5jZSAocywgbmV4dCkpID1cbiAgICBsZXQgcmVjIGxvb3AgcyBhY2MgPVxuICAgICAgaWYgYWNjID49IG1pblxuICAgICAgdGhlbiB0cnVlXG4gICAgICBlbHNlIChcbiAgICAgICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICAgICAgfCBEb25lIC0+IGZhbHNlXG4gICAgICAgIHwgU2tpcCBzIC0+IGxvb3AgcyBhY2NcbiAgICAgICAgfCBZaWVsZCAoXywgcykgLT4gbG9vcCBzIChhY2MgKyAxKSlcbiAgICBpblxuICAgIGxvb3AgcyAwXG4gIGluXG4gIG1hdGNoIG1heCB3aXRoXG4gIHwgTm9uZSAtPiBsZW5ndGhfaXNfYXRfbGVhc3QgdFxuICB8IFNvbWUgbWF4IC0+XG4gICAgKG1hdGNoIGJvdW5kZWRfbGVuZ3RoIHQgfmF0X21vc3Q6bWF4IHdpdGhcbiAgICAgfCBgSXMgbGVuIHdoZW4gbGVuID49IG1pbiAtPiB0cnVlXG4gICAgIHwgXyAtPiBmYWxzZSlcbjs7XG5cbmxldCBpdGVyaSBzIH5mID0gaXRlciAobWFwaSBzIH5mOihmdW4gaSBzIC0+IGksIHMpKSB+ZjooZnVuIChpLCBzKSAtPiBmIGkgcylcblxubGV0IGZvbGRpIHMgfmluaXQgfmYgPVxuICBmb2xkIH5pbml0IChtYXBpIHMgfmY6KGZ1biBpIHMgLT4gaSwgcykpIH5mOihmdW4gYWNjIChpLCBzKSAtPiBmIGkgYWNjIHMpXG47O1xuXG5sZXQgcmVkdWNlIHMgfmYgPVxuICBtYXRjaCBuZXh0IHMgd2l0aFxuICB8IE5vbmUgLT4gTm9uZVxuICB8IFNvbWUgKGEsIHMpIC0+IFNvbWUgKGZvbGQgcyB+aW5pdDphIH5mKVxuOztcblxubGV0IHJlZHVjZV9leG4gcyB+ZiA9XG4gIG1hdGNoIHJlZHVjZSBzIH5mIHdpdGhcbiAgfCBOb25lIC0+IGZhaWx3aXRoIFwiU2VxdWVuY2UucmVkdWNlX2V4blwiXG4gIHwgU29tZSByZXMgLT4gcmVzXG47O1xuXG5sZXQgZ3JvdXAgKFNlcXVlbmNlIChzLCBuZXh0KSkgfmJyZWFrID1cbiAgdW5mb2xkX3N0ZXBcbiAgICB+aW5pdDooU29tZSAoW10sIHMpKVxuICAgIH5mOihmdW5jdGlvblxuICAgICAgfCBOb25lIC0+IERvbmVcbiAgICAgIHwgU29tZSAoYWNjLCBzKSAtPlxuICAgICAgICAobWF0Y2ggYWNjLCBuZXh0IHMgd2l0aFxuICAgICAgICAgfCBfLCBTa2lwIHMgLT4gU2tpcCAoU29tZSAoYWNjLCBzKSlcbiAgICAgICAgIHwgW10sIERvbmUgLT4gRG9uZVxuICAgICAgICAgfCBhY2MsIERvbmUgLT4gWWllbGQgKExpc3QucmV2IGFjYywgTm9uZSlcbiAgICAgICAgIHwgW10sIFlpZWxkIChjdXIsIHMpIC0+IFNraXAgKFNvbWUgKFsgY3VyIF0sIHMpKVxuICAgICAgICAgfCAocHJldiA6OiBfIGFzIGFjYyksIFlpZWxkIChjdXIsIHMpIC0+XG4gICAgICAgICAgIGlmIGJyZWFrIHByZXYgY3VyXG4gICAgICAgICAgIHRoZW4gWWllbGQgKExpc3QucmV2IGFjYywgU29tZSAoWyBjdXIgXSwgcykpXG4gICAgICAgICAgIGVsc2UgU2tpcCAoU29tZSAoY3VyIDo6IGFjYywgcykpKSlcbjs7XG5cbmxldCBmaW5kX2NvbnNlY3V0aXZlX2R1cGxpY2F0ZSAoU2VxdWVuY2UgKHMsIG5leHQpKSB+ZXF1YWwgPVxuICBsZXQgcmVjIGxvb3AgbGFzdF9lbHQgcyA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gTm9uZVxuICAgIHwgU2tpcCBzIC0+IGxvb3AgbGFzdF9lbHQgc1xuICAgIHwgWWllbGQgKGEsIHMpIC0+XG4gICAgICAobWF0Y2ggbGFzdF9lbHQgd2l0aFxuICAgICAgIHwgU29tZSBiIHdoZW4gZXF1YWwgYSBiIC0+IFNvbWUgKGIsIGEpXG4gICAgICAgfCBOb25lIHwgU29tZSBfIC0+IGxvb3AgKFNvbWUgYSkgcylcbiAgaW5cbiAgbG9vcCBOb25lIHNcbjs7XG5cbmxldCByZW1vdmVfY29uc2VjdXRpdmVfZHVwbGljYXRlcyBzIH5lcXVhbCA9XG4gIHVuZm9sZF93aXRoIHMgfmluaXQ6Tm9uZSB+ZjooZnVuIHByZXYgYSAtPlxuICAgIG1hdGNoIHByZXYgd2l0aFxuICAgIHwgU29tZSBiIHdoZW4gZXF1YWwgYSBiIC0+IFNraXAgKFNvbWUgYSlcbiAgICB8IE5vbmUgfCBTb21lIF8gLT4gWWllbGQgKGEsIFNvbWUgYSkpXG47O1xuXG5sZXQgY291bnQgcyB+ZiA9IGxlbmd0aCAoZmlsdGVyIHMgfmYpXG5sZXQgY291bnRpIHQgfmYgPSBsZW5ndGggKGZpbHRlcmkgdCB+ZilcbmxldCBzdW0gbSB0IH5mID0gQ29udGFpbmVyLnN1bSB+Zm9sZCBtIHQgfmZcbmxldCBtaW5fZWx0IHQgfmNvbXBhcmUgPSBDb250YWluZXIubWluX2VsdCB+Zm9sZCB0IH5jb21wYXJlXG5sZXQgbWF4X2VsdCB0IH5jb21wYXJlID0gQ29udGFpbmVyLm1heF9lbHQgfmZvbGQgdCB+Y29tcGFyZVxuXG5sZXQgaW5pdCBuIH5mID1cbiAgdW5mb2xkX3N0ZXAgfmluaXQ6MCB+ZjooZnVuIGkgLT4gaWYgaSA+PSBuIHRoZW4gRG9uZSBlbHNlIFlpZWxkIChmIGksIGkgKyAxKSlcbjs7XG5cbmxldCBzdWIgcyB+cG9zIH5sZW4gPVxuICBpZiBwb3MgPCAwIHx8IGxlbiA8IDAgdGhlbiBmYWlsd2l0aCBcIlNlcXVlbmNlLnN1YlwiO1xuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSAocywgbmV4dCkgLT5cbiAgICBTZXF1ZW5jZVxuICAgICAgKCAoMCwgcylcbiAgICAgICwgZnVuIChpLCBzKSAtPlxuICAgICAgICBpZiBpIC0gcG9zID49IGxlblxuICAgICAgICB0aGVuIERvbmVcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICAgICAgICB8IERvbmUgLT4gRG9uZVxuICAgICAgICAgIHwgU2tpcCBzIC0+IFNraXAgKGksIHMpXG4gICAgICAgICAgfCBZaWVsZCAoYSwgcykgd2hlbiBpID49IHBvcyAtPiBZaWVsZCAoYSwgKGkgKyAxLCBzKSlcbiAgICAgICAgICB8IFlpZWxkIChfLCBzKSAtPiBTa2lwIChpICsgMSwgcykpIClcbjs7XG5cbmxldCB0YWtlIHMgbGVuID1cbiAgaWYgbGVuIDwgMCB0aGVuIGZhaWx3aXRoIFwiU2VxdWVuY2UudGFrZVwiO1xuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSAocywgbmV4dCkgLT5cbiAgICBTZXF1ZW5jZVxuICAgICAgKCAoMCwgcylcbiAgICAgICwgZnVuIChpLCBzKSAtPlxuICAgICAgICBpZiBpID49IGxlblxuICAgICAgICB0aGVuIERvbmVcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICAgICAgICB8IERvbmUgLT4gRG9uZVxuICAgICAgICAgIHwgU2tpcCBzIC0+IFNraXAgKGksIHMpXG4gICAgICAgICAgfCBZaWVsZCAoYSwgcykgLT4gWWllbGQgKGEsIChpICsgMSwgcykpKSApXG47O1xuXG5sZXQgZHJvcCBzIGxlbiA9XG4gIGlmIGxlbiA8IDAgdGhlbiBmYWlsd2l0aCBcIlNlcXVlbmNlLmRyb3BcIjtcbiAgbWF0Y2ggcyB3aXRoXG4gIHwgU2VxdWVuY2UgKHMsIG5leHQpIC0+XG4gICAgU2VxdWVuY2VcbiAgICAgICggKDAsIHMpXG4gICAgICAsIGZ1biAoaSwgcykgLT5cbiAgICAgICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgfCBTa2lwIHMgLT4gU2tpcCAoaSwgcylcbiAgICAgICAgfCBZaWVsZCAoYSwgcykgd2hlbiBpID49IGxlbiAtPiBZaWVsZCAoYSwgKGkgKyAxLCBzKSlcbiAgICAgICAgfCBZaWVsZCAoXywgcykgLT4gU2tpcCAoaSArIDEsIHMpIClcbjs7XG5cbmxldCB0YWtlX3doaWxlIHMgfmYgPVxuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSAocywgbmV4dCkgLT5cbiAgICBTZXF1ZW5jZVxuICAgICAgKCBzXG4gICAgICAsIGZ1biBzIC0+XG4gICAgICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgICAgIHwgRG9uZSAtPiBEb25lXG4gICAgICAgIHwgU2tpcCBzIC0+IFNraXAgc1xuICAgICAgICB8IFlpZWxkIChhLCBzKSB3aGVuIGYgYSAtPiBZaWVsZCAoYSwgcylcbiAgICAgICAgfCBZaWVsZCAoXywgXykgLT4gRG9uZSApXG47O1xuXG5sZXQgZHJvcF93aGlsZSBzIH5mID1cbiAgbWF0Y2ggcyB3aXRoXG4gIHwgU2VxdWVuY2UgKHMsIG5leHQpIC0+XG4gICAgU2VxdWVuY2VcbiAgICAgICggYERyb3BwaW5nIHNcbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBgRHJvcHBpbmcgcyAtPlxuICAgICAgICAgIChtYXRjaCBuZXh0IHMgd2l0aFxuICAgICAgICAgICB8IERvbmUgLT4gRG9uZVxuICAgICAgICAgICB8IFNraXAgcyAtPiBTa2lwIChgRHJvcHBpbmcgcylcbiAgICAgICAgICAgfCBZaWVsZCAoYSwgcykgd2hlbiBmIGEgLT4gU2tpcCAoYERyb3BwaW5nIHMpXG4gICAgICAgICAgIHwgWWllbGQgKGEsIHMpIC0+IFlpZWxkIChhLCBgSWRlbnRpdHkgcykpXG4gICAgICAgIHwgYElkZW50aXR5IHMgLT4gbGlmdF9pZGVudGl0eSBuZXh0IHMgKVxuOztcblxubGV0IHNoaWZ0X3JpZ2h0IHMgeCA9XG4gIG1hdGNoIHMgd2l0aFxuICB8IFNlcXVlbmNlIChzZWVkLCBuZXh0KSAtPlxuICAgIFNlcXVlbmNlXG4gICAgICAoIGBDb25zaW5nIChzZWVkLCB4KVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IGBDb25zaW5nIChzZWVkLCB4KSAtPiBZaWVsZCAoeCwgYElkZW50aXR5IHNlZWQpXG4gICAgICAgIHwgYElkZW50aXR5IHMgLT4gbGlmdF9pZGVudGl0eSBuZXh0IHMgKVxuOztcblxubGV0IHNoaWZ0X3JpZ2h0X3dpdGhfbGlzdCBzIGwgPSBhcHBlbmQgKG9mX2xpc3QgbCkgc1xubGV0IHNoaWZ0X2xlZnQgPSBkcm9wXG5cbm1vZHVsZSBJbmZpeCA9IHN0cnVjdFxuICBsZXQgKCBAICkgPSBhcHBlbmRcbmVuZFxuXG5sZXQgaW50ZXJzcGVyc2UgcyB+c2VwID1cbiAgbWF0Y2ggcyB3aXRoXG4gIHwgU2VxdWVuY2UgKHMsIG5leHQpIC0+XG4gICAgU2VxdWVuY2VcbiAgICAgICggYEluaXQgc1xuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IGBJbml0IHMgLT5cbiAgICAgICAgICAobWF0Y2ggbmV4dCBzIHdpdGhcbiAgICAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgICAgfCBTa2lwIHMgLT4gU2tpcCAoYEluaXQgcylcbiAgICAgICAgICAgfCBZaWVsZCAoYSwgcykgLT4gWWllbGQgKGEsIGBSdW5uaW5nIHMpKVxuICAgICAgICB8IGBSdW5uaW5nIHMgLT5cbiAgICAgICAgICAobWF0Y2ggbmV4dCBzIHdpdGhcbiAgICAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgICAgfCBTa2lwIHMgLT4gU2tpcCAoYFJ1bm5pbmcgcylcbiAgICAgICAgICAgfCBZaWVsZCAoYSwgcykgLT4gWWllbGQgKHNlcCwgYFB1dHRpbmcgKGEsIHMpKSlcbiAgICAgICAgfCBgUHV0dGluZyAoYSwgcykgLT4gWWllbGQgKGEsIGBSdW5uaW5nIHMpIClcbjs7XG5cbmxldCByZXBlYXQgeCA9IHVuZm9sZF9zdGVwIH5pbml0OnggfmY6KGZ1biB4IC0+IFlpZWxkICh4LCB4KSlcblxubGV0IGN5Y2xlX2xpc3RfZXhuIHhzID1cbiAgaWYgTGlzdC5pc19lbXB0eSB4cyB0aGVuIGludmFsaWRfYXJnIFwiU2VxdWVuY2UuY3ljbGVfbGlzdF9leG5cIjtcbiAgbGV0IHMgPSBvZl9saXN0IHhzIGluXG4gIGNvbmNhdF9tYXAgfmY6KGZ1biAoKSAtPiBzKSAocmVwZWF0ICgpKVxuOztcblxubGV0IGNhcnRlc2lhbl9wcm9kdWN0IHNhIHNiID0gY29uY2F0X21hcCBzYSB+ZjooZnVuIGEgLT4gemlwIChyZXBlYXQgYSkgc2IpXG5sZXQgc2luZ2xldG9uIHggPSByZXR1cm4geFxuXG5sZXQgZGVsYXllZF9mb2xkIHMgfmluaXQgfmYgfmZpbmlzaCA9XG4gIEV4cGVydC5kZWxheWVkX2ZvbGRfc3RlcCBzIH5pbml0IH5maW5pc2ggfmY6KGZ1biBhY2Mgb3B0aW9uIH5rIC0+XG4gICAgbWF0Y2ggb3B0aW9uIHdpdGhcbiAgICB8IE5vbmUgLT4gayBhY2NcbiAgICB8IFNvbWUgYSAtPiBmIGFjYyBhIH5rKVxuOztcblxubGV0IGZvbGRfbSB+YmluZCB+cmV0dXJuIHQgfmluaXQgfmYgPVxuICBFeHBlcnQuZGVsYXllZF9mb2xkX3N0ZXBcbiAgICB0XG4gICAgfmluaXRcbiAgICB+ZjooZnVuIGFjYyBvcHRpb24gfmsgLT5cbiAgICAgIG1hdGNoIG9wdGlvbiB3aXRoXG4gICAgICB8IE5vbmUgLT4gYmluZCAocmV0dXJuIGFjYykgfmY6a1xuICAgICAgfCBTb21lIGEgLT4gYmluZCAoZiBhY2MgYSkgfmY6aylcbiAgICB+ZmluaXNoOnJldHVyblxuOztcblxubGV0IGl0ZXJfbSB+YmluZCB+cmV0dXJuIHQgfmYgPVxuICBFeHBlcnQuZGVsYXllZF9mb2xkX3N0ZXBcbiAgICB0XG4gICAgfmluaXQ6KClcbiAgICB+ZjooZnVuICgpIG9wdGlvbiB+ayAtPlxuICAgICAgbWF0Y2ggb3B0aW9uIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBiaW5kIChyZXR1cm4gKCkpIH5mOmtcbiAgICAgIHwgU29tZSBhIC0+IGJpbmQgKGYgYSkgfmY6aylcbiAgICB+ZmluaXNoOnJldHVyblxuOztcblxubGV0IGZvbGRfdW50aWwgcyB+aW5pdCB+ZiB+ZmluaXNoID1cbiAgbGV0IHJlYyBsb29wIHMgbmV4dCBmIGFjYyA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gZmluaXNoIGFjY1xuICAgIHwgU2tpcCBzIC0+IGxvb3AgcyBuZXh0IGYgYWNjXG4gICAgfCBZaWVsZCAoYSwgcykgLT5cbiAgICAgIChtYXRjaCAoZiBhY2MgYSA6ICgnYSwgJ2IpIENvbnRpbnVlX29yX3N0b3AudCkgd2l0aFxuICAgICAgIHwgU3RvcCB4IC0+IHhcbiAgICAgICB8IENvbnRpbnVlIGFjYyAtPiBsb29wIHMgbmV4dCBmIGFjYylcbiAgaW5cbiAgbWF0Y2ggcyB3aXRoXG4gIHwgU2VxdWVuY2UgKHMsIG5leHQpIC0+IGxvb3AgcyBuZXh0IGYgaW5pdFxuOztcblxubGV0IGZvbGRfcmVzdWx0IHMgfmluaXQgfmYgPVxuICBsZXQgcmVjIGxvb3AgcyBuZXh0IGYgYWNjID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiBSZXN1bHQucmV0dXJuIGFjY1xuICAgIHwgU2tpcCBzIC0+IGxvb3AgcyBuZXh0IGYgYWNjXG4gICAgfCBZaWVsZCAoYSwgcykgLT5cbiAgICAgIChtYXRjaCAoZiBhY2MgYSA6IChfLCBfKSBSZXN1bHQudCkgd2l0aFxuICAgICAgIHwgRXJyb3IgXyBhcyBlIC0+IGVcbiAgICAgICB8IE9rIGFjYyAtPiBsb29wIHMgbmV4dCBmIGFjYylcbiAgaW5cbiAgbWF0Y2ggcyB3aXRoXG4gIHwgU2VxdWVuY2UgKHMsIG5leHQpIC0+IGxvb3AgcyBuZXh0IGYgaW5pdFxuOztcblxubGV0IGZvcmNlX2VhZ2VybHkgdCA9IG9mX2xpc3QgKHRvX2xpc3QgdClcblxubGV0IG1lbW9pemUgKHR5cGUgYSkgKFNlcXVlbmNlIChzLCBuZXh0KSkgPVxuICBsZXQgbW9kdWxlIE0gPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPSBUIG9mIChhLCB0KSBTdGVwLnQgTGF6eS50XG4gIGVuZFxuICBpblxuICBsZXQgcmVjIG1lbW9pemUgcyA9IE0uVCAobGF6eSAoZmluZF9zdGVwIHMpKVxuICBhbmQgZmluZF9zdGVwIHMgPVxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IERvbmVcbiAgICB8IFNraXAgcyAtPiBmaW5kX3N0ZXAgc1xuICAgIHwgWWllbGQgKGEsIHMpIC0+IFlpZWxkIChhLCBtZW1vaXplIHMpXG4gIGluXG4gIFNlcXVlbmNlIChtZW1vaXplIHMsIGZ1biAoTS5UIGwpIC0+IExhenkuZm9yY2UgbClcbjs7XG5cbmxldCBkcm9wX2VhZ2VybHkgcyBsZW4gPVxuICBsZXQgcmVjIGxvb3AgaSB+bGVuIHMgbmV4dCA9XG4gICAgaWYgaSA+PSBsZW5cbiAgICB0aGVuIFNlcXVlbmNlIChzLCBuZXh0KVxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICAgIHwgRG9uZSAtPiBlbXB0eVxuICAgICAgfCBTa2lwIHMgLT4gbG9vcCBpIH5sZW4gcyBuZXh0XG4gICAgICB8IFlpZWxkIChfLCBzKSAtPiBsb29wIChpICsgMSkgfmxlbiBzIG5leHQpXG4gIGluXG4gIG1hdGNoIHMgd2l0aFxuICB8IFNlcXVlbmNlIChzLCBuZXh0KSAtPiBsb29wIDAgfmxlbiBzIG5leHRcbjs7XG5cbmxldCBkcm9wX3doaWxlX29wdGlvbiAoU2VxdWVuY2UgKHMsIG5leHQpKSB+ZiA9XG4gIGxldCByZWMgbG9vcCBzID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiBOb25lXG4gICAgfCBTa2lwIHMgLT4gbG9vcCBzXG4gICAgfCBZaWVsZCAoeCwgcykgLT4gaWYgZiB4IHRoZW4gbG9vcCBzIGVsc2UgU29tZSAoeCwgU2VxdWVuY2UgKHMsIG5leHQpKVxuICBpblxuICBsb29wIHNcbjs7XG5cbmxldCBjb21wYXJlIGNvbXBhcmVfYSB0MSB0MiA9XG4gIFdpdGhfcmV0dXJuLndpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgIGl0ZXIgKHppcF9mdWxsIHQxIHQyKSB+ZjooZnVuY3Rpb25cbiAgICAgIHwgYExlZnQgXyAtPiByLnJldHVybiAxXG4gICAgICB8IGBSaWdodCBfIC0+IHIucmV0dXJuICgtMSlcbiAgICAgIHwgYEJvdGggKHYxLCB2MikgLT5cbiAgICAgICAgbGV0IGMgPSBjb21wYXJlX2EgdjEgdjIgaW5cbiAgICAgICAgaWYgYyA8PiAwIHRoZW4gci5yZXR1cm4gYyk7XG4gICAgMClcbjs7XG5cbmxldCBlcXVhbCBlcXVhbF9hIHQxIHQyID1cbiAgZm9yX2FsbCAoemlwX2Z1bGwgdDEgdDIpIH5mOihmdW5jdGlvblxuICAgIHwgYEJvdGggKGExLCBhMikgLT4gZXF1YWxfYSBhMSBhMlxuICAgIHwgYExlZnQgXyB8IGBSaWdodCBfIC0+IGZhbHNlKVxuOztcblxubGV0IHJvdW5kX3JvYmluIGxpc3QgPVxuICBsZXQgbmV4dCAodG9kb19zdGFjaywgZG9uZV9zdGFjaykgPVxuICAgIG1hdGNoIHRvZG9fc3RhY2sgd2l0aFxuICAgIHwgU2VxdWVuY2UgKHMsIGYpIDo6IHRvZG9fc3RhY2sgLT5cbiAgICAgIChtYXRjaCBmIHMgd2l0aFxuICAgICAgIHwgWWllbGQgKHgsIHMpIC0+IFlpZWxkICh4LCAodG9kb19zdGFjaywgU2VxdWVuY2UgKHMsIGYpIDo6IGRvbmVfc3RhY2spKVxuICAgICAgIHwgU2tpcCBzIC0+IFNraXAgKFNlcXVlbmNlIChzLCBmKSA6OiB0b2RvX3N0YWNrLCBkb25lX3N0YWNrKVxuICAgICAgIHwgRG9uZSAtPiBTa2lwICh0b2RvX3N0YWNrLCBkb25lX3N0YWNrKSlcbiAgICB8IFtdIC0+IGlmIExpc3QuaXNfZW1wdHkgZG9uZV9zdGFjayB0aGVuIERvbmUgZWxzZSBTa2lwIChMaXN0LnJldiBkb25lX3N0YWNrLCBbXSlcbiAgaW5cbiAgbGV0IHN0YXRlID0gbGlzdCwgW10gaW5cbiAgU2VxdWVuY2UgKHN0YXRlLCBuZXh0KVxuOztcblxubGV0IGludGVybGVhdmUgKFNlcXVlbmNlIChzMSwgZjEpKSA9XG4gIGxldCBuZXh0ICh0b2RvX3N0YWNrLCBkb25lX3N0YWNrLCBzMSkgPVxuICAgIG1hdGNoIHRvZG9fc3RhY2sgd2l0aFxuICAgIHwgU2VxdWVuY2UgKHMyLCBmMikgOjogdG9kb19zdGFjayAtPlxuICAgICAgKG1hdGNoIGYyIHMyIHdpdGhcbiAgICAgICB8IFlpZWxkICh4LCBzMikgLT4gWWllbGQgKHgsICh0b2RvX3N0YWNrLCBTZXF1ZW5jZSAoczIsIGYyKSA6OiBkb25lX3N0YWNrLCBzMSkpXG4gICAgICAgfCBTa2lwIHMyIC0+IFNraXAgKHRvZG9fc3RhY2ssIFNlcXVlbmNlIChzMiwgZjIpIDo6IGRvbmVfc3RhY2ssIHMxKVxuICAgICAgIHwgRG9uZSAtPiBTa2lwICh0b2RvX3N0YWNrLCBkb25lX3N0YWNrLCBzMSkpXG4gICAgfCBbXSAtPlxuICAgICAgKG1hdGNoIGYxIHMxLCBkb25lX3N0YWNrIHdpdGhcbiAgICAgICB8IFlpZWxkICh0LCBzMSksIF8gLT4gU2tpcCAoTGlzdC5yZXYgKHQgOjogZG9uZV9zdGFjayksIFtdLCBzMSlcbiAgICAgICB8IFNraXAgczEsIF8gLT4gU2tpcCAoTGlzdC5yZXYgZG9uZV9zdGFjaywgW10sIHMxKVxuICAgICAgIHwgRG9uZSwgXyA6OiBfIC0+IFNraXAgKExpc3QucmV2IGRvbmVfc3RhY2ssIFtdLCBzMSlcbiAgICAgICB8IERvbmUsIFtdIC0+IERvbmUpXG4gIGluXG4gIGxldCBzdGF0ZSA9IFtdLCBbXSwgczEgaW5cbiAgU2VxdWVuY2UgKHN0YXRlLCBuZXh0KVxuOztcblxubGV0IGludGVybGVhdmVkX2NhcnRlc2lhbl9wcm9kdWN0IHMxIHMyID1cbiAgbWFwIHMxIH5mOihmdW4geDEgLT4gbWFwIHMyIH5mOihmdW4geDIgLT4geDEsIHgyKSkgfD4gaW50ZXJsZWF2ZVxuOztcblxubGV0IG9mX3NlcSAoc2VxIDogXyBDYW1sLlNlcS50KSA9XG4gIHVuZm9sZF9zdGVwIH5pbml0OnNlcSB+ZjooZnVuIHNlcSAtPlxuICAgIG1hdGNoIHNlcSAoKSB3aXRoXG4gICAgfCBOaWwgLT4gRG9uZVxuICAgIHwgQ29ucyAoaGQsIHRsKSAtPiBZaWVsZCAoaGQsIHRsKSlcbjs7XG5cbmxldCB0b19zZXEgKFNlcXVlbmNlIChzdGF0ZSwgbmV4dCkpID1cbiAgbGV0IHJlYyBsb29wIHN0YXRlID1cbiAgICBtYXRjaCBuZXh0IHN0YXRlIHdpdGhcbiAgICB8IERvbmUgLT4gQ2FtbC5TZXEuTmlsXG4gICAgfCBTa2lwIHN0YXRlIC0+IGxvb3Agc3RhdGVcbiAgICB8IFlpZWxkIChoZCwgc3RhdGUpIC0+IENhbWwuU2VxLkNvbnMgKGhkLCBmdW4gKCkgLT4gbG9vcCBzdGF0ZSlcbiAgaW5cbiAgZnVuICgpIC0+IGxvb3Agc3RhdGVcbjs7XG5cbm1vZHVsZSBHZW5lcmF0b3IgPSBzdHJ1Y3RcbiAgdHlwZSAnZWx0IHN0ZXBzID0gV3JhcCBvZiAoJ2VsdCwgdW5pdCAtPiAnZWx0IHN0ZXBzKSBTdGVwLnRcblxuICBsZXQgdW53cmFwIChXcmFwIHN0ZXApID0gc3RlcFxuXG4gIG1vZHVsZSBUID0gc3RydWN0XG4gICAgdHlwZSAoJ2EsICdlbHQpIHQgPSAoJ2EgLT4gJ2VsdCBzdGVwcykgLT4gJ2VsdCBzdGVwc1xuXG4gICAgbGV0IHJldHVybiB4IGsgPSBrIHhcblxuICAgIGxldCBiaW5kIG0gfmYgayA9XG4gICAgICBtIChmdW4gYSAtPlxuICAgICAgICBsZXQgbScgPSBmIGEgaW5cbiAgICAgICAgbScgaylcbiAgICA7O1xuXG4gICAgbGV0IG1hcCBtIH5mIGsgPSBtIChmdW4gYSAtPiBrIChmIGEpKVxuICAgIGxldCBtYXAgPSBgQ3VzdG9tIG1hcFxuICBlbmRcblxuICBpbmNsdWRlIFRcbiAgaW5jbHVkZSBNb25hZC5NYWtlMiAoVClcblxuICBsZXQgeWllbGQgZSBrID0gV3JhcCAoWWllbGQgKGUsIGspKVxuICBsZXQgdG9fc3RlcHMgdCA9IHQgKGZ1biAoKSAtPiBXcmFwIERvbmUpXG5cbiAgbGV0IG9mX3NlcXVlbmNlIHNlcXVlbmNlID1cbiAgICBkZWxheWVkX2ZvbGRcbiAgICAgIHNlcXVlbmNlXG4gICAgICB+aW5pdDooKVxuICAgICAgfmY6KGZ1biAoKSB4IH5rIGYgLT4gV3JhcCAoWWllbGQgKHgsIGZ1biAoKSAtPiBrICgpIGYpKSlcbiAgICAgIH5maW5pc2g6cmV0dXJuXG4gIDs7XG5cbiAgbGV0IHJ1biB0ID1cbiAgICBsZXQgaW5pdCAoKSA9IHRvX3N0ZXBzIHQgaW5cbiAgICBsZXQgZiB0aHVuayA9IHVud3JhcCAodGh1bmsgKCkpIGluXG4gICAgdW5mb2xkX3N0ZXAgfmluaXQgfmZcbiAgOztcbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5tb2R1bGUgQXJyYXkgPSBBcnJheTBcbm1vZHVsZSBTdHJpbmcgPSBTdHJpbmcwXG5pbmNsdWRlIENoYXIwXG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIHR5cGUgdCA9IGNoYXIgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZSA9IChjb21wYXJlX2NoYXIgOiB0IC0+IHQgLT4gaW50KVxuXG4gIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICBoYXNoX2ZvbGRfY2hhclxuXG4gIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IGhhc2hfY2hhciBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCB0X29mX3NleHAgPSAoY2hhcl9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG4gIGxldCBzZXhwX29mX3QgPSAoc2V4cF9vZl9jaGFyIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IGNoYXJfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICBsZXQgdG9fc3RyaW5nIHQgPSBTdHJpbmcubWFrZSAxIHRcblxuICBsZXQgb2Zfc3RyaW5nIHMgPVxuICAgIG1hdGNoIFN0cmluZy5sZW5ndGggcyB3aXRoXG4gICAgfCAxIC0+IHMuWzBdXG4gICAgfCBfIC0+IGZhaWx3aXRoZiBcIkNoYXIub2Zfc3RyaW5nOiAlU1wiIHMgKClcbiAgOztcbmVuZFxuXG5pbmNsdWRlIFRcblxuaW5jbHVkZSBJZGVudGlmaWFibGUuTWFrZSAoc3RydWN0XG4gICAgaW5jbHVkZSBUXG5cbiAgICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuQ2hhclwiXG4gIGVuZClcblxubGV0IHBwIGZtdCBjID0gQ2FtbC5Gb3JtYXQuZnByaW50ZiBmbXQgXCIlQ1wiIGNcblxuKCogT3BlbiByZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgYWZ0ZXIgaW5jbHVkaW5nIGZ1bmN0b3IgaW5zdGFudGlhdGlvbnMgc28gdGhleSBkbyBub3RcbiAgIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXMgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvblxuICAgZnVuY3Rpb25zIGFyZSBhdmFpbGFibGUgd2l0aGluIHRoaXMgbW9kdWxlLiAqKVxub3BlbiEgQ2hhcl9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxubGV0IGludmFyaWFudCAoXyA6IHQpID0gKClcbmxldCBhbGwgPSBBcnJheS5pbml0IDI1NiB+Zjp1bnNhZmVfb2ZfaW50IHw+IEFycmF5LnRvX2xpc3RcblxubGV0IGlzX2xvd2VyY2FzZSA9IGZ1bmN0aW9uXG4gIHwgJ2EnIC4uICd6JyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuOztcblxubGV0IGlzX3VwcGVyY2FzZSA9IGZ1bmN0aW9uXG4gIHwgJ0EnIC4uICdaJyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuOztcblxubGV0IGlzX3ByaW50ID0gZnVuY3Rpb25cbiAgfCAnICcgLi4gJ34nIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG47O1xuXG5sZXQgaXNfd2hpdGVzcGFjZSA9IGZ1bmN0aW9uXG4gIHwgJ1xcdCcgfCAnXFxuJyB8ICdcXDAxMScgKCogdmVydGljYWwgdGFiICopIHwgJ1xcMDEyJyAoKiBmb3JtIGZlZWQgKikgfCAnXFxyJyB8ICcgJyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuOztcblxubGV0IGlzX2RpZ2l0ID0gZnVuY3Rpb25cbiAgfCAnMCcgLi4gJzknIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG47O1xuXG5sZXQgaXNfYWxwaGEgPSBmdW5jdGlvblxuICB8ICdhJyAuLiAneicgfCAnQScgLi4gJ1onIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG47O1xuXG4oKiBXcml0aW5nIHRoZXNlIG91dCwgaW5zdGVhZCBvZiBjYWxsaW5nIFtpc19hbHBoYV0gYW5kIFtpc19kaWdpdF0sIHJlZHVjZXNcbiAgIHJ1bnRpbWUgYnkgYXBwcm94LiAzMCUgKilcbmxldCBpc19hbHBoYW51bSA9IGZ1bmN0aW9uXG4gIHwgJ2EnIC4uICd6JyB8ICdBJyAuLiAnWicgfCAnMCcgLi4gJzknIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG47O1xuXG5sZXQgZ2V0X2RpZ2l0X3Vuc2FmZSB0ID0gdG9faW50IHQgLSB0b19pbnQgJzAnXG5cbmxldCBnZXRfZGlnaXRfZXhuIHQgPVxuICBpZiBpc19kaWdpdCB0XG4gIHRoZW4gZ2V0X2RpZ2l0X3Vuc2FmZSB0XG4gIGVsc2UgZmFpbHdpdGhmIFwiQ2hhci5nZXRfZGlnaXRfZXhuICVDOiBub3QgYSBkaWdpdFwiIHQgKClcbjs7XG5cbmxldCBnZXRfZGlnaXQgdCA9IGlmIGlzX2RpZ2l0IHQgdGhlbiBTb21lIChnZXRfZGlnaXRfdW5zYWZlIHQpIGVsc2UgTm9uZVxuXG5sZXQgaXNfaGV4X2RpZ2l0ID0gZnVuY3Rpb25cbiAgfCAnMCcgLi4gJzknIHwgJ2EnIC4uICdmJyB8ICdBJyAuLiAnRicgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2Vcbjs7XG5cbmxldCBpc19oZXhfZGlnaXRfbG93ZXIgPSBmdW5jdGlvblxuICB8ICcwJyAuLiAnOScgfCAnYScgLi4gJ2YnIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG47O1xuXG5sZXQgaXNfaGV4X2RpZ2l0X3VwcGVyID0gZnVuY3Rpb25cbiAgfCAnMCcgLi4gJzknIHwgJ0EnIC4uICdGJyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuOztcblxubGV0IGdldF9oZXhfZGlnaXRfZXhuID0gZnVuY3Rpb25cbiAgfCAnMCcgLi4gJzknIGFzIHQgLT4gdG9faW50IHQgLSB0b19pbnQgJzAnXG4gIHwgJ2EnIC4uICdmJyBhcyB0IC0+IHRvX2ludCB0IC0gdG9faW50ICdhJyArIDEwXG4gIHwgJ0EnIC4uICdGJyBhcyB0IC0+IHRvX2ludCB0IC0gdG9faW50ICdBJyArIDEwXG4gIHwgdCAtPlxuICAgIEVycm9yLnJhaXNlX3NcbiAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgIFwiQ2hhci5nZXRfaGV4X2RpZ2l0X2V4bjogbm90IGEgaGV4YWRlY2ltYWwgZGlnaXRcIlxuICAgICAgICAgWyBcImNoYXJcIiwgc2V4cF9vZl90IHQgXSlcbjs7XG5cbmxldCBnZXRfaGV4X2RpZ2l0IHQgPSBpZiBpc19oZXhfZGlnaXQgdCB0aGVuIFNvbWUgKGdldF9oZXhfZGlnaXRfZXhuIHQpIGVsc2UgTm9uZVxuXG5tb2R1bGUgTyA9IHN0cnVjdFxuICBsZXQgKCA+PSApID0gKCA+PSApXG4gIGxldCAoIDw9ICkgPSAoIDw9IClcbiAgbGV0ICggPSApID0gKCA9IClcbiAgbGV0ICggPiApID0gKCA+IClcbiAgbGV0ICggPCApID0gKCA8IClcbiAgbGV0ICggPD4gKSA9ICggPD4gKVxuZW5kXG5cbm1vZHVsZSBDYXNlbGVzcyA9IHN0cnVjdFxuICBtb2R1bGUgVCA9IHN0cnVjdFxuICAgIHR5cGUgdCA9IGNoYXIgW0BAZGVyaXZpbmdfaW5saW5lIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICAgIGxldCB0X29mX3NleHAgPSAoY2hhcl9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG4gICAgbGV0IHNleHBfb2ZfdCA9IChzZXhwX29mX2NoYXIgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBjaGFyX3NleHBfZ3JhbW1hclxuXG4gICAgW0BAQGVuZF1cblxuICAgIGxldCBjb21wYXJlIGMxIGMyID0gY29tcGFyZSAobG93ZXJjYXNlIGMxKSAobG93ZXJjYXNlIGMyKVxuICAgIGxldCBoYXNoX2ZvbGRfdCBzdGF0ZSB0ID0gaGFzaF9mb2xkX2NoYXIgc3RhdGUgKGxvd2VyY2FzZSB0KVxuICAgIGxldCBoYXNoIHQgPSBIYXNoLnJ1biBoYXNoX2ZvbGRfdCB0XG4gIGVuZFxuXG4gIGluY2x1ZGUgVFxuICBpbmNsdWRlIENvbXBhcmFibGUuTWFrZSAoVClcbmVuZFxuXG4oKiBJbmNsdWRlIHR5cGUtc3BlY2lmaWMgW1JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZV0gYXQgdGhlIGVuZCwgYWZ0ZXJcbiAgIGluY2x1ZGluZyBmdW5jdG9yIGFwcGxpY2F0aW9uIHRoYXQgY291bGQgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpc1xuICAgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbnMgYXJlIGV4cG9ydGVkIGJ5XG4gICB0aGlzIG1vZHVsZS4gKilcbmluY2x1ZGUgQ2hhcl9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcbiIsIm9wZW4hIEltcG9ydFxubW9kdWxlIEFycmF5ID0gQXJyYXkwXG5cbmxldCBzdGFnZSA9IFN0YWdlZC5zdGFnZVxuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICB0eXBlIHQgPSBieXRlcyBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCB0X29mX3NleHAgPSAoYnl0ZXNfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuICBsZXQgc2V4cF9vZl90ID0gKHNleHBfb2ZfYnl0ZXMgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gYnl0ZXNfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICBpbmNsdWRlIEJ5dGVzMFxuXG4gIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5CeXRlc1wiXG4gIGxldCBwcCBmbXQgdCA9IENhbWwuRm9ybWF0LmZwcmludGYgZm10IFwiJVNcIiAodG9fc3RyaW5nIHQpXG5lbmRcblxuaW5jbHVkZSBUXG5cbm1vZHVsZSBUb19ieXRlcyA9IEJsaXQuTWFrZSAoc3RydWN0XG4gICAgaW5jbHVkZSBUXG5cbiAgICBsZXQgY3JlYXRlIH5sZW4gPSBjcmVhdGUgbGVuXG4gIGVuZClcblxuaW5jbHVkZSBUb19ieXRlc1xuaW5jbHVkZSBDb21wYXJhdG9yLk1ha2UgKFQpXG5pbmNsdWRlIFByZXR0eV9wcmludGVyLlJlZ2lzdGVyX3BwIChUKVxuXG4oKiBPcGVuIHJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBhZnRlciBpbmNsdWRpbmcgZnVuY3RvciBpbnN0YW50aWF0aW9ucyBzbyB0aGV5IGRvIG5vdFxuICAgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpcyBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uXG4gICBmdW5jdGlvbnMgYXJlIGF2YWlsYWJsZSB3aXRoaW4gdGhpcyBtb2R1bGUuICopXG5vcGVuISBCeXRlc19yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcbm1vZHVsZSBUb19zdHJpbmcgPSBCbGl0Lk1ha2VfdG9fc3RyaW5nIChUKSAoVG9fYnl0ZXMpXG5cbm1vZHVsZSBGcm9tX3N0cmluZyA9XG4gIEJsaXQuTWFrZV9kaXN0aW5jdFxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgdCA9IHN0cmluZ1xuXG4gICAgICBsZXQgbGVuZ3RoID0gU3RyaW5nLmxlbmd0aFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gICAgICBsZXQgY3JlYXRlIH5sZW4gPSBjcmVhdGUgbGVuXG4gICAgICBsZXQgbGVuZ3RoID0gbGVuZ3RoXG4gICAgICBsZXQgdW5zYWZlX2JsaXQgPSB1bnNhZmVfYmxpdF9zdHJpbmdcbiAgICBlbmQpXG5cbmxldCBpbnZhcmlhbnQgKF8gOiB0KSA9ICgpXG5cbmxldCBpbml0IG4gfmYgPVxuICBpZiBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPCApIG4gMFxuICB0aGVuIFByaW50Zi5pbnZhbGlkX2FyZ2YgXCJCeXRlcy5pbml0ICVkXCIgbiAoKTtcbiAgbGV0IHQgPSBjcmVhdGUgbiBpblxuICBmb3IgaSA9IDAgdG8gbiAtIDEgZG9cbiAgICB1bnNhZmVfc2V0IHQgaSAoZiBpKVxuICBkb25lO1xuICB0XG47O1xuXG5sZXQgb2ZfY2hhcl9saXN0IGwgPVxuICBsZXQgdCA9IGNyZWF0ZSAoTGlzdC5sZW5ndGggbCkgaW5cbiAgTGlzdC5pdGVyaSBsIH5mOihmdW4gaSBjIC0+IHNldCB0IGkgYyk7XG4gIHRcbjs7XG5cbmxldCB0b19saXN0IHQgPVxuICBsZXQgcmVjIGxvb3AgdCBpIGFjYyA9XG4gICAgaWYgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oIDwgKSBpIDBcbiAgICB0aGVuIGFjY1xuICAgIGVsc2UgbG9vcCB0IChpIC0gMSkgKHVuc2FmZV9nZXQgdCBpIDo6IGFjYylcbiAgaW5cbiAgbG9vcCB0IChsZW5ndGggdCAtIDEpIFtdXG47O1xuXG5sZXQgdG9fYXJyYXkgdCA9IEFycmF5LmluaXQgKGxlbmd0aCB0KSB+ZjooZnVuIGkgLT4gdW5zYWZlX2dldCB0IGkpXG5sZXQgbWFwIHQgfmYgPSBtYXAgdCB+ZlxubGV0IG1hcGkgdCB+ZiA9IG1hcGkgdCB+ZlxuXG5sZXQgZm9sZCA9XG4gIGxldCByZWMgbG9vcCB0IH5mIH5sZW4gfnBvcyBhY2MgPVxuICAgIGlmIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuZXF1YWwgcG9zIGxlblxuICAgIHRoZW4gYWNjXG4gICAgZWxzZSBsb29wIHQgfmYgfmxlbiB+cG9zOihwb3MgKyAxKSAoZiBhY2MgKHVuc2FmZV9nZXQgdCBwb3MpKVxuICBpblxuICBmdW4gdCB+aW5pdCB+ZiAtPiBsb29wIHQgfmYgfmxlbjoobGVuZ3RoIHQpIH5wb3M6MCBpbml0XG47O1xuXG5sZXQgZm9sZGkgPVxuICBsZXQgcmVjIGxvb3AgdCB+ZiB+bGVuIH5wb3MgYWNjID1cbiAgICBpZiBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLmVxdWFsIHBvcyBsZW5cbiAgICB0aGVuIGFjY1xuICAgIGVsc2UgbG9vcCB0IH5mIH5sZW4gfnBvczoocG9zICsgMSkgKGYgcG9zIGFjYyAodW5zYWZlX2dldCB0IHBvcykpXG4gIGluXG4gIGZ1biB0IH5pbml0IH5mIC0+IGxvb3AgdCB+ZiB+bGVuOihsZW5ndGggdCkgfnBvczowIGluaXRcbjs7XG5cbmxldCB0ciB+dGFyZ2V0IH5yZXBsYWNlbWVudCBzID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBzIC0gMSBkb1xuICAgIGlmIENoYXIuZXF1YWwgKHVuc2FmZV9nZXQgcyBpKSB0YXJnZXQgdGhlbiB1bnNhZmVfc2V0IHMgaSByZXBsYWNlbWVudFxuICBkb25lXG47O1xuXG5sZXQgdHJfbXVsdGkgfnRhcmdldCB+cmVwbGFjZW1lbnQgPVxuICBpZiBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPSApIChTdHJpbmcubGVuZ3RoIHRhcmdldCkgMFxuICB0aGVuIHN0YWdlIGlnbm9yZVxuICBlbHNlIGlmIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA9ICkgKFN0cmluZy5sZW5ndGggcmVwbGFjZW1lbnQpIDBcbiAgdGhlbiBpbnZhbGlkX2FyZyBcInRyX211bHRpOiByZXBsYWNlbWVudCBpcyB0aGUgZW1wdHkgc3RyaW5nXCJcbiAgZWxzZSAoXG4gICAgbWF0Y2ggQnl0ZXNfdHIudHJfY3JlYXRlX21hcCB+dGFyZ2V0IH5yZXBsYWNlbWVudCB3aXRoXG4gICAgfCBOb25lIC0+IHN0YWdlIGlnbm9yZVxuICAgIHwgU29tZSB0cl9tYXAgLT5cbiAgICAgIHN0YWdlIChmdW4gcyAtPlxuICAgICAgICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHMgLSAxIGRvXG4gICAgICAgICAgdW5zYWZlX3NldCBzIGkgKFN0cmluZy51bnNhZmVfZ2V0IHRyX21hcCAoQ2hhci50b19pbnQgKHVuc2FmZV9nZXQgcyBpKSkpXG4gICAgICAgIGRvbmUpKVxuOztcblxubGV0IGJldHdlZW4gdCB+bG93IH5oaWdoID0gbG93IDw9IHQgJiYgdCA8PSBoaWdoXG5sZXQgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4ID0gaWYgdCA8IG1pbiB0aGVuIG1pbiBlbHNlIGlmIHQgPD0gbWF4IHRoZW4gdCBlbHNlIG1heFxuXG5sZXQgY2xhbXBfZXhuIHQgfm1pbiB+bWF4ID1cbiAgYXNzZXJ0IChtaW4gPD0gbWF4KTtcbiAgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4XG47O1xuXG5sZXQgY2xhbXAgdCB+bWluIH5tYXggPVxuICBpZiBtaW4gPiBtYXhcbiAgdGhlblxuICAgIE9yX2Vycm9yLmVycm9yX3NcbiAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgIFwiY2xhbXAgcmVxdWlyZXMgW21pbiA8PSBtYXhdXCJcbiAgICAgICAgIFsgXCJtaW5cIiwgVC5zZXhwX29mX3QgbWluOyBcIm1heFwiLCBULnNleHBfb2ZfdCBtYXggXSlcbiAgZWxzZSBPayAoY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4KVxuOztcblxubGV0IGNvbnRhaW5zID9wb3MgP2xlbiB0IGNoYXIgPVxuICBsZXQgcG9zLCBsZW4gPVxuICAgIE9yZGVyZWRfY29sbGVjdGlvbl9jb21tb24uZ2V0X3Bvc19sZW5fZXhuICgpID9wb3MgP2xlbiB+dG90YWxfbGVuZ3RoOihsZW5ndGggdClcbiAgaW5cbiAgbGV0IGxhc3QgPSBwb3MgKyBsZW4gaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA8ICkgaSBsYXN0XG4gICAgJiYgKENoYXIuZXF1YWwgKGdldCB0IGkpIGNoYXIgfHwgbG9vcCAoaSArIDEpKVxuICBpblxuICBsb29wIHBvc1xuOztcblxuKCogSW5jbHVkZSB0eXBlLXNwZWNpZmljIFtSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVdIGF0IHRoZSBlbmQsIGFmdGVyXG4gICBpbmNsdWRpbmcgZnVuY3RvciBhcHBsaWNhdGlvbiB0aGF0IGNvdWxkIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXNcbiAgIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25zIGFyZSBleHBvcnRlZCBieVxuICAgdGhpcyBtb2R1bGUuICopXG5pbmNsdWRlIEJ5dGVzX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuIiwiIyAxIFwic3JjL2hleF9sZXhlci5tbGxcIlxuIFxudHlwZSByZXN1bHQgPVxufCBOZWcgb2Ygc3RyaW5nXG58IFBvcyBvZiBzdHJpbmdcblxuIyA4IFwic3JjL2hleF9sZXhlci5tbFwiXG5sZXQgX19vY2FtbF9sZXhfdGFibGVzID0ge1xuICBMZXhpbmcubGV4X2Jhc2UgPVxuICAgXCJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAxXFwwMDBcXDAwMVxcMDAwXFwwMDJcXDAwMFxcMDI3XFwwMDBcXDA4MlxcMDAwXFwxMDVcXDAwMFxcXG4gICAgXCI7XG4gIExleGluZy5sZXhfYmFja3RyayA9XG4gICBcIlxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDBcXDAwMFxcMjU1XFwyNTVcXDAwMVxcMDAwXFxcbiAgICBcIjtcbiAgTGV4aW5nLmxleF9kZWZhdWx0ID1cbiAgIFwiXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFwiO1xuICBMZXhpbmcubGV4X3RyYW5zID1cbiAgIFwiXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAyXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDFcXDAwMFxcMDAzXFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXFxuICAgIFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcXG4gICAgXFwwMDVcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXFxuICAgIFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwNlxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcXG4gICAgXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwMFxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXFxuICAgIFxcMDA1XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDZcXDAwMFxcMDA0XFwwMDBcXDAwNVxcMDAwXFwwMDBcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXFxuICAgIFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFxcbiAgICBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXFxuICAgIFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFxcbiAgICBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFxcbiAgICBcXDAwN1xcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDA3XFwwMDBcXDAwMFxcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcIjtcbiAgTGV4aW5nLmxleF9jaGVjayA9XG4gICBcIlxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAwMFxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMDAwXFwwMDBcXDAwMlxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFxcbiAgICBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwwMDFcXDAwMFxcMDAzXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXFxuICAgIFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwyNTVcXDI1NVxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMDAxXFwwMDBcXDAwM1xcMDAwXFwwMDVcXDAwMFxcMjU1XFwyNTVcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFxcbiAgICBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcXG4gICAgXFwwMDZcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDA2XFwwMDBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFxcbiAgICBcXDAwNlxcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcXG4gICAgXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAwNlxcMDAwXFwwMDZcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcXG4gICAgXFwwMDZcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDAwN1xcMDAwXFwyNTVcXDI1NVxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XCI7XG4gIExleGluZy5sZXhfYmFzZV9jb2RlID1cbiAgIFwiXCI7XG4gIExleGluZy5sZXhfYmFja3Rya19jb2RlID1cbiAgIFwiXCI7XG4gIExleGluZy5sZXhfZGVmYXVsdF9jb2RlID1cbiAgIFwiXCI7XG4gIExleGluZy5sZXhfdHJhbnNfY29kZSA9XG4gICBcIlwiO1xuICBMZXhpbmcubGV4X2NoZWNrX2NvZGUgPVxuICAgXCJcIjtcbiAgTGV4aW5nLmxleF9jb2RlID1cbiAgIFwiXCI7XG59XG5cbmxldCByZWMgcGFyc2VfaGV4IGxleGJ1ZiA9XG4gICBfX29jYW1sX2xleF9wYXJzZV9oZXhfcmVjIGxleGJ1ZiAwXG5hbmQgX19vY2FtbF9sZXhfcGFyc2VfaGV4X3JlYyBsZXhidWYgX19vY2FtbF9sZXhfc3RhdGUgPVxuICBtYXRjaCBMZXhpbmcuZW5naW5lIF9fb2NhbWxfbGV4X3RhYmxlcyBfX29jYW1sX2xleF9zdGF0ZSBsZXhidWYgd2l0aFxuICAgICAgfCAwIC0+XG5sZXRcbiMgOCBcInNyYy9oZXhfbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlcbiMgMTM1IFwic3JjL2hleF9sZXhlci5tbFwiXG49IExleGluZy5zdWJfbGV4ZW1lIGxleGJ1ZiAobGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcG9zICsgMykgbGV4YnVmLkxleGluZy5sZXhfY3Vycl9wb3MgaW5cbiMgMTQgXCJzcmMvaGV4X2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICggTmVnIGJvZHkgKVxuIyAxMzkgXCJzcmMvaGV4X2xleGVyLm1sXCJcblxuICB8IDEgLT5cbmxldFxuIyA4IFwic3JjL2hleF9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keVxuIyAxNDUgXCJzcmMvaGV4X2xleGVyLm1sXCJcbj0gTGV4aW5nLnN1Yl9sZXhlbWUgbGV4YnVmIChsZXhidWYuTGV4aW5nLmxleF9zdGFydF9wb3MgKyAyKSBsZXhidWYuTGV4aW5nLmxleF9jdXJyX3BvcyBpblxuIyAxNSBcInNyYy9oZXhfbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCBQb3MgYm9keSApXG4jIDE0OSBcInNyYy9oZXhfbGV4ZXIubWxcIlxuXG4gIHwgX19vY2FtbF9sZXhfc3RhdGUgLT4gbGV4YnVmLkxleGluZy5yZWZpbGxfYnVmZiBsZXhidWY7XG4gICAgICBfX29jYW1sX2xleF9wYXJzZV9oZXhfcmVjIGxleGJ1ZiBfX29jYW1sX2xleF9zdGF0ZVxuXG47O1xuXG4iLCIoKiBUaGlzIGZpbGUgd2FzIGF1dG9nZW5lcmF0ZWQgYnkgLi4vZ2VuZXJhdGUvZ2VuZXJhdGVfcG93X292ZXJmbG93X2JvdW5kcy5leGUgKilcblxub3BlbiEgSW1wb3J0XG5cbm1vZHVsZSBBcnJheSA9IEFycmF5MFxuXG4oKiBXZSBoYXZlIHRvIHVzZSBJbnQ2NC50b19pbnRfZXhuIGluc3RlYWQgb2YgaW50IGNvbnN0YW50cyB0byBtYWtlXG4gICBzdXJlIHRoYXQgZmlsZSBjYW4gYmUgcHJlcHJvY2Vzc2VkIG9uIDMyLWJpdCBtYWNoaW5lcy4gKilcblxubGV0IG92ZXJmbG93X2JvdW5kX21heF9pbnQzMl92YWx1ZSA6IGludDMyID1cbiAgMjE0NzQ4MzY0N2xcblxubGV0IGludDMyX3Bvc2l0aXZlX292ZXJmbG93X2JvdW5kcyA6IGludDMyIGFycmF5ID1cbiAgW3wgMjE0NzQ4MzY0N2xcbiAgOyAgMjE0NzQ4MzY0N2xcbiAgOyAgNDYzNDBsXG4gIDsgIDEyOTBsXG4gIDsgIDIxNWxcbiAgOyAgNzNsXG4gIDsgIDM1bFxuICA7ICAyMWxcbiAgOyAgMTRsXG4gIDsgIDEwbFxuICA7ICA4bFxuICA7ICA3bFxuICA7ICA1bFxuICA7ICA1bFxuICA7ICA0bFxuICA7ICA0bFxuICA7ICAzbFxuICA7ICAzbFxuICA7ICAzbFxuICA7ICAzbFxuICA7ICAybFxuICA7ICAybFxuICA7ICAybFxuICA7ICAybFxuICA7ICAybFxuICA7ICAybFxuICA7ICAybFxuICA7ICAybFxuICA7ICAybFxuICA7ICAybFxuICA7ICAybFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICB8XVxuXG5sZXQgb3ZlcmZsb3dfYm91bmRfbWF4X2ludF92YWx1ZSA6IGludCA9XG4gICgtMSkgbHNyIDFcblxubGV0IGludF9wb3NpdGl2ZV9vdmVyZmxvd19ib3VuZHMgOiBpbnQgYXJyYXkgPVxuICBtYXRjaCBJbnRfY29udmVyc2lvbnMubnVtX2JpdHNfaW50IHdpdGhcbiAgfCAzMiAtPiBBcnJheS5tYXAgaW50MzJfcG9zaXRpdmVfb3ZlcmZsb3dfYm91bmRzIH5mOkNhbWwuSW50MzIudG9faW50XG4gIHwgNjMgLT5cbiAgICBbfCBDYW1sLkludDY0LnRvX2ludCA0NjExNjg2MDE4NDI3Mzg3OTAzTFxuICAgIDsgIENhbWwuSW50NjQudG9faW50IDQ2MTE2ODYwMTg0MjczODc5MDNMXG4gICAgOyAgQ2FtbC5JbnQ2NC50b19pbnQgMjE0NzQ4MzY0N0xcbiAgICA7ICAxNjY0NTEwXG4gICAgOyAgNDYzNDBcbiAgICA7ICA1NDA0XG4gICAgOyAgMTI5MFxuICAgIDsgIDQ2M1xuICAgIDsgIDIxNVxuICAgIDsgIDExOFxuICAgIDsgIDczXG4gICAgOyAgNDlcbiAgICA7ICAzNVxuICAgIDsgIDI3XG4gICAgOyAgMjFcbiAgICA7ICAxN1xuICAgIDsgIDE0XG4gICAgOyAgMTJcbiAgICA7ICAxMFxuICAgIDsgIDlcbiAgICA7ICA4XG4gICAgOyAgN1xuICAgIDsgIDdcbiAgICA7ICA2XG4gICAgOyAgNVxuICAgIDsgIDVcbiAgICA7ICA1XG4gICAgOyAgNFxuICAgIDsgIDRcbiAgICA7ICA0XG4gICAgOyAgNFxuICAgIDsgIDNcbiAgICA7ICAzXG4gICAgOyAgM1xuICAgIDsgIDNcbiAgICA7ICAzXG4gICAgOyAgM1xuICAgIDsgIDNcbiAgICA7ICAzXG4gICAgOyAgM1xuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIHxdXG4gIHwgMzEgLT5cbiAgICBbfCAxMDczNzQxODIzXG4gICAgOyAgMTA3Mzc0MTgyM1xuICAgIDsgIDMyNzY3XG4gICAgOyAgMTAyM1xuICAgIDsgIDE4MVxuICAgIDsgIDYzXG4gICAgOyAgMzFcbiAgICA7ICAxOVxuICAgIDsgIDEzXG4gICAgOyAgMTBcbiAgICA7ICA3XG4gICAgOyAgNlxuICAgIDsgIDVcbiAgICA7ICA0XG4gICAgOyAgNFxuICAgIDsgIDNcbiAgICA7ICAzXG4gICAgOyAgM1xuICAgIDsgIDNcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICB8XVxuICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbmxldCBvdmVyZmxvd19ib3VuZF9tYXhfaW50NjNfb25faW50NjRfdmFsdWUgOiBpbnQ2NCA9XG4gIDQ2MTE2ODYwMTg0MjczODc5MDNMXG5cbmxldCBpbnQ2M19vbl9pbnQ2NF9wb3NpdGl2ZV9vdmVyZmxvd19ib3VuZHMgOiBpbnQ2NCBhcnJheSA9XG4gIFt8IDQ2MTE2ODYwMTg0MjczODc5MDNMXG4gIDsgIDQ2MTE2ODYwMTg0MjczODc5MDNMXG4gIDsgIDIxNDc0ODM2NDdMXG4gIDsgIDE2NjQ1MTBMXG4gIDsgIDQ2MzQwTFxuICA7ICA1NDA0TFxuICA7ICAxMjkwTFxuICA7ICA0NjNMXG4gIDsgIDIxNUxcbiAgOyAgMTE4TFxuICA7ICA3M0xcbiAgOyAgNDlMXG4gIDsgIDM1TFxuICA7ICAyN0xcbiAgOyAgMjFMXG4gIDsgIDE3TFxuICA7ICAxNExcbiAgOyAgMTJMXG4gIDsgIDEwTFxuICA7ICA5TFxuICA7ICA4TFxuICA7ICA3TFxuICA7ICA3TFxuICA7ICA2TFxuICA7ICA1TFxuICA7ICA1TFxuICA7ICA1TFxuICA7ICA0TFxuICA7ICA0TFxuICA7ICA0TFxuICA7ICA0TFxuICA7ICAzTFxuICA7ICAzTFxuICA7ICAzTFxuICA7ICAzTFxuICA7ICAzTFxuICA7ICAzTFxuICA7ICAzTFxuICA7ICAzTFxuICA7ICAzTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAxTFxuICA7ICAxTFxuICB8XVxuXG5sZXQgb3ZlcmZsb3dfYm91bmRfbWF4X2ludDY0X3ZhbHVlIDogaW50NjQgPVxuICA5MjIzMzcyMDM2ODU0Nzc1ODA3TFxuXG5sZXQgaW50NjRfcG9zaXRpdmVfb3ZlcmZsb3dfYm91bmRzIDogaW50NjQgYXJyYXkgPVxuICBbfCA5MjIzMzcyMDM2ODU0Nzc1ODA3TFxuICA7ICA5MjIzMzcyMDM2ODU0Nzc1ODA3TFxuICA7ICAzMDM3MDAwNDk5TFxuICA7ICAyMDk3MTUxTFxuICA7ICA1NTEwOExcbiAgOyAgNjIwOExcbiAgOyAgMTQ0OExcbiAgOyAgNTExTFxuICA7ICAyMzRMXG4gIDsgIDEyN0xcbiAgOyAgNzhMXG4gIDsgIDUyTFxuICA7ICAzOExcbiAgOyAgMjhMXG4gIDsgIDIyTFxuICA7ICAxOExcbiAgOyAgMTVMXG4gIDsgIDEzTFxuICA7ICAxMUxcbiAgOyAgOUxcbiAgOyAgOExcbiAgOyAgN0xcbiAgOyAgN0xcbiAgOyAgNkxcbiAgOyAgNkxcbiAgOyAgNUxcbiAgOyAgNUxcbiAgOyAgNUxcbiAgOyAgNExcbiAgOyAgNExcbiAgOyAgNExcbiAgOyAgNExcbiAgOyAgM0xcbiAgOyAgM0xcbiAgOyAgM0xcbiAgOyAgM0xcbiAgOyAgM0xcbiAgOyAgM0xcbiAgOyAgM0xcbiAgOyAgM0xcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMUxcbiAgfF1cblxubGV0IGludDY0X25lZ2F0aXZlX292ZXJmbG93X2JvdW5kcyA6IGludDY0IGFycmF5ID1cbiAgW3wgLTkyMjMzNzIwMzY4NTQ3NzU4MDdMXG4gIDsgIC05MjIzMzcyMDM2ODU0Nzc1ODA3TFxuICA7ICAtMzAzNzAwMDQ5OUxcbiAgOyAgLTIwOTcxNTFMXG4gIDsgIC01NTEwOExcbiAgOyAgLTYyMDhMXG4gIDsgIC0xNDQ4TFxuICA7ICAtNTExTFxuICA7ICAtMjM0TFxuICA7ICAtMTI3TFxuICA7ICAtNzhMXG4gIDsgIC01MkxcbiAgOyAgLTM4TFxuICA7ICAtMjhMXG4gIDsgIC0yMkxcbiAgOyAgLTE4TFxuICA7ICAtMTVMXG4gIDsgIC0xM0xcbiAgOyAgLTExTFxuICA7ICAtOUxcbiAgOyAgLThMXG4gIDsgIC03TFxuICA7ICAtN0xcbiAgOyAgLTZMXG4gIDsgIC02TFxuICA7ICAtNUxcbiAgOyAgLTVMXG4gIDsgIC01TFxuICA7ICAtNExcbiAgOyAgLTRMXG4gIDsgIC00TFxuICA7ICAtNExcbiAgOyAgLTNMXG4gIDsgIC0zTFxuICA7ICAtM0xcbiAgOyAgLTNMXG4gIDsgIC0zTFxuICA7ICAtM0xcbiAgOyAgLTNMXG4gIDsgIC0zTFxuICA7ICAtMkxcbiAgOyAgLTJMXG4gIDsgIC0yTFxuICA7ICAtMkxcbiAgOyAgLTJMXG4gIDsgIC0yTFxuICA7ICAtMkxcbiAgOyAgLTJMXG4gIDsgIC0yTFxuICA7ICAtMkxcbiAgOyAgLTJMXG4gIDsgIC0yTFxuICA7ICAtMkxcbiAgOyAgLTJMXG4gIDsgIC0yTFxuICA7ICAtMkxcbiAgOyAgLTJMXG4gIDsgIC0yTFxuICA7ICAtMkxcbiAgOyAgLTJMXG4gIDsgIC0yTFxuICA7ICAtMkxcbiAgOyAgLTJMXG4gIDsgIC0xTFxuICB8XVxuIiwib3BlbiEgSW1wb3J0XG5cbigqIEMgc3R1YiBmb3IgaW50IHBvcGNvdW50IHRvIHVzZSB0aGUgUE9QQ05UIGluc3RydWN0aW9uIHdoZXJlIHBvc3NpYmxlICopXG5leHRlcm5hbCBpbnRfcG9wY291bnQgOiBpbnQgLT4gaW50ID0gXCJCYXNlX2ludF9tYXRoX2ludF9wb3Bjb3VudFwiIFtAQG5vYWxsb2NdXG5cbigqIFRvIG1haW50YWluIGphdmFzY3JpcHQgY29tcGF0aWJpbGl0eSBhbmQgZW5hYmxlIHVuYm94aW5nLCB3ZSBpbXBsZW1lbnQgcG9wY291bnQgaW5cbiAgIE9DYW1sIHJhdGhlciB0aGFuIHVzZSBDIHN0dWJzLiBJbXBsZW1lbnRhdGlvbiBhZGFwdGVkIGZyb206XG4gICBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IYW1taW5nX3dlaWdodCNFZmZpY2llbnRfaW1wbGVtZW50YXRpb24gKilcbmxldCBpbnQ2NF9wb3Bjb3VudCA9XG4gIGxldCBvcGVuIENhbWwuSW50NjQgaW5cbiAgbGV0ICggKyApID0gYWRkIGluXG4gIGxldCAoIC0gKSA9IHN1YiBpblxuICBsZXQgKCAqICkgPSBtdWwgaW5cbiAgbGV0ICggbHNyICkgPSBzaGlmdF9yaWdodF9sb2dpY2FsIGluXG4gIGxldCAoIGxhbmQgKSA9IGxvZ2FuZCBpblxuICBsZXQgbTEgPSAweDU1NTU1NTU1NTU1NTU1NTVMIGluXG4gICgqIDBiMDEwMTAxMDEuLi4gKilcbiAgbGV0IG0yID0gMHgzMzMzMzMzMzMzMzMzMzMzTCBpblxuICAoKiAwYjAwMTEwMDExLi4uICopXG4gIGxldCBtNCA9IDB4MGYwZjBmMGYwZjBmMGYwZkwgaW5cbiAgKCogMGIwMDAwMTExMS4uLiAqKVxuICBsZXQgaDAxID0gMHgwMTAxMDEwMTAxMDEwMTAxTCBpblxuICAoKiAxIGJpdCBzZXQgcGVyIGJ5dGUgKilcbiAgZnVuIFtAaW5saW5lXSB4IC0+XG4gICAgKCogZ2F0aGVyIHRoZSBiaXQgY291bnQgZm9yIGV2ZXJ5IHBhaXIgb2YgYml0cyAqKVxuICAgIGxldCB4ID0geCAtICgoeCBsc3IgMSkgbGFuZCBtMSkgaW5cbiAgICAoKiBnYXRoZXIgdGhlIGJpdCBjb3VudCBmb3IgZXZlcnkgNCBiaXRzICopXG4gICAgbGV0IHggPSAoeCBsYW5kIG0yKSArICgoeCBsc3IgMikgbGFuZCBtMikgaW5cbiAgICAoKiBnYXRoZXIgdGhlIGJpdCBjb3VudCBmb3IgZXZlcnkgYnl0ZSAqKVxuICAgIGxldCB4ID0gKHggKyAoeCBsc3IgNCkpIGxhbmQgbTQgaW5cbiAgICAoKiBzdW0gdGhlIGJpdCBjb3VudHMgaW4gdGhlIHRvcCBieXRlIGFuZCBzaGlmdCBpdCBkb3duICopXG4gICAgdG9faW50ICgoeCAqIGgwMSkgbHNyIDU2KVxuOztcblxubGV0IGludDMyX3BvcGNvdW50ID1cbiAgKCogT24gNjQtYml0IHN5c3RlbXMsIHRoaXMgaXMgZmFzdGVyIHRoYW4gaW1wbGVtZW50aW5nIHVzaW5nIFtpbnQzMl0gYXJpdGhtZXRpYy4gKilcbiAgbGV0IG1hc2sgPSAweGZmZmZfZmZmZkwgaW5cbiAgZnVuIFtAaW5saW5lXSB4IC0+IGludDY0X3BvcGNvdW50IChDYW1sLkludDY0LmxvZ2FuZCAoQ2FtbC5JbnQ2NC5vZl9pbnQzMiB4KSBtYXNrKVxuOztcblxubGV0IG5hdGl2ZWludF9wb3Bjb3VudCA9XG4gIG1hdGNoIENhbWwuTmF0aXZlaW50LnNpemUgd2l0aFxuICB8IDMyIC0+IGZ1biBbQGlubGluZV0geCAtPiBpbnQzMl9wb3Bjb3VudCAoQ2FtbC5OYXRpdmVpbnQudG9faW50MzIgeClcbiAgfCA2NCAtPiBmdW4gW0BpbmxpbmVdIHggLT4gaW50NjRfcG9wY291bnQgKENhbWwuSW50NjQub2ZfbmF0aXZlaW50IHgpXG4gIHwgXyAtPiBhc3NlcnQgZmFsc2Vcbjs7XG4iLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgSW50X2ludGZcbmluY2x1ZGUgSW50MFxuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICB0eXBlIHQgPSBpbnQgW0BAZGVyaXZpbmdfaW5saW5lIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgaGFzaF9mb2xkX2ludFxuXG4gIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IGhhc2hfaW50IGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cCA9IChpbnRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuICBsZXQgc2V4cF9vZl90ID0gKHNleHBfb2ZfaW50IDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IGludF9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIGxldCBoYXNoYWJsZSA6IHQgSGFzaGFibGUudCA9IHsgaGFzaDsgY29tcGFyZTsgc2V4cF9vZl90IH1cbiAgbGV0IGNvbXBhcmUgeCB5ID0gSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS5jb21wYXJlIHggeVxuXG4gIGxldCBvZl9zdHJpbmcgcyA9XG4gICAgdHJ5IG9mX3N0cmluZyBzIHdpdGhcbiAgICB8IF8gLT4gUHJpbnRmLmZhaWx3aXRoZiBcIkludC5vZl9zdHJpbmc6ICVTXCIgcyAoKVxuICA7O1xuXG4gIGxldCB0b19zdHJpbmcgPSB0b19zdHJpbmdcbmVuZFxuXG5sZXQgbnVtX2JpdHMgPSBJbnRfY29udmVyc2lvbnMubnVtX2JpdHNfaW50XG5sZXQgZmxvYXRfbG93ZXJfYm91bmQgPSBGbG9hdDAubG93ZXJfYm91bmRfZm9yX2ludCBudW1fYml0c1xubGV0IGZsb2F0X3VwcGVyX2JvdW5kID0gRmxvYXQwLnVwcGVyX2JvdW5kX2Zvcl9pbnQgbnVtX2JpdHNcbmxldCB0b19mbG9hdCA9IENhbWwuZmxvYXRfb2ZfaW50XG5sZXQgb2ZfZmxvYXRfdW5jaGVja2VkID0gQ2FtbC5pbnRfb2ZfZmxvYXRcblxubGV0IG9mX2Zsb2F0IGYgPVxuICBpZiBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA+PSApIGYgZmxvYXRfbG93ZXJfYm91bmRcbiAgJiYgRmxvYXRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPD0gKSBmIGZsb2F0X3VwcGVyX2JvdW5kXG4gIHRoZW4gQ2FtbC5pbnRfb2ZfZmxvYXQgZlxuICBlbHNlXG4gICAgUHJpbnRmLmludmFsaWRfYXJnZlxuICAgICAgXCJJbnQub2ZfZmxvYXQ6IGFyZ3VtZW50ICglZikgaXMgb3V0IG9mIHJhbmdlIG9yIE5hTlwiXG4gICAgICAoRmxvYXQwLmJveCBmKVxuICAgICAgKClcbjs7XG5cbmxldCB6ZXJvID0gMFxubGV0IG9uZSA9IDFcbmxldCBtaW51c19vbmUgPSAtMVxuXG5pbmNsdWRlIFRcbmluY2x1ZGUgQ29tcGFyYXRvci5NYWtlIChUKVxuXG5pbmNsdWRlIENvbXBhcmFibGUuV2l0aF96ZXJvIChzdHJ1Y3RcbiAgICBpbmNsdWRlIFRcblxuICAgIGxldCB6ZXJvID0gemVyb1xuICBlbmQpXG5cbm1vZHVsZSBDb252ID0gSW50X2NvbnZlcnNpb25zXG5pbmNsdWRlIENvbnYuTWFrZSAoVClcblxuaW5jbHVkZSBDb252Lk1ha2VfaGV4IChzdHJ1Y3RcbiAgICBvcGVuIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxuICAgIHR5cGUgdCA9IGludCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgaGFzaF1cblxuICAgIGxldCBjb21wYXJlID0gKGNvbXBhcmVfaW50IDogdCAtPiB0IC0+IGludClcblxuICAgIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICAgIGhhc2hfZm9sZF9pbnRcblxuICAgIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICAgIGxldCBmdW5jID0gaGFzaF9pbnQgaW5cbiAgICAgIGZ1biB4IC0+IGZ1bmMgeFxuICAgIDs7XG5cbiAgICBbQEBAZW5kXVxuXG4gICAgbGV0IHplcm8gPSB6ZXJvXG4gICAgbGV0IG5lZyA9ICggfi0gKVxuICAgIGxldCAoIDwgKSA9ICggPCApXG4gICAgbGV0IHRvX3N0cmluZyBpID0gUHJpbnRmLnNwcmludGYgXCIleFwiIGlcbiAgICBsZXQgb2Zfc3RyaW5nIHMgPSBDYW1sLlNjYW5mLnNzY2FuZiBzIFwiJXhcIiBGbi5pZFxuICAgIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5JbnQuSGV4XCJcbiAgZW5kKVxuXG5pbmNsdWRlIFByZXR0eV9wcmludGVyLlJlZ2lzdGVyIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gICAgbGV0IHRvX3N0cmluZyA9IHRvX3N0cmluZ1xuICAgIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5JbnRcIlxuICBlbmQpXG5cbigqIE9wZW4gcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGFmdGVyIGluY2x1ZGluZyBmdW5jdG9yIGluc3RhbnRpYXRpb25zIHNvXG4gICB0aGV5IGRvIG5vdCBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnNcbiAgIG9mIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9ucyBhcmUgYXZhaWxhYmxlIHdpdGhpbiB0aGlzIG1vZHVsZS4gKilcbm9wZW4hIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxubGV0IGludmFyaWFudCAoXyA6IHQpID0gKClcbmxldCBiZXR3ZWVuIHQgfmxvdyB+aGlnaCA9IGxvdyA8PSB0ICYmIHQgPD0gaGlnaFxubGV0IGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heCA9IGlmIHQgPCBtaW4gdGhlbiBtaW4gZWxzZSBpZiB0IDw9IG1heCB0aGVuIHQgZWxzZSBtYXhcblxubGV0IGNsYW1wX2V4biB0IH5taW4gfm1heCA9XG4gIGFzc2VydCAobWluIDw9IG1heCk7XG4gIGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heFxuOztcblxubGV0IGNsYW1wIHQgfm1pbiB+bWF4ID1cbiAgaWYgbWluID4gbWF4XG4gIHRoZW5cbiAgICBPcl9lcnJvci5lcnJvcl9zXG4gICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICBcImNsYW1wIHJlcXVpcmVzIFttaW4gPD0gbWF4XVwiXG4gICAgICAgICBbIFwibWluXCIsIFQuc2V4cF9vZl90IG1pbjsgXCJtYXhcIiwgVC5zZXhwX29mX3QgbWF4IF0pXG4gIGVsc2UgT2sgKGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heClcbjs7XG5cbmV4dGVybmFsIHRvX2ludDMyX3RydW5jIDogdCAtPiBpbnQzMiA9IFwiJWludDMyX29mX2ludFwiXG5leHRlcm5hbCBvZl9pbnQzMl90cnVuYyA6IGludDMyIC0+IHQgPSBcIiVpbnQzMl90b19pbnRcIlxuZXh0ZXJuYWwgb2ZfaW50NjRfdHJ1bmMgOiBpbnQ2NCAtPiB0ID0gXCIlaW50NjRfdG9faW50XCJcbmV4dGVybmFsIG9mX25hdGl2ZWludF90cnVuYyA6IG5hdGl2ZWludCAtPiB0ID0gXCIlbmF0aXZlaW50X3RvX2ludFwiXG5cbmxldCBwcmVkIGkgPSBpIC0gMVxubGV0IHN1Y2MgaSA9IGkgKyAxXG5sZXQgdG9faW50IGkgPSBpXG5sZXQgdG9faW50X2V4biA9IHRvX2ludFxubGV0IG9mX2ludCBpID0gaVxubGV0IG9mX2ludF9leG4gPSBvZl9pbnRcbmxldCBtYXhfdmFsdWUgPSBDYW1sLm1heF9pbnRcbmxldCBtaW5fdmFsdWUgPSBDYW1sLm1pbl9pbnRcbmxldCBtYXhfdmFsdWVfMzBfYml0cyA9IDB4M0ZGRl9GRkZGXG5sZXQgb2ZfaW50MzIgPSBDb252LmludDMyX3RvX2ludFxubGV0IG9mX2ludDMyX2V4biA9IENvbnYuaW50MzJfdG9faW50X2V4blxubGV0IHRvX2ludDMyID0gQ29udi5pbnRfdG9faW50MzJcbmxldCB0b19pbnQzMl9leG4gPSBDb252LmludF90b19pbnQzMl9leG5cbmxldCBvZl9pbnQ2NCA9IENvbnYuaW50NjRfdG9faW50XG5sZXQgb2ZfaW50NjRfZXhuID0gQ29udi5pbnQ2NF90b19pbnRfZXhuXG5sZXQgdG9faW50NjQgPSBDb252LmludF90b19pbnQ2NFxubGV0IG9mX25hdGl2ZWludCA9IENvbnYubmF0aXZlaW50X3RvX2ludFxubGV0IG9mX25hdGl2ZWludF9leG4gPSBDb252Lm5hdGl2ZWludF90b19pbnRfZXhuXG5sZXQgdG9fbmF0aXZlaW50ID0gQ29udi5pbnRfdG9fbmF0aXZlaW50XG5sZXQgdG9fbmF0aXZlaW50X2V4biA9IHRvX25hdGl2ZWludFxubGV0IGFicyB4ID0gYWJzIHhcblxuKCogbm90ZSB0aGF0IHJlbSBpcyBub3Qgc2FtZSBhcyAlICopXG5sZXQgcmVtIGEgYiA9IGEgbW9kIGJcbmxldCBpbmNyID0gQ2FtbC5pbmNyXG5sZXQgZGVjciA9IENhbWwuZGVjclxubGV0IHNoaWZ0X3JpZ2h0IGEgYiA9IGEgYXNyIGJcbmxldCBzaGlmdF9yaWdodF9sb2dpY2FsIGEgYiA9IGEgbHNyIGJcbmxldCBzaGlmdF9sZWZ0IGEgYiA9IGEgbHNsIGJcbmxldCBiaXRfbm90IGEgPSBsbm90IGFcbmxldCBiaXRfb3IgYSBiID0gYSBsb3IgYlxubGV0IGJpdF9hbmQgYSBiID0gYSBsYW5kIGJcbmxldCBiaXRfeG9yIGEgYiA9IGEgbHhvciBiXG5sZXQgcG93ID0gSW50X21hdGguUHJpdmF0ZS5pbnRfcG93XG5sZXQgKCAqKiApIGIgZSA9IHBvdyBiIGVcblxubW9kdWxlIFBvdzIgPSBzdHJ1Y3RcbiAgb3BlbiEgSW1wb3J0XG5cbiAgbGV0IHJhaXNlX3MgPSBFcnJvci5yYWlzZV9zXG5cbiAgbGV0IG5vbl9wb3NpdGl2ZV9hcmd1bWVudCAoKSA9XG4gICAgUHJpbnRmLmludmFsaWRfYXJnZiBcImFyZ3VtZW50IG11c3QgYmUgc3RyaWN0bHkgcG9zaXRpdmVcIiAoKVxuICA7O1xuXG5cbiAgKCoqIFwiY2VpbGluZyBwb3dlciBvZiAyXCIgLSBMZWFzdCBwb3dlciBvZiAyIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB4LiAqKVxuICBsZXQgY2VpbF9wb3cyIHggPVxuICAgIGlmIHggPD0gMCB0aGVuIG5vbl9wb3NpdGl2ZV9hcmd1bWVudCAoKTtcbiAgICBsZXQgeCA9IHggLSAxIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMSkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAyKSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDQpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgOCkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAxNikgaW5cbiAgICAoKiBUaGUgbmV4dCBsaW5lIGlzIHN1cGVyZmx1b3VzIG9uIDMyLWJpdCBhcmNoaXRlY3R1cmVzLCBidXQgaXQncyBmYXN0ZXIgdG8gZG8gaXRcbiAgICAgICBhbnl3YXkgdGhhbiB0byBicmFuY2ggKilcbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAzMikgaW5cbiAgICB4ICsgMVxuICA7O1xuXG4gICgqKiBcImZsb29yIHBvd2VyIG9mIDJcIiAtIExhcmdlc3QgcG93ZXIgb2YgMiBsZXNzIHRoYW4gb3IgZXF1YWwgdG8geC4gKilcbiAgbGV0IGZsb29yX3BvdzIgeCA9XG4gICAgaWYgeCA8PSAwIHRoZW4gbm9uX3Bvc2l0aXZlX2FyZ3VtZW50ICgpO1xuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDEpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMikgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciA0KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDgpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMTYpIGluXG4gICAgKCogVGhlIG5leHQgbGluZSBpcyBzdXBlcmZsdW91cyBvbiAzMi1iaXQgYXJjaGl0ZWN0dXJlcywgYnV0IGl0J3MgZmFzdGVyIHRvIGRvIGl0XG4gICAgICAgYW55d2F5IHRoYW4gdG8gYnJhbmNoICopXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMzIpIGluXG4gICAgeCAtICh4IGxzciAxKVxuICA7O1xuXG4gIGxldCBpc19wb3cyIHggPVxuICAgIGlmIHggPD0gMCB0aGVuIG5vbl9wb3NpdGl2ZV9hcmd1bWVudCAoKTtcbiAgICB4IGxhbmQgKHggLSAxKSA9IDBcbiAgOztcblxuICAoKiBDIHN0dWJzIGZvciBpbnQgY2x6IGFuZCBjdHogdG8gdXNlIHRoZSBDTFovQlNSL0NUWi9CU0YgaW5zdHJ1Y3Rpb24gd2hlcmUgcG9zc2libGUgKilcbiAgZXh0ZXJuYWwgY2x6XG4gICAgOiAgKCogTm90ZSB0aGF0IHdlIHBhc3MgdGhlIHRhZ2dlZCBpbnQgaGVyZS4gU2VlIGludF9tYXRoX3N0dWJzLmMgZm9yIGRldGFpbHMgb24gd2h5XG4gICAgICAgICAgdGhpcyBpcyBjb3JyZWN0LiAqKVxuICAgIGludFxuICAgIC0+IChpbnRbQHVudGFnZ2VkXSlcbiAgICA9IFwiQmFzZV9pbnRfbWF0aF9pbnRfY2x6XCIgXCJCYXNlX2ludF9tYXRoX2ludF9jbHpfdW50YWdnZWRcIlxuICBbQEBub2FsbG9jXVxuXG4gIGV4dGVybmFsIGN0elxuICAgIDogIChpbnRbQHVudGFnZ2VkXSlcbiAgICAtPiAoaW50W0B1bnRhZ2dlZF0pXG4gICAgPSBcIkJhc2VfaW50X21hdGhfaW50X2N0elwiIFwiQmFzZV9pbnRfbWF0aF9pbnRfY3R6X3VudGFnZ2VkXCJcbiAgW0BAbm9hbGxvY11cblxuICAoKiogSGFja2VyJ3MgRGVsaWdodCBTZWNvbmQgRWRpdGlvbiBwMTA2ICopXG4gIGxldCBmbG9vcl9sb2cyIGkgPVxuICAgIGlmIGkgPD0gMFxuICAgIHRoZW4gcmFpc2VfcyAoU2V4cC5tZXNzYWdlIFwiW0ludC5mbG9vcl9sb2cyXSBnb3QgaW52YWxpZCBpbnB1dFwiIFsgXCJcIiwgc2V4cF9vZl9pbnQgaSBdKTtcbiAgICBudW1fYml0cyAtIDEgLSBjbHogaVxuICA7O1xuXG4gIGxldCBjZWlsX2xvZzIgaSA9XG4gICAgaWYgaSA8PSAwXG4gICAgdGhlbiByYWlzZV9zIChTZXhwLm1lc3NhZ2UgXCJbSW50LmNlaWxfbG9nMl0gZ290IGludmFsaWQgaW5wdXRcIiBbIFwiXCIsIHNleHBfb2ZfaW50IGkgXSk7XG4gICAgaWYgaSA9IDEgdGhlbiAwIGVsc2UgbnVtX2JpdHMgLSBjbHogKGkgLSAxKVxuICA7O1xuZW5kXG5cbmluY2x1ZGUgUG93MlxuXG5sZXQgc2lnbiA9IFNpZ24ub2ZfaW50XG5sZXQgcG9wY291bnQgPSBQb3Bjb3VudC5pbnRfcG9wY291bnRcblxubW9kdWxlIFByZV9PID0gc3RydWN0XG4gIGV4dGVybmFsICggKyApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVhZGRpbnRcIlxuICBleHRlcm5hbCAoIC0gKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlc3ViaW50XCJcbiAgZXh0ZXJuYWwgKCAqICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJW11bGludFwiXG4gIGV4dGVybmFsICggLyApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVkaXZpbnRcIlxuICBleHRlcm5hbCAoIH4tICkgOiBpbnQgLT4gaW50ID0gXCIlbmVnaW50XCJcblxuICBsZXQgKCAqKiApID0gKCAqKiApXG5cbiAgaW5jbHVkZSBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbiAgbGV0IGFicyA9IGFic1xuXG4gIGV4dGVybmFsIG5lZyA6IHQgLT4gdCA9IFwiJW5lZ2ludFwiXG5cbiAgbGV0IHplcm8gPSB6ZXJvXG4gIGxldCBvZl9pbnRfZXhuID0gb2ZfaW50X2V4blxuZW5kXG5cbm1vZHVsZSBPID0gc3RydWN0XG4gIGluY2x1ZGUgUHJlX09cblxuICBtb2R1bGUgRiA9IEludF9tYXRoLk1ha2UgKHN0cnVjdFxuICAgICAgdHlwZSBub25yZWMgdCA9IHRcblxuICAgICAgaW5jbHVkZSBQcmVfT1xuXG4gICAgICBsZXQgcmVtID0gcmVtXG4gICAgICBsZXQgdG9fZmxvYXQgPSB0b19mbG9hdFxuICAgICAgbGV0IG9mX2Zsb2F0ID0gb2ZfZmxvYXRcbiAgICAgIGxldCBvZl9zdHJpbmcgPSBULm9mX3N0cmluZ1xuICAgICAgbGV0IHRvX3N0cmluZyA9IFQudG9fc3RyaW5nXG4gICAgZW5kKVxuXG4gIGluY2x1ZGUgRlxuXG4gIGV4dGVybmFsIGJzd2FwMTYgOiBpbnQgLT4gaW50ID0gXCIlYnN3YXAxNlwiXG5cbiAgKCogVGhlc2UgaW5saW5lZCB2ZXJzaW9ucyBvZiAoJSksICgvJSksIGFuZCAoLy8pIHBlcmZvcm0gYmV0dGVyIHRoYW4gdGhlaXIgZnVuY3Rvcml6ZWRcbiAgICAgY291bnRlcnBhcnRzIGluIFtGXSAoc2VlIGJlbmNobWFya3MgYmVsb3cpLlxuXG4gICAgIFRoZSByZWFzb24gdGhlc2UgZnVuY3Rpb25zIGFyZSBpbmxpbmVkIGluIFtJbnRdIGJ1dCBub3QgaW4gYW55IG9mIHRoZSBvdGhlciBpbnRlZ2VyXG4gICAgIG1vZHVsZXMgaXMgdGhhdCB0aGV5IGV4aXN0ZWQgaW4gW0ludF0gYW5kIFtJbnRdIGFsb25lIHByaW9yIHRvIHRoZSBpbnRyb2R1Y3Rpb24gb2ZcbiAgICAgdGhlIFtJbnRfbWF0aC5NYWtlXSBmdW5jdG9yLCBhbmQgd2UgZGlkbid0IHdhbnQgdG8gZGVncmFkZSB0aGVpciBwZXJmb3JtYW5jZS5cblxuICAgICBXZSB3b24ndCBwcmUtZW1wdGl2ZWx5IGRvIHRoZSBzYW1lIGZvciBuZXcgZnVuY3Rpb25zLCB1bmxlc3Mgc29tZW9uZSBjYXJlcywgb24gYSBjYXNlXG4gICAgIGJ5IGNhc2UgZmFzaGlvbi4gICopXG5cbiAgbGV0ICggJSApIHggeSA9XG4gICAgaWYgeSA8PSB6ZXJvXG4gICAgdGhlblxuICAgICAgUHJpbnRmLmludmFsaWRfYXJnZlxuICAgICAgICBcIiVzICUlICVzIGluIGNvcmVfaW50Lm1sOiBtb2R1bHVzIHNob3VsZCBiZSBwb3NpdGl2ZVwiXG4gICAgICAgICh0b19zdHJpbmcgeClcbiAgICAgICAgKHRvX3N0cmluZyB5KVxuICAgICAgICAoKTtcbiAgICBsZXQgcnZhbCA9IHJlbSB4IHkgaW5cbiAgICBpZiBydmFsIDwgemVybyB0aGVuIHJ2YWwgKyB5IGVsc2UgcnZhbFxuICA7O1xuXG4gIGxldCAoIC8lICkgeCB5ID1cbiAgICBpZiB5IDw9IHplcm9cbiAgICB0aGVuXG4gICAgICBQcmludGYuaW52YWxpZF9hcmdmXG4gICAgICAgIFwiJXMgLyUlICVzIGluIGNvcmVfaW50Lm1sOiBkaXZpc29yIHNob3VsZCBiZSBwb3NpdGl2ZVwiXG4gICAgICAgICh0b19zdHJpbmcgeClcbiAgICAgICAgKHRvX3N0cmluZyB5KVxuICAgICAgICAoKTtcbiAgICBpZiB4IDwgemVybyB0aGVuICgoeCArIG9uZSkgLyB5KSAtIG9uZSBlbHNlIHggLyB5XG4gIDs7XG5cbiAgbGV0ICggLy8gKSB4IHkgPSB0b19mbG9hdCB4IC8uIHRvX2Zsb2F0IHlcblxuICBleHRlcm5hbCAoIGxhbmQgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYW5kaW50XCJcbiAgZXh0ZXJuYWwgKCBsb3IgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlb3JpbnRcIlxuICBleHRlcm5hbCAoIGx4b3IgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIleG9yaW50XCJcblxuICBsZXQgbG5vdCA9IGxub3RcblxuICBleHRlcm5hbCAoIGxzbCApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVsc2xpbnRcIlxuICBleHRlcm5hbCAoIGxzciApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVsc3JpbnRcIlxuICBleHRlcm5hbCAoIGFzciApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVhc3JpbnRcIlxuZW5kXG5cbmluY2x1ZGUgT1xuXG4oKiBbSW50XSBhbmQgW0ludC5PXSBhZ3JlZSB2YWx1ZS13aXNlICopXG5cbm1vZHVsZSBQcml2YXRlID0gc3RydWN0XG4gIG1vZHVsZSBPX0YgPSBPLkZcbmVuZFxuXG4oKiBJbmNsdWRlIHR5cGUtc3BlY2lmaWMgW1JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZV0gYXQgdGhlIGVuZCwgYWZ0ZXIgaW5jbHVkaW5nIGZ1bmN0b3JcbiAgIGFwcGxpY2F0aW9uIHRoYXQgY291bGQgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpcyBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zXG4gICBvZiB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbnMgYXJlIGV4cG9ydGVkIGJ5IHRoaXMgbW9kdWxlLiAqKVxuaW5jbHVkZSBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG4iLCJvcGVuISBJbXBvcnRcblxubGV0IGZhaWx3aXRoZiA9IFByaW50Zi5mYWlsd2l0aGZcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBVY2hhcjBcblxuICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuVWNoYXJcIlxuICBsZXQgaGFzaF9mb2xkX3Qgc3RhdGUgdCA9IEhhc2guZm9sZF9pbnQgc3RhdGUgKHRvX2ludCB0KVxuICBsZXQgaGFzaCB0ID0gSGFzaC5ydW4gaGFzaF9mb2xkX3QgdFxuICBsZXQgdG9fc3RyaW5nIHQgPSBQcmludGYuc3ByaW50ZiBcIlUrJTA0WFwiICh0b19pbnQgdClcblxuICAoKiBEbyBub3QgYWN0dWFsbHkgZXhwb3J0IHRoaXMuIFNlZSBkaXNjdXNzaW9uIGluIHRoZSAubWxpICopXG5cbiAgbGV0IHNleHBfb2ZfdCB0ID0gU2V4cC5BdG9tICh0b19zdHJpbmcgdClcblxuICBsZXQgdF9vZl9zZXhwIHNleHAgPVxuICAgIG1hdGNoIHNleHAgd2l0aFxuICAgIHwgU2V4cC5MaXN0IF8gLT4gb2Zfc2V4cF9lcnJvciBcIlVjaGFyLnRfb2Zfc2V4cDogYXRvbSBuZWVkZWRcIiBzZXhwXG4gICAgfCBTZXhwLkF0b20gcyAtPlxuICAgICAgKHRyeSBDYW1sLlNjYW5mLnNzY2FuZiBzIFwiVSslWFwiIChmdW4gaSAtPiBVY2hhcjAub2ZfaW50IGkpIHdpdGhcbiAgICAgICB8IF8gLT4gb2Zfc2V4cF9lcnJvciBcIlVjaGFyLnRfb2Zfc2V4cDogYXRvbSBvZiB0aGUgZm9ybSBVK1hYWFggbmVlZGVkXCIgc2V4cClcbiAgOztcblxuICBsZXQgdF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50ID1cbiAgICBTZXhwbGliMC5TZXhwX2dyYW1tYXIuY29lcmNlIFN0cmluZy50X3NleHBfZ3JhbW1hclxuICA7O1xuZW5kXG5cbmluY2x1ZGUgVFxuaW5jbHVkZSBQcmV0dHlfcHJpbnRlci5SZWdpc3RlciAoVClcbmluY2x1ZGUgQ29tcGFyYWJsZS5NYWtlIChUKVxuXG4oKiBPcGVuIHJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBhZnRlciBpbmNsdWRpbmcgZnVuY3RvciBpbnN0YW50aWF0aW9ucyBzbyB0aGV5IGRvIG5vdFxuICAgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpcyBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uXG4gICBmdW5jdGlvbnMgYXJlIGF2YWlsYWJsZSB3aXRoaW4gdGhpcyBtb2R1bGUuICopXG5vcGVuISBVY2hhcl9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxubGV0IGludmFyaWFudCAoXyA6IHQpID0gKClcbmxldCBpbnRfaXNfc2NhbGFyID0gaXNfdmFsaWRcblxubGV0IHN1Y2NfZXhuIGMgPVxuICB0cnkgVWNoYXIwLnN1Y2MgYyB3aXRoXG4gIHwgSW52YWxpZF9hcmd1bWVudCBtc2cgLT4gZmFpbHdpdGhmIFwiVWNoYXIuc3VjY19leG46ICVzXCIgbXNnICgpXG47O1xuXG5sZXQgc3VjYyBjID1cbiAgdHJ5IFNvbWUgKFVjaGFyMC5zdWNjIGMpIHdpdGhcbiAgfCBJbnZhbGlkX2FyZ3VtZW50IF8gLT4gTm9uZVxuOztcblxubGV0IHByZWRfZXhuIGMgPVxuICB0cnkgVWNoYXIwLnByZWQgYyB3aXRoXG4gIHwgSW52YWxpZF9hcmd1bWVudCBtc2cgLT4gZmFpbHdpdGhmIFwiVWNoYXIucHJlZF9leG46ICVzXCIgbXNnICgpXG47O1xuXG5sZXQgcHJlZCBjID1cbiAgdHJ5IFNvbWUgKFVjaGFyMC5wcmVkIGMpIHdpdGhcbiAgfCBJbnZhbGlkX2FyZ3VtZW50IF8gLT4gTm9uZVxuOztcblxubGV0IG9mX3NjYWxhciBpID0gaWYgaW50X2lzX3NjYWxhciBpIHRoZW4gU29tZSAodW5zYWZlX29mX2ludCBpKSBlbHNlIE5vbmVcblxubGV0IG9mX3NjYWxhcl9leG4gaSA9XG4gIGlmIGludF9pc19zY2FsYXIgaVxuICB0aGVuIHVuc2FmZV9vZl9pbnQgaVxuICBlbHNlIGZhaWx3aXRoZiBcIlVjaGFyLm9mX2ludF9leG4gZ290IGEgaW52YWxpZCBVbmljb2RlIHNjYWxhciB2YWx1ZTogJTA0WFwiIGkgKClcbjs7XG5cbmxldCB0b19zY2FsYXIgdCA9IFVjaGFyMC50b19pbnQgdFxubGV0IHRvX2NoYXIgYyA9IGlmIGlzX2NoYXIgYyB0aGVuIFNvbWUgKHVuc2FmZV90b19jaGFyIGMpIGVsc2UgTm9uZVxuXG5sZXQgdG9fY2hhcl9leG4gYyA9XG4gIGlmIGlzX2NoYXIgY1xuICB0aGVuIHVuc2FmZV90b19jaGFyIGNcbiAgZWxzZSBmYWlsd2l0aGYgXCJVY2hhci50b19jaGFyX2V4biBnb3QgYSBub24gbGF0aW4tMSBjaGFyYWN0ZXI6IFUrJTA0WFwiICh0b19pbnQgYykgKClcbjs7XG5cbmxldCB1dGY4X2J5dGVfbGVuZ3RoIHVjaGFyID1cbiAgbGV0IGNvZGVwb2ludCA9IHRvX3NjYWxhciB1Y2hhciBpblxuICBpZiBJbnQuKCA8ICkgY29kZXBvaW50IDB4ODBcbiAgdGhlbiAxXG4gIGVsc2UgaWYgSW50LiggPCApIGNvZGVwb2ludCAweDgwMFxuICB0aGVuIDJcbiAgZWxzZSBpZiBJbnQuKCA8ICkgY29kZXBvaW50IDB4MTAwMDBcbiAgdGhlbiAzXG4gIGVsc2UgNFxuOztcblxuKCogSW5jbHVkZSB0eXBlLXNwZWNpZmljIFtSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVdIGF0IHRoZSBlbmQsIGFmdGVyXG4gICBpbmNsdWRpbmcgZnVuY3RvciBhcHBsaWNhdGlvbiB0aGF0IGNvdWxkIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXNcbiAgIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25zIGFyZSBleHBvcnRlZCBieVxuICAgdGhpcyBtb2R1bGUuICopXG5pbmNsdWRlIFVjaGFyX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuIiwib3BlbiEgSW1wb3J0XG5cbnR5cGUgKCdhLCAnYikgdCA9IFQgOiAoJ2EsICdhKSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG5sZXQgc2V4cF9vZl90IDpcbiAgJ2EgJ2IuXG4gICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICgnYiAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICgnYSwgJ2IpIHQgLT4gU2V4cGxpYjAuU2V4cC50XG4gID1cbiAgZnVuICh0eXBlIGFfXzAwM18gYl9fMDA0XylcbiAgICAgIDogICgoYV9fMDAzXyAtPiBTZXhwbGliMC5TZXhwLnQpIC0+IChiX18wMDRfIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgICAgICAtPiAoYV9fMDAzXywgYl9fMDA0XykgdCAtPiBTZXhwbGliMC5TZXhwLnQpIC0+XG4gICAgZnVuIF9vZl9hX18wMDFfIF9vZl9iX18wMDJfIFQgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiVFwiXG47O1xuXG5bQEBAZW5kXVxuXG50eXBlICgnYSwgJ2IpIGVxdWFsID0gKCdhLCAnYikgdFxuXG5sZXQgcmVmbCA9IFRcbmxldCBzeW0gKHR5cGUgYSBiKSAoVCA6IChhLCBiKSB0KSA6IChiLCBhKSB0ID0gVFxubGV0IHRyYW5zICh0eXBlIGEgYiBjKSAoVCA6IChhLCBiKSB0KSAoVCA6IChiLCBjKSB0KSA6IChhLCBjKSB0ID0gVFxubGV0IGNvbnYgKHR5cGUgYSBiKSAoVCA6IChhLCBiKSB0KSAoYSA6IGEpIDogYiA9IGFcblxubW9kdWxlIExpZnQgKFggOiBzaWdcbiAgICB0eXBlICdhIHRcbiAgZW5kKSA9XG5zdHJ1Y3RcbiAgbGV0IGxpZnQgKHR5cGUgYSBiKSAoVCA6IChhLCBiKSB0KSA6IChhIFgudCwgYiBYLnQpIHQgPSBUXG5lbmRcblxubW9kdWxlIExpZnQyIChYIDogc2lnXG4gICAgdHlwZSAoJ2ExLCAnYTIpIHRcbiAgZW5kKSA9XG5zdHJ1Y3RcbiAgbGV0IGxpZnQgKHR5cGUgYTEgYjEgYTIgYjIpIChUIDogKGExLCBiMSkgdCkgKFQgOiAoYTIsIGIyKSB0KVxuICAgIDogKChhMSwgYTIpIFgudCwgKGIxLCBiMikgWC50KSB0XG4gICAgPVxuICAgIFRcbiAgOztcbmVuZFxuXG5tb2R1bGUgTGlmdDMgKFggOiBzaWdcbiAgICB0eXBlICgnYTEsICdhMiwgJ2EzKSB0XG4gIGVuZCkgPVxuc3RydWN0XG4gIGxldCBsaWZ0ICh0eXBlIGExIGIxIGEyIGIyIGEzIGIzKSAoVCA6IChhMSwgYjEpIHQpIChUIDogKGEyLCBiMikgdCkgKFQgOiAoYTMsIGIzKSB0KVxuICAgIDogKChhMSwgYTIsIGEzKSBYLnQsIChiMSwgYjIsIGIzKSBYLnQpIHRcbiAgICA9XG4gICAgVFxuICA7O1xuZW5kXG5cbmxldCBkZXR1cGxlMiAodHlwZSBhMSBhMiBiMSBiMikgKFQgOiAoYTEgKiBhMiwgYjEgKiBiMikgdCkgOiAoYTEsIGIxKSB0ICogKGEyLCBiMikgdCA9XG4gIFQsIFRcbjs7XG5cbmxldCB0dXBsZTIgKHR5cGUgYTEgYTIgYjEgYjIpIChUIDogKGExLCBiMSkgdCkgKFQgOiAoYTIsIGIyKSB0KSA6IChhMSAqIGEyLCBiMSAqIGIyKSB0ID0gVFxuXG5tb2R1bGUgdHlwZSBJbmplY3RpdmUgPSBzaWdcbiAgdHlwZSAnYSB0XG5cbiAgdmFsIHN0cmlwIDogKCdhIHQsICdiIHQpIGVxdWFsIC0+ICgnYSwgJ2IpIGVxdWFsXG5lbmRcblxubW9kdWxlIHR5cGUgSW5qZWN0aXZlMiA9IHNpZ1xuICB0eXBlICgnYTEsICdhMikgdFxuXG4gIHZhbCBzdHJpcCA6ICgoJ2ExLCAnYTIpIHQsICgnYjEsICdiMikgdCkgZXF1YWwgLT4gKCdhMSwgJ2IxKSBlcXVhbCAqICgnYTIsICdiMikgZXF1YWxcbmVuZFxuXG5tb2R1bGUgQ29tcG9zaXRpb25fcHJlc2VydmVzX2luamVjdGl2aXR5IChNMSA6IEluamVjdGl2ZSkgKE0yIDogSW5qZWN0aXZlKSA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSAnYSBNMS50IE0yLnRcblxuICBsZXQgc3RyaXAgZSA9IE0xLnN0cmlwIChNMi5zdHJpcCBlKVxuZW5kXG5cbm1vZHVsZSBJZCA9IHN0cnVjdFxuICBtb2R1bGUgVWlkID0gSW50XG5cbiAgbW9kdWxlIFdpdG5lc3MgPSBzdHJ1Y3RcbiAgICBtb2R1bGUgS2V5ID0gc3RydWN0XG4gICAgICB0eXBlIF8gdCA9IC4uXG4gICAgICB0eXBlIHR5cGVfd2l0bmVzc19pbnQgPSBbIGB0eXBlX3dpdG5lc3Mgb2YgaW50IF0gW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgICAgIGxldCBzZXhwX29mX3R5cGVfd2l0bmVzc19pbnQgPVxuICAgICAgICAoZnVuIChgdHlwZV93aXRuZXNzIHZfXzAwNV8pIC0+XG4gICAgICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcInR5cGVfd2l0bmVzc1wiOyBzZXhwX29mX2ludCB2X18wMDVfIF1cbiAgICAgICAgICAgOiB0eXBlX3dpdG5lc3NfaW50IC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgIDs7XG5cbiAgICAgIFtAQEBlbmRdXG5cbiAgICAgIGxldCBzZXhwX29mX3QgX3NleHBfb2ZfYSB0ID1cbiAgICAgICAgYHR5cGVfd2l0bmVzc1xuICAgICAgICAgIChDYW1sLk9iai5FeHRlbnNpb25fY29uc3RydWN0b3IuaWQgKENhbWwuT2JqLkV4dGVuc2lvbl9jb25zdHJ1Y3Rvci5vZl92YWwgdCkpXG4gICAgICAgIHw+IHNleHBfb2ZfdHlwZV93aXRuZXNzX2ludFxuICAgICAgOztcbiAgICBlbmRcblxuICAgIG1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgICAgIHR5cGUgdFxuICAgICAgdHlwZSBfIEtleS50ICs9IEtleSA6IHQgS2V5LnRcbiAgICBlbmRcblxuICAgIHR5cGUgJ2EgdCA9IChtb2R1bGUgUyB3aXRoIHR5cGUgdCA9ICdhKVxuXG4gICAgbGV0IHNleHBfb2ZfdCAodHlwZSBhKSBzZXhwX29mX2EgKG1vZHVsZSBNIDogUyB3aXRoIHR5cGUgdCA9IGEpID1cbiAgICAgIE0uS2V5IHw+IEtleS5zZXhwX29mX3Qgc2V4cF9vZl9hXG4gICAgOztcblxuICAgIGxldCBjcmVhdGUgKHR5cGUgdCkgKCkgPVxuICAgICAgbGV0IG1vZHVsZSBNID0gc3RydWN0XG4gICAgICAgIHR5cGUgbm9ucmVjIHQgPSB0XG4gICAgICAgIHR5cGUgXyBLZXkudCArPSBLZXkgOiB0IEtleS50XG4gICAgICBlbmRcbiAgICAgIGluXG4gICAgICAobW9kdWxlIE0gOiBTIHdpdGggdHlwZSB0ID0gdClcbiAgICA7O1xuXG4gICAgbGV0IHVpZCAodHlwZSBhKSAobW9kdWxlIE0gOiBTIHdpdGggdHlwZSB0ID0gYSkgPVxuICAgICAgQ2FtbC5PYmouRXh0ZW5zaW9uX2NvbnN0cnVjdG9yLmlkIChDYW1sLk9iai5FeHRlbnNpb25fY29uc3RydWN0b3Iub2ZfdmFsIE0uS2V5KVxuICAgIDs7XG5cbiAgICAoKiBXZSB3YW50IGEgY29uc3RhbnQgYWxsb2NhdGVkIG9uY2UgdGhhdCBbc2FtZV0gY2FuIHJldHVybiB3aGVuZXZlciBpdCBnZXRzIHRoZSBzYW1lXG4gICAgICAgd2l0bmVzc2VzLiAgSWYgd2Ugd3JpdGUgdGhlIGNvbnN0YW50IGluc2lkZSB0aGUgYm9keSBvZiBbc2FtZV0sIHRoZSBuYXRpdmUtY29kZVxuICAgICAgIGNvbXBpbGVyIHdpbGwgZG8gdGhlIHJpZ2h0IHRoaW5nIGFuZCBsaWZ0IGl0IG91dC4gIEJ1dCBmb3IgY2xhcml0eSBhbmQgcm9idXN0bmVzcyxcbiAgICAgICB3ZSBkbyBpdCBvdXJzZWx2ZXMuICopXG4gICAgbGV0IHNvbWVfdCA9IFNvbWUgVFxuXG4gICAgbGV0IHNhbWUgKHR5cGUgYSBiKSAoYSA6IGEgdCkgKGIgOiBiIHQpIDogKGEsIGIpIGVxdWFsIG9wdGlvbiA9XG4gICAgICBsZXQgbW9kdWxlIEEgPSAodmFsIGEgOiBTIHdpdGggdHlwZSB0ID0gYSkgaW5cbiAgICAgIGxldCBtb2R1bGUgQiA9ICh2YWwgYiA6IFMgd2l0aCB0eXBlIHQgPSBiKSBpblxuICAgICAgbWF0Y2ggQS5LZXkgd2l0aFxuICAgICAgfCBCLktleSAtPiBzb21lX3RcbiAgICAgIHwgXyAtPiBOb25lXG4gICAgOztcbiAgZW5kXG5cblxuICB0eXBlICdhIHQgPVxuICAgIHsgd2l0bmVzcyA6ICdhIFdpdG5lc3MudFxuICAgIDsgbmFtZSA6IHN0cmluZ1xuICAgIDsgdG9fc2V4cCA6ICdhIC0+IFNleHAudFxuICAgIH1cblxuICBsZXQgc2V4cF9vZl90IF8geyB3aXRuZXNzOyBuYW1lOyB0b19zZXhwIH0gOiBTZXhwLnQgPVxuICAgIGlmIGFtX3Rlc3RpbmdcbiAgICB0aGVuIEF0b20gbmFtZVxuICAgIGVsc2VcbiAgICAgIExpc3RcbiAgICAgICAgWyBMaXN0IFsgQXRvbSBcIm5hbWVcIjsgQXRvbSBuYW1lIF1cbiAgICAgICAgOyBMaXN0IFsgQXRvbSBcIndpdG5lc3NcIjsgd2l0bmVzcyB8PiBXaXRuZXNzLnNleHBfb2ZfdCB0b19zZXhwIF1cbiAgICAgICAgXVxuICA7O1xuXG4gIGxldCB0b19zZXhwIHQgPSB0LnRvX3NleHBcbiAgbGV0IG5hbWUgdCA9IHQubmFtZVxuICBsZXQgY3JlYXRlIH5uYW1lIHRvX3NleHAgPSB7IHdpdG5lc3MgPSBXaXRuZXNzLmNyZWF0ZSAoKTsgbmFtZTsgdG9fc2V4cCB9XG4gIGxldCB1aWQgdCA9IFdpdG5lc3MudWlkIHQud2l0bmVzc1xuICBsZXQgaGFzaCB0ID0gdWlkIHRcbiAgbGV0IGhhc2hfZm9sZF90IHMgdCA9IGhhc2hfZm9sZF9pbnQgcyAodWlkIHQpXG4gIGxldCBzYW1lX3dpdG5lc3MgdDEgdDIgPSBXaXRuZXNzLnNhbWUgdDEud2l0bmVzcyB0Mi53aXRuZXNzXG4gIGxldCBzYW1lIHQxIHQyID0gT3B0aW9uLmlzX3NvbWUgKHNhbWVfd2l0bmVzcyB0MSB0MilcblxuICBsZXQgc2FtZV93aXRuZXNzX2V4biB0MSB0MiA9XG4gICAgbWF0Y2ggc2FtZV93aXRuZXNzIHQxIHQyIHdpdGhcbiAgICB8IFNvbWUgdyAtPiB3XG4gICAgfCBOb25lIC0+XG4gICAgICBFcnJvci5yYWlzZV9zXG4gICAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgICAgXCJUeXBlX2VxdWFsLklkLnNhbWVfd2l0bmVzc19leG4gZ290IGRpZmZlcmVudCBpZHNcIlxuICAgICAgICAgICBbICggXCJcIlxuICAgICAgICAgICAgICwgc2V4cF9vZl9wYWlyIChzZXhwX29mX3Qgc2V4cF9vZl9vcGFxdWUpIChzZXhwX29mX3Qgc2V4cF9vZl9vcGFxdWUpICh0MSwgdDIpXG4gICAgICAgICAgICAgKVxuICAgICAgICAgICBdKVxuICA7O1xuZW5kXG4iLCJvcGVuISBJbXBvcnRcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB8IE5lZ1xuICAgIHwgWmVyb1xuICAgIHwgUG9zXG4gICAgfCBOYW5cbiAgW0BAZGVyaXZpbmdfaW5saW5lIHNleHAsIHNleHBfZ3JhbW1hciwgY29tcGFyZSwgaGFzaCwgZW51bWVyYXRlXVxuXG4gIGxldCB0X29mX3NleHAgPVxuICAgIChsZXQgZXJyb3Jfc291cmNlX18wMDNfID0gXCJzaWduX29yX25hbi5tbC5ULnRcIiBpblxuICAgICBmdW5jdGlvblxuICAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJuZWdcIiB8IFwiTmVnXCIpIC0+IE5lZ1xuICAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJ6ZXJvXCIgfCBcIlplcm9cIikgLT4gWmVyb1xuICAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJwb3NcIiB8IFwiUG9zXCIpIC0+IFBvc1xuICAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJuYW5cIiB8IFwiTmFuXCIpIC0+IE5hblxuICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcIm5lZ1wiIHwgXCJOZWdcIikgOjogXykgYXMgc2V4cF9fMDA0XyAtPlxuICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMDNfIHNleHBfXzAwNF9cbiAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJ6ZXJvXCIgfCBcIlplcm9cIikgOjogXykgYXMgc2V4cF9fMDA0XyAtPlxuICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMDNfIHNleHBfXzAwNF9cbiAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJwb3NcIiB8IFwiUG9zXCIpIDo6IF8pIGFzIHNleHBfXzAwNF8gLT5cbiAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDAzXyBzZXhwX18wMDRfXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gKFwibmFuXCIgfCBcIk5hblwiKSA6OiBfKSBhcyBzZXhwX18wMDRfIC0+XG4gICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAwM18gc2V4cF9fMDA0X1xuICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5MaXN0IF8gOjogXykgYXMgc2V4cF9fMDAyXyAtPlxuICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5uZXN0ZWRfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAwM18gc2V4cF9fMDAyX1xuICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCBbXSBhcyBzZXhwX18wMDJfIC0+XG4gICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLmVtcHR5X2xpc3RfaW52YWxpZF9zdW0gZXJyb3Jfc291cmNlX18wMDNfIHNleHBfXzAwMl9cbiAgICAgfCBzZXhwX18wMDJfIC0+XG4gICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnVuZXhwZWN0ZWRfc3RhZyBlcnJvcl9zb3VyY2VfXzAwM18gc2V4cF9fMDAyX1xuICAgICAgIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCA9XG4gICAgKGZ1bmN0aW9uXG4gICAgICB8IE5lZyAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJOZWdcIlxuICAgICAgfCBaZXJvIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIlplcm9cIlxuICAgICAgfCBQb3MgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiUG9zXCJcbiAgICAgIHwgTmFuIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIk5hblwiXG4gICAgICAgICAgICAgICA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICA7O1xuXG4gIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9XG4gICAgeyB1bnR5cGVkID1cbiAgICAgICAgVmFyaWFudFxuICAgICAgICAgIHsgY2FzZV9zZW5zaXRpdml0eSA9IENhc2Vfc2Vuc2l0aXZlX2V4Y2VwdF9maXJzdF9jaGFyYWN0ZXJcbiAgICAgICAgICA7IGNsYXVzZXMgPVxuICAgICAgICAgICAgICBbIE5vX3RhZyB7IG5hbWUgPSBcIk5lZ1wiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgICAgOyBOb190YWcgeyBuYW1lID0gXCJaZXJvXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgICA7IE5vX3RhZyB7IG5hbWUgPSBcIlBvc1wiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgICAgOyBOb190YWcgeyBuYW1lID0gXCJOYW5cIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICB9XG4gICAgfVxuICA7O1xuXG4gIGxldCBjb21wYXJlID0gKFBweF9jb21wYXJlX2xpYi5wb2x5bW9ycGhpY19jb21wYXJlIDogdCAtPiB0IC0+IGludClcblxuICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgKGZ1biBoc3YgYXJnIC0+XG4gICAgICAgbWF0Y2ggYXJnIHdpdGhcbiAgICAgICB8IE5lZyAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDBcbiAgICAgICB8IFplcm8gLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50IGhzdiAxXG4gICAgICAgfCBQb3MgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50IGhzdiAyXG4gICAgICAgfCBOYW4gLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50IGhzdiAzXG4gICAgICAgICAgICAgICAgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gIDs7XG5cbiAgbGV0IChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jIGFyZyA9XG4gICAgICBQcHhfaGFzaF9saWIuU3RkLkhhc2guZ2V0X2hhc2hfdmFsdWVcbiAgICAgICAgKGxldCBoc3YgPSBQcHhfaGFzaF9saWIuU3RkLkhhc2guY3JlYXRlICgpIGluXG4gICAgICAgICBoYXNoX2ZvbGRfdCBoc3YgYXJnKVxuICAgIGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IGFsbCA9IChbIE5lZzsgWmVybzsgUG9zOyBOYW4gXSA6IHQgbGlzdClcblxuICBbQEBAZW5kXVxuXG4gIGxldCBvZl9zdHJpbmcgcyA9IHRfb2Zfc2V4cCAoc2V4cF9vZl9zdHJpbmcgcylcbiAgbGV0IHRvX3N0cmluZyB0ID0gc3RyaW5nX29mX3NleHAgKHNleHBfb2ZfdCB0KVxuICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuU2lnbl9vcl9uYW5cIlxuZW5kXG5cbm1vZHVsZSBSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgPSBzdHJ1Y3RcbiAgbGV0ICggPCApICh4IDogVC50KSB5ID0gUG9seS4oIDwgKSB4IHlcbiAgbGV0ICggPD0gKSAoeCA6IFQudCkgeSA9IFBvbHkuKCA8PSApIHggeVxuICBsZXQgKCA8PiApICh4IDogVC50KSB5ID0gUG9seS4oIDw+ICkgeCB5XG4gIGxldCAoID0gKSAoeCA6IFQudCkgeSA9IFBvbHkuKCA9ICkgeCB5XG4gIGxldCAoID4gKSAoeCA6IFQudCkgeSA9IFBvbHkuKCA+ICkgeCB5XG4gIGxldCAoID49ICkgKHggOiBULnQpIHkgPSBQb2x5LiggPj0gKSB4IHlcbiAgbGV0IGFzY2VuZGluZyAoeCA6IFQudCkgeSA9IFBvbHkuYXNjZW5kaW5nIHggeVxuICBsZXQgZGVzY2VuZGluZyAoeCA6IFQudCkgeSA9IFBvbHkuZGVzY2VuZGluZyB4IHlcbiAgbGV0IGNvbXBhcmUgKHggOiBULnQpIHkgPSBQb2x5LmNvbXBhcmUgeCB5XG4gIGxldCBlcXVhbCAoeCA6IFQudCkgeSA9IFBvbHkuZXF1YWwgeCB5XG4gIGxldCBtYXggKHggOiBULnQpIHkgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgeVxuICBsZXQgbWluICh4IDogVC50KSB5ID0gaWYgeCA8PSB5IHRoZW4geCBlbHNlIHlcbmVuZFxuXG5pbmNsdWRlIFRcbmluY2x1ZGUgSWRlbnRpZmlhYmxlLk1ha2UgKFQpXG5cbigqIE9wZW4gW1JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZV0gYWZ0ZXIgaW5jbHVkaW5nIGZ1bmN0b3IgYXBwbGljYXRpb25zIHNvIHRoZXkgZG8gbm90XG4gICBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb25cbiAgIGZ1bmN0aW9ucyBhcmUgYXZhaWxhYmxlIHdpdGhpbiB0aGlzIG1vZHVsZS4gKilcbm9wZW4hIFJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG5sZXQgb2Zfc2lnbiA9IGZ1bmN0aW9uXG4gIHwgU2lnbi5OZWcgLT4gTmVnXG4gIHwgU2lnbi5aZXJvIC0+IFplcm9cbiAgfCBTaWduLlBvcyAtPiBQb3Ncbjs7XG5cbmxldCB0b19zaWduX2V4biA9IGZ1bmN0aW9uXG4gIHwgTmVnIC0+IFNpZ24uTmVnXG4gIHwgWmVybyAtPiBTaWduLlplcm9cbiAgfCBQb3MgLT4gU2lnbi5Qb3NcbiAgfCBOYW4gLT4gaW52YWxpZF9hcmcgXCJCYXNlLlNpZ25fb3JfbmFuLnRvX3NpZ25fZXhuOiBOYW5cIlxuOztcblxubGV0IG9mX2ludCBuID0gb2Zfc2lnbiAoU2lnbi5vZl9pbnQgbilcbmxldCB0b19pbnRfZXhuIHQgPSBTaWduLnRvX2ludCAodG9fc2lnbl9leG4gdClcblxubGV0IGZsaXAgPSBmdW5jdGlvblxuICB8IE5lZyAtPiBQb3NcbiAgfCBaZXJvIC0+IFplcm9cbiAgfCBQb3MgLT4gTmVnXG4gIHwgTmFuIC0+IE5hblxuOztcblxubGV0ICggKiApIHQgdCcgPVxuICBtYXRjaCB0LCB0JyB3aXRoXG4gIHwgTmFuLCBfIHwgXywgTmFuIC0+IE5hblxuICB8IF8gLT4gb2Zfc2lnbiAoU2lnbi4oICogKSAodG9fc2lnbl9leG4gdCkgKHRvX3NpZ25fZXhuIHQnKSlcbjs7XG5cbigqIEluY2x1ZGUgW1JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZV0gYXQgdGhlIGVuZCwgYWZ0ZXIgYW55IGZ1bmN0b3IgYXBwbGljYXRpb25zIHRoYXRcbiAgIGNvdWxkIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXMgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvblxuICAgZnVuY3Rpb25zIGFyZSBleHBvcnRlZCBieSB0aGlzIG1vZHVsZS4gKilcbmluY2x1ZGUgUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG4iLCJvcGVuISBJbXBvcnRcblxudHlwZSAnYSB0ID1cbiAgfCBJbmNsIG9mICdhXG4gIHwgRXhjbCBvZiAnYVxuICB8IFVuYm91bmRlZFxuW0BAZGVyaXZpbmdfaW5saW5lIGVudW1lcmF0ZSwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG5sZXQgYWxsIDogJ2EuICdhIGxpc3QgLT4gJ2EgdCBsaXN0ID1cbiAgZnVuIF9hbGxfb2ZfYSAtPlxuICBQcHhfZW51bWVyYXRlX2xpYi5MaXN0LmFwcGVuZFxuICAgIChsZXQgcmVjIG1hcCBsIGFjYyA9XG4gICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICAgfCBbXSAtPiBQcHhfZW51bWVyYXRlX2xpYi5MaXN0LnJldiBhY2NcbiAgICAgICB8IGVudW1lcmF0ZV9fMDAxXyA6OiBsIC0+IG1hcCBsIChJbmNsIGVudW1lcmF0ZV9fMDAxXyA6OiBhY2MpXG4gICAgIGluXG4gICAgIG1hcCBfYWxsX29mX2EgW10pXG4gICAgKFBweF9lbnVtZXJhdGVfbGliLkxpc3QuYXBwZW5kXG4gICAgICAgKGxldCByZWMgbWFwIGwgYWNjID1cbiAgICAgICAgICBtYXRjaCBsIHdpdGhcbiAgICAgICAgICB8IFtdIC0+IFBweF9lbnVtZXJhdGVfbGliLkxpc3QucmV2IGFjY1xuICAgICAgICAgIHwgZW51bWVyYXRlX18wMDJfIDo6IGwgLT4gbWFwIGwgKEV4Y2wgZW51bWVyYXRlX18wMDJfIDo6IGFjYylcbiAgICAgICAgaW5cbiAgICAgICAgbWFwIF9hbGxfb2ZfYSBbXSlcbiAgICAgICBbIFVuYm91bmRlZCBdKVxuOztcblxubGV0IHRfb2Zfc2V4cCA6ICdhLiAoU2V4cGxpYjAuU2V4cC50IC0+ICdhKSAtPiBTZXhwbGliMC5TZXhwLnQgLT4gJ2EgdCA9XG4gIGZ1biAodHlwZSBhX18wMThfKSA6ICgoU2V4cGxpYjAuU2V4cC50IC0+IGFfXzAxOF8pIC0+IFNleHBsaWIwLlNleHAudCAtPiBhX18wMThfIHQpIC0+XG4gIGxldCBlcnJvcl9zb3VyY2VfXzAwNl8gPSBcIm1heWJlX2JvdW5kLm1sLnRcIiBpblxuICBmdW4gX29mX2FfXzAwM18gLT4gZnVuY3Rpb25cbiAgICB8IFNleHBsaWIwLlNleHAuTGlzdFxuICAgICAgICAoU2V4cGxpYjAuU2V4cC5BdG9tICgoXCJpbmNsXCIgfCBcIkluY2xcIikgYXMgX3RhZ19fMDA5XykgOjogc2V4cF9hcmdzX18wMTBfKSBhc1xuICAgICAgX3NleHBfXzAwOF8gLT5cbiAgICAgIChtYXRjaCBzZXhwX2FyZ3NfXzAxMF8gd2l0aFxuICAgICAgIHwgWyBhcmcwX18wMTFfIF0gLT5cbiAgICAgICAgIGxldCByZXMwX18wMTJfID0gX29mX2FfXzAwM18gYXJnMF9fMDExXyBpblxuICAgICAgICAgSW5jbCByZXMwX18wMTJfXG4gICAgICAgfCBfIC0+XG4gICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19pbmNvcnJlY3Rfbl9hcmdzXG4gICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDA2X1xuICAgICAgICAgICBfdGFnX18wMDlfXG4gICAgICAgICAgIF9zZXhwX18wMDhfKVxuICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0XG4gICAgICAgIChTZXhwbGliMC5TZXhwLkF0b20gKChcImV4Y2xcIiB8IFwiRXhjbFwiKSBhcyBfdGFnX18wMTRfKSA6OiBzZXhwX2FyZ3NfXzAxNV8pIGFzXG4gICAgICBfc2V4cF9fMDEzXyAtPlxuICAgICAgKG1hdGNoIHNleHBfYXJnc19fMDE1XyB3aXRoXG4gICAgICAgfCBbIGFyZzBfXzAxNl8gXSAtPlxuICAgICAgICAgbGV0IHJlczBfXzAxN18gPSBfb2ZfYV9fMDAzXyBhcmcwX18wMTZfIGluXG4gICAgICAgICBFeGNsIHJlczBfXzAxN19cbiAgICAgICB8IF8gLT5cbiAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX2luY29ycmVjdF9uX2FyZ3NcbiAgICAgICAgICAgZXJyb3Jfc291cmNlX18wMDZfXG4gICAgICAgICAgIF90YWdfXzAxNF9cbiAgICAgICAgICAgX3NleHBfXzAxM18pXG4gICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwidW5ib3VuZGVkXCIgfCBcIlVuYm91bmRlZFwiKSAtPiBVbmJvdW5kZWRcbiAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJpbmNsXCIgfCBcIkluY2xcIikgYXMgc2V4cF9fMDA3XyAtPlxuICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfdGFrZXNfYXJncyBlcnJvcl9zb3VyY2VfXzAwNl8gc2V4cF9fMDA3X1xuICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcImV4Y2xcIiB8IFwiRXhjbFwiKSBhcyBzZXhwX18wMDdfIC0+XG4gICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ190YWtlc19hcmdzIGVycm9yX3NvdXJjZV9fMDA2XyBzZXhwX18wMDdfXG4gICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJ1bmJvdW5kZWRcIiB8IFwiVW5ib3VuZGVkXCIpIDo6IF8pIGFzXG4gICAgICBzZXhwX18wMDdfIC0+IFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMDZfIHNleHBfXzAwN19cbiAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5MaXN0IF8gOjogXykgYXMgc2V4cF9fMDA1XyAtPlxuICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLm5lc3RlZF9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDA2XyBzZXhwX18wMDVfXG4gICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgW10gYXMgc2V4cF9fMDA1XyAtPlxuICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLmVtcHR5X2xpc3RfaW52YWxpZF9zdW0gZXJyb3Jfc291cmNlX18wMDZfIHNleHBfXzAwNV9cbiAgICB8IHNleHBfXzAwNV8gLT5cbiAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci51bmV4cGVjdGVkX3N0YWcgZXJyb3Jfc291cmNlX18wMDZfIHNleHBfXzAwNV9cbjs7XG5cbmxldCBzZXhwX29mX3QgOiAnYS4gKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgdCAtPiBTZXhwbGliMC5TZXhwLnQgPVxuICBmdW4gKHR5cGUgYV9fMDI0XykgOiAoKGFfXzAyNF8gLT4gU2V4cGxpYjAuU2V4cC50KSAtPiBhX18wMjRfIHQgLT4gU2V4cGxpYjAuU2V4cC50KSAtPlxuICBmdW4gX29mX2FfXzAxOV8gLT4gZnVuY3Rpb25cbiAgICB8IEluY2wgYXJnMF9fMDIwXyAtPlxuICAgICAgbGV0IHJlczBfXzAyMV8gPSBfb2ZfYV9fMDE5XyBhcmcwX18wMjBfIGluXG4gICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJJbmNsXCI7IHJlczBfXzAyMV8gXVxuICAgIHwgRXhjbCBhcmcwX18wMjJfIC0+XG4gICAgICBsZXQgcmVzMF9fMDIzXyA9IF9vZl9hX18wMTlfIGFyZzBfXzAyMl8gaW5cbiAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIkV4Y2xcIjsgcmVzMF9fMDIzXyBdXG4gICAgfCBVbmJvdW5kZWQgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiVW5ib3VuZGVkXCJcbjs7XG5cbmxldCAodF9zZXhwX2dyYW1tYXIgOiAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCAtPiAnYSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9XG4gIGZ1biBfJ2Ffc2V4cF9ncmFtbWFyIC0+XG4gIHsgdW50eXBlZCA9XG4gICAgICBWYXJpYW50XG4gICAgICAgIHsgY2FzZV9zZW5zaXRpdml0eSA9IENhc2Vfc2Vuc2l0aXZlX2V4Y2VwdF9maXJzdF9jaGFyYWN0ZXJcbiAgICAgICAgOyBjbGF1c2VzID1cbiAgICAgICAgICAgIFsgTm9fdGFnXG4gICAgICAgICAgICAgICAgeyBuYW1lID0gXCJJbmNsXCJcbiAgICAgICAgICAgICAgICA7IGNsYXVzZV9raW5kID1cbiAgICAgICAgICAgICAgICAgICAgTGlzdF9jbGF1c2UgeyBhcmdzID0gQ29ucyAoXydhX3NleHBfZ3JhbW1hci51bnR5cGVkLCBFbXB0eSkgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDsgTm9fdGFnXG4gICAgICAgICAgICAgICAgeyBuYW1lID0gXCJFeGNsXCJcbiAgICAgICAgICAgICAgICA7IGNsYXVzZV9raW5kID1cbiAgICAgICAgICAgICAgICAgICAgTGlzdF9jbGF1c2UgeyBhcmdzID0gQ29ucyAoXydhX3NleHBfZ3JhbW1hci51bnR5cGVkLCBFbXB0eSkgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDsgTm9fdGFnIHsgbmFtZSA9IFwiVW5ib3VuZGVkXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9XG4gIH1cbjs7XG5cbltAQEBlbmRdXG5cbnR5cGUgaW50ZXJ2YWxfY29tcGFyaXNvbiA9XG4gIHwgQmVsb3dfbG93ZXJfYm91bmRcbiAgfCBJbl9yYW5nZVxuICB8IEFib3ZlX3VwcGVyX2JvdW5kXG5bQEBkZXJpdmluZ19pbmxpbmUgc2V4cCwgc2V4cF9ncmFtbWFyLCBjb21wYXJlLCBoYXNoXVxuXG5sZXQgaW50ZXJ2YWxfY29tcGFyaXNvbl9vZl9zZXhwID1cbiAgKGxldCBlcnJvcl9zb3VyY2VfXzAyN18gPSBcIm1heWJlX2JvdW5kLm1sLmludGVydmFsX2NvbXBhcmlzb25cIiBpblxuICAgZnVuY3Rpb25cbiAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcImJlbG93X2xvd2VyX2JvdW5kXCIgfCBcIkJlbG93X2xvd2VyX2JvdW5kXCIpIC0+IEJlbG93X2xvd2VyX2JvdW5kXG4gICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJpbl9yYW5nZVwiIHwgXCJJbl9yYW5nZVwiKSAtPiBJbl9yYW5nZVxuICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwiYWJvdmVfdXBwZXJfYm91bmRcIiB8IFwiQWJvdmVfdXBwZXJfYm91bmRcIikgLT4gQWJvdmVfdXBwZXJfYm91bmRcbiAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0XG4gICAgICAgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJiZWxvd19sb3dlcl9ib3VuZFwiIHwgXCJCZWxvd19sb3dlcl9ib3VuZFwiKSA6OiBfKSBhcyBzZXhwX18wMjhfXG4gICAgIC0+IFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMjdfIHNleHBfXzAyOF9cbiAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gKFwiaW5fcmFuZ2VcIiB8IFwiSW5fcmFuZ2VcIikgOjogXykgYXMgc2V4cF9fMDI4X1xuICAgICAtPiBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDI3XyBzZXhwX18wMjhfXG4gICB8IFNleHBsaWIwLlNleHAuTGlzdFxuICAgICAgIChTZXhwbGliMC5TZXhwLkF0b20gKFwiYWJvdmVfdXBwZXJfYm91bmRcIiB8IFwiQWJvdmVfdXBwZXJfYm91bmRcIikgOjogXykgYXMgc2V4cF9fMDI4X1xuICAgICAtPiBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDI3XyBzZXhwX18wMjhfXG4gICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5MaXN0IF8gOjogXykgYXMgc2V4cF9fMDI2XyAtPlxuICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IubmVzdGVkX2xpc3RfaW52YWxpZF9zdW0gZXJyb3Jfc291cmNlX18wMjdfIHNleHBfXzAyNl9cbiAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IFtdIGFzIHNleHBfXzAyNl8gLT5cbiAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLmVtcHR5X2xpc3RfaW52YWxpZF9zdW0gZXJyb3Jfc291cmNlX18wMjdfIHNleHBfXzAyNl9cbiAgIHwgc2V4cF9fMDI2XyAtPiBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IudW5leHBlY3RlZF9zdGFnIGVycm9yX3NvdXJjZV9fMDI3XyBzZXhwX18wMjZfXG4gICAgICAgICAgICAgICAgICAgOiBTZXhwbGliMC5TZXhwLnQgLT4gaW50ZXJ2YWxfY29tcGFyaXNvbilcbjs7XG5cbmxldCBzZXhwX29mX2ludGVydmFsX2NvbXBhcmlzb24gPVxuICAoZnVuY3Rpb25cbiAgICB8IEJlbG93X2xvd2VyX2JvdW5kIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIkJlbG93X2xvd2VyX2JvdW5kXCJcbiAgICB8IEluX3JhbmdlIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIkluX3JhbmdlXCJcbiAgICB8IEFib3ZlX3VwcGVyX2JvdW5kIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIkFib3ZlX3VwcGVyX2JvdW5kXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIDogaW50ZXJ2YWxfY29tcGFyaXNvbiAtPiBTZXhwbGliMC5TZXhwLnQpXG47O1xuXG5sZXQgKGludGVydmFsX2NvbXBhcmlzb25fc2V4cF9ncmFtbWFyIDogaW50ZXJ2YWxfY29tcGFyaXNvbiBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPVxuICB7IHVudHlwZWQgPVxuICAgICAgVmFyaWFudFxuICAgICAgICB7IGNhc2Vfc2Vuc2l0aXZpdHkgPSBDYXNlX3NlbnNpdGl2ZV9leGNlcHRfZmlyc3RfY2hhcmFjdGVyXG4gICAgICAgIDsgY2xhdXNlcyA9XG4gICAgICAgICAgICBbIE5vX3RhZyB7IG5hbWUgPSBcIkJlbG93X2xvd2VyX2JvdW5kXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgOyBOb190YWcgeyBuYW1lID0gXCJJbl9yYW5nZVwiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgIDsgTm9fdGFnIHsgbmFtZSA9IFwiQWJvdmVfdXBwZXJfYm91bmRcIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH1cbiAgfVxuOztcblxubGV0IGNvbXBhcmVfaW50ZXJ2YWxfY29tcGFyaXNvbiA9XG4gIChQcHhfY29tcGFyZV9saWIucG9seW1vcnBoaWNfY29tcGFyZVxuICAgOiBpbnRlcnZhbF9jb21wYXJpc29uIC0+IGludGVydmFsX2NvbXBhcmlzb24gLT4gaW50KVxuOztcblxubGV0IChoYXNoX2ZvbGRfaW50ZXJ2YWxfY29tcGFyaXNvbiA6XG4gICAgICAgUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IGludGVydmFsX2NvbXBhcmlzb24gLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICA9XG4gIChmdW4gaHN2IGFyZyAtPlxuICAgICBtYXRjaCBhcmcgd2l0aFxuICAgICB8IEJlbG93X2xvd2VyX2JvdW5kIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludCBoc3YgMFxuICAgICB8IEluX3JhbmdlIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludCBoc3YgMVxuICAgICB8IEFib3ZlX3VwcGVyX2JvdW5kIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludCBoc3YgMlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IGludGVydmFsX2NvbXBhcmlzb24gLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuOztcblxubGV0IChoYXNoX2ludGVydmFsX2NvbXBhcmlzb24gOiBpbnRlcnZhbF9jb21wYXJpc29uIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gIGxldCBmdW5jIGFyZyA9XG4gICAgUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmdldF9oYXNoX3ZhbHVlXG4gICAgICAobGV0IGhzdiA9IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5jcmVhdGUgKCkgaW5cbiAgICAgICBoYXNoX2ZvbGRfaW50ZXJ2YWxfY29tcGFyaXNvbiBoc3YgYXJnKVxuICBpblxuICBmdW4geCAtPiBmdW5jIHhcbjs7XG5cbltAQEBlbmRdXG5cbmxldCBtYXAgdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IEluY2wgaW5jbCAtPiBJbmNsIChmIGluY2wpXG4gIHwgRXhjbCBleGNsIC0+IEV4Y2wgKGYgZXhjbClcbiAgfCBVbmJvdW5kZWQgLT4gVW5ib3VuZGVkXG47O1xuXG5sZXQgaXNfbG93ZXJfYm91bmQgdCB+b2ZfOmEgfmNvbXBhcmUgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBJbmNsIGluY2wgLT4gY29tcGFyZSBpbmNsIGEgPD0gMFxuICB8IEV4Y2wgZXhjbCAtPiBjb21wYXJlIGV4Y2wgYSA8IDBcbiAgfCBVbmJvdW5kZWQgLT4gdHJ1ZVxuOztcblxubGV0IGlzX3VwcGVyX2JvdW5kIHQgfm9mXzphIH5jb21wYXJlID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgSW5jbCBpbmNsIC0+IGNvbXBhcmUgYSBpbmNsIDw9IDBcbiAgfCBFeGNsIGV4Y2wgLT4gY29tcGFyZSBhIGV4Y2wgPCAwXG4gIHwgVW5ib3VuZGVkIC0+IHRydWVcbjs7XG5cbmxldCBib3VuZHNfY3Jvc3NlZCB+bG93ZXIgfnVwcGVyIH5jb21wYXJlID1cbiAgbWF0Y2ggbG93ZXIgd2l0aFxuICB8IFVuYm91bmRlZCAtPiBmYWxzZVxuICB8IEluY2wgbG93ZXIgfCBFeGNsIGxvd2VyIC0+XG4gICAgKG1hdGNoIHVwcGVyIHdpdGhcbiAgICAgfCBVbmJvdW5kZWQgLT4gZmFsc2VcbiAgICAgfCBJbmNsIHVwcGVyIHwgRXhjbCB1cHBlciAtPiBjb21wYXJlIGxvd2VyIHVwcGVyID4gMClcbjs7XG5cbmxldCBjaGVja19pbnRlcnZhbF9leG4gfmxvd2VyIH51cHBlciB+Y29tcGFyZSA9XG4gIGlmIGJvdW5kc19jcm9zc2VkIH5sb3dlciB+dXBwZXIgfmNvbXBhcmVcbiAgdGhlbiBmYWlsd2l0aCBcIk1heWJlX2JvdW5kLmNvbXBhcmVfdG9faW50ZXJ2YWxfZXhuOiBsb3dlciBib3VuZCA+IHVwcGVyIGJvdW5kXCJcbjs7XG5cbmxldCBjb21wYXJlX3RvX2ludGVydmFsX2V4biB+bG93ZXIgfnVwcGVyIGEgfmNvbXBhcmUgPVxuICBjaGVja19pbnRlcnZhbF9leG4gfmxvd2VyIH51cHBlciB+Y29tcGFyZTtcbiAgaWYgbm90IChpc19sb3dlcl9ib3VuZCBsb3dlciB+b2ZfOmEgfmNvbXBhcmUpXG4gIHRoZW4gQmVsb3dfbG93ZXJfYm91bmRcbiAgZWxzZSBpZiBub3QgKGlzX3VwcGVyX2JvdW5kIHVwcGVyIH5vZl86YSB+Y29tcGFyZSlcbiAgdGhlbiBBYm92ZV91cHBlcl9ib3VuZFxuICBlbHNlIEluX3JhbmdlXG47O1xuXG5sZXQgaW50ZXJ2YWxfY29udGFpbnNfZXhuIH5sb3dlciB+dXBwZXIgYSB+Y29tcGFyZSA9XG4gIG1hdGNoIGNvbXBhcmVfdG9faW50ZXJ2YWxfZXhuIH5sb3dlciB+dXBwZXIgYSB+Y29tcGFyZSB3aXRoXG4gIHwgSW5fcmFuZ2UgLT4gdHJ1ZVxuICB8IEJlbG93X2xvd2VyX2JvdW5kIHwgQWJvdmVfdXBwZXJfYm91bmQgLT4gZmFsc2Vcbjs7XG4iLCJvcGVuISBJbXBvcnRcbm9wZW4hIFRcblxubW9kdWxlIE9yX2R1cGxpY2F0ZSA9IHN0cnVjdFxuICB0eXBlICdhIHQgPVxuICAgIFsgYE9rIG9mICdhXG4gICAgfCBgRHVwbGljYXRlXG4gICAgXVxuICBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZXF1YWwsIHNleHBfb2ZdXG5cbiAgbGV0IGNvbXBhcmUgOiAnYS4gKCdhIC0+ICdhIC0+IGludCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGludCA9XG4gICAgZnVuIF9jbXBfX2EgYV9fMDAxXyBiX18wMDJfIC0+XG4gICAgaWYgUHB4X2NvbXBhcmVfbGliLnBoeXNfZXF1YWwgYV9fMDAxXyBiX18wMDJfXG4gICAgdGhlbiAwXG4gICAgZWxzZSAoXG4gICAgICBtYXRjaCBhX18wMDFfLCBiX18wMDJfIHdpdGhcbiAgICAgIHwgYE9rIF9sZWZ0X18wMDNfLCBgT2sgX3JpZ2h0X18wMDRfIC0+IF9jbXBfX2EgX2xlZnRfXzAwM18gX3JpZ2h0X18wMDRfXG4gICAgICB8IGBEdXBsaWNhdGUsIGBEdXBsaWNhdGUgLT4gMFxuICAgICAgfCB4LCB5IC0+IFBweF9jb21wYXJlX2xpYi5wb2x5bW9ycGhpY19jb21wYXJlIHggeSlcbiAgOztcblxuICBsZXQgZXF1YWwgOiAnYS4gKCdhIC0+ICdhIC0+IGJvb2wpIC0+ICdhIHQgLT4gJ2EgdCAtPiBib29sID1cbiAgICBmdW4gX2NtcF9fYSBhX18wMDVfIGJfXzAwNl8gLT5cbiAgICAgIGlmIFBweF9jb21wYXJlX2xpYi5waHlzX2VxdWFsIGFfXzAwNV8gYl9fMDA2X1xuICAgICAgdGhlbiB0cnVlXG4gICAgICBlbHNlIChcbiAgICAgICAgbWF0Y2ggYV9fMDA1XywgYl9fMDA2XyB3aXRoXG4gICAgICAgIHwgYE9rIF9sZWZ0X18wMDdfLCBgT2sgX3JpZ2h0X18wMDhfIC0+IF9jbXBfX2EgX2xlZnRfXzAwN18gX3JpZ2h0X18wMDhfXG4gICAgICAgIHwgYER1cGxpY2F0ZSwgYER1cGxpY2F0ZSAtPiB0cnVlXG4gICAgICAgIHwgeCwgeSAtPiBQcHhfY29tcGFyZV9saWIucG9seW1vcnBoaWNfZXF1YWwgeCB5KVxuICA7O1xuXG4gIGxldCBzZXhwX29mX3QgOiAnYS4gKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgdCAtPiBTZXhwbGliMC5TZXhwLnQgPVxuICAgIGZ1biBfb2ZfYV9fMDA5XyAtPiBmdW5jdGlvblxuICAgICAgfCBgT2sgdl9fMDEwXyAtPiBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJPa1wiOyBfb2ZfYV9fMDA5XyB2X18wMTBfIF1cbiAgICAgIHwgYER1cGxpY2F0ZSAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJEdXBsaWNhdGVcIlxuICA7O1xuXG4gIFtAQEBlbmRdXG5lbmRcblxubW9kdWxlIFdpdGhvdXRfY29tcGFyYXRvciA9IHN0cnVjdFxuICB0eXBlICgna2V5LCAnY21wLCAneikgdCA9ICd6XG5lbmRcblxubW9kdWxlIFdpdGhfY29tcGFyYXRvciA9IHN0cnVjdFxuICB0eXBlICgna2V5LCAnY21wLCAneikgdCA9IGNvbXBhcmF0b3I6KCdrZXksICdjbXApIENvbXBhcmF0b3IudCAtPiAnelxuZW5kXG5cbm1vZHVsZSBXaXRoX2ZpcnN0X2NsYXNzX21vZHVsZSA9IHN0cnVjdFxuICB0eXBlICgna2V5LCAnY21wLCAneikgdCA9ICgna2V5LCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50IC0+ICd6XG5lbmRcblxubW9kdWxlIFN5bW1ldHJpY19kaWZmX2VsZW1lbnQgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2ssICd2KSB0ID0gJ2sgKiBbIGBMZWZ0IG9mICd2IHwgYFJpZ2h0IG9mICd2IHwgYFVuZXF1YWwgb2YgJ3YgKiAndiBdXG4gIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlcXVhbCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlIDpcbiAgICAnayAndi4gKCdrIC0+ICdrIC0+IGludCkgLT4gKCd2IC0+ICd2IC0+IGludCkgLT4gKCdrLCAndikgdCAtPiAoJ2ssICd2KSB0IC0+IGludFxuICAgID1cbiAgICBmdW4gX2NtcF9fayBfY21wX192IGFfXzAxMV8gYl9fMDEyXyAtPlxuICAgIGxldCB0X18wMTNfLCB0X18wMTRfID0gYV9fMDExXyBpblxuICAgIGxldCB0X18wMTVfLCB0X18wMTZfID0gYl9fMDEyXyBpblxuICAgIG1hdGNoIF9jbXBfX2sgdF9fMDEzXyB0X18wMTVfIHdpdGhcbiAgICB8IDAgLT5cbiAgICAgIGlmIFBweF9jb21wYXJlX2xpYi5waHlzX2VxdWFsIHRfXzAxNF8gdF9fMDE2X1xuICAgICAgdGhlbiAwXG4gICAgICBlbHNlIChcbiAgICAgICAgbWF0Y2ggdF9fMDE0XywgdF9fMDE2XyB3aXRoXG4gICAgICAgIHwgYExlZnQgX2xlZnRfXzAxN18sIGBMZWZ0IF9yaWdodF9fMDE4XyAtPiBfY21wX192IF9sZWZ0X18wMTdfIF9yaWdodF9fMDE4X1xuICAgICAgICB8IGBSaWdodCBfbGVmdF9fMDE5XywgYFJpZ2h0IF9yaWdodF9fMDIwXyAtPiBfY21wX192IF9sZWZ0X18wMTlfIF9yaWdodF9fMDIwX1xuICAgICAgICB8IGBVbmVxdWFsIF9sZWZ0X18wMjFfLCBgVW5lcXVhbCBfcmlnaHRfXzAyMl8gLT5cbiAgICAgICAgICBsZXQgdF9fMDIzXywgdF9fMDI0XyA9IF9sZWZ0X18wMjFfIGluXG4gICAgICAgICAgbGV0IHRfXzAyNV8sIHRfXzAyNl8gPSBfcmlnaHRfXzAyMl8gaW5cbiAgICAgICAgICAobWF0Y2ggX2NtcF9fdiB0X18wMjNfIHRfXzAyNV8gd2l0aFxuICAgICAgICAgICB8IDAgLT4gX2NtcF9fdiB0X18wMjRfIHRfXzAyNl9cbiAgICAgICAgICAgfCBuIC0+IG4pXG4gICAgICAgIHwgeCwgeSAtPiBQcHhfY29tcGFyZV9saWIucG9seW1vcnBoaWNfY29tcGFyZSB4IHkpXG4gICAgfCBuIC0+IG5cbiAgOztcblxuICBsZXQgZXF1YWwgOlxuICAgICdrICd2LlxuICAgICgnayAtPiAnayAtPiBib29sKSAtPiAoJ3YgLT4gJ3YgLT4gYm9vbCkgLT4gKCdrLCAndikgdCAtPiAoJ2ssICd2KSB0IC0+IGJvb2xcbiAgICA9XG4gICAgZnVuIF9jbXBfX2sgX2NtcF9fdiBhX18wMjdfIGJfXzAyOF8gLT5cbiAgICAgIGxldCB0X18wMjlfLCB0X18wMzBfID0gYV9fMDI3XyBpblxuICAgICAgbGV0IHRfXzAzMV8sIHRfXzAzMl8gPSBiX18wMjhfIGluXG4gICAgICBQcHhfY29tcGFyZV9saWIuKCAmJiApXG4gICAgICAgIChfY21wX19rIHRfXzAyOV8gdF9fMDMxXylcbiAgICAgICAgKGlmIFBweF9jb21wYXJlX2xpYi5waHlzX2VxdWFsIHRfXzAzMF8gdF9fMDMyX1xuICAgICAgICAgdGhlbiB0cnVlXG4gICAgICAgICBlbHNlIChcbiAgICAgICAgICAgbWF0Y2ggdF9fMDMwXywgdF9fMDMyXyB3aXRoXG4gICAgICAgICAgIHwgYExlZnQgX2xlZnRfXzAzM18sIGBMZWZ0IF9yaWdodF9fMDM0XyAtPiBfY21wX192IF9sZWZ0X18wMzNfIF9yaWdodF9fMDM0X1xuICAgICAgICAgICB8IGBSaWdodCBfbGVmdF9fMDM1XywgYFJpZ2h0IF9yaWdodF9fMDM2XyAtPiBfY21wX192IF9sZWZ0X18wMzVfIF9yaWdodF9fMDM2X1xuICAgICAgICAgICB8IGBVbmVxdWFsIF9sZWZ0X18wMzdfLCBgVW5lcXVhbCBfcmlnaHRfXzAzOF8gLT5cbiAgICAgICAgICAgICBsZXQgdF9fMDM5XywgdF9fMDQwXyA9IF9sZWZ0X18wMzdfIGluXG4gICAgICAgICAgICAgbGV0IHRfXzA0MV8sIHRfXzA0Ml8gPSBfcmlnaHRfXzAzOF8gaW5cbiAgICAgICAgICAgICBQcHhfY29tcGFyZV9saWIuKCAmJiApIChfY21wX192IHRfXzAzOV8gdF9fMDQxXykgKF9jbXBfX3YgdF9fMDQwXyB0X18wNDJfKVxuICAgICAgICAgICB8IHgsIHkgLT4gUHB4X2NvbXBhcmVfbGliLnBvbHltb3JwaGljX2VxdWFsIHggeSkpXG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cCA6XG4gICAgJ2sgJ3YuXG4gICAgKFNleHBsaWIwLlNleHAudCAtPiAnaylcbiAgICAtPiAoU2V4cGxpYjAuU2V4cC50IC0+ICd2KVxuICAgIC0+IFNleHBsaWIwLlNleHAudFxuICAgIC0+ICgnaywgJ3YpIHRcbiAgICA9XG4gICAgbGV0IGVycm9yX3NvdXJjZV9fMDU3XyA9IFwibWFwX2ludGYubWwuU3ltbWV0cmljX2RpZmZfZWxlbWVudC50XCIgaW5cbiAgICBmdW4gX29mX2tfXzA0M18gX29mX3ZfXzA0NF8gLT4gZnVuY3Rpb25cbiAgICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IFsgYXJnMF9fMDY3XzsgYXJnMV9fMDY4XyBdIC0+XG4gICAgICAgIGxldCByZXMwX18wNjlfID0gX29mX2tfXzA0M18gYXJnMF9fMDY3X1xuICAgICAgICBhbmQgcmVzMV9fMDcwXyA9XG4gICAgICAgICAgbGV0IHNleHBfXzA2Nl8gPSBhcmcxX18wNjhfIGluXG4gICAgICAgICAgdHJ5XG4gICAgICAgICAgICBtYXRjaCBzZXhwX18wNjZfIHdpdGhcbiAgICAgICAgICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIGF0b21fXzA0N18gYXMgX3NleHBfXzA0OV8gLT5cbiAgICAgICAgICAgICAgKG1hdGNoIGF0b21fXzA0N18gd2l0aFxuICAgICAgICAgICAgICAgfCBcIkxlZnRcIiAtPlxuICAgICAgICAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IucHRhZ190YWtlc19hcmdzIGVycm9yX3NvdXJjZV9fMDU3XyBfc2V4cF9fMDQ5X1xuICAgICAgICAgICAgICAgfCBcIlJpZ2h0XCIgLT5cbiAgICAgICAgICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnB0YWdfdGFrZXNfYXJncyBlcnJvcl9zb3VyY2VfXzA1N18gX3NleHBfXzA0OV9cbiAgICAgICAgICAgICAgIHwgXCJVbmVxdWFsXCIgLT5cbiAgICAgICAgICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnB0YWdfdGFrZXNfYXJncyBlcnJvcl9zb3VyY2VfXzA1N18gX3NleHBfXzA0OV9cbiAgICAgICAgICAgICAgIHwgXyAtPiBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iubm9fdmFyaWFudF9tYXRjaCAoKSlcbiAgICAgICAgICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gYXRvbV9fMDQ3XyA6OiBzZXhwX2FyZ3NfXzA1MF8pIGFzXG4gICAgICAgICAgICAgIF9zZXhwX18wNDlfIC0+XG4gICAgICAgICAgICAgIChtYXRjaCBhdG9tX18wNDdfIHdpdGhcbiAgICAgICAgICAgICAgIHwgXCJMZWZ0XCIgYXMgX3RhZ19fMDYzXyAtPlxuICAgICAgICAgICAgICAgICAobWF0Y2ggc2V4cF9hcmdzX18wNTBfIHdpdGhcbiAgICAgICAgICAgICAgICAgIHwgWyBhcmcwX18wNjRfIF0gLT5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlczBfXzA2NV8gPSBfb2Zfdl9fMDQ0XyBhcmcwX18wNjRfIGluXG4gICAgICAgICAgICAgICAgICAgIGBMZWZ0IHJlczBfXzA2NV9cbiAgICAgICAgICAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IucHRhZ19pbmNvcnJlY3Rfbl9hcmdzXG4gICAgICAgICAgICAgICAgICAgICAgZXJyb3Jfc291cmNlX18wNTdfXG4gICAgICAgICAgICAgICAgICAgICAgX3RhZ19fMDYzX1xuICAgICAgICAgICAgICAgICAgICAgIF9zZXhwX18wNDlfKVxuICAgICAgICAgICAgICAgfCBcIlJpZ2h0XCIgYXMgX3RhZ19fMDYwXyAtPlxuICAgICAgICAgICAgICAgICAobWF0Y2ggc2V4cF9hcmdzX18wNTBfIHdpdGhcbiAgICAgICAgICAgICAgICAgIHwgWyBhcmcwX18wNjFfIF0gLT5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlczBfXzA2Ml8gPSBfb2Zfdl9fMDQ0XyBhcmcwX18wNjFfIGluXG4gICAgICAgICAgICAgICAgICAgIGBSaWdodCByZXMwX18wNjJfXG4gICAgICAgICAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnB0YWdfaW5jb3JyZWN0X25fYXJnc1xuICAgICAgICAgICAgICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDU3X1xuICAgICAgICAgICAgICAgICAgICAgIF90YWdfXzA2MF9cbiAgICAgICAgICAgICAgICAgICAgICBfc2V4cF9fMDQ5XylcbiAgICAgICAgICAgICAgIHwgXCJVbmVxdWFsXCIgYXMgX3RhZ19fMDUxXyAtPlxuICAgICAgICAgICAgICAgICAobWF0Y2ggc2V4cF9hcmdzX18wNTBfIHdpdGhcbiAgICAgICAgICAgICAgICAgIHwgWyBhcmcwX18wNThfIF0gLT5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlczBfXzA1OV8gPVxuICAgICAgICAgICAgICAgICAgICAgIG1hdGNoIGFyZzBfXzA1OF8gd2l0aFxuICAgICAgICAgICAgICAgICAgICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IFsgYXJnMF9fMDUyXzsgYXJnMV9fMDUzXyBdIC0+XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVzMF9fMDU0XyA9IF9vZl92X18wNDRfIGFyZzBfXzA1Ml9cbiAgICAgICAgICAgICAgICAgICAgICAgIGFuZCByZXMxX18wNTVfID0gX29mX3ZfXzA0NF8gYXJnMV9fMDUzXyBpblxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzMF9fMDU0XywgcmVzMV9fMDU1X1xuICAgICAgICAgICAgICAgICAgICAgIHwgc2V4cF9fMDU2XyAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnR1cGxlX29mX3NpemVfbl9leHBlY3RlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl9zb3VyY2VfXzA1N19cbiAgICAgICAgICAgICAgICAgICAgICAgICAgMlxuICAgICAgICAgICAgICAgICAgICAgICAgICBzZXhwX18wNTZfXG4gICAgICAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICAgICAgIGBVbmVxdWFsIHJlczBfXzA1OV9cbiAgICAgICAgICAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IucHRhZ19pbmNvcnJlY3Rfbl9hcmdzXG4gICAgICAgICAgICAgICAgICAgICAgZXJyb3Jfc291cmNlX18wNTdfXG4gICAgICAgICAgICAgICAgICAgICAgX3RhZ19fMDUxX1xuICAgICAgICAgICAgICAgICAgICAgIF9zZXhwX18wNDlfKVxuICAgICAgICAgICAgICAgfCBfIC0+IFNleHBsaWIwLlNleHBfY29udl9lcnJvci5ub192YXJpYW50X21hdGNoICgpKVxuICAgICAgICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuTGlzdCBfIDo6IF8pIGFzIHNleHBfXzA0OF8gLT5cbiAgICAgICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLm5lc3RlZF9saXN0X2ludmFsaWRfcG9seV92YXJcbiAgICAgICAgICAgICAgICBlcnJvcl9zb3VyY2VfXzA1N19cbiAgICAgICAgICAgICAgICBzZXhwX18wNDhfXG4gICAgICAgICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCBbXSBhcyBzZXhwX18wNDhfIC0+XG4gICAgICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5lbXB0eV9saXN0X2ludmFsaWRfcG9seV92YXJcbiAgICAgICAgICAgICAgICBlcnJvcl9zb3VyY2VfXzA1N19cbiAgICAgICAgICAgICAgICBzZXhwX18wNDhfXG4gICAgICAgICAgd2l0aFxuICAgICAgICAgIHwgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLk5vX3ZhcmlhbnRfbWF0Y2ggLT5cbiAgICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5ub19tYXRjaGluZ192YXJpYW50X2ZvdW5kXG4gICAgICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDU3X1xuICAgICAgICAgICAgICBzZXhwX18wNjZfXG4gICAgICAgIGluXG4gICAgICAgIHJlczBfXzA2OV8sIHJlczFfXzA3MF9cbiAgICAgIHwgc2V4cF9fMDcxXyAtPlxuICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IudHVwbGVfb2Zfc2l6ZV9uX2V4cGVjdGVkIGVycm9yX3NvdXJjZV9fMDU3XyAyIHNleHBfXzA3MV9cbiAgOztcblxuICBsZXQgc2V4cF9vZl90IDpcbiAgICAnayAndi5cbiAgICAoJ2sgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgIC0+ICgndiAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgLT4gKCdrLCAndikgdFxuICAgIC0+IFNleHBsaWIwLlNleHAudFxuICAgID1cbiAgICBmdW4gX29mX2tfXzA3Ml8gX29mX3ZfXzA3M18gKGFyZzBfXzA4MV8sIGFyZzFfXzA4Ml8pIC0+XG4gICAgICBsZXQgcmVzMF9fMDgzXyA9IF9vZl9rX18wNzJfIGFyZzBfXzA4MV9cbiAgICAgIGFuZCByZXMxX18wODRfID1cbiAgICAgICAgbWF0Y2ggYXJnMV9fMDgyXyB3aXRoXG4gICAgICAgIHwgYExlZnQgdl9fMDc0XyAtPlxuICAgICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIkxlZnRcIjsgX29mX3ZfXzA3M18gdl9fMDc0XyBdXG4gICAgICAgIHwgYFJpZ2h0IHZfXzA3NV8gLT5cbiAgICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJSaWdodFwiOyBfb2Zfdl9fMDczXyB2X18wNzVfIF1cbiAgICAgICAgfCBgVW5lcXVhbCB2X18wNzZfIC0+XG4gICAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0XG4gICAgICAgICAgICBbIFNleHBsaWIwLlNleHAuQXRvbSBcIlVuZXF1YWxcIlxuICAgICAgICAgICAgOyAobGV0IGFyZzBfXzA3N18sIGFyZzFfXzA3OF8gPSB2X18wNzZfIGluXG4gICAgICAgICAgICAgICBsZXQgcmVzMF9fMDc5XyA9IF9vZl92X18wNzNfIGFyZzBfXzA3N19cbiAgICAgICAgICAgICAgIGFuZCByZXMxX18wODBfID0gX29mX3ZfXzA3M18gYXJnMV9fMDc4XyBpblxuICAgICAgICAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgcmVzMF9fMDc5XzsgcmVzMV9fMDgwXyBdKVxuICAgICAgICAgICAgXVxuICAgICAgaW5cbiAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIHJlczBfXzA4M187IHJlczFfXzA4NF8gXVxuICA7O1xuXG4gIGxldCAodF9zZXhwX2dyYW1tYXIgOlxuICAgICAgICAgJ2sgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgICAgICAtPiAndiBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgICAgIC0+ICgnaywgJ3YpIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpXG4gICAgPVxuICAgIGZ1biBfJ2tfc2V4cF9ncmFtbWFyIF8ndl9zZXhwX2dyYW1tYXIgLT5cbiAgICAgIHsgdW50eXBlZCA9XG4gICAgICAgICAgTGlzdFxuICAgICAgICAgICAgKENvbnNcbiAgICAgICAgICAgICAgICggXydrX3NleHBfZ3JhbW1hci51bnR5cGVkXG4gICAgICAgICAgICAgICAsIENvbnNcbiAgICAgICAgICAgICAgICAgICAoIFZhcmlhbnRcbiAgICAgICAgICAgICAgICAgICAgICAgeyBjYXNlX3NlbnNpdGl2aXR5ID0gQ2FzZV9zZW5zaXRpdmVcbiAgICAgICAgICAgICAgICAgICAgICAgOyBjbGF1c2VzID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIFsgTm9fdGFnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lID0gXCJMZWZ0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7IGNsYXVzZV9raW5kID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTGlzdF9jbGF1c2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGFyZ3MgPSBDb25zIChfJ3Zfc2V4cF9ncmFtbWFyLnVudHlwZWQsIEVtcHR5KSB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgOyBOb190YWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWUgPSBcIlJpZ2h0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7IGNsYXVzZV9raW5kID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTGlzdF9jbGF1c2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGFyZ3MgPSBDb25zIChfJ3Zfc2V4cF9ncmFtbWFyLnVudHlwZWQsIEVtcHR5KSB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgOyBOb190YWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWUgPSBcIlVuZXF1YWxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDsgY2xhdXNlX2tpbmQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBMaXN0X2NsYXVzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgYXJncyA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIExpc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKENvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBfJ3Zfc2V4cF9ncmFtbWFyLnVudHlwZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLCBDb25zIChfJ3Zfc2V4cF9ncmFtbWFyLnVudHlwZWQsIEVtcHR5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICwgRW1wdHkgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAsIEVtcHR5ICkgKSlcbiAgICAgIH1cbiAgOztcblxuICBbQEBAZW5kXVxuZW5kXG5cbm1vZHVsZSBNZXJnZV9lbGVtZW50ID0gc3RydWN0XG4gIHR5cGUgKCdsZWZ0LCAncmlnaHQpIHQgPVxuICAgIFsgYExlZnQgb2YgJ2xlZnRcbiAgICB8IGBSaWdodCBvZiAncmlnaHRcbiAgICB8IGBCb3RoIG9mICdsZWZ0ICogJ3JpZ2h0XG4gICAgXVxuICBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZXF1YWwsIHNleHBfb2ZdXG5cbiAgbGV0IGNvbXBhcmUgOlxuICAgICdsZWZ0ICdyaWdodC5cbiAgICAoJ2xlZnQgLT4gJ2xlZnQgLT4gaW50KVxuICAgIC0+ICgncmlnaHQgLT4gJ3JpZ2h0IC0+IGludClcbiAgICAtPiAoJ2xlZnQsICdyaWdodCkgdFxuICAgIC0+ICgnbGVmdCwgJ3JpZ2h0KSB0XG4gICAgLT4gaW50XG4gICAgPVxuICAgIGZ1biBfY21wX19sZWZ0IF9jbXBfX3JpZ2h0IGFfXzA4NV8gYl9fMDg2XyAtPlxuICAgIGlmIFBweF9jb21wYXJlX2xpYi5waHlzX2VxdWFsIGFfXzA4NV8gYl9fMDg2X1xuICAgIHRoZW4gMFxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggYV9fMDg1XywgYl9fMDg2XyB3aXRoXG4gICAgICB8IGBMZWZ0IF9sZWZ0X18wODdfLCBgTGVmdCBfcmlnaHRfXzA4OF8gLT4gX2NtcF9fbGVmdCBfbGVmdF9fMDg3XyBfcmlnaHRfXzA4OF9cbiAgICAgIHwgYFJpZ2h0IF9sZWZ0X18wODlfLCBgUmlnaHQgX3JpZ2h0X18wOTBfIC0+IF9jbXBfX3JpZ2h0IF9sZWZ0X18wODlfIF9yaWdodF9fMDkwX1xuICAgICAgfCBgQm90aCBfbGVmdF9fMDkxXywgYEJvdGggX3JpZ2h0X18wOTJfIC0+XG4gICAgICAgIGxldCB0X18wOTNfLCB0X18wOTRfID0gX2xlZnRfXzA5MV8gaW5cbiAgICAgICAgbGV0IHRfXzA5NV8sIHRfXzA5Nl8gPSBfcmlnaHRfXzA5Ml8gaW5cbiAgICAgICAgKG1hdGNoIF9jbXBfX2xlZnQgdF9fMDkzXyB0X18wOTVfIHdpdGhcbiAgICAgICAgIHwgMCAtPiBfY21wX19yaWdodCB0X18wOTRfIHRfXzA5Nl9cbiAgICAgICAgIHwgbiAtPiBuKVxuICAgICAgfCB4LCB5IC0+IFBweF9jb21wYXJlX2xpYi5wb2x5bW9ycGhpY19jb21wYXJlIHggeSlcbiAgOztcblxuICBsZXQgZXF1YWwgOlxuICAgICdsZWZ0ICdyaWdodC5cbiAgICAoJ2xlZnQgLT4gJ2xlZnQgLT4gYm9vbClcbiAgICAtPiAoJ3JpZ2h0IC0+ICdyaWdodCAtPiBib29sKVxuICAgIC0+ICgnbGVmdCwgJ3JpZ2h0KSB0XG4gICAgLT4gKCdsZWZ0LCAncmlnaHQpIHRcbiAgICAtPiBib29sXG4gICAgPVxuICAgIGZ1biBfY21wX19sZWZ0IF9jbXBfX3JpZ2h0IGFfXzA5N18gYl9fMDk4XyAtPlxuICAgICAgaWYgUHB4X2NvbXBhcmVfbGliLnBoeXNfZXF1YWwgYV9fMDk3XyBiX18wOThfXG4gICAgICB0aGVuIHRydWVcbiAgICAgIGVsc2UgKFxuICAgICAgICBtYXRjaCBhX18wOTdfLCBiX18wOThfIHdpdGhcbiAgICAgICAgfCBgTGVmdCBfbGVmdF9fMDk5XywgYExlZnQgX3JpZ2h0X18xMDBfIC0+IF9jbXBfX2xlZnQgX2xlZnRfXzA5OV8gX3JpZ2h0X18xMDBfXG4gICAgICAgIHwgYFJpZ2h0IF9sZWZ0X18xMDFfLCBgUmlnaHQgX3JpZ2h0X18xMDJfIC0+IF9jbXBfX3JpZ2h0IF9sZWZ0X18xMDFfIF9yaWdodF9fMTAyX1xuICAgICAgICB8IGBCb3RoIF9sZWZ0X18xMDNfLCBgQm90aCBfcmlnaHRfXzEwNF8gLT5cbiAgICAgICAgICBsZXQgdF9fMTA1XywgdF9fMTA2XyA9IF9sZWZ0X18xMDNfIGluXG4gICAgICAgICAgbGV0IHRfXzEwN18sIHRfXzEwOF8gPSBfcmlnaHRfXzEwNF8gaW5cbiAgICAgICAgICBQcHhfY29tcGFyZV9saWIuKCAmJiApIChfY21wX19sZWZ0IHRfXzEwNV8gdF9fMTA3XykgKF9jbXBfX3JpZ2h0IHRfXzEwNl8gdF9fMTA4XylcbiAgICAgICAgfCB4LCB5IC0+IFBweF9jb21wYXJlX2xpYi5wb2x5bW9ycGhpY19lcXVhbCB4IHkpXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCA6XG4gICAgJ2xlZnQgJ3JpZ2h0LlxuICAgICgnbGVmdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgLT4gKCdyaWdodCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgLT4gKCdsZWZ0LCAncmlnaHQpIHRcbiAgICAtPiBTZXhwbGliMC5TZXhwLnRcbiAgICA9XG4gICAgZnVuIF9vZl9sZWZ0X18xMDlfIF9vZl9yaWdodF9fMTEwXyAtPiBmdW5jdGlvblxuICAgICAgfCBgTGVmdCB2X18xMTFfIC0+XG4gICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIkxlZnRcIjsgX29mX2xlZnRfXzEwOV8gdl9fMTExXyBdXG4gICAgICB8IGBSaWdodCB2X18xMTJfIC0+XG4gICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIlJpZ2h0XCI7IF9vZl9yaWdodF9fMTEwXyB2X18xMTJfIF1cbiAgICAgIHwgYEJvdGggdl9fMTEzXyAtPlxuICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3RcbiAgICAgICAgICBbIFNleHBsaWIwLlNleHAuQXRvbSBcIkJvdGhcIlxuICAgICAgICAgIDsgKGxldCBhcmcwX18xMTRfLCBhcmcxX18xMTVfID0gdl9fMTEzXyBpblxuICAgICAgICAgICAgIGxldCByZXMwX18xMTZfID0gX29mX2xlZnRfXzEwOV8gYXJnMF9fMTE0X1xuICAgICAgICAgICAgIGFuZCByZXMxX18xMTdfID0gX29mX3JpZ2h0X18xMTBfIGFyZzFfXzExNV8gaW5cbiAgICAgICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyByZXMwX18xMTZfOyByZXMxX18xMTdfIF0pXG4gICAgICAgICAgXVxuICA7O1xuXG4gIFtAQEBlbmRdXG5lbmRcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5NYXAuQ29udGludWVfb3Jfc3RvcCAqKVxubW9kdWxlIENvbnRpbnVlX29yX3N0b3AgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB8IENvbnRpbnVlXG4gICAgfCBTdG9wXG4gIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlbnVtZXJhdGUsIGVxdWFsLCBzZXhwX29mXVxuXG4gIGxldCBjb21wYXJlID0gKFBweF9jb21wYXJlX2xpYi5wb2x5bW9ycGhpY19jb21wYXJlIDogdCAtPiB0IC0+IGludClcbiAgbGV0IGFsbCA9IChbIENvbnRpbnVlOyBTdG9wIF0gOiB0IGxpc3QpXG4gIGxldCBlcXVhbCA9IChQcHhfY29tcGFyZV9saWIucG9seW1vcnBoaWNfZXF1YWwgOiB0IC0+IHQgLT4gYm9vbClcblxuICBsZXQgc2V4cF9vZl90ID1cbiAgICAoZnVuY3Rpb25cbiAgICAgIHwgQ29udGludWUgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiQ29udGludWVcIlxuICAgICAgfCBTdG9wIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIlN0b3BcIlxuICAgICAgICAgICAgICAgIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIDs7XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLk1hcC5GaW5pc2hlZF9vcl91bmZpbmlzaGVkICopXG5tb2R1bGUgRmluaXNoZWRfb3JfdW5maW5pc2hlZCA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHwgRmluaXNoZWRcbiAgICB8IFVuZmluaXNoZWRcbiAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVudW1lcmF0ZSwgZXF1YWwsIHNleHBfb2ZdXG5cbiAgbGV0IGNvbXBhcmUgPSAoUHB4X2NvbXBhcmVfbGliLnBvbHltb3JwaGljX2NvbXBhcmUgOiB0IC0+IHQgLT4gaW50KVxuICBsZXQgYWxsID0gKFsgRmluaXNoZWQ7IFVuZmluaXNoZWQgXSA6IHQgbGlzdClcbiAgbGV0IGVxdWFsID0gKFBweF9jb21wYXJlX2xpYi5wb2x5bW9ycGhpY19lcXVhbCA6IHQgLT4gdCAtPiBib29sKVxuXG4gIGxldCBzZXhwX29mX3QgPVxuICAgIChmdW5jdGlvblxuICAgICAgfCBGaW5pc2hlZCAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJGaW5pc2hlZFwiXG4gICAgICB8IFVuZmluaXNoZWQgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiVW5maW5pc2hlZFwiXG4gICAgICAgICAgICAgICAgICAgICAgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgOztcblxuICBbQEBAZW5kXVxuZW5kXG5cbm1vZHVsZSB0eXBlIEFjY2Vzc29yc19nZW5lcmljID0gc2lnXG4gIHR5cGUgKCdhLCAnYiwgJ2NtcCkgdFxuICB0eXBlICgnYSwgJ2IsICdjbXApIHRyZWVcbiAgdHlwZSAnYSBrZXlcbiAgdHlwZSAnY21wIGNtcFxuICB0eXBlICgnYSwgJ2NtcCwgJ3opIG9wdGlvbnNcblxuICB2YWwgaW52YXJpYW50cyA6ICgnaywgJ2NtcCwgKCdrLCAndiwgJ2NtcCkgdCAtPiBib29sKSBvcHRpb25zXG4gIHZhbCBpc19lbXB0eSA6IChfLCBfLCBfKSB0IC0+IGJvb2xcbiAgdmFsIGxlbmd0aCA6IChfLCBfLCBfKSB0IC0+IGludFxuXG4gIHZhbCBhZGRcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0IC0+IGtleTonayBrZXkgLT4gZGF0YTondiAtPiAoJ2ssICd2LCAnY21wKSB0IE9yX2R1cGxpY2F0ZS50IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBhZGRfZXhuXG4gICAgOiAoJ2ssICdjbXAsICgnaywgJ3YsICdjbXApIHQgLT4ga2V5OidrIGtleSAtPiBkYXRhOid2IC0+ICgnaywgJ3YsICdjbXApIHQpIG9wdGlvbnNcblxuICB2YWwgc2V0XG4gICAgOiAoJ2ssICdjbXAsICgnaywgJ3YsICdjbXApIHQgLT4ga2V5OidrIGtleSAtPiBkYXRhOid2IC0+ICgnaywgJ3YsICdjbXApIHQpIG9wdGlvbnNcblxuICB2YWwgYWRkX211bHRpXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndiBsaXN0LCAnY21wKSB0IC0+IGtleTonayBrZXkgLT4gZGF0YTondiAtPiAoJ2ssICd2IGxpc3QsICdjbXApIHQgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIHJlbW92ZV9tdWx0aVxuICAgIDogKCdrLCAnY21wLCAoJ2ssICd2IGxpc3QsICdjbXApIHQgLT4gJ2sga2V5IC0+ICgnaywgJ3YgbGlzdCwgJ2NtcCkgdCkgb3B0aW9uc1xuXG4gIHZhbCBmaW5kX211bHRpIDogKCdrLCAnY21wLCAoJ2ssICd2IGxpc3QsICdjbXApIHQgLT4gJ2sga2V5IC0+ICd2IGxpc3QpIG9wdGlvbnNcblxuICB2YWwgY2hhbmdlXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndiwgJ2NtcCkgdCAtPiAnayBrZXkgLT4gZjooJ3Ygb3B0aW9uIC0+ICd2IG9wdGlvbikgLT4gKCdrLCAndiwgJ2NtcCkgdCApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgdXBkYXRlXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndiwgJ2NtcCkgdCAtPiAnayBrZXkgLT4gZjooJ3Ygb3B0aW9uIC0+ICd2KSAtPiAoJ2ssICd2LCAnY21wKSB0IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBmaW5kIDogKCdrLCAnY21wLCAoJ2ssICd2LCAnY21wKSB0IC0+ICdrIGtleSAtPiAndiBvcHRpb24pIG9wdGlvbnNcbiAgdmFsIGZpbmRfZXhuIDogKCdrLCAnY21wLCAoJ2ssICd2LCAnY21wKSB0IC0+ICdrIGtleSAtPiAndikgb3B0aW9uc1xuICB2YWwgcmVtb3ZlIDogKCdrLCAnY21wLCAoJ2ssICd2LCAnY21wKSB0IC0+ICdrIGtleSAtPiAoJ2ssICd2LCAnY21wKSB0KSBvcHRpb25zXG4gIHZhbCBtZW0gOiAoJ2ssICdjbXAsICgnaywgXywgJ2NtcCkgdCAtPiAnayBrZXkgLT4gYm9vbCkgb3B0aW9uc1xuICB2YWwgaXRlcl9rZXlzIDogKCdrLCBfLCBfKSB0IC0+IGY6KCdrIGtleSAtPiB1bml0KSAtPiB1bml0XG4gIHZhbCBpdGVyIDogKF8sICd2LCBfKSB0IC0+IGY6KCd2IC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIGl0ZXJpIDogKCdrLCAndiwgXykgdCAtPiBmOihrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gdW5pdCkgLT4gdW5pdFxuXG4gIHZhbCBpdGVyaV91bnRpbFxuICAgIDogICgnaywgJ3YsIF8pIHRcbiAgICAtPiBmOihrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IEZpbmlzaGVkX29yX3VuZmluaXNoZWQudFxuXG4gIHZhbCBpdGVyMlxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YxLCAnY21wKSB0XG4gICAgICAtPiAoJ2ssICd2MiwgJ2NtcCkgdFxuICAgICAgLT4gZjooa2V5OidrIGtleSAtPiBkYXRhOigndjEsICd2MikgTWVyZ2VfZWxlbWVudC50IC0+IHVuaXQpXG4gICAgICAtPiB1bml0IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBtYXAgOiAoJ2ssICd2MSwgJ2NtcCkgdCAtPiBmOigndjEgLT4gJ3YyKSAtPiAoJ2ssICd2MiwgJ2NtcCkgdFxuICB2YWwgbWFwaSA6ICgnaywgJ3YxLCAnY21wKSB0IC0+IGY6KGtleTonayBrZXkgLT4gZGF0YTondjEgLT4gJ3YyKSAtPiAoJ2ssICd2MiwgJ2NtcCkgdFxuICB2YWwgZm9sZCA6ICgnaywgJ3YsIF8pIHQgLT4gaW5pdDonYSAtPiBmOihrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gJ2EgLT4gJ2EpIC0+ICdhXG5cbiAgdmFsIGZvbGRfdW50aWxcbiAgICA6ICAoJ2ssICd2LCBfKSB0XG4gICAgLT4gaW5pdDonYVxuICAgIC0+IGY6KGtleTonayBrZXkgLT4gZGF0YTondiAtPiAnYSAtPiAoJ2EsICdmaW5hbCkgQ29udGFpbmVyLkNvbnRpbnVlX29yX3N0b3AudClcbiAgICAtPiBmaW5pc2g6KCdhIC0+ICdmaW5hbClcbiAgICAtPiAnZmluYWxcblxuICB2YWwgZm9sZF9yaWdodCA6ICgnaywgJ3YsIF8pIHQgLT4gaW5pdDonYSAtPiBmOihrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gJ2EgLT4gJ2EpIC0+ICdhXG5cbiAgdmFsIGZvbGQyXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndjEsICdjbXApIHRcbiAgICAgIC0+ICgnaywgJ3YyLCAnY21wKSB0XG4gICAgICAtPiBpbml0OidhXG4gICAgICAtPiBmOihrZXk6J2sga2V5IC0+IGRhdGE6KCd2MSwgJ3YyKSBNZXJnZV9lbGVtZW50LnQgLT4gJ2EgLT4gJ2EpXG4gICAgICAtPiAnYSApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgZmlsdGVyX2tleXNcbiAgICA6ICgnaywgJ2NtcCwgKCdrLCAndiwgJ2NtcCkgdCAtPiBmOignayBrZXkgLT4gYm9vbCkgLT4gKCdrLCAndiwgJ2NtcCkgdCkgb3B0aW9uc1xuXG4gIHZhbCBmaWx0ZXIgOiAoJ2ssICdjbXAsICgnaywgJ3YsICdjbXApIHQgLT4gZjooJ3YgLT4gYm9vbCkgLT4gKCdrLCAndiwgJ2NtcCkgdCkgb3B0aW9uc1xuXG4gIHZhbCBmaWx0ZXJpXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndiwgJ2NtcCkgdCAtPiBmOihrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gYm9vbCkgLT4gKCdrLCAndiwgJ2NtcCkgdCApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgZmlsdGVyX21hcFxuICAgIDogKCdrLCAnY21wLCAoJ2ssICd2MSwgJ2NtcCkgdCAtPiBmOigndjEgLT4gJ3YyIG9wdGlvbikgLT4gKCdrLCAndjIsICdjbXApIHQpIG9wdGlvbnNcblxuICB2YWwgZmlsdGVyX21hcGlcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2MSwgJ2NtcCkgdCAtPiBmOihrZXk6J2sga2V5IC0+IGRhdGE6J3YxIC0+ICd2MiBvcHRpb24pIC0+ICgnaywgJ3YyLCAnY21wKSB0XG4gICAgICApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgcGFydGl0aW9uX21hcGlcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2MSwgJ2NtcCkgdFxuICAgICAgLT4gZjooa2V5OidrIGtleSAtPiBkYXRhOid2MSAtPiAoJ3YyLCAndjMpIEVpdGhlci50KVxuICAgICAgLT4gKCdrLCAndjIsICdjbXApIHQgKiAoJ2ssICd2MywgJ2NtcCkgdCApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgcGFydGl0aW9uX21hcFxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YxLCAnY21wKSB0XG4gICAgICAtPiBmOigndjEgLT4gKCd2MiwgJ3YzKSBFaXRoZXIudClcbiAgICAgIC0+ICgnaywgJ3YyLCAnY21wKSB0ICogKCdrLCAndjMsICdjbXApIHQgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIHBhcnRpdGlvbmlfdGZcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAtPiBmOihrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gYm9vbClcbiAgICAgIC0+ICgnaywgJ3YsICdjbXApIHQgKiAoJ2ssICd2LCAnY21wKSB0IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBwYXJ0aXRpb25fdGZcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0IC0+IGY6KCd2IC0+IGJvb2wpIC0+ICgnaywgJ3YsICdjbXApIHQgKiAoJ2ssICd2LCAnY21wKSB0IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBjb21iaW5lX2Vycm9yc1xuICAgIDogKCdrLCAnY21wLCAoJ2ssICd2IE9yX2Vycm9yLnQsICdjbXApIHQgLT4gKCdrLCAndiwgJ2NtcCkgdCBPcl9lcnJvci50KSBvcHRpb25zXG5cbiAgdmFsIGNvbXBhcmVfZGlyZWN0XG4gICAgOiAoJ2ssICdjbXAsICgndiAtPiAndiAtPiBpbnQpIC0+ICgnaywgJ3YsICdjbXApIHQgLT4gKCdrLCAndiwgJ2NtcCkgdCAtPiBpbnQpIG9wdGlvbnNcblxuICB2YWwgZXF1YWxcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ3YgLT4gJ3YgLT4gYm9vbCkgLT4gKCdrLCAndiwgJ2NtcCkgdCAtPiAoJ2ssICd2LCAnY21wKSB0IC0+IGJvb2wgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIGtleXMgOiAoJ2ssIF8sIF8pIHQgLT4gJ2sga2V5IGxpc3RcbiAgdmFsIGRhdGEgOiAoXywgJ3YsIF8pIHQgLT4gJ3YgbGlzdFxuXG4gIHZhbCB0b19hbGlzdFxuICAgIDogID9rZXlfb3JkZXI6WyBgSW5jcmVhc2luZyB8IGBEZWNyZWFzaW5nIF1cbiAgICAtPiAoJ2ssICd2LCBfKSB0XG4gICAgLT4gKCdrIGtleSAqICd2KSBsaXN0XG5cbiAgdmFsIG1lcmdlXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndjEsICdjbXApIHRcbiAgICAgIC0+ICgnaywgJ3YyLCAnY21wKSB0XG4gICAgICAtPiBmOihrZXk6J2sga2V5IC0+ICgndjEsICd2MikgTWVyZ2VfZWxlbWVudC50IC0+ICd2MyBvcHRpb24pXG4gICAgICAtPiAoJ2ssICd2MywgJ2NtcCkgdCApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgbWVyZ2Vfc2tld2VkXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndiwgJ2NtcCkgdFxuICAgICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgICAgLT4gY29tYmluZTooa2V5OidrIGtleSAtPiAndiAtPiAndiAtPiAndilcbiAgICAgIC0+ICgnaywgJ3YsICdjbXApIHQgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIHN5bW1ldHJpY19kaWZmXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndiwgJ2NtcCkgdFxuICAgICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgICAgLT4gZGF0YV9lcXVhbDooJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAgIC0+ICgnayBrZXksICd2KSBTeW1tZXRyaWNfZGlmZl9lbGVtZW50LnQgU2VxdWVuY2UudCApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgZm9sZF9zeW1tZXRyaWNfZGlmZlxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YsICdjbXApIHRcbiAgICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAgIC0+IGRhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgICAtPiBpbml0OidhXG4gICAgICAtPiBmOignYSAtPiAoJ2sga2V5LCAndikgU3ltbWV0cmljX2RpZmZfZWxlbWVudC50IC0+ICdhKVxuICAgICAgLT4gJ2EgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIG1pbl9lbHQgOiAoJ2ssICd2LCBfKSB0IC0+ICgnayBrZXkgKiAndikgb3B0aW9uXG4gIHZhbCBtaW5fZWx0X2V4biA6ICgnaywgJ3YsIF8pIHQgLT4gJ2sga2V5ICogJ3ZcbiAgdmFsIG1heF9lbHQgOiAoJ2ssICd2LCBfKSB0IC0+ICgnayBrZXkgKiAndikgb3B0aW9uXG4gIHZhbCBtYXhfZWx0X2V4biA6ICgnaywgJ3YsIF8pIHQgLT4gJ2sga2V5ICogJ3ZcbiAgdmFsIGZvcl9hbGwgOiAoJ2ssICd2LCBfKSB0IC0+IGY6KCd2IC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGZvcl9hbGxpIDogKCdrLCAndiwgXykgdCAtPiBmOihrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZXhpc3RzIDogKCdrLCAndiwgXykgdCAtPiBmOigndiAtPiBib29sKSAtPiBib29sXG4gIHZhbCBleGlzdHNpIDogKCdrLCAndiwgXykgdCAtPiBmOihrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgY291bnQgOiAoJ2ssICd2LCBfKSB0IC0+IGY6KCd2IC0+IGJvb2wpIC0+IGludFxuICB2YWwgY291bnRpIDogKCdrLCAndiwgXykgdCAtPiBmOihrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gYm9vbCkgLT4gaW50XG5cbiAgdmFsIHNwbGl0XG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndiwgJ2NtcCkgdFxuICAgICAgLT4gJ2sga2V5XG4gICAgICAtPiAoJ2ssICd2LCAnY21wKSB0ICogKCdrIGtleSAqICd2KSBvcHRpb24gKiAoJ2ssICd2LCAnY21wKSB0IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBhcHBlbmRcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCBsb3dlcl9wYXJ0OignaywgJ3YsICdjbXApIHRcbiAgICAgIC0+IHVwcGVyX3BhcnQ6KCdrLCAndiwgJ2NtcCkgdFxuICAgICAgLT4gWyBgT2sgb2YgKCdrLCAndiwgJ2NtcCkgdCB8IGBPdmVybGFwcGluZ19rZXlfcmFuZ2VzIF0gKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIHN1YnJhbmdlXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndiwgJ2NtcCkgdFxuICAgICAgLT4gbG93ZXJfYm91bmQ6J2sga2V5IE1heWJlX2JvdW5kLnRcbiAgICAgIC0+IHVwcGVyX2JvdW5kOidrIGtleSBNYXliZV9ib3VuZC50XG4gICAgICAtPiAoJ2ssICd2LCAnY21wKSB0IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBmb2xkX3JhbmdlX2luY2x1c2l2ZVxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YsICdjbXApIHRcbiAgICAgIC0+IG1pbjonayBrZXlcbiAgICAgIC0+IG1heDonayBrZXlcbiAgICAgIC0+IGluaXQ6J2FcbiAgICAgIC0+IGY6KGtleTonayBrZXkgLT4gZGF0YTondiAtPiAnYSAtPiAnYSlcbiAgICAgIC0+ICdhIClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCByYW5nZV90b19hbGlzdFxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YsICdjbXApIHQgLT4gbWluOidrIGtleSAtPiBtYXg6J2sga2V5IC0+ICgnayBrZXkgKiAndikgbGlzdCApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgY2xvc2VzdF9rZXlcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAtPiBbIGBHcmVhdGVyX29yX2VxdWFsX3RvIHwgYEdyZWF0ZXJfdGhhbiB8IGBMZXNzX29yX2VxdWFsX3RvIHwgYExlc3NfdGhhbiBdXG4gICAgICAtPiAnayBrZXlcbiAgICAgIC0+ICgnayBrZXkgKiAndikgb3B0aW9uIClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBudGggOiAoJ2ssICd2LCAnY21wKSB0IC0+IGludCAtPiAoJ2sga2V5ICogJ3YpIG9wdGlvblxuICB2YWwgbnRoX2V4biA6ICgnaywgJ3YsICdjbXApIHQgLT4gaW50IC0+ICdrIGtleSAqICd2XG4gIHZhbCByYW5rIDogKCdrLCAnY21wLCAoJ2ssIF8sICdjbXApIHQgLT4gJ2sga2V5IC0+IGludCBvcHRpb24pIG9wdGlvbnNcbiAgdmFsIHRvX3RyZWUgOiAoJ2ssICd2LCAnY21wKSB0IC0+ICgnayBrZXksICd2LCAnY21wKSB0cmVlXG5cbiAgdmFsIHRvX3NlcXVlbmNlXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgP29yZGVyOlsgYEluY3JlYXNpbmdfa2V5IHwgYERlY3JlYXNpbmdfa2V5IF1cbiAgICAgIC0+ID9rZXlzX2dyZWF0ZXJfb3JfZXF1YWxfdG86J2sga2V5XG4gICAgICAtPiA/a2V5c19sZXNzX29yX2VxdWFsX3RvOidrIGtleVxuICAgICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgICAgLT4gKCdrIGtleSAqICd2KSBTZXF1ZW5jZS50IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBiaW5hcnlfc2VhcmNoXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndiwgJ2NtcCkgdFxuICAgICAgLT4gY29tcGFyZTooa2V5OidrIGtleSAtPiBkYXRhOid2IC0+ICdrZXkgLT4gaW50KVxuICAgICAgLT4gQmluYXJ5X3NlYXJjaGFibGUuV2hpY2hfdGFyZ2V0X2J5X2tleS50XG4gICAgICAtPiAna2V5XG4gICAgICAtPiAoJ2sga2V5ICogJ3YpIG9wdGlvbiApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWRcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAtPiBzZWdtZW50X29mOihrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gWyBgTGVmdCB8IGBSaWdodCBdKVxuICAgICAgLT4gQmluYXJ5X3NlYXJjaGFibGUuV2hpY2hfdGFyZ2V0X2J5X3NlZ21lbnQudFxuICAgICAgLT4gKCdrIGtleSAqICd2KSBvcHRpb24gKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIGJpbmFyeV9zZWFyY2hfc3VicmFuZ2VcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAtPiBjb21wYXJlOihrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gJ2JvdW5kIC0+IGludClcbiAgICAgIC0+IGxvd2VyX2JvdW5kOidib3VuZCBNYXliZV9ib3VuZC50XG4gICAgICAtPiB1cHBlcl9ib3VuZDonYm91bmQgTWF5YmVfYm91bmQudFxuICAgICAgLT4gKCdrLCAndiwgJ2NtcCkgdCApXG4gICAgICAgIG9wdGlvbnNcbmVuZFxuXG5tb2R1bGUgdHlwZSBBY2Nlc3NvcnMxID0gc2lnXG4gIHR5cGUgJ2EgdFxuICB0eXBlICdhIHRyZWVcbiAgdHlwZSBrZXlcbiAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3NcblxuICB2YWwgaW52YXJpYW50cyA6IF8gdCAtPiBib29sXG4gIHZhbCBpc19lbXB0eSA6IF8gdCAtPiBib29sXG4gIHZhbCBsZW5ndGggOiBfIHQgLT4gaW50XG4gIHZhbCBhZGQgOiAnYSB0IC0+IGtleTprZXkgLT4gZGF0YTonYSAtPiAnYSB0IE9yX2R1cGxpY2F0ZS50XG4gIHZhbCBhZGRfZXhuIDogJ2EgdCAtPiBrZXk6a2V5IC0+IGRhdGE6J2EgLT4gJ2EgdFxuICB2YWwgc2V0IDogJ2EgdCAtPiBrZXk6a2V5IC0+IGRhdGE6J2EgLT4gJ2EgdFxuICB2YWwgYWRkX211bHRpIDogJ2EgbGlzdCB0IC0+IGtleTprZXkgLT4gZGF0YTonYSAtPiAnYSBsaXN0IHRcbiAgdmFsIHJlbW92ZV9tdWx0aSA6ICdhIGxpc3QgdCAtPiBrZXkgLT4gJ2EgbGlzdCB0XG4gIHZhbCBmaW5kX211bHRpIDogJ2EgbGlzdCB0IC0+IGtleSAtPiAnYSBsaXN0XG4gIHZhbCBjaGFuZ2UgOiAnYSB0IC0+IGtleSAtPiBmOignYSBvcHRpb24gLT4gJ2Egb3B0aW9uKSAtPiAnYSB0XG4gIHZhbCB1cGRhdGUgOiAnYSB0IC0+IGtleSAtPiBmOignYSBvcHRpb24gLT4gJ2EpIC0+ICdhIHRcbiAgdmFsIGZpbmQgOiAnYSB0IC0+IGtleSAtPiAnYSBvcHRpb25cbiAgdmFsIGZpbmRfZXhuIDogJ2EgdCAtPiBrZXkgLT4gJ2FcbiAgdmFsIHJlbW92ZSA6ICdhIHQgLT4ga2V5IC0+ICdhIHRcbiAgdmFsIG1lbSA6IF8gdCAtPiBrZXkgLT4gYm9vbFxuICB2YWwgaXRlcl9rZXlzIDogXyB0IC0+IGY6KGtleSAtPiB1bml0KSAtPiB1bml0XG4gIHZhbCBpdGVyIDogJ2EgdCAtPiBmOignYSAtPiB1bml0KSAtPiB1bml0XG4gIHZhbCBpdGVyaSA6ICdhIHQgLT4gZjooa2V5OmtleSAtPiBkYXRhOidhIC0+IHVuaXQpIC0+IHVuaXRcblxuICB2YWwgaXRlcmlfdW50aWxcbiAgICA6ICAnYSB0XG4gICAgLT4gZjooa2V5OmtleSAtPiBkYXRhOidhIC0+IENvbnRpbnVlX29yX3N0b3AudClcbiAgICAtPiBGaW5pc2hlZF9vcl91bmZpbmlzaGVkLnRcblxuICB2YWwgaXRlcjIgOiAnYSB0IC0+ICdiIHQgLT4gZjooa2V5OmtleSAtPiBkYXRhOignYSwgJ2IpIE1lcmdlX2VsZW1lbnQudCAtPiB1bml0KSAtPiB1bml0XG4gIHZhbCBtYXAgOiAnYSB0IC0+IGY6KCdhIC0+ICdiKSAtPiAnYiB0XG4gIHZhbCBtYXBpIDogJ2EgdCAtPiBmOihrZXk6a2V5IC0+IGRhdGE6J2EgLT4gJ2IpIC0+ICdiIHRcbiAgdmFsIGZvbGQgOiAnYSB0IC0+IGluaXQ6J2IgLT4gZjooa2V5OmtleSAtPiBkYXRhOidhIC0+ICdiIC0+ICdiKSAtPiAnYlxuXG4gIHZhbCBmb2xkX3VudGlsXG4gICAgOiAgJ2EgdFxuICAgIC0+IGluaXQ6J2FjY1xuICAgIC0+IGY6KGtleTprZXkgLT4gZGF0YTonYSAtPiAnYWNjIC0+ICgnYWNjLCAnZmluYWwpIENvbnRhaW5lci5Db250aW51ZV9vcl9zdG9wLnQpXG4gICAgLT4gZmluaXNoOignYWNjIC0+ICdmaW5hbClcbiAgICAtPiAnZmluYWxcblxuICB2YWwgZm9sZF9yaWdodCA6ICdhIHQgLT4gaW5pdDonYiAtPiBmOihrZXk6a2V5IC0+IGRhdGE6J2EgLT4gJ2IgLT4gJ2IpIC0+ICdiXG5cbiAgdmFsIGZvbGQyXG4gICAgOiAgJ2EgdFxuICAgIC0+ICdiIHRcbiAgICAtPiBpbml0OidjXG4gICAgLT4gZjooa2V5OmtleSAtPiBkYXRhOignYSwgJ2IpIE1lcmdlX2VsZW1lbnQudCAtPiAnYyAtPiAnYylcbiAgICAtPiAnY1xuXG4gIHZhbCBmaWx0ZXJfa2V5cyA6ICdhIHQgLT4gZjooa2V5IC0+IGJvb2wpIC0+ICdhIHRcbiAgdmFsIGZpbHRlciA6ICdhIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gJ2EgdFxuICB2YWwgZmlsdGVyaSA6ICdhIHQgLT4gZjooa2V5OmtleSAtPiBkYXRhOidhIC0+IGJvb2wpIC0+ICdhIHRcbiAgdmFsIGZpbHRlcl9tYXAgOiAnYSB0IC0+IGY6KCdhIC0+ICdiIG9wdGlvbikgLT4gJ2IgdFxuICB2YWwgZmlsdGVyX21hcGkgOiAnYSB0IC0+IGY6KGtleTprZXkgLT4gZGF0YTonYSAtPiAnYiBvcHRpb24pIC0+ICdiIHRcbiAgdmFsIHBhcnRpdGlvbl9tYXBpIDogJ2EgdCAtPiBmOihrZXk6a2V5IC0+IGRhdGE6J2EgLT4gKCdiLCAnYykgRWl0aGVyLnQpIC0+ICdiIHQgKiAnYyB0XG4gIHZhbCBwYXJ0aXRpb25fbWFwIDogJ2EgdCAtPiBmOignYSAtPiAoJ2IsICdjKSBFaXRoZXIudCkgLT4gJ2IgdCAqICdjIHRcbiAgdmFsIHBhcnRpdGlvbmlfdGYgOiAnYSB0IC0+IGY6KGtleTprZXkgLT4gZGF0YTonYSAtPiBib29sKSAtPiAnYSB0ICogJ2EgdFxuICB2YWwgcGFydGl0aW9uX3RmIDogJ2EgdCAtPiBmOignYSAtPiBib29sKSAtPiAnYSB0ICogJ2EgdFxuICB2YWwgY29tYmluZV9lcnJvcnMgOiAnYSBPcl9lcnJvci50IHQgLT4gJ2EgdCBPcl9lcnJvci50XG4gIHZhbCBjb21wYXJlX2RpcmVjdCA6ICgnYSAtPiAnYSAtPiBpbnQpIC0+ICdhIHQgLT4gJ2EgdCAtPiBpbnRcbiAgdmFsIGVxdWFsIDogKCdhIC0+ICdhIC0+IGJvb2wpIC0+ICdhIHQgLT4gJ2EgdCAtPiBib29sXG4gIHZhbCBrZXlzIDogXyB0IC0+IGtleSBsaXN0XG4gIHZhbCBkYXRhIDogJ2EgdCAtPiAnYSBsaXN0XG4gIHZhbCB0b19hbGlzdCA6ID9rZXlfb3JkZXI6WyBgSW5jcmVhc2luZyB8IGBEZWNyZWFzaW5nIF0gLT4gJ2EgdCAtPiAoa2V5ICogJ2EpIGxpc3RcbiAgdmFsIG1lcmdlIDogJ2EgdCAtPiAnYiB0IC0+IGY6KGtleTprZXkgLT4gKCdhLCAnYikgTWVyZ2VfZWxlbWVudC50IC0+ICdjIG9wdGlvbikgLT4gJ2MgdFxuICB2YWwgbWVyZ2Vfc2tld2VkIDogJ3YgdCAtPiAndiB0IC0+IGNvbWJpbmU6KGtleTprZXkgLT4gJ3YgLT4gJ3YgLT4gJ3YpIC0+ICd2IHRcblxuICB2YWwgc3ltbWV0cmljX2RpZmZcbiAgICA6ICAnYSB0XG4gICAgLT4gJ2EgdFxuICAgIC0+IGRhdGFfZXF1YWw6KCdhIC0+ICdhIC0+IGJvb2wpXG4gICAgLT4gKGtleSwgJ2EpIFN5bW1ldHJpY19kaWZmX2VsZW1lbnQudCBTZXF1ZW5jZS50XG5cbiAgdmFsIGZvbGRfc3ltbWV0cmljX2RpZmZcbiAgICA6ICAnYSB0XG4gICAgLT4gJ2EgdFxuICAgIC0+IGRhdGFfZXF1YWw6KCdhIC0+ICdhIC0+IGJvb2wpXG4gICAgLT4gaW5pdDonY1xuICAgIC0+IGY6KCdjIC0+IChrZXksICdhKSBTeW1tZXRyaWNfZGlmZl9lbGVtZW50LnQgLT4gJ2MpXG4gICAgLT4gJ2NcblxuICB2YWwgbWluX2VsdCA6ICdhIHQgLT4gKGtleSAqICdhKSBvcHRpb25cbiAgdmFsIG1pbl9lbHRfZXhuIDogJ2EgdCAtPiBrZXkgKiAnYVxuICB2YWwgbWF4X2VsdCA6ICdhIHQgLT4gKGtleSAqICdhKSBvcHRpb25cbiAgdmFsIG1heF9lbHRfZXhuIDogJ2EgdCAtPiBrZXkgKiAnYVxuICB2YWwgZm9yX2FsbCA6ICdhIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZm9yX2FsbGkgOiAnYSB0IC0+IGY6KGtleTprZXkgLT4gZGF0YTonYSAtPiBib29sKSAtPiBib29sXG4gIHZhbCBleGlzdHMgOiAnYSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGV4aXN0c2kgOiAnYSB0IC0+IGY6KGtleTprZXkgLT4gZGF0YTonYSAtPiBib29sKSAtPiBib29sXG4gIHZhbCBjb3VudCA6ICdhIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gaW50XG4gIHZhbCBjb3VudGkgOiAnYSB0IC0+IGY6KGtleTprZXkgLT4gZGF0YTonYSAtPiBib29sKSAtPiBpbnRcbiAgdmFsIHNwbGl0IDogJ2EgdCAtPiBrZXkgLT4gJ2EgdCAqIChrZXkgKiAnYSkgb3B0aW9uICogJ2EgdFxuXG4gIHZhbCBhcHBlbmRcbiAgICA6ICBsb3dlcl9wYXJ0OidhIHRcbiAgICAtPiB1cHBlcl9wYXJ0OidhIHRcbiAgICAtPiBbIGBPayBvZiAnYSB0IHwgYE92ZXJsYXBwaW5nX2tleV9yYW5nZXMgXVxuXG4gIHZhbCBzdWJyYW5nZVxuICAgIDogICdhIHRcbiAgICAtPiBsb3dlcl9ib3VuZDprZXkgTWF5YmVfYm91bmQudFxuICAgIC0+IHVwcGVyX2JvdW5kOmtleSBNYXliZV9ib3VuZC50XG4gICAgLT4gJ2EgdFxuXG4gIHZhbCBmb2xkX3JhbmdlX2luY2x1c2l2ZVxuICAgIDogICdhIHRcbiAgICAtPiBtaW46a2V5XG4gICAgLT4gbWF4OmtleVxuICAgIC0+IGluaXQ6J2JcbiAgICAtPiBmOihrZXk6a2V5IC0+IGRhdGE6J2EgLT4gJ2IgLT4gJ2IpXG4gICAgLT4gJ2JcblxuICB2YWwgcmFuZ2VfdG9fYWxpc3QgOiAnYSB0IC0+IG1pbjprZXkgLT4gbWF4OmtleSAtPiAoa2V5ICogJ2EpIGxpc3RcblxuICB2YWwgY2xvc2VzdF9rZXlcbiAgICA6ICAnYSB0XG4gICAgLT4gWyBgR3JlYXRlcl9vcl9lcXVhbF90byB8IGBHcmVhdGVyX3RoYW4gfCBgTGVzc19vcl9lcXVhbF90byB8IGBMZXNzX3RoYW4gXVxuICAgIC0+IGtleVxuICAgIC0+IChrZXkgKiAnYSkgb3B0aW9uXG5cbiAgdmFsIG50aCA6ICdhIHQgLT4gaW50IC0+IChrZXkgKiAnYSkgb3B0aW9uXG4gIHZhbCBudGhfZXhuIDogJ2EgdCAtPiBpbnQgLT4ga2V5ICogJ2FcbiAgdmFsIHJhbmsgOiBfIHQgLT4ga2V5IC0+IGludCBvcHRpb25cbiAgdmFsIHRvX3RyZWUgOiAnYSB0IC0+ICdhIHRyZWVcblxuICB2YWwgdG9fc2VxdWVuY2VcbiAgICA6ICA/b3JkZXI6WyBgSW5jcmVhc2luZ19rZXkgfCBgRGVjcmVhc2luZ19rZXkgXVxuICAgIC0+ID9rZXlzX2dyZWF0ZXJfb3JfZXF1YWxfdG86a2V5XG4gICAgLT4gP2tleXNfbGVzc19vcl9lcXVhbF90bzprZXlcbiAgICAtPiAnYSB0XG4gICAgLT4gKGtleSAqICdhKSBTZXF1ZW5jZS50XG5cbiAgdmFsIGJpbmFyeV9zZWFyY2hcbiAgICA6ICAnYSB0XG4gICAgLT4gY29tcGFyZTooa2V5OmtleSAtPiBkYXRhOidhIC0+ICdrZXkgLT4gaW50KVxuICAgIC0+IEJpbmFyeV9zZWFyY2hhYmxlLldoaWNoX3RhcmdldF9ieV9rZXkudFxuICAgIC0+ICdrZXlcbiAgICAtPiAoa2V5ICogJ2EpIG9wdGlvblxuXG4gIHZhbCBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZFxuICAgIDogICdhIHRcbiAgICAtPiBzZWdtZW50X29mOihrZXk6a2V5IC0+IGRhdGE6J2EgLT4gWyBgTGVmdCB8IGBSaWdodCBdKVxuICAgIC0+IEJpbmFyeV9zZWFyY2hhYmxlLldoaWNoX3RhcmdldF9ieV9zZWdtZW50LnRcbiAgICAtPiAoa2V5ICogJ2EpIG9wdGlvblxuXG4gIHZhbCBiaW5hcnlfc2VhcmNoX3N1YnJhbmdlXG4gICAgOiAgJ2EgdFxuICAgIC0+IGNvbXBhcmU6KGtleTprZXkgLT4gZGF0YTonYSAtPiAnYm91bmQgLT4gaW50KVxuICAgIC0+IGxvd2VyX2JvdW5kOidib3VuZCBNYXliZV9ib3VuZC50XG4gICAgLT4gdXBwZXJfYm91bmQ6J2JvdW5kIE1heWJlX2JvdW5kLnRcbiAgICAtPiAnYSB0XG5lbmRcblxubW9kdWxlIHR5cGUgQWNjZXNzb3JzMiA9IHNpZ1xuICB0eXBlICgnYSwgJ2IpIHRcbiAgdHlwZSAoJ2EsICdiKSB0cmVlXG4gIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgdmFsIGludmFyaWFudHMgOiAoXywgXykgdCAtPiBib29sXG4gIHZhbCBpc19lbXB0eSA6IChfLCBfKSB0IC0+IGJvb2xcbiAgdmFsIGxlbmd0aCA6IChfLCBfKSB0IC0+IGludFxuICB2YWwgYWRkIDogKCdhLCAnYikgdCAtPiBrZXk6J2EgLT4gZGF0YTonYiAtPiAoJ2EsICdiKSB0IE9yX2R1cGxpY2F0ZS50XG4gIHZhbCBhZGRfZXhuIDogKCdhLCAnYikgdCAtPiBrZXk6J2EgLT4gZGF0YTonYiAtPiAoJ2EsICdiKSB0XG4gIHZhbCBzZXQgOiAoJ2EsICdiKSB0IC0+IGtleTonYSAtPiBkYXRhOidiIC0+ICgnYSwgJ2IpIHRcbiAgdmFsIGFkZF9tdWx0aSA6ICgnYSwgJ2IgbGlzdCkgdCAtPiBrZXk6J2EgLT4gZGF0YTonYiAtPiAoJ2EsICdiIGxpc3QpIHRcbiAgdmFsIHJlbW92ZV9tdWx0aSA6ICgnYSwgJ2IgbGlzdCkgdCAtPiAnYSAtPiAoJ2EsICdiIGxpc3QpIHRcbiAgdmFsIGZpbmRfbXVsdGkgOiAoJ2EsICdiIGxpc3QpIHQgLT4gJ2EgLT4gJ2IgbGlzdFxuICB2YWwgY2hhbmdlIDogKCdhLCAnYikgdCAtPiAnYSAtPiBmOignYiBvcHRpb24gLT4gJ2Igb3B0aW9uKSAtPiAoJ2EsICdiKSB0XG4gIHZhbCB1cGRhdGUgOiAoJ2EsICdiKSB0IC0+ICdhIC0+IGY6KCdiIG9wdGlvbiAtPiAnYikgLT4gKCdhLCAnYikgdFxuICB2YWwgZmluZCA6ICgnYSwgJ2IpIHQgLT4gJ2EgLT4gJ2Igb3B0aW9uXG4gIHZhbCBmaW5kX2V4biA6ICgnYSwgJ2IpIHQgLT4gJ2EgLT4gJ2JcbiAgdmFsIHJlbW92ZSA6ICgnYSwgJ2IpIHQgLT4gJ2EgLT4gKCdhLCAnYikgdFxuICB2YWwgbWVtIDogKCdhLCAnYikgdCAtPiAnYSAtPiBib29sXG4gIHZhbCBpdGVyX2tleXMgOiAoJ2EsIF8pIHQgLT4gZjooJ2EgLT4gdW5pdCkgLT4gdW5pdFxuICB2YWwgaXRlciA6IChfLCAnYikgdCAtPiBmOignYiAtPiB1bml0KSAtPiB1bml0XG4gIHZhbCBpdGVyaSA6ICgnYSwgJ2IpIHQgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gdW5pdCkgLT4gdW5pdFxuXG4gIHZhbCBpdGVyaV91bnRpbFxuICAgIDogICgnYSwgJ2IpIHRcbiAgICAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiBDb250aW51ZV9vcl9zdG9wLnQpXG4gICAgLT4gRmluaXNoZWRfb3JfdW5maW5pc2hlZC50XG5cbiAgdmFsIGl0ZXIyXG4gICAgOiAgKCdhLCAnYikgdFxuICAgIC0+ICgnYSwgJ2MpIHRcbiAgICAtPiBmOihrZXk6J2EgLT4gZGF0YTooJ2IsICdjKSBNZXJnZV9lbGVtZW50LnQgLT4gdW5pdClcbiAgICAtPiB1bml0XG5cbiAgdmFsIG1hcCA6ICgnYSwgJ2IpIHQgLT4gZjooJ2IgLT4gJ2MpIC0+ICgnYSwgJ2MpIHRcbiAgdmFsIG1hcGkgOiAoJ2EsICdiKSB0IC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+ICdjKSAtPiAoJ2EsICdjKSB0XG4gIHZhbCBmb2xkIDogKCdhLCAnYikgdCAtPiBpbml0OidjIC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+ICdjIC0+ICdjKSAtPiAnY1xuXG4gIHZhbCBmb2xkX3VudGlsXG4gICAgOiAgKCdrLCAndikgdFxuICAgIC0+IGluaXQ6J2FcbiAgICAtPiBmOihrZXk6J2sgLT4gZGF0YTondiAtPiAnYSAtPiAoJ2EsICdmaW5hbCkgQ29udGFpbmVyLkNvbnRpbnVlX29yX3N0b3AudClcbiAgICAtPiBmaW5pc2g6KCdhIC0+ICdmaW5hbClcbiAgICAtPiAnZmluYWxcblxuICB2YWwgZm9sZF9yaWdodCA6ICgnYSwgJ2IpIHQgLT4gaW5pdDonYyAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiAnYyAtPiAnYykgLT4gJ2NcblxuICB2YWwgZm9sZDJcbiAgICA6ICAoJ2EsICdiKSB0XG4gICAgLT4gKCdhLCAnYykgdFxuICAgIC0+IGluaXQ6J2RcbiAgICAtPiBmOihrZXk6J2EgLT4gZGF0YTooJ2IsICdjKSBNZXJnZV9lbGVtZW50LnQgLT4gJ2QgLT4gJ2QpXG4gICAgLT4gJ2RcblxuICB2YWwgZmlsdGVyX2tleXMgOiAoJ2EsICdiKSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+ICgnYSwgJ2IpIHRcbiAgdmFsIGZpbHRlciA6ICgnYSwgJ2IpIHQgLT4gZjooJ2IgLT4gYm9vbCkgLT4gKCdhLCAnYikgdFxuICB2YWwgZmlsdGVyaSA6ICgnYSwgJ2IpIHQgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gYm9vbCkgLT4gKCdhLCAnYikgdFxuICB2YWwgZmlsdGVyX21hcCA6ICgnYSwgJ2IpIHQgLT4gZjooJ2IgLT4gJ2Mgb3B0aW9uKSAtPiAoJ2EsICdjKSB0XG4gIHZhbCBmaWx0ZXJfbWFwaSA6ICgnYSwgJ2IpIHQgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gJ2Mgb3B0aW9uKSAtPiAoJ2EsICdjKSB0XG5cbiAgdmFsIHBhcnRpdGlvbl9tYXBpXG4gICAgOiAgKCdhLCAnYikgdFxuICAgIC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+ICgnYywgJ2QpIEVpdGhlci50KVxuICAgIC0+ICgnYSwgJ2MpIHQgKiAoJ2EsICdkKSB0XG5cbiAgdmFsIHBhcnRpdGlvbl9tYXAgOiAoJ2EsICdiKSB0IC0+IGY6KCdiIC0+ICgnYywgJ2QpIEVpdGhlci50KSAtPiAoJ2EsICdjKSB0ICogKCdhLCAnZCkgdFxuXG4gIHZhbCBwYXJ0aXRpb25pX3RmXG4gICAgOiAgKCdhLCAnYikgdFxuICAgIC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+IGJvb2wpXG4gICAgLT4gKCdhLCAnYikgdCAqICgnYSwgJ2IpIHRcblxuICB2YWwgcGFydGl0aW9uX3RmIDogKCdhLCAnYikgdCAtPiBmOignYiAtPiBib29sKSAtPiAoJ2EsICdiKSB0ICogKCdhLCAnYikgdFxuICB2YWwgY29tYmluZV9lcnJvcnMgOiAoJ2EsICdiIE9yX2Vycm9yLnQpIHQgLT4gKCdhLCAnYikgdCBPcl9lcnJvci50XG4gIHZhbCBjb21wYXJlX2RpcmVjdCA6ICgnYiAtPiAnYiAtPiBpbnQpIC0+ICgnYSwgJ2IpIHQgLT4gKCdhLCAnYikgdCAtPiBpbnRcbiAgdmFsIGVxdWFsIDogKCdiIC0+ICdiIC0+IGJvb2wpIC0+ICgnYSwgJ2IpIHQgLT4gKCdhLCAnYikgdCAtPiBib29sXG4gIHZhbCBrZXlzIDogKCdhLCBfKSB0IC0+ICdhIGxpc3RcbiAgdmFsIGRhdGEgOiAoXywgJ2IpIHQgLT4gJ2IgbGlzdFxuICB2YWwgdG9fYWxpc3QgOiA/a2V5X29yZGVyOlsgYEluY3JlYXNpbmcgfCBgRGVjcmVhc2luZyBdIC0+ICgnYSwgJ2IpIHQgLT4gKCdhICogJ2IpIGxpc3RcblxuICB2YWwgbWVyZ2VcbiAgICA6ICAoJ2EsICdiKSB0XG4gICAgLT4gKCdhLCAnYykgdFxuICAgIC0+IGY6KGtleTonYSAtPiAoJ2IsICdjKSBNZXJnZV9lbGVtZW50LnQgLT4gJ2Qgb3B0aW9uKVxuICAgIC0+ICgnYSwgJ2QpIHRcblxuICB2YWwgbWVyZ2Vfc2tld2VkXG4gICAgOiAgKCdrLCAndikgdFxuICAgIC0+ICgnaywgJ3YpIHRcbiAgICAtPiBjb21iaW5lOihrZXk6J2sgLT4gJ3YgLT4gJ3YgLT4gJ3YpXG4gICAgLT4gKCdrLCAndikgdFxuXG4gIHZhbCBzeW1tZXRyaWNfZGlmZlxuICAgIDogICgnYSwgJ2IpIHRcbiAgICAtPiAoJ2EsICdiKSB0XG4gICAgLT4gZGF0YV9lcXVhbDooJ2IgLT4gJ2IgLT4gYm9vbClcbiAgICAtPiAoJ2EsICdiKSBTeW1tZXRyaWNfZGlmZl9lbGVtZW50LnQgU2VxdWVuY2UudFxuXG4gIHZhbCBmb2xkX3N5bW1ldHJpY19kaWZmXG4gICAgOiAgKCdhLCAnYikgdFxuICAgIC0+ICgnYSwgJ2IpIHRcbiAgICAtPiBkYXRhX2VxdWFsOignYiAtPiAnYiAtPiBib29sKVxuICAgIC0+IGluaXQ6J2NcbiAgICAtPiBmOignYyAtPiAoJ2EsICdiKSBTeW1tZXRyaWNfZGlmZl9lbGVtZW50LnQgLT4gJ2MpXG4gICAgLT4gJ2NcblxuICB2YWwgbWluX2VsdCA6ICgnYSwgJ2IpIHQgLT4gKCdhICogJ2IpIG9wdGlvblxuICB2YWwgbWluX2VsdF9leG4gOiAoJ2EsICdiKSB0IC0+ICdhICogJ2JcbiAgdmFsIG1heF9lbHQgOiAoJ2EsICdiKSB0IC0+ICgnYSAqICdiKSBvcHRpb25cbiAgdmFsIG1heF9lbHRfZXhuIDogKCdhLCAnYikgdCAtPiAnYSAqICdiXG4gIHZhbCBmb3JfYWxsIDogKF8sICdiKSB0IC0+IGY6KCdiIC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGZvcl9hbGxpIDogKCdhLCAnYikgdCAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiBib29sKSAtPiBib29sXG4gIHZhbCBleGlzdHMgOiAoXywgJ2IpIHQgLT4gZjooJ2IgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZXhpc3RzaSA6ICgnYSwgJ2IpIHQgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgY291bnQgOiAoXywgJ2IpIHQgLT4gZjooJ2IgLT4gYm9vbCkgLT4gaW50XG4gIHZhbCBjb3VudGkgOiAoJ2EsICdiKSB0IC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+IGJvb2wpIC0+IGludFxuICB2YWwgc3BsaXQgOiAoJ2EsICdiKSB0IC0+ICdhIC0+ICgnYSwgJ2IpIHQgKiAoJ2EgKiAnYikgb3B0aW9uICogKCdhLCAnYikgdFxuXG4gIHZhbCBhcHBlbmRcbiAgICA6ICBsb3dlcl9wYXJ0OignYSwgJ2IpIHRcbiAgICAtPiB1cHBlcl9wYXJ0OignYSwgJ2IpIHRcbiAgICAtPiBbIGBPayBvZiAoJ2EsICdiKSB0IHwgYE92ZXJsYXBwaW5nX2tleV9yYW5nZXMgXVxuXG4gIHZhbCBzdWJyYW5nZVxuICAgIDogICgnYSwgJ2IpIHRcbiAgICAtPiBsb3dlcl9ib3VuZDonYSBNYXliZV9ib3VuZC50XG4gICAgLT4gdXBwZXJfYm91bmQ6J2EgTWF5YmVfYm91bmQudFxuICAgIC0+ICgnYSwgJ2IpIHRcblxuICB2YWwgZm9sZF9yYW5nZV9pbmNsdXNpdmVcbiAgICA6ICAoJ2EsICdiKSB0XG4gICAgLT4gbWluOidhXG4gICAgLT4gbWF4OidhXG4gICAgLT4gaW5pdDonY1xuICAgIC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+ICdjIC0+ICdjKVxuICAgIC0+ICdjXG5cbiAgdmFsIHJhbmdlX3RvX2FsaXN0IDogKCdhLCAnYikgdCAtPiBtaW46J2EgLT4gbWF4OidhIC0+ICgnYSAqICdiKSBsaXN0XG5cbiAgdmFsIGNsb3Nlc3Rfa2V5XG4gICAgOiAgKCdhLCAnYikgdFxuICAgIC0+IFsgYEdyZWF0ZXJfb3JfZXF1YWxfdG8gfCBgR3JlYXRlcl90aGFuIHwgYExlc3Nfb3JfZXF1YWxfdG8gfCBgTGVzc190aGFuIF1cbiAgICAtPiAnYVxuICAgIC0+ICgnYSAqICdiKSBvcHRpb25cblxuICB2YWwgbnRoIDogKCdhLCAnYikgdCAtPiBpbnQgLT4gKCdhICogJ2IpIG9wdGlvblxuICB2YWwgbnRoX2V4biA6ICgnYSwgJ2IpIHQgLT4gaW50IC0+ICdhICogJ2JcbiAgdmFsIHJhbmsgOiAoJ2EsIF8pIHQgLT4gJ2EgLT4gaW50IG9wdGlvblxuICB2YWwgdG9fdHJlZSA6ICgnYSwgJ2IpIHQgLT4gKCdhLCAnYikgdHJlZVxuXG4gIHZhbCB0b19zZXF1ZW5jZVxuICAgIDogID9vcmRlcjpbIGBJbmNyZWFzaW5nX2tleSB8IGBEZWNyZWFzaW5nX2tleSBdXG4gICAgLT4gP2tleXNfZ3JlYXRlcl9vcl9lcXVhbF90bzonYVxuICAgIC0+ID9rZXlzX2xlc3Nfb3JfZXF1YWxfdG86J2FcbiAgICAtPiAoJ2EsICdiKSB0XG4gICAgLT4gKCdhICogJ2IpIFNlcXVlbmNlLnRcblxuICB2YWwgYmluYXJ5X3NlYXJjaFxuICAgIDogICgnaywgJ3YpIHRcbiAgICAtPiBjb21wYXJlOihrZXk6J2sgLT4gZGF0YTondiAtPiAna2V5IC0+IGludClcbiAgICAtPiBCaW5hcnlfc2VhcmNoYWJsZS5XaGljaF90YXJnZXRfYnlfa2V5LnRcbiAgICAtPiAna2V5XG4gICAgLT4gKCdrICogJ3YpIG9wdGlvblxuXG4gIHZhbCBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZFxuICAgIDogICgnaywgJ3YpIHRcbiAgICAtPiBzZWdtZW50X29mOihrZXk6J2sgLT4gZGF0YTondiAtPiBbIGBMZWZ0IHwgYFJpZ2h0IF0pXG4gICAgLT4gQmluYXJ5X3NlYXJjaGFibGUuV2hpY2hfdGFyZ2V0X2J5X3NlZ21lbnQudFxuICAgIC0+ICgnayAqICd2KSBvcHRpb25cblxuICB2YWwgYmluYXJ5X3NlYXJjaF9zdWJyYW5nZVxuICAgIDogICgnaywgJ3YpIHRcbiAgICAtPiBjb21wYXJlOihrZXk6J2sgLT4gZGF0YTondiAtPiAnYm91bmQgLT4gaW50KVxuICAgIC0+IGxvd2VyX2JvdW5kOidib3VuZCBNYXliZV9ib3VuZC50XG4gICAgLT4gdXBwZXJfYm91bmQ6J2JvdW5kIE1heWJlX2JvdW5kLnRcbiAgICAtPiAoJ2ssICd2KSB0XG5lbmRcblxubW9kdWxlIHR5cGUgQWNjZXNzb3JzMyA9IHNpZ1xuICB0eXBlICgnYSwgJ2IsICdjbXApIHRcbiAgdHlwZSAoJ2EsICdiLCAnY21wKSB0cmVlXG5cbiAgdmFsIGludmFyaWFudHMgOiAoXywgXywgXykgdCAtPiBib29sXG4gIHZhbCBpc19lbXB0eSA6IChfLCBfLCBfKSB0IC0+IGJvb2xcbiAgdmFsIGxlbmd0aCA6IChfLCBfLCBfKSB0IC0+IGludFxuICB2YWwgYWRkIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiBrZXk6J2EgLT4gZGF0YTonYiAtPiAoJ2EsICdiLCAnY21wKSB0IE9yX2R1cGxpY2F0ZS50XG4gIHZhbCBhZGRfZXhuIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiBrZXk6J2EgLT4gZGF0YTonYiAtPiAoJ2EsICdiLCAnY21wKSB0XG4gIHZhbCBzZXQgOiAoJ2EsICdiLCAnY21wKSB0IC0+IGtleTonYSAtPiBkYXRhOidiIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgdmFsIGFkZF9tdWx0aSA6ICgnYSwgJ2IgbGlzdCwgJ2NtcCkgdCAtPiBrZXk6J2EgLT4gZGF0YTonYiAtPiAoJ2EsICdiIGxpc3QsICdjbXApIHRcbiAgdmFsIHJlbW92ZV9tdWx0aSA6ICgnYSwgJ2IgbGlzdCwgJ2NtcCkgdCAtPiAnYSAtPiAoJ2EsICdiIGxpc3QsICdjbXApIHRcbiAgdmFsIGZpbmRfbXVsdGkgOiAoJ2EsICdiIGxpc3QsICdjbXApIHQgLT4gJ2EgLT4gJ2IgbGlzdFxuICB2YWwgY2hhbmdlIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiAnYSAtPiBmOignYiBvcHRpb24gLT4gJ2Igb3B0aW9uKSAtPiAoJ2EsICdiLCAnY21wKSB0XG4gIHZhbCB1cGRhdGUgOiAoJ2EsICdiLCAnY21wKSB0IC0+ICdhIC0+IGY6KCdiIG9wdGlvbiAtPiAnYikgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICB2YWwgZmluZCA6ICgnYSwgJ2IsICdjbXApIHQgLT4gJ2EgLT4gJ2Igb3B0aW9uXG4gIHZhbCBmaW5kX2V4biA6ICgnYSwgJ2IsICdjbXApIHQgLT4gJ2EgLT4gJ2JcbiAgdmFsIHJlbW92ZSA6ICgnYSwgJ2IsICdjbXApIHQgLT4gJ2EgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICB2YWwgbWVtIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiAnYSAtPiBib29sXG4gIHZhbCBpdGVyX2tleXMgOiAoJ2EsIF8sICdjbXApIHQgLT4gZjooJ2EgLT4gdW5pdCkgLT4gdW5pdFxuICB2YWwgaXRlciA6IChfLCAnYiwgJ2NtcCkgdCAtPiBmOignYiAtPiB1bml0KSAtPiB1bml0XG4gIHZhbCBpdGVyaSA6ICgnYSwgJ2IsICdjbXApIHQgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gdW5pdCkgLT4gdW5pdFxuXG4gIHZhbCBpdGVyaV91bnRpbFxuICAgIDogICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiBDb250aW51ZV9vcl9zdG9wLnQpXG4gICAgLT4gRmluaXNoZWRfb3JfdW5maW5pc2hlZC50XG5cbiAgdmFsIGl0ZXIyXG4gICAgOiAgKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+ICgnYSwgJ2MsICdjbXApIHRcbiAgICAtPiBmOihrZXk6J2EgLT4gZGF0YTooJ2IsICdjKSBNZXJnZV9lbGVtZW50LnQgLT4gdW5pdClcbiAgICAtPiB1bml0XG5cbiAgdmFsIG1hcCA6ICgnYSwgJ2IsICdjbXApIHQgLT4gZjooJ2IgLT4gJ2MpIC0+ICgnYSwgJ2MsICdjbXApIHRcbiAgdmFsIG1hcGkgOiAoJ2EsICdiLCAnY21wKSB0IC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+ICdjKSAtPiAoJ2EsICdjLCAnY21wKSB0XG4gIHZhbCBmb2xkIDogKCdhLCAnYiwgXykgdCAtPiBpbml0OidjIC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+ICdjIC0+ICdjKSAtPiAnY1xuXG4gIHZhbCBmb2xkX3VudGlsXG4gICAgOiAgKCdrLCAndiwgXykgdFxuICAgIC0+IGluaXQ6J2FcbiAgICAtPiBmOihrZXk6J2sgLT4gZGF0YTondiAtPiAnYSAtPiAoJ2EsICdmaW5hbCkgQ29udGFpbmVyLkNvbnRpbnVlX29yX3N0b3AudClcbiAgICAtPiBmaW5pc2g6KCdhIC0+ICdmaW5hbClcbiAgICAtPiAnZmluYWxcblxuICB2YWwgZm9sZF9yaWdodCA6ICgnYSwgJ2IsIF8pIHQgLT4gaW5pdDonYyAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiAnYyAtPiAnYykgLT4gJ2NcblxuICB2YWwgZm9sZDJcbiAgICA6ICAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnYywgJ2NtcCkgdFxuICAgIC0+IGluaXQ6J2RcbiAgICAtPiBmOihrZXk6J2EgLT4gZGF0YTooJ2IsICdjKSBNZXJnZV9lbGVtZW50LnQgLT4gJ2QgLT4gJ2QpXG4gICAgLT4gJ2RcblxuICB2YWwgZmlsdGVyX2tleXMgOiAoJ2EsICdiLCAnY21wKSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgdmFsIGZpbHRlciA6ICgnYSwgJ2IsICdjbXApIHQgLT4gZjooJ2IgLT4gYm9vbCkgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICB2YWwgZmlsdGVyaSA6ICgnYSwgJ2IsICdjbXApIHQgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gYm9vbCkgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICB2YWwgZmlsdGVyX21hcCA6ICgnYSwgJ2IsICdjbXApIHQgLT4gZjooJ2IgLT4gJ2Mgb3B0aW9uKSAtPiAoJ2EsICdjLCAnY21wKSB0XG5cbiAgdmFsIGZpbHRlcl9tYXBpXG4gICAgOiAgKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+ICdjIG9wdGlvbilcbiAgICAtPiAoJ2EsICdjLCAnY21wKSB0XG5cbiAgdmFsIHBhcnRpdGlvbl9tYXBpXG4gICAgOiAgKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+ICgnYywgJ2QpIEVpdGhlci50KVxuICAgIC0+ICgnYSwgJ2MsICdjbXApIHQgKiAoJ2EsICdkLCAnY21wKSB0XG5cbiAgdmFsIHBhcnRpdGlvbl9tYXBcbiAgICA6ICAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gZjooJ2IgLT4gKCdjLCAnZCkgRWl0aGVyLnQpXG4gICAgLT4gKCdhLCAnYywgJ2NtcCkgdCAqICgnYSwgJ2QsICdjbXApIHRcblxuICB2YWwgcGFydGl0aW9uaV90ZlxuICAgIDogICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiBib29sKVxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHQgKiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgdmFsIHBhcnRpdGlvbl90ZlxuICAgIDogICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiBmOignYiAtPiBib29sKVxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHQgKiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgdmFsIGNvbWJpbmVfZXJyb3JzIDogKCdhLCAnYiBPcl9lcnJvci50LCAnY21wKSB0IC0+ICgnYSwgJ2IsICdjbXApIHQgT3JfZXJyb3IudFxuICB2YWwgY29tcGFyZV9kaXJlY3QgOiAoJ2IgLT4gJ2IgLT4gaW50KSAtPiAoJ2EsICdiLCAnY21wKSB0IC0+ICgnYSwgJ2IsICdjbXApIHQgLT4gaW50XG4gIHZhbCBlcXVhbCA6ICgnYiAtPiAnYiAtPiBib29sKSAtPiAoJ2EsICdiLCAnY21wKSB0IC0+ICgnYSwgJ2IsICdjbXApIHQgLT4gYm9vbFxuICB2YWwga2V5cyA6ICgnYSwgXywgXykgdCAtPiAnYSBsaXN0XG4gIHZhbCBkYXRhIDogKF8sICdiLCBfKSB0IC0+ICdiIGxpc3RcblxuICB2YWwgdG9fYWxpc3RcbiAgICA6ICA/a2V5X29yZGVyOlsgYEluY3JlYXNpbmcgfCBgRGVjcmVhc2luZyBdXG4gICAgLT4gKCdhLCAnYiwgXykgdFxuICAgIC0+ICgnYSAqICdiKSBsaXN0XG5cbiAgdmFsIG1lcmdlXG4gICAgOiAgKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+ICgnYSwgJ2MsICdjbXApIHRcbiAgICAtPiBmOihrZXk6J2EgLT4gKCdiLCAnYykgTWVyZ2VfZWxlbWVudC50IC0+ICdkIG9wdGlvbilcbiAgICAtPiAoJ2EsICdkLCAnY21wKSB0XG5cbiAgdmFsIG1lcmdlX3NrZXdlZFxuICAgIDogICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gY29tYmluZTooa2V5OidrIC0+ICd2IC0+ICd2IC0+ICd2KVxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcblxuICB2YWwgc3ltbWV0cmljX2RpZmZcbiAgICA6ICAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IGRhdGFfZXF1YWw6KCdiIC0+ICdiIC0+IGJvb2wpXG4gICAgLT4gKCdhLCAnYikgU3ltbWV0cmljX2RpZmZfZWxlbWVudC50IFNlcXVlbmNlLnRcblxuICB2YWwgZm9sZF9zeW1tZXRyaWNfZGlmZlxuICAgIDogICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gZGF0YV9lcXVhbDooJ2IgLT4gJ2IgLT4gYm9vbClcbiAgICAtPiBpbml0OidjXG4gICAgLT4gZjooJ2MgLT4gKCdhLCAnYikgU3ltbWV0cmljX2RpZmZfZWxlbWVudC50IC0+ICdjKVxuICAgIC0+ICdjXG5cbiAgdmFsIG1pbl9lbHQgOiAoJ2EsICdiLCAnY21wKSB0IC0+ICgnYSAqICdiKSBvcHRpb25cbiAgdmFsIG1pbl9lbHRfZXhuIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiAnYSAqICdiXG4gIHZhbCBtYXhfZWx0IDogKCdhLCAnYiwgJ2NtcCkgdCAtPiAoJ2EgKiAnYikgb3B0aW9uXG4gIHZhbCBtYXhfZWx0X2V4biA6ICgnYSwgJ2IsICdjbXApIHQgLT4gJ2EgKiAnYlxuICB2YWwgZm9yX2FsbCA6IChfLCAnYiwgXykgdCAtPiBmOignYiAtPiBib29sKSAtPiBib29sXG4gIHZhbCBmb3JfYWxsaSA6ICgnYSwgJ2IsIF8pIHQgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZXhpc3RzIDogKF8sICdiLCBfKSB0IC0+IGY6KCdiIC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGV4aXN0c2kgOiAoJ2EsICdiLCBfKSB0IC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGNvdW50IDogKF8sICdiLCBfKSB0IC0+IGY6KCdiIC0+IGJvb2wpIC0+IGludFxuICB2YWwgY291bnRpIDogKCdhLCAnYiwgXykgdCAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiBib29sKSAtPiBpbnRcblxuICB2YWwgc3BsaXRcbiAgICA6ICAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gJ2tcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0ICogKCdrICogJ3YpIG9wdGlvbiAqICgnaywgJ3YsICdjbXApIHRcblxuICB2YWwgYXBwZW5kXG4gICAgOiAgbG93ZXJfcGFydDooJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gdXBwZXJfcGFydDooJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gWyBgT2sgb2YgKCdrLCAndiwgJ2NtcCkgdCB8IGBPdmVybGFwcGluZ19rZXlfcmFuZ2VzIF1cblxuICB2YWwgc3VicmFuZ2VcbiAgICA6ICAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gbG93ZXJfYm91bmQ6J2sgTWF5YmVfYm91bmQudFxuICAgIC0+IHVwcGVyX2JvdW5kOidrIE1heWJlX2JvdW5kLnRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgdmFsIGZvbGRfcmFuZ2VfaW5jbHVzaXZlXG4gICAgOiAgKCdhLCAnYiwgXykgdFxuICAgIC0+IG1pbjonYVxuICAgIC0+IG1heDonYVxuICAgIC0+IGluaXQ6J2NcbiAgICAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiAnYyAtPiAnYylcbiAgICAtPiAnY1xuXG4gIHZhbCByYW5nZV90b19hbGlzdCA6ICgnYSwgJ2IsIF8pIHQgLT4gbWluOidhIC0+IG1heDonYSAtPiAoJ2EgKiAnYikgbGlzdFxuXG4gIHZhbCBjbG9zZXN0X2tleVxuICAgIDogICgnYSwgJ2IsIF8pIHRcbiAgICAtPiBbIGBHcmVhdGVyX29yX2VxdWFsX3RvIHwgYEdyZWF0ZXJfdGhhbiB8IGBMZXNzX29yX2VxdWFsX3RvIHwgYExlc3NfdGhhbiBdXG4gICAgLT4gJ2FcbiAgICAtPiAoJ2EgKiAnYikgb3B0aW9uXG5cbiAgdmFsIG50aCA6ICgnYSwgJ2IsIF8pIHQgLT4gaW50IC0+ICgnYSAqICdiKSBvcHRpb25cbiAgdmFsIG50aF9leG4gOiAoJ2EsICdiLCBfKSB0IC0+IGludCAtPiAnYSAqICdiXG4gIHZhbCByYW5rIDogKCdhLCBfLCBfKSB0IC0+ICdhIC0+IGludCBvcHRpb25cbiAgdmFsIHRvX3RyZWUgOiAoJ2EsICdiLCAnY21wKSB0IC0+ICgnYSwgJ2IsICdjbXApIHRyZWVcblxuICB2YWwgdG9fc2VxdWVuY2VcbiAgICA6ICA/b3JkZXI6WyBgSW5jcmVhc2luZ19rZXkgfCBgRGVjcmVhc2luZ19rZXkgXVxuICAgIC0+ID9rZXlzX2dyZWF0ZXJfb3JfZXF1YWxfdG86J2FcbiAgICAtPiA/a2V5c19sZXNzX29yX2VxdWFsX3RvOidhXG4gICAgLT4gKCdhLCAnYiwgXykgdFxuICAgIC0+ICgnYSAqICdiKSBTZXF1ZW5jZS50XG5cbiAgdmFsIGJpbmFyeV9zZWFyY2hcbiAgICA6ICAoJ2ssICd2LCBfKSB0XG4gICAgLT4gY29tcGFyZTooa2V5OidrIC0+IGRhdGE6J3YgLT4gJ2tleSAtPiBpbnQpXG4gICAgLT4gQmluYXJ5X3NlYXJjaGFibGUuV2hpY2hfdGFyZ2V0X2J5X2tleS50XG4gICAgLT4gJ2tleVxuICAgIC0+ICgnayAqICd2KSBvcHRpb25cblxuICB2YWwgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWRcbiAgICA6ICAoJ2ssICd2LCBfKSB0XG4gICAgLT4gc2VnbWVudF9vZjooa2V5OidrIC0+IGRhdGE6J3YgLT4gWyBgTGVmdCB8IGBSaWdodCBdKVxuICAgIC0+IEJpbmFyeV9zZWFyY2hhYmxlLldoaWNoX3RhcmdldF9ieV9zZWdtZW50LnRcbiAgICAtPiAoJ2sgKiAndikgb3B0aW9uXG5cbiAgdmFsIGJpbmFyeV9zZWFyY2hfc3VicmFuZ2VcbiAgICA6ICAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gY29tcGFyZTooa2V5OidrIC0+IGRhdGE6J3YgLT4gJ2JvdW5kIC0+IGludClcbiAgICAtPiBsb3dlcl9ib3VuZDonYm91bmQgTWF5YmVfYm91bmQudFxuICAgIC0+IHVwcGVyX2JvdW5kOidib3VuZCBNYXliZV9ib3VuZC50XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIEFjY2Vzc29yczNfd2l0aF9jb21wYXJhdG9yID0gc2lnXG4gIHR5cGUgKCdhLCAnYiwgJ2NtcCkgdFxuICB0eXBlICgnYSwgJ2IsICdjbXApIHRyZWVcblxuICB2YWwgaW52YXJpYW50cyA6IGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnQgLT4gKCdhLCAnYiwgJ2NtcCkgdCAtPiBib29sXG4gIHZhbCBpc19lbXB0eSA6ICgnYSwgJ2IsICdjbXApIHQgLT4gYm9vbFxuICB2YWwgbGVuZ3RoIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiBpbnRcblxuICB2YWwgYWRkXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiBrZXk6J2FcbiAgICAtPiBkYXRhOidiXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdCBPcl9kdXBsaWNhdGUudFxuXG4gIHZhbCBhZGRfZXhuXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiBrZXk6J2FcbiAgICAtPiBkYXRhOidiXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gIHZhbCBzZXRcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IGtleTonYVxuICAgIC0+IGRhdGE6J2JcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgdmFsIGFkZF9tdWx0aVxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiIGxpc3QsICdjbXApIHRcbiAgICAtPiBrZXk6J2FcbiAgICAtPiBkYXRhOidiXG4gICAgLT4gKCdhLCAnYiBsaXN0LCAnY21wKSB0XG5cbiAgdmFsIHJlbW92ZV9tdWx0aVxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiIGxpc3QsICdjbXApIHRcbiAgICAtPiAnYVxuICAgIC0+ICgnYSwgJ2IgbGlzdCwgJ2NtcCkgdFxuXG4gIHZhbCBmaW5kX211bHRpXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2IgbGlzdCwgJ2NtcCkgdFxuICAgIC0+ICdhXG4gICAgLT4gJ2IgbGlzdFxuXG4gIHZhbCBjaGFuZ2VcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+ICdhXG4gICAgLT4gZjooJ2Igb3B0aW9uIC0+ICdiIG9wdGlvbilcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgdmFsIHVwZGF0ZVxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gJ2FcbiAgICAtPiBmOignYiBvcHRpb24gLT4gJ2IpXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gIHZhbCBmaW5kIDogY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudCAtPiAoJ2EsICdiLCAnY21wKSB0IC0+ICdhIC0+ICdiIG9wdGlvblxuICB2YWwgZmluZF9leG4gOiBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50IC0+ICgnYSwgJ2IsICdjbXApIHQgLT4gJ2EgLT4gJ2JcblxuICB2YWwgcmVtb3ZlXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiAnYVxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcblxuICB2YWwgbWVtIDogY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudCAtPiAoJ2EsICdiLCAnY21wKSB0IC0+ICdhIC0+IGJvb2xcbiAgdmFsIGl0ZXJfa2V5cyA6ICgnYSwgXywgJ2NtcCkgdCAtPiBmOignYSAtPiB1bml0KSAtPiB1bml0XG4gIHZhbCBpdGVyIDogKF8sICdiLCAnY21wKSB0IC0+IGY6KCdiIC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIGl0ZXJpIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiB1bml0KSAtPiB1bml0XG5cbiAgdmFsIGl0ZXJpX3VudGlsXG4gICAgOiAgKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+IENvbnRpbnVlX29yX3N0b3AudClcbiAgICAtPiBGaW5pc2hlZF9vcl91bmZpbmlzaGVkLnRcblxuICB2YWwgaXRlcjJcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+ICgnYSwgJ2MsICdjbXApIHRcbiAgICAtPiBmOihrZXk6J2EgLT4gZGF0YTooJ2IsICdjKSBNZXJnZV9lbGVtZW50LnQgLT4gdW5pdClcbiAgICAtPiB1bml0XG5cbiAgdmFsIG1hcCA6ICgnYSwgJ2IsICdjbXApIHQgLT4gZjooJ2IgLT4gJ2MpIC0+ICgnYSwgJ2MsICdjbXApIHRcbiAgdmFsIG1hcGkgOiAoJ2EsICdiLCAnY21wKSB0IC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+ICdjKSAtPiAoJ2EsICdjLCAnY21wKSB0XG4gIHZhbCBmb2xkIDogKCdhLCAnYiwgXykgdCAtPiBpbml0OidjIC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+ICdjIC0+ICdjKSAtPiAnY1xuXG4gIHZhbCBmb2xkX3VudGlsXG4gICAgOiAgKCdrLCAndiwgXykgdFxuICAgIC0+IGluaXQ6J2FcbiAgICAtPiBmOihrZXk6J2sgLT4gZGF0YTondiAtPiAnYSAtPiAoJ2EsICdmaW5hbCkgQ29udGFpbmVyLkNvbnRpbnVlX29yX3N0b3AudClcbiAgICAtPiBmaW5pc2g6KCdhIC0+ICdmaW5hbClcbiAgICAtPiAnZmluYWxcblxuICB2YWwgZm9sZF9yaWdodCA6ICgnYSwgJ2IsIF8pIHQgLT4gaW5pdDonYyAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiAnYyAtPiAnYykgLT4gJ2NcblxuICB2YWwgZm9sZDJcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+ICgnYSwgJ2MsICdjbXApIHRcbiAgICAtPiBpbml0OidkXG4gICAgLT4gZjooa2V5OidhIC0+IGRhdGE6KCdiLCAnYykgTWVyZ2VfZWxlbWVudC50IC0+ICdkIC0+ICdkKVxuICAgIC0+ICdkXG5cbiAgdmFsIGZpbHRlcl9rZXlzXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiBmOignYSAtPiBib29sKVxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcblxuICB2YWwgZmlsdGVyXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiBmOignYiAtPiBib29sKVxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcblxuICB2YWwgZmlsdGVyaVxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gYm9vbClcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgdmFsIGZpbHRlcl9tYXBcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IGY6KCdiIC0+ICdjIG9wdGlvbilcbiAgICAtPiAoJ2EsICdjLCAnY21wKSB0XG5cbiAgdmFsIGZpbHRlcl9tYXBpXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiAnYyBvcHRpb24pXG4gICAgLT4gKCdhLCAnYywgJ2NtcCkgdFxuXG4gIHZhbCBwYXJ0aXRpb25fbWFwaVxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gKCdjLCAnZCkgRWl0aGVyLnQpXG4gICAgLT4gKCdhLCAnYywgJ2NtcCkgdCAqICgnYSwgJ2QsICdjbXApIHRcblxuICB2YWwgcGFydGl0aW9uX21hcFxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gZjooJ2IgLT4gKCdjLCAnZCkgRWl0aGVyLnQpXG4gICAgLT4gKCdhLCAnYywgJ2NtcCkgdCAqICgnYSwgJ2QsICdjbXApIHRcblxuICB2YWwgcGFydGl0aW9uaV90ZlxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gYm9vbClcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0ICogKCdhLCAnYiwgJ2NtcCkgdFxuXG4gIHZhbCBwYXJ0aXRpb25fdGZcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IGY6KCdiIC0+IGJvb2wpXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdCAqICgnYSwgJ2IsICdjbXApIHRcblxuICB2YWwgY29tYmluZV9lcnJvcnNcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnYiBPcl9lcnJvci50LCAnY21wKSB0XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdCBPcl9lcnJvci50XG5cbiAgdmFsIGNvbXBhcmVfZGlyZWN0XG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYiAtPiAnYiAtPiBpbnQpXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiBpbnRcblxuICB2YWwgZXF1YWxcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdiIC0+ICdiIC0+IGJvb2wpXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiBib29sXG5cbiAgdmFsIGtleXMgOiAoJ2EsIF8sIF8pIHQgLT4gJ2EgbGlzdFxuICB2YWwgZGF0YSA6IChfLCAnYiwgXykgdCAtPiAnYiBsaXN0XG5cbiAgdmFsIHRvX2FsaXN0XG4gICAgOiAgP2tleV9vcmRlcjpbIGBJbmNyZWFzaW5nIHwgYERlY3JlYXNpbmcgXVxuICAgIC0+ICgnYSwgJ2IsIF8pIHRcbiAgICAtPiAoJ2EgKiAnYikgbGlzdFxuXG4gIHZhbCBtZXJnZVxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnYywgJ2NtcCkgdFxuICAgIC0+IGY6KGtleTonYSAtPiAoJ2IsICdjKSBNZXJnZV9lbGVtZW50LnQgLT4gJ2Qgb3B0aW9uKVxuICAgIC0+ICgnYSwgJ2QsICdjbXApIHRcblxuICB2YWwgbWVyZ2Vfc2tld2VkXG4gICAgOiAgY29tcGFyYXRvcjooJ2ssICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gY29tYmluZTooa2V5OidrIC0+ICd2IC0+ICd2IC0+ICd2KVxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcblxuICB2YWwgc3ltbWV0cmljX2RpZmZcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiBkYXRhX2VxdWFsOignYiAtPiAnYiAtPiBib29sKVxuICAgIC0+ICgnYSwgJ2IpIFN5bW1ldHJpY19kaWZmX2VsZW1lbnQudCBTZXF1ZW5jZS50XG5cbiAgdmFsIGZvbGRfc3ltbWV0cmljX2RpZmZcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiBkYXRhX2VxdWFsOignYiAtPiAnYiAtPiBib29sKVxuICAgIC0+IGluaXQ6J2NcbiAgICAtPiBmOignYyAtPiAoJ2EsICdiKSBTeW1tZXRyaWNfZGlmZl9lbGVtZW50LnQgLT4gJ2MpXG4gICAgLT4gJ2NcblxuICB2YWwgbWluX2VsdCA6ICgnYSwgJ2IsICdjbXApIHQgLT4gKCdhICogJ2IpIG9wdGlvblxuICB2YWwgbWluX2VsdF9leG4gOiAoJ2EsICdiLCAnY21wKSB0IC0+ICdhICogJ2JcbiAgdmFsIG1heF9lbHQgOiAoJ2EsICdiLCAnY21wKSB0IC0+ICgnYSAqICdiKSBvcHRpb25cbiAgdmFsIG1heF9lbHRfZXhuIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiAnYSAqICdiXG4gIHZhbCBmb3JfYWxsIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiBmOignYiAtPiBib29sKSAtPiBib29sXG4gIHZhbCBmb3JfYWxsaSA6ICgnYSwgJ2IsICdjbXApIHQgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZXhpc3RzIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiBmOignYiAtPiBib29sKSAtPiBib29sXG4gIHZhbCBleGlzdHNpIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiBib29sKSAtPiBib29sXG4gIHZhbCBjb3VudCA6ICgnYSwgJ2IsICdjbXApIHQgLT4gZjooJ2IgLT4gYm9vbCkgLT4gaW50XG4gIHZhbCBjb3VudGkgOiAoJ2EsICdiLCAnY21wKSB0IC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+IGJvb2wpIC0+IGludFxuXG4gIHZhbCBzcGxpdFxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gJ2FcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0ICogKCdhICogJ2IpIG9wdGlvbiAqICgnYSwgJ2IsICdjbXApIHRcblxuICB2YWwgYXBwZW5kXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+IGxvd2VyX3BhcnQ6KCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IHVwcGVyX3BhcnQ6KCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IFsgYE9rIG9mICgnYSwgJ2IsICdjbXApIHQgfCBgT3ZlcmxhcHBpbmdfa2V5X3JhbmdlcyBdXG5cbiAgdmFsIHN1YnJhbmdlXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiBsb3dlcl9ib3VuZDonYSBNYXliZV9ib3VuZC50XG4gICAgLT4gdXBwZXJfYm91bmQ6J2EgTWF5YmVfYm91bmQudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcblxuICB2YWwgZm9sZF9yYW5nZV9pbmNsdXNpdmVcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IG1pbjonYVxuICAgIC0+IG1heDonYVxuICAgIC0+IGluaXQ6J2NcbiAgICAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiAnYyAtPiAnYylcbiAgICAtPiAnY1xuXG4gIHZhbCByYW5nZV90b19hbGlzdFxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gbWluOidhXG4gICAgLT4gbWF4OidhXG4gICAgLT4gKCdhICogJ2IpIGxpc3RcblxuICB2YWwgY2xvc2VzdF9rZXlcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IFsgYEdyZWF0ZXJfb3JfZXF1YWxfdG8gfCBgR3JlYXRlcl90aGFuIHwgYExlc3Nfb3JfZXF1YWxfdG8gfCBgTGVzc190aGFuIF1cbiAgICAtPiAnYVxuICAgIC0+ICgnYSAqICdiKSBvcHRpb25cblxuICB2YWwgbnRoIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiBpbnQgLT4gKCdhICogJ2IpIG9wdGlvblxuICB2YWwgbnRoX2V4biA6ICgnYSwgJ2IsICdjbXApIHQgLT4gaW50IC0+ICdhICogJ2JcbiAgdmFsIHJhbmsgOiBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50IC0+ICgnYSwgJ2IsICdjbXApIHQgLT4gJ2EgLT4gaW50IG9wdGlvblxuICB2YWwgdG9fdHJlZSA6ICgnYSwgJ2IsICdjbXApIHQgLT4gKCdhLCAnYiwgJ2NtcCkgdHJlZVxuXG4gIHZhbCB0b19zZXF1ZW5jZVxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiA/b3JkZXI6WyBgSW5jcmVhc2luZ19rZXkgfCBgRGVjcmVhc2luZ19rZXkgXVxuICAgIC0+ID9rZXlzX2dyZWF0ZXJfb3JfZXF1YWxfdG86J2FcbiAgICAtPiA/a2V5c19sZXNzX29yX2VxdWFsX3RvOidhXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+ICgnYSAqICdiKSBTZXF1ZW5jZS50XG5cbiAgdmFsIGJpbmFyeV9zZWFyY2hcbiAgICA6ICBjb21wYXJhdG9yOignaywgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IGNvbXBhcmU6KGtleTonayAtPiBkYXRhOid2IC0+ICdrZXkgLT4gaW50KVxuICAgIC0+IEJpbmFyeV9zZWFyY2hhYmxlLldoaWNoX3RhcmdldF9ieV9rZXkudFxuICAgIC0+ICdrZXlcbiAgICAtPiAoJ2sgKiAndikgb3B0aW9uXG5cbiAgdmFsIGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkXG4gICAgOiAgY29tcGFyYXRvcjooJ2ssICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBzZWdtZW50X29mOihrZXk6J2sgLT4gZGF0YTondiAtPiBbIGBMZWZ0IHwgYFJpZ2h0IF0pXG4gICAgLT4gQmluYXJ5X3NlYXJjaGFibGUuV2hpY2hfdGFyZ2V0X2J5X3NlZ21lbnQudFxuICAgIC0+ICgnayAqICd2KSBvcHRpb25cblxuICB2YWwgYmluYXJ5X3NlYXJjaF9zdWJyYW5nZVxuICAgIDogIGNvbXBhcmF0b3I6KCdrLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gY29tcGFyZTooa2V5OidrIC0+IGRhdGE6J3YgLT4gJ2JvdW5kIC0+IGludClcbiAgICAtPiBsb3dlcl9ib3VuZDonYm91bmQgTWF5YmVfYm91bmQudFxuICAgIC0+IHVwcGVyX2JvdW5kOidib3VuZCBNYXliZV9ib3VuZC50XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuZW5kXG5cbigqKiBDb25zaXN0ZW5jeSBjaGVja3MgKHNhbWUgYXMgaW4gW0NvbnRhaW5lcl0pLiAqKVxubW9kdWxlIENoZWNrX2FjY2Vzc29yc1xuICAgIChUIDogVDMpXG4gICAgKFRyZWUgOiBUMylcbiAgICAoS2V5IDogVDEpXG4gICAgKENtcCA6IFQxKVxuICAgIChPcHRpb25zIDogVDMpXG4gICAgKF8gOiBBY2Nlc3NvcnNfZ2VuZXJpY1xuICAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIG9wdGlvbnMgOj0gKCdhLCAnYiwgJ2MpIE9wdGlvbnMudFxuICAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHQgOj0gKCdhLCAnYiwgJ2MpIFQudFxuICAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHRyZWUgOj0gKCdhLCAnYiwgJ2MpIFRyZWUudFxuICAgICB3aXRoIHR5cGUgJ2Ega2V5IDo9ICdhIEtleS50XG4gICAgIHdpdGggdHlwZSAnY21wIGNtcCA6PSAnY21wIENtcC50KSA9XG5zdHJ1Y3QgZW5kXG5cbm1vZHVsZSBDaGVja19hY2Nlc3NvcnMxIChNIDogQWNjZXNzb3JzMSkgPVxuICBDaGVja19hY2Nlc3NvcnNcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IsICdjKSB0ID0gJ2IgTS50XG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYiwgJ2MpIHQgPSAnYiBNLnRyZWVcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gTS5rZXlcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gTS5jb21wYXJhdG9yX3dpdG5lc3NcbiAgICBlbmQpXG4gICAgKFdpdGhvdXRfY29tcGFyYXRvcilcbiAgICAoTSlcblxubW9kdWxlIENoZWNrX2FjY2Vzc29yczIgKE0gOiBBY2Nlc3NvcnMyKSA9XG4gIENoZWNrX2FjY2Vzc29yc1xuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYiwgJ2MpIHQgPSAoJ2EsICdiKSBNLnRcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiLCAnYykgdCA9ICgnYSwgJ2IpIE0udHJlZVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSBNLmNvbXBhcmF0b3Jfd2l0bmVzc1xuICAgIGVuZClcbiAgICAoV2l0aG91dF9jb21wYXJhdG9yKVxuICAgIChNKVxuXG5tb2R1bGUgQ2hlY2tfYWNjZXNzb3JzMyAoTSA6IEFjY2Vzc29yczMpID1cbiAgQ2hlY2tfYWNjZXNzb3JzXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiLCAnYykgdCA9ICgnYSwgJ2IsICdjKSBNLnRcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiLCAnYykgdCA9ICgnYSwgJ2IsICdjKSBNLnRyZWVcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gJ2FcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gJ2FcbiAgICBlbmQpXG4gICAgKFdpdGhvdXRfY29tcGFyYXRvcilcbiAgICAoTSlcblxubW9kdWxlIENoZWNrX2FjY2Vzc29yczNfd2l0aF9jb21wYXJhdG9yIChNIDogQWNjZXNzb3JzM193aXRoX2NvbXBhcmF0b3IpID1cbiAgQ2hlY2tfYWNjZXNzb3JzXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiLCAnYykgdCA9ICgnYSwgJ2IsICdjKSBNLnRcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiLCAnYykgdCA9ICgnYSwgJ2IsICdjKSBNLnRyZWVcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gJ2FcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gJ2FcbiAgICBlbmQpXG4gICAgKFdpdGhfY29tcGFyYXRvcilcbiAgICAoTSlcblxubW9kdWxlIHR5cGUgQ3JlYXRvcnNfZ2VuZXJpYyA9IHNpZ1xuICB0eXBlICgnaywgJ3YsICdjbXApIHRcbiAgdHlwZSAoJ2ssICd2LCAnY21wKSB0cmVlXG4gIHR5cGUgJ2sga2V5XG4gIHR5cGUgKCdhLCAnY21wLCAneikgb3B0aW9uc1xuICB0eXBlICdjbXAgY21wXG5cbiAgdmFsIGVtcHR5IDogKCdrLCAnY21wLCAoJ2ssIF8sICdjbXApIHQpIG9wdGlvbnNcbiAgdmFsIHNpbmdsZXRvbiA6ICgnaywgJ2NtcCwgJ2sga2V5IC0+ICd2IC0+ICgnaywgJ3YsICdjbXApIHQpIG9wdGlvbnNcblxuICB2YWwgbWFwX2tleXNcbiAgICA6ICggJ2syXG4gICAgICAsICdjbXAyXG4gICAgICAsICgnazEsICd2LCAnY21wMSkgdFxuICAgICAgLT4gZjooJ2sxIGtleSAtPiAnazIga2V5KVxuICAgICAgLT4gWyBgT2sgb2YgKCdrMiwgJ3YsICdjbXAyKSB0IHwgYER1cGxpY2F0ZV9rZXkgb2YgJ2syIGtleSBdIClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBtYXBfa2V5c19leG5cbiAgICA6ICggJ2syXG4gICAgICAsICdjbXAyXG4gICAgICAsICgnazEsICd2LCAnY21wMSkgdCAtPiBmOignazEga2V5IC0+ICdrMiBrZXkpIC0+ICgnazIsICd2LCAnY21wMikgdCApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgb2Zfc29ydGVkX2FycmF5XG4gICAgOiAoJ2ssICdjbXAsICgnayBrZXkgKiAndikgYXJyYXkgLT4gKCdrLCAndiwgJ2NtcCkgdCBPcl9lcnJvci50KSBvcHRpb25zXG5cbiAgdmFsIG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWRcbiAgICA6ICgnaywgJ2NtcCwgKCdrIGtleSAqICd2KSBhcnJheSAtPiAoJ2ssICd2LCAnY21wKSB0KSBvcHRpb25zXG5cbiAgdmFsIG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkXG4gICAgOiAoJ2ssICdjbXAsIGxlbjppbnQgLT4gZjooaW50IC0+ICdrIGtleSAqICd2KSAtPiAoJ2ssICd2LCAnY21wKSB0KSBvcHRpb25zXG5cbiAgdmFsIG9mX2FsaXN0XG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrIGtleSAqICd2KSBsaXN0IC0+IFsgYE9rIG9mICgnaywgJ3YsICdjbXApIHQgfCBgRHVwbGljYXRlX2tleSBvZiAnayBrZXkgXSApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgb2ZfYWxpc3Rfb3JfZXJyb3JcbiAgICA6ICgnaywgJ2NtcCwgKCdrIGtleSAqICd2KSBsaXN0IC0+ICgnaywgJ3YsICdjbXApIHQgT3JfZXJyb3IudCkgb3B0aW9uc1xuXG4gIHZhbCBvZl9hbGlzdF9leG4gOiAoJ2ssICdjbXAsICgnayBrZXkgKiAndikgbGlzdCAtPiAoJ2ssICd2LCAnY21wKSB0KSBvcHRpb25zXG4gIHZhbCBvZl9hbGlzdF9tdWx0aSA6ICgnaywgJ2NtcCwgKCdrIGtleSAqICd2KSBsaXN0IC0+ICgnaywgJ3YgbGlzdCwgJ2NtcCkgdCkgb3B0aW9uc1xuXG4gIHZhbCBvZl9hbGlzdF9mb2xkXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrIGtleSAqICd2MSkgbGlzdCAtPiBpbml0Oid2MiAtPiBmOigndjIgLT4gJ3YxIC0+ICd2MikgLT4gKCdrLCAndjIsICdjbXApIHQgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIG9mX2FsaXN0X3JlZHVjZVxuICAgIDogKCdrLCAnY21wLCAoJ2sga2V5ICogJ3YpIGxpc3QgLT4gZjooJ3YgLT4gJ3YgLT4gJ3YpIC0+ICgnaywgJ3YsICdjbXApIHQpIG9wdGlvbnNcblxuICB2YWwgb2ZfaW5jcmVhc2luZ19zZXF1ZW5jZVxuICAgIDogKCdrLCAnY21wLCAoJ2sga2V5ICogJ3YpIFNlcXVlbmNlLnQgLT4gKCdrLCAndiwgJ2NtcCkgdCBPcl9lcnJvci50KSBvcHRpb25zXG5cbiAgdmFsIG9mX3NlcXVlbmNlXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrIGtleSAqICd2KSBTZXF1ZW5jZS50IC0+IFsgYE9rIG9mICgnaywgJ3YsICdjbXApIHQgfCBgRHVwbGljYXRlX2tleSBvZiAnayBrZXkgXVxuICAgICAgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIG9mX3NlcXVlbmNlX29yX2Vycm9yXG4gICAgOiAoJ2ssICdjbXAsICgnayBrZXkgKiAndikgU2VxdWVuY2UudCAtPiAoJ2ssICd2LCAnY21wKSB0IE9yX2Vycm9yLnQpIG9wdGlvbnNcblxuICB2YWwgb2Zfc2VxdWVuY2VfZXhuIDogKCdrLCAnY21wLCAoJ2sga2V5ICogJ3YpIFNlcXVlbmNlLnQgLT4gKCdrLCAndiwgJ2NtcCkgdCkgb3B0aW9uc1xuXG4gIHZhbCBvZl9zZXF1ZW5jZV9tdWx0aVxuICAgIDogKCdrLCAnY21wLCAoJ2sga2V5ICogJ3YpIFNlcXVlbmNlLnQgLT4gKCdrLCAndiBsaXN0LCAnY21wKSB0KSBvcHRpb25zXG5cbiAgdmFsIG9mX3NlcXVlbmNlX2ZvbGRcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2sga2V5ICogJ3YxKSBTZXF1ZW5jZS50XG4gICAgICAtPiBpbml0Oid2MlxuICAgICAgLT4gZjooJ3YyIC0+ICd2MSAtPiAndjIpXG4gICAgICAtPiAoJ2ssICd2MiwgJ2NtcCkgdCApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgb2Zfc2VxdWVuY2VfcmVkdWNlXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrIGtleSAqICd2KSBTZXF1ZW5jZS50IC0+IGY6KCd2IC0+ICd2IC0+ICd2KSAtPiAoJ2ssICd2LCAnY21wKSB0IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBvZl9pdGVyaVxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsIGl0ZXJpOihmOihrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gdW5pdCkgLT4gdW5pdClcbiAgICAgIC0+IFsgYE9rIG9mICgnaywgJ3YsICdjbXApIHQgfCBgRHVwbGljYXRlX2tleSBvZiAnayBrZXkgXSApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgb2ZfaXRlcmlfZXhuXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgaXRlcmk6KGY6KGtleTonayBrZXkgLT4gZGF0YTondiAtPiB1bml0KSAtPiB1bml0KSAtPiAoJ2ssICd2LCAnY21wKSB0IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBvZl90cmVlIDogKCdrLCAnY21wLCAoJ2sga2V5LCAndiwgJ2NtcCkgdHJlZSAtPiAoJ2ssICd2LCAnY21wKSB0KSBvcHRpb25zXG5lbmRcblxubW9kdWxlIHR5cGUgQ3JlYXRvcnMxID0gc2lnXG4gIHR5cGUgJ2EgdFxuICB0eXBlICdhIHRyZWVcbiAgdHlwZSBrZXlcbiAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3NcblxuICB2YWwgZW1wdHkgOiBfIHRcbiAgdmFsIHNpbmdsZXRvbiA6IGtleSAtPiAnYSAtPiAnYSB0XG4gIHZhbCBtYXBfa2V5cyA6ICd2IHQgLT4gZjooa2V5IC0+IGtleSkgLT4gWyBgT2sgb2YgJ3YgdCB8IGBEdXBsaWNhdGVfa2V5IG9mIGtleSBdXG4gIHZhbCBtYXBfa2V5c19leG4gOiAndiB0IC0+IGY6KGtleSAtPiBrZXkpIC0+ICd2IHRcbiAgdmFsIG9mX2FsaXN0IDogKGtleSAqICdhKSBsaXN0IC0+IFsgYE9rIG9mICdhIHQgfCBgRHVwbGljYXRlX2tleSBvZiBrZXkgXVxuICB2YWwgb2ZfYWxpc3Rfb3JfZXJyb3IgOiAoa2V5ICogJ2EpIGxpc3QgLT4gJ2EgdCBPcl9lcnJvci50XG4gIHZhbCBvZl9hbGlzdF9leG4gOiAoa2V5ICogJ2EpIGxpc3QgLT4gJ2EgdFxuICB2YWwgb2ZfYWxpc3RfbXVsdGkgOiAoa2V5ICogJ2EpIGxpc3QgLT4gJ2EgbGlzdCB0XG4gIHZhbCBvZl9hbGlzdF9mb2xkIDogKGtleSAqICdhKSBsaXN0IC0+IGluaXQ6J2IgLT4gZjooJ2IgLT4gJ2EgLT4gJ2IpIC0+ICdiIHRcbiAgdmFsIG9mX2FsaXN0X3JlZHVjZSA6IChrZXkgKiAnYSkgbGlzdCAtPiBmOignYSAtPiAnYSAtPiAnYSkgLT4gJ2EgdFxuICB2YWwgb2Zfc29ydGVkX2FycmF5IDogKGtleSAqICdhKSBhcnJheSAtPiAnYSB0IE9yX2Vycm9yLnRcbiAgdmFsIG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgOiAoa2V5ICogJ2EpIGFycmF5IC0+ICdhIHRcbiAgdmFsIG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIDogbGVuOmludCAtPiBmOihpbnQgLT4ga2V5ICogJ2EpIC0+ICdhIHRcbiAgdmFsIG9mX2luY3JlYXNpbmdfc2VxdWVuY2UgOiAoa2V5ICogJ2EpIFNlcXVlbmNlLnQgLT4gJ2EgdCBPcl9lcnJvci50XG4gIHZhbCBvZl9zZXF1ZW5jZSA6IChrZXkgKiAnYSkgU2VxdWVuY2UudCAtPiBbIGBPayBvZiAnYSB0IHwgYER1cGxpY2F0ZV9rZXkgb2Yga2V5IF1cbiAgdmFsIG9mX3NlcXVlbmNlX29yX2Vycm9yIDogKGtleSAqICdhKSBTZXF1ZW5jZS50IC0+ICdhIHQgT3JfZXJyb3IudFxuICB2YWwgb2Zfc2VxdWVuY2VfZXhuIDogKGtleSAqICdhKSBTZXF1ZW5jZS50IC0+ICdhIHRcbiAgdmFsIG9mX3NlcXVlbmNlX211bHRpIDogKGtleSAqICdhKSBTZXF1ZW5jZS50IC0+ICdhIGxpc3QgdFxuICB2YWwgb2Zfc2VxdWVuY2VfZm9sZCA6IChrZXkgKiAnYSkgU2VxdWVuY2UudCAtPiBpbml0OidiIC0+IGY6KCdiIC0+ICdhIC0+ICdiKSAtPiAnYiB0XG4gIHZhbCBvZl9zZXF1ZW5jZV9yZWR1Y2UgOiAoa2V5ICogJ2EpIFNlcXVlbmNlLnQgLT4gZjooJ2EgLT4gJ2EgLT4gJ2EpIC0+ICdhIHRcblxuICB2YWwgb2ZfaXRlcmlcbiAgICA6ICBpdGVyaTooZjooa2V5OmtleSAtPiBkYXRhOid2IC0+IHVuaXQpIC0+IHVuaXQpXG4gICAgLT4gWyBgT2sgb2YgJ3YgdCB8IGBEdXBsaWNhdGVfa2V5IG9mIGtleSBdXG5cbiAgdmFsIG9mX2l0ZXJpX2V4biA6IGl0ZXJpOihmOihrZXk6a2V5IC0+IGRhdGE6J3YgLT4gdW5pdCkgLT4gdW5pdCkgLT4gJ3YgdFxuICB2YWwgb2ZfdHJlZSA6ICdhIHRyZWUgLT4gJ2EgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIENyZWF0b3JzMiA9IHNpZ1xuICB0eXBlICgnYSwgJ2IpIHRcbiAgdHlwZSAoJ2EsICdiKSB0cmVlXG4gIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgdmFsIGVtcHR5IDogKF8sIF8pIHRcbiAgdmFsIHNpbmdsZXRvbiA6ICdhIC0+ICdiIC0+ICgnYSwgJ2IpIHRcblxuICB2YWwgbWFwX2tleXNcbiAgICA6ICAoJ2sxLCAndikgdFxuICAgIC0+IGY6KCdrMSAtPiAnazIpXG4gICAgLT4gWyBgT2sgb2YgKCdrMiwgJ3YpIHQgfCBgRHVwbGljYXRlX2tleSBvZiAnazIgXVxuXG4gIHZhbCBtYXBfa2V5c19leG4gOiAoJ2sxLCAndikgdCAtPiBmOignazEgLT4gJ2syKSAtPiAoJ2syLCAndikgdFxuICB2YWwgb2ZfYWxpc3QgOiAoJ2EgKiAnYikgbGlzdCAtPiBbIGBPayBvZiAoJ2EsICdiKSB0IHwgYER1cGxpY2F0ZV9rZXkgb2YgJ2EgXVxuICB2YWwgb2ZfYWxpc3Rfb3JfZXJyb3IgOiAoJ2EgKiAnYikgbGlzdCAtPiAoJ2EsICdiKSB0IE9yX2Vycm9yLnRcbiAgdmFsIG9mX2FsaXN0X2V4biA6ICgnYSAqICdiKSBsaXN0IC0+ICgnYSwgJ2IpIHRcbiAgdmFsIG9mX2FsaXN0X211bHRpIDogKCdhICogJ2IpIGxpc3QgLT4gKCdhLCAnYiBsaXN0KSB0XG4gIHZhbCBvZl9hbGlzdF9mb2xkIDogKCdhICogJ2IpIGxpc3QgLT4gaW5pdDonYyAtPiBmOignYyAtPiAnYiAtPiAnYykgLT4gKCdhLCAnYykgdFxuICB2YWwgb2ZfYWxpc3RfcmVkdWNlIDogKCdhICogJ2IpIGxpc3QgLT4gZjooJ2IgLT4gJ2IgLT4gJ2IpIC0+ICgnYSwgJ2IpIHRcbiAgdmFsIG9mX3NvcnRlZF9hcnJheSA6ICgnYSAqICdiKSBhcnJheSAtPiAoJ2EsICdiKSB0IE9yX2Vycm9yLnRcbiAgdmFsIG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgOiAoJ2EgKiAnYikgYXJyYXkgLT4gKCdhLCAnYikgdFxuICB2YWwgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgOiBsZW46aW50IC0+IGY6KGludCAtPiAnYSAqICdiKSAtPiAoJ2EsICdiKSB0XG4gIHZhbCBvZl9pbmNyZWFzaW5nX3NlcXVlbmNlIDogKCdhICogJ2IpIFNlcXVlbmNlLnQgLT4gKCdhLCAnYikgdCBPcl9lcnJvci50XG4gIHZhbCBvZl9zZXF1ZW5jZSA6ICgnYSAqICdiKSBTZXF1ZW5jZS50IC0+IFsgYE9rIG9mICgnYSwgJ2IpIHQgfCBgRHVwbGljYXRlX2tleSBvZiAnYSBdXG4gIHZhbCBvZl9zZXF1ZW5jZV9vcl9lcnJvciA6ICgnYSAqICdiKSBTZXF1ZW5jZS50IC0+ICgnYSwgJ2IpIHQgT3JfZXJyb3IudFxuICB2YWwgb2Zfc2VxdWVuY2VfZXhuIDogKCdhICogJ2IpIFNlcXVlbmNlLnQgLT4gKCdhLCAnYikgdFxuICB2YWwgb2Zfc2VxdWVuY2VfbXVsdGkgOiAoJ2EgKiAnYikgU2VxdWVuY2UudCAtPiAoJ2EsICdiIGxpc3QpIHRcblxuICB2YWwgb2Zfc2VxdWVuY2VfZm9sZFxuICAgIDogICgnYSAqICdiKSBTZXF1ZW5jZS50XG4gICAgLT4gaW5pdDonY1xuICAgIC0+IGY6KCdjIC0+ICdiIC0+ICdjKVxuICAgIC0+ICgnYSwgJ2MpIHRcblxuICB2YWwgb2Zfc2VxdWVuY2VfcmVkdWNlIDogKCdhICogJ2IpIFNlcXVlbmNlLnQgLT4gZjooJ2IgLT4gJ2IgLT4gJ2IpIC0+ICgnYSwgJ2IpIHRcblxuICB2YWwgb2ZfaXRlcmlcbiAgICA6ICBpdGVyaTooZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gdW5pdCkgLT4gdW5pdClcbiAgICAtPiBbIGBPayBvZiAoJ2EsICdiKSB0IHwgYER1cGxpY2F0ZV9rZXkgb2YgJ2EgXVxuXG4gIHZhbCBvZl9pdGVyaV9leG4gOiBpdGVyaTooZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gdW5pdCkgLT4gdW5pdCkgLT4gKCdhLCAnYikgdFxuICB2YWwgb2ZfdHJlZSA6ICgnYSwgJ2IpIHRyZWUgLT4gKCdhLCAnYikgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIENyZWF0b3JzM193aXRoX2NvbXBhcmF0b3IgPSBzaWdcbiAgdHlwZSAoJ2EsICdiLCAnY21wKSB0XG4gIHR5cGUgKCdhLCAnYiwgJ2NtcCkgdHJlZVxuXG4gIHZhbCBlbXB0eSA6IGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnQgLT4gKCdhLCBfLCAnY21wKSB0XG4gIHZhbCBzaW5nbGV0b24gOiBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50IC0+ICdhIC0+ICdiIC0+ICgnYSwgJ2IsICdjbXApIHRcblxuICB2YWwgbWFwX2tleXNcbiAgICA6ICBjb21wYXJhdG9yOignazIsICdjbXAyKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2sxLCAndiwgJ2NtcDEpIHRcbiAgICAtPiBmOignazEgLT4gJ2syKVxuICAgIC0+IFsgYE9rIG9mICgnazIsICd2LCAnY21wMikgdCB8IGBEdXBsaWNhdGVfa2V5IG9mICdrMiBdXG5cbiAgdmFsIG1hcF9rZXlzX2V4blxuICAgIDogIGNvbXBhcmF0b3I6KCdrMiwgJ2NtcDIpIENvbXBhcmF0b3IudFxuICAgIC0+ICgnazEsICd2LCAnY21wMSkgdFxuICAgIC0+IGY6KCdrMSAtPiAnazIpXG4gICAgLT4gKCdrMiwgJ3YsICdjbXAyKSB0XG5cbiAgdmFsIG9mX2FsaXN0XG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSAqICdiKSBsaXN0XG4gICAgLT4gWyBgT2sgb2YgKCdhLCAnYiwgJ2NtcCkgdCB8IGBEdXBsaWNhdGVfa2V5IG9mICdhIF1cblxuICB2YWwgb2ZfYWxpc3Rfb3JfZXJyb3JcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhICogJ2IpIGxpc3RcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0IE9yX2Vycm9yLnRcblxuICB2YWwgb2ZfYWxpc3RfZXhuXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSAqICdiKSBsaXN0XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gIHZhbCBvZl9hbGlzdF9tdWx0aVxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EgKiAnYikgbGlzdFxuICAgIC0+ICgnYSwgJ2IgbGlzdCwgJ2NtcCkgdFxuXG4gIHZhbCBvZl9hbGlzdF9mb2xkXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSAqICdiKSBsaXN0XG4gICAgLT4gaW5pdDonY1xuICAgIC0+IGY6KCdjIC0+ICdiIC0+ICdjKVxuICAgIC0+ICgnYSwgJ2MsICdjbXApIHRcblxuICB2YWwgb2ZfYWxpc3RfcmVkdWNlXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSAqICdiKSBsaXN0XG4gICAgLT4gZjooJ2IgLT4gJ2IgLT4gJ2IpXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gIHZhbCBvZl9zb3J0ZWRfYXJyYXlcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhICogJ2IpIGFycmF5XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdCBPcl9lcnJvci50XG5cbiAgdmFsIG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWRcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhICogJ2IpIGFycmF5XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gIHZhbCBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZFxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiBsZW46aW50XG4gICAgLT4gZjooaW50IC0+ICdhICogJ2IpXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gIHZhbCBvZl9pbmNyZWFzaW5nX3NlcXVlbmNlXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSAqICdiKSBTZXF1ZW5jZS50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdCBPcl9lcnJvci50XG5cbiAgdmFsIG9mX3NlcXVlbmNlXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSAqICdiKSBTZXF1ZW5jZS50XG4gICAgLT4gWyBgT2sgb2YgKCdhLCAnYiwgJ2NtcCkgdCB8IGBEdXBsaWNhdGVfa2V5IG9mICdhIF1cblxuICB2YWwgb2Zfc2VxdWVuY2Vfb3JfZXJyb3JcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhICogJ2IpIFNlcXVlbmNlLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0IE9yX2Vycm9yLnRcblxuICB2YWwgb2Zfc2VxdWVuY2VfZXhuXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSAqICdiKSBTZXF1ZW5jZS50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gIHZhbCBvZl9zZXF1ZW5jZV9tdWx0aVxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EgKiAnYikgU2VxdWVuY2UudFxuICAgIC0+ICgnYSwgJ2IgbGlzdCwgJ2NtcCkgdFxuXG4gIHZhbCBvZl9zZXF1ZW5jZV9mb2xkXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSAqICdiKSBTZXF1ZW5jZS50XG4gICAgLT4gaW5pdDonY1xuICAgIC0+IGY6KCdjIC0+ICdiIC0+ICdjKVxuICAgIC0+ICgnYSwgJ2MsICdjbXApIHRcblxuICB2YWwgb2Zfc2VxdWVuY2VfcmVkdWNlXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSAqICdiKSBTZXF1ZW5jZS50XG4gICAgLT4gZjooJ2IgLT4gJ2IgLT4gJ2IpXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gIHZhbCBvZl9pdGVyaVxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiBpdGVyaTooZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gdW5pdCkgLT4gdW5pdClcbiAgICAtPiBbIGBPayBvZiAoJ2EsICdiLCAnY21wKSB0IHwgYER1cGxpY2F0ZV9rZXkgb2YgJ2EgXVxuXG4gIHZhbCBvZl9pdGVyaV9leG5cbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gaXRlcmk6KGY6KGtleTonYSAtPiBkYXRhOidiIC0+IHVuaXQpIC0+IHVuaXQpXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gIHZhbCBvZl90cmVlXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRyZWVcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5lbmRcblxubW9kdWxlIENoZWNrX2NyZWF0b3JzXG4gICAgKFQgOiBUMylcbiAgICAoVHJlZSA6IFQzKVxuICAgIChLZXkgOiBUMSlcbiAgICAoQ21wIDogVDEpXG4gICAgKE9wdGlvbnMgOiBUMylcbiAgICAoXyA6IENyZWF0b3JzX2dlbmVyaWNcbiAgICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSBvcHRpb25zIDo9ICgnYSwgJ2IsICdjKSBPcHRpb25zLnRcbiAgICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSB0IDo9ICgnYSwgJ2IsICdjKSBULnRcbiAgICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSB0cmVlIDo9ICgnYSwgJ2IsICdjKSBUcmVlLnRcbiAgICAgd2l0aCB0eXBlICdhIGtleSA6PSAnYSBLZXkudFxuICAgICB3aXRoIHR5cGUgJ2EgY21wIDo9ICdhIENtcC50KSA9XG5zdHJ1Y3QgZW5kXG5cbm1vZHVsZSBDaGVja19jcmVhdG9yczEgKE0gOiBDcmVhdG9yczEpID1cbiAgQ2hlY2tfY3JlYXRvcnNcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IsICdjKSB0ID0gJ2IgTS50XG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYiwgJ2MpIHQgPSAnYiBNLnRyZWVcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gTS5rZXlcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gTS5jb21wYXJhdG9yX3dpdG5lc3NcbiAgICBlbmQpXG4gICAgKFdpdGhvdXRfY29tcGFyYXRvcilcbiAgICAoTSlcblxubW9kdWxlIENoZWNrX2NyZWF0b3JzMiAoTSA6IENyZWF0b3JzMikgPVxuICBDaGVja19jcmVhdG9yc1xuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYiwgJ2MpIHQgPSAoJ2EsICdiKSBNLnRcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiLCAnYykgdCA9ICgnYSwgJ2IpIE0udHJlZVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSBNLmNvbXBhcmF0b3Jfd2l0bmVzc1xuICAgIGVuZClcbiAgICAoV2l0aG91dF9jb21wYXJhdG9yKVxuICAgIChNKVxuXG5tb2R1bGUgQ2hlY2tfY3JlYXRvcnMzX3dpdGhfY29tcGFyYXRvciAoTSA6IENyZWF0b3JzM193aXRoX2NvbXBhcmF0b3IpID1cbiAgQ2hlY2tfY3JlYXRvcnNcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IsICdjKSB0ID0gKCdhLCAnYiwgJ2MpIE0udFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IsICdjKSB0ID0gKCdhLCAnYiwgJ2MpIE0udHJlZVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYVxuICAgIGVuZClcbiAgICAoV2l0aF9jb21wYXJhdG9yKVxuICAgIChNKVxuXG5tb2R1bGUgdHlwZSBDcmVhdG9yc19hbmRfYWNjZXNzb3JzX2dlbmVyaWMgPSBzaWdcbiAgaW5jbHVkZSBDcmVhdG9yc19nZW5lcmljXG5cbiAgaW5jbHVkZVxuICAgIEFjY2Vzc29yc19nZW5lcmljXG4gICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSB0IDo9ICgnYSwgJ2IsICdjKSB0XG4gICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSB0cmVlIDo9ICgnYSwgJ2IsICdjKSB0cmVlXG4gICAgd2l0aCB0eXBlICdhIGtleSA6PSAnYSBrZXlcbiAgICB3aXRoIHR5cGUgJ2EgY21wIDo9ICdhIGNtcFxuICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgb3B0aW9ucyA6PSAoJ2EsICdiLCAnYykgb3B0aW9uc1xuZW5kXG5cbm1vZHVsZSB0eXBlIENyZWF0b3JzX2FuZF9hY2Nlc3NvcnMxID0gc2lnXG4gIGluY2x1ZGUgQ3JlYXRvcnMxXG5cbiAgaW5jbHVkZVxuICAgIEFjY2Vzc29yczFcbiAgICB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG4gICAgd2l0aCB0eXBlICdhIHRyZWUgOj0gJ2EgdHJlZVxuICAgIHdpdGggdHlwZSBrZXkgOj0ga2V5XG4gICAgd2l0aCB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA6PSBjb21wYXJhdG9yX3dpdG5lc3NcbmVuZFxuXG5tb2R1bGUgdHlwZSBDcmVhdG9yc19hbmRfYWNjZXNzb3JzMiA9IHNpZ1xuICBpbmNsdWRlIENyZWF0b3JzMlxuXG4gIGluY2x1ZGVcbiAgICBBY2Nlc3NvcnMyXG4gICAgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdFxuICAgIHdpdGggdHlwZSAoJ2EsICdiKSB0cmVlIDo9ICgnYSwgJ2IpIHRyZWVcbiAgICB3aXRoIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzIDo9IGNvbXBhcmF0b3Jfd2l0bmVzc1xuZW5kXG5cbm1vZHVsZSB0eXBlIENyZWF0b3JzX2FuZF9hY2Nlc3NvcnMzX3dpdGhfY29tcGFyYXRvciA9IHNpZ1xuICBpbmNsdWRlIENyZWF0b3JzM193aXRoX2NvbXBhcmF0b3JcblxuICBpbmNsdWRlXG4gICAgQWNjZXNzb3JzM193aXRoX2NvbXBhcmF0b3JcbiAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHQgOj0gKCdhLCAnYiwgJ2MpIHRcbiAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHRyZWUgOj0gKCdhLCAnYiwgJ2MpIHRyZWVcbmVuZFxuXG5tb2R1bGUgdHlwZSBTX3BvbHkgPSBDcmVhdG9yc19hbmRfYWNjZXNzb3JzMlxuXG5tb2R1bGUgdHlwZSBGb3JfZGVyaXZpbmcgPSBzaWdcbiAgdHlwZSAoJ2EsICdiLCAnYykgdFxuXG4gIG1vZHVsZSB0eXBlIFNleHBfb2ZfbSA9IHNpZ1xuICAgIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICAgIHZhbCBzZXhwX29mX3QgOiB0IC0+IFNleHBsaWIwLlNleHAudFxuXG4gICAgW0BAQGVuZF1cbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgTV9vZl9zZXhwID0gc2lnXG4gICAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBvZl9zZXhwXVxuXG4gICAgdmFsIHRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0XG5cbiAgICBbQEBAZW5kXVxuXG4gICAgaW5jbHVkZSBDb21wYXJhdG9yLlMgd2l0aCB0eXBlIHQgOj0gdFxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBNX3NleHBfZ3JhbW1hciA9IHNpZ1xuICAgIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9ncmFtbWFyXVxuXG4gICAgdmFsIHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuXG4gICAgW0BAQGVuZF1cbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgQ29tcGFyZV9tID0gc2lnIGVuZFxuICBtb2R1bGUgdHlwZSBFcXVhbF9tID0gc2lnIGVuZFxuICBtb2R1bGUgdHlwZSBIYXNoX2ZvbGRfbSA9IEhhc2hlci5TXG5cbiAgdmFsIHNleHBfb2ZfbV9fdFxuICAgIDogIChtb2R1bGUgU2V4cF9vZl9tIHdpdGggdHlwZSB0ID0gJ2spXG4gICAgLT4gKCd2IC0+IFNleHAudClcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gU2V4cC50XG5cbiAgdmFsIG1fX3Rfb2Zfc2V4cFxuICAgIDogIChtb2R1bGUgTV9vZl9zZXhwIHdpdGggdHlwZSB0ID0gJ2sgYW5kIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gJ2NtcClcbiAgICAtPiAoU2V4cC50IC0+ICd2KVxuICAgIC0+IFNleHAudFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcblxuICB2YWwgbV9fdF9zZXhwX2dyYW1tYXJcbiAgICA6ICAobW9kdWxlIE1fc2V4cF9ncmFtbWFyIHdpdGggdHlwZSB0ID0gJ2spXG4gICAgLT4gJ3YgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG5cbiAgdmFsIGNvbXBhcmVfbV9fdFxuICAgIDogIChtb2R1bGUgQ29tcGFyZV9tKVxuICAgIC0+ICgndiAtPiAndiAtPiBpbnQpXG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBpbnRcblxuICB2YWwgZXF1YWxfbV9fdFxuICAgIDogIChtb2R1bGUgRXF1YWxfbSlcbiAgICAtPiAoJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IGJvb2xcblxuICB2YWwgaGFzaF9mb2xkX21fX3RcbiAgICA6ICAobW9kdWxlIEhhc2hfZm9sZF9tIHdpdGggdHlwZSB0ID0gJ2spXG4gICAgLT4gKEhhc2guc3RhdGUgLT4gJ3YgLT4gSGFzaC5zdGF0ZSlcbiAgICAtPiBIYXNoLnN0YXRlXG4gICAgLT4gKCdrLCAndiwgXykgdFxuICAgIC0+IEhhc2guc3RhdGVcbmVuZFxuXG5tb2R1bGUgdHlwZSBNYXAgPSBzaWdcbiAgKCoqIFtNYXBdIGlzIGEgZnVuY3Rpb25hbCBkYXRhIHN0cnVjdHVyZSAoYmFsYW5jZWQgYmluYXJ5IHRyZWUpIGltcGxlbWVudGluZyBmaW5pdGUgbWFwc1xuICAgICAgb3ZlciBhIHRvdGFsbHktb3JkZXJlZCBkb21haW4sIGNhbGxlZCBhIFwia2V5XCIuICopXG5cbiAgdHlwZSAoJ2tleSwgKyd2YWx1ZSwgJ2NtcCkgdFxuXG4gIG1vZHVsZSBPcl9kdXBsaWNhdGUgPSBPcl9kdXBsaWNhdGVcbiAgbW9kdWxlIENvbnRpbnVlX29yX3N0b3AgPSBDb250aW51ZV9vcl9zdG9wXG5cbiAgbW9kdWxlIEZpbmlzaGVkX29yX3VuZmluaXNoZWQgOiBzaWdcbiAgICB0eXBlIHQgPSBGaW5pc2hlZF9vcl91bmZpbmlzaGVkLnQgPVxuICAgICAgfCBGaW5pc2hlZFxuICAgICAgfCBVbmZpbmlzaGVkXG4gICAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVudW1lcmF0ZSwgZXF1YWwsIHNleHBfb2ZdXG5cbiAgICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlMgd2l0aCB0eXBlIHQgOj0gdFxuICAgIGluY2x1ZGUgUHB4X2VudW1lcmF0ZV9saWIuRW51bWVyYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcbiAgICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5FcXVhbC5TIHdpdGggdHlwZSB0IDo9IHRcblxuICAgIHZhbCBzZXhwX29mX3QgOiB0IC0+IFNleHBsaWIwLlNleHAudFxuXG4gICAgW0BAQGVuZF1cblxuICAgICgqKiBNYXBzIFtDb250aW51ZV0gdG8gW0ZpbmlzaGVkXSBhbmQgW1N0b3BdIHRvIFtVbmZpbmlzaGVkXS4gKilcbiAgICB2YWwgb2ZfY29udGludWVfb3Jfc3RvcCA6IENvbnRpbnVlX29yX3N0b3AudCAtPiB0XG5cbiAgICAoKiogTWFwcyBbRmluaXNoZWRdIHRvIFtDb250aW51ZV0gYW5kIFtVbmZpbmlzaGVkXSB0byBbU3RvcF0uICopXG4gICAgdmFsIHRvX2NvbnRpbnVlX29yX3N0b3AgOiB0IC0+IENvbnRpbnVlX29yX3N0b3AudFxuICBlbmRcblxuICBtb2R1bGUgTWVyZ2VfZWxlbWVudCA6IHNpZ1xuICAgIHR5cGUgKCdsZWZ0LCAncmlnaHQpIHQgPVxuICAgICAgWyBgTGVmdCBvZiAnbGVmdFxuICAgICAgfCBgUmlnaHQgb2YgJ3JpZ2h0XG4gICAgICB8IGBCb3RoIG9mICdsZWZ0ICogJ3JpZ2h0XG4gICAgICBdXG4gICAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBzZXhwX29mXVxuXG4gICAgdmFsIGNvbXBhcmVcbiAgICAgIDogICgnbGVmdCAtPiAnbGVmdCAtPiBpbnQpXG4gICAgICAtPiAoJ3JpZ2h0IC0+ICdyaWdodCAtPiBpbnQpXG4gICAgICAtPiAoJ2xlZnQsICdyaWdodCkgdFxuICAgICAgLT4gKCdsZWZ0LCAncmlnaHQpIHRcbiAgICAgIC0+IGludFxuXG4gICAgdmFsIGVxdWFsXG4gICAgICA6ICAoJ2xlZnQgLT4gJ2xlZnQgLT4gYm9vbClcbiAgICAgIC0+ICgncmlnaHQgLT4gJ3JpZ2h0IC0+IGJvb2wpXG4gICAgICAtPiAoJ2xlZnQsICdyaWdodCkgdFxuICAgICAgLT4gKCdsZWZ0LCAncmlnaHQpIHRcbiAgICAgIC0+IGJvb2xcblxuICAgIHZhbCBzZXhwX29mX3RcbiAgICAgIDogICgnbGVmdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAtPiAoJ3JpZ2h0IC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgIC0+ICgnbGVmdCwgJ3JpZ2h0KSB0XG4gICAgICAtPiBTZXhwbGliMC5TZXhwLnRcblxuICAgIFtAQEBlbmRdXG5cbiAgICB2YWwgbGVmdCA6ICgnbGVmdCwgXykgdCAtPiAnbGVmdCBvcHRpb25cbiAgICB2YWwgcmlnaHQgOiAoXywgJ3JpZ2h0KSB0IC0+ICdyaWdodCBvcHRpb25cbiAgICB2YWwgbGVmdF92YWx1ZSA6ICgnbGVmdCwgXykgdCAtPiBkZWZhdWx0OidsZWZ0IC0+ICdsZWZ0XG4gICAgdmFsIHJpZ2h0X3ZhbHVlIDogKF8sICdyaWdodCkgdCAtPiBkZWZhdWx0OidyaWdodCAtPiAncmlnaHRcblxuICAgIHZhbCB2YWx1ZXNcbiAgICAgIDogICgnbGVmdCwgJ3JpZ2h0KSB0XG4gICAgICAtPiBsZWZ0X2RlZmF1bHQ6J2xlZnRcbiAgICAgIC0+IHJpZ2h0X2RlZmF1bHQ6J3JpZ2h0XG4gICAgICAtPiAnbGVmdCAqICdyaWdodFxuICBlbmRcblxuICB0eXBlICgnaywgJ2NtcCkgY29tcGFyYXRvciA9ICgnaywgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICBbQEBkZXByZWNhdGVkIFwiW3NpbmNlIDIwMjEtMTJdIHVzZSBbQ29tcGFyYXRvci5Nb2R1bGUudF0gaW5zdGVhZFwiXVxuXG4gICgqKiBUZXN0IGlmIHRoZSBpbnZhcmlhbnRzIG9mIHRoZSBpbnRlcm5hbCBBVkwgc2VhcmNoIHRyZWUgaG9sZC4gKilcbiAgdmFsIGludmFyaWFudHMgOiAoXywgXywgXykgdCAtPiBib29sXG5cbiAgKCoqIFJldHVybnMgYSBmaXJzdC1jbGFzcyBtb2R1bGUgdGhhdCBjYW4gYmUgdXNlZCB0byBidWlsZCBvdGhlciBtYXAvc2V0L2V0Yy5cbiAgICAgIHdpdGggdGhlIHNhbWUgbm90aW9uIG9mIGNvbXBhcmlzb24uICopXG4gIHZhbCBjb21wYXJhdG9yX3MgOiAoJ2EsIF8sICdjbXApIHQgLT4gKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG5cbiAgdmFsIGNvbXBhcmF0b3IgOiAoJ2EsIF8sICdjbXApIHQgLT4gKCdhLCAnY21wKSBDb21wYXJhdG9yLnRcblxuICAoKiogVGhlIGVtcHR5IG1hcC4gKilcbiAgdmFsIGVtcHR5IDogKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50IC0+ICgnYSwgJ2IsICdjbXApIHRcblxuICAoKiogQSBtYXAgd2l0aCBvbmUgKGtleSwgZGF0YSkgcGFpci4gKilcbiAgdmFsIHNpbmdsZXRvbiA6ICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudCAtPiAnYSAtPiAnYiAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgKCoqIENyZWF0ZXMgYSBtYXAgZnJvbSBhbiBhc3NvY2lhdGlvbiBsaXN0IHdpdGggdW5pcXVlIGtleXMuICopXG4gIHZhbCBvZl9hbGlzdFxuICAgIDogICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnYSAqICdiKSBsaXN0XG4gICAgLT4gWyBgT2sgb2YgKCdhLCAnYiwgJ2NtcCkgdCB8IGBEdXBsaWNhdGVfa2V5IG9mICdhIF1cblxuICAoKiogQ3JlYXRlcyBhIG1hcCBmcm9tIGFuIGFzc29jaWF0aW9uIGxpc3Qgd2l0aCB1bmlxdWUga2V5cywgcmV0dXJuaW5nIGFuIGVycm9yIGlmXG4gICAgICBkdXBsaWNhdGUgWydhXSBrZXlzIGFyZSBmb3VuZC4gKilcbiAgdmFsIG9mX2FsaXN0X29yX2Vycm9yXG4gICAgOiAgKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCdhICogJ2IpIGxpc3RcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0IE9yX2Vycm9yLnRcblxuICAoKiogQ3JlYXRlcyBhIG1hcCBmcm9tIGFuIGFzc29jaWF0aW9uIGxpc3Qgd2l0aCB1bmlxdWUga2V5cywgcmFpc2luZyBhbiBleGNlcHRpb24gaWZcbiAgICAgIGR1cGxpY2F0ZSBbJ2FdIGtleXMgYXJlIGZvdW5kLiAqKVxuICB2YWwgb2ZfYWxpc3RfZXhuIDogKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50IC0+ICgnYSAqICdiKSBsaXN0IC0+ICgnYSwgJ2IsICdjbXApIHRcblxuICAoKiogQ3JlYXRlcyBhIG1hcCBmcm9tIGFuIGFzc29jaWF0aW9uIGxpc3Qgd2l0aCBwb3NzaWJseSByZXBlYXRlZCBrZXlzLiBUaGUgdmFsdWVzIGluXG4gICAgICB0aGUgbWFwIGZvciBhIGdpdmVuIGtleSBhcHBlYXIgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhleSBkaWQgaW4gdGhlIGFzc29jaWF0aW9uXG4gICAgICBsaXN0LiAqKVxuICB2YWwgb2ZfYWxpc3RfbXVsdGlcbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2EgKiAnYikgbGlzdFxuICAgIC0+ICgnYSwgJ2IgbGlzdCwgJ2NtcCkgdFxuXG4gICgqKiBDb21iaW5lcyBhbiBhc3NvY2lhdGlvbiBsaXN0IGludG8gYSBtYXAsIGZvbGRpbmcgdG9nZXRoZXIgYm91bmQgdmFsdWVzIHdpdGggY29tbW9uXG4gICAgICBrZXlzLiBUaGUgYWNjdW11bGF0b3IgaXMgcGVyLWtleS5cblxuICAgICAgRXhhbXBsZTpcblxuICAgICAge1tcbiAgICAgICAgIyBsZXQgbWFwID0gU3RyaW5nLk1hcC5vZl9hbGlzdF9mb2xkXG4gICAgICAgICAgICAgICAgICAgICAgWyBcImFcIiwgMTsgXCJhXCIsIDEwOyBcImJcIiwgMjsgXCJiXCIsIDIwOyBcImJcIiwgMjAwIF1cbiAgICAgICAgICAgICAgICAgICAgICB+aW5pdDpJbnQuU2V0LmVtcHR5XG4gICAgICAgICAgICAgICAgICAgICAgfmY6U2V0LmFkZFxuICAgICAgICAgIGluXG4gICAgICAgICAgcHJpbnRfcyBbJXNleHAgKG1hcCA6IEludC5TZXQudCBTdHJpbmcuTWFwLnQpXTs7XG4gICAgICAgICgoYSAoMSAxMCkpIChiICgyIDIwIDIwMCkpKVxuICAgICAgICAtIDogdW5pdCA9ICgpXG4gICAgICBdfVxuICAqKVxuICB2YWwgb2ZfYWxpc3RfZm9sZFxuICAgIDogICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnYSAqICdiKSBsaXN0XG4gICAgLT4gaW5pdDonY1xuICAgIC0+IGY6KCdjIC0+ICdiIC0+ICdjKVxuICAgIC0+ICgnYSwgJ2MsICdjbXApIHRcblxuICAoKiogQ29tYmluZXMgYW4gYXNzb2NpYXRpb24gbGlzdCBpbnRvIGEgbWFwLCByZWR1Y2luZyB0b2dldGhlciBib3VuZCB2YWx1ZXMgd2l0aCBjb21tb25cbiAgICAgIGtleXMuICopXG4gIHZhbCBvZl9hbGlzdF9yZWR1Y2VcbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2EgKiAnYikgbGlzdFxuICAgIC0+IGY6KCdiIC0+ICdiIC0+ICdiKVxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcblxuICAoKiogW29mX2l0ZXJpIH5pdGVyaV0gYmVoYXZlcyBsaWtlIFtvZl9hbGlzdF0sIGV4Y2VwdCB0aGF0IGluc3RlYWQgb2YgdGFraW5nIGEgY29uY3JldGVcbiAgICAgIGRhdGEgc3RydWN0dXJlLCBpdCB0YWtlcyBhbiBpdGVyYXRpb24gZnVuY3Rpb24uICBGb3IgaW5zdGFuY2UsIHRvIGNvbnZlcnQgYSBzdHJpbmcgdGFibGVcbiAgICAgIGludG8gYSBtYXA6IFtvZl9pdGVyaSAobW9kdWxlIFN0cmluZykgfmY6KEhhc2h0YmwuaXRlcmkgdGFibGUpXS4gIEl0IGlzIGZhc3RlciB0aGFuXG4gICAgICBhZGRpbmcgdGhlIGVsZW1lbnRzIG9uZSBieSBvbmUuICopXG4gIHZhbCBvZl9pdGVyaVxuICAgIDogICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+IGl0ZXJpOihmOihrZXk6J2EgLT4gZGF0YTonYiAtPiB1bml0KSAtPiB1bml0KVxuICAgIC0+IFsgYE9rIG9mICgnYSwgJ2IsICdjbXApIHQgfCBgRHVwbGljYXRlX2tleSBvZiAnYSBdXG5cbiAgKCoqIExpa2UgW29mX2l0ZXJpXSBleGNlcHQgdGhhdCBpdCByYWlzZXMgYW4gZXhjZXB0aW9uIGlmIGR1cGxpY2F0ZSBbJ2FdIGtleXMgYXJlIGZvdW5kLiAqKVxuICB2YWwgb2ZfaXRlcmlfZXhuXG4gICAgOiAgKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gaXRlcmk6KGY6KGtleTonYSAtPiBkYXRhOidiIC0+IHVuaXQpIC0+IHVuaXQpXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gICgqKiBDcmVhdGVzIGEgbWFwIGZyb20gYSBzb3J0ZWQgYXJyYXkgb2Yga2V5LWRhdGEgcGFpcnMuIFRoZSBpbnB1dCBhcnJheSBtdXN0IGJlIHNvcnRlZFxuICAgICAgKGVpdGhlciBpbiBhc2NlbmRpbmcgb3IgZGVzY2VuZGluZyBvcmRlciksIGFzIGdpdmVuIGJ5IHRoZSByZWxldmFudCBjb21wYXJhdG9yLCBhbmRcbiAgICAgIG11c3Qgbm90IGNvbnRhaW4gZHVwbGljYXRlIGtleXMuIElmIGVpdGhlciBvZiB0aGVzZSBjb25kaXRpb25zIGRvZXMgbm90IGhvbGQsXG4gICAgICBhbiBlcnJvciBpcyByZXR1cm5lZC4gICopXG4gIHZhbCBvZl9zb3J0ZWRfYXJyYXlcbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2EgKiAnYikgYXJyYXlcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0IE9yX2Vycm9yLnRcblxuICAoKiogTGlrZSBbb2Zfc29ydGVkX2FycmF5XSBleGNlcHQgdGhhdCBpdCByZXR1cm5zIGEgbWFwIHdpdGggYnJva2VuIGludmFyaWFudHMgd2hlbiBhblxuICAgICAgW0Vycm9yXSB3b3VsZCBoYXZlIGJlZW4gcmV0dXJuZWQuICopXG4gIHZhbCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkXG4gICAgOiAgKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCdhICogJ2IpIGFycmF5XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gICgqKiBbb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgYyB+bGVuIH5mXSBiZWhhdmVzIGxpa2UgW29mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgY1xuICAgICAgKEFycmF5LmluaXQgbGVuIH5mKV0sIHdpdGggdGhlIGFkZGl0aW9uYWwgcmVzdHJpY3Rpb24gdGhhdCBhIGRlY3JlYXNpbmcgb3JkZXIgaXMgbm90XG4gICAgICBzdXBwb3J0ZWQuICBUaGUgYWR2YW50YWdlIGlzIG5vdCByZXF1aXJpbmcgeW91IHRvIGFsbG9jYXRlIGFuIGludGVybWVkaWF0ZSBhcnJheS4gIFtmXVxuICAgICAgd2lsbCBiZSBjYWxsZWQgd2l0aCAwLCAxLCAuLi4gW2xlbiAtIDFdLCBpbiBvcmRlci4gKilcbiAgdmFsIG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkXG4gICAgOiAgKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gbGVuOmludFxuICAgIC0+IGY6KGludCAtPiAnYSAqICdiKVxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcblxuICAoKiogW29mX2luY3JlYXNpbmdfc2VxdWVuY2UgYyBzZXFdIGJlaGF2ZXMgbGlrZSBbb2Zfc29ydGVkX2FycmF5IGMgKFNlcXVlbmNlLnRvX2FycmF5XG4gICAgICBzZXEpXSwgYnV0IGRvZXMgbm90IGFsbG9jYXRlIHRoZSBpbnRlcm1lZGlhdGUgYXJyYXkuXG5cbiAgICAgIFRoZSBzZXF1ZW5jZSB3aWxsIGJlIGZvbGRlZCBvdmVyIG9uY2UsIGFuZCB0aGUgYWRkaXRpb25hbCB0aW1lIGNvbXBsZXhpdHkgaXMge2UgTyhuKX0uXG4gICopXG4gIHZhbCBvZl9pbmNyZWFzaW5nX3NlcXVlbmNlXG4gICAgOiAgKCdrLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCdrICogJ3YpIFNlcXVlbmNlLnRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0IE9yX2Vycm9yLnRcblxuICAoKiogQ3JlYXRlcyBhIG1hcCBmcm9tIGFuIGFzc29jaWF0aW9uIHNlcXVlbmNlIHdpdGggdW5pcXVlIGtleXMuXG5cbiAgICAgIFtvZl9zZXF1ZW5jZSBjIHNlcV0gYmVoYXZlcyBsaWtlIFtvZl9hbGlzdCBjIChTZXF1ZW5jZS50b19saXN0IHNlcSldIGJ1dFxuICAgICAgZG9lcyBub3QgYWxsb2NhdGUgdGhlIGludGVybWVkaWF0ZSBsaXN0LlxuXG4gICAgICBJZiB5b3VyIHNlcXVlbmNlIGlzIGluY3JlYXNpbmcsIHVzZSBbb2ZfaW5jcmVhc2luZ19zZXF1ZW5jZV0uXG4gICopXG4gIHZhbCBvZl9zZXF1ZW5jZVxuICAgIDogICgnaywgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnayAqICd2KSBTZXF1ZW5jZS50XG4gICAgLT4gWyBgT2sgb2YgKCdrLCAndiwgJ2NtcCkgdCB8IGBEdXBsaWNhdGVfa2V5IG9mICdrIF1cblxuICAoKiogQ3JlYXRlcyBhIG1hcCBmcm9tIGFuIGFzc29jaWF0aW9uIHNlcXVlbmNlIHdpdGggdW5pcXVlIGtleXMsIHJldHVybmluZyBhbiBlcnJvciBpZlxuICAgICAgZHVwbGljYXRlIFsnYV0ga2V5cyBhcmUgZm91bmQuXG5cbiAgICAgIFtvZl9zZXF1ZW5jZV9vcl9lcnJvciBjIHNlcV0gYmVoYXZlcyBsaWtlIFtvZl9hbGlzdF9vcl9lcnJvciBjIChTZXF1ZW5jZS50b19saXN0IHNlcSldXG4gICAgICBidXQgZG9lcyBub3QgYWxsb2NhdGUgdGhlIGludGVybWVkaWF0ZSBsaXN0LlxuICAqKVxuICB2YWwgb2Zfc2VxdWVuY2Vfb3JfZXJyb3JcbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2EgKiAnYikgU2VxdWVuY2UudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHQgT3JfZXJyb3IudFxuXG4gICgqKiBDcmVhdGVzIGEgbWFwIGZyb20gYW4gYXNzb2NpYXRpb24gc2VxdWVuY2Ugd2l0aCB1bmlxdWUga2V5cywgcmFpc2luZyBhbiBleGNlcHRpb24gaWZcbiAgICAgIGR1cGxpY2F0ZSBbJ2FdIGtleXMgYXJlIGZvdW5kLlxuXG4gICAgICBbb2Zfc2VxdWVuY2VfZXhuIGMgc2VxXSBiZWhhdmVzIGxpa2UgW29mX2FsaXN0X2V4biBjIChTZXF1ZW5jZS50b19saXN0IHNlcSldIGJ1dFxuICAgICAgZG9lcyBub3QgYWxsb2NhdGUgdGhlIGludGVybWVkaWF0ZSBsaXN0LlxuICAqKVxuICB2YWwgb2Zfc2VxdWVuY2VfZXhuXG4gICAgOiAgKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCdhICogJ2IpIFNlcXVlbmNlLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgKCoqIENyZWF0ZXMgYSBtYXAgZnJvbSBhbiBhc3NvY2lhdGlvbiBzZXF1ZW5jZSB3aXRoIHBvc3NpYmx5IHJlcGVhdGVkIGtleXMuIFRoZSB2YWx1ZXMgaW5cbiAgICAgIHRoZSBtYXAgZm9yIGEgZ2l2ZW4ga2V5IGFwcGVhciBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGV5IGRpZCBpbiB0aGUgYXNzb2NpYXRpb25cbiAgICAgIGxpc3QuXG5cbiAgICAgIFtvZl9zZXF1ZW5jZV9tdWx0aSBjIHNlcV0gYmVoYXZlcyBsaWtlIFtvZl9hbGlzdF9leG4gYyAoU2VxdWVuY2UudG9fbGlzdCBzZXEpXSBidXRcbiAgICAgIGRvZXMgbm90IGFsbG9jYXRlIHRoZSBpbnRlcm1lZGlhdGUgbGlzdC5cbiAgKilcbiAgdmFsIG9mX3NlcXVlbmNlX211bHRpXG4gICAgOiAgKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCdhICogJ2IpIFNlcXVlbmNlLnRcbiAgICAtPiAoJ2EsICdiIGxpc3QsICdjbXApIHRcblxuICAoKiogQ29tYmluZXMgYW4gYXNzb2NpYXRpb24gc2VxdWVuY2UgaW50byBhIG1hcCwgZm9sZGluZyB0b2dldGhlciBib3VuZCB2YWx1ZXMgd2l0aCBjb21tb25cbiAgICAgIGtleXMuXG5cbiAgICAgIFtvZl9zZXF1ZW5jZV9mb2xkIGMgc2VxIH5pbml0IH5mXSBiZWhhdmVzIGxpa2UgW29mX2FsaXN0X2ZvbGQgYyAoU2VxdWVuY2UudG9fbGlzdCBzZXEpIH5pbml0IH5mXVxuICAgICAgYnV0IGRvZXMgbm90IGFsbG9jYXRlIHRoZSBpbnRlcm1lZGlhdGUgbGlzdC5cbiAgKilcbiAgdmFsIG9mX3NlcXVlbmNlX2ZvbGRcbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2EgKiAnYikgU2VxdWVuY2UudFxuICAgIC0+IGluaXQ6J2NcbiAgICAtPiBmOignYyAtPiAnYiAtPiAnYylcbiAgICAtPiAoJ2EsICdjLCAnY21wKSB0XG5cbiAgKCoqIENvbWJpbmVzIGFuIGFzc29jaWF0aW9uIHNlcXVlbmNlIGludG8gYSBtYXAsIHJlZHVjaW5nIHRvZ2V0aGVyIGJvdW5kIHZhbHVlcyB3aXRoIGNvbW1vblxuICAgICAga2V5cy5cblxuICAgICAgW29mX3NlcXVlbmNlX3JlZHVjZSBjIHNlcSB+Zl0gYmVoYXZlcyBsaWtlIFtvZl9hbGlzdF9yZWR1Y2UgYyAoU2VxdWVuY2UudG9fbGlzdCBzZXEpIH5mXVxuICAgICAgYnV0IGRvZXMgbm90IGFsbG9jYXRlIHRoZSBpbnRlcm1lZGlhdGUgbGlzdC4gICopXG4gIHZhbCBvZl9zZXF1ZW5jZV9yZWR1Y2VcbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2EgKiAnYikgU2VxdWVuY2UudFxuICAgIC0+IGY6KCdiIC0+ICdiIC0+ICdiKVxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcblxuICAoKiogVGVzdHMgd2hldGhlciBhIG1hcCBpcyBlbXB0eS4gKilcbiAgdmFsIGlzX2VtcHR5IDogKF8sIF8sIF8pIHQgLT4gYm9vbFxuXG4gICgqKiBbbGVuZ3RoIG1hcF0gcmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIFttYXBdLiAgTygxKSwgYnV0IFtUcmVlLmxlbmd0aF0gaXNcbiAgICAgIE8obikuICopXG4gIHZhbCBsZW5ndGggOiAoXywgXywgXykgdCAtPiBpbnRcblxuICAoKiogUmV0dXJucyBhIG5ldyBtYXAgd2l0aCB0aGUgc3BlY2lmaWVkIG5ldyBiaW5kaW5nOyBpZiB0aGUga2V5IHdhcyBhbHJlYWR5IGJvdW5kLCBpdHNcbiAgICAgIHByZXZpb3VzIGJpbmRpbmcgZGlzYXBwZWFycy4gKilcbiAgdmFsIHNldCA6ICgnaywgJ3YsICdjbXApIHQgLT4ga2V5OidrIC0+IGRhdGE6J3YgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gICgqKiBbYWRkIHQgfmtleSB+ZGF0YV0gYWRkcyBhIG5ldyBlbnRyeSB0byBbdF0gbWFwcGluZyBba2V5XSB0byBbZGF0YV0gYW5kIHJldHVybnMgW2BPa11cbiAgICAgIHdpdGggdGhlIG5ldyBtYXAsIG9yIGlmIFtrZXldIGlzIGFscmVhZHkgcHJlc2VudCBpbiBbdF0sIHJldHVybnMgW2BEdXBsaWNhdGVdLiAqKVxuICB2YWwgYWRkIDogKCdrLCAndiwgJ2NtcCkgdCAtPiBrZXk6J2sgLT4gZGF0YTondiAtPiAoJ2ssICd2LCAnY21wKSB0IE9yX2R1cGxpY2F0ZS50XG5cbiAgdmFsIGFkZF9leG4gOiAoJ2ssICd2LCAnY21wKSB0IC0+IGtleTonayAtPiBkYXRhOid2IC0+ICgnaywgJ3YsICdjbXApIHRcblxuICAoKiogSWYgW2tleV0gaXMgbm90IHByZXNlbnQgdGhlbiBhZGQgYSBzaW5nbGV0b24gbGlzdCwgb3RoZXJ3aXNlLCBjb25zIGRhdGEgb250byB0aGVcbiAgICAgIGhlYWQgb2YgdGhlIGV4aXN0aW5nIGxpc3QuICopXG4gIHZhbCBhZGRfbXVsdGkgOiAoJ2ssICd2IGxpc3QsICdjbXApIHQgLT4ga2V5OidrIC0+IGRhdGE6J3YgLT4gKCdrLCAndiBsaXN0LCAnY21wKSB0XG5cbiAgKCoqIElmIHRoZSBrZXkgaXMgcHJlc2VudCwgdGhlbiByZW1vdmUgaXRzIGhlYWQgZWxlbWVudDsgaWYgdGhlIHJlc3VsdCBpcyBlbXB0eSwgcmVtb3ZlXG4gICAgICB0aGUga2V5LiAqKVxuICB2YWwgcmVtb3ZlX211bHRpIDogKCdrLCAndiBsaXN0LCAnY21wKSB0IC0+ICdrIC0+ICgnaywgJ3YgbGlzdCwgJ2NtcCkgdFxuXG4gICgqKiBSZXR1cm5zIHRoZSB2YWx1ZSBib3VuZCB0byB0aGUgZ2l2ZW4ga2V5LCBvciB0aGUgZW1wdHkgbGlzdCBpZiB0aGVyZSBpcyBub25lLiAqKVxuICB2YWwgZmluZF9tdWx0aSA6ICgnaywgJ3YgbGlzdCwgJ2NtcCkgdCAtPiAnayAtPiAndiBsaXN0XG5cbiAgKCoqIFtjaGFuZ2UgdCBrZXkgfmZdIHJldHVybnMgYSBuZXcgbWFwIFttXSB0aGF0IGlzIHRoZSBzYW1lIGFzIFt0XSBvbiBhbGwga2V5cyBleGNlcHRcbiAgICAgIGZvciBba2V5XSwgYW5kIHdob3NlIHZhbHVlIGZvciBba2V5XSBpcyBkZWZpbmVkIGJ5IFtmXSwgaS5lLiwgW2ZpbmQgbSBrZXkgPSBmIChmaW5kXG4gICAgICB0IGtleSldLiAqKVxuICB2YWwgY2hhbmdlIDogKCdrLCAndiwgJ2NtcCkgdCAtPiAnayAtPiBmOigndiBvcHRpb24gLT4gJ3Ygb3B0aW9uKSAtPiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgKCoqIFt1cGRhdGUgdCBrZXkgfmZdIGlzIFtjaGFuZ2UgdCBrZXkgfmY6KGZ1biBvIC0+IFNvbWUgKGYgbykpXS4gKilcbiAgdmFsIHVwZGF0ZSA6ICgnaywgJ3YsICdjbXApIHQgLT4gJ2sgLT4gZjooJ3Ygb3B0aW9uIC0+ICd2KSAtPiAoJ2ssICd2LCAnY21wKSB0XG5cblxuICAoKiogUmV0dXJucyBbU29tZSB2YWx1ZV0gYm91bmQgdG8gdGhlIGdpdmVuIGtleSwgb3IgW05vbmVdIGlmIG5vbmUgZXhpc3RzLiAqKVxuICB2YWwgZmluZCA6ICgnaywgJ3YsICdjbXApIHQgLT4gJ2sgLT4gJ3Ygb3B0aW9uXG5cbiAgKCoqIFJldHVybnMgdGhlIHZhbHVlIGJvdW5kIHRvIHRoZSBnaXZlbiBrZXksIHJhaXNpbmcgW0NhbWwuTm90X2ZvdW5kXSBvciBbTm90X2ZvdW5kX3NdXG4gICAgICBpZiBub25lIGV4aXN0cy4gKilcbiAgdmFsIGZpbmRfZXhuIDogKCdrLCAndiwgJ2NtcCkgdCAtPiAnayAtPiAndlxuXG4gICgqKiBSZXR1cm5zIGEgbmV3IG1hcCB3aXRoIGFueSBiaW5kaW5nIGZvciB0aGUga2V5IGluIHF1ZXN0aW9uIHJlbW92ZWQuICopXG4gIHZhbCByZW1vdmUgOiAoJ2ssICd2LCAnY21wKSB0IC0+ICdrIC0+ICgnaywgJ3YsICdjbXApIHRcblxuICAoKiogW21lbSBtYXAga2V5XSB0ZXN0cyB3aGV0aGVyIFttYXBdIGNvbnRhaW5zIGEgYmluZGluZyBmb3IgW2tleV0uICopXG4gIHZhbCBtZW0gOiAoJ2ssIF8sICdjbXApIHQgLT4gJ2sgLT4gYm9vbFxuXG4gIHZhbCBpdGVyX2tleXMgOiAoJ2ssIF8sIF8pIHQgLT4gZjooJ2sgLT4gdW5pdCkgLT4gdW5pdFxuICB2YWwgaXRlciA6IChfLCAndiwgXykgdCAtPiBmOigndiAtPiB1bml0KSAtPiB1bml0XG4gIHZhbCBpdGVyaSA6ICgnaywgJ3YsIF8pIHQgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YgLT4gdW5pdCkgLT4gdW5pdFxuXG4gICgqKiBJdGVyYXRlcyB1bnRpbCB0aGUgZmlyc3QgdGltZSBbZl0gcmV0dXJucyBbU3RvcF0uIElmIFtmXSByZXR1cm5zIFtTdG9wXSwgdGhlIGZpbmFsXG4gICAgICByZXN1bHQgaXMgW1VuZmluaXNoZWRdLiBPdGhlcndpc2UsIHRoZSBmaW5hbCByZXN1bHQgaXMgW0ZpbmlzaGVkXS4gKilcbiAgdmFsIGl0ZXJpX3VudGlsXG4gICAgOiAgKCdrLCAndiwgXykgdFxuICAgIC0+IGY6KGtleTonayAtPiBkYXRhOid2IC0+IENvbnRpbnVlX29yX3N0b3AudClcbiAgICAtPiBGaW5pc2hlZF9vcl91bmZpbmlzaGVkLnRcblxuICAoKiogSXRlcmF0ZXMgdHdvIG1hcHMgc2lkZSBieSBzaWRlLiBUaGUgY29tcGxleGl0eSBvZiB0aGlzIGZ1bmN0aW9uIGlzIE8oTSArIE4pLiAgSWYgdHdvXG4gICAgICBpbnB1dHMgYXJlIFtbKDAsIGEpOyAoMSwgYSldXSBhbmQgW1soMSwgYik7ICgyLCBiKV1dLCBbZl0gd2lsbCBiZSBjYWxsZWQgd2l0aCBbWygwLFxuICAgICAgYExlZnQgYSk7ICgxLCBgQm90aCAoYSwgYikpOyAoMiwgYFJpZ2h0IGIpXV0uICopXG4gIHZhbCBpdGVyMlxuICAgIDogICgnaywgJ3YxLCAnY21wKSB0XG4gICAgLT4gKCdrLCAndjIsICdjbXApIHRcbiAgICAtPiBmOihrZXk6J2sgLT4gZGF0YTooJ3YxLCAndjIpIE1lcmdlX2VsZW1lbnQudCAtPiB1bml0KVxuICAgIC0+IHVuaXRcblxuICAoKiogUmV0dXJucyBhIG5ldyBtYXAgd2l0aCBib3VuZCB2YWx1ZXMgcmVwbGFjZWQgYnkgW2ZdIGFwcGxpZWQgdG8gdGhlIGJvdW5kIHZhbHVlcy4qKVxuICB2YWwgbWFwIDogKCdrLCAndjEsICdjbXApIHQgLT4gZjooJ3YxIC0+ICd2MikgLT4gKCdrLCAndjIsICdjbXApIHRcblxuICAoKiogTGlrZSBbbWFwXSwgYnV0IHRoZSBwYXNzZWQgZnVuY3Rpb24gdGFrZXMgYm90aCBba2V5XSBhbmQgW2RhdGFdIGFzIGFyZ3VtZW50cy4gKilcbiAgdmFsIG1hcGkgOiAoJ2ssICd2MSwgJ2NtcCkgdCAtPiBmOihrZXk6J2sgLT4gZGF0YTondjEgLT4gJ3YyKSAtPiAoJ2ssICd2MiwgJ2NtcCkgdFxuXG4gICgqKiBDb252ZXJ0IG1hcCB3aXRoIGtleXMgb2YgdHlwZSBbJ2syXSB0byBhIG1hcCB3aXRoIGtleXMgb2YgdHlwZSBbJ2syXSB1c2luZyBbZl0uICopXG4gIHZhbCBtYXBfa2V5c1xuICAgIDogICgnazIsICdjbXAyKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCdrMSwgJ3YsICdjbXAxKSB0XG4gICAgLT4gZjooJ2sxIC0+ICdrMilcbiAgICAtPiBbIGBPayBvZiAoJ2syLCAndiwgJ2NtcDIpIHQgfCBgRHVwbGljYXRlX2tleSBvZiAnazIgXVxuXG4gICgqKiBMaWtlIFttYXBfa2V5c10sIGJ1dCByYWlzZXMgb24gZHVwbGljYXRlIGtleS4gKilcbiAgdmFsIG1hcF9rZXlzX2V4blxuICAgIDogICgnazIsICdjbXAyKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCdrMSwgJ3YsICdjbXAxKSB0XG4gICAgLT4gZjooJ2sxIC0+ICdrMilcbiAgICAtPiAoJ2syLCAndiwgJ2NtcDIpIHRcblxuICAoKiogRm9sZHMgb3ZlciBrZXlzIGFuZCBkYXRhIGluIHRoZSBtYXAgaW4gaW5jcmVhc2luZyBvcmRlciBvZiBba2V5XS4gKilcbiAgdmFsIGZvbGQgOiAoJ2ssICd2LCBfKSB0IC0+IGluaXQ6J2EgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YgLT4gJ2EgLT4gJ2EpIC0+ICdhXG5cbiAgKCoqIEZvbGRzIG92ZXIga2V5cyBhbmQgZGF0YSBpbiB0aGUgbWFwIGluIGluY3JlYXNpbmcgb3JkZXIgb2YgW2tleV0sIHVudGlsIHRoZSBmaXJzdFxuICAgICAgdGltZSB0aGF0IFtmXSByZXR1cm5zIFtTdG9wIF9dLiBJZiBbZl0gcmV0dXJucyBbU3RvcCBmaW5hbF0sIHRoaXMgZnVuY3Rpb24gcmV0dXJuc1xuICAgICAgaW1tZWRpYXRlbHkgd2l0aCB0aGUgdmFsdWUgW2ZpbmFsXS4gSWYgW2ZdIG5ldmVyIHJldHVybnMgW1N0b3AgX10sIGFuZCB0aGUgZmluYWxcbiAgICAgIGNhbGwgdG8gW2ZdIHJldHVybnMgW0NvbnRpbnVlIGxhc3RdLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgW2ZpbmlzaCBsYXN0XS4gKilcbiAgdmFsIGZvbGRfdW50aWxcbiAgICA6ICAoJ2ssICd2LCBfKSB0XG4gICAgLT4gaW5pdDonYWNjXG4gICAgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YgLT4gJ2FjYyAtPiAoJ2FjYywgJ2ZpbmFsKSBDb250YWluZXIuQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IGZpbmlzaDooJ2FjYyAtPiAnZmluYWwpXG4gICAgLT4gJ2ZpbmFsXG5cbiAgKCoqIEZvbGRzIG92ZXIga2V5cyBhbmQgZGF0YSBpbiB0aGUgbWFwIGluIGRlY3JlYXNpbmcgb3JkZXIgb2YgW2tleV0uICopXG4gIHZhbCBmb2xkX3JpZ2h0IDogKCdrLCAndiwgXykgdCAtPiBpbml0OidhIC0+IGY6KGtleTonayAtPiBkYXRhOid2IC0+ICdhIC0+ICdhKSAtPiAnYVxuXG4gICgqKiBGb2xkcyBvdmVyIHR3byBtYXBzIHNpZGUgYnkgc2lkZSwgbGlrZSBbaXRlcjJdLiAqKVxuICB2YWwgZm9sZDJcbiAgICA6ICAoJ2ssICd2MSwgJ2NtcCkgdFxuICAgIC0+ICgnaywgJ3YyLCAnY21wKSB0XG4gICAgLT4gaW5pdDonYVxuICAgIC0+IGY6KGtleTonayAtPiBkYXRhOigndjEsICd2MikgTWVyZ2VfZWxlbWVudC50IC0+ICdhIC0+ICdhKVxuICAgIC0+ICdhXG5cbiAgKCoqIFtmaWx0ZXJdLCBbZmlsdGVyaV0sIFtmaWx0ZXJfa2V5c10sIFtmaWx0ZXJfbWFwXSwgYW5kIFtmaWx0ZXJfbWFwaV0gcnVuIGluIE8obiAqIGxnXG4gICAgICBuKSB0aW1lOyB0aGV5IHNpbXBseSBhY2N1bXVsYXRlIGVhY2gga2V5ICYgZGF0YSBwYWlyIHJldGFpbmVkIGJ5IFtmXSBpbnRvIGEgbmV3IG1hcFxuICAgICAgdXNpbmcgW2FkZF0uICopXG4gIHZhbCBmaWx0ZXJfa2V5cyA6ICgnaywgJ3YsICdjbXApIHQgLT4gZjooJ2sgLT4gYm9vbCkgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gIHZhbCBmaWx0ZXIgOiAoJ2ssICd2LCAnY21wKSB0IC0+IGY6KCd2IC0+IGJvb2wpIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgdmFsIGZpbHRlcmkgOiAoJ2ssICd2LCAnY21wKSB0IC0+IGY6KGtleTonayAtPiBkYXRhOid2IC0+IGJvb2wpIC0+ICgnaywgJ3YsICdjbXApIHRcblxuICAoKiogUmV0dXJucyBhIG5ldyBtYXAgd2l0aCBib3VuZCB2YWx1ZXMgZmlsdGVyZWQgYnkgW2ZdIGFwcGxpZWQgdG8gdGhlIGJvdW5kIHZhbHVlcy4gKilcbiAgdmFsIGZpbHRlcl9tYXAgOiAoJ2ssICd2MSwgJ2NtcCkgdCAtPiBmOigndjEgLT4gJ3YyIG9wdGlvbikgLT4gKCdrLCAndjIsICdjbXApIHRcblxuICAoKiogTGlrZSBbZmlsdGVyX21hcF0sIGJ1dCB0aGUgcGFzc2VkIGZ1bmN0aW9uIHRha2VzIGJvdGggW2tleV0gYW5kIFtkYXRhXSBhc1xuICAgICAgYXJndW1lbnRzLiAqKVxuICB2YWwgZmlsdGVyX21hcGlcbiAgICA6ICAoJ2ssICd2MSwgJ2NtcCkgdFxuICAgIC0+IGY6KGtleTonayAtPiBkYXRhOid2MSAtPiAndjIgb3B0aW9uKVxuICAgIC0+ICgnaywgJ3YyLCAnY21wKSB0XG5cbiAgKCoqIFtwYXJ0aXRpb25fbWFwaSB0IH5mXSByZXR1cm5zIHR3byBuZXcgW3Rdcywgd2l0aCBlYWNoIGtleSBpbiBbdF0gYXBwZWFyaW5nIGluXG4gICAgICBleGFjdGx5IG9uZSBvZiB0aGUgcmVzdWx0aW5nIG1hcHMgZGVwZW5kaW5nIG9uIGl0cyBtYXBwaW5nIGluIFtmXS4gKilcbiAgdmFsIHBhcnRpdGlvbl9tYXBpXG4gICAgOiAgKCdrLCAndjEsICdjbXApIHRcbiAgICAtPiBmOihrZXk6J2sgLT4gZGF0YTondjEgLT4gKCd2MiwgJ3YzKSBFaXRoZXIudClcbiAgICAtPiAoJ2ssICd2MiwgJ2NtcCkgdCAqICgnaywgJ3YzLCAnY21wKSB0XG5cbiAgKCoqIFtwYXJ0aXRpb25fbWFwIHQgfmYgPSBwYXJ0aXRpb25fbWFwaSB0IH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSldICopXG4gIHZhbCBwYXJ0aXRpb25fbWFwXG4gICAgOiAgKCdrLCAndjEsICdjbXApIHRcbiAgICAtPiBmOigndjEgLT4gKCd2MiwgJ3YzKSBFaXRoZXIudClcbiAgICAtPiAoJ2ssICd2MiwgJ2NtcCkgdCAqICgnaywgJ3YzLCAnY21wKSB0XG5cbiAgKCoqXG4gICAgIHtbXG4gICAgICAgcGFydGl0aW9uaV90ZiB0IH5mXG4gICAgICAgPVxuICAgICAgIHBhcnRpdGlvbl9tYXBpIHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+XG4gICAgICAgICBpZiBmIH5rZXkgfmRhdGFcbiAgICAgICAgIHRoZW4gRmlyc3QgZGF0YVxuICAgICAgICAgZWxzZSBTZWNvbmQgZGF0YSlcbiAgICAgXX0gKilcbiAgdmFsIHBhcnRpdGlvbmlfdGZcbiAgICA6ICAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YgLT4gYm9vbClcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0ICogKCdrLCAndiwgJ2NtcCkgdFxuXG4gICgqKiBbcGFydGl0aW9uX3RmIHQgfmYgPSBwYXJ0aXRpb25pX3RmIHQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKV0gKilcbiAgdmFsIHBhcnRpdGlvbl90ZlxuICAgIDogICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBmOigndiAtPiBib29sKVxuICAgIC0+ICgnaywgJ3YsICdjbXApIHQgKiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgKCoqIFByb2R1Y2VzIFtPa10gb2YgYSBtYXAgaW5jbHVkaW5nIGFsbCBrZXlzIGlmIGFsbCBkYXRhIGlzIFtPa10sIG9yIGFuIFtFcnJvcl1cbiAgICAgIGluY2x1ZGluZyBhbGwgZXJyb3JzIG90aGVyd2lzZS4gKilcbiAgdmFsIGNvbWJpbmVfZXJyb3JzIDogKCdrLCAndiBPcl9lcnJvci50LCAnY21wKSB0IC0+ICgnaywgJ3YsICdjbXApIHQgT3JfZXJyb3IudFxuXG4gICgqKiBSZXR1cm5zIGEgdG90YWwgb3JkZXJpbmcgYmV0d2VlbiBtYXBzLiBUaGUgZmlyc3QgYXJndW1lbnQgaXMgYSB0b3RhbCBvcmRlcmluZyB1c2VkXG4gICAgICB0byBjb21wYXJlIGRhdGEgYXNzb2NpYXRlZCB3aXRoIGVxdWFsIGtleXMgaW4gdGhlIHR3byBtYXBzLiAqKVxuICB2YWwgY29tcGFyZV9kaXJlY3QgOiAoJ3YgLT4gJ3YgLT4gaW50KSAtPiAoJ2ssICd2LCAnY21wKSB0IC0+ICgnaywgJ3YsICdjbXApIHQgLT4gaW50XG5cbiAgKCoqIEhhc2ggZnVuY3Rpb246IGEgYnVpbGRpbmcgYmxvY2sgdG8gdXNlIHdoZW4gaGFzaGluZyBkYXRhIHN0cnVjdHVyZXMgY29udGFpbmluZyBtYXBzIGluXG4gICAgICB0aGVtLiBbaGFzaF9mb2xkX2RpcmVjdCBoYXNoX2ZvbGRfa2V5XSBpcyBjb21wYXRpYmxlIHdpdGggW2NvbXBhcmVfZGlyZWN0XSBpZmZcbiAgICAgIFtoYXNoX2ZvbGRfa2V5XSBpcyBjb21wYXRpYmxlIHdpdGggWyhjb21wYXJhdG9yIG0pLmNvbXBhcmVdIG9mIHRoZSBtYXAgW21dIGJlaW5nXG4gICAgICBoYXNoZWQuICopXG4gIHZhbCBoYXNoX2ZvbGRfZGlyZWN0IDogJ2sgSGFzaC5mb2xkZXIgLT4gJ3YgSGFzaC5mb2xkZXIgLT4gKCdrLCAndiwgJ2NtcCkgdCBIYXNoLmZvbGRlclxuXG4gICgqKiBbZXF1YWwgY21wIG0xIG0yXSB0ZXN0cyB3aGV0aGVyIHRoZSBtYXBzIFttMV0gYW5kIFttMl0gYXJlIGVxdWFsLCB0aGF0IGlzLCBjb250YWluXG4gICAgICB0aGUgc2FtZSBrZXlzIGFuZCBhc3NvY2lhdGUgZWFjaCBrZXkgd2l0aCB0aGUgc2FtZSB2YWx1ZS4gIFtjbXBdIGlzIHRoZSBlcXVhbGl0eVxuICAgICAgcHJlZGljYXRlIHVzZWQgdG8gY29tcGFyZSB0aGUgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCB0aGUga2V5cy4gKilcbiAgdmFsIGVxdWFsIDogKCd2IC0+ICd2IC0+IGJvb2wpIC0+ICgnaywgJ3YsICdjbXApIHQgLT4gKCdrLCAndiwgJ2NtcCkgdCAtPiBib29sXG5cbiAgKCoqIFJldHVybnMgYSBsaXN0IG9mIHRoZSBrZXlzIGluIHRoZSBnaXZlbiBtYXAuICopXG4gIHZhbCBrZXlzIDogKCdrLCBfLCBfKSB0IC0+ICdrIGxpc3RcblxuICAoKiogUmV0dXJucyBhIGxpc3Qgb2YgdGhlIGRhdGEgaW4gdGhlIGdpdmVuIG1hcC4gKilcbiAgdmFsIGRhdGEgOiAoXywgJ3YsIF8pIHQgLT4gJ3YgbGlzdFxuXG4gICgqKiBDcmVhdGVzIGFuIGFzc29jaWF0aW9uIGxpc3QgZnJvbSB0aGUgZ2l2ZW4gbWFwLiAqKVxuICB2YWwgdG9fYWxpc3RcbiAgICA6ICA/a2V5X29yZGVyOlsgYEluY3JlYXNpbmcgfCBgRGVjcmVhc2luZyBdICgqKiBkZWZhdWx0IGlzIFtgSW5jcmVhc2luZ10gKilcbiAgICAtPiAoJ2ssICd2LCBfKSB0XG4gICAgLT4gKCdrICogJ3YpIGxpc3RcblxuICAoKiogezIgQWRkaXRpb25hbCBvcGVyYXRpb25zIG9uIG1hcHN9ICopXG5cbiAgKCoqIE1lcmdlcyB0d28gbWFwcy4gVGhlIHJ1bnRpbWUgaXMgTyhsZW5ndGgodDEpICsgbGVuZ3RoKHQyKSkuIFlvdSBzaG91bGRuJ3QgdXNlIHRoaXNcbiAgICAgIGZ1bmN0aW9uIHRvIG1lcmdlIGEgbGlzdCBvZiBtYXBzOyBjb25zaWRlciB1c2luZyBbbWVyZ2Vfc2tld2VkXSBpbnN0ZWFkLiAqKVxuICB2YWwgbWVyZ2VcbiAgICA6ICAoJ2ssICd2MSwgJ2NtcCkgdFxuICAgIC0+ICgnaywgJ3YyLCAnY21wKSB0XG4gICAgLT4gZjooa2V5OidrIC0+ICgndjEsICd2MikgTWVyZ2VfZWxlbWVudC50IC0+ICd2MyBvcHRpb24pXG4gICAgLT4gKCdrLCAndjMsICdjbXApIHRcblxuICAoKiogQSBzcGVjaWFsIGNhc2Ugb2YgW21lcmdlXSwgW21lcmdlX3NrZXdlZCB0MSB0Ml0gaXMgYSBtYXAgY29udGFpbmluZyBhbGwgdGhlXG4gICAgICBiaW5kaW5ncyBvZiBbdDFdIGFuZCBbdDJdLiBCaW5kaW5ncyB0aGF0IGFwcGVhciBpbiBib3RoIFt0MV0gYW5kIFt0Ml0gYXJlXG4gICAgICBjb21iaW5lZCBpbnRvIGEgc2luZ2xlIHZhbHVlIHVzaW5nIHRoZSBbY29tYmluZV0gZnVuY3Rpb24uIEluIGEgY2FsbFxuICAgICAgW2NvbWJpbmUgfmtleSB2MSB2Ml0sIHRoZSB2YWx1ZSBbdjFdIGNvbWVzIGZyb20gW3QxXSBhbmQgW3YyXSBmcm9tIFt0Ml0uXG5cbiAgICAgIFRoZSBydW50aW1lIG9mIFttZXJnZV9za2V3ZWRdIGlzIFtPKG1pbihsMSwgbDIpICogbG9nKG1heChsMSwgbDIpKSldLCB3aGVyZSBbbDFdIGlzXG4gICAgICB0aGUgbGVuZ3RoIG9mIFt0MV0gYW5kIFtsMl0gdGhlIGxlbmd0aCBvZiBbdDJdLiBUaGlzIGlzIGxpa2VseSB0byBiZSBmYXN0ZXIgdGhhblxuICAgICAgW21lcmdlXSB3aGVuIG9uZSBvZiB0aGUgbWFwcyBpcyBhIGxvdCBzbWFsbGVyLCBvciB3aGVuIHlvdSBtZXJnZSBhIGxpc3Qgb2YgbWFwcy4gKilcbiAgdmFsIG1lcmdlX3NrZXdlZFxuICAgIDogICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gY29tYmluZTooa2V5OidrIC0+ICd2IC0+ICd2IC0+ICd2KVxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcblxuICBtb2R1bGUgU3ltbWV0cmljX2RpZmZfZWxlbWVudCA6IHNpZ1xuICAgIHR5cGUgKCdrLCAndikgdCA9ICdrICogWyBgTGVmdCBvZiAndiB8IGBSaWdodCBvZiAndiB8IGBVbmVxdWFsIG9mICd2ICogJ3YgXVxuICAgIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlcXVhbCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gICAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TMiB3aXRoIHR5cGUgKCdrLCAndikgdCA6PSAoJ2ssICd2KSB0XG4gICAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuRXF1YWwuUzIgd2l0aCB0eXBlICgnaywgJ3YpIHQgOj0gKCdrLCAndikgdFxuICAgIGluY2x1ZGUgU2V4cGxpYjAuU2V4cGFibGUuUzIgd2l0aCB0eXBlICgnaywgJ3YpIHQgOj0gKCdrLCAndikgdFxuXG4gICAgdmFsIHRfc2V4cF9ncmFtbWFyXG4gICAgICA6ICAnayBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgICAgLT4gJ3YgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgICAgIC0+ICgnaywgJ3YpIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcblxuICAgIFtAQEBlbmRdXG4gIGVuZFxuXG4gICgqKiBbc3ltbWV0cmljX2RpZmYgdDEgdDIgfmRhdGFfZXF1YWxdIHJldHVybnMgYSBsaXN0IG9mIGNoYW5nZXMgYmV0d2VlbiBbdDFdIGFuZCBbdDJdLlxuICAgICAgSXQgaXMgaW50ZW5kZWQgdG8gYmUgZWZmaWNpZW50IGluIHRoZSBjYXNlIHdoZXJlIFt0MV0gYW5kIFt0Ml0gc2hhcmUgYSBsYXJnZSBhbW91bnRcbiAgICAgIG9mIHN0cnVjdHVyZS4gVGhlIGtleXMgaW4gdGhlIG91dHB1dCBzZXF1ZW5jZSB3aWxsIGJlIGluIHNvcnRlZCBvcmRlci5cblxuICAgICAgSXQgaXMgYXNzdW1lZCB0aGF0IFtkYXRhX2VxdWFsXSBpcyBhdCBsZWFzdCBhcyBlcXVhdGluZyBhcyBwaHlzaWNhbCBlcXVhbGl0eTogdGhhdFxuICAgICAgW3BoeXNfZXF1YWwgeCB5XSBpbXBsaWVzIFtkYXRhX2VxdWFsIHggeV0uIE90aGVyd2lzZSwgW3N5bW1ldHJpY19kaWZmXSBtYXkgYmVoYXZlIGluXG4gICAgICB1bmV4cGVjdGVkIHdheXMuIEZvciBleGFtcGxlLCB3aXRoIFt+ZGF0YV9lcXVhbDooZnVuIF8gXyAtPiBmYWxzZSldIGl0IGlzIE5PVFxuICAgICAgbmVjZXNzYXJpbHkgdGhlIGNhc2UgdGhlIHJlc3VsdGluZyBjaGFuZ2Ugc2VxdWVuY2Ugd2lsbCBjb250YWluIGFuIGVsZW1lbnRcbiAgICAgIFsoaywgYFVuZXF1YWwgXyldIGZvciBldmVyeSBrZXkgW2tdIHNoYXJlZCBieSBib3RoIG1hcHMuXG5cbiAgICAgIFdhcm5pbmc6IEZsb2F0IGVxdWFsaXR5IHZpb2xhdGVzIHRoaXMgcHJvcGVydHkhIFtwaHlzX2VxdWFsIEZsb2F0Lm5hbiBGbG9hdC5uYW5dIGlzXG4gICAgICB0cnVlLCBidXQgW0Zsb2F0Lig9KSBGbG9hdC5uYW4gRmxvYXQubmFuXSBpcyBmYWxzZS4gKilcbiAgdmFsIHN5bW1ldHJpY19kaWZmXG4gICAgOiAgKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBkYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgIC0+ICgnaywgJ3YpIFN5bW1ldHJpY19kaWZmX2VsZW1lbnQudCBTZXF1ZW5jZS50XG5cbiAgKCoqIFtmb2xkX3N5bW1ldHJpY19kaWZmIHQxIHQyIH5kYXRhX2VxdWFsXSBmb2xkcyBhY3Jvc3MgYW4gaW1wbGljaXQgc2VxdWVuY2Ugb2YgY2hhbmdlc1xuICAgICAgYmV0d2VlbiBbdDFdIGFuZCBbdDJdLCBpbiBzb3J0ZWQgb3JkZXIgYnkga2V5cy4gRXF1aXZhbGVudCB0b1xuICAgICAgW1NlcXVlbmNlLmZvbGQgKHN5bW1ldHJpY19kaWZmIHQxIHQyIH5kYXRhX2VxdWFsKV0sIGFuZCBtb3JlIGVmZmljaWVudC4gKilcbiAgdmFsIGZvbGRfc3ltbWV0cmljX2RpZmZcbiAgICA6ICAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IGRhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgLT4gaW5pdDonYVxuICAgIC0+IGY6KCdhIC0+ICgnaywgJ3YpIFN5bW1ldHJpY19kaWZmX2VsZW1lbnQudCAtPiAnYSlcbiAgICAtPiAnYVxuXG4gICgqKiBbbWluX2VsdCBtYXBdIHJldHVybnMgW1NvbWUgKGtleSwgZGF0YSldIHBhaXIgY29ycmVzcG9uZGluZyB0byB0aGUgbWluaW11bSBrZXkgaW5cbiAgICAgIFttYXBdLCBvciBbTm9uZV0gaWYgZW1wdHkuICopXG4gIHZhbCBtaW5fZWx0IDogKCdrLCAndiwgXykgdCAtPiAoJ2sgKiAndikgb3B0aW9uXG5cbiAgdmFsIG1pbl9lbHRfZXhuIDogKCdrLCAndiwgXykgdCAtPiAnayAqICd2XG5cbiAgKCoqIFttYXhfZWx0IG1hcF0gcmV0dXJucyBbU29tZSAoa2V5LCBkYXRhKV0gcGFpciBjb3JyZXNwb25kaW5nIHRvIHRoZSBtYXhpbXVtIGtleSBpblxuICAgICAgW21hcF0sIG9yIFtOb25lXSBpZiBbbWFwXSBpcyBlbXB0eS4gKilcbiAgdmFsIG1heF9lbHQgOiAoJ2ssICd2LCBfKSB0IC0+ICgnayAqICd2KSBvcHRpb25cblxuICB2YWwgbWF4X2VsdF9leG4gOiAoJ2ssICd2LCBfKSB0IC0+ICdrICogJ3ZcblxuICAoKiogVGhlc2UgZnVuY3Rpb25zIGhhdmUgdGhlIHNhbWUgc2VtYW50aWNzIGFzIHNpbWlsYXIgZnVuY3Rpb25zIGluIFtMaXN0XS4gKilcblxuICB2YWwgZm9yX2FsbCA6ICgnaywgJ3YsIF8pIHQgLT4gZjooJ3YgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZm9yX2FsbGkgOiAoJ2ssICd2LCBfKSB0IC0+IGY6KGtleTonayAtPiBkYXRhOid2IC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGV4aXN0cyA6ICgnaywgJ3YsIF8pIHQgLT4gZjooJ3YgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZXhpc3RzaSA6ICgnaywgJ3YsIF8pIHQgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgY291bnQgOiAoJ2ssICd2LCBfKSB0IC0+IGY6KCd2IC0+IGJvb2wpIC0+IGludFxuICB2YWwgY291bnRpIDogKCdrLCAndiwgXykgdCAtPiBmOihrZXk6J2sgLT4gZGF0YTondiAtPiBib29sKSAtPiBpbnRcblxuXG4gICgqKiBbc3BsaXQgdCBrZXldIHJldHVybnMgYSBtYXAgb2Yga2V5cyBzdHJpY3RseSBsZXNzIHRoYW4gW2tleV0sIHRoZSBtYXBwaW5nIG9mIFtrZXldIGlmXG4gICAgICBhbnksIGFuZCBhIG1hcCBvZiBrZXlzIHN0cmljdGx5IGdyZWF0ZXIgdGhhbiBba2V5XS5cblxuICAgICAgUnVudGltZSBpcyBPKG0gKyBsb2cgbiksIHdoZXJlIG4gaXMgdGhlIHNpemUgb2YgdGhlIGlucHV0IG1hcCBhbmQgbSBpcyB0aGUgc2l6ZSBvZlxuICAgICAgdGhlIHNtYWxsZXIgb2YgdGhlIHR3byBvdXRwdXQgbWFwcy4gIFRoZSBPKG0pIHRlcm0gaXMgZHVlIHRvIHRoZSBuZWVkIHRvIGNhbGN1bGF0ZVxuICAgICAgdGhlIGxlbmd0aCBvZiB0aGUgb3V0cHV0IG1hcHMuICopXG4gIHZhbCBzcGxpdFxuICAgIDogICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiAna1xuICAgIC0+ICgnaywgJ3YsICdjbXApIHQgKiAoJ2sgKiAndikgb3B0aW9uICogKCdrLCAndiwgJ2NtcCkgdFxuXG4gICgqKiBbYXBwZW5kIH5sb3dlcl9wYXJ0IH51cHBlcl9wYXJ0XSByZXR1cm5zIFtgT2sgbWFwXSB3aGVyZSBbbWFwXSBjb250YWlucyBhbGwgdGhlXG4gICAgICBbKGtleSwgdmFsdWUpXSBwYWlycyBmcm9tIHRoZSB0d28gaW5wdXQgbWFwcyBpZiBhbGwgdGhlIGtleXMgZnJvbSBbbG93ZXJfcGFydF0gYXJlXG4gICAgICBsZXNzIHRoYW4gYWxsIHRoZSBrZXlzIGZyb20gW3VwcGVyX3BhcnRdLiAgT3RoZXJ3aXNlIGl0IHJldHVybnNcbiAgICAgIFtgT3ZlcmxhcHBpbmdfa2V5X3Jhbmdlc10uXG5cbiAgICAgIFJ1bnRpbWUgaXMgTyhsb2cgbikgd2hlcmUgbiBpcyB0aGUgc2l6ZSBvZiB0aGUgbGFyZ2VyIGlucHV0IG1hcC4gIFRoaXMgY2FuIGJlXG4gICAgICBzaWduaWZpY2FudGx5IGZhc3RlciB0aGFuIFtNYXAubWVyZ2VdIG9yIHJlcGVhdGVkIFtNYXAuYWRkXS5cblxuICAgICAge1tcbiAgICAgICAgYXNzZXJ0IChtYXRjaCBNYXAuYXBwZW5kIH5sb3dlcl9wYXJ0IH51cHBlcl9wYXJ0IHdpdGhcbiAgICAgICAgICB8IGBPayB3aG9sZV9tYXAgLT5cbiAgICAgICAgICAgIE1hcC50b19hbGlzdCB3aG9sZV9tYXBcbiAgICAgICAgICAgID0gTGlzdC5hcHBlbmQgKHRvX2FsaXN0IGxvd2VyX3BhcnQpICh0b19hbGlzdCB1cHBlcl9wYXJ0KVxuICAgICAgICAgIHwgYE92ZXJsYXBwaW5nX2tleV9yYW5nZXMgLT4gdHJ1ZSk7XG4gICAgICBdfSAqKVxuICB2YWwgYXBwZW5kXG4gICAgOiAgbG93ZXJfcGFydDooJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gdXBwZXJfcGFydDooJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gWyBgT2sgb2YgKCdrLCAndiwgJ2NtcCkgdCB8IGBPdmVybGFwcGluZ19rZXlfcmFuZ2VzIF1cblxuICAoKiogW3N1YnJhbmdlIHQgfmxvd2VyX2JvdW5kIH51cHBlcl9ib3VuZF0gcmV0dXJucyBhIG1hcCBjb250YWluaW5nIGFsbCB0aGUgZW50cmllcyBmcm9tXG4gICAgICBbdF0gd2hvc2Uga2V5cyBsaWUgaW5zaWRlIHRoZSBpbnRlcnZhbCBpbmRpY2F0ZWQgYnkgW35sb3dlcl9ib3VuZF0gYW5kXG4gICAgICBbfnVwcGVyX2JvdW5kXS4gIElmIHRoaXMgaW50ZXJ2YWwgaXMgZW1wdHksIGFuIGVtcHR5IG1hcCBpcyByZXR1cm5lZC5cblxuICAgICAgUnVudGltZSBpcyBPKG0gKyBsb2cgbiksIHdoZXJlIG4gaXMgdGhlIHNpemUgb2YgdGhlIGlucHV0IG1hcCBhbmQgbSBpcyB0aGUgc2l6ZSBvZlxuICAgICAgdGhlIG91dHB1dCBtYXAuICBUaGUgTyhtKSB0ZXJtIGlzIGR1ZSB0byB0aGUgbmVlZCB0byBjYWxjdWxhdGUgdGhlIGxlbmd0aCBvZiB0aGVcbiAgICAgIG91dHB1dCBtYXAuICopXG4gIHZhbCBzdWJyYW5nZVxuICAgIDogICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBsb3dlcl9ib3VuZDonayBNYXliZV9ib3VuZC50XG4gICAgLT4gdXBwZXJfYm91bmQ6J2sgTWF5YmVfYm91bmQudFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcblxuICAoKiogW2ZvbGRfcmFuZ2VfaW5jbHVzaXZlIHQgfm1pbiB+bWF4IH5pbml0IH5mXSBmb2xkcyBbZl0gKHdpdGggaW5pdGlhbCB2YWx1ZSBbfmluaXRdKVxuICAgICAgb3ZlciBhbGwga2V5cyAoYW5kIHRoZWlyIGFzc29jaWF0ZWQgdmFsdWVzKSB0aGF0IGFyZSBpbiB0aGUgcmFuZ2UgW1ttaW4sIG1heF1dXG4gICAgICAoaW5jbHVzaXZlKS4gICopXG4gIHZhbCBmb2xkX3JhbmdlX2luY2x1c2l2ZVxuICAgIDogICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBtaW46J2tcbiAgICAtPiBtYXg6J2tcbiAgICAtPiBpbml0OidhXG4gICAgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YgLT4gJ2EgLT4gJ2EpXG4gICAgLT4gJ2FcblxuICAoKiogW3JhbmdlX3RvX2FsaXN0IHQgfm1pbiB+bWF4XSByZXR1cm5zIGFuIGFzc29jaWF0aXZlIGxpc3Qgb2YgdGhlIGVsZW1lbnRzIHdob3NlIGtleXNcbiAgICAgIGxpZSBpbiBbW21pbiwgbWF4XV0gKGluY2x1c2l2ZSksIHdpdGggdGhlIHNtYWxsZXN0IGtleSBiZWluZyBhdCB0aGUgaGVhZCBvZiB0aGVcbiAgICAgIGxpc3QuICopXG4gIHZhbCByYW5nZV90b19hbGlzdCA6ICgnaywgJ3YsICdjbXApIHQgLT4gbWluOidrIC0+IG1heDonayAtPiAoJ2sgKiAndikgbGlzdFxuXG4gICgqKiBbY2xvc2VzdF9rZXkgdCBkaXIga10gcmV0dXJucyB0aGUgWyhrZXksIHZhbHVlKV0gcGFpciBpbiBbdF0gd2l0aCBba2V5XSBjbG9zZXN0IHRvXG4gICAgICBba10gdGhhdCBzYXRpc2ZpZXMgdGhlIGdpdmVuIGluZXF1YWxpdHkgYm91bmQuXG5cbiAgICAgIEZvciBleGFtcGxlLCBbY2xvc2VzdF9rZXkgdCBgTGVzc190aGFuIGtdIHdvdWxkIGJlIHRoZSBwYWlyIHdpdGggdGhlIGNsb3Nlc3Qga2V5IHRvXG4gICAgICBba10gd2hlcmUgW2tleSA8IGtdLlxuXG4gICAgICBbdG9fc2VxdWVuY2VdIGNhbiBiZSB1c2VkIHRvIGdldCB0aGUgc2FtZSByZXN1bHRzIGFzIFtjbG9zZXN0X2tleV0uICBJdCBpcyBsZXNzXG4gICAgICBlZmZpY2llbnQgZm9yIGluZGl2aWR1YWwgbG9va3VwcyBidXQgbW9yZSBlZmZpY2llbnQgZm9yIGZpbmRpbmcgbWFueSBlbGVtZW50cyBzdGFydGluZ1xuICAgICAgYXQgc29tZSB2YWx1ZS4gKilcbiAgdmFsIGNsb3Nlc3Rfa2V5XG4gICAgOiAgKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IFsgYEdyZWF0ZXJfb3JfZXF1YWxfdG8gfCBgR3JlYXRlcl90aGFuIHwgYExlc3Nfb3JfZXF1YWxfdG8gfCBgTGVzc190aGFuIF1cbiAgICAtPiAna1xuICAgIC0+ICgnayAqICd2KSBvcHRpb25cblxuICAoKiogW250aCB0IG5dIGZpbmRzIHRoZSAoa2V5LCB2YWx1ZSkgcGFpciBvZiByYW5rIG4gKGkuZS4sIHN1Y2ggdGhhdCB0aGVyZSBhcmUgZXhhY3RseSBuXG4gICAgICBrZXlzIHN0cmljdGx5IGxlc3MgdGhhbiB0aGUgZm91bmQga2V5KSwgaWYgb25lIGV4aXN0cy4gIE8obG9nKGxlbmd0aCB0KSArIG4pIHRpbWUuICopXG4gIHZhbCBudGggOiAoJ2ssICd2LCBfKSB0IC0+IGludCAtPiAoJ2sgKiAndikgb3B0aW9uXG5cbiAgdmFsIG50aF9leG4gOiAoJ2ssICd2LCBfKSB0IC0+IGludCAtPiAnayAqICd2XG5cbiAgKCoqIFtyYW5rIHQga10gSWYgW2tdIGlzIGluIFt0XSwgcmV0dXJucyB0aGUgbnVtYmVyIG9mIGtleXMgc3RyaWN0bHkgbGVzcyB0aGFuIFtrXSBpblxuICAgICAgW3RdLCBhbmQgW05vbmVdIG90aGVyd2lzZS4gKilcbiAgdmFsIHJhbmsgOiAoJ2ssICd2LCAnY21wKSB0IC0+ICdrIC0+IGludCBvcHRpb25cblxuXG5cbiAgKCoqIFt0b19zZXF1ZW5jZSA/b3JkZXIgP2tleXNfZ3JlYXRlcl9vcl9lcXVhbF90byA/a2V5c19sZXNzX29yX2VxdWFsX3RvIHRdXG4gICAgICBnaXZlcyBhIHNlcXVlbmNlIG9mIGtleS12YWx1ZSBwYWlycyBiZXR3ZWVuIFtrZXlzX2xlc3Nfb3JfZXF1YWxfdG9dIGFuZFxuICAgICAgW2tleXNfZ3JlYXRlcl9vcl9lcXVhbF90b10gaW5jbHVzaXZlLCBwcmVzZW50ZWQgaW4gW29yZGVyXS4gIElmXG4gICAgICBba2V5c19ncmVhdGVyX29yX2VxdWFsX3RvID4ga2V5c19sZXNzX29yX2VxdWFsX3RvXSwgdGhlIHNlcXVlbmNlIGlzXG4gICAgICBlbXB0eS5cblxuICAgICAgV2hlbiBuZWl0aGVyIFtrZXlzX2dyZWF0ZXJfb3JfZXF1YWxfdG9dIG5vciBba2V5c19sZXNzX29yX2VxdWFsX3RvXSBhcmVcbiAgICAgIHByb3ZpZGVkLCB0aGUgY29zdCBpcyBPKGxvZyBuKSB1cCBmcm9udCBhbmQgYW1vcnRpemVkIE8oMSkgdG8gcHJvZHVjZVxuICAgICAgZWFjaCBlbGVtZW50LiBJZiBlaXRoZXIgaXMgcHJvdmlkZWQgKGFuZCBpcyB1c2VkIGJ5IHRoZSBvcmRlciBwYXJhbWV0ZXJcbiAgICAgIHByb3ZpZGVkKSwgdGhlbiB0aGUgdGhlIGNvc3QgaXMgTyhuKSB1cCBmcm9udCwgYW5kIGFtb3J0aXplZCBPKDEpIHRvXG4gICAgICBwcm9kdWNlIGVhY2ggZWxlbWVudC4gKilcbiAgdmFsIHRvX3NlcXVlbmNlXG4gICAgOiAgP29yZGVyOlsgYEluY3JlYXNpbmdfa2V5ICgqKiBkZWZhdWx0ICopIHwgYERlY3JlYXNpbmdfa2V5IF1cbiAgICAtPiA/a2V5c19ncmVhdGVyX29yX2VxdWFsX3RvOidrXG4gICAgLT4gP2tleXNfbGVzc19vcl9lcXVhbF90bzona1xuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiAoJ2sgKiAndikgU2VxdWVuY2UudFxuXG4gICgqKiBbYmluYXJ5X3NlYXJjaCB0IH5jb21wYXJlIHdoaWNoIGVsdF0gcmV0dXJucyB0aGUgWyhrZXksIHZhbHVlKV0gcGFpciBpbiBbdF1cbiAgICAgIHNwZWNpZmllZCBieSBbY29tcGFyZV0gYW5kIFt3aGljaF0sIGlmIG9uZSBleGlzdHMuXG5cbiAgICAgIFt0XSBtdXN0IGJlIHNvcnRlZCBpbiBpbmNyZWFzaW5nIG9yZGVyIGFjY29yZGluZyB0byBbY29tcGFyZV0sIHdoZXJlIFtjb21wYXJlXSBhbmRcbiAgICAgIFtlbHRdIGRpdmlkZSBbdF0gaW50byB0aHJlZSAocG9zc2libHkgZW1wdHkpIHNlZ21lbnRzOlxuXG4gICAgICB7dlxuICAgICAgICB8ICA8IGVsdCAgfCAgPSBlbHQgIHwgID4gZWx0ICB8XG4gICAgICB2fVxuXG4gICAgICBbYmluYXJ5X3NlYXJjaF0gcmV0dXJucyBhbiBlbGVtZW50IG9uIHRoZSBib3VuZGFyeSBvZiBzZWdtZW50cyBhcyBzcGVjaWZpZWQgYnlcbiAgICAgIFt3aGljaF0uICBTZWUgdGhlIGRpYWdyYW0gYmVsb3cgbmV4dCB0byB0aGUgW3doaWNoXSB2YXJpYW50cy5cblxuICAgICAgW2JpbmFyeV9zZWFyY2hdIGRvZXMgbm90IGNoZWNrIHRoYXQgW2NvbXBhcmVdIG9yZGVycyBbdF0sIGFuZCBiZWhhdmlvciBpc1xuICAgICAgdW5zcGVjaWZpZWQgaWYgW2NvbXBhcmVdIGRvZXNuJ3Qgb3JkZXIgW3RdLiAgQmVoYXZpb3IgaXMgYWxzbyB1bnNwZWNpZmllZCBpZlxuICAgICAgW2NvbXBhcmVdIG11dGF0ZXMgW3RdLiAqKVxuICB2YWwgYmluYXJ5X3NlYXJjaFxuICAgIDogICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBjb21wYXJlOihrZXk6J2sgLT4gZGF0YTondiAtPiAna2V5IC0+IGludClcbiAgICAtPiBbIGBMYXN0X3N0cmljdGx5X2xlc3NfdGhhbiAoKiogICAgICAgIHt2IHwgPCBlbHQgWCB8ICAgICAgICAgICAgICAgICAgICAgICB2fSAqKVxuICAgICAgIHwgYExhc3RfbGVzc190aGFuX29yX2VxdWFsX3RvICgqKiAgICAge3YgfCAgICAgIDw9IGVsdCAgICAgICBYIHwgICAgICAgICAgIHZ9ICopXG4gICAgICAgfCBgTGFzdF9lcXVhbF90byAoKiogICAgICAgICAgICAgICAgICB7diAgICAgICAgICAgfCAgID0gZWx0IFggfCAgICAgICAgICAgdn0gKilcbiAgICAgICB8IGBGaXJzdF9lcXVhbF90byAoKiogICAgICAgICAgICAgICAgIHt2ICAgICAgICAgICB8IFggPSBlbHQgICB8ICAgICAgICAgICB2fSAqKVxuICAgICAgIHwgYEZpcnN0X2dyZWF0ZXJfdGhhbl9vcl9lcXVhbF90byAoKioge3YgICAgICAgICAgIHwgWCAgICAgICA+PSBlbHQgICAgICB8IHZ9ICopXG4gICAgICAgfCBgRmlyc3Rfc3RyaWN0bHlfZ3JlYXRlcl90aGFuICgqKiAgICB7diAgICAgICAgICAgICAgICAgICAgICAgfCBYID4gZWx0IHwgdn0gKilcbiAgICAgICBdXG4gICAgLT4gJ2tleVxuICAgIC0+ICgnayAqICd2KSBvcHRpb25cblxuICAoKiogW2JpbmFyeV9zZWFyY2hfc2VnbWVudGVkIHQgfnNlZ21lbnRfb2Ygd2hpY2hdIHRha2VzIGEgW3NlZ21lbnRfb2ZdIGZ1bmN0aW9uIHRoYXRcbiAgICAgIGRpdmlkZXMgW3RdIGludG8gdHdvIChwb3NzaWJseSBlbXB0eSkgc2VnbWVudHM6XG5cbiAgICAgIHt2XG4gICAgICAgIHwgc2VnbWVudF9vZiBlbHQgPSBgTGVmdCB8IHNlZ21lbnRfb2YgZWx0ID0gYFJpZ2h0IHxcbiAgICAgIHZ9XG5cbiAgICAgIFtiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZF0gcmV0dXJucyB0aGUgWyhrZXksIHZhbHVlKV0gcGFpciBvbiB0aGUgYm91bmRhcnkgb2YgdGhlXG4gICAgICBzZWdtZW50cyBhcyBzcGVjaWZpZWQgYnkgW3doaWNoXTogW2BMYXN0X29uX2xlZnRdIHlpZWxkcyB0aGUgbGFzdCBlbGVtZW50IG9mIHRoZVxuICAgICAgbGVmdCBzZWdtZW50LCB3aGlsZSBbYEZpcnN0X29uX3JpZ2h0XSB5aWVsZHMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIHJpZ2h0IHNlZ21lbnQuXG4gICAgICBJdCByZXR1cm5zIFtOb25lXSBpZiB0aGUgc2VnbWVudCBpcyBlbXB0eS5cblxuICAgICAgW2JpbmFyeV9zZWFyY2hfc2VnbWVudGVkXSBkb2VzIG5vdCBjaGVjayB0aGF0IFtzZWdtZW50X29mXSBzZWdtZW50cyBbdF0gYXMgaW4gdGhlXG4gICAgICBkaWFncmFtLCBhbmQgYmVoYXZpb3IgaXMgdW5zcGVjaWZpZWQgaWYgW3NlZ21lbnRfb2ZdIGRvZXNuJ3Qgc2VnbWVudCBbdF0uICBCZWhhdmlvclxuICAgICAgaXMgYWxzbyB1bnNwZWNpZmllZCBpZiBbc2VnbWVudF9vZl0gbXV0YXRlcyBbdF0uICopXG4gIHZhbCBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZFxuICAgIDogICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBzZWdtZW50X29mOihrZXk6J2sgLT4gZGF0YTondiAtPiBbIGBMZWZ0IHwgYFJpZ2h0IF0pXG4gICAgLT4gWyBgTGFzdF9vbl9sZWZ0IHwgYEZpcnN0X29uX3JpZ2h0IF1cbiAgICAtPiAoJ2sgKiAndikgb3B0aW9uXG5cbiAgKCoqIFtiaW5hcnlfc2VhcmNoX3N1YnJhbmdlXSB0YWtlcyBhIFtjb21wYXJlXSBmdW5jdGlvbiB0aGF0IGRpdmlkZXMgW3RdIGludG8gdGhyZWVcbiAgICAgIChwb3NzaWJseSBlbXB0eSkgc2VnbWVudHMgd2l0aCByZXNwZWN0IHRvIFtsb3dlcl9ib3VuZF0gYW5kIFt1cHBlcl9ib3VuZF06XG5cbiAgICAgIHt2XG4gICAgICAgIHwgQmVsb3dfbG93ZXJfYm91bmQgfCBJbl9yYW5nZSB8IEFib3ZlX3VwcGVyX2JvdW5kIHxcbiAgICAgIHZ9XG5cbiAgICAgIGFuZCByZXR1cm5zIGEgbWFwIG9mIHRoZSBbSW5fcmFuZ2VdIHNlZ21lbnQuXG5cbiAgICAgIFJ1bnRpbWUgaXMgTyhsb2cgbSArIG4pIHdoZXJlIFttXSBpcyB0aGUgbGVuZ3RoIG9mIHRoZSBpbnB1dCBtYXAgYW5kIFtuXSBpcyB0aGVcbiAgICAgIGxlbmd0aCBvZiB0aGUgb3V0cHV0LiBUaGUgbGluZWFyIHRlcm0gaW4gW25dIGlzIHRvIGNvbXB1dGUgdGhlIGxlbmd0aCBvZiB0aGUgb3V0cHV0LlxuXG4gICAgICBCZWhhdmlvciBpcyB1bmRlZmluZWQgaWYgW2NvbXBhcmVdIGRvZXMgbm90IHNlZ21lbnQgW3RdIGFzIHNob3duIGFib3ZlLCBvciBpZlxuICAgICAgW2NvbXBhcmVdIG11dGF0ZXMgaXRzIGlucHV0cy4gKilcbiAgdmFsIGJpbmFyeV9zZWFyY2hfc3VicmFuZ2VcbiAgICA6ICAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gY29tcGFyZTooa2V5OidrIC0+IGRhdGE6J3YgLT4gJ2JvdW5kIC0+IGludClcbiAgICAtPiBsb3dlcl9ib3VuZDonYm91bmQgTWF5YmVfYm91bmQudFxuICAgIC0+IHVwcGVyX2JvdW5kOidib3VuZCBNYXliZV9ib3VuZC50XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gICgqKiBbTV0gaXMgbWVhbnQgdG8gYmUgdXNlZCBpbiBjb21iaW5hdGlvbiB3aXRoIE9DYW1sIGFwcGxpY2F0aXZlIGZ1bmN0b3IgdHlwZXM6XG5cbiAgICAgIHtbXG4gICAgICAgIHR5cGUgc3RyaW5nX3RvX2ludF9tYXAgPSBpbnQgTWFwLk0oU3RyaW5nKS50XG4gICAgICBdfVxuXG4gICAgICB3aGljaCBzdGFuZHMgZm9yOlxuXG4gICAgICB7W1xuICAgICAgICB0eXBlIHN0cmluZ190b19pbnRfbWFwID0gKFN0cmluZy50LCBpbnQsIFN0cmluZy5jb21wYXJhdG9yX3dpdG5lc3MpIE1hcC50XG4gICAgICBdfVxuXG4gICAgICBUaGUgcG9pbnQgaXMgdGhhdCBbaW50IE1hcC5NKFN0cmluZykudF0gc3VwcG9ydHMgZGVyaXZpbmcsIHdoZXJlYXMgdGhlIHNlY29uZCBzeW50YXhcbiAgICAgIGRvZXNuJ3QgKGJlY2F1c2UgdGhlcmUgaXMgbm8gc3VjaCB0aGluZyBhcywgc2F5LCBbU3RyaW5nLnNleHBfb2ZfY29tcGFyYXRvcl93aXRuZXNzXVxuICAgICAgLS0gaW5zdGVhZCB5b3Ugd291bGQgd2FudCB0byBwYXNzIHRoZSBjb21wYXJhdG9yIGRpcmVjdGx5KS5cblxuICAgICAgSW4gYWRkaXRpb24sIHdoZW4gdXNpbmcgW0BAZGVyaXZpbmddLCB0aGUgcmVxdWlyZW1lbnRzIG9uIHRoZSBrZXkgbW9kdWxlIGFyZSBvbmx5XG4gICAgICB0aG9zZSBuZWVkZWQgdG8gc2F0aXNmeSB3aGF0IHlvdSBhcmUgdHJ5aW5nIHRvIGRlcml2ZSBvbiB0aGUgbWFwIGl0c2VsZi4gU2F5IHlvdVxuICAgICAgd3JpdGU6XG5cbiAgICAgIHtbXG4gICAgICAgIHR5cGUgdCA9IGludCBNYXAuTShYKS50IFtAQGRlcml2aW5nIGhhc2hdXG4gICAgICBdfVxuXG4gICAgICB0aGVuIHRoaXMgd2lsbCBiZSB3ZWxsIHR5cGVkIGV4YWN0bHkgaWYgW1hdIGNvbnRhaW5zIGF0IGxlYXN0OlxuICAgICAgLSBhIHR5cGUgW3RdIHdpdGggbm8gcGFyYW1ldGVyc1xuICAgICAgLSBhIGNvbXBhcmF0b3Igd2l0bmVzc1xuICAgICAgLSBhIFtoYXNoX2ZvbGRfdF0gZnVuY3Rpb24gd2l0aCB0aGUgcmlnaHQgdHlwZSAqKVxuICBtb2R1bGUgTSAoSyA6IHNpZ1xuICAgICAgdHlwZSB0XG4gICAgICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzc1xuICAgIGVuZCkgOiBzaWdcbiAgICB0eXBlIG5vbnJlYyAndiB0ID0gKEsudCwgJ3YsIEsuY29tcGFyYXRvcl93aXRuZXNzKSB0XG4gIGVuZFxuXG4gIGluY2x1ZGUgRm9yX2Rlcml2aW5nIHdpdGggdHlwZSAoJ2tleSwgJ3ZhbHVlLCAnY21wKSB0IDo9ICgna2V5LCAndmFsdWUsICdjbXApIHRcblxuICAoKiogW1VzaW5nX2NvbXBhcmF0b3JdIGlzIGEgc2ltaWxhciBpbnRlcmZhY2UgYXMgdGhlIHRvcGxldmVsIG9mIFtNYXBdLCBleGNlcHQgdGhlXG4gICAgICBmdW5jdGlvbnMgdGFrZSBhIFt+Y29tcGFyYXRvcjooJ2ssICdjbXApIENvbXBhcmF0b3IudF0sIHdoZXJlYXMgdGhlIGZ1bmN0aW9ucyBhdCB0aGVcbiAgICAgIHRvcGxldmVsIG9mIFtNYXBdIHRha2UgYSBbKCdrLCAnY21wKSBjb21wYXJhdG9yXS4gKilcbiAgbW9kdWxlIFVzaW5nX2NvbXBhcmF0b3IgOiBzaWdcbiAgICB0eXBlIG5vbnJlYyAoJ2ssICsndiwgJ2NtcCkgdCA9ICgnaywgJ3YsICdjbXApIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgICB2YWwgc2V4cF9vZl90XG4gICAgICA6ICAoJ2sgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgLT4gKCd2IC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgIC0+ICgnY21wIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAgIC0+IFNleHBsaWIwLlNleHAudFxuXG4gICAgW0BAQGVuZF1cblxuICAgIHZhbCB0X29mX3NleHBfZGlyZWN0XG4gICAgICA6ICBjb21wYXJhdG9yOignaywgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgICAtPiAoU2V4cC50IC0+ICdrKVxuICAgICAgLT4gKFNleHAudCAtPiAndilcbiAgICAgIC0+IFNleHAudFxuICAgICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gICAgbW9kdWxlIFRyZWUgOiBzaWdcbiAgICAgIHR5cGUgKCsnaywgKyd2LCAnY21wKSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gICAgICB2YWwgc2V4cF9vZl90XG4gICAgICAgIDogICgnayAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAgIC0+ICgndiAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAgIC0+ICgnY21wIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgICAgICAtPiBTZXhwbGliMC5TZXhwLnRcblxuICAgICAgW0BAQGVuZF1cblxuICAgICAgdmFsIHRfb2Zfc2V4cF9kaXJlY3RcbiAgICAgICAgOiAgY29tcGFyYXRvcjooJ2ssICdjbXApIENvbXBhcmF0b3IudFxuICAgICAgICAtPiAoU2V4cC50IC0+ICdrKVxuICAgICAgICAtPiAoU2V4cC50IC0+ICd2KVxuICAgICAgICAtPiBTZXhwLnRcbiAgICAgICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gICAgICBpbmNsdWRlXG4gICAgICAgIENyZWF0b3JzX2FuZF9hY2Nlc3NvcnMzX3dpdGhfY29tcGFyYXRvclxuICAgICAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHQgOj0gKCdhLCAnYiwgJ2MpIHRcbiAgICAgICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSB0cmVlIDo9ICgnYSwgJ2IsICdjKSB0XG5cbiAgICAgIHZhbCBlbXB0eV93aXRob3V0X3ZhbHVlX3Jlc3RyaWN0aW9uIDogKF8sIF8sIF8pIHRcblxuICAgICAgKCoqIFtCdWlsZF9pbmNyZWFzaW5nXSBjYW4gYmUgdXNlZCB0byBjb25zdHJ1Y3QgYSBtYXAgaW5jcmVtZW50YWxseSBmcm9tIGFcbiAgICAgICAgICBzZXF1ZW5jZSB0aGF0IGlzIGtub3duIHRvIGJlIGluY3JlYXNpbmcuXG5cbiAgICAgICAgICBUaGUgdG90YWwgdGltZSBjb21wbGV4aXR5IG9mIGNvbnN0cnVjdGluZyBhIG1hcCB0aGlzIHdheSBpcyBPKG4pLCB3aGljaCBpcyBtb3JlXG4gICAgICAgICAgZWZmaWNpZW50IHRoYW4gdXNpbmcgW01hcC5hZGRdIGJ5IGEgbG9nYXJpdGhtaWMgZmFjdG9yLlxuXG4gICAgICAgICAgVGhpcyBpbnRlcmZhY2UgY2FuIGJlIHRob3VnaHQgb2YgYXMgYSBkdWFsIG9mIFt0b19zZXF1ZW5jZV0sIGJ1dCB3ZSBkb24ndCBoYXZlXG4gICAgICAgICAgYW4gZXF1YWxseSBuZWF0IGlkaW9tIGZvciB0aGUgZHVhbHMgb2Ygc2VxdWVuY2VzIChbb2Zfc2VxdWVuY2VdIGlzIG11Y2ggbGVzc1xuICAgICAgICAgIGdlbmVyYWwgYmVjYXVzZSBpdCBkb2VzIG5vdCBhbGxvdyB0aGUgc2VxdWVuY2UgdG8gYmUgcHJvZHVjZWQgYXN5bmNocm9ub3VzbHkpLiAqKVxuICAgICAgbW9kdWxlIEJ1aWxkX2luY3JlYXNpbmcgOiBzaWdcbiAgICAgICAgdHlwZSAoJ2EsICdiLCAnYykgdHJlZSA6PSAoJ2EsICdiLCAnYykgdFxuICAgICAgICB0eXBlICgnaywgJ3YsICd3KSB0XG5cbiAgICAgICAgdmFsIGVtcHR5IDogKCdrLCAndiwgJ3cpIHRcblxuICAgICAgICAoKiogVGltZSBjb21wbGV4aXR5IG9mIFthZGRfZXhuXSBpcyBhbW9ydGl6ZWQgY29uc3RhbnQtdGltZSAoaWYgW3RdIGlzIHVzZWRcbiAgICAgICAgICAgIGxpbmVhcmx5KSwgd2l0aCBhIHdvcnN0LWNhc2UgTyhsb2cobikpIHRpbWUuICopXG4gICAgICAgIHZhbCBhZGRfZXhuXG4gICAgICAgICAgOiAgKCdrLCAndiwgJ3cpIHRcbiAgICAgICAgICAtPiBjb21wYXJhdG9yOignaywgJ3cpIENvbXBhcmF0b3IudFxuICAgICAgICAgIC0+IGtleTona1xuICAgICAgICAgIC0+IGRhdGE6J3ZcbiAgICAgICAgICAtPiAoJ2ssICd2LCAndykgdFxuXG4gICAgICAgICgqKiBUaW1lIGNvbXBsZXhpdHkgaXMgTyhsb2cobikpLiAqKVxuICAgICAgICB2YWwgdG9fdHJlZSA6ICgnaywgJ3YsICd3KSB0IC0+ICgnaywgJ3YsICd3KSB0cmVlXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGluY2x1ZGVcbiAgICAgIEFjY2Vzc29yczNcbiAgICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgdCA6PSAoJ2EsICdiLCAnYykgdFxuICAgICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSB0cmVlIDo9ICgnYSwgJ2IsICdjKSBUcmVlLnRcblxuICAgIGluY2x1ZGVcbiAgICAgIENyZWF0b3JzM193aXRoX2NvbXBhcmF0b3JcbiAgICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgdCA6PSAoJ2EsICdiLCAnYykgdFxuICAgICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSB0cmVlIDo9ICgnYSwgJ2IsICdjKSBUcmVlLnRcblxuICAgIHZhbCBjb21wYXJhdG9yIDogKCdhLCBfLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgQ29tcGFyYXRvci50XG5cbiAgICB2YWwgaGFzaF9mb2xkX2RpcmVjdFxuICAgICAgOiAgJ2sgSGFzaC5mb2xkZXJcbiAgICAgIC0+ICd2IEhhc2guZm9sZGVyXG4gICAgICAtPiAoJ2ssICd2LCAnY21wKSB0IEhhc2guZm9sZGVyXG5cbiAgICAoKiogVG8gZ2V0IGFyb3VuZCB0aGUgdmFsdWUgcmVzdHJpY3Rpb24sIGFwcGx5IHRoZSBmdW5jdG9yIGFuZCBpbmNsdWRlIGl0LiBZb3VcbiAgICAgICAgY2FuIHNlZSBhbiBleGFtcGxlIG9mIHRoaXMgaW4gdGhlIFtQb2x5XSBzdWJtb2R1bGUgYmVsb3cuICopXG4gICAgbW9kdWxlIEVtcHR5X3dpdGhvdXRfdmFsdWVfcmVzdHJpY3Rpb24gKEsgOiBDb21wYXJhdG9yLlMxKSA6IHNpZ1xuICAgICAgdmFsIGVtcHR5IDogKCdhIEsudCwgJ3YsIEsuY29tcGFyYXRvcl93aXRuZXNzKSB0XG4gICAgZW5kXG4gIGVuZFxuXG4gICgqKiBBIHBvbHltb3JwaGljIE1hcC4gKilcbiAgbW9kdWxlIFBvbHkgOlxuICAgIFNfcG9seVxuICAgIHdpdGggdHlwZSAoJ2tleSwgKyd2YWx1ZSkgdCA9ICgna2V5LCAndmFsdWUsIENvbXBhcmF0b3IuUG9seS5jb21wYXJhdG9yX3dpdG5lc3MpIHRcbiAgICAgYW5kIHR5cGUgKCdrZXksICsndmFsdWUpIHRyZWUgPVxuICAgICAgICAgICAoJ2tleSwgJ3ZhbHVlLCBDb21wYXJhdG9yLlBvbHkuY29tcGFyYXRvcl93aXRuZXNzKSBVc2luZ19jb21wYXJhdG9yLlRyZWUudFxuICAgICBhbmQgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSBDb21wYXJhdG9yLlBvbHkuY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgKCoqIENyZWF0ZSBhIG1hcCBmcm9tIGEgdHJlZSB1c2luZyB0aGUgZ2l2ZW4gY29tcGFyYXRvci4gKilcbiAgdmFsIG9mX3RyZWVcbiAgICA6ICAoJ2ssICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSBVc2luZ19jb21wYXJhdG9yLlRyZWUudFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcblxuICAoKiogRXh0cmFjdCBhIHRyZWUgZnJvbSBhIG1hcC4gKilcbiAgdmFsIHRvX3RyZWUgOiAoJ2ssICd2LCAnY21wKSB0IC0+ICgnaywgJ3YsICdjbXApIFVzaW5nX2NvbXBhcmF0b3IuVHJlZS50XG5cblxuICAoKiogezIgTW9kdWxlcyBhbmQgbW9kdWxlIHR5cGVzIGZvciBleHRlbmRpbmcgW01hcF19XG5cbiAgICAgIEZvciB1c2UgaW4gZXh0ZW5zaW9ucyBvZiBCYXNlLCBsaWtlIFtDb3JlXS4gKilcblxuICBtb2R1bGUgV2l0aF9jb21wYXJhdG9yID0gV2l0aF9jb21wYXJhdG9yXG4gIG1vZHVsZSBXaXRoX2ZpcnN0X2NsYXNzX21vZHVsZSA9IFdpdGhfZmlyc3RfY2xhc3NfbW9kdWxlXG4gIG1vZHVsZSBXaXRob3V0X2NvbXBhcmF0b3IgPSBXaXRob3V0X2NvbXBhcmF0b3JcblxuICBtb2R1bGUgdHlwZSBGb3JfZGVyaXZpbmcgPSBGb3JfZGVyaXZpbmdcbiAgbW9kdWxlIHR5cGUgU19wb2x5ID0gU19wb2x5XG4gIG1vZHVsZSB0eXBlIEFjY2Vzc29yczEgPSBBY2Nlc3NvcnMxXG4gIG1vZHVsZSB0eXBlIEFjY2Vzc29yczIgPSBBY2Nlc3NvcnMyXG4gIG1vZHVsZSB0eXBlIEFjY2Vzc29yczMgPSBBY2Nlc3NvcnMzXG4gIG1vZHVsZSB0eXBlIEFjY2Vzc29yczNfd2l0aF9jb21wYXJhdG9yID0gQWNjZXNzb3JzM193aXRoX2NvbXBhcmF0b3JcbiAgbW9kdWxlIHR5cGUgQWNjZXNzb3JzX2dlbmVyaWMgPSBBY2Nlc3NvcnNfZ2VuZXJpY1xuICBtb2R1bGUgdHlwZSBDcmVhdG9yczEgPSBDcmVhdG9yczFcbiAgbW9kdWxlIHR5cGUgQ3JlYXRvcnMyID0gQ3JlYXRvcnMyXG4gIG1vZHVsZSB0eXBlIENyZWF0b3JzM193aXRoX2NvbXBhcmF0b3IgPSBDcmVhdG9yczNfd2l0aF9jb21wYXJhdG9yXG4gIG1vZHVsZSB0eXBlIENyZWF0b3JzX2FuZF9hY2Nlc3NvcnMxID0gQ3JlYXRvcnNfYW5kX2FjY2Vzc29yczFcbiAgbW9kdWxlIHR5cGUgQ3JlYXRvcnNfYW5kX2FjY2Vzc29yczIgPSBDcmVhdG9yc19hbmRfYWNjZXNzb3JzMlxuXG4gIG1vZHVsZSB0eXBlIENyZWF0b3JzX2FuZF9hY2Nlc3NvcnMzX3dpdGhfY29tcGFyYXRvciA9XG4gICAgQ3JlYXRvcnNfYW5kX2FjY2Vzc29yczNfd2l0aF9jb21wYXJhdG9yXG5cbiAgbW9kdWxlIHR5cGUgQ3JlYXRvcnNfYW5kX2FjY2Vzc29yc19nZW5lcmljID0gQ3JlYXRvcnNfYW5kX2FjY2Vzc29yc19nZW5lcmljXG4gIG1vZHVsZSB0eXBlIENyZWF0b3JzX2dlbmVyaWMgPSBDcmVhdG9yc19nZW5lcmljXG5lbmRcbiIsIm9wZW4hIEltcG9ydFxuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICB0eXBlIHQgPSB8XG5cbiAgbGV0IHVucmVhY2hhYmxlX2NvZGUgPSBmdW5jdGlvblxuICAgIHwgKF8gOiB0KSAtPiAuXG4gIDs7XG5cbiAgbGV0IGFsbCA9IFtdXG4gIGxldCBoYXNoX2ZvbGRfdCBfIHQgPSB1bnJlYWNoYWJsZV9jb2RlIHRcbiAgbGV0IGhhc2ggPSB1bnJlYWNoYWJsZV9jb2RlXG4gIGxldCBjb21wYXJlIGEgXyA9IHVucmVhY2hhYmxlX2NvZGUgYVxuICBsZXQgc2V4cF9vZl90ID0gdW5yZWFjaGFibGVfY29kZVxuICBsZXQgdF9vZl9zZXhwIHNleHAgPSBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IuZW1wdHlfdHlwZSBcIkJhc2UuTm90aGluZy50XCIgc2V4cFxuICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSB7IHVudHlwZWQgPSBVbmlvbiBbXSB9XG4gIGxldCB0b19zdHJpbmcgPSB1bnJlYWNoYWJsZV9jb2RlXG4gIGxldCBvZl9zdHJpbmcgKF8gOiBzdHJpbmcpID0gZmFpbHdpdGggXCJCYXNlLk5vdGhpbmcub2Zfc3RyaW5nOiBub3Qgc3VwcG9ydGVkXCJcbmVuZFxuXG5pbmNsdWRlIFRcblxuaW5jbHVkZSBJZGVudGlmaWFibGUuTWFrZSAoc3RydWN0XG4gICAgaW5jbHVkZSBUXG5cbiAgICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuTm90aGluZ1wiXG4gIGVuZClcbiIsIm9wZW4hIEltcG9ydFxub3BlbiEgQ2FtbC5OYXRpdmVpbnRcbmluY2x1ZGUgTmF0aXZlaW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICB0eXBlIHQgPSBuYXRpdmVpbnQgW0BAZGVyaXZpbmdfaW5saW5lIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgaGFzaF9mb2xkX25hdGl2ZWludFxuXG4gIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IGhhc2hfbmF0aXZlaW50IGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cCA9IChuYXRpdmVpbnRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuICBsZXQgc2V4cF9vZl90ID0gKHNleHBfb2ZfbmF0aXZlaW50IDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IG5hdGl2ZWludF9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIGxldCBoYXNoYWJsZSA6IHQgSGFzaGFibGUudCA9IHsgaGFzaDsgY29tcGFyZTsgc2V4cF9vZl90IH1cbiAgbGV0IGNvbXBhcmUgPSBOYXRpdmVpbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLmNvbXBhcmVcbiAgbGV0IHRvX3N0cmluZyA9IHRvX3N0cmluZ1xuICBsZXQgb2Zfc3RyaW5nID0gb2Zfc3RyaW5nXG5lbmRcblxuaW5jbHVkZSBUXG5pbmNsdWRlIENvbXBhcmF0b3IuTWFrZSAoVClcblxuaW5jbHVkZSBDb21wYXJhYmxlLldpdGhfemVybyAoc3RydWN0XG4gICAgaW5jbHVkZSBUXG5cbiAgICBsZXQgemVybyA9IHplcm9cbiAgZW5kKVxuXG5tb2R1bGUgQ29udiA9IEludF9jb252ZXJzaW9uc1xuaW5jbHVkZSBDb252Lk1ha2UgKFQpXG5cbmluY2x1ZGUgQ29udi5NYWtlX2hleCAoc3RydWN0XG4gICAgb3BlbiBOYXRpdmVpbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbiAgICB0eXBlIHQgPSBuYXRpdmVpbnQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGhhc2hdXG5cbiAgICBsZXQgY29tcGFyZSA9IChjb21wYXJlX25hdGl2ZWludCA6IHQgLT4gdCAtPiBpbnQpXG5cbiAgICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgICBoYXNoX2ZvbGRfbmF0aXZlaW50XG5cbiAgICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgICBsZXQgZnVuYyA9IGhhc2hfbmF0aXZlaW50IGluXG4gICAgICBmdW4geCAtPiBmdW5jIHhcbiAgICA7O1xuXG4gICAgW0BAQGVuZF1cblxuICAgIGxldCB6ZXJvID0gemVyb1xuICAgIGxldCBuZWcgPSBuZWdcbiAgICBsZXQgKCA8ICkgPSAoIDwgKVxuICAgIGxldCB0b19zdHJpbmcgaSA9IFByaW50Zi5zcHJpbnRmIFwiJW54XCIgaVxuICAgIGxldCBvZl9zdHJpbmcgcyA9IENhbWwuU2NhbmYuc3NjYW5mIHMgXCIlbnhcIiBGbi5pZFxuICAgIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5OYXRpdmVpbnQuSGV4XCJcbiAgZW5kKVxuXG5pbmNsdWRlIFByZXR0eV9wcmludGVyLlJlZ2lzdGVyIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gICAgbGV0IHRvX3N0cmluZyA9IHRvX3N0cmluZ1xuICAgIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5OYXRpdmVpbnRcIlxuICBlbmQpXG5cbigqIE9wZW4gcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGFmdGVyIGluY2x1ZGluZyBmdW5jdG9yIGluc3RhbnRpYXRpb25zIHNvIHRoZXkgZG8gbm90XG4gICBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb25cbiAgIGZ1bmN0aW9ucyBhcmUgYXZhaWxhYmxlIHdpdGhpbiB0aGlzIG1vZHVsZS4gKilcbm9wZW4hIE5hdGl2ZWludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxubGV0IGludmFyaWFudCAoXyA6IHQpID0gKClcbmxldCBudW1fYml0cyA9IFdvcmRfc2l6ZS5udW1fYml0cyBXb3JkX3NpemUud29yZF9zaXplXG5sZXQgZmxvYXRfbG93ZXJfYm91bmQgPSBGbG9hdDAubG93ZXJfYm91bmRfZm9yX2ludCBudW1fYml0c1xubGV0IGZsb2F0X3VwcGVyX2JvdW5kID0gRmxvYXQwLnVwcGVyX2JvdW5kX2Zvcl9pbnQgbnVtX2JpdHNcbmxldCBzaGlmdF9yaWdodF9sb2dpY2FsID0gc2hpZnRfcmlnaHRfbG9naWNhbFxubGV0IHNoaWZ0X3JpZ2h0ID0gc2hpZnRfcmlnaHRcbmxldCBzaGlmdF9sZWZ0ID0gc2hpZnRfbGVmdFxubGV0IGJpdF9ub3QgPSBsb2dub3RcbmxldCBiaXRfeG9yID0gbG9neG9yXG5sZXQgYml0X29yID0gbG9nb3JcbmxldCBiaXRfYW5kID0gbG9nYW5kXG5sZXQgbWluX3ZhbHVlID0gbWluX2ludFxubGV0IG1heF92YWx1ZSA9IG1heF9pbnRcbmxldCBhYnMgPSBhYnNcbmxldCBwcmVkID0gcHJlZFxubGV0IHN1Y2MgPSBzdWNjXG5sZXQgcmVtID0gcmVtXG5sZXQgbmVnID0gbmVnXG5sZXQgbWludXNfb25lID0gbWludXNfb25lXG5sZXQgb25lID0gb25lXG5sZXQgemVybyA9IHplcm9cbmxldCB0b19mbG9hdCA9IHRvX2Zsb2F0XG5sZXQgb2ZfZmxvYXRfdW5jaGVja2VkID0gb2ZfZmxvYXRcblxubGV0IG9mX2Zsb2F0IGYgPVxuICBpZiBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA+PSApIGYgZmxvYXRfbG93ZXJfYm91bmRcbiAgJiYgRmxvYXRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPD0gKSBmIGZsb2F0X3VwcGVyX2JvdW5kXG4gIHRoZW4gb2ZfZmxvYXQgZlxuICBlbHNlXG4gICAgUHJpbnRmLmludmFsaWRfYXJnZlxuICAgICAgXCJOYXRpdmVpbnQub2ZfZmxvYXQ6IGFyZ3VtZW50ICglZikgaXMgb3V0IG9mIHJhbmdlIG9yIE5hTlwiXG4gICAgICAoRmxvYXQwLmJveCBmKVxuICAgICAgKClcbjs7XG5cbm1vZHVsZSBQb3cyID0gc3RydWN0XG4gIG9wZW4hIEltcG9ydFxuICBvcGVuIE5hdGl2ZWludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxuICBsZXQgcmFpc2VfcyA9IEVycm9yLnJhaXNlX3NcblxuICBsZXQgbm9uX3Bvc2l0aXZlX2FyZ3VtZW50ICgpID1cbiAgICBQcmludGYuaW52YWxpZF9hcmdmIFwiYXJndW1lbnQgbXVzdCBiZSBzdHJpY3RseSBwb3NpdGl2ZVwiICgpXG4gIDs7XG5cbiAgbGV0ICggbG9yICkgPSBDYW1sLk5hdGl2ZWludC5sb2dvclxuICBsZXQgKCBsc3IgKSA9IENhbWwuTmF0aXZlaW50LnNoaWZ0X3JpZ2h0X2xvZ2ljYWxcbiAgbGV0ICggbGFuZCApID0gQ2FtbC5OYXRpdmVpbnQubG9nYW5kXG5cbiAgKCoqIFwiY2VpbGluZyBwb3dlciBvZiAyXCIgLSBMZWFzdCBwb3dlciBvZiAyIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB4LiAqKVxuICBsZXQgY2VpbF9wb3cyICh4IDogbmF0aXZlaW50KSA9XG4gICAgaWYgeCA8PSAwbiB0aGVuIG5vbl9wb3NpdGl2ZV9hcmd1bWVudCAoKTtcbiAgICBsZXQgeCA9IENhbWwuTmF0aXZlaW50LnByZWQgeCBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDEpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMikgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciA0KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDgpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMTYpIGluXG4gICAgKCogVGhlIG5leHQgbGluZSBpcyBzdXBlcmZsdW91cyBvbiAzMi1iaXQgYXJjaGl0ZWN0dXJlcywgYnV0IGl0J3MgZmFzdGVyIHRvIGRvIGl0XG4gICAgICAgYW55d2F5IHRoYW4gdG8gYnJhbmNoICopXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMzIpIGluXG4gICAgQ2FtbC5OYXRpdmVpbnQuc3VjYyB4XG4gIDs7XG5cbiAgKCoqIFwiZmxvb3IgcG93ZXIgb2YgMlwiIC0gTGFyZ2VzdCBwb3dlciBvZiAyIGxlc3MgdGhhbiBvciBlcXVhbCB0byB4LiAqKVxuICBsZXQgZmxvb3JfcG93MiB4ID1cbiAgICBpZiB4IDw9IDBuIHRoZW4gbm9uX3Bvc2l0aXZlX2FyZ3VtZW50ICgpO1xuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDEpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMikgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciA0KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDgpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMTYpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMzIpIGluXG4gICAgQ2FtbC5OYXRpdmVpbnQuc3ViIHggKHggbHNyIDEpXG4gIDs7XG5cbiAgbGV0IGlzX3BvdzIgeCA9XG4gICAgaWYgeCA8PSAwbiB0aGVuIG5vbl9wb3NpdGl2ZV9hcmd1bWVudCAoKTtcbiAgICB4IGxhbmQgQ2FtbC5OYXRpdmVpbnQucHJlZCB4ID0gMG5cbiAgOztcblxuICAoKiBDIHN0dWJzIGZvciBuYXRpdmVpbnQgY2x6IGFuZCBjdHogdG8gdXNlIHRoZSBDTFovQlNSL0NUWi9CU0YgaW5zdHJ1Y3Rpb24gd2hlcmUgcG9zc2libGUgKilcbiAgZXh0ZXJuYWwgY2x6XG4gICAgOiAgKG5hdGl2ZWludFtAdW5ib3hlZF0pXG4gICAgLT4gKGludFtAdW50YWdnZWRdKVxuICAgID0gXCJCYXNlX2ludF9tYXRoX25hdGl2ZWludF9jbHpcIiBcIkJhc2VfaW50X21hdGhfbmF0aXZlaW50X2Nsel91bmJveGVkXCJcbiAgW0BAbm9hbGxvY11cblxuICBleHRlcm5hbCBjdHpcbiAgICA6ICAobmF0aXZlaW50W0B1bmJveGVkXSlcbiAgICAtPiAoaW50W0B1bnRhZ2dlZF0pXG4gICAgPSBcIkJhc2VfaW50X21hdGhfbmF0aXZlaW50X2N0elwiIFwiQmFzZV9pbnRfbWF0aF9uYXRpdmVpbnRfY3R6X3VuYm94ZWRcIlxuICBbQEBub2FsbG9jXVxuXG4gICgqKiBIYWNrZXIncyBEZWxpZ2h0IFNlY29uZCBFZGl0aW9uIHAxMDYgKilcbiAgbGV0IGZsb29yX2xvZzIgaSA9XG4gICAgaWYgUG9seS4oIDw9ICkgaSBDYW1sLk5hdGl2ZWludC56ZXJvXG4gICAgdGhlblxuICAgICAgcmFpc2Vfc1xuICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgIFwiW05hdGl2ZWludC5mbG9vcl9sb2cyXSBnb3QgaW52YWxpZCBpbnB1dFwiXG4gICAgICAgICAgIFsgXCJcIiwgc2V4cF9vZl9uYXRpdmVpbnQgaSBdKTtcbiAgICBudW1fYml0cyAtIDEgLSBjbHogaVxuICA7O1xuXG4gICgqKiBIYWNrZXIncyBEZWxpZ2h0IFNlY29uZCBFZGl0aW9uIHAxMDYgKilcbiAgbGV0IGNlaWxfbG9nMiBpID1cbiAgICBpZiBQb2x5LiggPD0gKSBpIENhbWwuTmF0aXZlaW50Lnplcm9cbiAgICB0aGVuXG4gICAgICByYWlzZV9zXG4gICAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgICAgXCJbTmF0aXZlaW50LmNlaWxfbG9nMl0gZ290IGludmFsaWQgaW5wdXRcIlxuICAgICAgICAgICBbIFwiXCIsIHNleHBfb2ZfbmF0aXZlaW50IGkgXSk7XG4gICAgaWYgQ2FtbC5OYXRpdmVpbnQuZXF1YWwgaSBDYW1sLk5hdGl2ZWludC5vbmVcbiAgICB0aGVuIDBcbiAgICBlbHNlIG51bV9iaXRzIC0gY2x6IChDYW1sLk5hdGl2ZWludC5wcmVkIGkpXG4gIDs7XG5lbmRcblxuaW5jbHVkZSBQb3cyXG5cbmxldCBiZXR3ZWVuIHQgfmxvdyB+aGlnaCA9IGxvdyA8PSB0ICYmIHQgPD0gaGlnaFxubGV0IGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heCA9IGlmIHQgPCBtaW4gdGhlbiBtaW4gZWxzZSBpZiB0IDw9IG1heCB0aGVuIHQgZWxzZSBtYXhcblxubGV0IGNsYW1wX2V4biB0IH5taW4gfm1heCA9XG4gIGFzc2VydCAobWluIDw9IG1heCk7XG4gIGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heFxuOztcblxubGV0IGNsYW1wIHQgfm1pbiB+bWF4ID1cbiAgaWYgbWluID4gbWF4XG4gIHRoZW5cbiAgICBPcl9lcnJvci5lcnJvcl9zXG4gICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICBcImNsYW1wIHJlcXVpcmVzIFttaW4gPD0gbWF4XVwiXG4gICAgICAgICBbIFwibWluXCIsIFQuc2V4cF9vZl90IG1pbjsgXCJtYXhcIiwgVC5zZXhwX29mX3QgbWF4IF0pXG4gIGVsc2UgT2sgKGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heClcbjs7XG5cbmxldCAoIC8gKSA9IGRpdlxubGV0ICggKiApID0gbXVsXG5sZXQgKCAtICkgPSBzdWJcbmxldCAoICsgKSA9IGFkZFxubGV0ICggfi0gKSA9IG5lZ1xubGV0IGluY3IgciA9IHIgOj0gIXIgKyBvbmVcbmxldCBkZWNyIHIgPSByIDo9ICFyIC0gb25lXG5sZXQgb2ZfbmF0aXZlaW50IHQgPSB0XG5sZXQgb2ZfbmF0aXZlaW50X2V4biA9IG9mX25hdGl2ZWludFxubGV0IHRvX25hdGl2ZWludCB0ID0gdFxubGV0IHRvX25hdGl2ZWludF9leG4gPSB0b19uYXRpdmVpbnRcbmxldCBwb3Bjb3VudCA9IFBvcGNvdW50Lm5hdGl2ZWludF9wb3Bjb3VudFxubGV0IG9mX2ludCA9IENvbnYuaW50X3RvX25hdGl2ZWludFxubGV0IG9mX2ludF9leG4gPSBvZl9pbnRcbmxldCB0b19pbnQgPSBDb252Lm5hdGl2ZWludF90b19pbnRcbmxldCB0b19pbnRfZXhuID0gQ29udi5uYXRpdmVpbnRfdG9faW50X2V4blxubGV0IHRvX2ludF90cnVuYyA9IENvbnYubmF0aXZlaW50X3RvX2ludF90cnVuY1xubGV0IG9mX2ludDMyID0gQ29udi5pbnQzMl90b19uYXRpdmVpbnRcbmxldCBvZl9pbnQzMl9leG4gPSBvZl9pbnQzMlxubGV0IHRvX2ludDMyID0gQ29udi5uYXRpdmVpbnRfdG9faW50MzJcbmxldCB0b19pbnQzMl9leG4gPSBDb252Lm5hdGl2ZWludF90b19pbnQzMl9leG5cbmxldCB0b19pbnQzMl90cnVuYyA9IENvbnYubmF0aXZlaW50X3RvX2ludDMyX3RydW5jXG5sZXQgb2ZfaW50NjQgPSBDb252LmludDY0X3RvX25hdGl2ZWludFxubGV0IG9mX2ludDY0X2V4biA9IENvbnYuaW50NjRfdG9fbmF0aXZlaW50X2V4blxubGV0IG9mX2ludDY0X3RydW5jID0gQ29udi5pbnQ2NF90b19uYXRpdmVpbnRfdHJ1bmNcbmxldCB0b19pbnQ2NCA9IENvbnYubmF0aXZlaW50X3RvX2ludDY0XG5sZXQgcG93IGIgZSA9IG9mX2ludF9leG4gKEludF9tYXRoLlByaXZhdGUuaW50X3BvdyAodG9faW50X2V4biBiKSAodG9faW50X2V4biBlKSlcbmxldCAoICoqICkgYiBlID0gcG93IGIgZVxuXG5tb2R1bGUgUHJlX08gPSBzdHJ1Y3RcbiAgbGV0ICggKyApID0gKCArIClcbiAgbGV0ICggLSApID0gKCAtIClcbiAgbGV0ICggKiApID0gKCAqIClcbiAgbGV0ICggLyApID0gKCAvIClcbiAgbGV0ICggfi0gKSA9ICggfi0gKVxuICBsZXQgKCAqKiApID0gKCAqKiApXG5cbiAgaW5jbHVkZSAoTmF0aXZlaW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSA6IENvbXBhcmlzb25zLkluZml4IHdpdGggdHlwZSB0IDo9IHQpXG5cbiAgbGV0IGFicyA9IGFic1xuICBsZXQgbmVnID0gbmVnXG4gIGxldCB6ZXJvID0gemVyb1xuICBsZXQgb2ZfaW50X2V4biA9IG9mX2ludF9leG5cbmVuZFxuXG5tb2R1bGUgTyA9IHN0cnVjdFxuICBpbmNsdWRlIFByZV9PXG5cbiAgaW5jbHVkZSBJbnRfbWF0aC5NYWtlIChzdHJ1Y3RcbiAgICAgIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgICAgIGluY2x1ZGUgUHJlX09cblxuICAgICAgbGV0IHJlbSA9IHJlbVxuICAgICAgbGV0IHRvX2Zsb2F0ID0gdG9fZmxvYXRcbiAgICAgIGxldCBvZl9mbG9hdCA9IG9mX2Zsb2F0XG4gICAgICBsZXQgb2Zfc3RyaW5nID0gVC5vZl9zdHJpbmdcbiAgICAgIGxldCB0b19zdHJpbmcgPSBULnRvX3N0cmluZ1xuICAgIGVuZClcblxuICBsZXQgKCBsYW5kICkgPSBiaXRfYW5kXG4gIGxldCAoIGxvciApID0gYml0X29yXG4gIGxldCAoIGx4b3IgKSA9IGJpdF94b3JcbiAgbGV0IGxub3QgPSBiaXRfbm90XG4gIGxldCAoIGxzbCApID0gc2hpZnRfbGVmdFxuICBsZXQgKCBhc3IgKSA9IHNoaWZ0X3JpZ2h0XG4gIGxldCAoIGxzciApID0gc2hpZnRfcmlnaHRfbG9naWNhbFxuZW5kXG5cbmluY2x1ZGUgT1xuXG4oKiBbTmF0aXZlaW50XSBhbmQgW05hdGl2ZWludC5PXSBhZ3JlZSB2YWx1ZS13aXNlICopXG5cbigqIEluY2x1ZGUgdHlwZS1zcGVjaWZpYyBbUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXSBhdCB0aGUgZW5kLCBhZnRlclxuICAgaW5jbHVkaW5nIGZ1bmN0b3IgYXBwbGljYXRpb24gdGhhdCBjb3VsZCBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzXG4gICBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9ucyBhcmUgZXhwb3J0ZWQgYnlcbiAgIHRoaXMgbW9kdWxlLiAqKVxuaW5jbHVkZSBOYXRpdmVpbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbmV4dGVybmFsIGJzd2FwIDogdCAtPiB0ID0gXCIlYnN3YXBfbmF0aXZlXCJcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0aXZlIENhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgKilcbigqICBlbiBBdXRvbWF0aXF1ZS4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgICAgKilcbigqICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEFwYWNoZSAyLjAgbGljZW5zZS4gU2VlIC4uL1RISVJELVBBUlRZLnR4dCAgKilcbigqICBmb3IgZGV0YWlscy4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxub3BlbiEgSW1wb3J0XG5tb2R1bGUgTGlzdCA9IExpc3QwXG5pbmNsdWRlIE1hcF9pbnRmXG5cbm1vZHVsZSBGaW5pc2hlZF9vcl91bmZpbmlzaGVkID0gc3RydWN0XG4gIGluY2x1ZGUgTWFwX2ludGYuRmluaXNoZWRfb3JfdW5maW5pc2hlZFxuXG4gICgqIFRoZXNlIHR3byBmdW5jdGlvbnMgYXJlIHRlc3RlZCBpbiBbdGVzdF9tYXAubWxdIHRvIG1ha2Ugc3VyZSBvdXIgdXNlIG9mXG4gICAgIFtDYW1sLk9iai5tYWdpY10gaXMgY29ycmVjdCBhbmQgc2FmZS4gKilcbiAgbGV0IG9mX2NvbnRpbnVlX29yX3N0b3AgOiBDb250aW51ZV9vcl9zdG9wLnQgLT4gdCA9IENhbWwuT2JqLm1hZ2ljXG4gIGxldCB0b19jb250aW51ZV9vcl9zdG9wIDogdCAtPiBDb250aW51ZV9vcl9zdG9wLnQgPSBDYW1sLk9iai5tYWdpY1xuZW5kXG5cbm1vZHVsZSBNZXJnZV9lbGVtZW50ID0gc3RydWN0XG4gIGluY2x1ZGUgTWFwX2ludGYuTWVyZ2VfZWxlbWVudFxuXG4gIGxldCBsZWZ0ID0gZnVuY3Rpb25cbiAgICB8IGBSaWdodCBfIC0+IE5vbmVcbiAgICB8IGBMZWZ0IGxlZnQgfCBgQm90aCAobGVmdCwgXykgLT4gU29tZSBsZWZ0XG4gIDs7XG5cbiAgbGV0IHJpZ2h0ID0gZnVuY3Rpb25cbiAgICB8IGBMZWZ0IF8gLT4gTm9uZVxuICAgIHwgYFJpZ2h0IHJpZ2h0IHwgYEJvdGggKF8sIHJpZ2h0KSAtPiBTb21lIHJpZ2h0XG4gIDs7XG5cbiAgbGV0IGxlZnRfdmFsdWUgdCB+ZGVmYXVsdCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBgUmlnaHQgXyAtPiBkZWZhdWx0XG4gICAgfCBgTGVmdCBsZWZ0IHwgYEJvdGggKGxlZnQsIF8pIC0+IGxlZnRcbiAgOztcblxuICBsZXQgcmlnaHRfdmFsdWUgdCB+ZGVmYXVsdCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBgTGVmdCBfIC0+IGRlZmF1bHRcbiAgICB8IGBSaWdodCByaWdodCB8IGBCb3RoIChfLCByaWdodCkgLT4gcmlnaHRcbiAgOztcblxuICBsZXQgdmFsdWVzIHQgfmxlZnRfZGVmYXVsdCB+cmlnaHRfZGVmYXVsdCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBgTGVmdCBsZWZ0IC0+IGxlZnQsIHJpZ2h0X2RlZmF1bHRcbiAgICB8IGBSaWdodCByaWdodCAtPiBsZWZ0X2RlZmF1bHQsIHJpZ2h0XG4gICAgfCBgQm90aCAobGVmdCwgcmlnaHQpIC0+IGxlZnQsIHJpZ2h0XG4gIDs7XG5lbmRcblxubGV0IHdpdGhfcmV0dXJuID0gV2l0aF9yZXR1cm4ud2l0aF9yZXR1cm5cblxuZXhjZXB0aW9uIER1cGxpY2F0ZSBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF1cblxubGV0ICgpID1cbiAgU2V4cGxpYjAuU2V4cF9jb252LkV4bl9jb252ZXJ0ZXIuYWRkIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIER1cGxpY2F0ZV0gKGZ1bmN0aW9uXG4gICAgfCBEdXBsaWNhdGUgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwibWFwLm1sLkR1cGxpY2F0ZVwiXG4gICAgfCBfIC0+IGFzc2VydCBmYWxzZSlcbjs7XG5cbltAQEBlbmRdXG5cbm1vZHVsZSBUcmVlMCA9IHN0cnVjdFxuICB0eXBlICgnaywgJ3YpIHQgPVxuICAgIHwgRW1wdHlcbiAgICB8IExlYWYgb2YgJ2sgKiAndlxuICAgIHwgTm9kZSBvZiAoJ2ssICd2KSB0ICogJ2sgKiAndiAqICgnaywgJ3YpIHQgKiBpbnRcblxuICB0eXBlICgnaywgJ3YpIHRyZWUgPSAoJ2ssICd2KSB0XG5cbiAgbGV0IGhlaWdodCA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPiAwXG4gICAgfCBMZWFmIF8gLT4gMVxuICAgIHwgTm9kZSAoXywgXywgXywgXywgaCkgLT4gaFxuICA7O1xuXG4gIGxldCBpbnZhcmlhbnRzID1cbiAgICBsZXQgaW5fcmFuZ2UgbG93ZXIgdXBwZXIgY29tcGFyZV9rZXkgayA9XG4gICAgICAobWF0Y2ggbG93ZXIgd2l0aFxuICAgICAgIHwgTm9uZSAtPiB0cnVlXG4gICAgICAgfCBTb21lIGxvd2VyIC0+IGNvbXBhcmVfa2V5IGxvd2VyIGsgPCAwKVxuICAgICAgJiZcbiAgICAgIG1hdGNoIHVwcGVyIHdpdGhcbiAgICAgIHwgTm9uZSAtPiB0cnVlXG4gICAgICB8IFNvbWUgdXBwZXIgLT4gY29tcGFyZV9rZXkgayB1cHBlciA8IDBcbiAgICBpblxuICAgIGxldCByZWMgbG9vcCBsb3dlciB1cHBlciBjb21wYXJlX2tleSB0ID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBFbXB0eSAtPiB0cnVlXG4gICAgICB8IExlYWYgKGssIF8pIC0+IGluX3JhbmdlIGxvd2VyIHVwcGVyIGNvbXBhcmVfa2V5IGtcbiAgICAgIHwgTm9kZSAobCwgaywgXywgciwgaCkgLT5cbiAgICAgICAgbGV0IGhsID0gaGVpZ2h0IGxcbiAgICAgICAgYW5kIGhyID0gaGVpZ2h0IHIgaW5cbiAgICAgICAgYWJzIChobCAtIGhyKSA8PSAyXG4gICAgICAgICYmIGggPSBtYXggaGwgaHIgKyAxXG4gICAgICAgICYmIGluX3JhbmdlIGxvd2VyIHVwcGVyIGNvbXBhcmVfa2V5IGtcbiAgICAgICAgJiYgbG9vcCBsb3dlciAoU29tZSBrKSBjb21wYXJlX2tleSBsXG4gICAgICAgICYmIGxvb3AgKFNvbWUgaykgdXBwZXIgY29tcGFyZV9rZXkgclxuICAgIGluXG4gICAgZnVuIHQgfmNvbXBhcmVfa2V5IC0+IGxvb3AgTm9uZSBOb25lIGNvbXBhcmVfa2V5IHRcbiAgOztcblxuICAoKiBwcmVjb25kaXRpb246IHxoZWlnaHQobCkgLSBoZWlnaHQocil8IDw9IDIgKilcbiAgbGV0IGNyZWF0ZSBsIHggZCByID1cbiAgICBsZXQgaGwgPSBoZWlnaHQgbFxuICAgIGFuZCBociA9IGhlaWdodCByIGluXG4gICAgaWYgaGwgPSAwICYmIGhyID0gMFxuICAgIHRoZW4gTGVhZiAoeCwgZClcbiAgICBlbHNlIE5vZGUgKGwsIHgsIGQsIHIsIGlmIGhsID49IGhyIHRoZW4gaGwgKyAxIGVsc2UgaHIgKyAxKVxuICA7O1xuXG4gIGxldCBzaW5nbGV0b24ga2V5IGRhdGEgPSBMZWFmIChrZXksIGRhdGEpXG5cbiAgKCogV2UgbXVzdCBjYWxsIFtmXSB3aXRoIGluY3JlYXNpbmcgaW5kZXhlcywgYmVjYXVzZSB0aGUgYmluX3Byb3QgcmVhZGVyIGluXG4gICAgIENvcmUuTWFwIG5lZWRzIGl0LiAqKVxuICBsZXQgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmxlbiB+ZiA9XG4gICAgbGV0IHJlYyBsb29wIG4gfmYgaSA6IChfLCBfKSB0ID1cbiAgICAgIG1hdGNoIG4gd2l0aFxuICAgICAgfCAwIC0+IEVtcHR5XG4gICAgICB8IDEgLT5cbiAgICAgICAgbGV0IGssIHYgPSBmIGkgaW5cbiAgICAgICAgTGVhZiAoaywgdilcbiAgICAgIHwgMiAtPlxuICAgICAgICBsZXQga2wsIHZsID0gZiBpIGluXG4gICAgICAgIGxldCBrLCB2ID0gZiAoaSArIDEpIGluXG4gICAgICAgIE5vZGUgKExlYWYgKGtsLCB2bCksIGssIHYsIEVtcHR5LCAyKVxuICAgICAgfCAzIC0+XG4gICAgICAgIGxldCBrbCwgdmwgPSBmIGkgaW5cbiAgICAgICAgbGV0IGssIHYgPSBmIChpICsgMSkgaW5cbiAgICAgICAgbGV0IGtyLCB2ciA9IGYgKGkgKyAyKSBpblxuICAgICAgICBOb2RlIChMZWFmIChrbCwgdmwpLCBrLCB2LCBMZWFmIChrciwgdnIpLCAyKVxuICAgICAgfCBuIC0+XG4gICAgICAgIGxldCBsZWZ0X2xlbmd0aCA9IG4gbHNyIDEgaW5cbiAgICAgICAgbGV0IHJpZ2h0X2xlbmd0aCA9IG4gLSBsZWZ0X2xlbmd0aCAtIDEgaW5cbiAgICAgICAgbGV0IGxlZnQgPSBsb29wIGxlZnRfbGVuZ3RoIH5mIGkgaW5cbiAgICAgICAgbGV0IGssIHYgPSBmIChpICsgbGVmdF9sZW5ndGgpIGluXG4gICAgICAgIGxldCByaWdodCA9IGxvb3AgcmlnaHRfbGVuZ3RoIH5mIChpICsgbGVmdF9sZW5ndGggKyAxKSBpblxuICAgICAgICBjcmVhdGUgbGVmdCBrIHYgcmlnaHRcbiAgICBpblxuICAgIGxvb3AgbGVuIH5mIDBcbiAgOztcblxuICBsZXQgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCBhcnJheSB+Y29tcGFyZV9rZXkgPVxuICAgIGxldCBhcnJheV9sZW5ndGggPSBBcnJheS5sZW5ndGggYXJyYXkgaW5cbiAgICBsZXQgbmV4dCA9XG4gICAgICBpZiBhcnJheV9sZW5ndGggPCAyXG4gICAgICAgICB8fFxuICAgICAgICAgbGV0IGswLCBfID0gYXJyYXkuKDApIGluXG4gICAgICAgICBsZXQgazEsIF8gPSBhcnJheS4oMSkgaW5cbiAgICAgICAgIGNvbXBhcmVfa2V5IGswIGsxIDwgMFxuICAgICAgdGhlbiBmdW4gaSAtPiBhcnJheS4oaSlcbiAgICAgIGVsc2UgZnVuIGkgLT4gYXJyYXkuKGFycmF5X2xlbmd0aCAtIDEgLSBpKVxuICAgIGluXG4gICAgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmxlbjphcnJheV9sZW5ndGggfmY6bmV4dCwgYXJyYXlfbGVuZ3RoXG4gIDs7XG5cbiAgbGV0IG9mX3NvcnRlZF9hcnJheSBhcnJheSB+Y29tcGFyZV9rZXkgPVxuICAgIG1hdGNoIGFycmF5IHdpdGhcbiAgICB8IFt8fF0gfCBbfCBfIHxdIC0+IFJlc3VsdC5PayAob2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCBhcnJheSB+Y29tcGFyZV9rZXkpXG4gICAgfCBfIC0+XG4gICAgICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICAgICAgbGV0IGluY3JlYXNpbmcgPVxuICAgICAgICAgIG1hdGNoIGNvbXBhcmVfa2V5IChmc3QgYXJyYXkuKDApKSAoZnN0IGFycmF5LigxKSkgd2l0aFxuICAgICAgICAgIHwgMCAtPiByLnJldHVybiAoT3JfZXJyb3IuZXJyb3Jfc3RyaW5nIFwib2Zfc29ydGVkX2FycmF5OiBkdXBsaWNhdGVkIGVsZW1lbnRzXCIpXG4gICAgICAgICAgfCBpIC0+IGkgPCAwXG4gICAgICAgIGluXG4gICAgICAgIGZvciBpID0gMSB0byBBcnJheS5sZW5ndGggYXJyYXkgLSAyIGRvXG4gICAgICAgICAgbWF0Y2ggY29tcGFyZV9rZXkgKGZzdCBhcnJheS4oaSkpIChmc3QgYXJyYXkuKGkgKyAxKSkgd2l0aFxuICAgICAgICAgIHwgMCAtPiByLnJldHVybiAoT3JfZXJyb3IuZXJyb3Jfc3RyaW5nIFwib2Zfc29ydGVkX2FycmF5OiBkdXBsaWNhdGVkIGVsZW1lbnRzXCIpXG4gICAgICAgICAgfCBpIC0+XG4gICAgICAgICAgICBpZiBQb2x5LiggPD4gKSAoaSA8IDApIGluY3JlYXNpbmdcbiAgICAgICAgICAgIHRoZW5cbiAgICAgICAgICAgICAgci5yZXR1cm5cbiAgICAgICAgICAgICAgICAoT3JfZXJyb3IuZXJyb3Jfc3RyaW5nIFwib2Zfc29ydGVkX2FycmF5OiBlbGVtZW50cyBhcmUgbm90IG9yZGVyZWRcIilcbiAgICAgICAgZG9uZTtcbiAgICAgICAgUmVzdWx0Lk9rIChvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIGFycmF5IH5jb21wYXJlX2tleSkpXG4gIDs7XG5cbiAgKCogcHJlY29uZGl0aW9uOiB8aGVpZ2h0KGwpIC0gaGVpZ2h0KHIpfCA8PSAzICopXG4gIGxldCBiYWwgbCB4IGQgciA9XG4gICAgbGV0IGhsID0gaGVpZ2h0IGwgaW5cbiAgICBsZXQgaHIgPSBoZWlnaHQgciBpblxuICAgIGlmIGhsID4gaHIgKyAyXG4gICAgdGhlbiAoXG4gICAgICBtYXRjaCBsIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJNYXAuYmFsXCJcbiAgICAgIHwgTGVhZiBfIC0+IGFzc2VydCBmYWxzZSAoKiBoZWlnaHQoTGVhZikgPSAxICYmIDEgaXMgbm90IGxhcmdlciB0aGFuIGhyICsgMiAqKVxuICAgICAgfCBOb2RlIChsbCwgbHYsIGxkLCBsciwgXykgLT5cbiAgICAgICAgaWYgaGVpZ2h0IGxsID49IGhlaWdodCBsclxuICAgICAgICB0aGVuIGNyZWF0ZSBsbCBsdiBsZCAoY3JlYXRlIGxyIHggZCByKVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBtYXRjaCBsciB3aXRoXG4gICAgICAgICAgfCBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIk1hcC5iYWxcIlxuICAgICAgICAgIHwgTGVhZiAobHJ2LCBscmQpIC0+IGNyZWF0ZSAoY3JlYXRlIGxsIGx2IGxkIEVtcHR5KSBscnYgbHJkIChjcmVhdGUgRW1wdHkgeCBkIHIpXG4gICAgICAgICAgfCBOb2RlIChscmwsIGxydiwgbHJkLCBscnIsIF8pIC0+XG4gICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsbCBsdiBsZCBscmwpIGxydiBscmQgKGNyZWF0ZSBscnIgeCBkIHIpKSlcbiAgICBlbHNlIGlmIGhyID4gaGwgKyAyXG4gICAgdGhlbiAoXG4gICAgICBtYXRjaCByIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJNYXAuYmFsXCJcbiAgICAgIHwgTGVhZiBfIC0+IGFzc2VydCBmYWxzZSAoKiBoZWlnaHQoTGVhZikgPSAxICYmIDEgaXMgbm90IGxhcmdlciB0aGFuIGhsICsgMiAqKVxuICAgICAgfCBOb2RlIChybCwgcnYsIHJkLCByciwgXykgLT5cbiAgICAgICAgaWYgaGVpZ2h0IHJyID49IGhlaWdodCBybFxuICAgICAgICB0aGVuIGNyZWF0ZSAoY3JlYXRlIGwgeCBkIHJsKSBydiByZCByclxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBtYXRjaCBybCB3aXRoXG4gICAgICAgICAgfCBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIk1hcC5iYWxcIlxuICAgICAgICAgIHwgTGVhZiAocmx2LCBybGQpIC0+IGNyZWF0ZSAoY3JlYXRlIGwgeCBkIEVtcHR5KSBybHYgcmxkIChjcmVhdGUgRW1wdHkgcnYgcmQgcnIpXG4gICAgICAgICAgfCBOb2RlIChybGwsIHJsdiwgcmxkLCBybHIsIF8pIC0+XG4gICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsIHggZCBybGwpIHJsdiBybGQgKGNyZWF0ZSBybHIgcnYgcmQgcnIpKSlcbiAgICBlbHNlIGNyZWF0ZSBsIHggZCByXG4gIDs7XG5cbiAgbGV0IGVtcHR5ID0gRW1wdHlcblxuICBsZXQgaXNfZW1wdHkgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gdHJ1ZVxuICAgIHwgXyAtPiBmYWxzZVxuICA7O1xuXG4gIGxldCByYWlzZV9rZXlfYWxyZWFkeV9wcmVzZW50IH5rZXkgfnNleHBfb2Zfa2V5ID1cbiAgICBFcnJvci5yYWlzZV9zXG4gICAgICAoU2V4cC5tZXNzYWdlIFwiW01hcC5hZGRfZXhuXSBnb3Qga2V5IGFscmVhZHkgcHJlc2VudFwiIFsgXCJrZXlcIiwga2V5IHw+IHNleHBfb2Zfa2V5IF0pXG4gIDs7XG5cbiAgbW9kdWxlIEFkZF9vcl9zZXQgPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPVxuICAgICAgfCBBZGRfZXhuX2ludGVybmFsXG4gICAgICB8IEFkZF9leG5cbiAgICAgIHwgU2V0XG4gIGVuZFxuXG5cbiAgbGV0IHJlYyBmaW5kX2FuZF9hZGRfb3Jfc2V0XG4gICAgICAgICAgICB0XG4gICAgICAgICAgICB+bGVuZ3RoXG4gICAgICAgICAgICB+a2V5OnhcbiAgICAgICAgICAgIH5kYXRhXG4gICAgICAgICAgICB+Y29tcGFyZV9rZXlcbiAgICAgICAgICAgIH5zZXhwX29mX2tleVxuICAgICAgICAgICAgfihhZGRfb3Jfc2V0IDogQWRkX29yX3NldC50KVxuICAgID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IExlYWYgKHgsIGRhdGEpLCBsZW5ndGggKyAxXG4gICAgfCBMZWFmICh2LCBkKSAtPlxuICAgICAgbGV0IGMgPSBjb21wYXJlX2tleSB4IHYgaW5cbiAgICAgIGlmIGMgPSAwXG4gICAgICB0aGVuIChcbiAgICAgICAgbWF0Y2ggYWRkX29yX3NldCB3aXRoXG4gICAgICAgIHwgQWRkX2V4bl9pbnRlcm5hbCAtPiBFeG4ucmFpc2Vfd2l0aG91dF9iYWNrdHJhY2UgRHVwbGljYXRlXG4gICAgICAgIHwgQWRkX2V4biAtPiByYWlzZV9rZXlfYWxyZWFkeV9wcmVzZW50IH5rZXk6eCB+c2V4cF9vZl9rZXlcbiAgICAgICAgfCBTZXQgLT4gTGVhZiAoeCwgZGF0YSksIGxlbmd0aClcbiAgICAgIGVsc2UgaWYgYyA8IDBcbiAgICAgIHRoZW4gTm9kZSAoTGVhZiAoeCwgZGF0YSksIHYsIGQsIEVtcHR5LCAyKSwgbGVuZ3RoICsgMVxuICAgICAgZWxzZSBOb2RlIChFbXB0eSwgdiwgZCwgTGVhZiAoeCwgZGF0YSksIDIpLCBsZW5ndGggKyAxXG4gICAgfCBOb2RlIChsLCB2LCBkLCByLCBoKSAtPlxuICAgICAgbGV0IGMgPSBjb21wYXJlX2tleSB4IHYgaW5cbiAgICAgIGlmIGMgPSAwXG4gICAgICB0aGVuIChcbiAgICAgICAgbWF0Y2ggYWRkX29yX3NldCB3aXRoXG4gICAgICAgIHwgQWRkX2V4bl9pbnRlcm5hbCAtPiBFeG4ucmFpc2Vfd2l0aG91dF9iYWNrdHJhY2UgRHVwbGljYXRlXG4gICAgICAgIHwgQWRkX2V4biAtPiByYWlzZV9rZXlfYWxyZWFkeV9wcmVzZW50IH5rZXk6eCB+c2V4cF9vZl9rZXlcbiAgICAgICAgfCBTZXQgLT4gTm9kZSAobCwgeCwgZGF0YSwgciwgaCksIGxlbmd0aClcbiAgICAgIGVsc2UgaWYgYyA8IDBcbiAgICAgIHRoZW4gKFxuICAgICAgICBsZXQgbCwgbGVuZ3RoID1cbiAgICAgICAgICBmaW5kX2FuZF9hZGRfb3Jfc2V0IH5sZW5ndGggfmtleTp4IH5kYXRhIGwgfmNvbXBhcmVfa2V5IH5zZXhwX29mX2tleSB+YWRkX29yX3NldFxuICAgICAgICBpblxuICAgICAgICBiYWwgbCB2IGQgciwgbGVuZ3RoKVxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCByLCBsZW5ndGggPVxuICAgICAgICAgIGZpbmRfYW5kX2FkZF9vcl9zZXQgfmxlbmd0aCB+a2V5OnggfmRhdGEgciB+Y29tcGFyZV9rZXkgfnNleHBfb2Zfa2V5IH5hZGRfb3Jfc2V0XG4gICAgICAgIGluXG4gICAgICAgIGJhbCBsIHYgZCByLCBsZW5ndGgpXG4gIDs7XG5cbiAgbGV0IGFkZF9leG4gdCB+bGVuZ3RoIH5rZXkgfmRhdGEgfmNvbXBhcmVfa2V5IH5zZXhwX29mX2tleSA9XG4gICAgZmluZF9hbmRfYWRkX29yX3NldCB0IH5sZW5ndGggfmtleSB+ZGF0YSB+Y29tcGFyZV9rZXkgfnNleHBfb2Zfa2V5IH5hZGRfb3Jfc2V0OkFkZF9leG5cbiAgOztcblxuICBsZXQgYWRkX2V4bl9pbnRlcm5hbCB0IH5sZW5ndGggfmtleSB+ZGF0YSB+Y29tcGFyZV9rZXkgfnNleHBfb2Zfa2V5ID1cbiAgICBmaW5kX2FuZF9hZGRfb3Jfc2V0XG4gICAgICB0XG4gICAgICB+bGVuZ3RoXG4gICAgICB+a2V5XG4gICAgICB+ZGF0YVxuICAgICAgfmNvbXBhcmVfa2V5XG4gICAgICB+c2V4cF9vZl9rZXlcbiAgICAgIH5hZGRfb3Jfc2V0OkFkZF9leG5faW50ZXJuYWxcbiAgOztcblxuICBsZXQgc2V0IHQgfmxlbmd0aCB+a2V5IH5kYXRhIH5jb21wYXJlX2tleSA9XG4gICAgZmluZF9hbmRfYWRkX29yX3NldFxuICAgICAgdFxuICAgICAgfmxlbmd0aFxuICAgICAgfmtleVxuICAgICAgfmRhdGFcbiAgICAgIH5jb21wYXJlX2tleVxuICAgICAgfnNleHBfb2Zfa2V5OihmdW4gXyAtPiBMaXN0IFtdKVxuICAgICAgfmFkZF9vcl9zZXQ6U2V0XG4gIDs7XG5cbiAgbGV0IHNldCcgdCBrZXkgZGF0YSB+Y29tcGFyZV9rZXkgPSBmc3QgKHNldCB0IH5sZW5ndGg6MCB+a2V5IH5kYXRhIH5jb21wYXJlX2tleSlcblxuICBtb2R1bGUgQnVpbGRfaW5jcmVhc2luZyA9IHN0cnVjdFxuICAgIG1vZHVsZSBGcmFnbWVudCA9IHN0cnVjdFxuICAgICAgdHlwZSBub25yZWMgKCdrLCAndikgdCA9XG4gICAgICAgIHsgbGVmdF9zdWJ0cmVlIDogKCdrLCAndikgdFxuICAgICAgICA7IGtleSA6ICdrXG4gICAgICAgIDsgZGF0YSA6ICd2XG4gICAgICAgIH1cblxuICAgICAgbGV0IHNpbmdsZXRvbl90b190cmVlX2V4biA9IGZ1bmN0aW9uXG4gICAgICAgIHwgeyBsZWZ0X3N1YnRyZWUgPSBFbXB0eTsga2V5OyBkYXRhIH0gLT4gc2luZ2xldG9uIGtleSBkYXRhXG4gICAgICAgIHwgXyAtPiBmYWlsd2l0aCBcIk1hcC5zaW5nbGV0b25fdG9fdHJlZV9leG46IG5vdCBhIHNpbmdsZXRvblwiXG4gICAgICA7O1xuXG4gICAgICBsZXQgc2luZ2xldG9uIH5rZXkgfmRhdGEgPSB7IGxlZnRfc3VidHJlZSA9IEVtcHR5OyBrZXk7IGRhdGEgfVxuXG4gICAgICAoKiBwcmVjb25kaXRpb246IHxoZWlnaHQobC5sZWZ0X3N1YnRyZWUpIC0gaGVpZ2h0KHIpfCA8PSAyLFxuICAgICAgICAgbWF4X2tleShsKSA8IG1pbl9rZXkocilcbiAgICAgICopXG4gICAgICBsZXQgY29sbGFwc2UgbCByID0gY3JlYXRlIGwubGVmdF9zdWJ0cmVlIGwua2V5IGwuZGF0YSByXG5cbiAgICAgICgqIHByZWNvbmRpdGlvbjogfGhlaWdodChsLmxlZnRfc3VidHJlZSkgLSBoZWlnaHQoci5sZWZ0X3N1YnRyZWUpfCA8PSAyLFxuICAgICAgICAgbWF4X2tleShsKSA8IG1pbl9rZXkocilcbiAgICAgICopXG4gICAgICBsZXQgam9pbiBsIHIgPSB7IHIgd2l0aCBsZWZ0X3N1YnRyZWUgPSBjb2xsYXBzZSBsIHIubGVmdF9zdWJ0cmVlIH1cbiAgICAgIGxldCBtYXhfa2V5IHQgPSB0LmtleVxuICAgIGVuZFxuXG4gICAgKCoqIEJ1aWxkIHRyZWVzIGZyb20gc2luZ2xldG9ucyBpbiBhIGJhbGFuY2VkIHdheSBieSB1c2luZyBza2V3IGJpbmFyeSBlbmNvZGluZy5cbiAgICAgICAgRWFjaCBsZXZlbCBjb250YWlucyB0cmVlcyBvZiB0aGUgc2FtZSBoZWlnaHQsIGNvbnNlY3V0aXZlIGxldmVscyBoYXZlIGNvbnNlY3V0aXZlXG4gICAgICAgIGhlaWdodHMuIFRoZXJlIGFyZSBubyBnYXBzLiBUaGUgZmlyc3QgbGV2ZWwgYXJlIHNpbmdsZSBrZXlzLlxuICAgICopXG4gICAgdHlwZSAoJ2ssICd2KSB0ID1cbiAgICAgIHwgWmVybyBvZiB1bml0XG4gICAgICAoKiBbdW5pdF0gdG8gbWFrZSBwYXR0ZXJuIG1hdGNoaW5nIGZhc3RlciAqKVxuICAgICAgfCBPbmUgb2YgKCdrLCAndikgdCAqICgnaywgJ3YpIEZyYWdtZW50LnRcbiAgICAgIHwgVHdvIG9mICgnaywgJ3YpIHQgKiAoJ2ssICd2KSBGcmFnbWVudC50ICogKCdrLCAndikgRnJhZ21lbnQudFxuXG4gICAgbGV0IGVtcHR5ID0gWmVybyAoKVxuXG4gICAgbGV0IGFkZF91bmNoZWNrZWQgPVxuICAgICAgbGV0IHJlYyBnbyB0IHggPVxuICAgICAgICBtYXRjaCB0IHdpdGhcbiAgICAgICAgfCBaZXJvICgpIC0+IE9uZSAodCwgeClcbiAgICAgICAgfCBPbmUgKHQsIHkpIC0+IFR3byAodCwgeSwgeClcbiAgICAgICAgfCBUd28gKHQsIHosIHkpIC0+IE9uZSAoZ28gdCAoRnJhZ21lbnQuam9pbiB6IHkpLCB4KVxuICAgICAgaW5cbiAgICAgIGZ1biB0IH5rZXkgfmRhdGEgLT4gZ28gdCAoRnJhZ21lbnQuc2luZ2xldG9uIH5rZXkgfmRhdGEpXG4gICAgOztcblxuICAgIGxldCB0b190cmVlX3VuY2hlY2tlZCA9XG4gICAgICBsZXQgcmVjIGdvIHQgciA9XG4gICAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgICB8IFplcm8gKCkgLT4gclxuICAgICAgICB8IE9uZSAodCwgbCkgLT4gZ28gdCAoRnJhZ21lbnQuY29sbGFwc2UgbCByKVxuICAgICAgICB8IFR3byAodCwgbGwsIGwpIC0+IGdvIHQgKEZyYWdtZW50LmNvbGxhcHNlIChGcmFnbWVudC5qb2luIGxsIGwpIHIpXG4gICAgICBpblxuICAgICAgZnVuY3Rpb25cbiAgICAgIHwgWmVybyAoKSAtPiBFbXB0eVxuICAgICAgfCBPbmUgKHQsIHIpIC0+IGdvIHQgKEZyYWdtZW50LnNpbmdsZXRvbl90b190cmVlX2V4biByKVxuICAgICAgfCBUd28gKHQsIGwsIHIpIC0+IGdvIChPbmUgKHQsIGwpKSAoRnJhZ21lbnQuc2luZ2xldG9uX3RvX3RyZWVfZXhuIHIpXG4gICAgOztcblxuICAgIGxldCBtYXhfa2V5ID0gZnVuY3Rpb25cbiAgICAgIHwgWmVybyAoKSAtPiBOb25lXG4gICAgICB8IE9uZSAoXywgcikgfCBUd28gKF8sIF8sIHIpIC0+IFNvbWUgKEZyYWdtZW50Lm1heF9rZXkgcilcbiAgICA7O1xuICBlbmRcblxuICBsZXQgb2ZfaW5jcmVhc2luZ19zZXF1ZW5jZSBzZXEgfmNvbXBhcmVfa2V5ID1cbiAgICB3aXRoX3JldHVybiAoZnVuIHsgcmV0dXJuIH0gLT5cbiAgICAgIGxldCBidWlsZGVyLCBsZW5ndGggPVxuICAgICAgICBTZXF1ZW5jZS5mb2xkXG4gICAgICAgICAgc2VxXG4gICAgICAgICAgfmluaXQ6KEJ1aWxkX2luY3JlYXNpbmcuZW1wdHksIDApXG4gICAgICAgICAgfmY6KGZ1biAoYnVpbGRlciwgbGVuZ3RoKSAoa2V5LCBkYXRhKSAtPlxuICAgICAgICAgICAgbWF0Y2ggQnVpbGRfaW5jcmVhc2luZy5tYXhfa2V5IGJ1aWxkZXIgd2l0aFxuICAgICAgICAgICAgfCBTb21lIHByZXZfa2V5IHdoZW4gY29tcGFyZV9rZXkgcHJldl9rZXkga2V5ID49IDAgLT5cbiAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgKE9yX2Vycm9yLmVycm9yX3N0cmluZyBcIm9mX2luY3JlYXNpbmdfc2VxdWVuY2U6IG5vbi1pbmNyZWFzaW5nIGtleVwiKVxuICAgICAgICAgICAgfCBfIC0+IEJ1aWxkX2luY3JlYXNpbmcuYWRkX3VuY2hlY2tlZCBidWlsZGVyIH5rZXkgfmRhdGEsIGxlbmd0aCArIDEpXG4gICAgICBpblxuICAgICAgT2sgKEJ1aWxkX2luY3JlYXNpbmcudG9fdHJlZV91bmNoZWNrZWQgYnVpbGRlciwgbGVuZ3RoKSlcbiAgOztcblxuICAoKiBMaWtlIFtiYWxdIGJ1dCBhbGxvd3MgYW55IGRpZmZlcmVuY2UgaW4gaGVpZ2h0IGJldHdlZW4gW2xdIGFuZCBbcl0uXG5cbiAgICAgTyh8aGVpZ2h0IGwgLSBoZWlnaHQgcnwpICopXG4gIGxldCByZWMgam9pbiBsIGsgZCByIH5jb21wYXJlX2tleSA9XG4gICAgbWF0Y2ggbCwgciB3aXRoXG4gICAgfCBFbXB0eSwgXyAtPiBzZXQnIHIgayBkIH5jb21wYXJlX2tleVxuICAgIHwgXywgRW1wdHkgLT4gc2V0JyBsIGsgZCB+Y29tcGFyZV9rZXlcbiAgICB8IExlYWYgKGxrLCBsZCksIF8gLT4gc2V0JyAoc2V0JyByIGsgZCB+Y29tcGFyZV9rZXkpIGxrIGxkIH5jb21wYXJlX2tleVxuICAgIHwgXywgTGVhZiAocmssIHJkKSAtPiBzZXQnIChzZXQnIGwgayBkIH5jb21wYXJlX2tleSkgcmsgcmQgfmNvbXBhcmVfa2V5XG4gICAgfCBOb2RlIChsbCwgbGssIGxkLCBsciwgbGgpLCBOb2RlIChybCwgcmssIHJkLCByciwgcmgpIC0+XG4gICAgICAoKiBbYmFsXSByZXF1aXJlcyBoZWlnaHQgZGlmZmVyZW5jZSA8PSAzLiAqKVxuICAgICAgaWYgbGggPiByaCArIDNcbiAgICAgICgqIFtoZWlnaHQgbHIgPj0gaGVpZ2h0IHJdLFxuICAgICAgICAgdGhlcmVmb3JlIFtoZWlnaHQgKGpvaW4gbHIgayBkIHIgLi4uKV0gaXMgW2hlaWdodCBybCArIDFdIG9yIFtoZWlnaHQgcmxdXG4gICAgICAgICB0aGVyZWZvcmUgdGhlIGhlaWdodCBkaWZmZXJlbmNlIHdpdGggW2xsXSB3aWxsIGJlIDw9IDMgKilcbiAgICAgIHRoZW4gYmFsIGxsIGxrIGxkIChqb2luIGxyIGsgZCByIH5jb21wYXJlX2tleSlcbiAgICAgIGVsc2UgaWYgcmggPiBsaCArIDNcbiAgICAgIHRoZW4gYmFsIChqb2luIGwgayBkIHJsIH5jb21wYXJlX2tleSkgcmsgcmQgcnJcbiAgICAgIGVsc2UgYmFsIGwgayBkIHJcbiAgOztcblxuICBsZXQgcmVjIHNwbGl0IHQgeCB+Y29tcGFyZV9rZXkgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gRW1wdHksIE5vbmUsIEVtcHR5XG4gICAgfCBMZWFmIChrLCBkKSAtPlxuICAgICAgbGV0IGNtcCA9IGNvbXBhcmVfa2V5IHggayBpblxuICAgICAgaWYgY21wID0gMFxuICAgICAgdGhlbiBFbXB0eSwgU29tZSAoaywgZCksIEVtcHR5XG4gICAgICBlbHNlIGlmIGNtcCA8IDBcbiAgICAgIHRoZW4gRW1wdHksIE5vbmUsIHRcbiAgICAgIGVsc2UgdCwgTm9uZSwgRW1wdHlcbiAgICB8IE5vZGUgKGwsIGssIGQsIHIsIF8pIC0+XG4gICAgICBsZXQgY21wID0gY29tcGFyZV9rZXkgeCBrIGluXG4gICAgICBpZiBjbXAgPSAwXG4gICAgICB0aGVuIGwsIFNvbWUgKGssIGQpLCByXG4gICAgICBlbHNlIGlmIGNtcCA8IDBcbiAgICAgIHRoZW4gKFxuICAgICAgICBsZXQgbGwsIG1heWJlLCBsciA9IHNwbGl0IGwgeCB+Y29tcGFyZV9rZXkgaW5cbiAgICAgICAgbGwsIG1heWJlLCBqb2luIGxyIGsgZCByIH5jb21wYXJlX2tleSlcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgcmwsIG1heWJlLCByciA9IHNwbGl0IHIgeCB+Y29tcGFyZV9rZXkgaW5cbiAgICAgICAgam9pbiBsIGsgZCBybCB+Y29tcGFyZV9rZXksIG1heWJlLCBycilcbiAgOztcblxuICBsZXQgc3BsaXRfYW5kX3JlaW5zZXJ0X2JvdW5kYXJ5IHQgfmludG8geCB+Y29tcGFyZV9rZXkgPVxuICAgIGxldCBsZWZ0LCBib3VuZGFyeV9vcHQsIHJpZ2h0ID0gc3BsaXQgdCB4IH5jb21wYXJlX2tleSBpblxuICAgIG1hdGNoIGJvdW5kYXJ5X29wdCB3aXRoXG4gICAgfCBOb25lIC0+IGxlZnQsIHJpZ2h0XG4gICAgfCBTb21lIChrZXksIGRhdGEpIC0+XG4gICAgICBsZXQgaW5zZXJ0X2ludG8gdHJlZSA9IGZzdCAoc2V0IHRyZWUgfmtleSB+ZGF0YSB+bGVuZ3RoOjAgfmNvbXBhcmVfa2V5KSBpblxuICAgICAgKG1hdGNoIGludG8gd2l0aFxuICAgICAgIHwgYExlZnQgLT4gaW5zZXJ0X2ludG8gbGVmdCwgcmlnaHRcbiAgICAgICB8IGBSaWdodCAtPiBsZWZ0LCBpbnNlcnRfaW50byByaWdodClcbiAgOztcblxuICBsZXQgc3BsaXRfcmFuZ2VcbiAgICAgICAgdFxuICAgICAgICB+KGxvd2VyX2JvdW5kIDogJ2EgTWF5YmVfYm91bmQudClcbiAgICAgICAgfih1cHBlcl9ib3VuZCA6ICdhIE1heWJlX2JvdW5kLnQpXG4gICAgICAgIH5jb21wYXJlX2tleVxuICAgID1cbiAgICBpZiBNYXliZV9ib3VuZC5ib3VuZHNfY3Jvc3NlZFxuICAgICAgICAgfmNvbXBhcmU6Y29tcGFyZV9rZXlcbiAgICAgICAgIH5sb3dlcjpsb3dlcl9ib3VuZFxuICAgICAgICAgfnVwcGVyOnVwcGVyX2JvdW5kXG4gICAgdGhlbiBlbXB0eSwgZW1wdHksIGVtcHR5XG4gICAgZWxzZSAoXG4gICAgICBsZXQgbGVmdCwgbWlkX2FuZF9yaWdodCA9XG4gICAgICAgIG1hdGNoIGxvd2VyX2JvdW5kIHdpdGhcbiAgICAgICAgfCBVbmJvdW5kZWQgLT4gZW1wdHksIHRcbiAgICAgICAgfCBJbmNsIGxiIC0+IHNwbGl0X2FuZF9yZWluc2VydF9ib3VuZGFyeSB+aW50bzpgUmlnaHQgdCBsYiB+Y29tcGFyZV9rZXlcbiAgICAgICAgfCBFeGNsIGxiIC0+IHNwbGl0X2FuZF9yZWluc2VydF9ib3VuZGFyeSB+aW50bzpgTGVmdCB0IGxiIH5jb21wYXJlX2tleVxuICAgICAgaW5cbiAgICAgIGxldCBtaWQsIHJpZ2h0ID1cbiAgICAgICAgbWF0Y2ggdXBwZXJfYm91bmQgd2l0aFxuICAgICAgICB8IFVuYm91bmRlZCAtPiBtaWRfYW5kX3JpZ2h0LCBlbXB0eVxuICAgICAgICB8IEluY2wgbGIgLT4gc3BsaXRfYW5kX3JlaW5zZXJ0X2JvdW5kYXJ5IH5pbnRvOmBMZWZ0IG1pZF9hbmRfcmlnaHQgbGIgfmNvbXBhcmVfa2V5XG4gICAgICAgIHwgRXhjbCBsYiAtPlxuICAgICAgICAgIHNwbGl0X2FuZF9yZWluc2VydF9ib3VuZGFyeSB+aW50bzpgUmlnaHQgbWlkX2FuZF9yaWdodCBsYiB+Y29tcGFyZV9rZXlcbiAgICAgIGluXG4gICAgICBsZWZ0LCBtaWQsIHJpZ2h0KVxuICA7O1xuXG4gIGxldCByZWMgZmluZCB0IHggfmNvbXBhcmVfa2V5ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICB8IExlYWYgKHYsIGQpIC0+IGlmIGNvbXBhcmVfa2V5IHggdiA9IDAgdGhlbiBTb21lIGQgZWxzZSBOb25lXG4gICAgfCBOb2RlIChsLCB2LCBkLCByLCBfKSAtPlxuICAgICAgbGV0IGMgPSBjb21wYXJlX2tleSB4IHYgaW5cbiAgICAgIGlmIGMgPSAwIHRoZW4gU29tZSBkIGVsc2UgZmluZCAoaWYgYyA8IDAgdGhlbiBsIGVsc2UgcikgeCB+Y29tcGFyZV9rZXlcbiAgOztcblxuICBsZXQgYWRkX211bHRpIHQgfmxlbmd0aCB+a2V5IH5kYXRhIH5jb21wYXJlX2tleSA9XG4gICAgbGV0IGRhdGEgPSBkYXRhIDo6IE9wdGlvbi52YWx1ZSAoZmluZCB0IGtleSB+Y29tcGFyZV9rZXkpIH5kZWZhdWx0OltdIGluXG4gICAgc2V0IH5sZW5ndGggfmtleSB+ZGF0YSB0IH5jb21wYXJlX2tleVxuICA7O1xuXG4gIGxldCBmaW5kX211bHRpIHQgeCB+Y29tcGFyZV9rZXkgPVxuICAgIG1hdGNoIGZpbmQgdCB4IH5jb21wYXJlX2tleSB3aXRoXG4gICAgfCBOb25lIC0+IFtdXG4gICAgfCBTb21lIGwgLT4gbFxuICA7O1xuXG4gIGxldCBmaW5kX2V4biA9XG4gICAgbGV0IGlmX25vdF9mb3VuZCBrZXkgfnNleHBfb2Zfa2V5ID1cbiAgICAgIHJhaXNlIChOb3RfZm91bmRfcyAoTGlzdCBbIEF0b20gXCJNYXAuZmluZF9leG46IG5vdCBmb3VuZFwiOyBzZXhwX29mX2tleSBrZXkgXSkpXG4gICAgaW5cbiAgICBsZXQgcmVjIGZpbmRfZXhuIHQgeCB+Y29tcGFyZV9rZXkgfnNleHBfb2Zfa2V5ID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBpZl9ub3RfZm91bmQgeCB+c2V4cF9vZl9rZXlcbiAgICAgIHwgTGVhZiAodiwgZCkgLT4gaWYgY29tcGFyZV9rZXkgeCB2ID0gMCB0aGVuIGQgZWxzZSBpZl9ub3RfZm91bmQgeCB+c2V4cF9vZl9rZXlcbiAgICAgIHwgTm9kZSAobCwgdiwgZCwgciwgXykgLT5cbiAgICAgICAgbGV0IGMgPSBjb21wYXJlX2tleSB4IHYgaW5cbiAgICAgICAgaWYgYyA9IDAgdGhlbiBkIGVsc2UgZmluZF9leG4gKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpIHggfmNvbXBhcmVfa2V5IH5zZXhwX29mX2tleVxuICAgIGluXG4gICAgKCogbmFtZWQgdG8gcHJlc2VydmUgc3ltYm9sIGluIGNvbXBpbGVkIGJpbmFyeSAqKVxuICAgIGZpbmRfZXhuXG4gIDs7XG5cbiAgbGV0IG1lbSB0IHggfmNvbXBhcmVfa2V5ID0gT3B0aW9uLmlzX3NvbWUgKGZpbmQgdCB4IH5jb21wYXJlX2tleSlcblxuICBsZXQgcmVjIG1pbl9lbHQgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgIHwgTGVhZiAoaywgZCkgLT4gU29tZSAoaywgZClcbiAgICB8IE5vZGUgKEVtcHR5LCBrLCBkLCBfLCBfKSAtPiBTb21lIChrLCBkKVxuICAgIHwgTm9kZSAobCwgXywgXywgXywgXykgLT4gbWluX2VsdCBsXG4gIDs7XG5cbiAgZXhjZXB0aW9uIE1hcF9taW5fZWx0X2V4bl9vZl9lbXB0eV9tYXAgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBdXG5cbiAgbGV0ICgpID1cbiAgICBTZXhwbGliMC5TZXhwX2NvbnYuRXhuX2NvbnZlcnRlci5hZGRcbiAgICAgIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIE1hcF9taW5fZWx0X2V4bl9vZl9lbXB0eV9tYXBdXG4gICAgICAoZnVuY3Rpb25cbiAgICAgICAgfCBNYXBfbWluX2VsdF9leG5fb2ZfZW1wdHlfbWFwIC0+XG4gICAgICAgICAgU2V4cGxpYjAuU2V4cC5BdG9tIFwibWFwLm1sLlRyZWUwLk1hcF9taW5fZWx0X2V4bl9vZl9lbXB0eV9tYXBcIlxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlKVxuICA7O1xuXG4gIFtAQEBlbmRdXG5cbiAgZXhjZXB0aW9uIE1hcF9tYXhfZWx0X2V4bl9vZl9lbXB0eV9tYXAgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBdXG5cbiAgbGV0ICgpID1cbiAgICBTZXhwbGliMC5TZXhwX2NvbnYuRXhuX2NvbnZlcnRlci5hZGRcbiAgICAgIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIE1hcF9tYXhfZWx0X2V4bl9vZl9lbXB0eV9tYXBdXG4gICAgICAoZnVuY3Rpb25cbiAgICAgICAgfCBNYXBfbWF4X2VsdF9leG5fb2ZfZW1wdHlfbWFwIC0+XG4gICAgICAgICAgU2V4cGxpYjAuU2V4cC5BdG9tIFwibWFwLm1sLlRyZWUwLk1hcF9tYXhfZWx0X2V4bl9vZl9lbXB0eV9tYXBcIlxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlKVxuICA7O1xuXG4gIFtAQEBlbmRdXG5cbiAgbGV0IG1pbl9lbHRfZXhuIHQgPVxuICAgIG1hdGNoIG1pbl9lbHQgdCB3aXRoXG4gICAgfCBOb25lIC0+IHJhaXNlIE1hcF9taW5fZWx0X2V4bl9vZl9lbXB0eV9tYXBcbiAgICB8IFNvbWUgdiAtPiB2XG4gIDs7XG5cbiAgbGV0IHJlYyBtYXhfZWx0ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICB8IExlYWYgKGssIGQpIC0+IFNvbWUgKGssIGQpXG4gICAgfCBOb2RlIChfLCBrLCBkLCBFbXB0eSwgXykgLT4gU29tZSAoaywgZClcbiAgICB8IE5vZGUgKF8sIF8sIF8sIHIsIF8pIC0+IG1heF9lbHQgclxuICA7O1xuXG4gIGxldCBtYXhfZWx0X2V4biB0ID1cbiAgICBtYXRjaCBtYXhfZWx0IHQgd2l0aFxuICAgIHwgTm9uZSAtPiByYWlzZSBNYXBfbWF4X2VsdF9leG5fb2ZfZW1wdHlfbWFwXG4gICAgfCBTb21lIHYgLT4gdlxuICA7O1xuXG4gIGxldCByZWMgcmVtb3ZlX21pbl9lbHQgdCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIk1hcC5yZW1vdmVfbWluX2VsdFwiXG4gICAgfCBMZWFmIF8gLT4gRW1wdHlcbiAgICB8IE5vZGUgKEVtcHR5LCBfLCBfLCByLCBfKSAtPiByXG4gICAgfCBOb2RlIChsLCB4LCBkLCByLCBfKSAtPiBiYWwgKHJlbW92ZV9taW5fZWx0IGwpIHggZCByXG4gIDs7XG5cbiAgbGV0IGFwcGVuZCB+bG93ZXJfcGFydCB+dXBwZXJfcGFydCB+Y29tcGFyZV9rZXkgPVxuICAgIG1hdGNoIG1heF9lbHQgbG93ZXJfcGFydCwgbWluX2VsdCB1cHBlcl9wYXJ0IHdpdGhcbiAgICB8IE5vbmUsIF8gLT4gYE9rIHVwcGVyX3BhcnRcbiAgICB8IF8sIE5vbmUgLT4gYE9rIGxvd2VyX3BhcnRcbiAgICB8IFNvbWUgKG1heF9sb3dlciwgXyksIFNvbWUgKG1pbl91cHBlciwgdikgd2hlbiBjb21wYXJlX2tleSBtYXhfbG93ZXIgbWluX3VwcGVyIDwgMCAtPlxuICAgICAgbGV0IHVwcGVyX3BhcnRfd2l0aG91dF9taW4gPSByZW1vdmVfbWluX2VsdCB1cHBlcl9wYXJ0IGluXG4gICAgICBgT2sgKGpvaW4gfmNvbXBhcmVfa2V5IGxvd2VyX3BhcnQgbWluX3VwcGVyIHYgdXBwZXJfcGFydF93aXRob3V0X21pbilcbiAgICB8IF8gLT4gYE92ZXJsYXBwaW5nX2tleV9yYW5nZXNcbiAgOztcblxuICBsZXQgZm9sZF9yYW5nZV9pbmNsdXNpdmUgPVxuICAgICgqIFRoaXMgYXNzdW1lcyB0aGF0IG1pbiA8PSBtYXgsIHdoaWNoIGlzIGNoZWNrZWQgYnkgdGhlIG91dGVyIGZ1bmN0aW9uLiAqKVxuICAgIGxldCByZWMgZ28gdCB+bWluIH5tYXggfmluaXQgfmYgfmNvbXBhcmVfa2V5ID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBpbml0XG4gICAgICB8IExlYWYgKGssIGQpIC0+XG4gICAgICAgIGlmIGNvbXBhcmVfa2V5IGsgbWluIDwgMCB8fCBjb21wYXJlX2tleSBrIG1heCA+IDBcbiAgICAgICAgdGhlbiAoKiBrIDwgbWluIHx8IGsgPiBtYXggKilcbiAgICAgICAgICBpbml0XG4gICAgICAgIGVsc2UgZiB+a2V5OmsgfmRhdGE6ZCBpbml0XG4gICAgICB8IE5vZGUgKGwsIGssIGQsIHIsIF8pIC0+XG4gICAgICAgIGxldCBjX21pbiA9IGNvbXBhcmVfa2V5IGsgbWluIGluXG4gICAgICAgIGlmIGNfbWluIDwgMFxuICAgICAgICB0aGVuXG4gICAgICAgICAgKCogaWYgayA8IG1pbiwgdGhlbiB0aGlzIG5vZGUgYW5kIGl0cyBsZWZ0IGJyYW5jaCBhcmUgb3V0c2lkZSBvdXIgcmFuZ2UgKilcbiAgICAgICAgICBnbyByIH5taW4gfm1heCB+aW5pdCB+ZiB+Y29tcGFyZV9rZXlcbiAgICAgICAgZWxzZSBpZiBjX21pbiA9IDBcbiAgICAgICAgdGhlblxuICAgICAgICAgICgqIGlmIGsgPSBtaW4sIHRoZW4gdGhpcyBub2RlJ3MgbGVmdCBicmFuY2ggaXMgb3V0c2lkZSBvdXIgcmFuZ2UgKilcbiAgICAgICAgICBnbyByIH5taW4gfm1heCB+aW5pdDooZiB+a2V5OmsgfmRhdGE6ZCBpbml0KSB+ZiB+Y29tcGFyZV9rZXlcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgKCogayA+IG1pbiAqKVxuICAgICAgICAgIGxldCB6ID0gZ28gbCB+bWluIH5tYXggfmluaXQgfmYgfmNvbXBhcmVfa2V5IGluXG4gICAgICAgICAgbGV0IGNfbWF4ID0gY29tcGFyZV9rZXkgayBtYXggaW5cbiAgICAgICAgICAoKiBpZiBrID4gbWF4LCB3ZSdyZSBkb25lICopXG4gICAgICAgICAgaWYgY19tYXggPiAwXG4gICAgICAgICAgdGhlbiB6XG4gICAgICAgICAgZWxzZSAoXG4gICAgICAgICAgICBsZXQgeiA9IGYgfmtleTprIH5kYXRhOmQgeiBpblxuICAgICAgICAgICAgKCogaWYgayA9IG1heCwgdGhlbiB3ZSBmb2xkIGluIHRoaXMgb25lIGxhc3QgdmFsdWUgYW5kIHdlJ3JlIGRvbmUgKilcbiAgICAgICAgICAgIGlmIGNfbWF4ID0gMCB0aGVuIHogZWxzZSBnbyByIH5taW4gfm1heCB+aW5pdDp6IH5mIH5jb21wYXJlX2tleSkpXG4gICAgaW5cbiAgICBmdW4gdCB+bWluIH5tYXggfmluaXQgfmYgfmNvbXBhcmVfa2V5IC0+XG4gICAgICBpZiBjb21wYXJlX2tleSBtaW4gbWF4IDw9IDAgdGhlbiBnbyB0IH5taW4gfm1heCB+aW5pdCB+ZiB+Y29tcGFyZV9rZXkgZWxzZSBpbml0XG4gIDs7XG5cbiAgbGV0IHJhbmdlX3RvX2FsaXN0IHQgfm1pbiB+bWF4IH5jb21wYXJlX2tleSA9XG4gICAgTGlzdC5yZXZcbiAgICAgIChmb2xkX3JhbmdlX2luY2x1c2l2ZVxuICAgICAgICAgdFxuICAgICAgICAgfm1pblxuICAgICAgICAgfm1heFxuICAgICAgICAgfmluaXQ6W11cbiAgICAgICAgIH5mOihmdW4gfmtleSB+ZGF0YSBsIC0+IChrZXksIGRhdGEpIDo6IGwpXG4gICAgICAgICB+Y29tcGFyZV9rZXkpXG4gIDs7XG5cbiAgbGV0IGNvbmNhdF91bmNoZWNrZWQgdDEgdDIgPVxuICAgIG1hdGNoIHQxLCB0MiB3aXRoXG4gICAgfCBFbXB0eSwgdCAtPiB0XG4gICAgfCB0LCBFbXB0eSAtPiB0XG4gICAgfCBfLCBfIC0+XG4gICAgICBsZXQgeCwgZCA9IG1pbl9lbHRfZXhuIHQyIGluXG4gICAgICBiYWwgdDEgeCBkIChyZW1vdmVfbWluX2VsdCB0MilcbiAgOztcblxuICBleGNlcHRpb24gUmVtb3ZlX25vX29wXG5cbiAgbGV0IHJlbW92ZSB0IHggfmxlbmd0aCB+Y29tcGFyZV9rZXkgPVxuICAgIGxldCByZWMgcmVtb3ZlX2xvb3AgdCB4IH5sZW5ndGggfmNvbXBhcmVfa2V5ID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBFeG4ucmFpc2Vfd2l0aG91dF9iYWNrdHJhY2UgUmVtb3ZlX25vX29wXG4gICAgICB8IExlYWYgKHYsIF8pIC0+XG4gICAgICAgIGlmIGNvbXBhcmVfa2V5IHggdiA9IDBcbiAgICAgICAgdGhlbiBFbXB0eSwgbGVuZ3RoIC0gMVxuICAgICAgICBlbHNlIEV4bi5yYWlzZV93aXRob3V0X2JhY2t0cmFjZSBSZW1vdmVfbm9fb3BcbiAgICAgIHwgTm9kZSAobCwgdiwgZCwgciwgXykgLT5cbiAgICAgICAgbGV0IGMgPSBjb21wYXJlX2tleSB4IHYgaW5cbiAgICAgICAgaWYgYyA9IDBcbiAgICAgICAgdGhlbiBjb25jYXRfdW5jaGVja2VkIGwgciwgbGVuZ3RoIC0gMVxuICAgICAgICBlbHNlIGlmIGMgPCAwXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIGxldCBsLCBsZW5ndGggPSByZW1vdmVfbG9vcCBsIHggfmxlbmd0aCB+Y29tcGFyZV9rZXkgaW5cbiAgICAgICAgICBiYWwgbCB2IGQgciwgbGVuZ3RoKVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBsZXQgciwgbGVuZ3RoID0gcmVtb3ZlX2xvb3AgciB4IH5sZW5ndGggfmNvbXBhcmVfa2V5IGluXG4gICAgICAgICAgYmFsIGwgdiBkIHIsIGxlbmd0aClcbiAgICBpblxuICAgIHRyeSByZW1vdmVfbG9vcCB0IHggfmxlbmd0aCB+Y29tcGFyZV9rZXkgd2l0aFxuICAgIHwgUmVtb3ZlX25vX29wIC0+IHQsIGxlbmd0aFxuICA7O1xuXG4gICgqIFVzZSBleGNlcHRpb24gdG8gYXZvaWQgdHJlZS1yZWJ1aWxkIGluIG5vLW9wIGNhc2UgKilcbiAgZXhjZXB0aW9uIENoYW5nZV9ub19vcFxuXG4gIGxldCBjaGFuZ2UgdCBrZXkgfmYgfmxlbmd0aCB+Y29tcGFyZV9rZXkgPVxuICAgIGxldCByZWMgY2hhbmdlX2NvcmUgdCBrZXkgZiA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgKG1hdGNoIGYgTm9uZSB3aXRoXG4gICAgICAgICB8IE5vbmUgLT4gcmFpc2UgQ2hhbmdlX25vX29wICgqIGVxdWl2YWxlbnQgdG8gcmV0dXJuaW5nOiBFbXB0eSAqKVxuICAgICAgICAgfCBTb21lIGRhdGEgLT4gTGVhZiAoa2V5LCBkYXRhKSwgbGVuZ3RoICsgMSlcbiAgICAgIHwgTGVhZiAodiwgZCkgLT5cbiAgICAgICAgbGV0IGMgPSBjb21wYXJlX2tleSBrZXkgdiBpblxuICAgICAgICBpZiBjID0gMFxuICAgICAgICB0aGVuIChcbiAgICAgICAgICBtYXRjaCBmIChTb21lIGQpIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gRW1wdHksIGxlbmd0aCAtIDFcbiAgICAgICAgICB8IFNvbWUgZCcgLT4gTGVhZiAodiwgZCcpLCBsZW5ndGgpXG4gICAgICAgIGVsc2UgaWYgYyA8IDBcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgbGV0IGwsIGxlbmd0aCA9IGNoYW5nZV9jb3JlIEVtcHR5IGtleSBmIGluXG4gICAgICAgICAgYmFsIGwgdiBkIEVtcHR5LCBsZW5ndGgpXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIGxldCByLCBsZW5ndGggPSBjaGFuZ2VfY29yZSBFbXB0eSBrZXkgZiBpblxuICAgICAgICAgIGJhbCBFbXB0eSB2IGQgciwgbGVuZ3RoKVxuICAgICAgfCBOb2RlIChsLCB2LCBkLCByLCBoKSAtPlxuICAgICAgICBsZXQgYyA9IGNvbXBhcmVfa2V5IGtleSB2IGluXG4gICAgICAgIGlmIGMgPSAwXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIG1hdGNoIGYgKFNvbWUgZCkgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiBjb25jYXRfdW5jaGVja2VkIGwgciwgbGVuZ3RoIC0gMVxuICAgICAgICAgIHwgU29tZSBkYXRhIC0+IE5vZGUgKGwsIGtleSwgZGF0YSwgciwgaCksIGxlbmd0aClcbiAgICAgICAgZWxzZSBpZiBjIDwgMFxuICAgICAgICB0aGVuIChcbiAgICAgICAgICBsZXQgbCwgbGVuZ3RoID0gY2hhbmdlX2NvcmUgbCBrZXkgZiBpblxuICAgICAgICAgIGJhbCBsIHYgZCByLCBsZW5ndGgpXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIGxldCByLCBsZW5ndGggPSBjaGFuZ2VfY29yZSByIGtleSBmIGluXG4gICAgICAgICAgYmFsIGwgdiBkIHIsIGxlbmd0aClcbiAgICBpblxuICAgIHRyeSBjaGFuZ2VfY29yZSB0IGtleSBmIHdpdGhcbiAgICB8IENoYW5nZV9ub19vcCAtPiB0LCBsZW5ndGhcbiAgOztcblxuICBsZXQgdXBkYXRlIHQga2V5IH5mIH5sZW5ndGggfmNvbXBhcmVfa2V5ID1cbiAgICBsZXQgcmVjIHVwZGF0ZV9jb3JlIHQga2V5IGYgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgIGxldCBkYXRhID0gZiBOb25lIGluXG4gICAgICAgIExlYWYgKGtleSwgZGF0YSksIGxlbmd0aCArIDFcbiAgICAgIHwgTGVhZiAodiwgZCkgLT5cbiAgICAgICAgbGV0IGMgPSBjb21wYXJlX2tleSBrZXkgdiBpblxuICAgICAgICBpZiBjID0gMFxuICAgICAgICB0aGVuIChcbiAgICAgICAgICBsZXQgZCcgPSBmIChTb21lIGQpIGluXG4gICAgICAgICAgTGVhZiAodiwgZCcpLCBsZW5ndGgpXG4gICAgICAgIGVsc2UgaWYgYyA8IDBcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgbGV0IGwsIGxlbmd0aCA9IHVwZGF0ZV9jb3JlIEVtcHR5IGtleSBmIGluXG4gICAgICAgICAgYmFsIGwgdiBkIEVtcHR5LCBsZW5ndGgpXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIGxldCByLCBsZW5ndGggPSB1cGRhdGVfY29yZSBFbXB0eSBrZXkgZiBpblxuICAgICAgICAgIGJhbCBFbXB0eSB2IGQgciwgbGVuZ3RoKVxuICAgICAgfCBOb2RlIChsLCB2LCBkLCByLCBoKSAtPlxuICAgICAgICBsZXQgYyA9IGNvbXBhcmVfa2V5IGtleSB2IGluXG4gICAgICAgIGlmIGMgPSAwXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIGxldCBkYXRhID0gZiAoU29tZSBkKSBpblxuICAgICAgICAgIE5vZGUgKGwsIGtleSwgZGF0YSwgciwgaCksIGxlbmd0aClcbiAgICAgICAgZWxzZSBpZiBjIDwgMFxuICAgICAgICB0aGVuIChcbiAgICAgICAgICBsZXQgbCwgbGVuZ3RoID0gdXBkYXRlX2NvcmUgbCBrZXkgZiBpblxuICAgICAgICAgIGJhbCBsIHYgZCByLCBsZW5ndGgpXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIGxldCByLCBsZW5ndGggPSB1cGRhdGVfY29yZSByIGtleSBmIGluXG4gICAgICAgICAgYmFsIGwgdiBkIHIsIGxlbmd0aClcbiAgICBpblxuICAgIHVwZGF0ZV9jb3JlIHQga2V5IGZcbiAgOztcblxuICBsZXQgcmVtb3ZlX211bHRpIHQga2V5IH5sZW5ndGggfmNvbXBhcmVfa2V5ID1cbiAgICBjaGFuZ2UgdCBrZXkgfmxlbmd0aCB+Y29tcGFyZV9rZXkgfmY6KGZ1bmN0aW9uXG4gICAgICB8IE5vbmUgfCBTb21lIChbXSB8IFsgXyBdKSAtPiBOb25lXG4gICAgICB8IFNvbWUgKF8gOjogKF8gOjogXyBhcyBub25fZW1wdHlfdGFpbCkpIC0+IFNvbWUgbm9uX2VtcHR5X3RhaWwpXG4gIDs7XG5cbiAgbGV0IHJlYyBpdGVyX2tleXMgdCB+ZiA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiAoKVxuICAgIHwgTGVhZiAodiwgXykgLT4gZiB2XG4gICAgfCBOb2RlIChsLCB2LCBfLCByLCBfKSAtPlxuICAgICAgaXRlcl9rZXlzIH5mIGw7XG4gICAgICBmIHY7XG4gICAgICBpdGVyX2tleXMgfmYgclxuICA7O1xuXG4gIGxldCByZWMgaXRlciB0IH5mID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+ICgpXG4gICAgfCBMZWFmIChfLCBkKSAtPiBmIGRcbiAgICB8IE5vZGUgKGwsIF8sIGQsIHIsIF8pIC0+XG4gICAgICBpdGVyIH5mIGw7XG4gICAgICBmIGQ7XG4gICAgICBpdGVyIH5mIHJcbiAgOztcblxuICBsZXQgcmVjIGl0ZXJpIHQgfmYgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gKClcbiAgICB8IExlYWYgKHYsIGQpIC0+IGYgfmtleTp2IH5kYXRhOmRcbiAgICB8IE5vZGUgKGwsIHYsIGQsIHIsIF8pIC0+XG4gICAgICBpdGVyaSB+ZiBsO1xuICAgICAgZiB+a2V5OnYgfmRhdGE6ZDtcbiAgICAgIGl0ZXJpIH5mIHJcbiAgOztcblxuICBsZXQgaXRlcmlfdW50aWwgPVxuICAgIGxldCByZWMgaXRlcmlfdW50aWxfbG9vcCB0IH5mIDogQ29udGludWVfb3Jfc3RvcC50ID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBDb250aW51ZVxuICAgICAgfCBMZWFmICh2LCBkKSAtPiBmIH5rZXk6diB+ZGF0YTpkXG4gICAgICB8IE5vZGUgKGwsIHYsIGQsIHIsIF8pIC0+XG4gICAgICAgIChtYXRjaCBpdGVyaV91bnRpbF9sb29wIH5mIGwgd2l0aFxuICAgICAgICAgfCBTdG9wIC0+IFN0b3BcbiAgICAgICAgIHwgQ29udGludWUgLT5cbiAgICAgICAgICAgKG1hdGNoIGYgfmtleTp2IH5kYXRhOmQgd2l0aFxuICAgICAgICAgICAgfCBTdG9wIC0+IFN0b3BcbiAgICAgICAgICAgIHwgQ29udGludWUgLT4gaXRlcmlfdW50aWxfbG9vcCB+ZiByKSlcbiAgICBpblxuICAgIGZ1biB0IH5mIC0+IEZpbmlzaGVkX29yX3VuZmluaXNoZWQub2ZfY29udGludWVfb3Jfc3RvcCAoaXRlcmlfdW50aWxfbG9vcCB0IH5mKVxuICA7O1xuXG4gIGxldCByZWMgbWFwIHQgfmYgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gRW1wdHlcbiAgICB8IExlYWYgKHYsIGQpIC0+IExlYWYgKHYsIGYgZClcbiAgICB8IE5vZGUgKGwsIHYsIGQsIHIsIGgpIC0+XG4gICAgICBsZXQgbCcgPSBtYXAgfmYgbCBpblxuICAgICAgbGV0IGQnID0gZiBkIGluXG4gICAgICBsZXQgcicgPSBtYXAgfmYgciBpblxuICAgICAgTm9kZSAobCcsIHYsIGQnLCByJywgaClcbiAgOztcblxuICBsZXQgcmVjIG1hcGkgdCB+ZiA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBFbXB0eVxuICAgIHwgTGVhZiAodiwgZCkgLT4gTGVhZiAodiwgZiB+a2V5OnYgfmRhdGE6ZClcbiAgICB8IE5vZGUgKGwsIHYsIGQsIHIsIGgpIC0+XG4gICAgICBsZXQgbCcgPSBtYXBpIH5mIGwgaW5cbiAgICAgIGxldCBkJyA9IGYgfmtleTp2IH5kYXRhOmQgaW5cbiAgICAgIGxldCByJyA9IG1hcGkgfmYgciBpblxuICAgICAgTm9kZSAobCcsIHYsIGQnLCByJywgaClcbiAgOztcblxuICBsZXQgcmVjIGZvbGQgdCB+aW5pdDphY2N1IH5mID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IGFjY3VcbiAgICB8IExlYWYgKHYsIGQpIC0+IGYgfmtleTp2IH5kYXRhOmQgYWNjdVxuICAgIHwgTm9kZSAobCwgdiwgZCwgciwgXykgLT4gZm9sZCB+ZiByIH5pbml0OihmIH5rZXk6diB+ZGF0YTpkIChmb2xkIH5mIGwgfmluaXQ6YWNjdSkpXG4gIDs7XG5cbiAgbGV0IGZvbGRfdW50aWwgdCB+aW5pdCB+ZiB+ZmluaXNoID1cbiAgICBsZXQgcmVjIGZvbGRfdW50aWxfbG9vcCB0IH5hY2MgfmYgOiAoXywgXykgQ29udGFpbmVyLkNvbnRpbnVlX29yX3N0b3AudCA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gQ29udGludWUgYWNjXG4gICAgICB8IExlYWYgKHYsIGQpIC0+IGYgfmtleTp2IH5kYXRhOmQgYWNjXG4gICAgICB8IE5vZGUgKGwsIHYsIGQsIHIsIF8pIC0+XG4gICAgICAgIChtYXRjaCBmb2xkX3VudGlsX2xvb3AgbCB+YWNjIH5mIHdpdGhcbiAgICAgICAgIHwgU3RvcCBmaW5hbCAtPiBTdG9wIGZpbmFsXG4gICAgICAgICB8IENvbnRpbnVlIGFjYyAtPlxuICAgICAgICAgICAobWF0Y2ggZiB+a2V5OnYgfmRhdGE6ZCBhY2Mgd2l0aFxuICAgICAgICAgICAgfCBTdG9wIGZpbmFsIC0+IFN0b3AgZmluYWxcbiAgICAgICAgICAgIHwgQ29udGludWUgYWNjIC0+IGZvbGRfdW50aWxfbG9vcCByIH5hY2MgfmYpKVxuICAgIGluXG4gICAgbWF0Y2ggZm9sZF91bnRpbF9sb29wIHQgfmFjYzppbml0IH5mIHdpdGhcbiAgICB8IENvbnRpbnVlIGFjYyAtPiBmaW5pc2ggYWNjXG4gICAgfCBTdG9wIHN0b3AgLT4gc3RvcFxuICA7O1xuXG4gIGxldCByZWMgZm9sZF9yaWdodCB0IH5pbml0OmFjY3UgfmYgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gYWNjdVxuICAgIHwgTGVhZiAodiwgZCkgLT4gZiB+a2V5OnYgfmRhdGE6ZCBhY2N1XG4gICAgfCBOb2RlIChsLCB2LCBkLCByLCBfKSAtPlxuICAgICAgZm9sZF9yaWdodCB+ZiBsIH5pbml0OihmIH5rZXk6diB+ZGF0YTpkIChmb2xkX3JpZ2h0IH5mIHIgfmluaXQ6YWNjdSkpXG4gIDs7XG5cbiAgbGV0IGZpbHRlcl9rZXlzIHQgfmYgfmNvbXBhcmVfa2V5ID1cbiAgICBmb2xkIH5pbml0OihFbXB0eSwgMCkgdCB+ZjooZnVuIH5rZXkgfmRhdGEgKGFjY3UsIGxlbmd0aCkgLT5cbiAgICAgIGlmIGYga2V5IHRoZW4gc2V0IH5sZW5ndGggfmtleSB+ZGF0YSBhY2N1IH5jb21wYXJlX2tleSBlbHNlIGFjY3UsIGxlbmd0aClcbiAgOztcblxuXG4gIGxldCBmaWx0ZXIgdCB+ZiB+Y29tcGFyZV9rZXkgPVxuICAgIGZvbGQgfmluaXQ6KEVtcHR5LCAwKSB0IH5mOihmdW4gfmtleSB+ZGF0YSAoYWNjdSwgbGVuZ3RoKSAtPlxuICAgICAgaWYgZiBkYXRhIHRoZW4gc2V0IH5sZW5ndGggfmtleSB+ZGF0YSBhY2N1IH5jb21wYXJlX2tleSBlbHNlIGFjY3UsIGxlbmd0aClcbiAgOztcblxuICBsZXQgZmlsdGVyaSB0IH5mIH5jb21wYXJlX2tleSA9XG4gICAgZm9sZCB+aW5pdDooRW1wdHksIDApIHQgfmY6KGZ1biB+a2V5IH5kYXRhIChhY2N1LCBsZW5ndGgpIC0+XG4gICAgICBpZiBmIH5rZXkgfmRhdGEgdGhlbiBzZXQgfmxlbmd0aCB+a2V5IH5kYXRhIGFjY3UgfmNvbXBhcmVfa2V5IGVsc2UgYWNjdSwgbGVuZ3RoKVxuICA7O1xuXG4gIGxldCBmaWx0ZXJfbWFwIHQgfmYgfmNvbXBhcmVfa2V5ID1cbiAgICBmb2xkIH5pbml0OihFbXB0eSwgMCkgdCB+ZjooZnVuIH5rZXkgfmRhdGEgKGFjY3UsIGxlbmd0aCkgLT5cbiAgICAgIG1hdGNoIGYgZGF0YSB3aXRoXG4gICAgICB8IE5vbmUgLT4gYWNjdSwgbGVuZ3RoXG4gICAgICB8IFNvbWUgYiAtPiBzZXQgfmxlbmd0aCB+a2V5IH5kYXRhOmIgYWNjdSB+Y29tcGFyZV9rZXkpXG4gIDs7XG5cbiAgbGV0IGZpbHRlcl9tYXBpIHQgfmYgfmNvbXBhcmVfa2V5ID1cbiAgICBmb2xkIH5pbml0OihFbXB0eSwgMCkgdCB+ZjooZnVuIH5rZXkgfmRhdGEgKGFjY3UsIGxlbmd0aCkgLT5cbiAgICAgIG1hdGNoIGYgfmtleSB+ZGF0YSB3aXRoXG4gICAgICB8IE5vbmUgLT4gYWNjdSwgbGVuZ3RoXG4gICAgICB8IFNvbWUgYiAtPiBzZXQgfmxlbmd0aCB+a2V5IH5kYXRhOmIgYWNjdSB+Y29tcGFyZV9rZXkpXG4gIDs7XG5cbiAgbGV0IHBhcnRpdGlvbl9tYXBpIHQgfmYgfmNvbXBhcmVfa2V5ID1cbiAgICBmb2xkXG4gICAgICB0XG4gICAgICB+aW5pdDooKEVtcHR5LCAwKSwgKEVtcHR5LCAwKSlcbiAgICAgIH5mOihmdW4gfmtleSB+ZGF0YSAocGFpcjEsIHBhaXIyKSAtPlxuICAgICAgICBtYXRjaCAoZiB+a2V5IH5kYXRhIDogXyBFaXRoZXIudCkgd2l0aFxuICAgICAgICB8IEZpcnN0IHggLT5cbiAgICAgICAgICBsZXQgdCwgbGVuZ3RoID0gcGFpcjEgaW5cbiAgICAgICAgICBzZXQgdCB+a2V5IH5kYXRhOnggfmNvbXBhcmVfa2V5IH5sZW5ndGgsIHBhaXIyXG4gICAgICAgIHwgU2Vjb25kIHkgLT5cbiAgICAgICAgICBsZXQgdCwgbGVuZ3RoID0gcGFpcjIgaW5cbiAgICAgICAgICBwYWlyMSwgc2V0IHQgfmtleSB+ZGF0YTp5IH5jb21wYXJlX2tleSB+bGVuZ3RoKVxuICA7O1xuXG4gIGxldCBwYXJ0aXRpb25fbWFwIHQgfmYgfmNvbXBhcmVfa2V5ID1cbiAgICBwYXJ0aXRpb25fbWFwaSB0IH5jb21wYXJlX2tleSB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXG4gIDs7XG5cbiAgbGV0IHBhcnRpdGlvbmlfdGYgdCB+ZiB+Y29tcGFyZV9rZXkgPVxuICAgIHBhcnRpdGlvbl9tYXBpIHQgfmNvbXBhcmVfa2V5IH5mOihmdW4gfmtleSB+ZGF0YSAtPlxuICAgICAgaWYgZiB+a2V5IH5kYXRhIHRoZW4gRmlyc3QgZGF0YSBlbHNlIFNlY29uZCBkYXRhKVxuICA7O1xuXG4gIGxldCBwYXJ0aXRpb25fdGYgdCB+ZiB+Y29tcGFyZV9rZXkgPVxuICAgIHBhcnRpdGlvbl9tYXBpIHQgfmNvbXBhcmVfa2V5IH5mOihmdW4gfmtleTpfIH5kYXRhIC0+XG4gICAgICBpZiBmIGRhdGEgdGhlbiBGaXJzdCBkYXRhIGVsc2UgU2Vjb25kIGRhdGEpXG4gIDs7XG5cbiAgbW9kdWxlIEVudW0gPSBzdHJ1Y3RcbiAgICB0eXBlIGluY3JlYXNpbmdcbiAgICB0eXBlIGRlY3JlYXNpbmdcblxuICAgIHR5cGUgKCdrLCAndiwgJ2RpcmVjdGlvbikgdCA9XG4gICAgICB8IEVuZFxuICAgICAgfCBNb3JlIG9mICdrICogJ3YgKiAoJ2ssICd2KSB0cmVlICogKCdrLCAndiwgJ2RpcmVjdGlvbikgdFxuXG4gICAgbGV0IHJlYyBjb25zIHQgKGUgOiAoXywgXywgaW5jcmVhc2luZykgdCkgOiAoXywgXywgaW5jcmVhc2luZykgdCA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gZVxuICAgICAgfCBMZWFmICh2LCBkKSAtPiBNb3JlICh2LCBkLCBFbXB0eSwgZSlcbiAgICAgIHwgTm9kZSAobCwgdiwgZCwgciwgXykgLT4gY29ucyBsIChNb3JlICh2LCBkLCByLCBlKSlcbiAgICA7O1xuXG4gICAgbGV0IHJlYyBjb25zX3JpZ2h0IHQgKGUgOiAoXywgXywgZGVjcmVhc2luZykgdCkgOiAoXywgXywgZGVjcmVhc2luZykgdCA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gZVxuICAgICAgfCBMZWFmICh2LCBkKSAtPiBNb3JlICh2LCBkLCBFbXB0eSwgZSlcbiAgICAgIHwgTm9kZSAobCwgdiwgZCwgciwgXykgLT4gY29uc19yaWdodCByIChNb3JlICh2LCBkLCBsLCBlKSlcbiAgICA7O1xuXG4gICAgbGV0IG9mX3RyZWUgdHJlZSA6IChfLCBfLCBpbmNyZWFzaW5nKSB0ID0gY29ucyB0cmVlIEVuZFxuICAgIGxldCBvZl90cmVlX3JpZ2h0IHRyZWUgOiAoXywgXywgZGVjcmVhc2luZykgdCA9IGNvbnNfcmlnaHQgdHJlZSBFbmRcblxuICAgIGxldCBzdGFydGluZ19hdF9pbmNyZWFzaW5nIHQga2V5IGNvbXBhcmUgOiAoXywgXywgaW5jcmVhc2luZykgdCA9XG4gICAgICBsZXQgcmVjIGxvb3AgdCBlID1cbiAgICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICAgIHwgRW1wdHkgLT4gZVxuICAgICAgICB8IExlYWYgKHYsIGQpIC0+IGxvb3AgKE5vZGUgKEVtcHR5LCB2LCBkLCBFbXB0eSwgMSkpIGVcbiAgICAgICAgfCBOb2RlIChfLCB2LCBfLCByLCBfKSB3aGVuIGNvbXBhcmUgdiBrZXkgPCAwIC0+IGxvb3AgciBlXG4gICAgICAgIHwgTm9kZSAobCwgdiwgZCwgciwgXykgLT4gbG9vcCBsIChNb3JlICh2LCBkLCByLCBlKSlcbiAgICAgIGluXG4gICAgICBsb29wIHQgRW5kXG4gICAgOztcblxuICAgIGxldCBzdGFydGluZ19hdF9kZWNyZWFzaW5nIHQga2V5IGNvbXBhcmUgOiAoXywgXywgZGVjcmVhc2luZykgdCA9XG4gICAgICBsZXQgcmVjIGxvb3AgdCBlID1cbiAgICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICAgIHwgRW1wdHkgLT4gZVxuICAgICAgICB8IExlYWYgKHYsIGQpIC0+IGxvb3AgKE5vZGUgKEVtcHR5LCB2LCBkLCBFbXB0eSwgMSkpIGVcbiAgICAgICAgfCBOb2RlIChsLCB2LCBfLCBfLCBfKSB3aGVuIGNvbXBhcmUgdiBrZXkgPiAwIC0+IGxvb3AgbCBlXG4gICAgICAgIHwgTm9kZSAobCwgdiwgZCwgciwgXykgLT4gbG9vcCByIChNb3JlICh2LCBkLCBsLCBlKSlcbiAgICAgIGluXG4gICAgICBsb29wIHQgRW5kXG4gICAgOztcblxuICAgIGxldCBjb21wYXJlIGNvbXBhcmVfa2V5IGNvbXBhcmVfZGF0YSB0MSB0MiA9XG4gICAgICBsZXQgcmVjIGxvb3AgdDEgdDIgPVxuICAgICAgICBtYXRjaCB0MSwgdDIgd2l0aFxuICAgICAgICB8IEVuZCwgRW5kIC0+IDBcbiAgICAgICAgfCBFbmQsIF8gLT4gLTFcbiAgICAgICAgfCBfLCBFbmQgLT4gMVxuICAgICAgICB8IE1vcmUgKHYxLCBkMSwgcjEsIGUxKSwgTW9yZSAodjIsIGQyLCByMiwgZTIpIC0+XG4gICAgICAgICAgbGV0IGMgPSBjb21wYXJlX2tleSB2MSB2MiBpblxuICAgICAgICAgIGlmIGMgPD4gMFxuICAgICAgICAgIHRoZW4gY1xuICAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICAgbGV0IGMgPSBjb21wYXJlX2RhdGEgZDEgZDIgaW5cbiAgICAgICAgICAgIGlmIGMgPD4gMFxuICAgICAgICAgICAgdGhlbiBjXG4gICAgICAgICAgICBlbHNlIGlmIHBoeXNfZXF1YWwgcjEgcjJcbiAgICAgICAgICAgIHRoZW4gbG9vcCBlMSBlMlxuICAgICAgICAgICAgZWxzZSBsb29wIChjb25zIHIxIGUxKSAoY29ucyByMiBlMikpXG4gICAgICBpblxuICAgICAgbG9vcCB0MSB0MlxuICAgIDs7XG5cbiAgICBsZXQgZXF1YWwgY29tcGFyZV9rZXkgZGF0YV9lcXVhbCB0MSB0MiA9XG4gICAgICBsZXQgcmVjIGxvb3AgdDEgdDIgPVxuICAgICAgICBtYXRjaCB0MSwgdDIgd2l0aFxuICAgICAgICB8IEVuZCwgRW5kIC0+IHRydWVcbiAgICAgICAgfCBFbmQsIF8gfCBfLCBFbmQgLT4gZmFsc2VcbiAgICAgICAgfCBNb3JlICh2MSwgZDEsIHIxLCBlMSksIE1vcmUgKHYyLCBkMiwgcjIsIGUyKSAtPlxuICAgICAgICAgIGNvbXBhcmVfa2V5IHYxIHYyID0gMFxuICAgICAgICAgICYmIGRhdGFfZXF1YWwgZDEgZDJcbiAgICAgICAgICAmJiBpZiBwaHlzX2VxdWFsIHIxIHIyIHRoZW4gbG9vcCBlMSBlMiBlbHNlIGxvb3AgKGNvbnMgcjEgZTEpIChjb25zIHIyIGUyKVxuICAgICAgaW5cbiAgICAgIGxvb3AgdDEgdDJcbiAgICA7O1xuXG4gICAgbGV0IHJlYyBmb2xkIH5pbml0IH5mID0gZnVuY3Rpb25cbiAgICAgIHwgRW5kIC0+IGluaXRcbiAgICAgIHwgTW9yZSAoa2V5LCBkYXRhLCB0cmVlLCBlbnVtKSAtPlxuICAgICAgICBsZXQgbmV4dCA9IGYgfmtleSB+ZGF0YSBpbml0IGluXG4gICAgICAgIGZvbGQgKGNvbnMgdHJlZSBlbnVtKSB+aW5pdDpuZXh0IH5mXG4gICAgOztcblxuICAgIGxldCBmb2xkMiBjb21wYXJlX2tleSB0MSB0MiB+aW5pdCB+ZiA9XG4gICAgICBsZXQgcmVjIGxvb3AgdDEgdDIgY3VyciA9XG4gICAgICAgIG1hdGNoIHQxLCB0MiB3aXRoXG4gICAgICAgIHwgRW5kLCBFbmQgLT4gY3VyclxuICAgICAgICB8IEVuZCwgXyAtPlxuICAgICAgICAgIGZvbGQgdDIgfmluaXQ6Y3VyciB+ZjooZnVuIH5rZXkgfmRhdGEgYWNjIC0+IGYgfmtleSB+ZGF0YTooYFJpZ2h0IGRhdGEpIGFjYylcbiAgICAgICAgfCBfLCBFbmQgLT5cbiAgICAgICAgICBmb2xkIHQxIH5pbml0OmN1cnIgfmY6KGZ1biB+a2V5IH5kYXRhIGFjYyAtPiBmIH5rZXkgfmRhdGE6KGBMZWZ0IGRhdGEpIGFjYylcbiAgICAgICAgfCBNb3JlIChrMSwgdjEsIHRyZWUxLCBlbnVtMSksIE1vcmUgKGsyLCB2MiwgdHJlZTIsIGVudW0yKSAtPlxuICAgICAgICAgIGxldCBjb21wYXJlX3Jlc3VsdCA9IGNvbXBhcmVfa2V5IGsxIGsyIGluXG4gICAgICAgICAgaWYgY29tcGFyZV9yZXN1bHQgPSAwXG4gICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICBsZXQgbmV4dCA9IGYgfmtleTprMSB+ZGF0YTooYEJvdGggKHYxLCB2MikpIGN1cnIgaW5cbiAgICAgICAgICAgIGxvb3AgKGNvbnMgdHJlZTEgZW51bTEpIChjb25zIHRyZWUyIGVudW0yKSBuZXh0KVxuICAgICAgICAgIGVsc2UgaWYgY29tcGFyZV9yZXN1bHQgPCAwXG4gICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICBsZXQgbmV4dCA9IGYgfmtleTprMSB+ZGF0YTooYExlZnQgdjEpIGN1cnIgaW5cbiAgICAgICAgICAgIGxvb3AgKGNvbnMgdHJlZTEgZW51bTEpIHQyIG5leHQpXG4gICAgICAgICAgZWxzZSAoXG4gICAgICAgICAgICBsZXQgbmV4dCA9IGYgfmtleTprMiB+ZGF0YTooYFJpZ2h0IHYyKSBjdXJyIGluXG4gICAgICAgICAgICBsb29wIHQxIChjb25zIHRyZWUyIGVudW0yKSBuZXh0KVxuICAgICAgaW5cbiAgICAgIGxvb3AgdDEgdDIgaW5pdFxuICAgIDs7XG5cbiAgICBsZXQgc3ltbWV0cmljX2RpZmYgdDEgdDIgfmNvbXBhcmVfa2V5IH5kYXRhX2VxdWFsID1cbiAgICAgIGxldCBzdGVwIHN0YXRlID1cbiAgICAgICAgbWF0Y2ggc3RhdGUgd2l0aFxuICAgICAgICB8IEVuZCwgRW5kIC0+IFNlcXVlbmNlLlN0ZXAuRG9uZVxuICAgICAgICB8IEVuZCwgTW9yZSAoa2V5LCBkYXRhLCB0cmVlLCBlbnVtKSAtPlxuICAgICAgICAgIFNlcXVlbmNlLlN0ZXAuWWllbGQgKChrZXksIGBSaWdodCBkYXRhKSwgKEVuZCwgY29ucyB0cmVlIGVudW0pKVxuICAgICAgICB8IE1vcmUgKGtleSwgZGF0YSwgdHJlZSwgZW51bSksIEVuZCAtPlxuICAgICAgICAgIFNlcXVlbmNlLlN0ZXAuWWllbGQgKChrZXksIGBMZWZ0IGRhdGEpLCAoY29ucyB0cmVlIGVudW0sIEVuZCkpXG4gICAgICAgIHwgKE1vcmUgKGsxLCB2MSwgdHJlZTEsIGVudW0xKSBhcyBsZWZ0KSwgKE1vcmUgKGsyLCB2MiwgdHJlZTIsIGVudW0yKSBhcyByaWdodCkgLT5cbiAgICAgICAgICBsZXQgY29tcGFyZV9yZXN1bHQgPSBjb21wYXJlX2tleSBrMSBrMiBpblxuICAgICAgICAgIGlmIGNvbXBhcmVfcmVzdWx0ID0gMFxuICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgbGV0IG5leHRfc3RhdGUgPVxuICAgICAgICAgICAgICBpZiBwaHlzX2VxdWFsIHRyZWUxIHRyZWUyXG4gICAgICAgICAgICAgIHRoZW4gZW51bTEsIGVudW0yXG4gICAgICAgICAgICAgIGVsc2UgY29ucyB0cmVlMSBlbnVtMSwgY29ucyB0cmVlMiBlbnVtMlxuICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIGlmIGRhdGFfZXF1YWwgdjEgdjJcbiAgICAgICAgICAgIHRoZW4gU2VxdWVuY2UuU3RlcC5Ta2lwIG5leHRfc3RhdGVcbiAgICAgICAgICAgIGVsc2UgU2VxdWVuY2UuU3RlcC5ZaWVsZCAoKGsxLCBgVW5lcXVhbCAodjEsIHYyKSksIG5leHRfc3RhdGUpKVxuICAgICAgICAgIGVsc2UgaWYgY29tcGFyZV9yZXN1bHQgPCAwXG4gICAgICAgICAgdGhlbiBTZXF1ZW5jZS5TdGVwLllpZWxkICgoazEsIGBMZWZ0IHYxKSwgKGNvbnMgdHJlZTEgZW51bTEsIHJpZ2h0KSlcbiAgICAgICAgICBlbHNlIFNlcXVlbmNlLlN0ZXAuWWllbGQgKChrMiwgYFJpZ2h0IHYyKSwgKGxlZnQsIGNvbnMgdHJlZTIgZW51bTIpKVxuICAgICAgaW5cbiAgICAgIFNlcXVlbmNlLnVuZm9sZF9zdGVwIH5pbml0OihvZl90cmVlIHQxLCBvZl90cmVlIHQyKSB+ZjpzdGVwXG4gICAgOztcblxuICAgIGxldCBmb2xkX3N5bW1ldHJpY19kaWZmIHQxIHQyIH5jb21wYXJlX2tleSB+ZGF0YV9lcXVhbCB+aW5pdCB+ZiA9XG4gICAgICBsZXQgYWRkIGFjYyBrIHYgPSBmIGFjYyAoaywgYFJpZ2h0IHYpIGluXG4gICAgICBsZXQgcmVtb3ZlIGFjYyBrIHYgPSBmIGFjYyAoaywgYExlZnQgdikgaW5cbiAgICAgIGxldCByZWMgbG9vcCBsZWZ0IHJpZ2h0IGFjYyA9XG4gICAgICAgIG1hdGNoIGxlZnQsIHJpZ2h0IHdpdGhcbiAgICAgICAgfCBFbmQsIGVudW0gLT4gZm9sZCBlbnVtIH5pbml0OmFjYyB+ZjooZnVuIH5rZXkgfmRhdGEgYWNjIC0+IGFkZCBhY2Mga2V5IGRhdGEpXG4gICAgICAgIHwgZW51bSwgRW5kIC0+IGZvbGQgZW51bSB+aW5pdDphY2MgfmY6KGZ1biB+a2V5IH5kYXRhIGFjYyAtPiByZW1vdmUgYWNjIGtleSBkYXRhKVxuICAgICAgICB8IChNb3JlIChrMSwgdjEsIHRyZWUxLCBlbnVtMSkgYXMgbGVmdCksIChNb3JlIChrMiwgdjIsIHRyZWUyLCBlbnVtMikgYXMgcmlnaHQpIC0+XG4gICAgICAgICAgbGV0IGNvbXBhcmVfcmVzdWx0ID0gY29tcGFyZV9rZXkgazEgazIgaW5cbiAgICAgICAgICBpZiBjb21wYXJlX3Jlc3VsdCA9IDBcbiAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgIGxldCBhY2MgPSBpZiBkYXRhX2VxdWFsIHYxIHYyIHRoZW4gYWNjIGVsc2UgZiBhY2MgKGsxLCBgVW5lcXVhbCAodjEsIHYyKSkgaW5cbiAgICAgICAgICAgIGlmIHBoeXNfZXF1YWwgdHJlZTEgdHJlZTJcbiAgICAgICAgICAgIHRoZW4gbG9vcCBlbnVtMSBlbnVtMiBhY2NcbiAgICAgICAgICAgIGVsc2UgbG9vcCAoY29ucyB0cmVlMSBlbnVtMSkgKGNvbnMgdHJlZTIgZW51bTIpIGFjYylcbiAgICAgICAgICBlbHNlIGlmIGNvbXBhcmVfcmVzdWx0IDwgMFxuICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgbGV0IGFjYyA9IHJlbW92ZSBhY2MgazEgdjEgaW5cbiAgICAgICAgICAgIGxvb3AgKGNvbnMgdHJlZTEgZW51bTEpIHJpZ2h0IGFjYylcbiAgICAgICAgICBlbHNlIChcbiAgICAgICAgICAgIGxldCBhY2MgPSBhZGQgYWNjIGsyIHYyIGluXG4gICAgICAgICAgICBsb29wIGxlZnQgKGNvbnMgdHJlZTIgZW51bTIpIGFjYylcbiAgICAgIGluXG4gICAgICBsb29wIChvZl90cmVlIHQxKSAob2ZfdHJlZSB0MikgaW5pdFxuICAgIDs7XG4gIGVuZFxuXG4gIGxldCB0b19zZXF1ZW5jZV9pbmNyZWFzaW5nIGNvbXBhcmF0b3IgfmZyb21fa2V5IHQgPVxuICAgIGxldCBuZXh0IGVudW0gPVxuICAgICAgbWF0Y2ggZW51bSB3aXRoXG4gICAgICB8IEVudW0uRW5kIC0+IFNlcXVlbmNlLlN0ZXAuRG9uZVxuICAgICAgfCBFbnVtLk1vcmUgKGssIHYsIHQsIGUpIC0+IFNlcXVlbmNlLlN0ZXAuWWllbGQgKChrLCB2KSwgRW51bS5jb25zIHQgZSlcbiAgICBpblxuICAgIGxldCBpbml0ID1cbiAgICAgIG1hdGNoIGZyb21fa2V5IHdpdGhcbiAgICAgIHwgTm9uZSAtPiBFbnVtLm9mX3RyZWUgdFxuICAgICAgfCBTb21lIGtleSAtPiBFbnVtLnN0YXJ0aW5nX2F0X2luY3JlYXNpbmcgdCBrZXkgY29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICBpblxuICAgIFNlcXVlbmNlLnVuZm9sZF9zdGVwIH5pbml0IH5mOm5leHRcbiAgOztcblxuICBsZXQgdG9fc2VxdWVuY2VfZGVjcmVhc2luZyBjb21wYXJhdG9yIH5mcm9tX2tleSB0ID1cbiAgICBsZXQgbmV4dCBlbnVtID1cbiAgICAgIG1hdGNoIGVudW0gd2l0aFxuICAgICAgfCBFbnVtLkVuZCAtPiBTZXF1ZW5jZS5TdGVwLkRvbmVcbiAgICAgIHwgRW51bS5Nb3JlIChrLCB2LCB0LCBlKSAtPiBTZXF1ZW5jZS5TdGVwLllpZWxkICgoaywgdiksIEVudW0uY29uc19yaWdodCB0IGUpXG4gICAgaW5cbiAgICBsZXQgaW5pdCA9XG4gICAgICBtYXRjaCBmcm9tX2tleSB3aXRoXG4gICAgICB8IE5vbmUgLT4gRW51bS5vZl90cmVlX3JpZ2h0IHRcbiAgICAgIHwgU29tZSBrZXkgLT4gRW51bS5zdGFydGluZ19hdF9kZWNyZWFzaW5nIHQga2V5IGNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgaW5cbiAgICBTZXF1ZW5jZS51bmZvbGRfc3RlcCB+aW5pdCB+ZjpuZXh0XG4gIDs7XG5cbiAgbGV0IHRvX3NlcXVlbmNlXG4gICAgICAgIGNvbXBhcmF0b3JcbiAgICAgICAgPyhvcmRlciA9IGBJbmNyZWFzaW5nX2tleSlcbiAgICAgICAgP2tleXNfZ3JlYXRlcl9vcl9lcXVhbF90b1xuICAgICAgICA/a2V5c19sZXNzX29yX2VxdWFsX3RvXG4gICAgICAgIHRcbiAgICA9XG4gICAgbGV0IGluY2x1c2l2ZV9ib3VuZCBzaWRlIHQgYm91bmQgPVxuICAgICAgbGV0IGNvbXBhcmVfa2V5ID0gY29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgaW5cbiAgICAgIGxldCBsLCBtYXliZSwgciA9IHNwbGl0IHQgYm91bmQgfmNvbXBhcmVfa2V5IGluXG4gICAgICBsZXQgdCA9IHNpZGUgKGwsIHIpIGluXG4gICAgICBtYXRjaCBtYXliZSB3aXRoXG4gICAgICB8IE5vbmUgLT4gdFxuICAgICAgfCBTb21lIChrZXksIGRhdGEpIC0+IHNldCcgdCBrZXkgZGF0YSB+Y29tcGFyZV9rZXlcbiAgICBpblxuICAgIG1hdGNoIG9yZGVyIHdpdGhcbiAgICB8IGBJbmNyZWFzaW5nX2tleSAtPlxuICAgICAgbGV0IHQgPSBPcHRpb24uZm9sZCBrZXlzX2xlc3Nfb3JfZXF1YWxfdG8gfmluaXQ6dCB+ZjooaW5jbHVzaXZlX2JvdW5kIGZzdCkgaW5cbiAgICAgIHRvX3NlcXVlbmNlX2luY3JlYXNpbmcgY29tcGFyYXRvciB+ZnJvbV9rZXk6a2V5c19ncmVhdGVyX29yX2VxdWFsX3RvIHRcbiAgICB8IGBEZWNyZWFzaW5nX2tleSAtPlxuICAgICAgbGV0IHQgPSBPcHRpb24uZm9sZCBrZXlzX2dyZWF0ZXJfb3JfZXF1YWxfdG8gfmluaXQ6dCB+ZjooaW5jbHVzaXZlX2JvdW5kIHNuZCkgaW5cbiAgICAgIHRvX3NlcXVlbmNlX2RlY3JlYXNpbmcgY29tcGFyYXRvciB+ZnJvbV9rZXk6a2V5c19sZXNzX29yX2VxdWFsX3RvIHRcbiAgOztcblxuICBsZXQgY29tcGFyZSBjb21wYXJlX2tleSBjb21wYXJlX2RhdGEgdDEgdDIgPVxuICAgIEVudW0uY29tcGFyZSBjb21wYXJlX2tleSBjb21wYXJlX2RhdGEgKEVudW0ub2ZfdHJlZSB0MSkgKEVudW0ub2ZfdHJlZSB0MilcbiAgOztcblxuICBsZXQgZXF1YWwgY29tcGFyZV9rZXkgY29tcGFyZV9kYXRhIHQxIHQyID1cbiAgICBFbnVtLmVxdWFsIGNvbXBhcmVfa2V5IGNvbXBhcmVfZGF0YSAoRW51bS5vZl90cmVlIHQxKSAoRW51bS5vZl90cmVlIHQyKVxuICA7O1xuXG4gIGxldCBpdGVyMiB0MSB0MiB+ZiB+Y29tcGFyZV9rZXkgPVxuICAgIEVudW0uZm9sZDJcbiAgICAgIGNvbXBhcmVfa2V5XG4gICAgICAoRW51bS5vZl90cmVlIHQxKVxuICAgICAgKEVudW0ub2ZfdHJlZSB0MilcbiAgICAgIH5pbml0OigpXG4gICAgICB+ZjooZnVuIH5rZXkgfmRhdGEgKCkgLT4gZiB+a2V5IH5kYXRhKVxuICA7O1xuXG4gIGxldCBmb2xkMiB0MSB0MiB+aW5pdCB+ZiB+Y29tcGFyZV9rZXkgPVxuICAgIEVudW0uZm9sZDIgY29tcGFyZV9rZXkgKEVudW0ub2ZfdHJlZSB0MSkgKEVudW0ub2ZfdHJlZSB0MikgfmYgfmluaXRcbiAgOztcblxuICBsZXQgc3ltbWV0cmljX2RpZmYgPSBFbnVtLnN5bW1ldHJpY19kaWZmXG5cbiAgbGV0IGZvbGRfc3ltbWV0cmljX2RpZmYgdDEgdDIgfmNvbXBhcmVfa2V5IH5kYXRhX2VxdWFsIH5pbml0IH5mID1cbiAgICAoKiBbRW51bS5mb2xkX2RpZmZzXSBpcyBhIGNvcnJlY3QgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBmdW5jdGlvbiwgYnV0IGlzIGNvbnNpZGVyYWJseVxuICAgICAgIHNsb3dlciwgYXMgd2UgaGF2ZSB0byBhbGxvY2F0ZSBxdWl0ZSBhIGxvdCBvZiBzdGF0ZSB0byB0cmFjayBlbnVtZXJhdGlvbiBvZiBhIHRyZWUuXG4gICAgICAgQXZvaWQgaWYgd2UgY2FuLlxuICAgICopXG4gICAgbGV0IHNsb3cgeCB5IH5pbml0ID0gRW51bS5mb2xkX3N5bW1ldHJpY19kaWZmIHggeSB+Y29tcGFyZV9rZXkgfmRhdGFfZXF1YWwgfmYgfmluaXQgaW5cbiAgICBsZXQgYWRkIGFjYyBrIHYgPSBmIGFjYyAoaywgYFJpZ2h0IHYpIGluXG4gICAgbGV0IHJlbW92ZSBhY2MgayB2ID0gZiBhY2MgKGssIGBMZWZ0IHYpIGluXG4gICAgbGV0IGRlbHRhIGFjYyBrIHYgdicgPSBpZiBkYXRhX2VxdWFsIHYgdicgdGhlbiBhY2MgZWxzZSBmIGFjYyAoaywgYFVuZXF1YWwgKHYsIHYnKSkgaW5cbiAgICAoKiBJZiB0d28gdHJlZXMgaGF2ZSB0aGUgc2FtZSBzdHJ1Y3R1cmUgYXQgdGhlIHJvb3QgKGFuZCB0aGUgc2FtZSBrZXksIGlmIHRoZXkncmVcbiAgICAgICBbTm9kZV1zKSB3ZSBjYW4gdHJpdmlhbGx5IGRpZmYgZWFjaCBzdWJwYXJ0IGluIG9idmlvdXMgd2F5cy4gKilcbiAgICBsZXQgcmVjIGxvb3AgdCB0JyBhY2MgPVxuICAgICAgaWYgcGh5c19lcXVhbCB0IHQnXG4gICAgICB0aGVuIGFjY1xuICAgICAgZWxzZSAoXG4gICAgICAgIG1hdGNoIHQsIHQnIHdpdGhcbiAgICAgICAgfCBFbXB0eSwgbmV3X3ZhbHMgLT5cbiAgICAgICAgICBmb2xkIG5ld192YWxzIH5pbml0OmFjYyB+ZjooZnVuIH5rZXkgfmRhdGEgYWNjIC0+IGFkZCBhY2Mga2V5IGRhdGEpXG4gICAgICAgIHwgb2xkX3ZhbHMsIEVtcHR5IC0+XG4gICAgICAgICAgZm9sZCBvbGRfdmFscyB+aW5pdDphY2MgfmY6KGZ1biB+a2V5IH5kYXRhIGFjYyAtPiByZW1vdmUgYWNjIGtleSBkYXRhKVxuICAgICAgICB8IExlYWYgKGssIHYpLCBMZWFmIChrJywgdicpIC0+XG4gICAgICAgICAgKG1hdGNoIGNvbXBhcmVfa2V5IGsgaycgd2l0aFxuICAgICAgICAgICB8IHggd2hlbiB4ID0gMCAtPiBkZWx0YSBhY2MgayB2IHYnXG4gICAgICAgICAgIHwgeCB3aGVuIHggPCAwIC0+XG4gICAgICAgICAgICAgbGV0IGFjYyA9IHJlbW92ZSBhY2MgayB2IGluXG4gICAgICAgICAgICAgYWRkIGFjYyBrJyB2J1xuICAgICAgICAgICB8IF8gKCogd2hlbiB4ID4gMCAqKSAtPlxuICAgICAgICAgICAgIGxldCBhY2MgPSBhZGQgYWNjIGsnIHYnIGluXG4gICAgICAgICAgICAgcmVtb3ZlIGFjYyBrIHYpXG4gICAgICAgIHwgTm9kZSAobCwgaywgdiwgciwgXyksIE5vZGUgKGwnLCBrJywgdicsIHInLCBfKSB3aGVuIGNvbXBhcmVfa2V5IGsgaycgPSAwIC0+XG4gICAgICAgICAgbGV0IGFjYyA9IGxvb3AgbCBsJyBhY2MgaW5cbiAgICAgICAgICBsZXQgYWNjID0gZGVsdGEgYWNjIGsgdiB2JyBpblxuICAgICAgICAgIGxvb3AgciByJyBhY2NcbiAgICAgICAgKCogT3VyIHJvb3RzIGFyZW4ndCB0aGUgc2FtZSBrZXkuIEZhbGxiYWNrIHRvIHRoZSBzbG93IG1vZGUuIFRyZWVzIHdpdGggc21hbGxcbiAgICAgICAgICAgZGlmZnMgd2lsbCBvbmx5IGRvIHRoaXMgb24gdmVyeSBzbWFsbCBwYXJ0cyBvZiB0aGUgdHJlZSAoaG9wZWZ1bGx5IC0gaWYgdGhlXG4gICAgICAgICAgIG92ZXJhbGwgcm9vdCBpcyByZWJhbGFuY2VkLCB3ZSdsbCBlYXQgdGhlIHdob2xlIGNvc3QsIHVuZm9ydHVuYXRlbHkuKSAqKVxuICAgICAgICB8IE5vZGUgXywgTm9kZSBfIHwgTm9kZSBfLCBMZWFmIF8gfCBMZWFmIF8sIE5vZGUgXyAtPiBzbG93IHQgdCcgfmluaXQ6YWNjKVxuICAgIGluXG4gICAgbG9vcCB0MSB0MiBpbml0XG4gIDs7XG5cbiAgbGV0IHJlYyBsZW5ndGggPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gMFxuICAgIHwgTGVhZiBfIC0+IDFcbiAgICB8IE5vZGUgKGwsIF8sIF8sIHIsIF8pIC0+IGxlbmd0aCBsICsgbGVuZ3RoIHIgKyAxXG4gIDs7XG5cbiAgbGV0IGhhc2hfZm9sZF90X2lnbm9yaW5nX3N0cnVjdHVyZSBoYXNoX2ZvbGRfa2V5IGhhc2hfZm9sZF9kYXRhIHN0YXRlIHQgPVxuICAgIGZvbGRcbiAgICAgIHRcbiAgICAgIH5pbml0OihoYXNoX2ZvbGRfaW50IHN0YXRlIChsZW5ndGggdCkpXG4gICAgICB+ZjooZnVuIH5rZXkgfmRhdGEgc3RhdGUgLT4gaGFzaF9mb2xkX2RhdGEgKGhhc2hfZm9sZF9rZXkgc3RhdGUga2V5KSBkYXRhKVxuICA7O1xuXG4gIGxldCBrZXlzIHQgPSBmb2xkX3JpZ2h0IH5mOihmdW4gfmtleSB+ZGF0YTpfIGxpc3QgLT4ga2V5IDo6IGxpc3QpIHQgfmluaXQ6W11cbiAgbGV0IGRhdGEgdCA9IGZvbGRfcmlnaHQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgbGlzdCAtPiBkYXRhIDo6IGxpc3QpIHQgfmluaXQ6W11cblxuICBtb2R1bGUgdHlwZSBGb2xkYWJsZSA9IHNpZ1xuICAgIHZhbCBuYW1lIDogc3RyaW5nXG5cbiAgICB0eXBlICdhIHRcblxuICAgIHZhbCBmb2xkIDogJ2EgdCAtPiBpbml0OidiIC0+IGY6KCdiIC0+ICdhIC0+ICdiKSAtPiAnYlxuICBlbmRcblxuICBtb2R1bGUgT2ZfZm9sZGFibGUgKE0gOiBGb2xkYWJsZSkgPSBzdHJ1Y3RcbiAgICBsZXQgb2ZfZm9sZGFibGVfZm9sZCBmb2xkYWJsZSB+aW5pdCB+ZiB+Y29tcGFyZV9rZXkgPVxuICAgICAgTS5mb2xkIGZvbGRhYmxlIH5pbml0OihlbXB0eSwgMCkgfmY6KGZ1biAoYWNjdW0sIGxlbmd0aCkgKGtleSwgZGF0YSkgLT5cbiAgICAgICAgbGV0IHByZXZfZGF0YSA9XG4gICAgICAgICAgbWF0Y2ggZmluZCBhY2N1bSBrZXkgfmNvbXBhcmVfa2V5IHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gaW5pdFxuICAgICAgICAgIHwgU29tZSBwcmV2IC0+IHByZXZcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IGRhdGEgPSBmIHByZXZfZGF0YSBkYXRhIGluXG4gICAgICAgIHNldCBhY2N1bSB+bGVuZ3RoIH5rZXkgfmRhdGEgfmNvbXBhcmVfa2V5KVxuICAgIDs7XG5cbiAgICBsZXQgb2ZfZm9sZGFibGVfcmVkdWNlIGZvbGRhYmxlIH5mIH5jb21wYXJlX2tleSA9XG4gICAgICBNLmZvbGQgZm9sZGFibGUgfmluaXQ6KGVtcHR5LCAwKSB+ZjooZnVuIChhY2N1bSwgbGVuZ3RoKSAoa2V5LCBkYXRhKSAtPlxuICAgICAgICBsZXQgbmV3X2RhdGEgPVxuICAgICAgICAgIG1hdGNoIGZpbmQgYWNjdW0ga2V5IH5jb21wYXJlX2tleSB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IGRhdGFcbiAgICAgICAgICB8IFNvbWUgcHJldiAtPiBmIHByZXYgZGF0YVxuICAgICAgICBpblxuICAgICAgICBzZXQgYWNjdW0gfmxlbmd0aCB+a2V5IH5kYXRhOm5ld19kYXRhIH5jb21wYXJlX2tleSlcbiAgICA7O1xuXG4gICAgbGV0IG9mX2ZvbGRhYmxlIGZvbGRhYmxlIH5jb21wYXJlX2tleSA9XG4gICAgICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICAgICAgbGV0IG1hcCA9XG4gICAgICAgICAgTS5mb2xkIGZvbGRhYmxlIH5pbml0OihlbXB0eSwgMCkgfmY6KGZ1biAodCwgbGVuZ3RoKSAoa2V5LCBkYXRhKSAtPlxuICAgICAgICAgICAgbGV0ICgoXywgbGVuZ3RoJykgYXMgYWNjKSA9IHNldCB+bGVuZ3RoIH5rZXkgfmRhdGEgdCB+Y29tcGFyZV9rZXkgaW5cbiAgICAgICAgICAgIGlmIGxlbmd0aCA9IGxlbmd0aCcgdGhlbiByLnJldHVybiAoYER1cGxpY2F0ZV9rZXkga2V5KSBlbHNlIGFjYylcbiAgICAgICAgaW5cbiAgICAgICAgYE9rIG1hcClcbiAgICA7O1xuXG4gICAgbGV0IG9mX2ZvbGRhYmxlX29yX2Vycm9yIGZvbGRhYmxlIH5jb21wYXJhdG9yID1cbiAgICAgIG1hdGNoIG9mX2ZvbGRhYmxlIGZvbGRhYmxlIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSB3aXRoXG4gICAgICB8IGBPayB4IC0+IFJlc3VsdC5PayB4XG4gICAgICB8IGBEdXBsaWNhdGVfa2V5IGtleSAtPlxuICAgICAgICBPcl9lcnJvci5lcnJvclxuICAgICAgICAgIChcIk1hcC5vZl9cIiBeIE0ubmFtZSBeIFwiX29yX2Vycm9yOiBkdXBsaWNhdGUga2V5XCIpXG4gICAgICAgICAga2V5XG4gICAgICAgICAgY29tcGFyYXRvci5zZXhwX29mX3RcbiAgICA7O1xuXG4gICAgbGV0IG9mX2ZvbGRhYmxlX2V4biBmb2xkYWJsZSB+Y29tcGFyYXRvciA9XG4gICAgICBtYXRjaCBvZl9mb2xkYWJsZSBmb2xkYWJsZSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgd2l0aFxuICAgICAgfCBgT2sgeCAtPiB4XG4gICAgICB8IGBEdXBsaWNhdGVfa2V5IGtleSAtPlxuICAgICAgICBFcnJvci5jcmVhdGUgKFwiTWFwLm9mX1wiIF4gTS5uYW1lIF4gXCJfZXhuOiBkdXBsaWNhdGUga2V5XCIpIGtleSBjb21wYXJhdG9yLnNleHBfb2ZfdFxuICAgICAgICB8PiBFcnJvci5yYWlzZVxuICAgIDs7XG4gIGVuZFxuXG4gIG1vZHVsZSBPZl9hbGlzdCA9IE9mX2ZvbGRhYmxlIChzdHJ1Y3RcbiAgICAgIGxldCBuYW1lID0gXCJhbGlzdFwiXG5cbiAgICAgIHR5cGUgJ2EgdCA9ICdhIGxpc3RcblxuICAgICAgbGV0IGZvbGQgPSBMaXN0LmZvbGRcbiAgICBlbmQpXG5cbiAgbGV0IG9mX2FsaXN0X2ZvbGQgPSBPZl9hbGlzdC5vZl9mb2xkYWJsZV9mb2xkXG4gIGxldCBvZl9hbGlzdF9yZWR1Y2UgPSBPZl9hbGlzdC5vZl9mb2xkYWJsZV9yZWR1Y2VcbiAgbGV0IG9mX2FsaXN0ID0gT2ZfYWxpc3Qub2ZfZm9sZGFibGVcbiAgbGV0IG9mX2FsaXN0X29yX2Vycm9yID0gT2ZfYWxpc3Qub2ZfZm9sZGFibGVfb3JfZXJyb3JcbiAgbGV0IG9mX2FsaXN0X2V4biA9IE9mX2FsaXN0Lm9mX2ZvbGRhYmxlX2V4blxuXG4gICgqIFJldmVyc2UgdGhlIGlucHV0LCB0aGVuIGZvbGQgZnJvbSBsZWZ0IHRvIHJpZ2h0LiBUaGUgcmVzdWx0aW5nIG1hcCB1c2VzIHRoZSBmaXJzdFxuICAgICBpbnN0YW5jZSBvZiBlYWNoIGtleSBmcm9tIHRoZSBpbnB1dCBsaXN0LiBUaGUgcmVsYXRpdmUgb3JkZXJpbmcgb2YgZWxlbWVudHMgaW4gZWFjaFxuICAgICBvdXRwdXQgbGlzdCBpcyB0aGUgc2FtZSBhcyBpbiB0aGUgaW5wdXQgbGlzdC4gKilcbiAgbGV0IG9mX2ZvbGRhYmxlX211bHRpIGZvbGRhYmxlIH5mb2xkIH5jb21wYXJlX2tleSA9XG4gICAgbGV0IGFsaXN0ID0gZm9sZCBmb2xkYWJsZSB+aW5pdDpbXSB+ZjooZnVuIGwgeCAtPiB4IDo6IGwpIGluXG4gICAgb2ZfYWxpc3RfZm9sZCBhbGlzdCB+aW5pdDpbXSB+ZjooZnVuIGwgeCAtPiB4IDo6IGwpIH5jb21wYXJlX2tleVxuICA7O1xuXG4gIGxldCBvZl9hbGlzdF9tdWx0aSBhbGlzdCB+Y29tcGFyZV9rZXkgPVxuICAgIG9mX2ZvbGRhYmxlX211bHRpIGFsaXN0IH5mb2xkOkxpc3QuZm9sZCB+Y29tcGFyZV9rZXlcbiAgOztcblxuICBtb2R1bGUgT2Zfc2VxdWVuY2UgPSBPZl9mb2xkYWJsZSAoc3RydWN0XG4gICAgICBsZXQgbmFtZSA9IFwic2VxdWVuY2VcIlxuXG4gICAgICB0eXBlICdhIHQgPSAnYSBTZXF1ZW5jZS50XG5cbiAgICAgIGxldCBmb2xkID0gU2VxdWVuY2UuZm9sZFxuICAgIGVuZClcblxuICBsZXQgb2Zfc2VxdWVuY2VfZm9sZCA9IE9mX3NlcXVlbmNlLm9mX2ZvbGRhYmxlX2ZvbGRcbiAgbGV0IG9mX3NlcXVlbmNlX3JlZHVjZSA9IE9mX3NlcXVlbmNlLm9mX2ZvbGRhYmxlX3JlZHVjZVxuICBsZXQgb2Zfc2VxdWVuY2UgPSBPZl9zZXF1ZW5jZS5vZl9mb2xkYWJsZVxuICBsZXQgb2Zfc2VxdWVuY2Vfb3JfZXJyb3IgPSBPZl9zZXF1ZW5jZS5vZl9mb2xkYWJsZV9vcl9lcnJvclxuICBsZXQgb2Zfc2VxdWVuY2VfZXhuID0gT2Zfc2VxdWVuY2Uub2ZfZm9sZGFibGVfZXhuXG5cbiAgbGV0IG9mX3NlcXVlbmNlX211bHRpIHNlcXVlbmNlIH5jb21wYXJlX2tleSA9XG4gICAgb2ZfZm9sZGFibGVfbXVsdGkgc2VxdWVuY2UgfmZvbGQ6U2VxdWVuY2UuZm9sZCB+Y29tcGFyZV9rZXlcbiAgOztcblxuICBsZXQgZm9yX2FsbCB0IH5mID1cbiAgICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICAgIGl0ZXIgdCB+ZjooZnVuIGRhdGEgLT4gaWYgbm90IChmIGRhdGEpIHRoZW4gci5yZXR1cm4gZmFsc2UpO1xuICAgICAgdHJ1ZSlcbiAgOztcblxuICBsZXQgZm9yX2FsbGkgdCB+ZiA9XG4gICAgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgICBpdGVyaSB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPiBpZiBub3QgKGYgfmtleSB+ZGF0YSkgdGhlbiByLnJldHVybiBmYWxzZSk7XG4gICAgICB0cnVlKVxuICA7O1xuXG4gIGxldCBleGlzdHMgdCB+ZiA9XG4gICAgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgICBpdGVyIHQgfmY6KGZ1biBkYXRhIC0+IGlmIGYgZGF0YSB0aGVuIHIucmV0dXJuIHRydWUpO1xuICAgICAgZmFsc2UpXG4gIDs7XG5cbiAgbGV0IGV4aXN0c2kgdCB+ZiA9XG4gICAgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgICBpdGVyaSB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPiBpZiBmIH5rZXkgfmRhdGEgdGhlbiByLnJldHVybiB0cnVlKTtcbiAgICAgIGZhbHNlKVxuICA7O1xuXG4gIGxldCBjb3VudCB0IH5mID1cbiAgICBmb2xkIHQgfmluaXQ6MCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSBhY2MgLT4gaWYgZiBkYXRhIHRoZW4gYWNjICsgMSBlbHNlIGFjYylcbiAgOztcblxuICBsZXQgY291bnRpIHQgfmYgPVxuICAgIGZvbGQgdCB+aW5pdDowIH5mOihmdW4gfmtleSB+ZGF0YSBhY2MgLT4gaWYgZiB+a2V5IH5kYXRhIHRoZW4gYWNjICsgMSBlbHNlIGFjYylcbiAgOztcblxuICBsZXQgdG9fYWxpc3QgPyhrZXlfb3JkZXIgPSBgSW5jcmVhc2luZykgdCA9XG4gICAgbWF0Y2gga2V5X29yZGVyIHdpdGhcbiAgICB8IGBJbmNyZWFzaW5nIC0+IGZvbGRfcmlnaHQgdCB+aW5pdDpbXSB+ZjooZnVuIH5rZXkgfmRhdGEgeCAtPiAoa2V5LCBkYXRhKSA6OiB4KVxuICAgIHwgYERlY3JlYXNpbmcgLT4gZm9sZCB0IH5pbml0OltdIH5mOihmdW4gfmtleSB+ZGF0YSB4IC0+IChrZXksIGRhdGEpIDo6IHgpXG4gIDs7XG5cbiAgbGV0IG1lcmdlIHQxIHQyIH5mIH5jb21wYXJlX2tleSA9XG4gICAgbGV0IGVsdHMgPSBVbmlmb3JtX2FycmF5LnVuc2FmZV9jcmVhdGVfdW5pbml0aWFsaXplZCB+bGVuOihsZW5ndGggdDEgKyBsZW5ndGggdDIpIGluXG4gICAgbGV0IGkgPSByZWYgMCBpblxuICAgIGl0ZXIyIHQxIHQyIH5jb21wYXJlX2tleSB+ZjooZnVuIH5rZXkgfmRhdGE6dmFsdWVzIC0+XG4gICAgICBtYXRjaCBmIH5rZXkgdmFsdWVzIHdpdGhcbiAgICAgIHwgU29tZSB2YWx1ZSAtPlxuICAgICAgICBVbmlmb3JtX2FycmF5LnNldCBlbHRzICFpIChrZXksIHZhbHVlKTtcbiAgICAgICAgaW5jciBpXG4gICAgICB8IE5vbmUgLT4gKCkpO1xuICAgIGxldCBsZW4gPSAhaSBpblxuICAgIGxldCBnZXQgaSA9IFVuaWZvcm1fYXJyYXkuZ2V0IGVsdHMgaSBpblxuICAgIGxldCB0cmVlID0gb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmxlbiB+ZjpnZXQgaW5cbiAgICB0cmVlLCBsZW5cbiAgOztcblxuICBsZXQgbWVyZ2Vfc2tld2VkID1cbiAgICBsZXQgbWVyZ2VfbGFyZ2VfZmlyc3QgbGVuZ3RoX2xhcmdlIHRfbGFyZ2UgdF9zbWFsbCB+Y2FsbCB+Y29tYmluZSB+Y29tcGFyZV9rZXkgPVxuICAgICAgZm9sZCB0X3NtYWxsIH5pbml0Oih0X2xhcmdlLCBsZW5ndGhfbGFyZ2UpIH5mOihmdW4gfmtleSB+ZGF0YTpkYXRhJyAodCwgbGVuZ3RoKSAtPlxuICAgICAgICB1cGRhdGUgdCBrZXkgfmxlbmd0aCB+Y29tcGFyZV9rZXkgfmY6KGZ1bmN0aW9uXG4gICAgICAgICAgfCBOb25lIC0+IGRhdGEnXG4gICAgICAgICAgfCBTb21lIGRhdGEgLT4gY2FsbCBjb21iaW5lIH5rZXkgZGF0YSBkYXRhJykpXG4gICAgaW5cbiAgICBsZXQgY2FsbCBmIH5rZXkgeCB5ID0gZiB+a2V5IHggeSBpblxuICAgIGxldCBzd2FwIGYgfmtleSB4IHkgPSBmIH5rZXkgeSB4IGluXG4gICAgZnVuIHQxIHQyIH5sZW5ndGgxIH5sZW5ndGgyIH5jb21iaW5lIH5jb21wYXJlX2tleSAtPlxuICAgICAgaWYgbGVuZ3RoMiA8PSBsZW5ndGgxXG4gICAgICB0aGVuIG1lcmdlX2xhcmdlX2ZpcnN0IGxlbmd0aDEgdDEgdDIgfmNhbGwgfmNvbWJpbmUgfmNvbXBhcmVfa2V5XG4gICAgICBlbHNlIG1lcmdlX2xhcmdlX2ZpcnN0IGxlbmd0aDIgdDIgdDEgfmNhbGw6c3dhcCB+Y29tYmluZSB+Y29tcGFyZV9rZXlcbiAgOztcblxuICBtb2R1bGUgQ2xvc2VzdF9rZXlfaW1wbCA9IHN0cnVjdFxuICAgICgqIFttYXJrZXJdIGFuZCBbcmVwYWNrYWdlXSBhbGxvdyB1cyB0byBjcmVhdGUgXCJsb2dpY2FsXCIgb3B0aW9ucyB3aXRob3V0IGFjdHVhbGx5XG4gICAgICAgYWxsb2NhdGluZyBhbnkgb3B0aW9ucy4gUGFzc2luZyBbRm91bmQga2V5IHZhbHVlXSB0byBhIGZ1bmN0aW9uIGlzIGVxdWl2YWxlbnQgdG9cbiAgICAgICBwYXNzaW5nIFtTb21lIChrZXksIHZhbHVlKV07IHBhc3NpbmcgW01pc3NpbmcgKCkgKCldIGlzIGVxdWl2YWxlbnQgdG8gcGFzc2luZ1xuICAgICAgIFtOb25lXS4gKilcbiAgICB0eXBlICgnaywgJ3YsICdrX29wdCwgJ3Zfb3B0KSBtYXJrZXIgPVxuICAgICAgfCBNaXNzaW5nIDogKCdrLCAndiwgdW5pdCwgdW5pdCkgbWFya2VyXG4gICAgICB8IEZvdW5kIDogKCdrLCAndiwgJ2ssICd2KSBtYXJrZXJcblxuICAgIGxldCByZXBhY2thZ2VcbiAgICAgICAgICAodHlwZSBrIHYga19vcHQgdl9vcHQpXG4gICAgICAgICAgKG1hcmtlciA6IChrLCB2LCBrX29wdCwgdl9vcHQpIG1hcmtlcilcbiAgICAgICAgICAoayA6IGtfb3B0KVxuICAgICAgICAgICh2IDogdl9vcHQpXG4gICAgICA6IChrICogdikgb3B0aW9uXG4gICAgICA9XG4gICAgICBtYXRjaCBtYXJrZXIgd2l0aFxuICAgICAgfCBNaXNzaW5nIC0+IE5vbmVcbiAgICAgIHwgRm91bmQgLT4gU29tZSAoaywgdilcbiAgICA7O1xuXG4gICAgKCogVGhlIHR5cGUgc2lnbmF0dXJlIGlzIGV4cGxpY2l0IGhlcmUgdG8gYWxsb3cgcG9seW1vcnBoaWMgcmVjdXJzaW9uLiAqKVxuICAgIGxldCByZWMgbG9vcCA6XG4gICAgICAnayAndiAna19vcHQgJ3Zfb3B0LlxuICAgICAgKCdrLCAndikgdHJlZVxuICAgICAgLT4gWyBgR3JlYXRlcl9vcl9lcXVhbF90byB8IGBHcmVhdGVyX3RoYW4gfCBgTGVzc19vcl9lcXVhbF90byB8IGBMZXNzX3RoYW4gXVxuICAgICAgLT4gJ2tcbiAgICAgIC0+IGNvbXBhcmVfa2V5OignayAtPiAnayAtPiBpbnQpXG4gICAgICAtPiAoJ2ssICd2LCAna19vcHQsICd2X29wdCkgbWFya2VyXG4gICAgICAtPiAna19vcHRcbiAgICAgIC0+ICd2X29wdFxuICAgICAgLT4gKCdrICogJ3YpIG9wdGlvblxuICAgICAgPVxuICAgICAgZnVuIHQgZGlyIGsgfmNvbXBhcmVfa2V5IGZvdW5kX21hcmtlciBmb3VuZF9rZXkgZm91bmRfdmFsdWUgLT5cbiAgICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICAgIHwgRW1wdHkgLT4gcmVwYWNrYWdlIGZvdW5kX21hcmtlciBmb3VuZF9rZXkgZm91bmRfdmFsdWVcbiAgICAgICAgfCBMZWFmIChrJywgdicpIC0+XG4gICAgICAgICAgbGV0IGMgPSBjb21wYXJlX2tleSBrJyBrIGluXG4gICAgICAgICAgaWYgbWF0Y2ggZGlyIHdpdGhcbiAgICAgICAgICAgIHwgYEdyZWF0ZXJfb3JfZXF1YWxfdG8gLT4gYyA+PSAwXG4gICAgICAgICAgICB8IGBHcmVhdGVyX3RoYW4gLT4gYyA+IDBcbiAgICAgICAgICAgIHwgYExlc3Nfb3JfZXF1YWxfdG8gLT4gYyA8PSAwXG4gICAgICAgICAgICB8IGBMZXNzX3RoYW4gLT4gYyA8IDBcbiAgICAgICAgICB0aGVuIFNvbWUgKGsnLCB2JylcbiAgICAgICAgICBlbHNlIHJlcGFja2FnZSBmb3VuZF9tYXJrZXIgZm91bmRfa2V5IGZvdW5kX3ZhbHVlXG4gICAgICAgIHwgTm9kZSAobCwgaycsIHYnLCByLCBfKSAtPlxuICAgICAgICAgIGxldCBjID0gY29tcGFyZV9rZXkgaycgayBpblxuICAgICAgICAgIGlmIGMgPSAwXG4gICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICAoKiBUaGlzIGlzIGEgYmFzZSBjYXNlIChubyByZWN1cnNpdmUgY2FsbCkuICopXG4gICAgICAgICAgICBtYXRjaCBkaXIgd2l0aFxuICAgICAgICAgICAgfCBgR3JlYXRlcl9vcl9lcXVhbF90byB8IGBMZXNzX29yX2VxdWFsX3RvIC0+IFNvbWUgKGsnLCB2JylcbiAgICAgICAgICAgIHwgYEdyZWF0ZXJfdGhhbiAtPlxuICAgICAgICAgICAgICBpZiBpc19lbXB0eSByIHRoZW4gcmVwYWNrYWdlIGZvdW5kX21hcmtlciBmb3VuZF9rZXkgZm91bmRfdmFsdWUgZWxzZSBtaW5fZWx0IHJcbiAgICAgICAgICAgIHwgYExlc3NfdGhhbiAtPlxuICAgICAgICAgICAgICBpZiBpc19lbXB0eSBsIHRoZW4gcmVwYWNrYWdlIGZvdW5kX21hcmtlciBmb3VuZF9rZXkgZm91bmRfdmFsdWUgZWxzZSBtYXhfZWx0IGwpXG4gICAgICAgICAgZWxzZSAoXG4gICAgICAgICAgICAoKiBXZSBhcmUgZ3VhcmFudGVlZCBoZXJlIHRoYXQgaycgPD4gay4gKilcbiAgICAgICAgICAgICgqIFRoaXMgaXMgdGhlIG9ubHkgcmVjdXJzaXZlIGNhc2UuICopXG4gICAgICAgICAgICBtYXRjaCBkaXIgd2l0aFxuICAgICAgICAgICAgfCBgR3JlYXRlcl9vcl9lcXVhbF90byB8IGBHcmVhdGVyX3RoYW4gLT5cbiAgICAgICAgICAgICAgaWYgYyA+IDBcbiAgICAgICAgICAgICAgdGhlbiBsb29wIGwgZGlyIGsgfmNvbXBhcmVfa2V5IEZvdW5kIGsnIHYnXG4gICAgICAgICAgICAgIGVsc2UgbG9vcCByIGRpciBrIH5jb21wYXJlX2tleSBmb3VuZF9tYXJrZXIgZm91bmRfa2V5IGZvdW5kX3ZhbHVlXG4gICAgICAgICAgICB8IGBMZXNzX29yX2VxdWFsX3RvIHwgYExlc3NfdGhhbiAtPlxuICAgICAgICAgICAgICBpZiBjIDwgMFxuICAgICAgICAgICAgICB0aGVuIGxvb3AgciBkaXIgayB+Y29tcGFyZV9rZXkgRm91bmQgaycgdidcbiAgICAgICAgICAgICAgZWxzZSBsb29wIGwgZGlyIGsgfmNvbXBhcmVfa2V5IGZvdW5kX21hcmtlciBmb3VuZF9rZXkgZm91bmRfdmFsdWUpXG4gICAgOztcblxuICAgIGxldCBjbG9zZXN0X2tleSB0IGRpciBrIH5jb21wYXJlX2tleSA9IGxvb3AgdCBkaXIgayB+Y29tcGFyZV9rZXkgTWlzc2luZyAoKSAoKVxuICBlbmRcblxuICBsZXQgY2xvc2VzdF9rZXkgPSBDbG9zZXN0X2tleV9pbXBsLmNsb3Nlc3Rfa2V5XG5cbiAgbGV0IHJlYyByYW5rIHQgayB+Y29tcGFyZV9rZXkgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgIHwgTGVhZiAoaycsIF8pIC0+IGlmIGNvbXBhcmVfa2V5IGsnIGsgPSAwIHRoZW4gU29tZSAwIGVsc2UgTm9uZVxuICAgIHwgTm9kZSAobCwgaycsIF8sIHIsIF8pIC0+XG4gICAgICBsZXQgYyA9IGNvbXBhcmVfa2V5IGsnIGsgaW5cbiAgICAgIGlmIGMgPSAwXG4gICAgICB0aGVuIFNvbWUgKGxlbmd0aCBsKVxuICAgICAgZWxzZSBpZiBjID4gMFxuICAgICAgdGhlbiByYW5rIGwgayB+Y29tcGFyZV9rZXlcbiAgICAgIGVsc2UgT3B0aW9uLm1hcCAocmFuayByIGsgfmNvbXBhcmVfa2V5KSB+ZjooZnVuIHJhbmsgLT4gcmFuayArIDEgKyBsZW5ndGggbClcbiAgOztcblxuICAoKiB0aGlzIGNvdWxkIGJlIGltcGxlbWVudGVkIHVzaW5nIFtTZXF1ZW5jZV0gaW50ZXJmYWNlIGJ1dCB0aGUgZm9sbG93aW5nIGltcGxlbWVudGF0aW9uXG4gICAgIGFsbG9jYXRlcyBvbmx5IDIgd29yZHMgYW5kIGRvZXNuJ3QgcmVxdWlyZSB3cml0ZS1iYXJyaWVyICopXG4gIGxldCByZWMgbnRoJyBudW1fdG9fc2VhcmNoID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICB8IExlYWYgKGssIHYpIC0+XG4gICAgICBpZiAhbnVtX3RvX3NlYXJjaCA9IDBcbiAgICAgIHRoZW4gU29tZSAoaywgdilcbiAgICAgIGVsc2UgKFxuICAgICAgICBkZWNyIG51bV90b19zZWFyY2g7XG4gICAgICAgIE5vbmUpXG4gICAgfCBOb2RlIChsLCBrLCB2LCByLCBfKSAtPlxuICAgICAgKG1hdGNoIG50aCcgbnVtX3RvX3NlYXJjaCBsIHdpdGhcbiAgICAgICB8IFNvbWUgXyBhcyBzb21lIC0+IHNvbWVcbiAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgIGlmICFudW1fdG9fc2VhcmNoID0gMFxuICAgICAgICAgdGhlbiBTb21lIChrLCB2KVxuICAgICAgICAgZWxzZSAoXG4gICAgICAgICAgIGRlY3IgbnVtX3RvX3NlYXJjaDtcbiAgICAgICAgICAgbnRoJyBudW1fdG9fc2VhcmNoIHIpKVxuICA7O1xuXG4gIGxldCBudGggdCBuID0gbnRoJyAocmVmIG4pIHRcblxuXG4gIGxldCByZWMgZmluZF9maXJzdF9zYXRpc2Z5aW5nIHQgfmYgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgIHwgTGVhZiAoaywgdikgLT4gaWYgZiB+a2V5OmsgfmRhdGE6diB0aGVuIFNvbWUgKGssIHYpIGVsc2UgTm9uZVxuICAgIHwgTm9kZSAobCwgaywgdiwgciwgXykgLT5cbiAgICAgIGlmIGYgfmtleTprIH5kYXRhOnZcbiAgICAgIHRoZW4gKFxuICAgICAgICBtYXRjaCBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgbCB+ZiB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBTb21lIChrLCB2KVxuICAgICAgICB8IFNvbWUgXyBhcyB4IC0+IHgpXG4gICAgICBlbHNlIGZpbmRfZmlyc3Rfc2F0aXNmeWluZyByIH5mXG4gIDs7XG5cbiAgbGV0IHJlYyBmaW5kX2xhc3Rfc2F0aXNmeWluZyB0IH5mID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICB8IExlYWYgKGssIHYpIC0+IGlmIGYgfmtleTprIH5kYXRhOnYgdGhlbiBTb21lIChrLCB2KSBlbHNlIE5vbmVcbiAgICB8IE5vZGUgKGwsIGssIHYsIHIsIF8pIC0+XG4gICAgICBpZiBmIH5rZXk6ayB+ZGF0YTp2XG4gICAgICB0aGVuIChcbiAgICAgICAgbWF0Y2ggZmluZF9sYXN0X3NhdGlzZnlpbmcgciB+ZiB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBTb21lIChrLCB2KVxuICAgICAgICB8IFNvbWUgXyBhcyB4IC0+IHgpXG4gICAgICBlbHNlIGZpbmRfbGFzdF9zYXRpc2Z5aW5nIGwgfmZcbiAgOztcblxuICBsZXQgYmluYXJ5X3NlYXJjaCB0IH5jb21wYXJlIGhvdyB2ID1cbiAgICBtYXRjaCBob3cgd2l0aFxuICAgIHwgYExhc3Rfc3RyaWN0bHlfbGVzc190aGFuIC0+XG4gICAgICBmaW5kX2xhc3Rfc2F0aXNmeWluZyB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPiBjb21wYXJlIH5rZXkgfmRhdGEgdiA8IDApXG4gICAgfCBgTGFzdF9sZXNzX3RoYW5fb3JfZXF1YWxfdG8gLT5cbiAgICAgIGZpbmRfbGFzdF9zYXRpc2Z5aW5nIHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+IGNvbXBhcmUgfmtleSB+ZGF0YSB2IDw9IDApXG4gICAgfCBgRmlyc3RfZXF1YWxfdG8gLT5cbiAgICAgIChtYXRjaCBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT4gY29tcGFyZSB+a2V5IH5kYXRhIHYgPj0gMCkgd2l0aFxuICAgICAgIHwgU29tZSAoa2V5LCBkYXRhKSBhcyBwYWlyIHdoZW4gY29tcGFyZSB+a2V5IH5kYXRhIHYgPSAwIC0+IHBhaXJcbiAgICAgICB8IE5vbmUgfCBTb21lIF8gLT4gTm9uZSlcbiAgICB8IGBMYXN0X2VxdWFsX3RvIC0+XG4gICAgICAobWF0Y2ggZmluZF9sYXN0X3NhdGlzZnlpbmcgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT4gY29tcGFyZSB+a2V5IH5kYXRhIHYgPD0gMCkgd2l0aFxuICAgICAgIHwgU29tZSAoa2V5LCBkYXRhKSBhcyBwYWlyIHdoZW4gY29tcGFyZSB+a2V5IH5kYXRhIHYgPSAwIC0+IHBhaXJcbiAgICAgICB8IE5vbmUgfCBTb21lIF8gLT4gTm9uZSlcbiAgICB8IGBGaXJzdF9ncmVhdGVyX3RoYW5fb3JfZXF1YWxfdG8gLT5cbiAgICAgIGZpbmRfZmlyc3Rfc2F0aXNmeWluZyB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPiBjb21wYXJlIH5rZXkgfmRhdGEgdiA+PSAwKVxuICAgIHwgYEZpcnN0X3N0cmljdGx5X2dyZWF0ZXJfdGhhbiAtPlxuICAgICAgZmluZF9maXJzdF9zYXRpc2Z5aW5nIHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+IGNvbXBhcmUgfmtleSB+ZGF0YSB2ID4gMClcbiAgOztcblxuICBsZXQgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQgdCB+c2VnbWVudF9vZiBob3cgPVxuICAgIGxldCBpc19sZWZ0IH5rZXkgfmRhdGEgPVxuICAgICAgbWF0Y2ggc2VnbWVudF9vZiB+a2V5IH5kYXRhIHdpdGhcbiAgICAgIHwgYExlZnQgLT4gdHJ1ZVxuICAgICAgfCBgUmlnaHQgLT4gZmFsc2VcbiAgICBpblxuICAgIGxldCBpc19yaWdodCB+a2V5IH5kYXRhID0gbm90IChpc19sZWZ0IH5rZXkgfmRhdGEpIGluXG4gICAgbWF0Y2ggaG93IHdpdGhcbiAgICB8IGBMYXN0X29uX2xlZnQgLT4gZmluZF9sYXN0X3NhdGlzZnlpbmcgdCB+Zjppc19sZWZ0XG4gICAgfCBgRmlyc3Rfb25fcmlnaHQgLT4gZmluZF9maXJzdF9zYXRpc2Z5aW5nIHQgfmY6aXNfcmlnaHRcbiAgOztcblxuICAoKiBbYmluYXJ5X3NlYXJjaF9vbmVfc2lkZWRfYm91bmRdIGZpbmRzIHRoZSBrZXkgaW4gW3RdIHdoaWNoIHNhdGlzZmllcyBbbWF5YmVfYm91bmRdXG4gICAgIGFuZCB0aGUgcmVsZXZhbnQgb25lIG9mIFtpZl9leGNsdXNpdmVdIG9yIFtpZl9pbmNsdXNpdmVdLCBhcyBqdWRnZWQgYnkgW2NvbXBhcmVdLiAqKVxuICBsZXQgYmluYXJ5X3NlYXJjaF9vbmVfc2lkZWRfYm91bmQgdCBtYXliZV9ib3VuZCB+Y29tcGFyZSB+aWZfZXhjbHVzaXZlIH5pZl9pbmNsdXNpdmUgPVxuICAgIGxldCBmaW5kX2JvdW5kIHQgaG93IGJvdW5kIH5jb21wYXJlIDogXyBNYXliZV9ib3VuZC50IG9wdGlvbiA9XG4gICAgICBtYXRjaCBiaW5hcnlfc2VhcmNoIHQgaG93IGJvdW5kIH5jb21wYXJlIHdpdGhcbiAgICAgIHwgU29tZSAoYm91bmQsIF8pIC0+IFNvbWUgKEluY2wgYm91bmQpXG4gICAgICB8IE5vbmUgLT4gTm9uZVxuICAgIGluXG4gICAgbWF0Y2ggKG1heWJlX2JvdW5kIDogXyBNYXliZV9ib3VuZC50KSB3aXRoXG4gICAgfCBFeGNsIGJvdW5kIC0+IGZpbmRfYm91bmQgdCBpZl9leGNsdXNpdmUgYm91bmQgfmNvbXBhcmVcbiAgICB8IEluY2wgYm91bmQgLT4gZmluZF9ib3VuZCB0IGlmX2luY2x1c2l2ZSBib3VuZCB+Y29tcGFyZVxuICAgIHwgVW5ib3VuZGVkIC0+IFNvbWUgVW5ib3VuZGVkXG4gIDs7XG5cbiAgKCogW2JpbmFyeV9zZWFyY2hfdHdvX3NpZGVkX2JvdW5kc10gZmluZHMgdGhlIChub3QgbmVjZXNzYXJpbHkgZGlzdGluY3QpIGtleXMgaW4gW3RdXG4gICAgIHdoaWNoIG1vc3QgY2xvc2VseSBhcHByb2FjaCAoYnV0IGRvIG5vdCBjcm9zcykgW2xvd2VyX2JvdW5kXSBhbmQgW3VwcGVyX2JvdW5kXSwgYXNcbiAgICAganVkZ2VkIGJ5IFtjb21wYXJlXS4gSXQgcmV0dXJucyBbTm9uZV0gaWYgbm8ga2V5cyBpbiBbdF0gYXJlIHdpdGhpbiB0aGF0IHJhbmdlLiAqKVxuICBsZXQgYmluYXJ5X3NlYXJjaF90d29fc2lkZWRfYm91bmRzIHQgfmNvbXBhcmUgfmxvd2VyX2JvdW5kIH51cHBlcl9ib3VuZCA9XG4gICAgbGV0IGZpbmRfbG93ZXJfYm91bmQgdCBtYXliZV9ib3VuZCB+Y29tcGFyZSA9XG4gICAgICBiaW5hcnlfc2VhcmNoX29uZV9zaWRlZF9ib3VuZFxuICAgICAgICB0XG4gICAgICAgIG1heWJlX2JvdW5kXG4gICAgICAgIH5jb21wYXJlXG4gICAgICAgIH5pZl9leGNsdXNpdmU6YEZpcnN0X3N0cmljdGx5X2dyZWF0ZXJfdGhhblxuICAgICAgICB+aWZfaW5jbHVzaXZlOmBGaXJzdF9ncmVhdGVyX3RoYW5fb3JfZXF1YWxfdG9cbiAgICBpblxuICAgIGxldCBmaW5kX3VwcGVyX2JvdW5kIHQgbWF5YmVfYm91bmQgfmNvbXBhcmUgPVxuICAgICAgYmluYXJ5X3NlYXJjaF9vbmVfc2lkZWRfYm91bmRcbiAgICAgICAgdFxuICAgICAgICBtYXliZV9ib3VuZFxuICAgICAgICB+Y29tcGFyZVxuICAgICAgICB+aWZfZXhjbHVzaXZlOmBMYXN0X3N0cmljdGx5X2xlc3NfdGhhblxuICAgICAgICB+aWZfaW5jbHVzaXZlOmBMYXN0X2xlc3NfdGhhbl9vcl9lcXVhbF90b1xuICAgIGluXG4gICAgbWF0Y2ggZmluZF9sb3dlcl9ib3VuZCB0IGxvd2VyX2JvdW5kIH5jb21wYXJlIHdpdGhcbiAgICB8IE5vbmUgLT4gTm9uZVxuICAgIHwgU29tZSBsb3dlcl9ib3VuZCAtPlxuICAgICAgKG1hdGNoIGZpbmRfdXBwZXJfYm91bmQgdCB1cHBlcl9ib3VuZCB+Y29tcGFyZSB3aXRoXG4gICAgICAgfCBOb25lIC0+IE5vbmVcbiAgICAgICB8IFNvbWUgdXBwZXJfYm91bmQgLT4gU29tZSAobG93ZXJfYm91bmQsIHVwcGVyX2JvdW5kKSlcbiAgOztcblxuICB0eXBlICgnaywgJ3YpIGFjYyA9XG4gICAgeyBtdXRhYmxlIGJhZF9rZXkgOiAnayBvcHRpb25cbiAgICA7IG11dGFibGUgbWFwX2xlbmd0aCA6ICgnaywgJ3YpIHQgKiBpbnRcbiAgICB9XG5cbiAgbGV0IG9mX2l0ZXJpIH5pdGVyaSB+Y29tcGFyZV9rZXkgPVxuICAgIGxldCBhY2MgPSB7IGJhZF9rZXkgPSBOb25lOyBtYXBfbGVuZ3RoID0gZW1wdHksIDAgfSBpblxuICAgIGl0ZXJpIH5mOihmdW4gfmtleSB+ZGF0YSAtPlxuICAgICAgbGV0IG1hcCwgbGVuZ3RoID0gYWNjLm1hcF9sZW5ndGggaW5cbiAgICAgIGxldCAoKF8sIGxlbmd0aCcpIGFzIHBhaXIpID0gc2V0IH5sZW5ndGggfmtleSB+ZGF0YSBtYXAgfmNvbXBhcmVfa2V5IGluXG4gICAgICBpZiBsZW5ndGggPSBsZW5ndGgnICYmIE9wdGlvbi5pc19ub25lIGFjYy5iYWRfa2V5XG4gICAgICB0aGVuIGFjYy5iYWRfa2V5IDwtIFNvbWUga2V5XG4gICAgICBlbHNlIGFjYy5tYXBfbGVuZ3RoIDwtIHBhaXIpO1xuICAgIG1hdGNoIGFjYy5iYWRfa2V5IHdpdGhcbiAgICB8IE5vbmUgLT4gYE9rIGFjYy5tYXBfbGVuZ3RoXG4gICAgfCBTb21lIGtleSAtPiBgRHVwbGljYXRlX2tleSBrZXlcbiAgOztcblxuICBsZXQgb2ZfaXRlcmlfZXhuIH5pdGVyaSB+KGNvbXBhcmF0b3IgOiBfIENvbXBhcmF0b3IudCkgPVxuICAgIG1hdGNoIG9mX2l0ZXJpIH5pdGVyaSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5jb21wYXJlIHdpdGhcbiAgICB8IGBPayB2IC0+IHZcbiAgICB8IGBEdXBsaWNhdGVfa2V5IGtleSAtPlxuICAgICAgRXJyb3IuY3JlYXRlIFwiTWFwLm9mX2l0ZXJpX2V4bjogZHVwbGljYXRlIGtleVwiIGtleSBjb21wYXJhdG9yLnNleHBfb2ZfdFxuICAgICAgfD4gRXJyb3IucmFpc2VcbiAgOztcblxuICBsZXQgdF9vZl9zZXhwX2RpcmVjdCBrZXlfb2Zfc2V4cCB2YWx1ZV9vZl9zZXhwIHNleHAgfihjb21wYXJhdG9yIDogXyBDb21wYXJhdG9yLnQpID1cbiAgICBsZXQgYWxpc3QgPSBsaXN0X29mX3NleHAgKHBhaXJfb2Zfc2V4cCBrZXlfb2Zfc2V4cCB2YWx1ZV9vZl9zZXhwKSBzZXhwIGluXG4gICAgbGV0IGNvbXBhcmVfa2V5ID0gY29tcGFyYXRvci5jb21wYXJlIGluXG4gICAgbWF0Y2ggb2ZfYWxpc3QgYWxpc3QgfmNvbXBhcmVfa2V5IHdpdGhcbiAgICB8IGBPayB2IC0+IHZcbiAgICB8IGBEdXBsaWNhdGVfa2V5IGsgLT5cbiAgICAgICgqIGZpbmQgdGhlIHNleHAgb2YgYSBkdXBsaWNhdGUga2V5LCBzbyB0aGUgZXJyb3IgaXMgbmFycm93ZWQgdG8gYSBrZXkgYW5kIG5vdFxuICAgICAgICAgdGhlIHdob2xlIG1hcCAqKVxuICAgICAgbGV0IGFsaXN0X3NleHBzID0gbGlzdF9vZl9zZXhwIChwYWlyX29mX3NleHAgRm4uaWQgRm4uaWQpIHNleHAgaW5cbiAgICAgIGxldCBmb3VuZF9maXJzdF9rID0gcmVmIGZhbHNlIGluXG4gICAgICBMaXN0Lml0ZXIyX29rIGFsaXN0IGFsaXN0X3NleHBzIH5mOihmdW4gKGsyLCBfKSAoazJfc2V4cCwgXykgLT5cbiAgICAgICAgaWYgY29tcGFyZV9rZXkgayBrMiA9IDBcbiAgICAgICAgdGhlblxuICAgICAgICAgIGlmICFmb3VuZF9maXJzdF9rXG4gICAgICAgICAgdGhlbiBvZl9zZXhwX2Vycm9yIFwiTWFwLnRfb2Zfc2V4cF9kaXJlY3Q6IGR1cGxpY2F0ZSBrZXlcIiBrMl9zZXhwXG4gICAgICAgICAgZWxzZSBmb3VuZF9maXJzdF9rIDo9IHRydWUpO1xuICAgICAgYXNzZXJ0IGZhbHNlXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCBzZXhwX29mX2tleSBzZXhwX29mX3ZhbHVlIHQgPVxuICAgIGxldCBmIH5rZXkgfmRhdGEgYWNjID0gU2V4cC5MaXN0IFsgc2V4cF9vZl9rZXkga2V5OyBzZXhwX29mX3ZhbHVlIGRhdGEgXSA6OiBhY2MgaW5cbiAgICBTZXhwLkxpc3QgKGZvbGRfcmlnaHQgfmYgdCB+aW5pdDpbXSlcbiAgOztcblxuICBsZXQgY29tYmluZV9lcnJvcnMgdCB+Y29tcGFyZV9rZXkgfnNleHBfb2Zfa2V5ID1cbiAgICBsZXQgb2tzLCAoZXJyb3JfdHJlZSwgXykgPSBwYXJ0aXRpb25fbWFwIHQgfmNvbXBhcmVfa2V5IH5mOlJlc3VsdC50b19laXRoZXIgaW5cbiAgICBpZiBpc19lbXB0eSBlcnJvcl90cmVlXG4gICAgdGhlbiBPayBva3NcbiAgICBlbHNlIE9yX2Vycm9yLmVycm9yX3MgKHNleHBfb2ZfdCBzZXhwX29mX2tleSBFcnJvci5zZXhwX29mX3QgZXJyb3JfdHJlZSlcbiAgOztcblxuICBsZXQgbWFwX2tleXNcbiAgICAgICAgdDFcbiAgICAgICAgfmZcbiAgICAgICAgfmNvbXBhcmF0b3I6KHsgY29tcGFyZSA9IGNvbXBhcmVfa2V5OyBzZXhwX29mX3QgPSBzZXhwX29mX2tleSB9IDogXyBDb21wYXJhdG9yLnQpXG4gICAgPVxuICAgIHdpdGhfcmV0dXJuIChmdW4geyByZXR1cm4gfSAtPlxuICAgICAgYE9rXG4gICAgICAgIChmb2xkIHQxIH5pbml0OihlbXB0eSwgMCkgfmY6KGZ1biB+a2V5IH5kYXRhICh0MiwgbGVuZ3RoKSAtPlxuICAgICAgICAgICBsZXQga2V5ID0gZiBrZXkgaW5cbiAgICAgICAgICAgdHJ5IGFkZF9leG5faW50ZXJuYWwgdDIgfmxlbmd0aCB+a2V5IH5kYXRhIH5jb21wYXJlX2tleSB+c2V4cF9vZl9rZXkgd2l0aFxuICAgICAgICAgICB8IER1cGxpY2F0ZSAtPiByZXR1cm4gKGBEdXBsaWNhdGVfa2V5IGtleSkpKSlcbiAgOztcblxuICBsZXQgbWFwX2tleXNfZXhuIHQgfmYgfmNvbXBhcmF0b3IgPVxuICAgIG1hdGNoIG1hcF9rZXlzIHQgfmYgfmNvbXBhcmF0b3Igd2l0aFxuICAgIHwgYE9rIHJlc3VsdCAtPiByZXN1bHRcbiAgICB8IGBEdXBsaWNhdGVfa2V5IGtleSAtPlxuICAgICAgbGV0IHNleHBfb2Zfa2V5ID0gY29tcGFyYXRvci5Db21wYXJhdG9yLnNleHBfb2ZfdCBpblxuICAgICAgRXJyb3IucmFpc2Vfc1xuICAgICAgICAoU2V4cC5tZXNzYWdlIFwiTWFwLm1hcF9rZXlzX2V4bjogZHVwbGljYXRlIGtleVwiIFsgXCJrZXlcIiwga2V5IHw+IHNleHBfb2Zfa2V5IF0pXG4gIDs7XG5lbmRcblxudHlwZSAoJ2ssICd2LCAnY29tcGFyYXRvcikgdCA9XG4gIHsgKCogW2NvbXBhcmF0b3JdIGlzIHRoZSBmaXJzdCBmaWVsZCBzbyB0aGF0IHBvbHltb3JwaGljIGVxdWFsaXR5IGZhaWxzIG9uIGEgbWFwIGR1ZVxuICAgICAgIHRvIHRoZSBmdW5jdGlvbmFsIHZhbHVlIGluIHRoZSBjb21wYXJhdG9yLlxuICAgICAgIE5vdGUgdGhhdCB0aGlzIGRvZXMgbm90IGFmZmVjdCBwb2x5bW9ycGhpYyBbY29tcGFyZV06IHRoYXQgc3RpbGwgcHJvZHVjZXNcbiAgICAgICBub25zZW5zZS4gKilcbiAgICBjb21wYXJhdG9yIDogKCdrLCAnY29tcGFyYXRvcikgQ29tcGFyYXRvci50XG4gIDsgdHJlZSA6ICgnaywgJ3YpIFRyZWUwLnRcbiAgOyBsZW5ndGggOiBpbnRcbiAgfVxuXG50eXBlICgnaywgJ3YsICdjb21wYXJhdG9yKSB0cmVlID0gKCdrLCAndikgVHJlZTAudFxuXG5sZXQgY29tcGFyZV9rZXkgdCA9IHQuY29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcblxuXG5sZXQgbGlrZSB7IHRyZWUgPSBfOyBsZW5ndGggPSBfOyBjb21wYXJhdG9yIH0gKHRyZWUsIGxlbmd0aCkgPVxuICB7IHRyZWU7IGxlbmd0aDsgY29tcGFyYXRvciB9XG47O1xuXG5sZXQgbGlrZTIgeCAoeSwgeikgPSBsaWtlIHggeSwgbGlrZSB4IHpcblxubGV0IGxpa2VfbWF5YmVfbm9fb3AgKHsgdHJlZSA9IG9sZF90cmVlOyBsZW5ndGggPSBfOyBjb21wYXJhdG9yIH0gYXMgb2xkX3QpICh0cmVlLCBsZW5ndGgpXG4gID1cbiAgaWYgcGh5c19lcXVhbCBvbGRfdHJlZSB0cmVlIHRoZW4gb2xkX3QgZWxzZSB7IHRyZWU7IGxlbmd0aDsgY29tcGFyYXRvciB9XG47O1xuXG5sZXQgd2l0aF9zYW1lX2xlbmd0aCB7IHRyZWUgPSBfOyBjb21wYXJhdG9yOyBsZW5ndGggfSB0cmVlID0geyB0cmVlOyBjb21wYXJhdG9yOyBsZW5ndGggfVxubGV0IG9mX3RyZWUgfmNvbXBhcmF0b3IgdHJlZSA9IHsgdHJlZTsgY29tcGFyYXRvcjsgbGVuZ3RoID0gVHJlZTAubGVuZ3RoIHRyZWUgfVxuXG4oKiBFeHBvc2luZyB0aGlzIGZ1bmN0aW9uIHdvdWxkIG1ha2UgaXQgdmVyeSBlYXN5IGZvciB0aGUgaW52YXJpYW50c1xuICAgb2YgdGhpcyBtb2R1bGUgdG8gYmUgYnJva2VuLiAqKVxubGV0IG9mX3RyZWVfdW5zYWZlIH5jb21wYXJhdG9yIH5sZW5ndGggdHJlZSA9IHsgdHJlZTsgY29tcGFyYXRvcjsgbGVuZ3RoIH1cblxubW9kdWxlIEFjY2Vzc29ycyA9IHN0cnVjdFxuICBsZXQgY29tcGFyYXRvciB0ID0gdC5jb21wYXJhdG9yXG4gIGxldCB0b190cmVlIHQgPSB0LnRyZWVcblxuICBsZXQgaW52YXJpYW50cyB0ID1cbiAgICBUcmVlMC5pbnZhcmlhbnRzIHQudHJlZSB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpICYmIFRyZWUwLmxlbmd0aCB0LnRyZWUgPSB0Lmxlbmd0aFxuICA7O1xuXG4gIGxldCBpc19lbXB0eSB0ID0gVHJlZTAuaXNfZW1wdHkgdC50cmVlXG4gIGxldCBsZW5ndGggdCA9IHQubGVuZ3RoXG5cbiAgbGV0IHNldCB0IH5rZXkgfmRhdGEgPVxuICAgIGxpa2UgdCAoVHJlZTAuc2V0IHQudHJlZSB+bGVuZ3RoOnQubGVuZ3RoIH5rZXkgfmRhdGEgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KSlcbiAgOztcblxuICBsZXQgYWRkX2V4biB0IH5rZXkgfmRhdGEgPVxuICAgIGxpa2VcbiAgICAgIHRcbiAgICAgIChUcmVlMC5hZGRfZXhuXG4gICAgICAgICB0LnRyZWVcbiAgICAgICAgIH5sZW5ndGg6dC5sZW5ndGhcbiAgICAgICAgIH5rZXlcbiAgICAgICAgIH5kYXRhXG4gICAgICAgICB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpXG4gICAgICAgICB+c2V4cF9vZl9rZXk6dC5jb21wYXJhdG9yLnNleHBfb2ZfdClcbiAgOztcblxuICBsZXQgYWRkX2V4bl9pbnRlcm5hbCB0IH5rZXkgfmRhdGEgPVxuICAgIGxpa2VcbiAgICAgIHRcbiAgICAgIChUcmVlMC5hZGRfZXhuX2ludGVybmFsXG4gICAgICAgICB0LnRyZWVcbiAgICAgICAgIH5sZW5ndGg6dC5sZW5ndGhcbiAgICAgICAgIH5rZXlcbiAgICAgICAgIH5kYXRhXG4gICAgICAgICB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpXG4gICAgICAgICB+c2V4cF9vZl9rZXk6dC5jb21wYXJhdG9yLnNleHBfb2ZfdClcbiAgOztcblxuICBsZXQgYWRkIHQgfmtleSB+ZGF0YSA9XG4gICAgbWF0Y2ggYWRkX2V4bl9pbnRlcm5hbCB0IH5rZXkgfmRhdGEgd2l0aFxuICAgIHwgcmVzdWx0IC0+IGBPayByZXN1bHRcbiAgICB8IGV4Y2VwdGlvbiBEdXBsaWNhdGUgLT4gYER1cGxpY2F0ZVxuICA7O1xuXG4gIGxldCBhZGRfbXVsdGkgdCB+a2V5IH5kYXRhID1cbiAgICBsaWtlXG4gICAgICB0XG4gICAgICAoVHJlZTAuYWRkX211bHRpIHQudHJlZSB+bGVuZ3RoOnQubGVuZ3RoIH5rZXkgfmRhdGEgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KSlcbiAgOztcblxuICBsZXQgcmVtb3ZlX211bHRpIHQga2V5ID1cbiAgICBsaWtlIHQgKFRyZWUwLnJlbW92ZV9tdWx0aSB0LnRyZWUgfmxlbmd0aDp0Lmxlbmd0aCBrZXkgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KSlcbiAgOztcblxuICBsZXQgZmluZF9tdWx0aSB0IGtleSA9IFRyZWUwLmZpbmRfbXVsdGkgdC50cmVlIGtleSB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpXG5cbiAgbGV0IGNoYW5nZSB0IGtleSB+ZiA9XG4gICAgbGlrZSB0IChUcmVlMC5jaGFuZ2UgdC50cmVlIGtleSB+ZiB+bGVuZ3RoOnQubGVuZ3RoIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdCkpXG4gIDs7XG5cbiAgbGV0IHVwZGF0ZSB0IGtleSB+ZiA9XG4gICAgbGlrZSB0IChUcmVlMC51cGRhdGUgdC50cmVlIGtleSB+ZiB+bGVuZ3RoOnQubGVuZ3RoIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdCkpXG4gIDs7XG5cbiAgbGV0IGZpbmRfZXhuIHQga2V5ID1cbiAgICBUcmVlMC5maW5kX2V4blxuICAgICAgdC50cmVlXG4gICAgICBrZXlcbiAgICAgIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdClcbiAgICAgIH5zZXhwX29mX2tleTp0LmNvbXBhcmF0b3Iuc2V4cF9vZl90XG4gIDs7XG5cbiAgbGV0IGZpbmQgdCBrZXkgPSBUcmVlMC5maW5kIHQudHJlZSBrZXkgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KVxuXG4gIGxldCByZW1vdmUgdCBrZXkgPVxuICAgIGxpa2VfbWF5YmVfbm9fb3BcbiAgICAgIHRcbiAgICAgIChUcmVlMC5yZW1vdmUgdC50cmVlIGtleSB+bGVuZ3RoOnQubGVuZ3RoIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdCkpXG4gIDs7XG5cbiAgbGV0IG1lbSB0IGtleSA9IFRyZWUwLm1lbSB0LnRyZWUga2V5IH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdClcbiAgbGV0IGl0ZXJfa2V5cyB0IH5mID0gVHJlZTAuaXRlcl9rZXlzIHQudHJlZSB+ZlxuICBsZXQgaXRlciB0IH5mID0gVHJlZTAuaXRlciB0LnRyZWUgfmZcbiAgbGV0IGl0ZXJpIHQgfmYgPSBUcmVlMC5pdGVyaSB0LnRyZWUgfmZcbiAgbGV0IGl0ZXJpX3VudGlsIHQgfmYgPSBUcmVlMC5pdGVyaV91bnRpbCB0LnRyZWUgfmZcbiAgbGV0IGl0ZXIyIHQxIHQyIH5mID0gVHJlZTAuaXRlcjIgdDEudHJlZSB0Mi50cmVlIH5mIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdDEpXG4gIGxldCBtYXAgdCB+ZiA9IHdpdGhfc2FtZV9sZW5ndGggdCAoVHJlZTAubWFwIHQudHJlZSB+ZilcbiAgbGV0IG1hcGkgdCB+ZiA9IHdpdGhfc2FtZV9sZW5ndGggdCAoVHJlZTAubWFwaSB0LnRyZWUgfmYpXG4gIGxldCBmb2xkIHQgfmluaXQgfmYgPSBUcmVlMC5mb2xkIHQudHJlZSB+ZiB+aW5pdFxuICBsZXQgZm9sZF91bnRpbCB0IH5pbml0IH5mID0gVHJlZTAuZm9sZF91bnRpbCB0LnRyZWUgfmYgfmluaXRcbiAgbGV0IGZvbGRfcmlnaHQgdCB+aW5pdCB+ZiA9IFRyZWUwLmZvbGRfcmlnaHQgdC50cmVlIH5mIH5pbml0XG5cbiAgbGV0IGZvbGQyIHQxIHQyIH5pbml0IH5mID1cbiAgICBUcmVlMC5mb2xkMiB0MS50cmVlIHQyLnRyZWUgfmluaXQgfmYgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0MSlcbiAgOztcblxuICBsZXQgZmlsdGVyX2tleXMgdCB+ZiA9IGxpa2UgdCAoVHJlZTAuZmlsdGVyX2tleXMgdC50cmVlIH5mIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdCkpXG4gIGxldCBmaWx0ZXIgdCB+ZiA9IGxpa2UgdCAoVHJlZTAuZmlsdGVyIHQudHJlZSB+ZiB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpKVxuICBsZXQgZmlsdGVyaSB0IH5mID0gbGlrZSB0IChUcmVlMC5maWx0ZXJpIHQudHJlZSB+ZiB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpKVxuICBsZXQgZmlsdGVyX21hcCB0IH5mID0gbGlrZSB0IChUcmVlMC5maWx0ZXJfbWFwIHQudHJlZSB+ZiB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpKVxuICBsZXQgZmlsdGVyX21hcGkgdCB+ZiA9IGxpa2UgdCAoVHJlZTAuZmlsdGVyX21hcGkgdC50cmVlIH5mIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdCkpXG5cbiAgbGV0IHBhcnRpdGlvbl9tYXBpIHQgfmYgPVxuICAgIGxpa2UyIHQgKFRyZWUwLnBhcnRpdGlvbl9tYXBpIHQudHJlZSB+ZiB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpKVxuICA7O1xuXG4gIGxldCBwYXJ0aXRpb25fbWFwIHQgfmYgPVxuICAgIGxpa2UyIHQgKFRyZWUwLnBhcnRpdGlvbl9tYXAgdC50cmVlIH5mIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdCkpXG4gIDs7XG5cbiAgbGV0IHBhcnRpdGlvbmlfdGYgdCB+ZiA9XG4gICAgbGlrZTIgdCAoVHJlZTAucGFydGl0aW9uaV90ZiB0LnRyZWUgfmYgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KSlcbiAgOztcblxuICBsZXQgcGFydGl0aW9uX3RmIHQgfmYgPVxuICAgIGxpa2UyIHQgKFRyZWUwLnBhcnRpdGlvbl90ZiB0LnRyZWUgfmYgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KSlcbiAgOztcblxuICBsZXQgY29tYmluZV9lcnJvcnMgdCA9XG4gICAgT3JfZXJyb3IubWFwXG4gICAgICB+ZjoobGlrZSB0KVxuICAgICAgKFRyZWUwLmNvbWJpbmVfZXJyb3JzXG4gICAgICAgICB0LnRyZWVcbiAgICAgICAgIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdClcbiAgICAgICAgIH5zZXhwX29mX2tleTp0LmNvbXBhcmF0b3Iuc2V4cF9vZl90KVxuICA7O1xuXG4gIGxldCBjb21wYXJlX2RpcmVjdCBjb21wYXJlX2RhdGEgdDEgdDIgPVxuICAgIFRyZWUwLmNvbXBhcmUgKGNvbXBhcmVfa2V5IHQxKSBjb21wYXJlX2RhdGEgdDEudHJlZSB0Mi50cmVlXG4gIDs7XG5cbiAgbGV0IGVxdWFsIGNvbXBhcmVfZGF0YSB0MSB0MiA9IFRyZWUwLmVxdWFsIChjb21wYXJlX2tleSB0MSkgY29tcGFyZV9kYXRhIHQxLnRyZWUgdDIudHJlZVxuICBsZXQga2V5cyB0ID0gVHJlZTAua2V5cyB0LnRyZWVcbiAgbGV0IGRhdGEgdCA9IFRyZWUwLmRhdGEgdC50cmVlXG4gIGxldCB0b19hbGlzdCA/a2V5X29yZGVyIHQgPSBUcmVlMC50b19hbGlzdCA/a2V5X29yZGVyIHQudHJlZVxuXG4gIGxldCBzeW1tZXRyaWNfZGlmZiB0MSB0MiB+ZGF0YV9lcXVhbCA9XG4gICAgVHJlZTAuc3ltbWV0cmljX2RpZmYgdDEudHJlZSB0Mi50cmVlIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdDEpIH5kYXRhX2VxdWFsXG4gIDs7XG5cbiAgbGV0IGZvbGRfc3ltbWV0cmljX2RpZmYgdDEgdDIgfmRhdGFfZXF1YWwgfmluaXQgfmYgPVxuICAgIFRyZWUwLmZvbGRfc3ltbWV0cmljX2RpZmZcbiAgICAgIHQxLnRyZWVcbiAgICAgIHQyLnRyZWVcbiAgICAgIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdDEpXG4gICAgICB+ZGF0YV9lcXVhbFxuICAgICAgfmluaXRcbiAgICAgIH5mXG4gIDs7XG5cbiAgbGV0IG1lcmdlIHQxIHQyIH5mID1cbiAgICBsaWtlIHQxIChUcmVlMC5tZXJnZSB0MS50cmVlIHQyLnRyZWUgfmYgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0MSkpXG4gIDs7XG5cbiAgbGV0IG1lcmdlX3NrZXdlZCB0MSB0MiB+Y29tYmluZSA9XG4gICAgKCogVGhpcyBpcyBvbmx5IGEgbm8tb3AgaW4gdGhlIGNhc2Ugd2hlcmUgYXQgbGVhc3Qgb25lIG9mIHRoZSBtYXBzIGlzIGVtcHR5LiAqKVxuICAgIGxpa2VfbWF5YmVfbm9fb3BcbiAgICAgIChpZiB0Mi5sZW5ndGggPD0gdDEubGVuZ3RoIHRoZW4gdDEgZWxzZSB0MilcbiAgICAgIChUcmVlMC5tZXJnZV9za2V3ZWRcbiAgICAgICAgIHQxLnRyZWVcbiAgICAgICAgIHQyLnRyZWVcbiAgICAgICAgIH5sZW5ndGgxOnQxLmxlbmd0aFxuICAgICAgICAgfmxlbmd0aDI6dDIubGVuZ3RoXG4gICAgICAgICB+Y29tYmluZVxuICAgICAgICAgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0MSkpXG4gIDs7XG5cbiAgbGV0IG1pbl9lbHQgdCA9IFRyZWUwLm1pbl9lbHQgdC50cmVlXG4gIGxldCBtaW5fZWx0X2V4biB0ID0gVHJlZTAubWluX2VsdF9leG4gdC50cmVlXG4gIGxldCBtYXhfZWx0IHQgPSBUcmVlMC5tYXhfZWx0IHQudHJlZVxuICBsZXQgbWF4X2VsdF9leG4gdCA9IFRyZWUwLm1heF9lbHRfZXhuIHQudHJlZVxuICBsZXQgZm9yX2FsbCB0IH5mID0gVHJlZTAuZm9yX2FsbCB0LnRyZWUgfmZcbiAgbGV0IGZvcl9hbGxpIHQgfmYgPSBUcmVlMC5mb3JfYWxsaSB0LnRyZWUgfmZcbiAgbGV0IGV4aXN0cyB0IH5mID0gVHJlZTAuZXhpc3RzIHQudHJlZSB+ZlxuICBsZXQgZXhpc3RzaSB0IH5mID0gVHJlZTAuZXhpc3RzaSB0LnRyZWUgfmZcbiAgbGV0IGNvdW50IHQgfmYgPSBUcmVlMC5jb3VudCB0LnRyZWUgfmZcbiAgbGV0IGNvdW50aSB0IH5mID0gVHJlZTAuY291bnRpIHQudHJlZSB+ZlxuXG4gIGxldCBzcGxpdCB0IGsgPVxuICAgIGxldCBsLCBtYXliZSwgciA9IFRyZWUwLnNwbGl0IHQudHJlZSBrIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdCkgaW5cbiAgICBsZXQgY29tcGFyYXRvciA9IGNvbXBhcmF0b3IgdCBpblxuICAgICgqIFRyeSB0byB0cmF2ZXJzZSB0aGUgbGVhc3QgYW1vdW50IHBvc3NpYmxlIHRvIGNhbGN1bGF0ZSB0aGUgbGVuZ3RoLFxuICAgICAgIHVzaW5nIGhlaWdodCBhcyBhIGhldXJpc3RpYy4gKilcbiAgICBsZXQgYm90aF9sZW4gPSBpZiBPcHRpb24uaXNfc29tZSBtYXliZSB0aGVuIHQubGVuZ3RoIC0gMSBlbHNlIHQubGVuZ3RoIGluXG4gICAgaWYgVHJlZTAuaGVpZ2h0IGwgPCBUcmVlMC5oZWlnaHQgclxuICAgIHRoZW4gKFxuICAgICAgbGV0IGwgPSBvZl90cmVlIGwgfmNvbXBhcmF0b3IgaW5cbiAgICAgIGwsIG1heWJlLCBvZl90cmVlX3Vuc2FmZSByIH5jb21wYXJhdG9yIH5sZW5ndGg6KGJvdGhfbGVuIC0gbGVuZ3RoIGwpKVxuICAgIGVsc2UgKFxuICAgICAgbGV0IHIgPSBvZl90cmVlIHIgfmNvbXBhcmF0b3IgaW5cbiAgICAgIG9mX3RyZWVfdW5zYWZlIGwgfmNvbXBhcmF0b3Igfmxlbmd0aDooYm90aF9sZW4gLSBsZW5ndGggciksIG1heWJlLCByKVxuICA7O1xuXG4gIGxldCBzdWJyYW5nZSB0IH5sb3dlcl9ib3VuZCB+dXBwZXJfYm91bmQgPVxuICAgIGxldCBsZWZ0LCBtaWQsIHJpZ2h0ID1cbiAgICAgIFRyZWUwLnNwbGl0X3JhbmdlIHQudHJlZSB+bG93ZXJfYm91bmQgfnVwcGVyX2JvdW5kIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdClcbiAgICBpblxuICAgICgqIFRyeSB0byB0cmF2ZXJzZSB0aGUgbGVhc3QgYW1vdW50IHBvc3NpYmxlIHRvIGNhbGN1bGF0ZSB0aGUgbGVuZ3RoLFxuICAgICAgIHVzaW5nIGhlaWdodCBhcyBhIGhldXJpc3RpYy4gKilcbiAgICBsZXQgb3V0ZXJfam9pbmVkX2hlaWdodCA9XG4gICAgICBsZXQgaF9sID0gVHJlZTAuaGVpZ2h0IGxlZnRcbiAgICAgIGFuZCBoX3IgPSBUcmVlMC5oZWlnaHQgcmlnaHQgaW5cbiAgICAgIGlmIGhfbCA9IGhfciB0aGVuIGhfbCArIDEgZWxzZSBtYXggaF9sIGhfclxuICAgIGluXG4gICAgaWYgb3V0ZXJfam9pbmVkX2hlaWdodCA8IFRyZWUwLmhlaWdodCBtaWRcbiAgICB0aGVuIChcbiAgICAgIGxldCBtaWRfbGVuZ3RoID0gdC5sZW5ndGggLSAoVHJlZTAubGVuZ3RoIGxlZnQgKyBUcmVlMC5sZW5ndGggcmlnaHQpIGluXG4gICAgICBvZl90cmVlX3Vuc2FmZSBtaWQgfmNvbXBhcmF0b3I6KGNvbXBhcmF0b3IgdCkgfmxlbmd0aDptaWRfbGVuZ3RoKVxuICAgIGVsc2Ugb2ZfdHJlZSBtaWQgfmNvbXBhcmF0b3I6KGNvbXBhcmF0b3IgdClcbiAgOztcblxuICBsZXQgYXBwZW5kIH5sb3dlcl9wYXJ0IH51cHBlcl9wYXJ0ID1cbiAgICBtYXRjaFxuICAgICAgVHJlZTAuYXBwZW5kXG4gICAgICAgIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgbG93ZXJfcGFydClcbiAgICAgICAgfmxvd2VyX3BhcnQ6bG93ZXJfcGFydC50cmVlXG4gICAgICAgIH51cHBlcl9wYXJ0OnVwcGVyX3BhcnQudHJlZVxuICAgIHdpdGhcbiAgICB8IGBPayB0cmVlIC0+XG4gICAgICBgT2tcbiAgICAgICAgKG9mX3RyZWVfdW5zYWZlXG4gICAgICAgICAgIHRyZWVcbiAgICAgICAgICAgfmNvbXBhcmF0b3I6KGNvbXBhcmF0b3IgbG93ZXJfcGFydClcbiAgICAgICAgICAgfmxlbmd0aDoobG93ZXJfcGFydC5sZW5ndGggKyB1cHBlcl9wYXJ0Lmxlbmd0aCkpXG4gICAgfCBgT3ZlcmxhcHBpbmdfa2V5X3JhbmdlcyAtPiBgT3ZlcmxhcHBpbmdfa2V5X3Jhbmdlc1xuICA7O1xuXG4gIGxldCBmb2xkX3JhbmdlX2luY2x1c2l2ZSB0IH5taW4gfm1heCB+aW5pdCB+ZiA9XG4gICAgVHJlZTAuZm9sZF9yYW5nZV9pbmNsdXNpdmUgdC50cmVlIH5taW4gfm1heCB+aW5pdCB+ZiB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpXG4gIDs7XG5cbiAgbGV0IHJhbmdlX3RvX2FsaXN0IHQgfm1pbiB+bWF4ID1cbiAgICBUcmVlMC5yYW5nZV90b19hbGlzdCB0LnRyZWUgfm1pbiB+bWF4IH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdClcbiAgOztcblxuICBsZXQgY2xvc2VzdF9rZXkgdCBkaXIga2V5ID1cbiAgICBUcmVlMC5jbG9zZXN0X2tleSB0LnRyZWUgZGlyIGtleSB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpXG4gIDs7XG5cbiAgbGV0IG50aCB0IG4gPSBUcmVlMC5udGggdC50cmVlIG5cbiAgbGV0IG50aF9leG4gdCBuID0gT3B0aW9uLnZhbHVlX2V4biAobnRoIHQgbilcbiAgbGV0IHJhbmsgdCBrZXkgPSBUcmVlMC5yYW5rIHQudHJlZSBrZXkgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KVxuICBsZXQgc2V4cF9vZl90IHNleHBfb2ZfayBzZXhwX29mX3YgXyB0ID0gVHJlZTAuc2V4cF9vZl90IHNleHBfb2ZfayBzZXhwX29mX3YgdC50cmVlXG5cbiAgbGV0IHRvX3NlcXVlbmNlID9vcmRlciA/a2V5c19ncmVhdGVyX29yX2VxdWFsX3RvID9rZXlzX2xlc3Nfb3JfZXF1YWxfdG8gdCA9XG4gICAgVHJlZTAudG9fc2VxdWVuY2VcbiAgICAgIHQuY29tcGFyYXRvclxuICAgICAgP29yZGVyXG4gICAgICA/a2V5c19ncmVhdGVyX29yX2VxdWFsX3RvXG4gICAgICA/a2V5c19sZXNzX29yX2VxdWFsX3RvXG4gICAgICB0LnRyZWVcbiAgOztcblxuICBsZXQgYmluYXJ5X3NlYXJjaCB0IH5jb21wYXJlIGhvdyB2ID0gVHJlZTAuYmluYXJ5X3NlYXJjaCB0LnRyZWUgfmNvbXBhcmUgaG93IHZcblxuICBsZXQgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQgdCB+c2VnbWVudF9vZiBob3cgPVxuICAgIFRyZWUwLmJpbmFyeV9zZWFyY2hfc2VnbWVudGVkIHQudHJlZSB+c2VnbWVudF9vZiBob3dcbiAgOztcblxuICBsZXQgaGFzaF9mb2xkX2RpcmVjdCBoYXNoX2ZvbGRfa2V5IGhhc2hfZm9sZF9kYXRhIHN0YXRlIHQgPVxuICAgIFRyZWUwLmhhc2hfZm9sZF90X2lnbm9yaW5nX3N0cnVjdHVyZSBoYXNoX2ZvbGRfa2V5IGhhc2hfZm9sZF9kYXRhIHN0YXRlIHQudHJlZVxuICA7O1xuXG4gIGxldCBiaW5hcnlfc2VhcmNoX3N1YnJhbmdlIHQgfmNvbXBhcmUgfmxvd2VyX2JvdW5kIH51cHBlcl9ib3VuZCA9XG4gICAgbWF0Y2hcbiAgICAgIFRyZWUwLmJpbmFyeV9zZWFyY2hfdHdvX3NpZGVkX2JvdW5kcyB0LnRyZWUgfmNvbXBhcmUgfmxvd2VyX2JvdW5kIH51cHBlcl9ib3VuZFxuICAgIHdpdGhcbiAgICB8IFNvbWUgKGxvd2VyX2JvdW5kLCB1cHBlcl9ib3VuZCkgLT4gc3VicmFuZ2UgdCB+bG93ZXJfYm91bmQgfnVwcGVyX2JvdW5kXG4gICAgfCBOb25lIC0+IGxpa2VfbWF5YmVfbm9fb3AgdCAoRW1wdHksIDApXG4gIDs7XG5lbmRcblxuKCogWzBdIGlzIHVzZWQgYXMgdGhlIFtsZW5ndGhdIGFyZ3VtZW50IGV2ZXJ5d2hlcmUgaW4gdGhpcyBtb2R1bGUsIHNpbmNlIHRyZWVzIGRvIG5vdFxuICAgaGF2ZSB0aGVpciBsZW5ndGhzIHN0b3JlZCBhdCB0aGUgcm9vdCwgdW5saWtlIG1hcHMuIFRoZSB2YWx1ZXMgYXJlIGRpc2NhcmRlZCBhbHdheXMuICopXG5tb2R1bGUgVHJlZSA9IHN0cnVjdFxuICB0eXBlICgnaywgJ3YsICdjb21wYXJhdG9yKSB0ID0gKCdrLCAndiwgJ2NvbXBhcmF0b3IpIHRyZWVcblxuICBsZXQgZW1wdHlfd2l0aG91dF92YWx1ZV9yZXN0cmljdGlvbiA9IFRyZWUwLmVtcHR5XG4gIGxldCBlbXB0eSB+Y29tcGFyYXRvcjpfID0gZW1wdHlfd2l0aG91dF92YWx1ZV9yZXN0cmljdGlvblxuICBsZXQgb2ZfdHJlZSB+Y29tcGFyYXRvcjpfIHRyZWUgPSB0cmVlXG4gIGxldCBzaW5nbGV0b24gfmNvbXBhcmF0b3I6XyBrIHYgPSBUcmVlMC5zaW5nbGV0b24gayB2XG5cbiAgbGV0IG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgfmNvbXBhcmF0b3IgYXJyYXkgPVxuICAgIGZzdCAoVHJlZTAub2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCBhcnJheSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IG9mX3NvcnRlZF9hcnJheSB+Y29tcGFyYXRvciBhcnJheSA9XG4gICAgVHJlZTAub2Zfc29ydGVkX2FycmF5IGFycmF5IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICAgIHw+IE9yX2Vycm9yLm1hcCB+Zjpmc3RcbiAgOztcblxuICBsZXQgb2ZfYWxpc3QgfmNvbXBhcmF0b3IgYWxpc3QgPVxuICAgIG1hdGNoIFRyZWUwLm9mX2FsaXN0IGFsaXN0IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSB3aXRoXG4gICAgfCBgRHVwbGljYXRlX2tleSBfIGFzIGQgLT4gZFxuICAgIHwgYE9rICh0cmVlLCBfc2l6ZSkgLT4gYE9rIHRyZWVcbiAgOztcblxuICBsZXQgb2ZfYWxpc3Rfb3JfZXJyb3IgfmNvbXBhcmF0b3IgYWxpc3QgPVxuICAgIFRyZWUwLm9mX2FsaXN0X29yX2Vycm9yIGFsaXN0IH5jb21wYXJhdG9yIHw+IE9yX2Vycm9yLm1hcCB+Zjpmc3RcbiAgOztcblxuICBsZXQgb2ZfYWxpc3RfZXhuIH5jb21wYXJhdG9yIGFsaXN0ID0gZnN0IChUcmVlMC5vZl9hbGlzdF9leG4gYWxpc3QgfmNvbXBhcmF0b3IpXG5cbiAgbGV0IG9mX2FsaXN0X211bHRpIH5jb21wYXJhdG9yIGFsaXN0ID1cbiAgICBmc3QgKFRyZWUwLm9mX2FsaXN0X211bHRpIGFsaXN0IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgb2ZfYWxpc3RfZm9sZCB+Y29tcGFyYXRvciBhbGlzdCB+aW5pdCB+ZiA9XG4gICAgZnN0IChUcmVlMC5vZl9hbGlzdF9mb2xkIGFsaXN0IH5pbml0IH5mIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgb2ZfYWxpc3RfcmVkdWNlIH5jb21wYXJhdG9yIGFsaXN0IH5mID1cbiAgICBmc3QgKFRyZWUwLm9mX2FsaXN0X3JlZHVjZSBhbGlzdCB+ZiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IG9mX2l0ZXJpIH5jb21wYXJhdG9yIH5pdGVyaSA9XG4gICAgbWF0Y2ggVHJlZTAub2ZfaXRlcmkgfml0ZXJpIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSB3aXRoXG4gICAgfCBgT2sgKHRyZWUsIF9zaXplKSAtPiBgT2sgdHJlZVxuICAgIHwgYER1cGxpY2F0ZV9rZXkgXyBhcyBkIC0+IGRcbiAgOztcblxuICBsZXQgb2ZfaXRlcmlfZXhuIH5jb21wYXJhdG9yIH5pdGVyaSA9IGZzdCAoVHJlZTAub2ZfaXRlcmlfZXhuIH5pdGVyaSB+Y29tcGFyYXRvcilcblxuICBsZXQgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmNvbXBhcmF0b3I6X3JlcXVpcmVkX2J5X2ludGYgfmxlbiB+ZiA9XG4gICAgVHJlZTAub2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmxlbiB+ZlxuICA7O1xuXG4gIGxldCBvZl9pbmNyZWFzaW5nX3NlcXVlbmNlIH5jb21wYXJhdG9yIHNlcSA9XG4gICAgT3JfZXJyb3IubWFwXG4gICAgICB+Zjpmc3RcbiAgICAgIChUcmVlMC5vZl9pbmNyZWFzaW5nX3NlcXVlbmNlIHNlcSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IG9mX3NlcXVlbmNlIH5jb21wYXJhdG9yIHNlcSA9XG4gICAgbWF0Y2ggVHJlZTAub2Zfc2VxdWVuY2Ugc2VxIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSB3aXRoXG4gICAgfCBgRHVwbGljYXRlX2tleSBfIGFzIGQgLT4gZFxuICAgIHwgYE9rICh0cmVlLCBfc2l6ZSkgLT4gYE9rIHRyZWVcbiAgOztcblxuICBsZXQgb2Zfc2VxdWVuY2Vfb3JfZXJyb3IgfmNvbXBhcmF0b3Igc2VxID1cbiAgICBUcmVlMC5vZl9zZXF1ZW5jZV9vcl9lcnJvciBzZXEgfmNvbXBhcmF0b3IgfD4gT3JfZXJyb3IubWFwIH5mOmZzdFxuICA7O1xuXG4gIGxldCBvZl9zZXF1ZW5jZV9leG4gfmNvbXBhcmF0b3Igc2VxID0gZnN0IChUcmVlMC5vZl9zZXF1ZW5jZV9leG4gc2VxIH5jb21wYXJhdG9yKVxuXG4gIGxldCBvZl9zZXF1ZW5jZV9tdWx0aSB+Y29tcGFyYXRvciBzZXEgPVxuICAgIGZzdCAoVHJlZTAub2Zfc2VxdWVuY2VfbXVsdGkgc2VxIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgb2Zfc2VxdWVuY2VfZm9sZCB+Y29tcGFyYXRvciBzZXEgfmluaXQgfmYgPVxuICAgIGZzdCAoVHJlZTAub2Zfc2VxdWVuY2VfZm9sZCBzZXEgfmluaXQgfmYgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBvZl9zZXF1ZW5jZV9yZWR1Y2UgfmNvbXBhcmF0b3Igc2VxIH5mID1cbiAgICBmc3QgKFRyZWUwLm9mX3NlcXVlbmNlX3JlZHVjZSBzZXEgfmYgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCB0b190cmVlIHQgPSB0XG5cbiAgbGV0IGludmFyaWFudHMgfmNvbXBhcmF0b3IgdCA9XG4gICAgVHJlZTAuaW52YXJpYW50cyB0IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICA7O1xuXG4gIGxldCBpc19lbXB0eSB0ID0gVHJlZTAuaXNfZW1wdHkgdFxuICBsZXQgbGVuZ3RoIHQgPSBUcmVlMC5sZW5ndGggdFxuXG4gIGxldCBzZXQgfmNvbXBhcmF0b3IgdCB+a2V5IH5kYXRhID1cbiAgICBmc3QgKFRyZWUwLnNldCB0IH5rZXkgfmRhdGEgfmxlbmd0aDowIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgYWRkX2V4biB+Y29tcGFyYXRvciB0IH5rZXkgfmRhdGEgPVxuICAgIGZzdFxuICAgICAgKFRyZWUwLmFkZF9leG5cbiAgICAgICAgIHRcbiAgICAgICAgIH5rZXlcbiAgICAgICAgIH5kYXRhXG4gICAgICAgICB+bGVuZ3RoOjBcbiAgICAgICAgIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICAgICAgICAgfnNleHBfb2Zfa2V5OmNvbXBhcmF0b3Iuc2V4cF9vZl90KVxuICA7O1xuXG4gIGxldCBhZGQgfmNvbXBhcmF0b3IgdCB+a2V5IH5kYXRhID1cbiAgICB0cnkgYE9rIChhZGRfZXhuIHQgfmNvbXBhcmF0b3IgfmtleSB+ZGF0YSkgd2l0aFxuICAgIHwgXyAtPiBgRHVwbGljYXRlXG4gIDs7XG5cbiAgbGV0IGFkZF9tdWx0aSB+Y29tcGFyYXRvciB0IH5rZXkgfmRhdGEgPVxuICAgIFRyZWUwLmFkZF9tdWx0aSB0IH5rZXkgfmRhdGEgfmxlbmd0aDowIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICAgIHw+IGZzdFxuICA7O1xuXG4gIGxldCByZW1vdmVfbXVsdGkgfmNvbXBhcmF0b3IgdCBrZXkgPVxuICAgIFRyZWUwLnJlbW92ZV9tdWx0aSB0IGtleSB+bGVuZ3RoOjAgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIHw+IGZzdFxuICA7O1xuXG4gIGxldCBmaW5kX211bHRpIH5jb21wYXJhdG9yIHQga2V5ID1cbiAgICBUcmVlMC5maW5kX211bHRpIHQga2V5IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICA7O1xuXG4gIGxldCBjaGFuZ2UgfmNvbXBhcmF0b3IgdCBrZXkgfmYgPVxuICAgIGZzdCAoVHJlZTAuY2hhbmdlIHQga2V5IH5mIH5sZW5ndGg6MCB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IHVwZGF0ZSB+Y29tcGFyYXRvciB0IGtleSB+ZiA9XG4gICAgY2hhbmdlIH5jb21wYXJhdG9yIHQga2V5IH5mOihmdW4gZGF0YSAtPiBTb21lIChmIGRhdGEpKVxuICA7O1xuXG4gIGxldCBmaW5kX2V4biB+Y29tcGFyYXRvciB0IGtleSA9XG4gICAgVHJlZTAuZmluZF9leG5cbiAgICAgIHRcbiAgICAgIGtleVxuICAgICAgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgICB+c2V4cF9vZl9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLnNleHBfb2ZfdFxuICA7O1xuXG4gIGxldCBmaW5kIH5jb21wYXJhdG9yIHQga2V5ID0gVHJlZTAuZmluZCB0IGtleSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcblxuICBsZXQgcmVtb3ZlIH5jb21wYXJhdG9yIHQga2V5ID1cbiAgICBmc3QgKFRyZWUwLnJlbW92ZSB0IGtleSB+bGVuZ3RoOjAgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBtZW0gfmNvbXBhcmF0b3IgdCBrZXkgPSBUcmVlMC5tZW0gdCBrZXkgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gIGxldCBpdGVyX2tleXMgdCB+ZiA9IFRyZWUwLml0ZXJfa2V5cyB0IH5mXG4gIGxldCBpdGVyIHQgfmYgPSBUcmVlMC5pdGVyIHQgfmZcbiAgbGV0IGl0ZXJpIHQgfmYgPSBUcmVlMC5pdGVyaSB0IH5mXG4gIGxldCBpdGVyaV91bnRpbCB0IH5mID0gVHJlZTAuaXRlcmlfdW50aWwgdCB+ZlxuXG4gIGxldCBpdGVyMiB+Y29tcGFyYXRvciB0MSB0MiB+ZiA9XG4gICAgVHJlZTAuaXRlcjIgdDEgdDIgfmYgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gIDs7XG5cbiAgbGV0IG1hcCB0IH5mID0gVHJlZTAubWFwIHQgfmZcbiAgbGV0IG1hcGkgdCB+ZiA9IFRyZWUwLm1hcGkgdCB+ZlxuICBsZXQgZm9sZCB0IH5pbml0IH5mID0gVHJlZTAuZm9sZCB0IH5mIH5pbml0XG4gIGxldCBmb2xkX3VudGlsIHQgfmluaXQgfmYgfmZpbmlzaCA9IFRyZWUwLmZvbGRfdW50aWwgdCB+ZiB+aW5pdCB+ZmluaXNoXG4gIGxldCBmb2xkX3JpZ2h0IHQgfmluaXQgfmYgPSBUcmVlMC5mb2xkX3JpZ2h0IHQgfmYgfmluaXRcblxuICBsZXQgZm9sZDIgfmNvbXBhcmF0b3IgdDEgdDIgfmluaXQgfmYgPVxuICAgIFRyZWUwLmZvbGQyIHQxIHQyIH5pbml0IH5mIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICA7O1xuXG4gIGxldCBmaWx0ZXJfa2V5cyB+Y29tcGFyYXRvciB0IH5mID1cbiAgICBmc3QgKFRyZWUwLmZpbHRlcl9rZXlzIHQgfmYgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBmaWx0ZXIgfmNvbXBhcmF0b3IgdCB+ZiA9XG4gICAgZnN0IChUcmVlMC5maWx0ZXIgdCB+ZiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IGZpbHRlcmkgfmNvbXBhcmF0b3IgdCB+ZiA9XG4gICAgZnN0IChUcmVlMC5maWx0ZXJpIHQgfmYgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBmaWx0ZXJfbWFwIH5jb21wYXJhdG9yIHQgfmYgPVxuICAgIGZzdCAoVHJlZTAuZmlsdGVyX21hcCB0IH5mIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgZmlsdGVyX21hcGkgfmNvbXBhcmF0b3IgdCB+ZiA9XG4gICAgZnN0IChUcmVlMC5maWx0ZXJfbWFwaSB0IH5mIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgcGFydGl0aW9uX21hcGkgfmNvbXBhcmF0b3IgdCB+ZiA9XG4gICAgbGV0IChhLCBfKSwgKGIsIF8pID1cbiAgICAgIFRyZWUwLnBhcnRpdGlvbl9tYXBpIHQgfmYgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgaW5cbiAgICBhLCBiXG4gIDs7XG5cbiAgbGV0IHBhcnRpdGlvbl9tYXAgfmNvbXBhcmF0b3IgdCB+ZiA9XG4gICAgbGV0IChhLCBfKSwgKGIsIF8pID1cbiAgICAgIFRyZWUwLnBhcnRpdGlvbl9tYXAgdCB+ZiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICBpblxuICAgIGEsIGJcbiAgOztcblxuICBsZXQgcGFydGl0aW9uaV90ZiB+Y29tcGFyYXRvciB0IH5mID1cbiAgICBsZXQgKGEsIF8pLCAoYiwgXykgPVxuICAgICAgVHJlZTAucGFydGl0aW9uaV90ZiB0IH5mIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICAgIGluXG4gICAgYSwgYlxuICA7O1xuXG4gIGxldCBwYXJ0aXRpb25fdGYgfmNvbXBhcmF0b3IgdCB+ZiA9XG4gICAgbGV0IChhLCBfKSwgKGIsIF8pID1cbiAgICAgIFRyZWUwLnBhcnRpdGlvbl90ZiB0IH5mIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICAgIGluXG4gICAgYSwgYlxuICA7O1xuXG4gIGxldCBjb21iaW5lX2Vycm9ycyB+Y29tcGFyYXRvciB0ID1cbiAgICBPcl9lcnJvci5tYXBcbiAgICAgIH5mOmZzdFxuICAgICAgKFRyZWUwLmNvbWJpbmVfZXJyb3JzXG4gICAgICAgICB0XG4gICAgICAgICB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICAgICAgIH5zZXhwX29mX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3Iuc2V4cF9vZl90KVxuICA7O1xuXG4gIGxldCBjb21wYXJlX2RpcmVjdCB+Y29tcGFyYXRvciBjb21wYXJlX2RhdGEgdDEgdDIgPVxuICAgIFRyZWUwLmNvbXBhcmUgY29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgY29tcGFyZV9kYXRhIHQxIHQyXG4gIDs7XG5cbiAgbGV0IGVxdWFsIH5jb21wYXJhdG9yIGNvbXBhcmVfZGF0YSB0MSB0MiA9XG4gICAgVHJlZTAuZXF1YWwgY29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgY29tcGFyZV9kYXRhIHQxIHQyXG4gIDs7XG5cbiAgbGV0IGtleXMgdCA9IFRyZWUwLmtleXMgdFxuICBsZXQgZGF0YSB0ID0gVHJlZTAuZGF0YSB0XG4gIGxldCB0b19hbGlzdCA/a2V5X29yZGVyIHQgPSBUcmVlMC50b19hbGlzdCA/a2V5X29yZGVyIHRcblxuICBsZXQgc3ltbWV0cmljX2RpZmYgfmNvbXBhcmF0b3IgdDEgdDIgfmRhdGFfZXF1YWwgPVxuICAgIFRyZWUwLnN5bW1ldHJpY19kaWZmIHQxIHQyIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSB+ZGF0YV9lcXVhbFxuICA7O1xuXG4gIGxldCBmb2xkX3N5bW1ldHJpY19kaWZmIH5jb21wYXJhdG9yIHQxIHQyIH5kYXRhX2VxdWFsIH5pbml0IH5mID1cbiAgICBUcmVlMC5mb2xkX3N5bW1ldHJpY19kaWZmXG4gICAgICB0MVxuICAgICAgdDJcbiAgICAgIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICAgICAgfmRhdGFfZXF1YWxcbiAgICAgIH5pbml0XG4gICAgICB+ZlxuICA7O1xuXG4gIGxldCBtZXJnZSB+Y29tcGFyYXRvciB0MSB0MiB+ZiA9XG4gICAgZnN0IChUcmVlMC5tZXJnZSB0MSB0MiB+ZiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IG1lcmdlX3NrZXdlZCB+Y29tcGFyYXRvciB0MSB0MiB+Y29tYmluZSA9XG4gICAgKCogTGVuZ3RoIGNvbXB1dGF0aW9uIG1ha2VzIHRoaXMgc2lnbmlmaWNhbnRseSBzbG93ZXIgdGhhbiBbbWVyZ2Vfc2tld2VkXSBvbiBhIG1hcFxuICAgICAgIHdpdGggYSBbbGVuZ3RoXSBmaWVsZCwgYnV0IGRvZXMgcHJlc2VydmUgYW1vdW50IG9mIGFsbG9jYXRpb24uICopXG4gICAgZnN0XG4gICAgICAoVHJlZTAubWVyZ2Vfc2tld2VkXG4gICAgICAgICB0MVxuICAgICAgICAgdDJcbiAgICAgICAgIH5sZW5ndGgxOihsZW5ndGggdDEpXG4gICAgICAgICB+bGVuZ3RoMjoobGVuZ3RoIHQyKVxuICAgICAgICAgfmNvbWJpbmVcbiAgICAgICAgIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgbWluX2VsdCB0ID0gVHJlZTAubWluX2VsdCB0XG4gIGxldCBtaW5fZWx0X2V4biB0ID0gVHJlZTAubWluX2VsdF9leG4gdFxuICBsZXQgbWF4X2VsdCB0ID0gVHJlZTAubWF4X2VsdCB0XG4gIGxldCBtYXhfZWx0X2V4biB0ID0gVHJlZTAubWF4X2VsdF9leG4gdFxuICBsZXQgZm9yX2FsbCB0IH5mID0gVHJlZTAuZm9yX2FsbCB0IH5mXG4gIGxldCBmb3JfYWxsaSB0IH5mID0gVHJlZTAuZm9yX2FsbGkgdCB+ZlxuICBsZXQgZXhpc3RzIHQgfmYgPSBUcmVlMC5leGlzdHMgdCB+ZlxuICBsZXQgZXhpc3RzaSB0IH5mID0gVHJlZTAuZXhpc3RzaSB0IH5mXG4gIGxldCBjb3VudCB0IH5mID0gVHJlZTAuY291bnQgdCB+ZlxuICBsZXQgY291bnRpIHQgfmYgPSBUcmVlMC5jb3VudGkgdCB+ZlxuICBsZXQgc3BsaXQgfmNvbXBhcmF0b3IgdCBrID0gVHJlZTAuc3BsaXQgdCBrIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuXG4gIGxldCBhcHBlbmQgfmNvbXBhcmF0b3Igfmxvd2VyX3BhcnQgfnVwcGVyX3BhcnQgPVxuICAgIFRyZWUwLmFwcGVuZCB+bG93ZXJfcGFydCB+dXBwZXJfcGFydCB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgOztcblxuICBsZXQgc3VicmFuZ2UgfmNvbXBhcmF0b3IgdCB+bG93ZXJfYm91bmQgfnVwcGVyX2JvdW5kID1cbiAgICBsZXQgXywgcmV0LCBfID1cbiAgICAgIFRyZWUwLnNwbGl0X3JhbmdlXG4gICAgICAgIHRcbiAgICAgICAgfmxvd2VyX2JvdW5kXG4gICAgICAgIH51cHBlcl9ib3VuZFxuICAgICAgICB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICBpblxuICAgIHJldFxuICA7O1xuXG4gIGxldCBmb2xkX3JhbmdlX2luY2x1c2l2ZSB+Y29tcGFyYXRvciB0IH5taW4gfm1heCB+aW5pdCB+ZiA9XG4gICAgVHJlZTAuZm9sZF9yYW5nZV9pbmNsdXNpdmVcbiAgICAgIHRcbiAgICAgIH5taW5cbiAgICAgIH5tYXhcbiAgICAgIH5pbml0XG4gICAgICB+ZlxuICAgICAgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gIDs7XG5cbiAgbGV0IHJhbmdlX3RvX2FsaXN0IH5jb21wYXJhdG9yIHQgfm1pbiB+bWF4ID1cbiAgICBUcmVlMC5yYW5nZV90b19hbGlzdCB0IH5taW4gfm1heCB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgOztcblxuICBsZXQgY2xvc2VzdF9rZXkgfmNvbXBhcmF0b3IgdCBkaXIga2V5ID1cbiAgICBUcmVlMC5jbG9zZXN0X2tleSB0IGRpciBrZXkgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gIDs7XG5cbiAgbGV0IG50aCB0IG4gPSBUcmVlMC5udGggdCBuXG4gIGxldCBudGhfZXhuIHQgbiA9IE9wdGlvbi52YWx1ZV9leG4gKG50aCB0IG4pXG4gIGxldCByYW5rIH5jb21wYXJhdG9yIHQga2V5ID0gVHJlZTAucmFuayB0IGtleSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgbGV0IHNleHBfb2ZfdCBzZXhwX29mX2sgc2V4cF9vZl92IF8gdCA9IFRyZWUwLnNleHBfb2ZfdCBzZXhwX29mX2sgc2V4cF9vZl92IHRcblxuICBsZXQgdF9vZl9zZXhwX2RpcmVjdCB+Y29tcGFyYXRvciBrX29mX3NleHAgdl9vZl9zZXhwIHNleHAgPVxuICAgIGZzdCAoVHJlZTAudF9vZl9zZXhwX2RpcmVjdCBrX29mX3NleHAgdl9vZl9zZXhwIHNleHAgfmNvbXBhcmF0b3IpXG4gIDs7XG5cbiAgbGV0IHRvX3NlcXVlbmNlIH5jb21wYXJhdG9yID9vcmRlciA/a2V5c19ncmVhdGVyX29yX2VxdWFsX3RvID9rZXlzX2xlc3Nfb3JfZXF1YWxfdG8gdCA9XG4gICAgVHJlZTAudG9fc2VxdWVuY2UgY29tcGFyYXRvciA/b3JkZXIgP2tleXNfZ3JlYXRlcl9vcl9lcXVhbF90byA/a2V5c19sZXNzX29yX2VxdWFsX3RvIHRcbiAgOztcblxuICBsZXQgYmluYXJ5X3NlYXJjaCB+Y29tcGFyYXRvcjpfIHQgfmNvbXBhcmUgaG93IHYgPSBUcmVlMC5iaW5hcnlfc2VhcmNoIHQgfmNvbXBhcmUgaG93IHZcblxuICBsZXQgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQgfmNvbXBhcmF0b3I6XyB0IH5zZWdtZW50X29mIGhvdyA9XG4gICAgVHJlZTAuYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQgdCB+c2VnbWVudF9vZiBob3dcbiAgOztcblxuICBsZXQgYmluYXJ5X3NlYXJjaF9zdWJyYW5nZSB+Y29tcGFyYXRvciB0IH5jb21wYXJlIH5sb3dlcl9ib3VuZCB+dXBwZXJfYm91bmQgPVxuICAgIG1hdGNoIFRyZWUwLmJpbmFyeV9zZWFyY2hfdHdvX3NpZGVkX2JvdW5kcyB0IH5jb21wYXJlIH5sb3dlcl9ib3VuZCB+dXBwZXJfYm91bmQgd2l0aFxuICAgIHwgU29tZSAobG93ZXJfYm91bmQsIHVwcGVyX2JvdW5kKSAtPiBzdWJyYW5nZSB+Y29tcGFyYXRvciB0IH5sb3dlcl9ib3VuZCB+dXBwZXJfYm91bmRcbiAgICB8IE5vbmUgLT4gRW1wdHlcbiAgOztcblxuICBsZXQgbWFwX2tleXMgfmNvbXBhcmF0b3IgdCB+ZiA9XG4gICAgbWF0Y2ggVHJlZTAubWFwX2tleXMgfmNvbXBhcmF0b3IgdCB+ZiB3aXRoXG4gICAgfCBgT2sgKHQsIF8pIC0+IGBPayB0XG4gICAgfCBgRHVwbGljYXRlX2tleSBfIGFzIGR1cCAtPiBkdXBcbiAgOztcblxuICBsZXQgbWFwX2tleXNfZXhuIH5jb21wYXJhdG9yIHQgfmYgPSBmc3QgKFRyZWUwLm1hcF9rZXlzX2V4biB+Y29tcGFyYXRvciB0IH5mKVxuXG4gIG1vZHVsZSBCdWlsZF9pbmNyZWFzaW5nID0gc3RydWN0XG4gICAgdHlwZSAoJ2ssICd2LCAndykgdCA9ICgnaywgJ3YpIFRyZWUwLkJ1aWxkX2luY3JlYXNpbmcudFxuXG4gICAgbGV0IGVtcHR5ID0gVHJlZTAuQnVpbGRfaW5jcmVhc2luZy5lbXB0eVxuXG4gICAgbGV0IGFkZF9leG4gdCB+Y29tcGFyYXRvciB+a2V5IH5kYXRhID1cbiAgICAgIG1hdGNoIFRyZWUwLkJ1aWxkX2luY3JlYXNpbmcubWF4X2tleSB0IHdpdGhcbiAgICAgIHwgU29tZSBwcmV2X2tleSB3aGVuIGNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIHByZXZfa2V5IGtleSA+PSAwIC0+XG4gICAgICAgIEVycm9yLnJhaXNlX3MgKFNleHAuQXRvbSBcIk1hcC5CdWlsZF9pbmNyZWFzaW5nLmFkZDogbm9uLWluY3JlYXNpbmcga2V5XCIpXG4gICAgICB8IF8gLT4gVHJlZTAuQnVpbGRfaW5jcmVhc2luZy5hZGRfdW5jaGVja2VkIHQgfmtleSB+ZGF0YVxuICAgIDs7XG5cbiAgICBsZXQgdG9fdHJlZSB0ID0gVHJlZTAuQnVpbGRfaW5jcmVhc2luZy50b190cmVlX3VuY2hlY2tlZCB0XG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBVc2luZ19jb21wYXJhdG9yID0gc3RydWN0XG4gIHR5cGUgbm9ucmVjICgnaywgJ3YsICdjbXApIHQgPSAoJ2ssICd2LCAnY21wKSB0XG5cbiAgaW5jbHVkZSBBY2Nlc3NvcnNcblxuICBsZXQgZW1wdHkgfmNvbXBhcmF0b3IgPSB7IHRyZWUgPSBUcmVlMC5lbXB0eTsgY29tcGFyYXRvcjsgbGVuZ3RoID0gMCB9XG4gIGxldCBzaW5nbGV0b24gfmNvbXBhcmF0b3IgayB2ID0geyBjb21wYXJhdG9yOyB0cmVlID0gVHJlZTAuc2luZ2xldG9uIGsgdjsgbGVuZ3RoID0gMSB9XG4gIGxldCBvZl90cmVlMCB+Y29tcGFyYXRvciAodHJlZSwgbGVuZ3RoKSA9IHsgY29tcGFyYXRvcjsgdHJlZTsgbGVuZ3RoIH1cbiAgbGV0IG9mX3RyZWUgfmNvbXBhcmF0b3IgdHJlZSA9IG9mX3RyZWUwIH5jb21wYXJhdG9yICh0cmVlLCBUcmVlMC5sZW5ndGggdHJlZSlcbiAgbGV0IHRvX3RyZWUgPSB0b190cmVlXG5cbiAgbGV0IG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgfmNvbXBhcmF0b3IgYXJyYXkgPVxuICAgIG9mX3RyZWUwXG4gICAgICB+Y29tcGFyYXRvclxuICAgICAgKFRyZWUwLm9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgYXJyYXkgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBvZl9zb3J0ZWRfYXJyYXkgfmNvbXBhcmF0b3IgYXJyYXkgPVxuICAgIE9yX2Vycm9yLm1hcFxuICAgICAgKFRyZWUwLm9mX3NvcnRlZF9hcnJheSBhcnJheSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gICAgICB+ZjooZnVuIHRyZWUgLT4gb2ZfdHJlZTAgfmNvbXBhcmF0b3IgdHJlZSlcbiAgOztcblxuICBsZXQgb2ZfYWxpc3QgfmNvbXBhcmF0b3IgYWxpc3QgPVxuICAgIG1hdGNoIFRyZWUwLm9mX2FsaXN0IGFsaXN0IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSB3aXRoXG4gICAgfCBgT2sgKHRyZWUsIGxlbmd0aCkgLT4gYE9rIHsgY29tcGFyYXRvcjsgdHJlZTsgbGVuZ3RoIH1cbiAgICB8IGBEdXBsaWNhdGVfa2V5IF8gYXMgeiAtPiB6XG4gIDs7XG5cbiAgbGV0IG9mX2FsaXN0X29yX2Vycm9yIH5jb21wYXJhdG9yIGFsaXN0ID1cbiAgICBSZXN1bHQubWFwIChUcmVlMC5vZl9hbGlzdF9vcl9lcnJvciBhbGlzdCB+Y29tcGFyYXRvcikgfmY6KGZ1biB0cmVlIC0+XG4gICAgICBvZl90cmVlMCB+Y29tcGFyYXRvciB0cmVlKVxuICA7O1xuXG4gIGxldCBvZl9hbGlzdF9leG4gfmNvbXBhcmF0b3IgYWxpc3QgPVxuICAgIG9mX3RyZWUwIH5jb21wYXJhdG9yIChUcmVlMC5vZl9hbGlzdF9leG4gYWxpc3QgfmNvbXBhcmF0b3IpXG4gIDs7XG5cbiAgbGV0IG9mX2FsaXN0X211bHRpIH5jb21wYXJhdG9yIGFsaXN0ID1cbiAgICBvZl90cmVlMFxuICAgICAgfmNvbXBhcmF0b3JcbiAgICAgIChUcmVlMC5vZl9hbGlzdF9tdWx0aSBhbGlzdCB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IG9mX2FsaXN0X2ZvbGQgfmNvbXBhcmF0b3IgYWxpc3QgfmluaXQgfmYgPVxuICAgIG9mX3RyZWUwXG4gICAgICB+Y29tcGFyYXRvclxuICAgICAgKFRyZWUwLm9mX2FsaXN0X2ZvbGQgYWxpc3QgfmluaXQgfmYgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBvZl9hbGlzdF9yZWR1Y2UgfmNvbXBhcmF0b3IgYWxpc3QgfmYgPVxuICAgIG9mX3RyZWUwXG4gICAgICB+Y29tcGFyYXRvclxuICAgICAgKFRyZWUwLm9mX2FsaXN0X3JlZHVjZSBhbGlzdCB+ZiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IG9mX2l0ZXJpIH5jb21wYXJhdG9yIH5pdGVyaSA9XG4gICAgbWF0Y2ggVHJlZTAub2ZfaXRlcmkgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIH5pdGVyaSB3aXRoXG4gICAgfCBgT2sgdHJlZV9sZW5ndGggLT4gYE9rIChvZl90cmVlMCB+Y29tcGFyYXRvciB0cmVlX2xlbmd0aClcbiAgICB8IGBEdXBsaWNhdGVfa2V5IF8gYXMgeiAtPiB6XG4gIDs7XG5cbiAgbGV0IG9mX2l0ZXJpX2V4biB+Y29tcGFyYXRvciB+aXRlcmkgPVxuICAgIG9mX3RyZWUwIH5jb21wYXJhdG9yIChUcmVlMC5vZl9pdGVyaV9leG4gfmNvbXBhcmF0b3Igfml0ZXJpKVxuICA7O1xuXG4gIGxldCBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+Y29tcGFyYXRvciB+bGVuIH5mID1cbiAgICBvZl90cmVlMCB+Y29tcGFyYXRvciAoVHJlZTAub2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmxlbiB+ZiwgbGVuKVxuICA7O1xuXG4gIGxldCBvZl9pbmNyZWFzaW5nX3NlcXVlbmNlIH5jb21wYXJhdG9yIHNlcSA9XG4gICAgT3JfZXJyb3IubWFwXG4gICAgICB+Zjoob2ZfdHJlZTAgfmNvbXBhcmF0b3IpXG4gICAgICAoVHJlZTAub2ZfaW5jcmVhc2luZ19zZXF1ZW5jZSBzZXEgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBvZl9zZXF1ZW5jZSB+Y29tcGFyYXRvciBzZXEgPVxuICAgIG1hdGNoIFRyZWUwLm9mX3NlcXVlbmNlIHNlcSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgd2l0aFxuICAgIHwgYE9rICh0cmVlLCBsZW5ndGgpIC0+IGBPayB7IGNvbXBhcmF0b3I7IHRyZWU7IGxlbmd0aCB9XG4gICAgfCBgRHVwbGljYXRlX2tleSBfIGFzIHogLT4gelxuICA7O1xuXG4gIGxldCBvZl9zZXF1ZW5jZV9vcl9lcnJvciB+Y29tcGFyYXRvciBzZXEgPVxuICAgIFJlc3VsdC5tYXAgKFRyZWUwLm9mX3NlcXVlbmNlX29yX2Vycm9yIHNlcSB+Y29tcGFyYXRvcikgfmY6KGZ1biB0cmVlIC0+XG4gICAgICBvZl90cmVlMCB+Y29tcGFyYXRvciB0cmVlKVxuICA7O1xuXG4gIGxldCBvZl9zZXF1ZW5jZV9leG4gfmNvbXBhcmF0b3Igc2VxID1cbiAgICBvZl90cmVlMCB+Y29tcGFyYXRvciAoVHJlZTAub2Zfc2VxdWVuY2VfZXhuIHNlcSB+Y29tcGFyYXRvcilcbiAgOztcblxuICBsZXQgb2Zfc2VxdWVuY2VfbXVsdGkgfmNvbXBhcmF0b3Igc2VxID1cbiAgICBvZl90cmVlMFxuICAgICAgfmNvbXBhcmF0b3JcbiAgICAgIChUcmVlMC5vZl9zZXF1ZW5jZV9tdWx0aSBzZXEgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBvZl9zZXF1ZW5jZV9mb2xkIH5jb21wYXJhdG9yIHNlcSB+aW5pdCB+ZiA9XG4gICAgb2ZfdHJlZTBcbiAgICAgIH5jb21wYXJhdG9yXG4gICAgICAoVHJlZTAub2Zfc2VxdWVuY2VfZm9sZCBzZXEgfmluaXQgfmYgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBvZl9zZXF1ZW5jZV9yZWR1Y2UgfmNvbXBhcmF0b3Igc2VxIH5mID1cbiAgICBvZl90cmVlMFxuICAgICAgfmNvbXBhcmF0b3JcbiAgICAgIChUcmVlMC5vZl9zZXF1ZW5jZV9yZWR1Y2Ugc2VxIH5mIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgdF9vZl9zZXhwX2RpcmVjdCB+Y29tcGFyYXRvciBrX29mX3NleHAgdl9vZl9zZXhwIHNleHAgPVxuICAgIG9mX3RyZWUwIH5jb21wYXJhdG9yIChUcmVlMC50X29mX3NleHBfZGlyZWN0IGtfb2Zfc2V4cCB2X29mX3NleHAgc2V4cCB+Y29tcGFyYXRvcilcbiAgOztcblxuICBsZXQgbWFwX2tleXMgfmNvbXBhcmF0b3IgdCB+ZiA9XG4gICAgbWF0Y2ggVHJlZTAubWFwX2tleXMgdC50cmVlIH5mIH5jb21wYXJhdG9yIHdpdGhcbiAgICB8IGBPayBwYWlyIC0+IGBPayAob2ZfdHJlZTAgfmNvbXBhcmF0b3IgcGFpcilcbiAgICB8IGBEdXBsaWNhdGVfa2V5IF8gYXMgZHVwIC0+IGR1cFxuICA7O1xuXG4gIGxldCBtYXBfa2V5c19leG4gfmNvbXBhcmF0b3IgdCB+ZiA9XG4gICAgb2ZfdHJlZTAgfmNvbXBhcmF0b3IgKFRyZWUwLm1hcF9rZXlzX2V4biB0LnRyZWUgfmYgfmNvbXBhcmF0b3IpXG4gIDs7XG5cbiAgbW9kdWxlIEVtcHR5X3dpdGhvdXRfdmFsdWVfcmVzdHJpY3Rpb24gKEsgOiBDb21wYXJhdG9yLlMxKSA9IHN0cnVjdFxuICAgIGxldCBlbXB0eSA9IHsgdHJlZSA9IFRyZWUwLmVtcHR5OyBjb21wYXJhdG9yID0gSy5jb21wYXJhdG9yOyBsZW5ndGggPSAwIH1cbiAgZW5kXG5cbiAgbW9kdWxlIFRyZWUgPSBUcmVlXG5lbmRcblxuaW5jbHVkZSBBY2Nlc3NvcnNcblxudHlwZSAoJ2ssICdjbXApIGNvbXBhcmF0b3IgPVxuICAobW9kdWxlIENvbXBhcmF0b3IuUyB3aXRoIHR5cGUgdCA9ICdrIGFuZCB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA9ICdjbXApXG5cbmxldCBjb21wYXJhdG9yX3MgKHR5cGUgayBjbXApIHQgOiAoaywgY21wKSBjb21wYXJhdG9yID1cbiAgKG1vZHVsZSBzdHJ1Y3RcbiAgICB0eXBlIHQgPSBrXG4gICAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSBjbXBcblxuICAgIGxldCBjb21wYXJhdG9yID0gdC5jb21wYXJhdG9yXG4gIGVuZClcbjs7XG5cbmxldCB0b19jb21wYXJhdG9yICh0eXBlIGsgY21wKSAoKG1vZHVsZSBNKSA6IChrLCBjbXApIGNvbXBhcmF0b3IpID0gTS5jb21wYXJhdG9yXG5cbmxldCBvZl90cmVlICh0eXBlIGsgY21wKSAoKG1vZHVsZSBNKSA6IChrLCBjbXApIGNvbXBhcmF0b3IpIHRyZWUgPVxuICBvZl90cmVlIH5jb21wYXJhdG9yOk0uY29tcGFyYXRvciB0cmVlXG47O1xuXG5sZXQgZW1wdHkgbSA9IFVzaW5nX2NvbXBhcmF0b3IuZW1wdHkgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSlcbmxldCBzaW5nbGV0b24gbSBhID0gVXNpbmdfY29tcGFyYXRvci5zaW5nbGV0b24gfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgYVxubGV0IG9mX2FsaXN0IG0gYSA9IFVzaW5nX2NvbXBhcmF0b3Iub2ZfYWxpc3QgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgYVxuXG5sZXQgb2ZfYWxpc3Rfb3JfZXJyb3IgbSBhID1cbiAgVXNpbmdfY29tcGFyYXRvci5vZl9hbGlzdF9vcl9lcnJvciB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhXG47O1xuXG5sZXQgb2ZfYWxpc3RfZXhuIG0gYSA9IFVzaW5nX2NvbXBhcmF0b3Iub2ZfYWxpc3RfZXhuIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGFcbmxldCBvZl9hbGlzdF9tdWx0aSBtIGEgPSBVc2luZ19jb21wYXJhdG9yLm9mX2FsaXN0X211bHRpIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGFcblxubGV0IG9mX2FsaXN0X2ZvbGQgbSBhIH5pbml0IH5mID1cbiAgVXNpbmdfY29tcGFyYXRvci5vZl9hbGlzdF9mb2xkIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGEgfmluaXQgfmZcbjs7XG5cbmxldCBvZl9hbGlzdF9yZWR1Y2UgbSBhIH5mID1cbiAgVXNpbmdfY29tcGFyYXRvci5vZl9hbGlzdF9yZWR1Y2UgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgYSB+ZlxuOztcblxubGV0IG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgbSBhID1cbiAgVXNpbmdfY29tcGFyYXRvci5vZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGFcbjs7XG5cbmxldCBvZl9zb3J0ZWRfYXJyYXkgbSBhID0gVXNpbmdfY29tcGFyYXRvci5vZl9zb3J0ZWRfYXJyYXkgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgYVxubGV0IG9mX2l0ZXJpIG0gfml0ZXJpID0gVXNpbmdfY29tcGFyYXRvci5vZl9pdGVyaSB+aXRlcmkgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSlcblxubGV0IG9mX2l0ZXJpX2V4biBtIH5pdGVyaSA9XG4gIFVzaW5nX2NvbXBhcmF0b3Iub2ZfaXRlcmlfZXhuIH5pdGVyaSB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKVxuOztcblxubGV0IG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIG0gfmxlbiB+ZiA9XG4gIFVzaW5nX2NvbXBhcmF0b3Iub2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmxlbiB+ZiB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKVxuOztcblxubGV0IG9mX2luY3JlYXNpbmdfc2VxdWVuY2UgbSBzZXEgPVxuICBVc2luZ19jb21wYXJhdG9yLm9mX2luY3JlYXNpbmdfc2VxdWVuY2UgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgc2VxXG47O1xuXG5sZXQgb2Zfc2VxdWVuY2UgbSBzID0gVXNpbmdfY29tcGFyYXRvci5vZl9zZXF1ZW5jZSB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBzXG5cbmxldCBvZl9zZXF1ZW5jZV9vcl9lcnJvciBtIHMgPVxuICBVc2luZ19jb21wYXJhdG9yLm9mX3NlcXVlbmNlX29yX2Vycm9yIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIHNcbjs7XG5cbmxldCBvZl9zZXF1ZW5jZV9leG4gbSBzID0gVXNpbmdfY29tcGFyYXRvci5vZl9zZXF1ZW5jZV9leG4gfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgc1xuXG5sZXQgb2Zfc2VxdWVuY2VfbXVsdGkgbSBzID1cbiAgVXNpbmdfY29tcGFyYXRvci5vZl9zZXF1ZW5jZV9tdWx0aSB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBzXG47O1xuXG5sZXQgb2Zfc2VxdWVuY2VfZm9sZCBtIHMgfmluaXQgfmYgPVxuICBVc2luZ19jb21wYXJhdG9yLm9mX3NlcXVlbmNlX2ZvbGQgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgcyB+aW5pdCB+ZlxuOztcblxubGV0IG9mX3NlcXVlbmNlX3JlZHVjZSBtIHMgfmYgPVxuICBVc2luZ19jb21wYXJhdG9yLm9mX3NlcXVlbmNlX3JlZHVjZSB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBzIH5mXG47O1xuXG5sZXQgbWFwX2tleXMgbSB0IH5mID0gVXNpbmdfY29tcGFyYXRvci5tYXBfa2V5cyB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSB0IH5mXG5sZXQgbWFwX2tleXNfZXhuIG0gdCB+ZiA9IFVzaW5nX2NvbXBhcmF0b3IubWFwX2tleXNfZXhuIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIHQgfmZcblxubW9kdWxlIE0gKEsgOiBzaWdcbiAgICB0eXBlIHRcbiAgICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzc1xuICBlbmQpID1cbnN0cnVjdFxuICB0eXBlIG5vbnJlYyAndiB0ID0gKEsudCwgJ3YsIEsuY29tcGFyYXRvcl93aXRuZXNzKSB0XG5lbmRcblxubW9kdWxlIHR5cGUgU2V4cF9vZl9tID0gc2lnXG4gIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICB2YWwgc2V4cF9vZl90IDogdCAtPiBTZXhwbGliMC5TZXhwLnRcblxuICBbQEBAZW5kXVxuZW5kXG5cbm1vZHVsZSB0eXBlIE1fb2Zfc2V4cCA9IHNpZ1xuICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIG9mX3NleHBdXG5cbiAgdmFsIHRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0XG5cbiAgW0BAQGVuZF1cblxuICBpbmNsdWRlIENvbXBhcmF0b3IuUyB3aXRoIHR5cGUgdCA6PSB0XG5lbmRcblxubW9kdWxlIHR5cGUgTV9zZXhwX2dyYW1tYXIgPSBzaWdcbiAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX2dyYW1tYXJdXG5cbiAgdmFsIHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuXG4gIFtAQEBlbmRdXG5lbmRcblxubW9kdWxlIHR5cGUgQ29tcGFyZV9tID0gc2lnIGVuZFxubW9kdWxlIHR5cGUgRXF1YWxfbSA9IHNpZyBlbmRcbm1vZHVsZSB0eXBlIEhhc2hfZm9sZF9tID0gSGFzaGVyLlNcblxubGV0IHNleHBfb2ZfbV9fdCAodHlwZSBrKSAobW9kdWxlIEsgOiBTZXhwX29mX20gd2l0aCB0eXBlIHQgPSBrKSBzZXhwX29mX3YgdCA9XG4gIHNleHBfb2ZfdCBLLnNleHBfb2ZfdCBzZXhwX29mX3YgKGZ1biBfIC0+IFNleHAuQXRvbSBcIl9cIikgdFxuOztcblxubGV0IG1fX3Rfb2Zfc2V4cFxuICAgICAgKHR5cGUgayBjbXApXG4gICAgICAobW9kdWxlIEsgOiBNX29mX3NleHAgd2l0aCB0eXBlIHQgPSBrIGFuZCB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA9IGNtcClcbiAgICAgIHZfb2Zfc2V4cFxuICAgICAgc2V4cFxuICA9XG4gIFVzaW5nX2NvbXBhcmF0b3IudF9vZl9zZXhwX2RpcmVjdCB+Y29tcGFyYXRvcjpLLmNvbXBhcmF0b3IgSy50X29mX3NleHAgdl9vZl9zZXhwIHNleHBcbjs7XG5cbmxldCBtX190X3NleHBfZ3JhbW1hclxuICAgICAgKHR5cGUgaylcbiAgICAgIChtb2R1bGUgSyA6IE1fc2V4cF9ncmFtbWFyIHdpdGggdHlwZSB0ID0gaylcbiAgICAgICh2X2dyYW1tYXIgOiBfIFNleHBsaWIwLlNleHBfZ3JhbW1hci50KVxuICA6IF8gU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgPVxuICB7IHVudHlwZWQgPVxuICAgICAgTGlzdFxuICAgICAgICAoTWFueSAoTGlzdCAoQ29ucyAoSy50X3NleHBfZ3JhbW1hci51bnR5cGVkLCBDb25zICh2X2dyYW1tYXIudW50eXBlZCwgRW1wdHkpKSkpKVxuICB9XG47O1xuXG5sZXQgY29tcGFyZV9tX190IChtb2R1bGUgXyA6IENvbXBhcmVfbSkgY29tcGFyZV92IHQxIHQyID0gY29tcGFyZV9kaXJlY3QgY29tcGFyZV92IHQxIHQyXG5sZXQgZXF1YWxfbV9fdCAobW9kdWxlIF8gOiBFcXVhbF9tKSBlcXVhbF92IHQxIHQyID0gZXF1YWwgZXF1YWxfdiB0MSB0MlxuXG5sZXQgaGFzaF9mb2xkX21fX3QgKHR5cGUgaykgKG1vZHVsZSBLIDogSGFzaF9mb2xkX20gd2l0aCB0eXBlIHQgPSBrKSBoYXNoX2ZvbGRfdiBzdGF0ZSA9XG4gIGhhc2hfZm9sZF9kaXJlY3QgSy5oYXNoX2ZvbGRfdCBoYXNoX2ZvbGRfdiBzdGF0ZVxuOztcblxubW9kdWxlIFBvbHkgPSBzdHJ1Y3RcbiAgdHlwZSBub25yZWMgKCdrLCAndikgdCA9ICgnaywgJ3YsIENvbXBhcmF0b3IuUG9seS5jb21wYXJhdG9yX3dpdG5lc3MpIHRcbiAgdHlwZSBub25yZWMgKCdrLCAndikgdHJlZSA9ICgnaywgJ3YpIFRyZWUwLnRcbiAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSBDb21wYXJhdG9yLlBvbHkuY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgaW5jbHVkZSBBY2Nlc3NvcnNcblxuICBsZXQgY29tcGFyYXRvciA9IENvbXBhcmF0b3IuUG9seS5jb21wYXJhdG9yXG4gIGxldCBvZl90cmVlIHRyZWUgPSB7IHRyZWU7IGNvbXBhcmF0b3I7IGxlbmd0aCA9IFRyZWUwLmxlbmd0aCB0cmVlIH1cblxuICBpbmNsdWRlIFVzaW5nX2NvbXBhcmF0b3IuRW1wdHlfd2l0aG91dF92YWx1ZV9yZXN0cmljdGlvbiAoQ29tcGFyYXRvci5Qb2x5KVxuXG4gIGxldCBzaW5nbGV0b24gYSA9IFVzaW5nX2NvbXBhcmF0b3Iuc2luZ2xldG9uIH5jb21wYXJhdG9yIGFcbiAgbGV0IG9mX2FsaXN0IGEgPSBVc2luZ19jb21wYXJhdG9yLm9mX2FsaXN0IH5jb21wYXJhdG9yIGFcbiAgbGV0IG9mX2FsaXN0X29yX2Vycm9yIGEgPSBVc2luZ19jb21wYXJhdG9yLm9mX2FsaXN0X29yX2Vycm9yIH5jb21wYXJhdG9yIGFcbiAgbGV0IG9mX2FsaXN0X2V4biBhID0gVXNpbmdfY29tcGFyYXRvci5vZl9hbGlzdF9leG4gfmNvbXBhcmF0b3IgYVxuICBsZXQgb2ZfYWxpc3RfbXVsdGkgYSA9IFVzaW5nX2NvbXBhcmF0b3Iub2ZfYWxpc3RfbXVsdGkgfmNvbXBhcmF0b3IgYVxuICBsZXQgb2ZfYWxpc3RfZm9sZCBhIH5pbml0IH5mID0gVXNpbmdfY29tcGFyYXRvci5vZl9hbGlzdF9mb2xkIH5jb21wYXJhdG9yIGEgfmluaXQgfmZcbiAgbGV0IG9mX2FsaXN0X3JlZHVjZSBhIH5mID0gVXNpbmdfY29tcGFyYXRvci5vZl9hbGlzdF9yZWR1Y2UgfmNvbXBhcmF0b3IgYSB+ZlxuXG4gIGxldCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIGEgPVxuICAgIFVzaW5nX2NvbXBhcmF0b3Iub2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCB+Y29tcGFyYXRvciBhXG4gIDs7XG5cbiAgbGV0IG9mX3NvcnRlZF9hcnJheSBhID0gVXNpbmdfY29tcGFyYXRvci5vZl9zb3J0ZWRfYXJyYXkgfmNvbXBhcmF0b3IgYVxuICBsZXQgb2ZfaXRlcmkgfml0ZXJpID0gVXNpbmdfY29tcGFyYXRvci5vZl9pdGVyaSB+aXRlcmkgfmNvbXBhcmF0b3JcbiAgbGV0IG9mX2l0ZXJpX2V4biB+aXRlcmkgPSBVc2luZ19jb21wYXJhdG9yLm9mX2l0ZXJpX2V4biB+aXRlcmkgfmNvbXBhcmF0b3JcblxuICBsZXQgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmxlbiB+ZiA9XG4gICAgVXNpbmdfY29tcGFyYXRvci5vZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+bGVuIH5mIH5jb21wYXJhdG9yXG4gIDs7XG5cbiAgbGV0IG9mX2luY3JlYXNpbmdfc2VxdWVuY2Ugc2VxID0gVXNpbmdfY29tcGFyYXRvci5vZl9pbmNyZWFzaW5nX3NlcXVlbmNlIH5jb21wYXJhdG9yIHNlcVxuICBsZXQgb2Zfc2VxdWVuY2UgcyA9IFVzaW5nX2NvbXBhcmF0b3Iub2Zfc2VxdWVuY2UgfmNvbXBhcmF0b3Igc1xuICBsZXQgb2Zfc2VxdWVuY2Vfb3JfZXJyb3IgcyA9IFVzaW5nX2NvbXBhcmF0b3Iub2Zfc2VxdWVuY2Vfb3JfZXJyb3IgfmNvbXBhcmF0b3Igc1xuICBsZXQgb2Zfc2VxdWVuY2VfZXhuIHMgPSBVc2luZ19jb21wYXJhdG9yLm9mX3NlcXVlbmNlX2V4biB+Y29tcGFyYXRvciBzXG4gIGxldCBvZl9zZXF1ZW5jZV9tdWx0aSBzID0gVXNpbmdfY29tcGFyYXRvci5vZl9zZXF1ZW5jZV9tdWx0aSB+Y29tcGFyYXRvciBzXG5cbiAgbGV0IG9mX3NlcXVlbmNlX2ZvbGQgcyB+aW5pdCB+ZiA9XG4gICAgVXNpbmdfY29tcGFyYXRvci5vZl9zZXF1ZW5jZV9mb2xkIH5jb21wYXJhdG9yIHMgfmluaXQgfmZcbiAgOztcblxuICBsZXQgb2Zfc2VxdWVuY2VfcmVkdWNlIHMgfmYgPSBVc2luZ19jb21wYXJhdG9yLm9mX3NlcXVlbmNlX3JlZHVjZSB+Y29tcGFyYXRvciBzIH5mXG4gIGxldCBtYXBfa2V5cyB0IH5mID0gVXNpbmdfY29tcGFyYXRvci5tYXBfa2V5cyB+Y29tcGFyYXRvciB0IH5mXG4gIGxldCBtYXBfa2V5c19leG4gdCB+ZiA9IFVzaW5nX2NvbXBhcmF0b3IubWFwX2tleXNfZXhuIH5jb21wYXJhdG9yIHQgfmZcbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5vcGVuISBDYW1sLkludDY0XG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIHR5cGUgdCA9IGludDY0IFtAQGRlcml2aW5nX2lubGluZSBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgIGhhc2hfZm9sZF9pbnQ2NFxuXG4gIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IGhhc2hfaW50NjQgaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgdF9vZl9zZXhwID0gKGludDY0X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdClcbiAgbGV0IHNleHBfb2ZfdCA9IChzZXhwX29mX2ludDY0IDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IGludDY0X3NleHBfZ3JhbW1hclxuXG4gIFtAQEBlbmRdXG5cbiAgbGV0IGhhc2hhYmxlIDogdCBIYXNoYWJsZS50ID0geyBoYXNoOyBjb21wYXJlOyBzZXhwX29mX3QgfVxuXG4gIGxldCBjb21wYXJlID0gSW50NjRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLmNvbXBhcmVcbiAgbGV0IHRvX3N0cmluZyA9IHRvX3N0cmluZ1xuICBsZXQgb2Zfc3RyaW5nID0gb2Zfc3RyaW5nXG5lbmRcblxuaW5jbHVkZSBUXG5pbmNsdWRlIENvbXBhcmF0b3IuTWFrZSAoVClcblxubGV0IG51bV9iaXRzID0gNjRcbmxldCBmbG9hdF9sb3dlcl9ib3VuZCA9IEZsb2F0MC5sb3dlcl9ib3VuZF9mb3JfaW50IG51bV9iaXRzXG5sZXQgZmxvYXRfdXBwZXJfYm91bmQgPSBGbG9hdDAudXBwZXJfYm91bmRfZm9yX2ludCBudW1fYml0c1xubGV0IGZsb2F0X29mX2JpdHMgPSBmbG9hdF9vZl9iaXRzXG5sZXQgYml0c19vZl9mbG9hdCA9IGJpdHNfb2ZfZmxvYXRcbmxldCBzaGlmdF9yaWdodF9sb2dpY2FsID0gc2hpZnRfcmlnaHRfbG9naWNhbFxubGV0IHNoaWZ0X3JpZ2h0ID0gc2hpZnRfcmlnaHRcbmxldCBzaGlmdF9sZWZ0ID0gc2hpZnRfbGVmdFxubGV0IGJpdF9ub3QgPSBsb2dub3RcbmxldCBiaXRfeG9yID0gbG9neG9yXG5sZXQgYml0X29yID0gbG9nb3JcbmxldCBiaXRfYW5kID0gbG9nYW5kXG5sZXQgbWluX3ZhbHVlID0gbWluX2ludFxubGV0IG1heF92YWx1ZSA9IG1heF9pbnRcbmxldCBhYnMgPSBhYnNcbmxldCBwcmVkID0gcHJlZFxubGV0IHN1Y2MgPSBzdWNjXG5sZXQgcG93ID0gSW50X21hdGguUHJpdmF0ZS5pbnQ2NF9wb3dcbmxldCByZW0gPSByZW1cbmxldCBuZWcgPSBuZWdcbmxldCBtaW51c19vbmUgPSBtaW51c19vbmVcbmxldCBvbmUgPSBvbmVcbmxldCB6ZXJvID0gemVyb1xubGV0IHRvX2Zsb2F0ID0gdG9fZmxvYXRcbmxldCBvZl9mbG9hdF91bmNoZWNrZWQgPSBDYW1sLkludDY0Lm9mX2Zsb2F0XG5cbmxldCBvZl9mbG9hdCBmID1cbiAgaWYgRmxvYXRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPj0gKSBmIGZsb2F0X2xvd2VyX2JvdW5kXG4gICYmIEZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oIDw9ICkgZiBmbG9hdF91cHBlcl9ib3VuZFxuICB0aGVuIENhbWwuSW50NjQub2ZfZmxvYXQgZlxuICBlbHNlXG4gICAgUHJpbnRmLmludmFsaWRfYXJnZlxuICAgICAgXCJJbnQ2NC5vZl9mbG9hdDogYXJndW1lbnQgKCVmKSBpcyBvdXQgb2YgcmFuZ2Ugb3IgTmFOXCJcbiAgICAgIChGbG9hdDAuYm94IGYpXG4gICAgICAoKVxuOztcblxubGV0ICggKiogKSBiIGUgPSBwb3cgYiBlXG5cbmV4dGVybmFsIGJzd2FwNjQgOiB0IC0+IHQgPSBcIiVic3dhcF9pbnQ2NFwiXG5cbmxldFtAaW5saW5lIGFsd2F5c10gYnN3YXAxNiB4ID0gQ2FtbC5JbnQ2NC5zaGlmdF9yaWdodF9sb2dpY2FsIChic3dhcDY0IHgpIDQ4XG5cbmxldFtAaW5saW5lIGFsd2F5c10gYnN3YXAzMiB4ID1cbiAgKCogVGhpcyBpcyBzdHJpY3RseSBiZXR0ZXIgdGhhbiBjb2VyY2luZyB0byBhbiBpbnQzMiB0byBwZXJmb3JtIGJ5dGVzd2FwLiBDb2VyY2luZ1xuICAgICBmcm9tIGFuIGludDMyIHdpbGwgYWRkIHVubmVjZXNzYXJ5IHNoaWZ0IG9wZXJhdGlvbnMgdG8gc2lnbiBleHRlbmQgdGhlIG51bWJlclxuICAgICBhcHByb3ByaWF0ZWx5LlxuICAqKVxuICBDYW1sLkludDY0LnNoaWZ0X3JpZ2h0X2xvZ2ljYWwgKGJzd2FwNjQgeCkgMzJcbjs7XG5cbmxldFtAaW5saW5lIGFsd2F5c10gYnN3YXA0OCB4ID0gQ2FtbC5JbnQ2NC5zaGlmdF9yaWdodF9sb2dpY2FsIChic3dhcDY0IHgpIDE2XG5cbmluY2x1ZGUgQ29tcGFyYWJsZS5XaXRoX3plcm8gKHN0cnVjdFxuICAgIGluY2x1ZGUgVFxuXG4gICAgbGV0IHplcm8gPSB6ZXJvXG4gIGVuZClcblxuKCogT3BlbiByZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgYWZ0ZXIgaW5jbHVkaW5nIGZ1bmN0b3IgaW5zdGFudGlhdGlvbnMgc28gdGhleSBkbyBub3RcbiAgIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXMgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvblxuICAgZnVuY3Rpb25zIGFyZSBhdmFpbGFibGUgd2l0aGluIHRoaXMgbW9kdWxlLiAqKVxub3BlbiBJbnQ2NF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxubGV0IGludmFyaWFudCAoXyA6IHQpID0gKClcbmxldCBiZXR3ZWVuIHQgfmxvdyB+aGlnaCA9IGxvdyA8PSB0ICYmIHQgPD0gaGlnaFxubGV0IGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heCA9IGlmIHQgPCBtaW4gdGhlbiBtaW4gZWxzZSBpZiB0IDw9IG1heCB0aGVuIHQgZWxzZSBtYXhcblxubGV0IGNsYW1wX2V4biB0IH5taW4gfm1heCA9XG4gIGFzc2VydCAobWluIDw9IG1heCk7XG4gIGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heFxuOztcblxubGV0IGNsYW1wIHQgfm1pbiB+bWF4ID1cbiAgaWYgbWluID4gbWF4XG4gIHRoZW5cbiAgICBPcl9lcnJvci5lcnJvcl9zXG4gICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICBcImNsYW1wIHJlcXVpcmVzIFttaW4gPD0gbWF4XVwiXG4gICAgICAgICBbIFwibWluXCIsIFQuc2V4cF9vZl90IG1pbjsgXCJtYXhcIiwgVC5zZXhwX29mX3QgbWF4IF0pXG4gIGVsc2UgT2sgKGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heClcbjs7XG5cbmxldCBpbmNyIHIgPSByIDo9IGFkZCAhciBvbmVcbmxldCBkZWNyIHIgPSByIDo9IHN1YiAhciBvbmVcblxuZXh0ZXJuYWwgb2ZfaW50NjQgOiB0IC0+IHQgPSBcIiVpZGVudGl0eVwiXG5cbmxldCBvZl9pbnQ2NF9leG4gPSBvZl9pbnQ2NFxubGV0IHRvX2ludDY0IHQgPSB0XG5sZXQgcG9wY291bnQgPSBQb3Bjb3VudC5pbnQ2NF9wb3Bjb3VudFxuXG5tb2R1bGUgQ29udiA9IEludF9jb252ZXJzaW9uc1xuXG5leHRlcm5hbCB0b19pbnRfdHJ1bmMgOiB0IC0+IGludCA9IFwiJWludDY0X3RvX2ludFwiXG5leHRlcm5hbCB0b19pbnQzMl90cnVuYyA6IGludDY0IC0+IGludDMyID0gXCIlaW50NjRfdG9faW50MzJcIlxuZXh0ZXJuYWwgdG9fbmF0aXZlaW50X3RydW5jIDogaW50NjQgLT4gbmF0aXZlaW50ID0gXCIlaW50NjRfdG9fbmF0aXZlaW50XCJcbmV4dGVybmFsIG9mX2ludCA6IGludCAtPiBpbnQ2NCA9IFwiJWludDY0X29mX2ludFwiXG5leHRlcm5hbCBvZl9pbnQzMiA6IGludDMyIC0+IGludDY0ID0gXCIlaW50NjRfb2ZfaW50MzJcIlxuXG5sZXQgb2ZfaW50X2V4biA9IG9mX2ludFxubGV0IHRvX2ludCA9IENvbnYuaW50NjRfdG9faW50XG5sZXQgdG9faW50X2V4biA9IENvbnYuaW50NjRfdG9faW50X2V4blxubGV0IG9mX2ludDMyX2V4biA9IG9mX2ludDMyXG5sZXQgdG9faW50MzIgPSBDb252LmludDY0X3RvX2ludDMyXG5sZXQgdG9faW50MzJfZXhuID0gQ29udi5pbnQ2NF90b19pbnQzMl9leG5cbmxldCBvZl9uYXRpdmVpbnQgPSBDb252Lm5hdGl2ZWludF90b19pbnQ2NFxubGV0IG9mX25hdGl2ZWludF9leG4gPSBvZl9uYXRpdmVpbnRcbmxldCB0b19uYXRpdmVpbnQgPSBDb252LmludDY0X3RvX25hdGl2ZWludFxubGV0IHRvX25hdGl2ZWludF9leG4gPSBDb252LmludDY0X3RvX25hdGl2ZWludF9leG5cblxubW9kdWxlIFBvdzIgPSBzdHJ1Y3RcbiAgb3BlbiEgSW1wb3J0XG4gIG9wZW4gSW50NjRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbiAgbGV0IHJhaXNlX3MgPSBFcnJvci5yYWlzZV9zXG5cbiAgbGV0IG5vbl9wb3NpdGl2ZV9hcmd1bWVudCAoKSA9XG4gICAgUHJpbnRmLmludmFsaWRfYXJnZiBcImFyZ3VtZW50IG11c3QgYmUgc3RyaWN0bHkgcG9zaXRpdmVcIiAoKVxuICA7O1xuXG4gIGxldCAoIGxvciApID0gQ2FtbC5JbnQ2NC5sb2dvclxuICBsZXQgKCBsc3IgKSA9IENhbWwuSW50NjQuc2hpZnRfcmlnaHRfbG9naWNhbFxuICBsZXQgKCBsYW5kICkgPSBDYW1sLkludDY0LmxvZ2FuZFxuXG4gICgqKiBcImNlaWxpbmcgcG93ZXIgb2YgMlwiIC0gTGVhc3QgcG93ZXIgb2YgMiBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8geC4gKilcbiAgbGV0IGNlaWxfcG93MiB4ID1cbiAgICBpZiB4IDw9IENhbWwuSW50NjQuemVybyB0aGVuIG5vbl9wb3NpdGl2ZV9hcmd1bWVudCAoKTtcbiAgICBsZXQgeCA9IENhbWwuSW50NjQucHJlZCB4IGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMSkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAyKSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDQpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgOCkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAxNikgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAzMikgaW5cbiAgICBDYW1sLkludDY0LnN1Y2MgeFxuICA7O1xuXG4gICgqKiBcImZsb29yIHBvd2VyIG9mIDJcIiAtIExhcmdlc3QgcG93ZXIgb2YgMiBsZXNzIHRoYW4gb3IgZXF1YWwgdG8geC4gKilcbiAgbGV0IGZsb29yX3BvdzIgeCA9XG4gICAgaWYgeCA8PSBDYW1sLkludDY0Lnplcm8gdGhlbiBub25fcG9zaXRpdmVfYXJndW1lbnQgKCk7XG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMSkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAyKSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDQpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgOCkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAxNikgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAzMikgaW5cbiAgICBDYW1sLkludDY0LnN1YiB4ICh4IGxzciAxKVxuICA7O1xuXG4gIGxldCBpc19wb3cyIHggPVxuICAgIGlmIHggPD0gQ2FtbC5JbnQ2NC56ZXJvIHRoZW4gbm9uX3Bvc2l0aXZlX2FyZ3VtZW50ICgpO1xuICAgIHggbGFuZCBDYW1sLkludDY0LnByZWQgeCA9IENhbWwuSW50NjQuemVyb1xuICA7O1xuXG4gICgqIEMgc3R1YnMgZm9yIGludCBjbHogYW5kIGN0eiB0byB1c2UgdGhlIENMWi9CU1IvQ1RaL0JTRiBpbnN0cnVjdGlvbiB3aGVyZSBwb3NzaWJsZSAqKVxuICBleHRlcm5hbCBjbHpcbiAgICA6ICAoaW50NjRbQHVuYm94ZWRdKVxuICAgIC0+IChpbnRbQHVudGFnZ2VkXSlcbiAgICA9IFwiQmFzZV9pbnRfbWF0aF9pbnQ2NF9jbHpcIiBcIkJhc2VfaW50X21hdGhfaW50NjRfY2x6X3VuYm94ZWRcIlxuICBbQEBub2FsbG9jXVxuXG4gIGV4dGVybmFsIGN0elxuICAgIDogIChpbnQ2NFtAdW5ib3hlZF0pXG4gICAgLT4gKGludFtAdW50YWdnZWRdKVxuICAgID0gXCJCYXNlX2ludF9tYXRoX2ludDY0X2N0elwiIFwiQmFzZV9pbnRfbWF0aF9pbnQ2NF9jdHpfdW5ib3hlZFwiXG4gIFtAQG5vYWxsb2NdXG5cbiAgKCoqIEhhY2tlcidzIERlbGlnaHQgU2Vjb25kIEVkaXRpb24gcDEwNiAqKVxuICBsZXQgZmxvb3JfbG9nMiBpID1cbiAgICBpZiBpIDw9IENhbWwuSW50NjQuemVyb1xuICAgIHRoZW5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgKFNleHAubWVzc2FnZSBcIltJbnQ2NC5mbG9vcl9sb2cyXSBnb3QgaW52YWxpZCBpbnB1dFwiIFsgXCJcIiwgc2V4cF9vZl9pbnQ2NCBpIF0pO1xuICAgIG51bV9iaXRzIC0gMSAtIGNseiBpXG4gIDs7XG5cbiAgKCoqIEhhY2tlcidzIERlbGlnaHQgU2Vjb25kIEVkaXRpb24gcDEwNiAqKVxuICBsZXQgY2VpbF9sb2cyIGkgPVxuICAgIGlmIFBvbHkuKCA8PSApIGkgQ2FtbC5JbnQ2NC56ZXJvXG4gICAgdGhlblxuICAgICAgcmFpc2VfcyAoU2V4cC5tZXNzYWdlIFwiW0ludDY0LmNlaWxfbG9nMl0gZ290IGludmFsaWQgaW5wdXRcIiBbIFwiXCIsIHNleHBfb2ZfaW50NjQgaSBdKTtcbiAgICBpZiBDYW1sLkludDY0LmVxdWFsIGkgQ2FtbC5JbnQ2NC5vbmUgdGhlbiAwIGVsc2UgbnVtX2JpdHMgLSBjbHogKENhbWwuSW50NjQucHJlZCBpKVxuICA7O1xuZW5kXG5cbmluY2x1ZGUgUG93MlxuaW5jbHVkZSBDb252Lk1ha2UgKFQpXG5cbmluY2x1ZGUgQ29udi5NYWtlX2hleCAoc3RydWN0XG4gICAgdHlwZSB0ID0gaW50NjQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGhhc2hdXG5cbiAgICBsZXQgY29tcGFyZSA9IChjb21wYXJlX2ludDY0IDogdCAtPiB0IC0+IGludClcblxuICAgIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICAgIGhhc2hfZm9sZF9pbnQ2NFxuXG4gICAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgICAgbGV0IGZ1bmMgPSBoYXNoX2ludDY0IGluXG4gICAgICBmdW4geCAtPiBmdW5jIHhcbiAgICA7O1xuXG4gICAgW0BAQGVuZF1cblxuICAgIGxldCB6ZXJvID0gemVyb1xuICAgIGxldCBuZWcgPSBuZWdcbiAgICBsZXQgKCA8ICkgPSAoIDwgKVxuICAgIGxldCB0b19zdHJpbmcgaSA9IFByaW50Zi5zcHJpbnRmIFwiJUx4XCIgaVxuICAgIGxldCBvZl9zdHJpbmcgcyA9IENhbWwuU2NhbmYuc3NjYW5mIHMgXCIlTHhcIiBGbi5pZFxuICAgIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5JbnQ2NC5IZXhcIlxuICBlbmQpXG5cbmluY2x1ZGUgUHJldHR5X3ByaW50ZXIuUmVnaXN0ZXIgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgICBsZXQgdG9fc3RyaW5nID0gdG9fc3RyaW5nXG4gICAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLkludDY0XCJcbiAgZW5kKVxuXG5tb2R1bGUgUHJlX08gPSBzdHJ1Y3RcbiAgZXh0ZXJuYWwgKCArICkgOiB0IC0+IHQgLT4gdCA9IFwiJWludDY0X2FkZFwiXG4gIGV4dGVybmFsICggLSApIDogdCAtPiB0IC0+IHQgPSBcIiVpbnQ2NF9zdWJcIlxuICBleHRlcm5hbCAoICogKSA6IHQgLT4gdCAtPiB0ID0gXCIlaW50NjRfbXVsXCJcbiAgZXh0ZXJuYWwgKCAvICkgOiB0IC0+IHQgLT4gdCA9IFwiJWludDY0X2RpdlwiXG4gIGV4dGVybmFsICggfi0gKSA6IHQgLT4gdCA9IFwiJWludDY0X25lZ1wiXG5cbiAgbGV0ICggKiogKSA9ICggKiogKVxuXG4gIGluY2x1ZGUgSW50NjRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbiAgbGV0IGFicyA9IGFic1xuXG4gIGV4dGVybmFsIG5lZyA6IHQgLT4gdCA9IFwiJWludDY0X25lZ1wiXG5cbiAgbGV0IHplcm8gPSB6ZXJvXG4gIGxldCBvZl9pbnRfZXhuID0gb2ZfaW50X2V4blxuZW5kXG5cbm1vZHVsZSBPID0gc3RydWN0XG4gIGluY2x1ZGUgUHJlX09cblxuICBpbmNsdWRlIEludF9tYXRoLk1ha2UgKHN0cnVjdFxuICAgICAgdHlwZSBub25yZWMgdCA9IHRcblxuICAgICAgaW5jbHVkZSBQcmVfT1xuXG4gICAgICBsZXQgcmVtID0gcmVtXG4gICAgICBsZXQgdG9fZmxvYXQgPSB0b19mbG9hdFxuICAgICAgbGV0IG9mX2Zsb2F0ID0gb2ZfZmxvYXRcbiAgICAgIGxldCBvZl9zdHJpbmcgPSBULm9mX3N0cmluZ1xuICAgICAgbGV0IHRvX3N0cmluZyA9IFQudG9fc3RyaW5nXG4gICAgZW5kKVxuXG4gIGV4dGVybmFsICggbGFuZCApIDogdCAtPiB0IC0+IHQgPSBcIiVpbnQ2NF9hbmRcIlxuICBleHRlcm5hbCAoIGxvciApIDogdCAtPiB0IC0+IHQgPSBcIiVpbnQ2NF9vclwiXG4gIGV4dGVybmFsICggbHhvciApIDogdCAtPiB0IC0+IHQgPSBcIiVpbnQ2NF94b3JcIlxuXG4gIGxldCBsbm90ID0gYml0X25vdFxuXG4gIGV4dGVybmFsICggbHNsICkgOiB0IC0+IGludCAtPiB0ID0gXCIlaW50NjRfbHNsXCJcbiAgZXh0ZXJuYWwgKCBhc3IgKSA6IHQgLT4gaW50IC0+IHQgPSBcIiVpbnQ2NF9hc3JcIlxuICBleHRlcm5hbCAoIGxzciApIDogdCAtPiBpbnQgLT4gdCA9IFwiJWludDY0X2xzclwiXG5lbmRcblxuaW5jbHVkZSBPXG5cbigqIFtJbnQ2NF0gYW5kIFtJbnQ2NC5PXSBhZ3JlZSB2YWx1ZS13aXNlICopXG5cbigqIEluY2x1ZGUgdHlwZS1zcGVjaWZpYyBbUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXSBhdCB0aGUgZW5kLCBhZnRlclxuICAgaW5jbHVkaW5nIGZ1bmN0b3IgYXBwbGljYXRpb24gdGhhdCBjb3VsZCBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzXG4gICBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9ucyBhcmUgZXhwb3J0ZWQgYnlcbiAgIHRoaXMgbW9kdWxlLiAqKVxuaW5jbHVkZSBJbnQ2NF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcbiIsIigqIEEgNjNiaXQgaW50ZWdlciBpcyBhIDY0Yml0IGludGVnZXIgd2l0aCBpdHMgYml0cyBzaGlmdGVkIHRvIHRoZSBsZWZ0XG4gICBhbmQgaXRzIGxvd2VzdCBiaXQgc2V0IHRvIDAuXG4gICBUaGlzIGlzIHRoZSBzYW1lIGtpbmQgb2YgZW5jb2RpbmcgYXMgT0NhbWwgaW50IG9uIDY0Yml0IGFyY2hpdGVjdHVyZS5cbiAgIFRoZSBvbmx5IGRpZmZlcmVuY2UgYmVpbmcgdGhlIGxvd2VzdCBiaXQgKGltbWVkaWF0ZSBiaXQpIHNldCB0byAxLiAqKVxuXG5vcGVuISBJbXBvcnRcbmluY2x1ZGUgSW50NjRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cblxubW9kdWxlIFQwID0gc3RydWN0XG4gIG1vZHVsZSBUID0gc3RydWN0XG4gICAgdHlwZSB0ID0gaW50NjQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICAgIGxldCBjb21wYXJlID0gKGNvbXBhcmVfaW50NjQgOiB0IC0+IHQgLT4gaW50KVxuXG4gICAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgICAgaGFzaF9mb2xkX2ludDY0XG5cbiAgICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgICBsZXQgZnVuYyA9IGhhc2hfaW50NjQgaW5cbiAgICAgIGZ1biB4IC0+IGZ1bmMgeFxuICAgIDs7XG5cbiAgICBsZXQgdF9vZl9zZXhwID0gKGludDY0X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdClcbiAgICBsZXQgc2V4cF9vZl90ID0gKHNleHBfb2ZfaW50NjQgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBpbnQ2NF9zZXhwX2dyYW1tYXJcblxuICAgIFtAQEBlbmRdXG5cbiAgICBsZXQgaGFzaGFibGUgOiB0IEhhc2hhYmxlLnQgPSB7IGhhc2g7IGNvbXBhcmU7IHNleHBfb2ZfdCB9XG4gIGVuZFxuXG4gIGluY2x1ZGUgVFxuICBpbmNsdWRlIENvbXBhcmF0b3IuTWFrZSAoVClcbmVuZFxuXG5tb2R1bGUgQ29udiA9IEludF9jb252ZXJzaW9uc1xuXG5tb2R1bGUgVyA6IHNpZ1xuXG4gIGluY2x1ZGUgbW9kdWxlIHR5cGUgb2Ygc3RydWN0XG4gICAgaW5jbHVkZSBUMFxuICBlbmRcblxuICB0eXBlIHQgPSBpbnQ2NFxuXG4gIHZhbCB3cmFwX2V4biA6IENhbWwuSW50NjQudCAtPiB0XG4gIHZhbCB3cmFwX21vZHVsbyA6IENhbWwuSW50NjQudCAtPiB0XG4gIHZhbCB1bndyYXAgOiB0IC0+IENhbWwuSW50NjQudFxuXG4gICgqKiBSZXR1cm5zIGEgbm9uLW5lZ2F0aXZlIGludDY0IHRoYXQgaXMgZXF1YWwgdG8gdGhlIGlucHV0IGludDYzIG1vZHVsbyAyXjYzLiAqKVxuICB2YWwgdW53cmFwX3Vuc2lnbmVkIDogdCAtPiBDYW1sLkludDY0LnRcblxuICB2YWwgaW52YXJpYW50IDogdCAtPiB1bml0XG4gIHZhbCBhZGQgOiB0IC0+IHQgLT4gdFxuICB2YWwgc3ViIDogdCAtPiB0IC0+IHRcbiAgdmFsIG5lZyA6IHQgLT4gdFxuICB2YWwgYWJzIDogdCAtPiB0XG4gIHZhbCBzdWNjIDogdCAtPiB0XG4gIHZhbCBwcmVkIDogdCAtPiB0XG4gIHZhbCBtdWwgOiB0IC0+IHQgLT4gdFxuICB2YWwgcG93IDogdCAtPiB0IC0+IHRcbiAgdmFsIGRpdiA6IHQgLT4gdCAtPiB0XG4gIHZhbCByZW0gOiB0IC0+IHQgLT4gdFxuICB2YWwgcG9wY291bnQgOiB0IC0+IGludFxuICB2YWwgYml0X25vdCA6IHQgLT4gdFxuICB2YWwgYml0X3hvciA6IHQgLT4gdCAtPiB0XG4gIHZhbCBiaXRfb3IgOiB0IC0+IHQgLT4gdFxuICB2YWwgYml0X2FuZCA6IHQgLT4gdCAtPiB0XG4gIHZhbCBzaGlmdF9sZWZ0IDogdCAtPiBpbnQgLT4gdFxuICB2YWwgc2hpZnRfcmlnaHQgOiB0IC0+IGludCAtPiB0XG4gIHZhbCBzaGlmdF9yaWdodF9sb2dpY2FsIDogdCAtPiBpbnQgLT4gdFxuICB2YWwgbWluX3ZhbHVlIDogdFxuICB2YWwgbWF4X3ZhbHVlIDogdFxuICB2YWwgdG9faW50NjQgOiB0IC0+IENhbWwuSW50NjQudFxuICB2YWwgb2ZfaW50NjQgOiBDYW1sLkludDY0LnQgLT4gdCBvcHRpb25cbiAgdmFsIG9mX2ludDY0X2V4biA6IENhbWwuSW50NjQudCAtPiB0XG4gIHZhbCBvZl9pbnQ2NF90cnVuYyA6IENhbWwuSW50NjQudCAtPiB0XG4gIHZhbCBjb21wYXJlIDogdCAtPiB0IC0+IGludFxuICB2YWwgY2VpbF9wb3cyIDogdCAtPiB0XG4gIHZhbCBmbG9vcl9wb3cyIDogdCAtPiB0XG4gIHZhbCBjZWlsX2xvZzIgOiB0IC0+IGludFxuICB2YWwgZmxvb3JfbG9nMiA6IHQgLT4gaW50XG4gIHZhbCBpc19wb3cyIDogdCAtPiBib29sXG4gIHZhbCBjbHogOiB0IC0+IGludFxuICB2YWwgY3R6IDogdCAtPiBpbnRcbmVuZCA9IHN0cnVjdFxuICBpbmNsdWRlIFQwXG5cbiAgdHlwZSB0ID0gaW50NjRcblxuICBsZXQgd3JhcF9leG4geCA9XG4gICAgKCogUmFpc2VzIGlmIHRoZSBpbnQ2NCB2YWx1ZSBkb2VzIG5vdCBmaXQgb24gaW50NjMuICopXG4gICAgQ29udi5pbnQ2NF9maXRfb25faW50NjNfZXhuIHg7XG4gICAgQ2FtbC5JbnQ2NC5tdWwgeCAyTFxuICA7O1xuXG4gIGxldCB3cmFwIHggPVxuICAgIGlmIENvbnYuaW50NjRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQ2MyB4IHRoZW4gU29tZSAoQ2FtbC5JbnQ2NC5tdWwgeCAyTCkgZWxzZSBOb25lXG4gIDs7XG5cbiAgbGV0IHdyYXBfbW9kdWxvIHggPSBDYW1sLkludDY0Lm11bCB4IDJMXG4gIGxldCB1bndyYXAgeCA9IENhbWwuSW50NjQuc2hpZnRfcmlnaHQgeCAxXG4gIGxldCB1bndyYXBfdW5zaWduZWQgeCA9IENhbWwuSW50NjQuc2hpZnRfcmlnaHRfbG9naWNhbCB4IDFcblxuICAoKiBUaGlzIGRvZXMgbm90IHVzZSB3cmFwIG9yIHVud3JhcCB0byBhdm9pZCBnZW5lcmF0aW5nIGV4Y2VwdGlvbnMgaW4gdGhlIGNhc2Ugb2ZcbiAgICAgb3ZlcmZsb3dzLiBUaGlzIGlzIHRvIHByZXNlcnZlIHRoZSBzZW1hbnRpY3Mgb2YgaW50IHR5cGUgb24gNjQgYml0IGFyY2hpdGVjdHVyZS4gKilcbiAgbGV0IGYyIGYgYSBiID1cbiAgICBDYW1sLkludDY0Lm11bCAoZiAoQ2FtbC5JbnQ2NC5zaGlmdF9yaWdodCBhIDEpIChDYW1sLkludDY0LnNoaWZ0X3JpZ2h0IGIgMSkpIDJMXG4gIDs7XG5cbiAgbGV0IG1hc2sgPSAweGZmZmZfZmZmZl9mZmZmX2ZmZmVMXG4gIGxldCBtIHggPSBDYW1sLkludDY0LmxvZ2FuZCB4IG1hc2tcbiAgbGV0IGludmFyaWFudCB0ID0gYXNzZXJ0IChtIHQgPSB0KVxuICBsZXQgYWRkIHggeSA9IENhbWwuSW50NjQuYWRkIHggeVxuICBsZXQgc3ViIHggeSA9IENhbWwuSW50NjQuc3ViIHggeVxuICBsZXQgbmVnIHggPSBDYW1sLkludDY0Lm5lZyB4XG4gIGxldCBhYnMgeCA9IENhbWwuSW50NjQuYWJzIHhcbiAgbGV0IG9uZSA9IHdyYXBfZXhuIDFMXG4gIGxldCBzdWNjIGEgPSBhZGQgYSBvbmVcbiAgbGV0IHByZWQgYSA9IHN1YiBhIG9uZVxuICBsZXQgbWluX3ZhbHVlID0gbSBDYW1sLkludDY0Lm1pbl9pbnRcbiAgbGV0IG1heF92YWx1ZSA9IG0gQ2FtbC5JbnQ2NC5tYXhfaW50XG4gIGxldCBiaXRfbm90IHggPSBtIChDYW1sLkludDY0LmxvZ25vdCB4KVxuICBsZXQgYml0X2FuZCA9IENhbWwuSW50NjQubG9nYW5kXG4gIGxldCBiaXRfeG9yID0gQ2FtbC5JbnQ2NC5sb2d4b3JcbiAgbGV0IGJpdF9vciA9IENhbWwuSW50NjQubG9nb3JcbiAgbGV0IHNoaWZ0X2xlZnQgeCBpID0gQ2FtbC5JbnQ2NC5zaGlmdF9sZWZ0IHggaVxuICBsZXQgc2hpZnRfcmlnaHQgeCBpID0gbSAoQ2FtbC5JbnQ2NC5zaGlmdF9yaWdodCB4IGkpXG4gIGxldCBzaGlmdF9yaWdodF9sb2dpY2FsIHggaSA9IG0gKENhbWwuSW50NjQuc2hpZnRfcmlnaHRfbG9naWNhbCB4IGkpXG4gIGxldCBwb3cgPSBmMiBJbnRfbWF0aC5Qcml2YXRlLmludDYzX3Bvd19vbl9pbnQ2NFxuICBsZXQgbXVsIGEgYiA9IENhbWwuSW50NjQubXVsIGEgKENhbWwuSW50NjQuc2hpZnRfcmlnaHQgYiAxKVxuICBsZXQgZGl2IGEgYiA9IHdyYXBfbW9kdWxvIChDYW1sLkludDY0LmRpdiBhIGIpXG4gIGxldCByZW0gYSBiID0gQ2FtbC5JbnQ2NC5yZW0gYSBiXG4gIGxldCBwb3Bjb3VudCB4ID0gUG9wY291bnQuaW50NjRfcG9wY291bnQgeFxuICBsZXQgdG9faW50NjQgdCA9IHVud3JhcCB0XG4gIGxldCBvZl9pbnQ2NCB0ID0gd3JhcCB0XG4gIGxldCBvZl9pbnQ2NF9leG4gdCA9IHdyYXBfZXhuIHRcbiAgbGV0IG9mX2ludDY0X3RydW5jIHQgPSB3cmFwX21vZHVsbyB0XG4gIGxldCB0X29mX3NleHAgeCA9IHdyYXBfZXhuIChpbnQ2NF9vZl9zZXhwIHgpXG4gIGxldCBzZXhwX29mX3QgeCA9IHNleHBfb2ZfaW50NjQgKHVud3JhcCB4KVxuICBsZXQgY29tcGFyZSAoeCA6IHQpIHkgPSBjb21wYXJlIHggeVxuICBsZXQgaXNfcG93MiB4ID0gSW50NjQuaXNfcG93MiAodW53cmFwIHgpXG5cbiAgbGV0IGNseiB4ID1cbiAgICAoKiBXZSBydW4gSW50NjQuY2x6IGRpcmVjdGx5IG9uIHRoZSB3cmFwcGVkIGludDYzIHZhbHVlLiBUaGlzIGlzIGNvcnJlY3QgYmVjYXVzZSB0aGVcbiAgICAgICBiaXRzIG9mIHRoZSBpbnQ2M19lbXVsIGFyZSBsZWZ0LWFsaWduZWQgaW4gdGhlIEludDY0LiAqKVxuICAgIEludDY0LmNseiB4XG4gIDs7XG5cbiAgbGV0IGN0eiB4ID0gSW50NjQuY3R6ICh1bndyYXAgeClcbiAgbGV0IGZsb29yX3BvdzIgeCA9IEludDY0LmZsb29yX3BvdzIgKHVud3JhcCB4KSB8PiB3cmFwX2V4blxuICBsZXQgY2VpbF9wb3cyIHggPSBJbnQ2NC5mbG9vcl9wb3cyICh1bndyYXAgeCkgfD4gd3JhcF9leG5cbiAgbGV0IGZsb29yX2xvZzIgeCA9IEludDY0LmZsb29yX2xvZzIgKHVud3JhcCB4KVxuICBsZXQgY2VpbF9sb2cyIHggPSBJbnQ2NC5jZWlsX2xvZzIgKHVud3JhcCB4KVxuZW5kXG5cbm9wZW4gV1xuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICB0eXBlIHQgPSBXLnQgW0BAZGVyaXZpbmdfaW5saW5lIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgVy5oYXNoX2ZvbGRfdFxuXG4gIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IFcuaGFzaCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCB0X29mX3NleHAgPSAoVy50X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdClcbiAgbGV0IHNleHBfb2ZfdCA9IChXLnNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBXLnRfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA9IFcuY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgbGV0IGNvbXBhcmF0b3IgPSBXLmNvbXBhcmF0b3JcbiAgbGV0IGNvbXBhcmUgPSBXLmNvbXBhcmVcbiAgbGV0IGludmFyaWFudCA9IFcuaW52YXJpYW50XG5cbiAgKCogV2UgZG9uJ3QgZXhwZWN0IFtoYXNoXSB0byBmb2xsb3cgdGhlIGJlaGF2aW9yIG9mIGludCBpbiA2NGJpdCBhcmNoaXRlY3R1cmUgKilcbiAgbGV0IF8gPSBoYXNoXG4gIGxldCBoYXNoICh4IDogdCkgPSBDYW1sLkhhc2h0YmwuaGFzaCB4XG4gIGxldCBoYXNoYWJsZSA6IHQgSGFzaGFibGUudCA9IHsgaGFzaDsgY29tcGFyZTsgc2V4cF9vZl90IH1cbiAgbGV0IGludmFsaWRfc3RyIHggPSBQcmludGYuZmFpbHdpdGhmIFwiSW50NjMub2Zfc3RyaW5nOiBpbnZhbGlkIGlucHV0ICVTXCIgeCAoKVxuXG4gICgqXG4gICAgIFwic2lnblwiIHJlZmVycyB0byB3aGV0aGVyIHRoZSBudW1iZXIgc3RhcnRzIHdpdGggYSAnLSdcbiAgICAgXCJzaWduZWRuZXNzID0gZmFsc2VcIiBtZWFucyB0aGUgcmVzdCBvZiB0aGUgbnVtYmVyIGlzIHBhcnNlZCBhcyB1bnNpZ25lZCBhbmQgdGhlbiBjYXN0XG4gICAgIHRvIHNpZ25lZCB3aXRoIHdyYXAtYXJvdW5kIG1vZHVsbyAyXmlcbiAgICAgXCJzaWduZWRuZXNzID0gdHJ1ZVwiIG1lYW5zIG5vIHN1Y2ggY3JhemluZXNzIGhhcHBlbnNcblxuICAgICBUaGUgdGVybWlub2xvZ3kgYW5kIHRoZSBsb2dpYyBpcyBkdWUgdG8gdGhlIGNvZGUgaW4gYnl0ZXJ1bi9pbnRzLmMgaW4gb2NhbWwgNC4wM1xuICAgICAoW3BhcnNlX3NpZ25fYW5kX2Jhc2VdIGZ1bmN0aW9uKS5cblxuICAgICBTaWduZWRuZXNzIGVxdWFscyB0cnVlIGZvciBwbGFpbiBkZWNpbWFsIG51bWJlciAoZS5nLiAxMjM1LCAtNjc4OSlcblxuICAgICBTaWduZWRuZXNzIGVxdWFscyBmYWxzZSBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxuICAgICAtIFsweGZmZmZdLCBbLTB4ZmZmZl0gKGhleGFkZWNpbWFsIHJlcHJlc2VudGF0aW9uKVxuICAgICAtIFswYjAxMDFdLCBbLTBiMDEwMV0gKGJpbmFyeSByZXByZXNlbnRhdGlvbilcbiAgICAgLSBbMG8xMjM3XSwgWy0wbzEyMzddIChvY3RhbCByZXByZXNlbnRhdGlvbilcbiAgICAgLSBbMHU5ODEyXSwgWy0wdTk4MTJdICh1bnNpZ25lZCBkZWNpbWFsIHJlcHJlc2VudGF0aW9uIC0gYXZhaWxhYmxlIGZyb20gT0NhbWwgNC4wMykgKilcbiAgbGV0IHNpZ25fYW5kX3NpZ25lZG5lc3MgeCA9XG4gICAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggeCBpblxuICAgIGxldCBvcGVuIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgaW5cbiAgICBsZXQgcG9zLCBzaWduID1cbiAgICAgIGlmIDAgPCBsZW5cbiAgICAgIHRoZW4gKFxuICAgICAgICBtYXRjaCB4LlswXSB3aXRoXG4gICAgICAgIHwgJy0nIC0+IDEsIGBOZWdcbiAgICAgICAgfCAnKycgLT4gMSwgYFBvc1xuICAgICAgICB8IF8gLT4gMCwgYFBvcylcbiAgICAgIGVsc2UgMCwgYFBvc1xuICAgIGluXG4gICAgaWYgcG9zICsgMiA8IGxlblxuICAgIHRoZW4gKFxuICAgICAgbGV0IGMxID0geC5bcG9zXSBpblxuICAgICAgbGV0IGMyID0geC5bcG9zICsgMV0gaW5cbiAgICAgIG1hdGNoIGMxLCBjMiB3aXRoXG4gICAgICB8ICcwJywgJzAnIC4uICc5JyAtPiBzaWduLCB0cnVlXG4gICAgICB8ICcwJywgXyAtPiBzaWduLCBmYWxzZVxuICAgICAgfCBfIC0+IHNpZ24sIHRydWUpXG4gICAgZWxzZSBzaWduLCB0cnVlXG4gIDs7XG5cbiAgbGV0IHRvX3N0cmluZyB4ID0gQ2FtbC5JbnQ2NC50b19zdHJpbmcgKHVud3JhcCB4KVxuXG4gIGxldCBvZl9zdHJpbmcgc3RyID1cbiAgICB0cnlcbiAgICAgIGxldCBzaWduLCBzaWduZWRuZXNzID0gc2lnbl9hbmRfc2lnbmVkbmVzcyBzdHIgaW5cbiAgICAgIGlmIHNpZ25lZG5lc3NcbiAgICAgIHRoZW4gb2ZfaW50NjRfZXhuIChDYW1sLkludDY0Lm9mX3N0cmluZyBzdHIpXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IHBvc19zdHIgPVxuICAgICAgICAgIG1hdGNoIHNpZ24gd2l0aFxuICAgICAgICAgIHwgYE5lZyAtPiBTdHJpbmcuc3ViIHN0ciB+cG9zOjEgfmxlbjooU3RyaW5nLmxlbmd0aCBzdHIgLSAxKVxuICAgICAgICAgIHwgYFBvcyAtPiBzdHJcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IGludDY0ID0gQ2FtbC5JbnQ2NC5vZl9zdHJpbmcgcG9zX3N0ciBpblxuICAgICAgICAoKiB1bnNpZ25lZCA2My1iaXQgaW50IG11c3QgcGFyc2UgYXMgYSBwb3NpdGl2ZSBzaWduZWQgNjQtYml0IGludCAqKVxuICAgICAgICBpZiBJbnQ2NF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA8ICkgaW50NjQgMEwgdGhlbiBpbnZhbGlkX3N0ciBzdHI7XG4gICAgICAgIGxldCBpbnQ2MyA9IHdyYXBfbW9kdWxvIGludDY0IGluXG4gICAgICAgIG1hdGNoIHNpZ24gd2l0aFxuICAgICAgICB8IGBOZWcgLT4gbmVnIGludDYzXG4gICAgICAgIHwgYFBvcyAtPiBpbnQ2MylcbiAgICB3aXRoXG4gICAgfCBfIC0+IGludmFsaWRfc3RyIHN0clxuICA7O1xuXG4gIGxldCBic3dhcDE2IHQgPSB3cmFwX21vZHVsbyAoSW50NjQuYnN3YXAxNiAodW53cmFwIHQpKVxuICBsZXQgYnN3YXAzMiB0ID0gd3JhcF9tb2R1bG8gKEludDY0LmJzd2FwMzIgKHVud3JhcCB0KSlcbiAgbGV0IGJzd2FwNDggdCA9IHdyYXBfbW9kdWxvIChJbnQ2NC5ic3dhcDQ4ICh1bndyYXAgdCkpXG5lbmRcblxuaW5jbHVkZSBUXG5cbmxldCBudW1fYml0cyA9IDYzXG5sZXQgZmxvYXRfbG93ZXJfYm91bmQgPSBGbG9hdDAubG93ZXJfYm91bmRfZm9yX2ludCBudW1fYml0c1xubGV0IGZsb2F0X3VwcGVyX2JvdW5kID0gRmxvYXQwLnVwcGVyX2JvdW5kX2Zvcl9pbnQgbnVtX2JpdHNcbmxldCBzaGlmdF9yaWdodF9sb2dpY2FsID0gc2hpZnRfcmlnaHRfbG9naWNhbFxubGV0IHNoaWZ0X3JpZ2h0ID0gc2hpZnRfcmlnaHRcbmxldCBzaGlmdF9sZWZ0ID0gc2hpZnRfbGVmdFxubGV0IGJpdF9ub3QgPSBiaXRfbm90XG5sZXQgYml0X3hvciA9IGJpdF94b3JcbmxldCBiaXRfb3IgPSBiaXRfb3JcbmxldCBiaXRfYW5kID0gYml0X2FuZFxubGV0IHBvcGNvdW50ID0gcG9wY291bnRcbmxldCBhYnMgPSBhYnNcbmxldCBwcmVkID0gcHJlZFxubGV0IHN1Y2MgPSBzdWNjXG5sZXQgcG93ID0gcG93XG5sZXQgcmVtID0gcmVtXG5sZXQgbmVnID0gbmVnXG5sZXQgbWF4X3ZhbHVlID0gbWF4X3ZhbHVlXG5sZXQgbWluX3ZhbHVlID0gbWluX3ZhbHVlXG5sZXQgbWludXNfb25lID0gd3JhcF9leG4gQ2FtbC5JbnQ2NC5taW51c19vbmVcbmxldCBvbmUgPSB3cmFwX2V4biBDYW1sLkludDY0Lm9uZVxubGV0IHplcm8gPSB3cmFwX2V4biBDYW1sLkludDY0Lnplcm9cbmxldCBpc19wb3cyID0gaXNfcG93MlxubGV0IGZsb29yX3BvdzIgPSBmbG9vcl9wb3cyXG5sZXQgY2VpbF9wb3cyID0gY2VpbF9wb3cyXG5sZXQgZmxvb3JfbG9nMiA9IGZsb29yX2xvZzJcbmxldCBjZWlsX2xvZzIgPSBjZWlsX2xvZzJcbmxldCBjbHogPSBjbHpcbmxldCBjdHogPSBjdHpcbmxldCB0b19mbG9hdCB4ID0gQ2FtbC5JbnQ2NC50b19mbG9hdCAodW53cmFwIHgpXG5sZXQgb2ZfZmxvYXRfdW5jaGVja2VkIHggPSB3cmFwX21vZHVsbyAoQ2FtbC5JbnQ2NC5vZl9mbG9hdCB4KVxuXG5sZXQgb2ZfZmxvYXQgdCA9XG4gIGxldCBvcGVuIEZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBpblxuICBpZiB0ID49IGZsb2F0X2xvd2VyX2JvdW5kICYmIHQgPD0gZmxvYXRfdXBwZXJfYm91bmRcbiAgdGhlbiB3cmFwX21vZHVsbyAoQ2FtbC5JbnQ2NC5vZl9mbG9hdCB0KVxuICBlbHNlXG4gICAgUHJpbnRmLmludmFsaWRfYXJnZlxuICAgICAgXCJJbnQ2My5vZl9mbG9hdDogYXJndW1lbnQgKCVmKSBpcyBvdXQgb2YgcmFuZ2Ugb3IgTmFOXCJcbiAgICAgIChGbG9hdDAuYm94IHQpXG4gICAgICAoKVxuOztcblxubGV0IG9mX2ludDY0ID0gb2ZfaW50NjRcbmxldCBvZl9pbnQ2NF9leG4gPSBvZl9pbnQ2NF9leG5cbmxldCBvZl9pbnQ2NF90cnVuYyA9IG9mX2ludDY0X3RydW5jXG5sZXQgdG9faW50NjQgPSB0b19pbnQ2NFxuXG5pbmNsdWRlIENvbXBhcmFibGUuV2l0aF96ZXJvIChzdHJ1Y3RcbiAgICBpbmNsdWRlIFRcblxuICAgIGxldCB6ZXJvID0gemVyb1xuICBlbmQpXG5cbmxldCBiZXR3ZWVuIHQgfmxvdyB+aGlnaCA9IGxvdyA8PSB0ICYmIHQgPD0gaGlnaFxubGV0IGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heCA9IGlmIHQgPCBtaW4gdGhlbiBtaW4gZWxzZSBpZiB0IDw9IG1heCB0aGVuIHQgZWxzZSBtYXhcblxubGV0IGNsYW1wX2V4biB0IH5taW4gfm1heCA9XG4gIGFzc2VydCAobWluIDw9IG1heCk7XG4gIGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heFxuOztcblxubGV0IGNsYW1wIHQgfm1pbiB+bWF4ID1cbiAgaWYgbWluID4gbWF4XG4gIHRoZW5cbiAgICBPcl9lcnJvci5lcnJvcl9zXG4gICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICBcImNsYW1wIHJlcXVpcmVzIFttaW4gPD0gbWF4XVwiXG4gICAgICAgICBbIFwibWluXCIsIFQuc2V4cF9vZl90IG1pbjsgXCJtYXhcIiwgVC5zZXhwX29mX3QgbWF4IF0pXG4gIGVsc2UgT2sgKGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heClcbjs7XG5cbmxldCAoIC8gKSA9IGRpdlxubGV0ICggKiApID0gbXVsXG5sZXQgKCAtICkgPSBzdWJcbmxldCAoICsgKSA9IGFkZFxubGV0ICggfi0gKSA9IG5lZ1xubGV0ICggKiogKSBiIGUgPSBwb3cgYiBlXG5sZXQgaW5jciByID0gciA6PSAhciArIG9uZVxubGV0IGRlY3IgciA9IHIgOj0gIXIgLSBvbmVcblxuKCogV2UgY2FuIHJldXNlIGNvbnZlcnNpb24gZnVuY3Rpb24gZnJvbS90byBpbnQ2NCBoZXJlLiAqKVxubGV0IG9mX2ludCB4ID0gd3JhcF9leG4gKENvbnYuaW50X3RvX2ludDY0IHgpXG5sZXQgb2ZfaW50X2V4biB4ID0gb2ZfaW50IHhcbmxldCB0b19pbnQgeCA9IENvbnYuaW50NjRfdG9faW50ICh1bndyYXAgeClcbmxldCB0b19pbnRfZXhuIHggPSBDb252LmludDY0X3RvX2ludF9leG4gKHVud3JhcCB4KVxubGV0IHRvX2ludF90cnVuYyB4ID0gQ29udi5pbnQ2NF90b19pbnRfdHJ1bmMgKHVud3JhcCB4KVxubGV0IG9mX2ludDMyIHggPSB3cmFwX2V4biAoQ29udi5pbnQzMl90b19pbnQ2NCB4KVxubGV0IG9mX2ludDMyX2V4biB4ID0gb2ZfaW50MzIgeFxubGV0IHRvX2ludDMyIHggPSBDb252LmludDY0X3RvX2ludDMyICh1bndyYXAgeClcbmxldCB0b19pbnQzMl9leG4geCA9IENvbnYuaW50NjRfdG9faW50MzJfZXhuICh1bndyYXAgeClcbmxldCB0b19pbnQzMl90cnVuYyB4ID0gQ29udi5pbnQ2NF90b19pbnQzMl90cnVuYyAodW53cmFwIHgpXG5sZXQgb2ZfbmF0aXZlaW50IHggPSBvZl9pbnQ2NCAoQ29udi5uYXRpdmVpbnRfdG9faW50NjQgeClcbmxldCBvZl9uYXRpdmVpbnRfZXhuIHggPSB3cmFwX2V4biAoQ29udi5uYXRpdmVpbnRfdG9faW50NjQgeClcbmxldCBvZl9uYXRpdmVpbnRfdHJ1bmMgeCA9IG9mX2ludDY0X3RydW5jIChDb252Lm5hdGl2ZWludF90b19pbnQ2NCB4KVxubGV0IHRvX25hdGl2ZWludCB4ID0gQ29udi5pbnQ2NF90b19uYXRpdmVpbnQgKHVud3JhcCB4KVxubGV0IHRvX25hdGl2ZWludF9leG4geCA9IENvbnYuaW50NjRfdG9fbmF0aXZlaW50X2V4biAodW53cmFwIHgpXG5sZXQgdG9fbmF0aXZlaW50X3RydW5jIHggPSBDb252LmludDY0X3RvX25hdGl2ZWludF90cnVuYyAodW53cmFwIHgpXG5cbmluY2x1ZGUgQ29udi5NYWtlIChUKVxuXG5pbmNsdWRlIENvbnYuTWFrZV9oZXggKHN0cnVjdFxuICAgIHR5cGUgdCA9IFQudCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgaGFzaF1cblxuICAgIGxldCBjb21wYXJlID0gKFQuY29tcGFyZSA6IHQgLT4gdCAtPiBpbnQpXG5cbiAgICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgICBULmhhc2hfZm9sZF90XG5cbiAgICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgICBsZXQgZnVuYyA9IFQuaGFzaCBpblxuICAgICAgZnVuIHggLT4gZnVuYyB4XG4gICAgOztcblxuICAgIFtAQEBlbmRdXG5cbiAgICBsZXQgemVybyA9IHplcm9cbiAgICBsZXQgbmVnID0gKCB+LSApXG4gICAgbGV0ICggPCApID0gKCA8IClcblxuICAgIGxldCB0b19zdHJpbmcgaSA9XG4gICAgICAoKiB0aGUgdXNlIG9mIFt1bndyYXBfdW5zaWduZWRdIGhlcmUgaXMgaW1wb3J0YW50IGZvciB0aGUgY2FzZSBvZiBbbWluX3ZhbHVlXSAqKVxuICAgICAgUHJpbnRmLnNwcmludGYgXCIlTHhcIiAodW53cmFwX3Vuc2lnbmVkIGkpXG4gICAgOztcblxuICAgIGxldCBvZl9zdHJpbmcgcyA9IG9mX3N0cmluZyAoXCIweFwiIF4gcylcbiAgICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuSW50NjMuSGV4XCJcbiAgZW5kKVxuXG5pbmNsdWRlIFByZXR0eV9wcmludGVyLlJlZ2lzdGVyIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gICAgbGV0IHRvX3N0cmluZyB4ID0gdG9fc3RyaW5nIHhcbiAgICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuSW50NjNcIlxuICBlbmQpXG5cbm1vZHVsZSBQcmVfTyA9IHN0cnVjdFxuICBsZXQgKCArICkgPSAoICsgKVxuICBsZXQgKCAtICkgPSAoIC0gKVxuICBsZXQgKCAqICkgPSAoICogKVxuICBsZXQgKCAvICkgPSAoIC8gKVxuICBsZXQgKCB+LSApID0gKCB+LSApXG4gIGxldCAoICoqICkgPSAoICoqIClcblxuICBpbmNsdWRlIChJbnQ2NF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgOiBDb21wYXJpc29ucy5JbmZpeCB3aXRoIHR5cGUgdCA6PSB0KVxuXG4gIGxldCBhYnMgPSBhYnNcbiAgbGV0IG5lZyA9IG5lZ1xuICBsZXQgemVybyA9IHplcm9cbiAgbGV0IG9mX2ludF9leG4gPSBvZl9pbnRfZXhuXG5lbmRcblxubW9kdWxlIE8gPSBzdHJ1Y3RcbiAgaW5jbHVkZSBQcmVfT1xuXG4gIGluY2x1ZGUgSW50X21hdGguTWFrZSAoc3RydWN0XG4gICAgICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gICAgICBpbmNsdWRlIFByZV9PXG5cbiAgICAgIGxldCByZW0gPSByZW1cbiAgICAgIGxldCB0b19mbG9hdCA9IHRvX2Zsb2F0XG4gICAgICBsZXQgb2ZfZmxvYXQgPSBvZl9mbG9hdFxuICAgICAgbGV0IG9mX3N0cmluZyA9IFQub2Zfc3RyaW5nXG4gICAgICBsZXQgdG9fc3RyaW5nID0gVC50b19zdHJpbmdcbiAgICBlbmQpXG5cbiAgbGV0ICggbGFuZCApID0gYml0X2FuZFxuICBsZXQgKCBsb3IgKSA9IGJpdF9vclxuICBsZXQgKCBseG9yICkgPSBiaXRfeG9yXG4gIGxldCBsbm90ID0gYml0X25vdFxuICBsZXQgKCBsc2wgKSA9IHNoaWZ0X2xlZnRcbiAgbGV0ICggYXNyICkgPSBzaGlmdF9yaWdodFxuICBsZXQgKCBsc3IgKSA9IHNoaWZ0X3JpZ2h0X2xvZ2ljYWxcbmVuZFxuXG5pbmNsdWRlIE9cblxuKCogW0ludDYzXSBhbmQgW0ludDYzLk9dIGFncmVlIHZhbHVlLXdpc2UgKilcblxubW9kdWxlIFJlcHIgPSBzdHJ1Y3RcbiAgdHlwZSBlbXVsYXRlZCA9IHRcblxuICB0eXBlICgndW5kZXJseWluZ190eXBlLCAnaW50ZXJtZWRpYXRlX3R5cGUpIHQgPVxuICAgIHwgSW50IDogKGludCwgaW50KSB0XG4gICAgfCBJbnQ2NCA6IChpbnQ2NCwgZW11bGF0ZWQpIHRcbmVuZFxuXG5sZXQgcmVwciA9IFJlcHIuSW50NjRcblxuKCogSW5jbHVkZSB0eXBlLXNwZWNpZmljIFtSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVdIGF0IHRoZSBlbmQsIGFmdGVyXG4gICBpbmNsdWRpbmcgZnVuY3RvciBhcHBsaWNhdGlvbiB0aGF0IGNvdWxkIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXNcbiAgIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25zIGFyZSBleHBvcnRlZCBieVxuICAgdGhpcyBtb2R1bGUuICopXG5pbmNsdWRlIEludDY0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuIiwib3BlbiEgSW1wb3J0XG5cbmxldCBpbnZhbGlkX2FyZ2YgPSBQcmludGYuaW52YWxpZF9hcmdmXG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIHR5cGUgdCA9IGJvb2wgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVudW1lcmF0ZSwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlID0gKGNvbXBhcmVfYm9vbCA6IHQgLT4gdCAtPiBpbnQpXG4gIGxldCBhbGwgPSAoWyBmYWxzZTsgdHJ1ZSBdIDogdCBsaXN0KVxuXG4gIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICBoYXNoX2ZvbGRfYm9vbFxuXG4gIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IGhhc2hfYm9vbCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCB0X29mX3NleHAgPSAoYm9vbF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG4gIGxldCBzZXhwX29mX3QgPSAoc2V4cF9vZl9ib29sIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IGJvb2xfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICBsZXQgaGFzaGFibGUgOiB0IEhhc2hhYmxlLnQgPSB7IGhhc2g7IGNvbXBhcmU7IHNleHBfb2ZfdCB9XG5cbiAgbGV0IG9mX3N0cmluZyA9IGZ1bmN0aW9uXG4gICAgfCBcInRydWVcIiAtPiB0cnVlXG4gICAgfCBcImZhbHNlXCIgLT4gZmFsc2VcbiAgICB8IHMgLT4gaW52YWxpZF9hcmdmIFwiQm9vbC5vZl9zdHJpbmc6IGV4cGVjdGVkIHRydWUgb3IgZmFsc2UgYnV0IGdvdCAlc1wiIHMgKClcbiAgOztcblxuICBsZXQgdG9fc3RyaW5nID0gQ2FtbC5zdHJpbmdfb2ZfYm9vbFxuZW5kXG5cbmluY2x1ZGUgVFxuaW5jbHVkZSBDb21wYXJhdG9yLk1ha2UgKFQpXG5cbmluY2x1ZGUgUHJldHR5X3ByaW50ZXIuUmVnaXN0ZXIgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgICBsZXQgdG9fc3RyaW5nID0gdG9fc3RyaW5nXG4gICAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLkJvb2xcIlxuICBlbmQpXG5cbigqIE9wZW4gcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGFmdGVyIGluY2x1ZGluZyBmdW5jdG9yIGluc3RhbnRpYXRpb25zIHNvIHRoZXkgZG8gbm90XG4gICBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb25cbiAgIGZ1bmN0aW9ucyBhcmUgYXZhaWxhYmxlIHdpdGhpbiB0aGlzIG1vZHVsZS4gKilcbm9wZW4hIEJvb2xfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbmxldCBpbnZhcmlhbnQgKF8gOiB0KSA9ICgpXG5sZXQgYmV0d2VlbiB0IH5sb3cgfmhpZ2ggPSBsb3cgPD0gdCAmJiB0IDw9IGhpZ2hcbmxldCBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXggPSBpZiB0IDwgbWluIHRoZW4gbWluIGVsc2UgaWYgdCA8PSBtYXggdGhlbiB0IGVsc2UgbWF4XG5cbmxldCBjbGFtcF9leG4gdCB+bWluIH5tYXggPVxuICBhc3NlcnQgKG1pbiA8PSBtYXgpO1xuICBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXhcbjs7XG5cbmxldCBjbGFtcCB0IH5taW4gfm1heCA9XG4gIGlmIG1pbiA+IG1heFxuICB0aGVuXG4gICAgT3JfZXJyb3IuZXJyb3Jfc1xuICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgXCJjbGFtcCByZXF1aXJlcyBbbWluIDw9IG1heF1cIlxuICAgICAgICAgWyBcIm1pblwiLCBULnNleHBfb2ZfdCBtaW47IFwibWF4XCIsIFQuc2V4cF9vZl90IG1heCBdKVxuICBlbHNlIE9rIChjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXgpXG47O1xuXG5sZXQgdG9faW50IHggPSBib29sX3RvX2ludCB4XG5cbm1vZHVsZSBOb25fc2hvcnRfY2lyY3VpdGluZyA9IHN0cnVjdFxuICAoKiBXZSBkb24ndCBleHBvc2UgdGhpcywgc2luY2Ugd2UgZG9uJ3Qgd2FudCB0byBicmVhayB0aGUgaW52YXJpYW50IG1lbnRpb25lZCBiZWxvdyBvZlxuICAgICAodG9faW50IHRydWUgPSAxKSBhbmQgKHRvX2ludCBmYWxzZSA9IDApLiAqKVxuICBsZXQgdW5zYWZlX29mX2ludCAoeCA6IGludCkgOiBib29sID0gQ2FtbC5PYmoubWFnaWMgeFxuICBsZXQgKCB8fCApIGEgYiA9IHVuc2FmZV9vZl9pbnQgKHRvX2ludCBhIGxvciB0b19pbnQgYilcbiAgbGV0ICggJiYgKSBhIGIgPSB1bnNhZmVfb2ZfaW50ICh0b19pbnQgYSBsYW5kIHRvX2ludCBiKVxuZW5kXG5cbigqIFdlIGRvIHRoaXMgYXMgYSBkaXJlY3QgYXNzZXJ0IG9uIHRoZSB0aGVvcnkgdGhhdCBpdCdzIGEgY2hlYXAgdGhpbmcgdG8gdGVzdCBhbmQgYVxuICAgcmVhbGx5IGNvcmUgaW52YXJpYW50IHRoYXQgd2UgbmV2ZXIgZXhwZWN0IHRvIGJyZWFrLCBhbmQgd2Ugc2hvdWxkIGJlIGhhcHB5IGZvciBhXG4gICBwcm9ncmFtIHRvIGZhaWwgaW1tZWRpYXRlbHkgaWYgdGhpcyBpcyB2aW9sYXRlZC4gKilcbmxldCAoKSA9IGFzc2VydCAoUG9seS4oID0gKSAodG9faW50IHRydWUpIDEgJiYgUG9seS4oID0gKSAodG9faW50IGZhbHNlKSAwKVxuXG4oKiBJbmNsdWRlIHR5cGUtc3BlY2lmaWMgW1JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZV0gYXQgdGhlIGVuZCwgYWZ0ZXJcbiAgIGluY2x1ZGluZyBmdW5jdG9yIGFwcGxpY2F0aW9uIHRoYXQgY291bGQgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpc1xuICAgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbnMgYXJlIGV4cG9ydGVkIGJ5XG4gICB0aGlzIG1vZHVsZS4gKilcbmluY2x1ZGUgQm9vbF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcbiIsIm9wZW4hIEltcG9ydFxub3BlbiEgQ2FtbC5JbnQzMlxuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICB0eXBlIHQgPSBpbnQzMiBbQEBkZXJpdmluZ19pbmxpbmUgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICBoYXNoX2ZvbGRfaW50MzJcblxuICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBoYXNoX2ludDMyIGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cCA9IChpbnQzMl9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG4gIGxldCBzZXhwX29mX3QgPSAoc2V4cF9vZl9pbnQzMiA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBpbnQzMl9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIGxldCBoYXNoYWJsZSA6IHQgSGFzaGFibGUudCA9IHsgaGFzaDsgY29tcGFyZTsgc2V4cF9vZl90IH1cbiAgbGV0IGNvbXBhcmUgKHggOiB0KSB5ID0gY29tcGFyZSB4IHlcbiAgbGV0IHRvX3N0cmluZyA9IHRvX3N0cmluZ1xuICBsZXQgb2Zfc3RyaW5nID0gb2Zfc3RyaW5nXG5lbmRcblxuaW5jbHVkZSBUXG5pbmNsdWRlIENvbXBhcmF0b3IuTWFrZSAoVClcblxubGV0IG51bV9iaXRzID0gMzJcbmxldCBmbG9hdF9sb3dlcl9ib3VuZCA9IEZsb2F0MC5sb3dlcl9ib3VuZF9mb3JfaW50IG51bV9iaXRzXG5sZXQgZmxvYXRfdXBwZXJfYm91bmQgPSBGbG9hdDAudXBwZXJfYm91bmRfZm9yX2ludCBudW1fYml0c1xubGV0IGZsb2F0X29mX2JpdHMgPSBmbG9hdF9vZl9iaXRzXG5sZXQgYml0c19vZl9mbG9hdCA9IGJpdHNfb2ZfZmxvYXRcbmxldCBzaGlmdF9yaWdodF9sb2dpY2FsID0gc2hpZnRfcmlnaHRfbG9naWNhbFxubGV0IHNoaWZ0X3JpZ2h0ID0gc2hpZnRfcmlnaHRcbmxldCBzaGlmdF9sZWZ0ID0gc2hpZnRfbGVmdFxubGV0IGJpdF9ub3QgPSBsb2dub3RcbmxldCBiaXRfeG9yID0gbG9neG9yXG5sZXQgYml0X29yID0gbG9nb3JcbmxldCBiaXRfYW5kID0gbG9nYW5kXG5sZXQgbWluX3ZhbHVlID0gbWluX2ludFxubGV0IG1heF92YWx1ZSA9IG1heF9pbnRcbmxldCBhYnMgPSBhYnNcbmxldCBwcmVkID0gcHJlZFxubGV0IHN1Y2MgPSBzdWNjXG5sZXQgcmVtID0gcmVtXG5sZXQgbmVnID0gbmVnXG5sZXQgbWludXNfb25lID0gbWludXNfb25lXG5sZXQgb25lID0gb25lXG5sZXQgemVybyA9IHplcm9cbmxldCBjb21wYXJlID0gY29tcGFyZVxubGV0IHRvX2Zsb2F0ID0gdG9fZmxvYXRcbmxldCBvZl9mbG9hdF91bmNoZWNrZWQgPSBvZl9mbG9hdFxuXG5sZXQgb2ZfZmxvYXQgZiA9XG4gIGlmIEZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oID49ICkgZiBmbG9hdF9sb3dlcl9ib3VuZFxuICAmJiBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA8PSApIGYgZmxvYXRfdXBwZXJfYm91bmRcbiAgdGhlbiBvZl9mbG9hdCBmXG4gIGVsc2VcbiAgICBQcmludGYuaW52YWxpZF9hcmdmXG4gICAgICBcIkludDMyLm9mX2Zsb2F0OiBhcmd1bWVudCAoJWYpIGlzIG91dCBvZiByYW5nZSBvciBOYU5cIlxuICAgICAgKEZsb2F0MC5ib3ggZilcbiAgICAgICgpXG47O1xuXG5pbmNsdWRlIENvbXBhcmFibGUuV2l0aF96ZXJvIChzdHJ1Y3RcbiAgICBpbmNsdWRlIFRcblxuICAgIGxldCB6ZXJvID0gemVyb1xuICBlbmQpXG5cbm1vZHVsZSBJbmZpeF9jb21wYXJlID0gc3RydWN0XG4gIG9wZW4gUG9seVxuXG4gIGxldCAoID49ICkgKHggOiB0KSB5ID0geCA+PSB5XG4gIGxldCAoIDw9ICkgKHggOiB0KSB5ID0geCA8PSB5XG4gIGxldCAoID0gKSAoeCA6IHQpIHkgPSB4ID0geVxuICBsZXQgKCA+ICkgKHggOiB0KSB5ID0geCA+IHlcbiAgbGV0ICggPCApICh4IDogdCkgeSA9IHggPCB5XG4gIGxldCAoIDw+ICkgKHggOiB0KSB5ID0geCA8PiB5XG5lbmRcblxubW9kdWxlIENvbXBhcmUgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBJbmZpeF9jb21wYXJlXG5cbiAgbGV0IGNvbXBhcmUgPSBjb21wYXJlXG4gIGxldCBhc2NlbmRpbmcgPSBjb21wYXJlXG4gIGxldCBkZXNjZW5kaW5nIHggeSA9IGNvbXBhcmUgeSB4XG4gIGxldCBtaW4gKHggOiB0KSB5ID0gaWYgeCA8IHkgdGhlbiB4IGVsc2UgeVxuICBsZXQgbWF4ICh4IDogdCkgeSA9IGlmIHggPiB5IHRoZW4geCBlbHNlIHlcbiAgbGV0IGVxdWFsICh4IDogdCkgeSA9IHggPSB5XG4gIGxldCBiZXR3ZWVuIHQgfmxvdyB+aGlnaCA9IGxvdyA8PSB0ICYmIHQgPD0gaGlnaFxuICBsZXQgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4ID0gaWYgdCA8IG1pbiB0aGVuIG1pbiBlbHNlIGlmIHQgPD0gbWF4IHRoZW4gdCBlbHNlIG1heFxuXG4gIGxldCBjbGFtcF9leG4gdCB+bWluIH5tYXggPVxuICAgIGFzc2VydCAobWluIDw9IG1heCk7XG4gICAgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4XG4gIDs7XG5cbiAgbGV0IGNsYW1wIHQgfm1pbiB+bWF4ID1cbiAgICBpZiBtaW4gPiBtYXhcbiAgICB0aGVuXG4gICAgICBPcl9lcnJvci5lcnJvcl9zXG4gICAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgICAgXCJjbGFtcCByZXF1aXJlcyBbbWluIDw9IG1heF1cIlxuICAgICAgICAgICBbIFwibWluXCIsIFQuc2V4cF9vZl90IG1pbjsgXCJtYXhcIiwgVC5zZXhwX29mX3QgbWF4IF0pXG4gICAgZWxzZSBPayAoY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4KVxuICA7O1xuZW5kXG5cbmluY2x1ZGUgQ29tcGFyZVxuXG5sZXQgaW52YXJpYW50IChfIDogdCkgPSAoKVxubGV0ICggLyApID0gZGl2XG5sZXQgKCAqICkgPSBtdWxcbmxldCAoIC0gKSA9IHN1YlxubGV0ICggKyApID0gYWRkXG5sZXQgKCB+LSApID0gbmVnXG5sZXQgaW5jciByID0gciA6PSAhciArIG9uZVxubGV0IGRlY3IgciA9IHIgOj0gIXIgLSBvbmVcbmxldCBvZl9pbnQzMiB0ID0gdFxubGV0IG9mX2ludDMyX2V4biA9IG9mX2ludDMyXG5sZXQgdG9faW50MzIgdCA9IHRcbmxldCB0b19pbnQzMl9leG4gPSB0b19pbnQzMlxubGV0IHBvcGNvdW50ID0gUG9wY291bnQuaW50MzJfcG9wY291bnRcblxubW9kdWxlIENvbnYgPSBJbnRfY29udmVyc2lvbnNcblxubGV0IG9mX2ludCA9IENvbnYuaW50X3RvX2ludDMyXG5sZXQgb2ZfaW50X2V4biA9IENvbnYuaW50X3RvX2ludDMyX2V4blxubGV0IG9mX2ludF90cnVuYyA9IENvbnYuaW50X3RvX2ludDMyX3RydW5jXG5sZXQgdG9faW50ID0gQ29udi5pbnQzMl90b19pbnRcbmxldCB0b19pbnRfZXhuID0gQ29udi5pbnQzMl90b19pbnRfZXhuXG5sZXQgdG9faW50X3RydW5jID0gQ29udi5pbnQzMl90b19pbnRfdHJ1bmNcbmxldCBvZl9pbnQ2NCA9IENvbnYuaW50NjRfdG9faW50MzJcbmxldCBvZl9pbnQ2NF9leG4gPSBDb252LmludDY0X3RvX2ludDMyX2V4blxubGV0IG9mX2ludDY0X3RydW5jID0gQ29udi5pbnQ2NF90b19pbnQzMl90cnVuY1xubGV0IHRvX2ludDY0ID0gQ29udi5pbnQzMl90b19pbnQ2NFxubGV0IG9mX25hdGl2ZWludCA9IENvbnYubmF0aXZlaW50X3RvX2ludDMyXG5sZXQgb2ZfbmF0aXZlaW50X2V4biA9IENvbnYubmF0aXZlaW50X3RvX2ludDMyX2V4blxubGV0IG9mX25hdGl2ZWludF90cnVuYyA9IENvbnYubmF0aXZlaW50X3RvX2ludDMyX3RydW5jXG5sZXQgdG9fbmF0aXZlaW50ID0gQ29udi5pbnQzMl90b19uYXRpdmVpbnRcbmxldCB0b19uYXRpdmVpbnRfZXhuID0gdG9fbmF0aXZlaW50XG5sZXQgcG93IGIgZSA9IG9mX2ludF9leG4gKEludF9tYXRoLlByaXZhdGUuaW50X3BvdyAodG9faW50X2V4biBiKSAodG9faW50X2V4biBlKSlcbmxldCAoICoqICkgYiBlID0gcG93IGIgZVxuXG5leHRlcm5hbCBic3dhcDMyIDogdCAtPiB0ID0gXCIlYnN3YXBfaW50MzJcIlxuXG5sZXQgYnN3YXAxNiB4ID0gQ2FtbC5JbnQzMi5zaGlmdF9yaWdodF9sb2dpY2FsIChic3dhcDMyIHgpIDE2XG5cbm1vZHVsZSBQb3cyID0gc3RydWN0XG4gIG9wZW4hIEltcG9ydFxuICBvcGVuIEludDMyX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG4gIGxldCByYWlzZV9zID0gRXJyb3IucmFpc2Vfc1xuXG4gIGxldCBub25fcG9zaXRpdmVfYXJndW1lbnQgKCkgPVxuICAgIFByaW50Zi5pbnZhbGlkX2FyZ2YgXCJhcmd1bWVudCBtdXN0IGJlIHN0cmljdGx5IHBvc2l0aXZlXCIgKClcbiAgOztcblxuICBsZXQgKCBsb3IgKSA9IENhbWwuSW50MzIubG9nb3JcbiAgbGV0ICggbHNyICkgPSBDYW1sLkludDMyLnNoaWZ0X3JpZ2h0X2xvZ2ljYWxcbiAgbGV0ICggbGFuZCApID0gQ2FtbC5JbnQzMi5sb2dhbmRcblxuICAoKiogXCJjZWlsaW5nIHBvd2VyIG9mIDJcIiAtIExlYXN0IHBvd2VyIG9mIDIgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHguICopXG4gIGxldCBjZWlsX3BvdzIgeCA9XG4gICAgaWYgeCA8PSBDYW1sLkludDMyLnplcm8gdGhlbiBub25fcG9zaXRpdmVfYXJndW1lbnQgKCk7XG4gICAgbGV0IHggPSBDYW1sLkludDMyLnByZWQgeCBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDEpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMikgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciA0KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDgpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMTYpIGluXG4gICAgQ2FtbC5JbnQzMi5zdWNjIHhcbiAgOztcblxuICAoKiogXCJmbG9vciBwb3dlciBvZiAyXCIgLSBMYXJnZXN0IHBvd2VyIG9mIDIgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHguICopXG4gIGxldCBmbG9vcl9wb3cyIHggPVxuICAgIGlmIHggPD0gQ2FtbC5JbnQzMi56ZXJvIHRoZW4gbm9uX3Bvc2l0aXZlX2FyZ3VtZW50ICgpO1xuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDEpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMikgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciA0KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDgpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMTYpIGluXG4gICAgQ2FtbC5JbnQzMi5zdWIgeCAoeCBsc3IgMSlcbiAgOztcblxuICBsZXQgaXNfcG93MiB4ID1cbiAgICBpZiB4IDw9IENhbWwuSW50MzIuemVybyB0aGVuIG5vbl9wb3NpdGl2ZV9hcmd1bWVudCAoKTtcbiAgICB4IGxhbmQgQ2FtbC5JbnQzMi5wcmVkIHggPSBDYW1sLkludDMyLnplcm9cbiAgOztcblxuICAoKiBDIHN0dWJzIGZvciBpbnQzMiBjbHogYW5kIGN0eiB0byB1c2UgdGhlIENMWi9CU1IvQ1RaL0JTRiBpbnN0cnVjdGlvbiB3aGVyZSBwb3NzaWJsZSAqKVxuICBleHRlcm5hbCBjbHpcbiAgICA6ICAoaW50MzJbQHVuYm94ZWRdKVxuICAgIC0+IChpbnRbQHVudGFnZ2VkXSlcbiAgICA9IFwiQmFzZV9pbnRfbWF0aF9pbnQzMl9jbHpcIiBcIkJhc2VfaW50X21hdGhfaW50MzJfY2x6X3VuYm94ZWRcIlxuICBbQEBub2FsbG9jXVxuXG4gIGV4dGVybmFsIGN0elxuICAgIDogIChpbnQzMltAdW5ib3hlZF0pXG4gICAgLT4gKGludFtAdW50YWdnZWRdKVxuICAgID0gXCJCYXNlX2ludF9tYXRoX2ludDMyX2N0elwiIFwiQmFzZV9pbnRfbWF0aF9pbnQzMl9jdHpfdW5ib3hlZFwiXG4gIFtAQG5vYWxsb2NdXG5cbiAgKCoqIEhhY2tlcidzIERlbGlnaHQgU2Vjb25kIEVkaXRpb24gcDEwNiAqKVxuICBsZXQgZmxvb3JfbG9nMiBpID1cbiAgICBpZiBpIDw9IENhbWwuSW50MzIuemVyb1xuICAgIHRoZW5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgKFNleHAubWVzc2FnZSBcIltJbnQzMi5mbG9vcl9sb2cyXSBnb3QgaW52YWxpZCBpbnB1dFwiIFsgXCJcIiwgc2V4cF9vZl9pbnQzMiBpIF0pO1xuICAgIG51bV9iaXRzIC0gMSAtIGNseiBpXG4gIDs7XG5cbiAgKCoqIEhhY2tlcidzIERlbGlnaHQgU2Vjb25kIEVkaXRpb24gcDEwNiAqKVxuICBsZXQgY2VpbF9sb2cyIGkgPVxuICAgIGlmIGkgPD0gQ2FtbC5JbnQzMi56ZXJvXG4gICAgdGhlblxuICAgICAgcmFpc2VfcyAoU2V4cC5tZXNzYWdlIFwiW0ludDMyLmNlaWxfbG9nMl0gZ290IGludmFsaWQgaW5wdXRcIiBbIFwiXCIsIHNleHBfb2ZfaW50MzIgaSBdKTtcbiAgICAoKiBUaGUgW2kgPSAxXSBjaGVjayBpcyBuZWVkZWQgYmVjYXVzZSBjbHooMCkgaXMgdW5kZWZpbmVkICopXG4gICAgaWYgQ2FtbC5JbnQzMi5lcXVhbCBpIENhbWwuSW50MzIub25lIHRoZW4gMCBlbHNlIG51bV9iaXRzIC0gY2x6IChDYW1sLkludDMyLnByZWQgaSlcbiAgOztcbmVuZFxuXG5pbmNsdWRlIFBvdzJcbmluY2x1ZGUgQ29udi5NYWtlIChUKVxuXG5pbmNsdWRlIENvbnYuTWFrZV9oZXggKHN0cnVjdFxuICAgIHR5cGUgdCA9IGludDMyIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBoYXNoXVxuXG4gICAgbGV0IGNvbXBhcmUgPSAoY29tcGFyZV9pbnQzMiA6IHQgLT4gdCAtPiBpbnQpXG5cbiAgICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgICBoYXNoX2ZvbGRfaW50MzJcblxuICAgIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICAgIGxldCBmdW5jID0gaGFzaF9pbnQzMiBpblxuICAgICAgZnVuIHggLT4gZnVuYyB4XG4gICAgOztcblxuICAgIFtAQEBlbmRdXG5cbiAgICBsZXQgemVybyA9IHplcm9cbiAgICBsZXQgbmVnID0gKCB+LSApXG4gICAgbGV0ICggPCApID0gKCA8IClcbiAgICBsZXQgdG9fc3RyaW5nIGkgPSBQcmludGYuc3ByaW50ZiBcIiVseFwiIGlcbiAgICBsZXQgb2Zfc3RyaW5nIHMgPSBDYW1sLlNjYW5mLnNzY2FuZiBzIFwiJWx4XCIgRm4uaWRcbiAgICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuSW50MzIuSGV4XCJcbiAgZW5kKVxuXG5pbmNsdWRlIFByZXR0eV9wcmludGVyLlJlZ2lzdGVyIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gICAgbGV0IHRvX3N0cmluZyA9IHRvX3N0cmluZ1xuICAgIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5JbnQzMlwiXG4gIGVuZClcblxubW9kdWxlIFByZV9PID0gc3RydWN0XG4gIGxldCAoICsgKSA9ICggKyApXG4gIGxldCAoIC0gKSA9ICggLSApXG4gIGxldCAoICogKSA9ICggKiApXG4gIGxldCAoIC8gKSA9ICggLyApXG4gIGxldCAoIH4tICkgPSAoIH4tIClcbiAgbGV0ICggKiogKSA9ICggKiogKVxuXG4gIGluY2x1ZGUgKENvbXBhcmUgOiBDb21wYXJpc29ucy5JbmZpeCB3aXRoIHR5cGUgdCA6PSB0KVxuXG4gIGxldCBhYnMgPSBhYnNcbiAgbGV0IG5lZyA9IG5lZ1xuICBsZXQgemVybyA9IHplcm9cbiAgbGV0IG9mX2ludF9leG4gPSBvZl9pbnRfZXhuXG5lbmRcblxubW9kdWxlIE8gPSBzdHJ1Y3RcbiAgaW5jbHVkZSBQcmVfT1xuXG4gIGluY2x1ZGUgSW50X21hdGguTWFrZSAoc3RydWN0XG4gICAgICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gICAgICBpbmNsdWRlIFByZV9PXG5cbiAgICAgIGxldCByZW0gPSByZW1cbiAgICAgIGxldCB0b19mbG9hdCA9IHRvX2Zsb2F0XG4gICAgICBsZXQgb2ZfZmxvYXQgPSBvZl9mbG9hdFxuICAgICAgbGV0IG9mX3N0cmluZyA9IFQub2Zfc3RyaW5nXG4gICAgICBsZXQgdG9fc3RyaW5nID0gVC50b19zdHJpbmdcbiAgICBlbmQpXG5cbiAgbGV0ICggbGFuZCApID0gYml0X2FuZFxuICBsZXQgKCBsb3IgKSA9IGJpdF9vclxuICBsZXQgKCBseG9yICkgPSBiaXRfeG9yXG4gIGxldCBsbm90ID0gYml0X25vdFxuICBsZXQgKCBsc2wgKSA9IHNoaWZ0X2xlZnRcbiAgbGV0ICggYXNyICkgPSBzaGlmdF9yaWdodFxuICBsZXQgKCBsc3IgKSA9IHNoaWZ0X3JpZ2h0X2xvZ2ljYWxcbmVuZFxuXG5pbmNsdWRlIE9cblxuKCogW0ludDMyXSBhbmQgW0ludDMyLk9dIGFncmVlIHZhbHVlLXdpc2UgKilcbiIsIm9wZW4hIEltcG9ydFxub3BlbiEgUHJpbnRmXG5tb2R1bGUgQnl0ZXMgPSBCeXRlczBcbmluY2x1ZGUgRmxvYXQwXG5cbmxldCByYWlzZV9zID0gRXJyb3IucmFpc2Vfc1xuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICB0eXBlIHQgPSBmbG9hdCBbQEBkZXJpdmluZ19pbmxpbmUgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICBoYXNoX2ZvbGRfZmxvYXRcblxuICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBoYXNoX2Zsb2F0IGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cCA9IChmbG9hdF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG4gIGxldCBzZXhwX29mX3QgPSAoc2V4cF9vZl9mbG9hdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBmbG9hdF9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIGxldCBoYXNoYWJsZSA6IHQgSGFzaGFibGUudCA9IHsgaGFzaDsgY29tcGFyZTsgc2V4cF9vZl90IH1cbiAgbGV0IGNvbXBhcmUgPSBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuY29tcGFyZVxuZW5kXG5cbmluY2x1ZGUgVFxuaW5jbHVkZSBDb21wYXJhdG9yLk1ha2UgKFQpXG5cbigqIE9wZW4gcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGFmdGVyIGluY2x1ZGluZyBmdW5jdG9yIGluc3RhbnRpYXRpb25zIHNvIHRoZXkgZG8gbm90XG4gICBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb25cbiAgIGZ1bmN0aW9ucyBhcmUgYXZhaWxhYmxlIHdpdGhpbiB0aGlzIG1vZHVsZS4gKilcbm9wZW4gRmxvYXRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbmxldCBpbnZhcmlhbnQgKF8gOiB0KSA9ICgpXG5sZXQgdG9fZmxvYXQgeCA9IHhcbmxldCBvZl9mbG9hdCB4ID0geFxuXG5sZXQgb2Zfc3RyaW5nIHMgPVxuICB0cnkgZmxvYXRfb2Zfc3RyaW5nIHMgd2l0aFxuICB8IF8gLT4gaW52YWxpZF9hcmdmIFwiRmxvYXQub2Zfc3RyaW5nICVzXCIgcyAoKVxuOztcblxuZXh0ZXJuYWwgZm9ybWF0X2Zsb2F0IDogc3RyaW5nIC0+IGZsb2F0IC0+IHN0cmluZyA9IFwiY2FtbF9mb3JtYXRfZmxvYXRcIlxuXG4oKiBTdG9sZW4gZnJvbSBbcGVydmFzaXZlcy5tbF0uICBBZGRzIGEgXCIuXCIgYXQgdGhlIGVuZCBpZiBuZWVkZWQuICBJdCBpcyBpblxuICAgW3BlcnZhc2l2ZXMubWxpXSwgYnV0IGl0IGFsc28gc2F5cyBub3QgdG8gdXNlIGl0IGRpcmVjdGx5LCBzbyB3ZSBjb3B5IGFuZCBwYXN0ZSB0aGVcbiAgIGNvZGUuIEl0IG1ha2VzIHRoZSBhc3N1bXB0aW9uIG9uIHRoZSBzdHJpbmcgcGFzc2VkIGluIGFyZ3VtZW50IHRoYXQgaXQgd2FzIHJldHVybmVkIGJ5XG4gICBbZm9ybWF0X2Zsb2F0XS4gKilcbmxldCB2YWxpZF9mbG9hdF9sZXhlbSBzID1cbiAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA+PSApIGkgbFxuICAgIHRoZW4gcyBeIFwiLlwiXG4gICAgZWxzZSAoXG4gICAgICBtYXRjaCBzLltpXSB3aXRoXG4gICAgICB8ICcwJyAuLiAnOScgfCAnLScgLT4gbG9vcCAoaSArIDEpXG4gICAgICB8IF8gLT4gcylcbiAgaW5cbiAgbG9vcCAwXG47O1xuXG4oKiBMZXQgW3ldIGJlIGEgcG93ZXIgb2YgMi4gIFRoZW4gdGhlIG5leHQgcmVwcmVzZW50YWJsZSBmbG9hdCBpczpcbiAgIFt6ID0geSAqICgxICsgMiAqKiAtNTIpXVxuICAgYW5kIHRoZSBwcmV2aW91cyBvbmUgaXNcbiAgIFt4ID0geSAqICgxIC0gMiAqKiAtNTMpXVxuXG4gICBJbiBnZW5lcmFsLCBldmVyeSB0d28gYWRqYWNlbnQgZmxvYXRzIGFyZSB3aXRoaW4gYSBmYWN0b3Igb2YgYmV0d2VlbiBbMSArIDIqKi01M11cbiAgIGFuZCBbMSArIDIqKi01Ml0gZnJvbSBlYWNoIG90aGVyLCB0aGF0IGlzIHdpdGhpbiBbMSArIDEuMWUtMTZdIGFuZCBbMSArIDIuM2UtMTZdLlxuXG4gICBTbyBpZiB0aGUgZGVjaW1hbCByZXByZXNlbnRhdGlvbiBvZiBhIGZsb2F0IHN0YXJ0cyB3aXRoIFwiMVwiLCB0aGVuIGl0cyBhZGphY2VudCBmbG9hdHNcbiAgIHdpbGwgdXN1YWxseSBkaWZmZXIgZnJvbSBpdCBieSAxLCBhbmQgc29tZXRpbWVzIGJ5IDIsIGF0IHRoZSAxN3RoIHNpZ25pZmljYW50IGRpZ2l0XG4gICAoY291bnRpbmcgZnJvbSAxKS5cblxuICAgT24gdGhlIG90aGVyIGhhbmQsIGlmIHRoZSBkZWNpbWFsIHJlcHJlc2VudGF0aW9uIHN0YXJ0cyB3aXRoIFwiOVwiLCB0aGVuIHRoZSBhZGphY2VudFxuICAgZmxvYXRzIHdpbGwgYmUgb2ZmIGJ5IG5vIG1vcmUgdGhhbiAyMyBhdCB0aGUgMTZ0aCBhbmQgMTd0aCBzaWduaWZpY2FudCBkaWdpdHMuXG5cbiAgIEUuZy46XG5cbiAgIHt2XG4gICAgICMgc3ByaW50ZiBcIiUuMTdnXCIgKDEwMjQuICouICgxLiAtLiAyLioqICgtNTMuKSkpOztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTExMTExMTFcbiAgICAgICAgICAgICAgICAgICAxMjM0IDU2Nzg5MDEyMzQ1NjdcbiAgICAgLSA6IHN0cmluZyA9IFwiMTAyMy45OTk5OTk5OTk5OTk5XCJcbiAgIHZ9XG4gICBQcmludGluZyBhIGNvdXBsZSBvZiBleHRyYSBkaWdpdHMgcmV2ZWFscyB0aGF0IHRoZSBkaWZmZXJlbmNlIGluZGVlZCBpcyByb3VnaGx5IDExIGF0XG4gICBkaWdpdHMgMTd0aCBhbmQgMTh0aCAodGhhdCBpcywgMTN0aCBhbmQgMTR0aCBhZnRlciBcIi5cIik6XG5cbiAgIHt2XG4gICAgICMgc3ByaW50ZiBcIiUuMTlnXCIgKDEwMjQuICouICgxLiAtLiAyLioqICgtNTMuKSkpOztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTExMTExMTExMVxuICAgICAgICAgICAgICAgICAgIDEyMzQgNTY3ODkwMTIzNDU2Nzg5XG4gICAgIC0gOiBzdHJpbmcgPSBcIjEwMjMuOTk5OTk5OTk5OTk5ODg2XCJcbiAgIHZ9XG5cbiAgIFRoZSB1bHAgKHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gYWRqYWNlbnQgZmxvYXRzKSBpcyB0d2ljZSBhcyBiaWcgb24gdGhlIG90aGVyIHNpZGUgb2ZcbiAgIDEwMjQuOlxuXG4gICB7dlxuICAgICAjIHNwcmludGYgXCIlLjE5Z1wiICgxMDI0LiAqLiAoMS4gKy4gMi4qKiAoLTUyLikpKTs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIDExMTExMTExMTFcbiAgICAgICAgICAgICAgICAgICAxMjM0IDU2Nzg5MDEyMzQ1Njc4OVxuICAgICAtIDogc3RyaW5nID0gXCIxMDI0LjAwMDAwMDAwMDAwMDIyN1wiXG4gICB2fVxuXG4gICBOb3cgdGFrZSBhIHBvd2VyIG9mIDIgd2hpY2ggc3RhcnRzIHdpdGggOTk6XG5cbiAgIHt2XG4gICAgICMgMi4qKjkzLiA7O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAxMTExMTExMTExXG4gICAgICAgICAgICAgICAgIDEgMjM0NTY3ODkwMTIzNDU2NzhcbiAgICAgLSA6IGZsb2F0ID0gOS45MDM1MjAzMTQyODMwNDIyZSsyN1xuXG4gICAgICMgMi4qKjkzLiAqLiAoMS4gKy4gMi4qKiAoLTUyLikpOztcbiAgICAgLSA6IGZsb2F0ID0gOS45MDM1MjAzMTQyODMwNDQ0ZSsyN1xuXG4gICAgICMgMi4qKjkzLiAqLiAoMS4gLS4gMi4qKiAoLTUzLikpOztcbiAgICAgLSA6IGZsb2F0ID0gOS45MDM1MjAzMTQyODMwNDExZSsyN1xuICAgdn1cblxuICAgVGhlIGRpZmZlcmVuY2UgYmV0d2VlbiAyKio5MyBhbmQgaXRzIHR3byBuZWlnaGJvcnMgaXMgc2xpZ2h0bHkgbW9yZSB0aGFuLCByZXNwZWN0aXZlbHksXG4gICAxIGFuZCAyIGF0IHNpZ25pZmljYW50IGRpZ2l0IDE2LlxuXG4gICBUaG9zZSBleGFtcGxlcyBzaG93IHRoYXQ6XG4gICAtIDE3IHNpZ25pZmljYW50IGRpZ2l0cyBpcyBhbHdheXMgc3VmZmljaWVudCB0byByZXByZXNlbnQgYSBmbG9hdCB3aXRob3V0IGFtYmlndWl0eVxuICAgLSAxNXRoIHNpZ25pZmljYW50IGRpZ2l0IGNhbiBhbHdheXMgYmUgcmVwcmVzZW50ZWQgYWNjdXJhdGVseVxuICAgLSBjb252ZXJ0aW5nIGEgZGVjaW1hbCBudW1iZXIgd2l0aCAxNiBzaWduaWZpY2FudCBkaWdpdHMgdG8gaXRzIG5lYXJlc3QgZmxvYXQgYW5kIGJhY2tcbiAgICAgY2FuIGNoYW5nZSB0aGUgbGFzdCBkZWNpbWFsIGRpZ2l0IGJ5IG5vIG1vcmUgdGhhbiAxXG5cbiAgIFRvIG1ha2Ugc3VyZSB0aGF0IGZsb2F0cyBvYnRhaW5lZCBieSBjb252ZXJzaW9uIGZyb20gZGVjaW1hbCBmcmFjdGlvbnMgKGUuZy4gXCIzLjE0XCIpXG4gICBhcmUgcHJpbnRlZCB3aXRob3V0IHRyYWlsaW5nIG5vbi16ZXJvIGRpZ2l0cywgb25lIHNob3VsZCBjaG9vc2UgdGhlIGZpcnN0IGFtb25nIHRoZVxuICAgJyUuMTVnJywgJyUuMTZnJywgYW5kICclLjE3ZycgcmVwcmVzZW50YXRpb25zIHdoaWNoIGRvZXMgcm91bmQtdHJpcDpcblxuICAge3ZcbiAgICAgIyBzcHJpbnRmIFwiJS4xNWdcIiAzLjE0OztcbiAgICAgLSA6IHN0cmluZyA9IFwiMy4xNFwiICAgICAgICAgICAgICAgICAgICAgKCogcGljayB0aGlzIG9uZSAqKVxuICAgICAjIHNwcmludGYgXCIlLjE2Z1wiIDMuMTQ7O1xuICAgICAtIDogc3RyaW5nID0gXCIzLjE0XCJcbiAgICAgIyBzcHJpbnRmIFwiJS4xN2dcIiAzLjE0OztcbiAgICAgLSA6IHN0cmluZyA9IFwiMy4xNDAwMDAwMDAwMDAwMDAxXCIgICAgICAgKCogZG8gbm90IHBpY2sgdGhpcyBvbmUgKilcblxuICAgICAjIHNwcmludGYgXCIlLjE1Z1wiIDguMDAwMDAwMDAwMDAwMDAyOztcbiAgICAgLSA6IHN0cmluZyA9IFwiOFwiICAgICAgICAgICAgICAgICAgICAgICAgKCogZG8gbm90IHBpY2sgdGhpcyBvbmUtLWRvZXMgbm90IHJvdW5kLXRyaXAgKilcbiAgICAgIyBzcHJpbnRmIFwiJS4xNmdcIiA4LjAwMDAwMDAwMDAwMDAwMjs7XG4gICAgIC0gOiBzdHJpbmcgPSBcIjguMDAwMDAwMDAwMDAwMDAyXCIgICAgICAgICgqIHByZWZlciB0aGlzIG9uZSAqKVxuICAgICAjIHNwcmludGYgXCIlLjE3Z1wiIDguMDAwMDAwMDAwMDAwMDAyOztcbiAgICAgLSA6IHN0cmluZyA9IFwiOC4wMDAwMDAwMDAwMDAwMDE4XCIgICAgICAgKCogdGhpcyBvbmUgaGFzIG9uZSBkaWdpdCBvZiBqdW5rIGF0IHRoZSBlbmQgKilcbiAgIHZ9XG5cbiAgIFNraXBwaW5nIHRoZSAnJS4xNmcnIGluIHRoZSBhYm92ZSBwcm9jZWR1cmUgc2F2ZXMgdXMgc29tZSB0aW1lLCBidXQgaXQgbWVhbnMgdGhhdCwgYXNcbiAgIHNlZW4gaW4gdGhlIHNlY29uZCBleGFtcGxlIGFib3ZlLCBvY2Nhc2lvbmFsbHkgbnVtYmVycyB3aXRoIGV4YWN0bHkgMTYgc2lnbmlmaWNhbnRcbiAgIGRpZ2l0cyB3aWxsIGhhdmUgYW4gZXJyb3IgaW50cm9kdWNlZCBhdCB0aGUgMTd0aCBkaWdpdC4gIFRoYXQgaXMgcHJvYmFibHkgT0sgZm9yXG4gICB0eXBpY2FsIHVzZSwgYmVjYXVzZSBhIG51bWJlciB3aXRoIDE2IHNpZ25pZmljYW50IGRpZ2l0cyBpcyBcInVnbHlcIiBhbHJlYWR5LiAgQWRkaW5nIG9uZVxuICAgbW9yZSBkb2Vzbid0IG1ha2UgaXQgbXVjaCB3b3JzZSBmb3IgYSBodW1hbiByZWFkZXIuXG5cbiAgIE9uIHRoZSBvdGhlciBoYW5kLCB3ZSBjYW5ub3Qgc2tpcCAnJS4xNWcnIGFuZCBvbmx5IGxvb2sgYXQgJyUuMTZnJyBhbmQgJyUuMTdnJywgc2luY2VcbiAgIHRoZSBpbmFjY3VyYWN5IGF0IHRoZSAxNnRoIGRpZ2l0IG1pZ2h0IGludHJvZHVjZSB0aGUgbm9pc2Ugd2Ugd2FudCB0byBhdm9pZDpcblxuICAge3ZcbiAgICAgIyBzcHJpbnRmIFwiJS4xNWdcIiA5Ljk5Mjs7XG4gICAgIC0gOiBzdHJpbmcgPSBcIjkuOTkyXCIgICAgICAgICAgICAgICAgICAgICgqIHBpY2sgdGhpcyBvbmUgKilcbiAgICAgIyBzcHJpbnRmIFwiJS4xNmdcIiA5Ljk5Mjs7XG4gICAgIC0gOiBzdHJpbmcgPSBcIjkuOTkyMDAwMDAwMDAwMDAxXCIgICAgICAgICgqIGRvIG5vdCBwaWNrIHRoaXMgb25lLS1qdW5rIGF0IHRoZSBlbmQgKilcbiAgICAgIyBzcHJpbnRmIFwiJS4xN2dcIiA5Ljk5Mjs7XG4gICAgIC0gOiBzdHJpbmcgPSBcIjkuOTkyMDAwMDAwMDAwMDAwOVwiXG4gICB2fVxuKilcbmxldCB0b19zdHJpbmcgeCA9XG4gIHZhbGlkX2Zsb2F0X2xleGVtXG4gICAgKGxldCB5ID0gZm9ybWF0X2Zsb2F0IFwiJS4xNWdcIiB4IGluXG4gICAgIGlmIGZsb2F0X29mX3N0cmluZyB5ID0geCB0aGVuIHkgZWxzZSBmb3JtYXRfZmxvYXQgXCIlLjE3Z1wiIHgpXG47O1xuXG5sZXQgbWF4X3ZhbHVlID0gaW5maW5pdHlcbmxldCBtaW5fdmFsdWUgPSBuZWdfaW5maW5pdHlcbmxldCBtaW5fcG9zaXRpdmVfc3Vibm9ybWFsX3ZhbHVlID0gMi4gKiogLTEwNzQuXG5sZXQgbWluX3Bvc2l0aXZlX25vcm1hbF92YWx1ZSA9IDIuICoqIC0xMDIyLlxubGV0IHplcm8gPSAwLlxubGV0IG9uZSA9IDEuXG5sZXQgbWludXNfb25lID0gLTEuXG5sZXQgcGkgPSAweDMuMjQzRjZBODg4NUEzMDhEMzEzMTk4QTJFMDM3MDczXG5sZXQgc3FydF9waSA9IDB4MS5DNUJGODkxQjRFRjZBQTc5QzNCMDUyMEQ1REI5MzhcbmxldCBzcXJ0XzJwaSA9IDB4Mi44MUIyNjNGRUM0RTBCMkNBRjk0ODNGNUNFNDU5RENcbmxldCBldWxlciA9IDB4MC45M0M0NjdFMzdEQjBDN0E0RDFCRTNGODEwMTUyQ0JcbmxldCBvZl9pbnQgPSBJbnQudG9fZmxvYXRcbmxldCB0b19pbnQgPSBJbnQub2ZfZmxvYXRcbmxldCBvZl9pbnQ2MyBpID0gSW50NjMudG9fZmxvYXQgaVxubGV0IG9mX2ludDY0IGkgPSBDYW1sLkludDY0LnRvX2Zsb2F0IGlcbmxldCB0b19pbnQ2NCA9IENhbWwuSW50NjQub2ZfZmxvYXRcbmxldCBpcm91bmRfbGJvdW5kID0gbG93ZXJfYm91bmRfZm9yX2ludCBJbnQubnVtX2JpdHNcbmxldCBpcm91bmRfdWJvdW5kID0gdXBwZXJfYm91bmRfZm9yX2ludCBJbnQubnVtX2JpdHNcblxuKCogVGhlIHBlcmZvcm1hbmNlIG9mIHRoZSBcImV4blwiIHJvdW5kaW5nIGZ1bmN0aW9ucyBpcyBpbXBvcnRhbnQsIHNvIHRoZXkgYXJlIHdyaXR0ZW5cbiAgIG91dCBzZXBhcmF0ZWx5LCBhbmQgdHVuZWQgaW5kaXZpZHVhbGx5LiAgKFdlIGNvdWxkIGhhdmUgdGhlIG9wdGlvbiB2ZXJzaW9ucyBjYWxsXG4gICB0aGUgXCJleG5cIiB2ZXJzaW9ucywgYnV0IHRoYXQgaW1wb3NlcyBhcmd1YWJseSBncmF0dWl0b3VzIG92ZXJoZWFkLS0tZXNwZWNpYWxseVxuICAgaW4gdGhlIGNhc2Ugd2hlcmUgdGhlIGNhcHR1cmUgb2YgYmFja3RyYWNlcyBpcyBlbmFibGVkIHVwb24gXCJ3aXRoXCItLS1hbmQgdGhhdCBzZWVtc1xuICAgbm90IHdvcnRoIGl0IHdoZW4gY29tcGFyZWQgdG8gdGhlIHJlbGF0aXZlbHkgc21hbGwgYW1vdW50IG9mIGNvZGUgZHVwbGljYXRpb24uKSAqKVxuXG4oKiBFcnJvciByZXBvcnRpbmcgYmVsb3cgaXMgdmVyeSBjYXJlZnVsbHkgYXJyYW5nZWQgc28gdGhhdCwgZS5nLiwgW2lyb3VuZF9uZWFyZXN0X2V4bl1cbiAgIGl0c2VsZiBjYW4gYmUgaW5saW5lZCBpbnRvIGNhbGxlcnMgc3VjaCB0aGF0IHRoZXkgZG9uJ3QgbmVlZCB0byBhbGxvY2F0ZSBhIGJveCBmb3IgdGhlXG4gICBbZmxvYXRdIGFyZ3VtZW50LiAgVGhpcyBpcyBkb25lIHdpdGggYSBib3ggW2JveF0gZnVuY3Rpb24gY2FyZWZ1bGx5IGNob3NlbiB0byBhbGxvdyB0aGVcbiAgIGNvbXBpbGVyIHRvIGNyZWF0ZSBhIHNlcGFyYXRlIGJveCBmb3IgdGhlIGZsb2F0IG9ubHkgaW4gZXJyb3IgY2FzZXMuICBTZWUsIGUuZy4sXG4gICBbLi4vLi4vemVyby90ZXN0L3ByaWNlX3Rlc3QubWxdIGZvciBhIG1lY2hhbmljYWwgdGVzdCBvZiB0aGlzIHByb3BlcnR5IHdoZW4gYnVpbGRpbmdcbiAgIHdpdGggW1hfTElCUkFSWV9JTkxJTklORz10cnVlXS4gKilcblxubGV0IGlyb3VuZF91cCB0ID1cbiAgaWYgdCA+IDAuMFxuICB0aGVuIChcbiAgICBsZXQgdCcgPSBjZWlsIHQgaW5cbiAgICBpZiB0JyA8PSBpcm91bmRfdWJvdW5kIHRoZW4gU29tZSAoSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0JykgZWxzZSBOb25lKVxuICBlbHNlIGlmIHQgPj0gaXJvdW5kX2xib3VuZFxuICB0aGVuIFNvbWUgKEludC5vZl9mbG9hdF91bmNoZWNrZWQgdClcbiAgZWxzZSBOb25lXG47O1xuXG5sZXRbQG9jYW1sLmlubGluZSBhbHdheXNdIGlyb3VuZF91cF9leG4gdCA9XG4gIGlmIHQgPiAwLjBcbiAgdGhlbiAoXG4gICAgbGV0IHQnID0gY2VpbCB0IGluXG4gICAgaWYgdCcgPD0gaXJvdW5kX3Vib3VuZFxuICAgIHRoZW4gSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0J1xuICAgIGVsc2UgaW52YWxpZF9hcmdmIFwiRmxvYXQuaXJvdW5kX3VwX2V4bjogYXJndW1lbnQgKCVmKSBpcyB0b28gbGFyZ2VcIiAoYm94IHQpICgpKVxuICBlbHNlIGlmIHQgPj0gaXJvdW5kX2xib3VuZFxuICB0aGVuIEludC5vZl9mbG9hdF91bmNoZWNrZWQgdFxuICBlbHNlIGludmFsaWRfYXJnZiBcIkZsb2F0Lmlyb3VuZF91cF9leG46IGFyZ3VtZW50ICglZikgaXMgdG9vIHNtYWxsIG9yIE5hTlwiIChib3ggdCkgKClcbjs7XG5cbmxldCBpcm91bmRfZG93biB0ID1cbiAgaWYgdCA+PSAwLjBcbiAgdGhlbiBpZiB0IDw9IGlyb3VuZF91Ym91bmQgdGhlbiBTb21lIChJbnQub2ZfZmxvYXRfdW5jaGVja2VkIHQpIGVsc2UgTm9uZVxuICBlbHNlIChcbiAgICBsZXQgdCcgPSBmbG9vciB0IGluXG4gICAgaWYgdCcgPj0gaXJvdW5kX2xib3VuZCB0aGVuIFNvbWUgKEludC5vZl9mbG9hdF91bmNoZWNrZWQgdCcpIGVsc2UgTm9uZSlcbjs7XG5cbmxldFtAb2NhbWwuaW5saW5lIGFsd2F5c10gaXJvdW5kX2Rvd25fZXhuIHQgPVxuICBpZiB0ID49IDAuMFxuICB0aGVuXG4gICAgaWYgdCA8PSBpcm91bmRfdWJvdW5kXG4gICAgdGhlbiBJbnQub2ZfZmxvYXRfdW5jaGVja2VkIHRcbiAgICBlbHNlIGludmFsaWRfYXJnZiBcIkZsb2F0Lmlyb3VuZF9kb3duX2V4bjogYXJndW1lbnQgKCVmKSBpcyB0b28gbGFyZ2VcIiAoYm94IHQpICgpXG4gIGVsc2UgKFxuICAgIGxldCB0JyA9IGZsb29yIHQgaW5cbiAgICBpZiB0JyA+PSBpcm91bmRfbGJvdW5kXG4gICAgdGhlbiBJbnQub2ZfZmxvYXRfdW5jaGVja2VkIHQnXG4gICAgZWxzZVxuICAgICAgaW52YWxpZF9hcmdmIFwiRmxvYXQuaXJvdW5kX2Rvd25fZXhuOiBhcmd1bWVudCAoJWYpIGlzIHRvbyBzbWFsbCBvciBOYU5cIiAoYm94IHQpICgpKVxuOztcblxubGV0IGlyb3VuZF90b3dhcmRzX3plcm8gdCA9XG4gIGlmIHQgPj0gaXJvdW5kX2xib3VuZCAmJiB0IDw9IGlyb3VuZF91Ym91bmRcbiAgdGhlbiBTb21lIChJbnQub2ZfZmxvYXRfdW5jaGVja2VkIHQpXG4gIGVsc2UgTm9uZVxuOztcblxubGV0W0BvY2FtbC5pbmxpbmUgYWx3YXlzXSBpcm91bmRfdG93YXJkc196ZXJvX2V4biB0ID1cbiAgaWYgdCA+PSBpcm91bmRfbGJvdW5kICYmIHQgPD0gaXJvdW5kX3Vib3VuZFxuICB0aGVuIEludC5vZl9mbG9hdF91bmNoZWNrZWQgdFxuICBlbHNlXG4gICAgaW52YWxpZF9hcmdmXG4gICAgICBcIkZsb2F0Lmlyb3VuZF90b3dhcmRzX3plcm9fZXhuOiBhcmd1bWVudCAoJWYpIGlzIG91dCBvZiByYW5nZSBvciBOYU5cIlxuICAgICAgKGJveCB0KVxuICAgICAgKClcbjs7XG5cbigqIE91dHNpZGUgb2YgdGhlIHJhbmdlIChyb3VuZF9uZWFyZXN0X2xiLi5yb3VuZF9uZWFyZXN0X3ViKSwgYWxsIHJlcHJlc2VudGFibGUgZG91Ymxlc1xuICAgYXJlIGludGVnZXJzIGluIHRoZSBtYXRoZW1hdGljYWwgc2Vuc2UsIGFuZCBbcm91bmRfbmVhcmVzdF0gc2hvdWxkIGJlIGlkZW50aXR5LlxuXG4gICBIb3dldmVyLCBmb3Igb2RkIG51bWJlcnMgd2l0aCB0aGUgYWJzb2x1dGUgdmFsdWUgYmV0d2VlbiAyKio1MiBhbmQgMioqNTMsIHRoZSBmb3JtdWxhXG4gICBbcm91bmRfbmVhcmVzdCB4ID0gZmxvb3IgKHggKyAwLjUpXSBkb2VzIG5vdCBob2xkOlxuXG4gICB7dlxuICAgICAjIGxldCBuYWl2ZV9yb3VuZF9uZWFyZXN0IHggPSBmbG9vciAoeCArLiAwLjUpOztcbiAgICAgIyBsZXQgeCA9IDIuICoqIDUyLiArLiAxLjs7XG4gICAgIHZhbCB4IDogZmxvYXQgPSA0NTAzNTk5NjI3MzcwNDk3LlxuICAgICAjIG5haXZlX3JvdW5kX25lYXJlc3QgeDs7XG4gICAgIC0gOiAgICAgZmxvYXQgPSA0NTAzNTk5NjI3MzcwNDk4LlxuICAgdn1cbiopXG5cbmxldCByb3VuZF9uZWFyZXN0X2xiID0gLS4oMi4gKiogNTIuKVxubGV0IHJvdW5kX25lYXJlc3RfdWIgPSAyLiAqKiA1Mi5cblxuKCogRm9yIFt4ID0gb25lX3VscCBgRG93biAwLjVdLCB0aGUgZm9ybXVsYSBbZmxvb3IgKHggKy4gMC41KV0gZm9yIHJvdW5kaW5nIHRvIG5lYXJlc3RcbiAgIGRvZXMgbm90IHdvcmssIGJlY2F1c2UgdGhlIGV4YWN0IHJlc3VsdCBpcyBoYWxmd2F5IGJldHdlZW4gW29uZV91bHAgYERvd24gMS5dIGFuZCBbMS5dLFxuICAgYW5kIGl0IGdldHMgcm91bmRlZCB1cCB0byBbMS5dIGR1ZSB0byB0aGUgcm91bmQtdGllcy10by1ldmVuIHJ1bGUuICopXG5sZXQgb25lX3VscF9sZXNzX3RoYW5faGFsZiA9IG9uZV91bHAgYERvd24gMC41XG5cbmxldFtAb2NhbWwuaW5saW5lIGFsd2F5c10gYWRkX2hhbGZfZm9yX3JvdW5kX25lYXJlc3QgdCA9XG4gIHRcbiAgKy5cbiAgaWYgdCA9IG9uZV91bHBfbGVzc190aGFuX2hhbGZcbiAgdGhlbiBvbmVfdWxwX2xlc3NfdGhhbl9oYWxmICgqIHNpbmNlIHQgPCAwLjUsIG1ha2Ugc3VyZSB0aGUgcmVzdWx0IGlzIDwgMS4wICopXG4gIGVsc2UgMC41XG47O1xuXG5sZXQgaXJvdW5kX25lYXJlc3RfMzIgdCA9XG4gIGlmIHQgPj0gMC5cbiAgdGhlbiAoXG4gICAgbGV0IHQnID0gYWRkX2hhbGZfZm9yX3JvdW5kX25lYXJlc3QgdCBpblxuICAgIGlmIHQnIDw9IGlyb3VuZF91Ym91bmQgdGhlbiBTb21lIChJbnQub2ZfZmxvYXRfdW5jaGVja2VkIHQnKSBlbHNlIE5vbmUpXG4gIGVsc2UgKFxuICAgIGxldCB0JyA9IGZsb29yICh0ICsuIDAuNSkgaW5cbiAgICBpZiB0JyA+PSBpcm91bmRfbGJvdW5kIHRoZW4gU29tZSAoSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0JykgZWxzZSBOb25lKVxuOztcblxubGV0IGlyb3VuZF9uZWFyZXN0XzY0IHQgPVxuICBpZiB0ID49IDAuXG4gIHRoZW5cbiAgICBpZiB0IDwgcm91bmRfbmVhcmVzdF91YlxuICAgIHRoZW4gU29tZSAoSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCAoYWRkX2hhbGZfZm9yX3JvdW5kX25lYXJlc3QgdCkpXG4gICAgZWxzZSBpZiB0IDw9IGlyb3VuZF91Ym91bmRcbiAgICB0aGVuIFNvbWUgKEludC5vZl9mbG9hdF91bmNoZWNrZWQgdClcbiAgICBlbHNlIE5vbmVcbiAgZWxzZSBpZiB0ID4gcm91bmRfbmVhcmVzdF9sYlxuICB0aGVuIFNvbWUgKEludC5vZl9mbG9hdF91bmNoZWNrZWQgKGZsb29yICh0ICsuIDAuNSkpKVxuICBlbHNlIGlmIHQgPj0gaXJvdW5kX2xib3VuZFxuICB0aGVuIFNvbWUgKEludC5vZl9mbG9hdF91bmNoZWNrZWQgdClcbiAgZWxzZSBOb25lXG47O1xuXG5sZXQgaXJvdW5kX25lYXJlc3QgPVxuICBtYXRjaCBXb3JkX3NpemUud29yZF9zaXplIHdpdGhcbiAgfCBXNjQgLT4gaXJvdW5kX25lYXJlc3RfNjRcbiAgfCBXMzIgLT4gaXJvdW5kX25lYXJlc3RfMzJcbjs7XG5cbmxldCBpcm91bmRfbmVhcmVzdF9leG5fMzIgdCA9XG4gIGlmIHQgPj0gMC5cbiAgdGhlbiAoXG4gICAgbGV0IHQnID0gYWRkX2hhbGZfZm9yX3JvdW5kX25lYXJlc3QgdCBpblxuICAgIGlmIHQnIDw9IGlyb3VuZF91Ym91bmRcbiAgICB0aGVuIEludC5vZl9mbG9hdF91bmNoZWNrZWQgdCdcbiAgICBlbHNlIGludmFsaWRfYXJnZiBcIkZsb2F0Lmlyb3VuZF9uZWFyZXN0X2V4bjogYXJndW1lbnQgKCVmKSBpcyB0b28gbGFyZ2VcIiAoYm94IHQpICgpKVxuICBlbHNlIChcbiAgICBsZXQgdCcgPSBmbG9vciAodCArLiAwLjUpIGluXG4gICAgaWYgdCcgPj0gaXJvdW5kX2xib3VuZFxuICAgIHRoZW4gSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0J1xuICAgIGVsc2UgaW52YWxpZF9hcmdmIFwiRmxvYXQuaXJvdW5kX25lYXJlc3RfZXhuOiBhcmd1bWVudCAoJWYpIGlzIHRvbyBzbWFsbFwiIChib3ggdCkgKCkpXG47O1xuXG5sZXRbQG9jYW1sLmlubGluZSBhbHdheXNdIGlyb3VuZF9uZWFyZXN0X2V4bl82NCB0ID1cbiAgaWYgdCA+PSAwLlxuICB0aGVuXG4gICAgaWYgdCA8IHJvdW5kX25lYXJlc3RfdWJcbiAgICB0aGVuIEludC5vZl9mbG9hdF91bmNoZWNrZWQgKGFkZF9oYWxmX2Zvcl9yb3VuZF9uZWFyZXN0IHQpXG4gICAgZWxzZSBpZiB0IDw9IGlyb3VuZF91Ym91bmRcbiAgICB0aGVuIEludC5vZl9mbG9hdF91bmNoZWNrZWQgdFxuICAgIGVsc2UgaW52YWxpZF9hcmdmIFwiRmxvYXQuaXJvdW5kX25lYXJlc3RfZXhuOiBhcmd1bWVudCAoJWYpIGlzIHRvbyBsYXJnZVwiIChib3ggdCkgKClcbiAgZWxzZSBpZiB0ID4gcm91bmRfbmVhcmVzdF9sYlxuICB0aGVuIEludC5vZl9mbG9hdF91bmNoZWNrZWQgKGZsb29yICh0ICsuIDAuNSkpXG4gIGVsc2UgaWYgdCA+PSBpcm91bmRfbGJvdW5kXG4gIHRoZW4gSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0XG4gIGVsc2VcbiAgICBpbnZhbGlkX2FyZ2YgXCJGbG9hdC5pcm91bmRfbmVhcmVzdF9leG46IGFyZ3VtZW50ICglZikgaXMgdG9vIHNtYWxsIG9yIE5hTlwiIChib3ggdCkgKClcbjs7XG5cbmxldCBpcm91bmRfbmVhcmVzdF9leG4gPVxuICBtYXRjaCBXb3JkX3NpemUud29yZF9zaXplIHdpdGhcbiAgfCBXNjQgLT4gaXJvdW5kX25lYXJlc3RfZXhuXzY0XG4gIHwgVzMyIC0+IGlyb3VuZF9uZWFyZXN0X2V4bl8zMlxuOztcblxuKCogVGhlIGZvbGxvd2luZyBbaXJvdW5kX2V4bl0gYW5kIFtpcm91bmRdIGZ1bmN0aW9ucyBhcmUgc2xvd2VyIHRoYW4gdGhlIG9uZXMgYWJvdmUuXG4gICBUaGVpciBlcXVpdmFsZW5jZSB0byB0aG9zZSBmdW5jdGlvbnMgaXMgdGVzdGVkIGluIHRoZSB1bml0IHRlc3RzIGJlbG93LiAqKVxuXG5sZXRbQGlubGluZV0gaXJvdW5kX2V4biA/KGRpciA9IGBOZWFyZXN0KSB0ID1cbiAgbWF0Y2ggZGlyIHdpdGhcbiAgfCBgWmVybyAtPiBpcm91bmRfdG93YXJkc196ZXJvX2V4biB0XG4gIHwgYE5lYXJlc3QgLT4gaXJvdW5kX25lYXJlc3RfZXhuIHRcbiAgfCBgVXAgLT4gaXJvdW5kX3VwX2V4biB0XG4gIHwgYERvd24gLT4gaXJvdW5kX2Rvd25fZXhuIHRcbjs7XG5cbmxldCBpcm91bmQgPyhkaXIgPSBgTmVhcmVzdCkgdCA9XG4gIHRyeSBTb21lIChpcm91bmRfZXhuIH5kaXIgdCkgd2l0aFxuICB8IF8gLT4gTm9uZVxuOztcblxubGV0IGlzX2luZiB0ID0gMS4gLy4gdCA9IDAuXG5sZXQgaXNfZmluaXRlIHQgPSB0IC0uIHQgPSAwLlxuXG5sZXQgbWluX2luYW4gKHggOiB0KSB5ID1cbiAgaWYgaXNfbmFuIHkgdGhlbiB4IGVsc2UgaWYgaXNfbmFuIHggdGhlbiB5IGVsc2UgaWYgeCA8IHkgdGhlbiB4IGVsc2UgeVxuOztcblxubGV0IG1heF9pbmFuICh4IDogdCkgeSA9XG4gIGlmIGlzX25hbiB5IHRoZW4geCBlbHNlIGlmIGlzX25hbiB4IHRoZW4geSBlbHNlIGlmIHggPiB5IHRoZW4geCBlbHNlIHlcbjs7XG5cbmxldCBhZGQgPSAoICsuIClcbmxldCBzdWIgPSAoIC0uIClcbmxldCBuZWcgPSAoIH4tLiApXG5sZXQgYWJzID0gYWJzX2Zsb2F0XG5sZXQgc2NhbGUgPSAoICouIClcbmxldCBzcXVhcmUgeCA9IHggKi4geFxuXG5tb2R1bGUgUGFydHMgOiBzaWdcbiAgdHlwZSB0XG5cbiAgdmFsIGZyYWN0aW9uYWwgOiB0IC0+IGZsb2F0XG4gIHZhbCBpbnRlZ3JhbCA6IHQgLT4gZmxvYXRcbiAgdmFsIG1vZGYgOiBmbG9hdCAtPiB0XG5lbmQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gZmxvYXQgKiBmbG9hdFxuXG4gIGxldCBmcmFjdGlvbmFsIHQgPSBmc3QgdFxuICBsZXQgaW50ZWdyYWwgdCA9IHNuZCB0XG4gIGxldCBtb2RmID0gbW9kZlxuZW5kXG5cbmxldCBtb2RmID0gUGFydHMubW9kZlxubGV0IHJvdW5kX2Rvd24gPSBmbG9vclxubGV0IHJvdW5kX3VwID0gY2VpbFxubGV0IHJvdW5kX3Rvd2FyZHNfemVybyB0ID0gaWYgdCA+PSAwLiB0aGVuIHJvdW5kX2Rvd24gdCBlbHNlIHJvdW5kX3VwIHRcblxuKCogc2VlIHRoZSBjb21tZW50IGFib3ZlIFtyb3VuZF9uZWFyZXN0X2xiXSBhbmQgW3JvdW5kX25lYXJlc3RfdWJdIGZvciBhbiBleHBsYW5hdGlvbiAqKVxubGV0W0BvY2FtbC5pbmxpbmVdIHJvdW5kX25lYXJlc3RfaW5saW5lIHQgPVxuICBpZiB0ID4gcm91bmRfbmVhcmVzdF9sYiAmJiB0IDwgcm91bmRfbmVhcmVzdF91YlxuICB0aGVuIGZsb29yIChhZGRfaGFsZl9mb3Jfcm91bmRfbmVhcmVzdCB0KVxuICBlbHNlIHQgKy4gMC5cbjs7XG5cbmxldCByb3VuZF9uZWFyZXN0IHQgPSAocm91bmRfbmVhcmVzdF9pbmxpbmUgW0BvY2FtbC5pbmxpbmVkIGFsd2F5c10pIHRcblxubGV0IHJvdW5kX25lYXJlc3RfaGFsZl90b19ldmVuIHQgPVxuICBpZiB0IDw9IHJvdW5kX25lYXJlc3RfbGIgfHwgdCA+PSByb3VuZF9uZWFyZXN0X3ViXG4gIHRoZW4gdCArLiAwLlxuICBlbHNlIChcbiAgICBsZXQgZmxvb3IgPSBmbG9vciB0IGluXG4gICAgKCogW2NlaWxfb3Jfc3VjYyA9IGlmIHQgaXMgYW4gaW50ZWdlciB0aGVuIHQgKy4gMS4gZWxzZSBjZWlsIHRdLiAgRmFzdGVyIHRoYW4gW2NlaWxdLiAqKVxuICAgIGxldCBjZWlsX29yX3N1Y2MgPSBmbG9vciArLiAxLiBpblxuICAgIGxldCBkaWZmX2Zsb29yID0gdCAtLiBmbG9vciBpblxuICAgIGxldCBkaWZmX2NlaWwgPSBjZWlsX29yX3N1Y2MgLS4gdCBpblxuICAgIGlmIGRpZmZfZmxvb3IgPCBkaWZmX2NlaWxcbiAgICB0aGVuIGZsb29yXG4gICAgZWxzZSBpZiBkaWZmX2Zsb29yID4gZGlmZl9jZWlsXG4gICAgdGhlbiBjZWlsX29yX3N1Y2NcbiAgICBlbHNlIGlmICgqIGV4YWN0IHRpZSwgcGljayB0aGUgZXZlbiAqKVxuICAgICAgbW9kX2Zsb2F0IGZsb29yIDIuID0gMC5cbiAgICB0aGVuIGZsb29yXG4gICAgZWxzZSBjZWlsX29yX3N1Y2MpXG47O1xuXG5sZXQgaW50NjNfcm91bmRfbGJvdW5kID0gbG93ZXJfYm91bmRfZm9yX2ludCBJbnQ2My5udW1fYml0c1xubGV0IGludDYzX3JvdW5kX3Vib3VuZCA9IHVwcGVyX2JvdW5kX2Zvcl9pbnQgSW50NjMubnVtX2JpdHNcblxubGV0IGludDYzX3JvdW5kX3VwX2V4biB0ID1cbiAgaWYgdCA+IDAuMFxuICB0aGVuIChcbiAgICBsZXQgdCcgPSBjZWlsIHQgaW5cbiAgICBpZiB0JyA8PSBpbnQ2M19yb3VuZF91Ym91bmRcbiAgICB0aGVuIEludDYzLm9mX2Zsb2F0X3VuY2hlY2tlZCB0J1xuICAgIGVsc2VcbiAgICAgIGludmFsaWRfYXJnZlxuICAgICAgICBcIkZsb2F0LmludDYzX3JvdW5kX3VwX2V4bjogYXJndW1lbnQgKCVmKSBpcyB0b28gbGFyZ2VcIlxuICAgICAgICAoRmxvYXQwLmJveCB0KVxuICAgICAgICAoKSlcbiAgZWxzZSBpZiB0ID49IGludDYzX3JvdW5kX2xib3VuZFxuICB0aGVuIEludDYzLm9mX2Zsb2F0X3VuY2hlY2tlZCB0XG4gIGVsc2VcbiAgICBpbnZhbGlkX2FyZ2ZcbiAgICAgIFwiRmxvYXQuaW50NjNfcm91bmRfdXBfZXhuOiBhcmd1bWVudCAoJWYpIGlzIHRvbyBzbWFsbCBvciBOYU5cIlxuICAgICAgKEZsb2F0MC5ib3ggdClcbiAgICAgICgpXG47O1xuXG5sZXQgaW50NjNfcm91bmRfZG93bl9leG4gdCA9XG4gIGlmIHQgPj0gMC4wXG4gIHRoZW5cbiAgICBpZiB0IDw9IGludDYzX3JvdW5kX3Vib3VuZFxuICAgIHRoZW4gSW50NjMub2ZfZmxvYXRfdW5jaGVja2VkIHRcbiAgICBlbHNlXG4gICAgICBpbnZhbGlkX2FyZ2ZcbiAgICAgICAgXCJGbG9hdC5pbnQ2M19yb3VuZF9kb3duX2V4bjogYXJndW1lbnQgKCVmKSBpcyB0b28gbGFyZ2VcIlxuICAgICAgICAoRmxvYXQwLmJveCB0KVxuICAgICAgICAoKVxuICBlbHNlIChcbiAgICBsZXQgdCcgPSBmbG9vciB0IGluXG4gICAgaWYgdCcgPj0gaW50NjNfcm91bmRfbGJvdW5kXG4gICAgdGhlbiBJbnQ2My5vZl9mbG9hdF91bmNoZWNrZWQgdCdcbiAgICBlbHNlXG4gICAgICBpbnZhbGlkX2FyZ2ZcbiAgICAgICAgXCJGbG9hdC5pbnQ2M19yb3VuZF9kb3duX2V4bjogYXJndW1lbnQgKCVmKSBpcyB0b28gc21hbGwgb3IgTmFOXCJcbiAgICAgICAgKEZsb2F0MC5ib3ggdClcbiAgICAgICAgKCkpXG47O1xuXG5sZXQgaW50NjNfcm91bmRfbmVhcmVzdF9wb3J0YWJsZV9hbGxvY19leG4gdDAgPVxuICBsZXQgdCA9IChyb3VuZF9uZWFyZXN0X2lubGluZSBbQG9jYW1sLmlubGluZWQgYWx3YXlzXSkgdDAgaW5cbiAgaWYgdCA+IDAuXG4gIHRoZW5cbiAgICBpZiB0IDw9IGludDYzX3JvdW5kX3Vib3VuZFxuICAgIHRoZW4gSW50NjMub2ZfZmxvYXRfdW5jaGVja2VkIHRcbiAgICBlbHNlXG4gICAgICBpbnZhbGlkX2FyZ2ZcbiAgICAgICAgXCJGbG9hdC5pbnQ2M19yb3VuZF9uZWFyZXN0X3BvcnRhYmxlX2FsbG9jX2V4bjogYXJndW1lbnQgKCVmKSBpcyB0b28gbGFyZ2VcIlxuICAgICAgICAoYm94IHQwKVxuICAgICAgICAoKVxuICBlbHNlIGlmIHQgPj0gaW50NjNfcm91bmRfbGJvdW5kXG4gIHRoZW4gSW50NjMub2ZfZmxvYXRfdW5jaGVja2VkIHRcbiAgZWxzZVxuICAgIGludmFsaWRfYXJnZlxuICAgICAgXCJGbG9hdC5pbnQ2M19yb3VuZF9uZWFyZXN0X3BvcnRhYmxlX2FsbG9jX2V4bjogYXJndW1lbnQgKCVmKSBpcyB0b28gc21hbGwgb3IgTmFOXCJcbiAgICAgIChib3ggdDApXG4gICAgICAoKVxuOztcblxubGV0IGludDYzX3JvdW5kX25lYXJlc3RfYXJjaDY0X25vYWxsb2NfZXhuIGYgPSBJbnQ2My5vZl9pbnQgKGlyb3VuZF9uZWFyZXN0X2V4biBmKVxuXG5sZXQgaW50NjNfcm91bmRfbmVhcmVzdF9leG4gPVxuICBtYXRjaCBXb3JkX3NpemUud29yZF9zaXplIHdpdGhcbiAgfCBXNjQgLT4gaW50NjNfcm91bmRfbmVhcmVzdF9hcmNoNjRfbm9hbGxvY19leG5cbiAgfCBXMzIgLT4gaW50NjNfcm91bmRfbmVhcmVzdF9wb3J0YWJsZV9hbGxvY19leG5cbjs7XG5cbmxldCByb3VuZCA/KGRpciA9IGBOZWFyZXN0KSB0ID1cbiAgbWF0Y2ggZGlyIHdpdGhcbiAgfCBgTmVhcmVzdCAtPiByb3VuZF9uZWFyZXN0IHRcbiAgfCBgRG93biAtPiByb3VuZF9kb3duIHRcbiAgfCBgVXAgLT4gcm91bmRfdXAgdFxuICB8IGBaZXJvIC0+IHJvdW5kX3Rvd2FyZHNfemVybyB0XG47O1xuXG5tb2R1bGUgQ2xhc3MgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB8IEluZmluaXRlXG4gICAgfCBOYW5cbiAgICB8IE5vcm1hbFxuICAgIHwgU3Vibm9ybWFsXG4gICAgfCBaZXJvXG4gIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlbnVtZXJhdGUsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZSA9IChQcHhfY29tcGFyZV9saWIucG9seW1vcnBoaWNfY29tcGFyZSA6IHQgLT4gdCAtPiBpbnQpXG4gIGxldCBhbGwgPSAoWyBJbmZpbml0ZTsgTmFuOyBOb3JtYWw7IFN1Ym5vcm1hbDsgWmVybyBdIDogdCBsaXN0KVxuXG4gIGxldCB0X29mX3NleHAgPVxuICAgIChsZXQgZXJyb3Jfc291cmNlX18wMDZfID0gXCJmbG9hdC5tbC5DbGFzcy50XCIgaW5cbiAgICAgZnVuY3Rpb25cbiAgICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwiaW5maW5pdGVcIiB8IFwiSW5maW5pdGVcIikgLT4gSW5maW5pdGVcbiAgICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwibmFuXCIgfCBcIk5hblwiKSAtPiBOYW5cbiAgICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwibm9ybWFsXCIgfCBcIk5vcm1hbFwiKSAtPiBOb3JtYWxcbiAgICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwic3Vibm9ybWFsXCIgfCBcIlN1Ym5vcm1hbFwiKSAtPiBTdWJub3JtYWxcbiAgICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwiemVyb1wiIHwgXCJaZXJvXCIpIC0+IFplcm9cbiAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJpbmZpbml0ZVwiIHwgXCJJbmZpbml0ZVwiKSA6OiBfKSBhc1xuICAgICAgIHNleHBfXzAwN18gLT4gU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAwNl8gc2V4cF9fMDA3X1xuICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcIm5hblwiIHwgXCJOYW5cIikgOjogXykgYXMgc2V4cF9fMDA3XyAtPlxuICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMDZfIHNleHBfXzAwN19cbiAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJub3JtYWxcIiB8IFwiTm9ybWFsXCIpIDo6IF8pIGFzIHNleHBfXzAwN18gLT5cbiAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDA2XyBzZXhwX18wMDdfXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gKFwic3Vibm9ybWFsXCIgfCBcIlN1Ym5vcm1hbFwiKSA6OiBfKSBhc1xuICAgICAgIHNleHBfXzAwN18gLT4gU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAwNl8gc2V4cF9fMDA3X1xuICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcInplcm9cIiB8IFwiWmVyb1wiKSA6OiBfKSBhcyBzZXhwX18wMDdfIC0+XG4gICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAwNl8gc2V4cF9fMDA3X1xuICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5MaXN0IF8gOjogXykgYXMgc2V4cF9fMDA1XyAtPlxuICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5uZXN0ZWRfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAwNl8gc2V4cF9fMDA1X1xuICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCBbXSBhcyBzZXhwX18wMDVfIC0+XG4gICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLmVtcHR5X2xpc3RfaW52YWxpZF9zdW0gZXJyb3Jfc291cmNlX18wMDZfIHNleHBfXzAwNV9cbiAgICAgfCBzZXhwX18wMDVfIC0+XG4gICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnVuZXhwZWN0ZWRfc3RhZyBlcnJvcl9zb3VyY2VfXzAwNl8gc2V4cF9fMDA1X1xuICAgICAgIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCA9XG4gICAgKGZ1bmN0aW9uXG4gICAgICB8IEluZmluaXRlIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIkluZmluaXRlXCJcbiAgICAgIHwgTmFuIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIk5hblwiXG4gICAgICB8IE5vcm1hbCAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJOb3JtYWxcIlxuICAgICAgfCBTdWJub3JtYWwgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiU3Vibm9ybWFsXCJcbiAgICAgIHwgWmVybyAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJaZXJvXCJcbiAgICAgICAgICAgICAgICA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICA7O1xuXG4gIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9XG4gICAgeyB1bnR5cGVkID1cbiAgICAgICAgVmFyaWFudFxuICAgICAgICAgIHsgY2FzZV9zZW5zaXRpdml0eSA9IENhc2Vfc2Vuc2l0aXZlX2V4Y2VwdF9maXJzdF9jaGFyYWN0ZXJcbiAgICAgICAgICA7IGNsYXVzZXMgPVxuICAgICAgICAgICAgICBbIE5vX3RhZyB7IG5hbWUgPSBcIkluZmluaXRlXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgICA7IE5vX3RhZyB7IG5hbWUgPSBcIk5hblwiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgICAgOyBOb190YWcgeyBuYW1lID0gXCJOb3JtYWxcIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICAgIDsgTm9fdGFnIHsgbmFtZSA9IFwiU3Vibm9ybWFsXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgICA7IE5vX3RhZyB7IG5hbWUgPSBcIlplcm9cIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICB9XG4gICAgfVxuICA7O1xuXG4gIFtAQEBlbmRdXG5cbiAgbGV0IHRvX3N0cmluZyB0ID0gc3RyaW5nX29mX3NleHAgKHNleHBfb2ZfdCB0KVxuICBsZXQgb2Zfc3RyaW5nIHMgPSB0X29mX3NleHAgKHNleHBfb2Zfc3RyaW5nIHMpXG5lbmRcblxubGV0IGNsYXNzaWZ5IHQgPVxuICBsZXQgbW9kdWxlIEMgPSBDbGFzcyBpblxuICBtYXRjaCBjbGFzc2lmeV9mbG9hdCB0IHdpdGhcbiAgfCBGUF9ub3JtYWwgLT4gQy5Ob3JtYWxcbiAgfCBGUF9zdWJub3JtYWwgLT4gQy5TdWJub3JtYWxcbiAgfCBGUF96ZXJvIC0+IEMuWmVyb1xuICB8IEZQX2luZmluaXRlIC0+IEMuSW5maW5pdGVcbiAgfCBGUF9uYW4gLT4gQy5OYW5cbjs7XG5cbmxldCBpbnNlcnRfdW5kZXJzY29yZXMgPyhkZWxpbWl0ZXIgPSAnXycpID8oc3RyaXBfemVybyA9IGZhbHNlKSBzdHJpbmcgPVxuICBtYXRjaCBTdHJpbmcubHNwbGl0MiBzdHJpbmcgfm9uOicuJyB3aXRoXG4gIHwgTm9uZSAtPiBJbnRfY29udmVyc2lvbnMuaW5zZXJ0X2RlbGltaXRlciBzdHJpbmcgfmRlbGltaXRlclxuICB8IFNvbWUgKGxlZnQsIHJpZ2h0KSAtPlxuICAgIGxldCBsZWZ0ID0gSW50X2NvbnZlcnNpb25zLmluc2VydF9kZWxpbWl0ZXIgbGVmdCB+ZGVsaW1pdGVyIGluXG4gICAgbGV0IHJpZ2h0ID1cbiAgICAgIGlmIHN0cmlwX3plcm8gdGhlbiBTdHJpbmcucnN0cmlwIHJpZ2h0IH5kcm9wOihmdW4gYyAtPiBDaGFyLiggPSApIGMgJzAnKSBlbHNlIHJpZ2h0XG4gICAgaW5cbiAgICAobWF0Y2ggcmlnaHQgd2l0aFxuICAgICB8IFwiXCIgLT4gbGVmdFxuICAgICB8IF8gLT4gbGVmdCBeIFwiLlwiIF4gcmlnaHQpXG47O1xuXG5sZXQgdG9fc3RyaW5nX2h1bSA/ZGVsaW1pdGVyID8oZGVjaW1hbHMgPSAzKSA/c3RyaXBfemVybyA/KGV4cGxpY2l0X3BsdXMgPSBmYWxzZSkgZiA9XG4gIGlmIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA8ICkgZGVjaW1hbHMgMFxuICB0aGVuIGludmFsaWRfYXJnZiBcInRvX3N0cmluZ19odW06IGludmFsaWQgYXJndW1lbnQgfmRlY2ltYWxzPSVkXCIgZGVjaW1hbHMgKCk7XG4gIG1hdGNoIGNsYXNzaWZ5IGYgd2l0aFxuICB8IENsYXNzLkluZmluaXRlIC0+IGlmIGYgPiAwLiB0aGVuIFwiaW5mXCIgZWxzZSBcIi1pbmZcIlxuICB8IENsYXNzLk5hbiAtPiBcIm5hblwiXG4gIHwgQ2xhc3MuTm9ybWFsIHwgQ2xhc3MuU3Vibm9ybWFsIHwgQ2xhc3MuWmVybyAtPlxuICAgIGxldCBzID1cbiAgICAgIGlmIGV4cGxpY2l0X3BsdXMgdGhlbiBzcHJpbnRmIFwiJSsuKmZcIiBkZWNpbWFscyBmIGVsc2Ugc3ByaW50ZiBcIiUuKmZcIiBkZWNpbWFscyBmXG4gICAgaW5cbiAgICBpbnNlcnRfdW5kZXJzY29yZXMgcyA/ZGVsaW1pdGVyID9zdHJpcF96ZXJvXG47O1xuXG5sZXQgc2V4cF9vZl90IHQgPVxuICBsZXQgc2V4cCA9IHNleHBfb2ZfdCB0IGluXG4gIG1hdGNoICFTZXhwLm9mX2Zsb2F0X3N0eWxlIHdpdGhcbiAgfCBgTm9fdW5kZXJzY29yZXMgLT4gc2V4cFxuICB8IGBVbmRlcnNjb3JlcyAtPlxuICAgIChtYXRjaCBzZXhwIHdpdGhcbiAgICAgfCBMaXN0IF8gLT5cbiAgICAgICByYWlzZV9zXG4gICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgICBcIltzZXhwX29mX2Zsb2F0XSBwcm9kdWNlZCBzdHJhbmdlIHNleHBcIlxuICAgICAgICAgICAgWyBcInNleHBcIiwgU2V4cC5zZXhwX29mX3Qgc2V4cCBdKVxuICAgICB8IEF0b20gc3RyaW5nIC0+XG4gICAgICAgaWYgU3RyaW5nLmNvbnRhaW5zIHN0cmluZyAnRScgdGhlbiBzZXhwIGVsc2UgQXRvbSAoaW5zZXJ0X3VuZGVyc2NvcmVzIHN0cmluZykpXG47O1xuXG5sZXQgdG9fcGFkZGVkX2NvbXBhY3Rfc3RyaW5nX2N1c3RvbSB0ID8ocHJlZml4ID0gXCJcIikgfmtpbG8gfm1lZ2EgfmdpZ2EgfnRlcmEgP3BldGEgKCkgPVxuICAoKiBSb3VuZCBhIHJhdGlvIHRvd2FyZCB0aGUgbmVhcmVzdCBpbnRlZ2VyLCByZXNvbHZpbmcgdGllcyB0b3dhcmQgdGhlIG5lYXJlc3QgZXZlblxuICAgICBudW1iZXIuICBGb3Igc2FuZSBpbnB1dHMgKGluIHBhcnRpY3VsYXIsIHdoZW4gW2Rlbm9taW5hdG9yXSBpcyBhbiBpbnRlZ2VyIGFuZFxuICAgICBbYWJzIG51bWVyYXRvciA8IDJlNTJdKSB0aGlzIHNob3VsZCBiZSBhY2N1cmF0ZS4gIE90aGVyd2lzZSwgdGhlIHJlc3VsdCBtaWdodCBiZSBhXG4gICAgIGxpdHRsZSBiaXQgb2ZmLCBidXQgd2UgZG9uJ3QgcmVhbGx5IHVzZSB0aGF0IGNhc2UuICopXG4gIGxldCBpcm91bmRfcmF0aW9fZXhuIH5udW1lcmF0b3IgfmRlbm9taW5hdG9yID1cbiAgICBsZXQgayA9IGZsb29yIChudW1lcmF0b3IgLy4gZGVub21pbmF0b3IpIGluXG4gICAgKCogaWYgW2FicyBrIDwgMmU1M10sIHRoZW4gYm90aCBba10gYW5kIFtrICsuIDEuXSBhcmUgYWNjdXJhdGVseSByZXByZXNlbnRlZCwgYW5kIGluXG4gICAgICAgcGFydGljdWxhciBbayArLiAxLiA+IGtdLiAgSWYgW2Rlbm9taW5hdG9yXSBpcyBhbHNvIGFuIGludGVnZXIsIGFuZFxuICAgICAgIFthYnMgKGRlbm9taW5hdG9yICouIChrICsuIDEpKSA8IDJlNTNdIChhbmQgaW4gc29tZSBvdGhlciBjYXNlcywgdG9vKSwgdGhlbiBbbG93ZXJdXG4gICAgICAgYW5kIFtoaWdoZXJdIGFyZSBhY3R1YWxseSBib3RoIGFjY3VyYXRlLiAgU2luY2UgKHJvdWdobHkpXG4gICAgICAgW251bWVyYXRvciA9IGRlbm9taW5hdG9yICouIGtdIHRoZW4gZm9yIFthYnMgbnVtZXJhdG9yIDwgMmU1Ml0gd2Ugc2hvdWxkIGJlXG4gICAgICAgZmluZS4gKilcbiAgICBsZXQgbG93ZXIgPSBkZW5vbWluYXRvciAqLiBrIGluXG4gICAgbGV0IGhpZ2hlciA9IGRlbm9taW5hdG9yICouIChrICsuIDEuKSBpblxuICAgICgqIFN1YnRyYWN0aW5nIG51bWJlcnMgd2l0aGluIGEgZmFjdG9yIG9mIHR3byBmcm9tIGVhY2ggb3RoZXIgaXMgYWNjdXJhdGUuXG4gICAgICAgU28gZWl0aGVyIHRoZSB0d28gc3VidHJhY3Rpb25zIGJlbG93IGFyZSBhY2N1cmF0ZSwgb3IgayA9IDAsIG9yIGsgPSAtMS5cbiAgICAgICBJbiBjYXNlIG9mIGEgdGllLCByb3VuZCB0byBldmVuLiAqKVxuICAgIGxldCBkaWZmX3JpZ2h0ID0gaGlnaGVyIC0uIG51bWVyYXRvciBpblxuICAgIGxldCBkaWZmX2xlZnQgPSBudW1lcmF0b3IgLS4gbG93ZXIgaW5cbiAgICBsZXQgayA9IGlyb3VuZF9uZWFyZXN0X2V4biBrIGluXG4gICAgaWYgZGlmZl9yaWdodCA8IGRpZmZfbGVmdFxuICAgIHRoZW4gayArIDFcbiAgICBlbHNlIGlmIGRpZmZfcmlnaHQgPiBkaWZmX2xlZnRcbiAgICB0aGVuIGtcbiAgICBlbHNlIGlmICgqIGEgdGllICopXG4gICAgICBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPSApIChrIG1vZCAyKSAwXG4gICAgdGhlbiBrXG4gICAgZWxzZSBrICsgMVxuICBpblxuICBtYXRjaCBjbGFzc2lmeSB0IHdpdGhcbiAgfCBDbGFzcy5JbmZpbml0ZSAtPiBpZiB0IDwgMC4wIHRoZW4gXCItaW5mICBcIiBlbHNlIFwiaW5mICBcIlxuICB8IENsYXNzLk5hbiAtPiBcIm5hbiAgXCJcbiAgfCBDbGFzcy5TdWJub3JtYWwgfCBDbGFzcy5Ob3JtYWwgfCBDbGFzcy5aZXJvIC0+XG4gICAgbGV0IGdvIHQgPVxuICAgICAgbGV0IGNvbnZfb25lIHQgPVxuICAgICAgICBhc3NlcnQgKDAuIDw9IHQgJiYgdCA8IDk5OS45NSk7XG4gICAgICAgIGxldCB4ID0gcHJlZml4IF4gZm9ybWF0X2Zsb2F0IFwiJS4xZlwiIHQgaW5cbiAgICAgICAgKCogRml4IHRoZSBcIi4wXCIgc3VmZml4ICopXG4gICAgICAgIGlmIFN0cmluZy5pc19zdWZmaXggeCB+c3VmZml4OlwiLjBcIlxuICAgICAgICB0aGVuIChcbiAgICAgICAgICBsZXQgeCA9IEJ5dGVzLm9mX3N0cmluZyB4IGluXG4gICAgICAgICAgbGV0IG4gPSBCeXRlcy5sZW5ndGggeCBpblxuICAgICAgICAgIEJ5dGVzLnNldCB4IChuIC0gMSkgJyAnO1xuICAgICAgICAgIEJ5dGVzLnNldCB4IChuIC0gMikgJyAnO1xuICAgICAgICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6eClcbiAgICAgICAgZWxzZSB4XG4gICAgICBpblxuICAgICAgbGV0IGNvbnYgbWFnIHQgZGVub21pbmF0b3IgPVxuICAgICAgICBhc3NlcnQgKFxuICAgICAgICAgIChkZW5vbWluYXRvciA9IDEwMC4gJiYgdCA+PSA5OTkuOTUpXG4gICAgICAgICAgfHwgKGRlbm9taW5hdG9yID49IDEwMF8wMDAuICYmIHQgPj0gcm91bmRfbmVhcmVzdCAoZGVub21pbmF0b3IgKi4gOS45OTlfNSkpKTtcbiAgICAgICAgYXNzZXJ0ICh0IDwgcm91bmRfbmVhcmVzdCAoZGVub21pbmF0b3IgKi4gOV85OTkuNSkpO1xuICAgICAgICBsZXQgaSwgZCA9XG4gICAgICAgICAgbGV0IGsgPSBpcm91bmRfcmF0aW9fZXhuIH5udW1lcmF0b3I6dCB+ZGVub21pbmF0b3IgaW5cbiAgICAgICAgICAoKiBbbW9kXSBpcyBva2F5IGhlcmUgYmVjYXVzZSB3ZSBrbm93IGkgPj0gMC4gKilcbiAgICAgICAgICBrIC8gMTAsIGsgbW9kIDEwXG4gICAgICAgIGluXG4gICAgICAgIGxldCBvcGVuIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgaW5cbiAgICAgICAgYXNzZXJ0ICgwIDw9IGkgJiYgaSA8IDEwMDApO1xuICAgICAgICBhc3NlcnQgKDAgPD0gZCAmJiBkIDwgMTApO1xuICAgICAgICBpZiBkID0gMFxuICAgICAgICB0aGVuIHNwcmludGYgXCIlcyVkJXMgXCIgcHJlZml4IGkgbWFnXG4gICAgICAgIGVsc2Ugc3ByaW50ZiBcIiVzJWQlcyVkXCIgcHJlZml4IGkgbWFnIGRcbiAgICAgIGluXG4gICAgICAoKiBXaGlsZSB0aGUgc3RhbmRhcmQgbWV0cmljIHByZWZpeGVzIChlLmcuIGNhcGl0YWwgXCJNXCIgcmF0aGVyIHRoYW4gXCJtXCIsIFsxXSkgYXJlXG4gICAgICAgICBub21pbmFsbHkgbW9yZSBjb3JyZWN0LCB0aGlzIGhpbmRlcnMgcmVhZGFiaWxpdHkgaW4gb3VyIGNhc2UuICBFLmcuLCAxMEc2IGFuZFxuICAgICAgICAgMTA2NiBsb29rIHRvbyBzaW1pbGFyLiAgVGhhdCdzIGFuIGV4dHJlbWUgZXhhbXBsZSwgYnV0IGluIGdlbmVyYWwgayxtLGcsdCxwXG4gICAgICAgICBwcm9iYWJseSBzdGFuZCBvdXQgYmV0dGVyIHRoYW4gSyxNLEcsVCxQIHdoZW4gaW50ZXJzcGVyc2VkIHdpdGggZGlnaXRzLlxuXG4gICAgICAgICBbMV0gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NZXRyaWNfcHJlZml4ICopXG4gICAgICAoKiBUaGUgdHJpY2sgaGVyZSBpcyB0aGF0OlxuICAgICAgICAgLSB0aGUgZmlyc3QgYm91bmRhcnkgKDk5OS45NSkgYXMgYSBmbG9hdCBpcyBzbGlnaHRseSBvdmVyLXJlcHJlc2VudGVkIChzbyBpdCBpc1xuICAgICAgICAgICBiZXR0ZXIgYXBwcm94aW1hdGVkIGFzIFwiMWtcIiB0aGFuIGFzIFwiOTk5LjlcIiksXG4gICAgICAgICAtIHRoZSBvdGhlciBib3VuZGFyaWVzIGFyZSBhY2N1cmF0ZWx5IHJlcHJlc2VudGVkLCBiZWNhdXNlIHRoZXkgYXJlIGludGVnZXJzLlxuICAgICAgICAgICBUaGF0J3Mgd2h5IHRoZSBzdHJpY3QgZXF1YWxpdGllcyBiZWxvdyBkbyBleGFjdGx5IHdoYXQgd2Ugd2FudC4gKilcbiAgICAgIGlmIHQgPCA5OTkuOTVFMFxuICAgICAgdGhlbiBjb252X29uZSB0XG4gICAgICBlbHNlIGlmIHQgPCA5OTkuOTVFM1xuICAgICAgdGhlbiBjb252IGtpbG8gdCAxMDAuXG4gICAgICBlbHNlIGlmIHQgPCA5OTkuOTVFNlxuICAgICAgdGhlbiBjb252IG1lZ2EgdCAxMDBfMDAwLlxuICAgICAgZWxzZSBpZiB0IDwgOTk5Ljk1RTlcbiAgICAgIHRoZW4gY29udiBnaWdhIHQgMTAwXzAwMF8wMDAuXG4gICAgICBlbHNlIGlmIHQgPCA5OTkuOTVFMTJcbiAgICAgIHRoZW4gY29udiB0ZXJhIHQgMTAwXzAwMF8wMDBfMDAwLlxuICAgICAgZWxzZSAoXG4gICAgICAgIG1hdGNoIHBldGEgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gc3ByaW50ZiBcIiVzJS4xZVwiIHByZWZpeCB0XG4gICAgICAgIHwgU29tZSBwZXRhIC0+XG4gICAgICAgICAgaWYgdCA8IDk5OS45NUUxNVxuICAgICAgICAgIHRoZW4gY29udiBwZXRhIHQgMTAwXzAwMF8wMDBfMDAwXzAwMC5cbiAgICAgICAgICBlbHNlIHNwcmludGYgXCIlcyUuMWVcIiBwcmVmaXggdClcbiAgICBpblxuICAgIGlmIHQgPj0gMC4gdGhlbiBnbyB0IGVsc2UgXCItXCIgXiBnbyB+LS50XG47O1xuXG5sZXQgdG9fcGFkZGVkX2NvbXBhY3Rfc3RyaW5nIHQgPVxuICB0b19wYWRkZWRfY29tcGFjdF9zdHJpbmdfY3VzdG9tIHQgfmtpbG86XCJrXCIgfm1lZ2E6XCJtXCIgfmdpZ2E6XCJnXCIgfnRlcmE6XCJ0XCIgfnBldGE6XCJwXCIgKClcbjs7XG5cbigqIFBlcmZvcm1hbmNlIG5vdGU6IEluaXRpYWxpemluZyB0aGUgYWNjdW11bGF0b3IgdG8gMSByZXN1bHRzIGluIG9uZSBleHRyYVxuICAgbXVsdGlwbHk7IGUuZy4sIHRvIGNvbXB1dGUgeCAqKiA0LCB3ZSBpbiBwcmluY2lwbGUgb25seSBuZWVkIDIgbXVsdGlwbGllcyxcbiAgIGJ1dCB0aGlzIGZ1bmN0aW9uIHdpbGwgaGF2ZSAzIG11bHRpcGxpZXMuICBIb3dldmVyLCBhdHRlbXB0cyB0byBhdm9pZCB0aGlzXG4gICAobGlrZSBkZWNyZW1lbnRpbmcgbiBhbmQgaW5pdGlhbGl6aW5nIGFjY3VtIHRvIGJlIHgsIG9yIGhhbmRsaW5nIHNtYWxsXG4gICBleHBvbmVudHMgYXMgYSBzcGVjaWFsIGNhc2UpIGhhdmUgbm90IHlpZWxkZWQgYW55dGhpbmcgdGhhdCBpcyBhIG5ldFxuICAgaW1wcm92ZW1lbnQuXG4qKVxubGV0IGludF9wb3cgeCBuID1cbiAgbGV0IG9wZW4gSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBpblxuICBpZiBuID0gMFxuICB0aGVuIDEuXG4gIGVsc2UgKFxuICAgICgqIFVzaW5nIFt4ICsuICgtMC4pXSBvbiB0aGUgZm9sbG93aW5nIGxpbmUgY29udmluY2VzIHRoZSBjb21waWxlciB0byBhdm9pZCBhIGNlcnRhaW5cbiAgICAgICBib3hpbmcgKHRoYXQgd291bGQgcmVzdWx0IGluIGFsbG9jYXRpb24gaW4gZWFjaCBpdGVyYXRpb24pLiAgU29vbiwgdGhlIGNvbXBpbGVyXG4gICAgICAgc2hvdWxkbid0IG5lZWQgdGhpcyBcImhpbnRcIiB0byBhdm9pZCB0aGUgYm94aW5nLiAgVGhlIHJlYXNvbiB3ZSBhZGQgLTAgcmF0aGVyIHRoYW4gMFxuICAgICAgIGlzIHRoYXQgW3ggKy4gKC0wLildIGlzIGFwcGFyZW50bHkgYWx3YXlzIHRoZSBzYW1lIGFzIFt4XSwgd2hlcmVhcyBbeCArLiAwLl0gaXNcbiAgICAgICBub3QsIGluIHRoYXQgaXQgc2VuZHMgWy0wLl0gdG8gWzAuXS4gIFRoaXMgbWFrZXMgYSBkaWZmZXJlbmNlIGJlY2F1c2Ugd2Ugd2FudFxuICAgICAgIFtpbnRfcG93ICgtMC4pICgtMSldIHRvIHJldHVybiBuZWdfaW5maW5pdHkganVzdCBsaWtlIFstMC4gKiogLTEuXSB3b3VsZC4gICopXG4gICAgbGV0IHggPSByZWYgKHggKy4gLTAuKSBpblxuICAgIGxldCBuID0gcmVmIG4gaW5cbiAgICBsZXQgYWNjdW0gPSByZWYgMS4gaW5cbiAgICBpZiAhbiA8IDBcbiAgICB0aGVuIChcbiAgICAgICgqIHggKiogbiA9ICgxL3gpICoqIC1uICopXG4gICAgICB4IDo9IDEuIC8uICF4O1xuICAgICAgbiA6PSB+LSAoIW4pO1xuICAgICAgaWYgIW4gPCAwXG4gICAgICB0aGVuIChcbiAgICAgICAgKCogbiBtdXN0IGhhdmUgYmVlbiBtaW5faW50LCBzbyBpdCBpcyBub3cgc28gYmlnIHRoYXQgaXQgaGFzIHdyYXBwZWQgYXJvdW5kLlxuICAgICAgICAgICBXZSBkZWNyZW1lbnQgaXQgc28gdGhhdCBpdCBsb29rcyBwb3NpdGl2ZSBhZ2FpbiwgYnV0IGFjY29yZGluZ2x5IGhhdmVcbiAgICAgICAgICAgdG8gcHV0IGFuIGV4dHJhIGZhY3RvciBvZiB4IGluIHRoZSBhY2N1bXVsYXRvci5cbiAgICAgICAgKilcbiAgICAgICAgYWNjdW0gOj0gIXg7XG4gICAgICAgIGRlY3IgbikpO1xuICAgICgqIExldHRpbmcgW2FdIGRlbm90ZSAodGhlIG9yaWdpbmFsIHZhbHVlIG9mKSBbeCAqKiBuXSwgd2UgbWFpbnRhaW5cbiAgICAgICB0aGUgaW52YXJpYW50IHRoYXQgWyh4ICoqIG4pICouIGFjY3VtID0gYV0uICopXG4gICAgd2hpbGUgIW4gPiAxIGRvXG4gICAgICBpZiAhbiBsYW5kIDEgPD4gMCB0aGVuIGFjY3VtIDo9ICF4ICouICFhY2N1bTtcbiAgICAgIHggOj0gIXggKi4gIXg7XG4gICAgICBuIDo9ICFuIGxzciAxXG4gICAgZG9uZTtcbiAgICAoKiBuIGlzIG5lY2Vzc2FyaWx5IDEgYXQgdGhpcyBwb2ludCwgc28gdGhlcmUgaXMgb25lIGFkZGl0aW9uYWxcbiAgICAgICBtdWx0aXBsaWNhdGlvbiBieSB4LiAqKVxuICAgICF4ICouICFhY2N1bSlcbjs7XG5cbmxldCByb3VuZF9nZW4geCB+aG93ID1cbiAgaWYgeCA9IDAuXG4gIHRoZW4gMC5cbiAgZWxzZSBpZiBub3QgKGlzX2Zpbml0ZSB4KVxuICB0aGVuIHhcbiAgZWxzZSAoXG4gICAgKCogU2lnbmlmaWNhbnQgZGlnaXRzIGFuZCBkZWNpbWFsIGRpZ2l0cy4gKilcbiAgICBsZXQgc2QsIGRkID1cbiAgICAgIG1hdGNoIGhvdyB3aXRoXG4gICAgICB8IGBzaWduaWZpY2FudF9kaWdpdHMgc2QgLT5cbiAgICAgICAgbGV0IGRkID0gc2QgLSB0b19pbnQgKHJvdW5kX3VwIChsb2cxMCAoYWJzIHgpKSkgaW5cbiAgICAgICAgc2QsIGRkXG4gICAgICB8IGBkZWNpbWFsX2RpZ2l0cyBkZCAtPlxuICAgICAgICBsZXQgc2QgPSBkZCArIHRvX2ludCAocm91bmRfdXAgKGxvZzEwIChhYnMgeCkpKSBpblxuICAgICAgICBzZCwgZGRcbiAgICBpblxuICAgIGxldCBvcGVuIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgaW5cbiAgICBpZiBzZCA8IDBcbiAgICB0aGVuIDAuXG4gICAgZWxzZSBpZiBzZCA+PSAxN1xuICAgIHRoZW4geFxuICAgIGVsc2UgKFxuICAgICAgKCogQ2hvb3NlIHRoZSBvcmRlciB0aGF0IGlzIGV4YWN0bHkgcmVwcmVzZW50YWJsZSBhcyBhIGZsb2F0LiBTbWFsbCBwb3NpdGl2ZVxuICAgICAgICAgaW50ZWdlcnMgYXJlLCBidXQgdGhlaXIgaW52ZXJzZXMgaW4gbW9zdCBjYXNlcyBhcmUgbm90LiAqKVxuICAgICAgbGV0IGFic19kZCA9IEludC5hYnMgZGQgaW5cbiAgICAgIGlmIGFic19kZCA+IDIyIHx8IHNkID49IDE2XG4gICAgICAoKiAxMCoqMjIgaXMgZXhhY3RseSByZXByZXNlbnRhYmxlIGFzIGEgZmxvYXQsIGJ1dCAxMCoqMjMgaXMgbm90LCBzbyB1c2UgdGhlIHNsb3dcbiAgICAgICAgIHBhdGguICBTaW1pbGFybHksIGlmIHdlIG5lZWQgMTYgc2lnbmlmaWNhbnQgZGlnaXRzIGluIHRoZSByZXN1bHQsIHRoZW4gdGhlIGludGVnZXJcbiAgICAgICAgIFtyb3VuZF9uZWFyZXN0ICh4IDxvcD4gb3JkZXIpXSBtaWdodCBub3QgYmUgZXhhY3RseSByZXByZXNlbnRhYmxlIGFzIGEgZmxvYXQsIHNpbmNlXG4gICAgICAgICBmb3Igc29tZSByYW5nZXMgd2Ugb25seSBoYXZlIDE1IGRpZ2l0cyBvZiBwcmVjaXNpb24gZ3VhcmFudGVlZC5cblxuICAgICAgICAgVGhhdCBzYWlkLCB3ZSBhcmUgc3RpbGwgcm91bmRpbmcgdHdpY2UgaGVyZTpcblxuICAgICAgICAgMSkgZmlyc3QgdGltZSB3aGVuIHJvdW5kaW5nIFt4ICouIG9yZGVyXSBvciBbeCAvLiBvcmRlcl0gdG8gdGhlIG5lYXJlc3QgZmxvYXRcbiAgICAgICAgIChqdXN0IHRoZSBub3JtYWwgd2F5IGZsb2F0aW5nLXBvaW50IG11bHRpcGxpY2F0aW9uIG9yIGRpdmlzaW9uIHdvcmtzKSxcblxuICAgICAgICAgMikgc2Vjb25kIHRpbWUgd2hlbiBhcHBseWluZyBbcm91bmRfbmVhcmVzdF9oYWxmX3RvX2V2ZW5dIHRvIHRoZSByZXN1bHQgb2YgdGhlXG4gICAgICAgICBhYm92ZSBvcGVyYXRpb25cblxuICAgICAgICAgU28gZm9yIGFyZ3VtZW50cyB3aXRoaW4gYW4gdWxwIGZyb20gYSB0aWUgd2UgbWlnaHQgc3RpbGwgcHJvZHVjZSBhbiBvZmYtYnktb25lXG4gICAgICAgICByZXN1bHQuICopXG4gICAgICB0aGVuIG9mX3N0cmluZyAoc3ByaW50ZiBcIiUuKmdcIiBzZCB4KVxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBvcmRlciA9IGludF9wb3cgMTAuIGFic19kZCBpblxuICAgICAgICBpZiBkZCA+PSAwXG4gICAgICAgIHRoZW4gcm91bmRfbmVhcmVzdF9oYWxmX3RvX2V2ZW4gKHggKi4gb3JkZXIpIC8uIG9yZGVyXG4gICAgICAgIGVsc2Ugcm91bmRfbmVhcmVzdF9oYWxmX3RvX2V2ZW4gKHggLy4gb3JkZXIpICouIG9yZGVyKSkpXG47O1xuXG5sZXQgcm91bmRfc2lnbmlmaWNhbnQgeCB+c2lnbmlmaWNhbnRfZGlnaXRzID1cbiAgaWYgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oIDw9ICkgc2lnbmlmaWNhbnRfZGlnaXRzIDBcbiAgdGhlblxuICAgIGludmFsaWRfYXJnZlxuICAgICAgXCJGbG9hdC5yb3VuZF9zaWduaWZpY2FudDogaW52YWxpZCBhcmd1bWVudCBzaWduaWZpY2FudF9kaWdpdHM6JWRcIlxuICAgICAgc2lnbmlmaWNhbnRfZGlnaXRzXG4gICAgICAoKVxuICBlbHNlIHJvdW5kX2dlbiB4IH5ob3c6KGBzaWduaWZpY2FudF9kaWdpdHMgc2lnbmlmaWNhbnRfZGlnaXRzKVxuOztcblxubGV0IHJvdW5kX2RlY2ltYWwgeCB+ZGVjaW1hbF9kaWdpdHMgPSByb3VuZF9nZW4geCB+aG93OihgZGVjaW1hbF9kaWdpdHMgZGVjaW1hbF9kaWdpdHMpXG5sZXQgYmV0d2VlbiB0IH5sb3cgfmhpZ2ggPSBsb3cgPD0gdCAmJiB0IDw9IGhpZ2hcblxubGV0IGNsYW1wX2V4biB0IH5taW4gfm1heCA9XG4gICgqIEFsc28gZmFpbHMgaWYgW21pbl0gb3IgW21heF0gaXMgbmFuICopXG4gIGFzc2VydCAobWluIDw9IG1heCk7XG4gICgqIGNsYW1wX3VuY2hlY2tlZCBpcyBpbiBmbG9hdDAubWwgKilcbiAgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4XG47O1xuXG5sZXQgY2xhbXAgdCB+bWluIH5tYXggPVxuICAoKiBBbHNvIGZhaWxzIGlmIFttaW5dIG9yIFttYXhdIGlzIG5hbiAqKVxuICBpZiBtaW4gPD0gbWF4XG4gIHRoZW4gT2sgKGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heClcbiAgZWxzZVxuICAgIE9yX2Vycm9yLmVycm9yX3NcbiAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgIFwiY2xhbXAgcmVxdWlyZXMgW21pbiA8PSBtYXhdXCJcbiAgICAgICAgIFsgXCJtaW5cIiwgVC5zZXhwX29mX3QgbWluOyBcIm1heFwiLCBULnNleHBfb2ZfdCBtYXggXSlcbjs7XG5cbmxldCAoICsgKSA9ICggKy4gKVxubGV0ICggLSApID0gKCAtLiApXG5sZXQgKCAqICkgPSAoICouIClcbmxldCAoICoqICkgPSAoICoqIClcbmxldCAoIC8gKSA9ICggLy4gKVxubGV0ICggJSApID0gKCAlLiApXG5sZXQgKCB+LSApID0gKCB+LS4gKVxuXG5sZXQgc2lnbl9leG4gdCA6IFNpZ24udCA9XG4gIGlmIHQgPiAwLlxuICB0aGVuIFBvc1xuICBlbHNlIGlmIHQgPCAwLlxuICB0aGVuIE5lZ1xuICBlbHNlIGlmIHQgPSAwLlxuICB0aGVuIFplcm9cbiAgZWxzZSBFcnJvci5yYWlzZV9zIChTZXhwLm1lc3NhZ2UgXCJGbG9hdC5zaWduX2V4biBvZiBOQU5cIiBbIFwiXCIsIHNleHBfb2ZfdCB0IF0pXG47O1xuXG5sZXQgc2lnbl9vcl9uYW4gdCA6IFNpZ25fb3JfbmFuLnQgPVxuICBpZiB0ID4gMC4gdGhlbiBQb3MgZWxzZSBpZiB0IDwgMC4gdGhlbiBOZWcgZWxzZSBpZiB0ID0gMC4gdGhlbiBaZXJvIGVsc2UgTmFuXG47O1xuXG5sZXQgaWVlZV9uZWdhdGl2ZSB0ID1cbiAgbGV0IGJpdHMgPSBDYW1sLkludDY0LmJpdHNfb2ZfZmxvYXQgdCBpblxuICBQb2x5LihiaXRzIDwgQ2FtbC5JbnQ2NC56ZXJvKVxuOztcblxubGV0IGV4cG9uZW50X2JpdHMgPSAxMVxubGV0IG1hbnRpc3NhX2JpdHMgPSA1MlxubGV0IGV4cG9uZW50X21hc2s2NCA9IEludDY0LihzaGlmdF9sZWZ0IG9uZSBleHBvbmVudF9iaXRzIC0gb25lKVxubGV0IGV4cG9uZW50X21hc2sgPSBJbnQ2NC50b19pbnRfZXhuIGV4cG9uZW50X21hc2s2NFxubGV0IG1hbnRpc3NhX21hc2sgPSBJbnQ2My4oc2hpZnRfbGVmdCBvbmUgbWFudGlzc2FfYml0cyAtIG9uZSlcbmxldCBtYW50aXNzYV9tYXNrNjQgPSBJbnQ2My50b19pbnQ2NCBtYW50aXNzYV9tYXNrXG5cbmxldCBpZWVlX2V4cG9uZW50IHQgPVxuICBsZXQgYml0cyA9IENhbWwuSW50NjQuYml0c19vZl9mbG9hdCB0IGluXG4gIEludDY0LihiaXRfYW5kIChzaGlmdF9yaWdodF9sb2dpY2FsIGJpdHMgbWFudGlzc2FfYml0cykgZXhwb25lbnRfbWFzazY0KVxuICB8PiBDYW1sLkludDY0LnRvX2ludFxuOztcblxubGV0IGllZWVfbWFudGlzc2EgdCA9XG4gIGxldCBiaXRzID0gQ2FtbC5JbnQ2NC5iaXRzX29mX2Zsb2F0IHQgaW5cbiAgSW50NjMub2ZfaW50NjRfZXhuIENhbWwuSW50NjQuKGxvZ2FuZCBiaXRzIG1hbnRpc3NhX21hc2s2NClcbjs7XG5cbmxldCBjcmVhdGVfaWVlZV9leG4gfm5lZ2F0aXZlIH5leHBvbmVudCB+bWFudGlzc2EgPVxuICBpZiBJbnQuKGJpdF9hbmQgZXhwb25lbnQgZXhwb25lbnRfbWFzayA8PiBleHBvbmVudClcbiAgdGhlbiBmYWlsd2l0aGYgXCJleHBvbmVudCAlZCBvdXQgb2YgcmFuZ2UgWzAsICVkXVwiIGV4cG9uZW50IGV4cG9uZW50X21hc2sgKClcbiAgZWxzZSBpZiBJbnQ2My4oYml0X2FuZCBtYW50aXNzYSBtYW50aXNzYV9tYXNrIDw+IG1hbnRpc3NhKVxuICB0aGVuXG4gICAgZmFpbHdpdGhmXG4gICAgICBcIm1hbnRpc3NhICVzIG91dCBvZiByYW5nZSBbMCwgJXNdXCJcbiAgICAgIChJbnQ2My50b19zdHJpbmcgbWFudGlzc2EpXG4gICAgICAoSW50NjMudG9fc3RyaW5nIG1hbnRpc3NhX21hc2spXG4gICAgICAoKVxuICBlbHNlIChcbiAgICBsZXQgc2lnbl9iaXRzID0gaWYgbmVnYXRpdmUgdGhlbiBDYW1sLkludDY0Lm1pbl9pbnQgZWxzZSBDYW1sLkludDY0Lnplcm8gaW5cbiAgICBsZXQgZXhwdF9iaXRzID0gQ2FtbC5JbnQ2NC5zaGlmdF9sZWZ0IChDYW1sLkludDY0Lm9mX2ludCBleHBvbmVudCkgbWFudGlzc2FfYml0cyBpblxuICAgIGxldCBtYW50X2JpdHMgPSBJbnQ2My50b19pbnQ2NCBtYW50aXNzYSBpblxuICAgIGxldCBiaXRzID0gQ2FtbC5JbnQ2NC4obG9nb3Igc2lnbl9iaXRzIChsb2dvciBleHB0X2JpdHMgbWFudF9iaXRzKSkgaW5cbiAgICBDYW1sLkludDY0LmZsb2F0X29mX2JpdHMgYml0cylcbjs7XG5cbmxldCBjcmVhdGVfaWVlZSB+bmVnYXRpdmUgfmV4cG9uZW50IH5tYW50aXNzYSA9XG4gIE9yX2Vycm9yLnRyeV93aXRoIChmdW4gKCkgLT4gY3JlYXRlX2llZWVfZXhuIH5uZWdhdGl2ZSB+ZXhwb25lbnQgfm1hbnRpc3NhKVxuOztcblxubW9kdWxlIFRlcnNlID0gc3RydWN0XG4gIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgbGV0IHRfb2Zfc2V4cCA9IHRfb2Zfc2V4cFxuICBsZXQgdG9fc3RyaW5nIHggPSBQcmludGYuc3ByaW50ZiBcIiUuOEdcIiB4XG4gIGxldCBzZXhwX29mX3QgeCA9IFNleHAuQXRvbSAodG9fc3RyaW5nIHgpXG4gIGxldCBvZl9zdHJpbmcgeCA9IG9mX3N0cmluZyB4XG4gIGxldCB0X3NleHBfZ3JhbW1hciA9IHRfc2V4cF9ncmFtbWFyXG5lbmRcblxuaW5jbHVkZSBDb21wYXJhYmxlLldpdGhfemVybyAoc3RydWN0XG4gICAgaW5jbHVkZSBUXG5cbiAgICBsZXQgemVybyA9IHplcm9cbiAgZW5kKVxuXG4oKiBUaGVzZSBhcmUgcGFydGx5IGhlcmUgYXMgYSBwZXJmb3JtYW5jZSBoYWNrIHRvIGF2b2lkIHNvbWUgYm94aW5nIHdlJ3JlIGdldHRpbmcgd2l0aFxuICAgdGhlIHZlcnNpb25zIHdlIGdldCBmcm9tIFtXaXRoX3plcm9dLiAgVGhleSBhbHNvIG1ha2UgW0Zsb2F0LmlzX25lZ2F0aXZlIG5hbl0gYW5kXG4gICBbRmxvYXQuaXNfbm9uX3Bvc2l0aXZlIG5hbl0gcmV0dXJuIFtmYWxzZV07IHRoZSB2ZXJzaW9ucyB3ZSBnZXQgZnJvbSBbV2l0aF96ZXJvXSByZXR1cm5cbiAgIFt0cnVlXS4gKilcbmxldCBpc19wb3NpdGl2ZSB0ID0gdCA+IDAuXG5sZXQgaXNfbm9uX25lZ2F0aXZlIHQgPSB0ID49IDAuXG5sZXQgaXNfbmVnYXRpdmUgdCA9IHQgPCAwLlxubGV0IGlzX25vbl9wb3NpdGl2ZSB0ID0gdCA8PSAwLlxuXG5pbmNsdWRlIFByZXR0eV9wcmludGVyLlJlZ2lzdGVyIChzdHJ1Y3RcbiAgICBpbmNsdWRlIFRcblxuICAgIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5GbG9hdFwiXG4gICAgbGV0IHRvX3N0cmluZyA9IHRvX3N0cmluZ1xuICBlbmQpXG5cbm1vZHVsZSBPID0gc3RydWN0XG4gIGxldCAoICsgKSA9ICggKyApXG4gIGxldCAoIC0gKSA9ICggLSApXG4gIGxldCAoICogKSA9ICggKiApXG4gIGxldCAoIC8gKSA9ICggLyApXG4gIGxldCAoICUgKSA9ICggJSApXG4gIGxldCAoIH4tICkgPSAoIH4tIClcbiAgbGV0ICggKiogKSA9ICggKiogKVxuXG4gIGluY2x1ZGUgKEZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSA6IENvbXBhcmlzb25zLkluZml4IHdpdGggdHlwZSB0IDo9IHQpXG5cbiAgbGV0IGFicyA9IGFic1xuICBsZXQgbmVnID0gbmVnXG4gIGxldCB6ZXJvID0gemVyb1xuICBsZXQgb2ZfaW50ID0gb2ZfaW50XG4gIGxldCBvZl9mbG9hdCB4ID0geFxuZW5kXG5cbm1vZHVsZSBPX2RvdCA9IHN0cnVjdFxuICBsZXQgKCAqLiApID0gKCAqIClcbiAgbGV0ICggKy4gKSA9ICggKyApXG4gIGxldCAoIC0uICkgPSAoIC0gKVxuICBsZXQgKCAvLiApID0gKCAvIClcbiAgbGV0ICggJS4gKSA9ICggJSApXG4gIGxldCAoIH4tLiApID0gKCB+LSApXG4gIGxldCAoICoqLiApID0gKCAqKiApXG5lbmRcblxubW9kdWxlIFByaXZhdGUgPSBzdHJ1Y3RcbiAgbGV0IGJveCA9IGJveFxuICBsZXQgY2xhbXBfdW5jaGVja2VkID0gY2xhbXBfdW5jaGVja2VkXG4gIGxldCBsb3dlcl9ib3VuZF9mb3JfaW50ID0gbG93ZXJfYm91bmRfZm9yX2ludFxuICBsZXQgdXBwZXJfYm91bmRfZm9yX2ludCA9IHVwcGVyX2JvdW5kX2Zvcl9pbnRcbiAgbGV0IHNwZWNpYWxpemVkX2hhc2ggPSBoYXNoX2Zsb2F0XG4gIGxldCBvbmVfdWxwX2xlc3NfdGhhbl9oYWxmID0gb25lX3VscF9sZXNzX3RoYW5faGFsZlxuICBsZXQgaW50NjNfcm91bmRfbmVhcmVzdF9wb3J0YWJsZV9hbGxvY19leG4gPSBpbnQ2M19yb3VuZF9uZWFyZXN0X3BvcnRhYmxlX2FsbG9jX2V4blxuICBsZXQgaW50NjNfcm91bmRfbmVhcmVzdF9hcmNoNjRfbm9hbGxvY19leG4gPSBpbnQ2M19yb3VuZF9uZWFyZXN0X2FyY2g2NF9ub2FsbG9jX2V4blxuICBsZXQgaXJvdW5kX25lYXJlc3RfZXhuXzY0ID0gaXJvdW5kX25lYXJlc3RfZXhuXzY0XG5lbmRcblxuKCogSW5jbHVkZSB0eXBlLXNwZWNpZmljIFtSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVdIGF0IHRoZSBlbmQsIGFmdGVyXG4gICBpbmNsdWRpbmcgZnVuY3RvciBhcHBsaWNhdGlvbiB0aGF0IGNvdWxkIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXNcbiAgIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25zIGFyZSBleHBvcnRlZCBieVxuICAgdGhpcyBtb2R1bGUuICopXG5pbmNsdWRlIEZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG4oKiBUaGVzZSBmdW5jdGlvbnMgc3BlY2lmaWNhbGx5IHJlcGxhY2UgZGVmYXVsdHMgaW4gcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLlxuXG4gICBUaGUgZGVzaXJlZCBiZWhhdmlvciBoZXJlIGlzIHRvIHByb3BhZ2F0ZSBhIG5hbiBpZiBlaXRoZXIgYXJndW1lbnQgaXMgbmFuLiBCZWNhdXNlIHRoZVxuICAgZmlyc3QgY29tcGFyaXNvbiB3aWxsIGFsd2F5cyByZXR1cm4gZmFsc2UgaWYgZWl0aGVyIGFyZ3VtZW50IGlzIG5hbiwgaXQgc3VmZmljZXMgdG9cbiAgIGNoZWNrIGlmIHggaXMgbmFuLiBUaGVuLCB3aGVuIHggaXMgbmFuIG9yIGJvdGggeCBhbmQgeSBhcmUgbmFuLCB3ZSByZXR1cm4geCA9IG5hbjsgYW5kXG4gICB3aGVuIHkgaXMgbmFuIGJ1dCBub3QgeCwgd2UgcmV0dXJuIHkgPSBuYW4uXG5cbiAgIFRoZXJlIGFyZSB2YXJpb3VzIHdheXMgdG8gaW1wbGVtZW50IHRoZXNlIGZ1bmN0aW9ucy4gIFRoZSBiZW5jaG1hcmsgYmVsb3cgc2hvd3MgYSBmZXdcbiAgIGRpZmZlcmVudCB2ZXJzaW9ucy4gIFRoaXMgYmVuY2htYXJrIHdhcyBydW4gb3ZlciBhbiBhcnJheSBvZiByYW5kb20gZmxvYXRzIChub25lIG9mXG4gICB3aGljaCBhcmUgbmFuKS5cblxuICAg4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSs4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQXG4gICDilIIgTmFtZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIIgVGltZS9SdW4g4pSCXG4gICDilJzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKRcbiAgIOKUgiBpZiBpc19uYW4geCB0aGVuIHggZWxzZSBpZiB4IDwgeSB0aGVuIHggZWxzZSB5IOKUgiAgIDIuNDJ1cyDilIJcbiAgIOKUgiBpZiBpc19uYW4geCB8fCB4IDwgeSB0aGVuIHggZWxzZSB5ICAgICAgICAgICAgIOKUgiAgIDIuMDJ1cyDilIJcbiAgIOKUgiBpZiB4IDwgeSB8fCBpc19uYW4geCB0aGVuIHggZWxzZSB5ICAgICAgICAgICAgIOKUgiAgIDEuODh1cyDilIJcbiAgIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUtOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmFxuXG4gICBUaGUgYmVuY2htYXJrIGJlbG93IHdhcyBydW4gd2hlbiB4ID4geSBpcyBhbHdheXMgdHJ1ZSAoYWdhaW4sIG5vIG5hbiB2YWx1ZXMpLlxuXG4gICDilIzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJBcbiAgIOKUgiBOYW1lICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiBUaW1lL1J1biDilIJcbiAgIOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUpFxuICAg4pSCIGlmIGlzX25hbiB4IHRoZW4geCBlbHNlIGlmIHggPCB5IHRoZW4geCBlbHNlIHkg4pSCICAgMi44M3VzIOKUglxuICAg4pSCIGlmIGlzX25hbiB4IHx8IHggPCB5IHRoZW4geCBlbHNlIHkgICAgICAgICAgICAg4pSCICAgMS45N3VzIOKUglxuICAg4pSCIGlmIHggPCB5IHx8IGlzX25hbiB4IHRoZW4geCBlbHNlIHkgICAgICAgICAgICAg4pSCICAgMS41NnVzIOKUglxuICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS04pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYXG4qKVxubGV0IG1pbiAoeCA6IHQpIHkgPSBpZiB4IDwgeSB8fCBpc19uYW4geCB0aGVuIHggZWxzZSB5XG5sZXQgbWF4ICh4IDogdCkgeSA9IGlmIHggPiB5IHx8IGlzX25hbiB4IHRoZW4geCBlbHNlIHlcbiIsIm9wZW4hIEltcG9ydFxubW9kdWxlIFN5cyA9IFN5czBcblxudHlwZSB0ID0gQ2FtbC5QcmludGV4Yy5yYXdfYmFja3RyYWNlXG5cbmxldCBlbGlkZSA9IHJlZiBmYWxzZVxubGV0IGVsaWRlZF9tZXNzYWdlID0gXCI8YmFja3RyYWNlIGVsaWRlZCBpbiB0ZXN0PlwiXG5cbmxldCBnZXQgPyhhdF9tb3N0X251bV9mcmFtZXMgPSBJbnQubWF4X3ZhbHVlKSAoKSA9XG4gIENhbWwuUHJpbnRleGMuZ2V0X2NhbGxzdGFjayBhdF9tb3N0X251bV9mcmFtZXNcbjs7XG5cbmxldCB0b19zdHJpbmcgdCA9XG4gIGlmICFlbGlkZSB0aGVuIGVsaWRlZF9tZXNzYWdlIGVsc2UgQ2FtbC5QcmludGV4Yy5yYXdfYmFja3RyYWNlX3RvX3N0cmluZyB0XG47O1xuXG5sZXQgdG9fc3RyaW5nX2xpc3QgdCA9IFN0cmluZy5zcGxpdF9saW5lcyAodG9fc3RyaW5nIHQpXG5sZXQgc2V4cF9vZl90IHQgPSBTZXhwLkxpc3QgKExpc3QubWFwICh0b19zdHJpbmdfbGlzdCB0KSB+ZjooZnVuIHggLT4gU2V4cC5BdG9tIHgpKVxuXG5tb2R1bGUgRXhuID0gc3RydWN0XG4gIGxldCBzZXRfcmVjb3JkaW5nID0gQ2FtbC5QcmludGV4Yy5yZWNvcmRfYmFja3RyYWNlXG4gIGxldCBhbV9yZWNvcmRpbmcgPSBDYW1sLlByaW50ZXhjLmJhY2t0cmFjZV9zdGF0dXNcbiAgbGV0IG1vc3RfcmVjZW50ICgpID0gQ2FtbC5QcmludGV4Yy5nZXRfcmF3X2JhY2t0cmFjZSAoKVxuXG4gIGxldCBtb3N0X3JlY2VudF9mb3JfZXhuIGV4biA9XG4gICAgaWYgRXhuLmlzX3BoeXNfZXF1YWxfbW9zdF9yZWNlbnQgZXhuIHRoZW4gU29tZSAobW9zdF9yZWNlbnQgKCkpIGVsc2UgTm9uZVxuICA7O1xuXG4gICgqIFdlIHR1cm4gb24gYmFja3RyYWNlcyBieSBkZWZhdWx0IGlmIE9DQU1MUlVOUEFSQU0gZG9lc24ndCBleHBsaWNpdGx5IG1lbnRpb24gdGhlbS4gKilcbiAgbGV0IG1heWJlX3NldF9yZWNvcmRpbmcgKCkgPVxuICAgIGxldCBvY2FtbHJ1bnBhcmFtX21lbnRpb25zX2JhY2t0cmFjZXMgPVxuICAgICAgbWF0Y2ggU3lzLmdldGVudiBcIk9DQU1MUlVOUEFSQU1cIiB3aXRoXG4gICAgICB8IE5vbmUgLT4gZmFsc2VcbiAgICAgIHwgU29tZSB4IC0+IExpc3QuZXhpc3RzIChTdHJpbmcuc3BsaXQgeCB+b246JywnKSB+ZjooU3RyaW5nLmlzX3ByZWZpeCB+cHJlZml4OlwiYlwiKVxuICAgIGluXG4gICAgaWYgbm90IG9jYW1scnVucGFyYW1fbWVudGlvbnNfYmFja3RyYWNlcyB0aGVuIHNldF9yZWNvcmRpbmcgdHJ1ZVxuICA7O1xuXG4gICgqIHRoZSBjYWxsZXIgc2V0IHNvbWV0aGluZywgdGhleSBhcmUgcmVzcG9uc2libGUgKilcblxuICBsZXQgd2l0aF9yZWNvcmRpbmcgYiB+ZiA9XG4gICAgbGV0IHNhdmVkID0gYW1fcmVjb3JkaW5nICgpIGluXG4gICAgc2V0X3JlY29yZGluZyBiO1xuICAgIEV4bi5wcm90ZWN0IH5mIH5maW5hbGx5OihmdW4gKCkgLT4gc2V0X3JlY29yZGluZyBzYXZlZClcbiAgOztcbmVuZFxuXG5sZXQgaW5pdGlhbGl6ZV9tb2R1bGUgKCkgPSBFeG4ubWF5YmVfc2V0X3JlY29yZGluZyAoKVxuIiwiKCoqIFByaW1pdGl2ZXMgZm9yIHBvbHltb3JwaGljIGNvbXBhcmUuICopXG5cbigqXyBQb2x5bW9ycGhpYyBjb21waWxlciBwcmltaXRpdmVzIGNhbid0IGJlIGFsaWFzZXMgYXMgdGhpcyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoXG4gIGlubGluaW5nLiAoSWYgYWxpYXNlZCB3aXRob3V0IGEgdHlwZSBhbm5vdGF0aW9uLCB0aGUgY29tcGlsZXIgd291bGQgaW1wbGVtZW50IHRoZW1cbiAgdXNpbmcgdGhlIGdlbmVyaWMgY29kZSBkb2luZyBhIEMgY2FsbCwgYW5kIGl0J3MgdGhpcyBjb2RlIHRoYXQgd291bGQgYmUgaW5saW5lZC4pIEFzIGFcbiAgcmVzdWx0IHdlIGhhdmUgdG8gY29weSB0aGUgW2V4dGVybmFsIC4uLl0gZGVjbGFyYXRpb24gaGVyZS4gKilcbmV4dGVybmFsICggPCApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWxlc3N0aGFuXCJcbmV4dGVybmFsICggPD0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVsZXNzZXF1YWxcIlxuZXh0ZXJuYWwgKCA8PiApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJW5vdGVxdWFsXCJcbmV4dGVybmFsICggPSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWVxdWFsXCJcbmV4dGVybmFsICggPiApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWdyZWF0ZXJ0aGFuXCJcbmV4dGVybmFsICggPj0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVncmVhdGVyZXF1YWxcIlxuZXh0ZXJuYWwgYXNjZW5kaW5nIDogJ2EgLT4gJ2EgLT4gaW50ID0gXCIlY29tcGFyZVwiXG5leHRlcm5hbCBjb21wYXJlIDogJ2EgLT4gJ2EgLT4gaW50ID0gXCIlY29tcGFyZVwiXG5leHRlcm5hbCBlcXVhbCA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVlcXVhbFwiXG5cbmxldCBkZXNjZW5kaW5nIHggeSA9IGNvbXBhcmUgeSB4XG5sZXQgbWF4ID0gQ2FtbC5tYXhcbmxldCBtaW4gPSBDYW1sLm1pblxuIiwiKCogVGhpcyBtb2R1bGUgaXMgaW5jbHVkZWQgaW4gW0ltcG9ydF0uICBJdCBpcyBhaW1lZCBhdCBtb2R1bGVzIHRoYXQgZGVmaW5lIHRoZSBzdGFuZGFyZFxuICAgY29tYmluYXRvcnMgZm9yIFtzZXhwX29mXSwgW29mX3NleHBdLCBbY29tcGFyZV0gYW5kIFtoYXNoXSBhbmQgYXJlIGluY2x1ZGVkIGluXG4gICBbSW1wb3J0XS4gKilcblxuaW5jbHVkZSAoXG4gIFNoYWRvd19zdGRsaWIgOlxuICAgIG1vZHVsZSB0eXBlIG9mIHN0cnVjdFxuICAgIGluY2x1ZGUgU2hhZG93X3N0ZGxpYlxuICBlbmRcbiAgd2l0aCB0eXBlICdhIHJlZiA6PSAnYSByZWZcbiAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSBmb3JtYXQgOj0gKCdhLCAnYiwgJ2MpIGZvcm1hdFxuICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MsICdkKSBmb3JtYXQ0IDo9ICgnYSwgJ2IsICdjLCAnZCkgZm9ybWF0NFxuICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgOj0gKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDZcbiAgKCogVGhlc2UgbW9kdWxlcyBhcmUgcmVkZWZpbmVkIGluIEJhc2UgKilcbiAgd2l0aCBtb2R1bGUgQXJyYXkgOj0gU2hhZG93X3N0ZGxpYi5BcnJheVxuICB3aXRoIG1vZHVsZSBBdG9taWMgOj0gU2hhZG93X3N0ZGxpYi5BdG9taWNcbiAgd2l0aCBtb2R1bGUgQm9vbCA6PSBTaGFkb3dfc3RkbGliLkJvb2xcbiAgd2l0aCBtb2R1bGUgQnVmZmVyIDo9IFNoYWRvd19zdGRsaWIuQnVmZmVyXG4gIHdpdGggbW9kdWxlIEJ5dGVzIDo9IFNoYWRvd19zdGRsaWIuQnl0ZXNcbiAgd2l0aCBtb2R1bGUgQ2hhciA6PSBTaGFkb3dfc3RkbGliLkNoYXJcbiAgd2l0aCBtb2R1bGUgRWl0aGVyIDo9IFNoYWRvd19zdGRsaWIuRWl0aGVyXG4gIHdpdGggbW9kdWxlIEZsb2F0IDo9IFNoYWRvd19zdGRsaWIuRmxvYXRcbiAgd2l0aCBtb2R1bGUgSGFzaHRibCA6PSBTaGFkb3dfc3RkbGliLkhhc2h0YmxcbiAgd2l0aCBtb2R1bGUgSW50IDo9IFNoYWRvd19zdGRsaWIuSW50XG4gIHdpdGggbW9kdWxlIEludDMyIDo9IFNoYWRvd19zdGRsaWIuSW50MzJcbiAgd2l0aCBtb2R1bGUgSW50NjQgOj0gU2hhZG93X3N0ZGxpYi5JbnQ2NFxuICB3aXRoIG1vZHVsZSBMYXp5IDo9IFNoYWRvd19zdGRsaWIuTGF6eVxuICB3aXRoIG1vZHVsZSBMaXN0IDo9IFNoYWRvd19zdGRsaWIuTGlzdFxuICB3aXRoIG1vZHVsZSBNYXAgOj0gU2hhZG93X3N0ZGxpYi5NYXBcbiAgd2l0aCBtb2R1bGUgTmF0aXZlaW50IDo9IFNoYWRvd19zdGRsaWIuTmF0aXZlaW50XG4gIHdpdGggbW9kdWxlIE9wdGlvbiA6PSBTaGFkb3dfc3RkbGliLk9wdGlvblxuICB3aXRoIG1vZHVsZSBQcmludGYgOj0gU2hhZG93X3N0ZGxpYi5QcmludGZcbiAgd2l0aCBtb2R1bGUgUXVldWUgOj0gU2hhZG93X3N0ZGxpYi5RdWV1ZVxuICB3aXRoIG1vZHVsZSBSYW5kb20gOj0gU2hhZG93X3N0ZGxpYi5SYW5kb21cbiAgd2l0aCBtb2R1bGUgUmVzdWx0IDo9IFNoYWRvd19zdGRsaWIuUmVzdWx0XG4gIHdpdGggbW9kdWxlIFNldCA6PSBTaGFkb3dfc3RkbGliLlNldFxuICB3aXRoIG1vZHVsZSBTdGFjayA6PSBTaGFkb3dfc3RkbGliLlN0YWNrXG4gIHdpdGggbW9kdWxlIFN0cmluZyA6PSBTaGFkb3dfc3RkbGliLlN0cmluZ1xuICB3aXRoIG1vZHVsZSBTeXMgOj0gU2hhZG93X3N0ZGxpYi5TeXNcbiAgd2l0aCBtb2R1bGUgVWNoYXIgOj0gU2hhZG93X3N0ZGxpYi5VY2hhclxuICB3aXRoIG1vZHVsZSBVbml0IDo9IFNoYWRvd19zdGRsaWIuVW5pdCkgW0BvY2FtbC53YXJuaW5nIFwiLTNcIl1cblxudHlwZSAnYSByZWYgPSAnYSBDYW1sLnJlZiA9IHsgbXV0YWJsZSBjb250ZW50cyA6ICdhIH1cblxuKCogUmVzaHVmZmxlIFtDYW1sXSBzbyB0aGF0IHdlIGNob29zZSB0aGUgbW9kdWxlcyB1c2luZyBsYWJlbHMgd2hlbiBhdmFpbGFibGUuICopXG5tb2R1bGUgQ2FtbCA9IHN0cnVjdFxuXG4gIGluY2x1ZGUgQ2FtbFxuXG4gIG1vZHVsZSBBcmcgPSBDYW1sLkFyZyAoKiogQGNhbm9uaWNhbCBDYW1sLkFyZyAqKVxuXG4gIG1vZHVsZSBBcnJheSA9IENhbWwuU3RkTGFiZWxzLkFycmF5ICgqKiBAY2Fub25pY2FsIENhbWwuU3RkTGFiZWxzLkFycmF5ICopXG5cbiAgbW9kdWxlIEJvb2wgPSBDYW1sLkJvb2wgKCoqIEBjYW5vbmljYWwgQ2FtbC5Cb29sICopXG5cbiAgbW9kdWxlIEJ1ZmZlciA9IENhbWwuQnVmZmVyICgqKiBAY2Fub25pY2FsIENhbWwuQnVmZmVyICopXG5cbiAgbW9kdWxlIEJ5dGVzID0gQ2FtbC5TdGRMYWJlbHMuQnl0ZXMgKCoqIEBjYW5vbmljYWwgQ2FtbC5TdGRMYWJlbHMuQnl0ZXMgKilcblxuICBtb2R1bGUgQ2hhciA9IENhbWwuQ2hhciAoKiogQGNhbm9uaWNhbCBDYW1sLkNoYXIgKilcblxuICBtb2R1bGUgRXBoZW1lcm9uID0gQ2FtbC5FcGhlbWVyb24gKCoqIEBjYW5vbmljYWwgQ2FtbC5FcGhlbWVyb24gKilcblxuICBtb2R1bGUgRmxvYXQgPSBDYW1sLkZsb2F0ICgqKiBAY2Fub25pY2FsIENhbWwuRmxvYXQgKilcblxuICBtb2R1bGUgRm9ybWF0ID0gQ2FtbC5Gb3JtYXQgKCoqIEBjYW5vbmljYWwgQ2FtbC5Gb3JtYXQgKilcblxuICBtb2R1bGUgRnVuID0gQ2FtbC5GdW4gKCoqIEBjYW5vbmljYWwgQ2FtbC5GdW4gKilcblxuICBtb2R1bGUgR2MgPSBDYW1sLkdjICgqKiBAY2Fub25pY2FsIENhbWwuR2MgKilcblxuICBtb2R1bGUgSGFzaHRibCA9IENhbWwuTW9yZUxhYmVscy5IYXNodGJsICgqKiBAY2Fub25pY2FsIENhbWwuTW9yZUxhYmVscy5IYXNodGJsICopXG5cbiAgbW9kdWxlIEludDMyID0gQ2FtbC5JbnQzMiAoKiogQGNhbm9uaWNhbCBDYW1sLkludDMyICopXG5cbiAgbW9kdWxlIEludCA9IENhbWwuSW50ICgqKiBAY2Fub25pY2FsIENhbWwuSW50ICopXG5cbiAgbW9kdWxlIEludDY0ID0gQ2FtbC5JbnQ2NCAoKiogQGNhbm9uaWNhbCBDYW1sLkludDY0ICopXG5cbiAgbW9kdWxlIExhenkgPSBDYW1sLkxhenkgKCoqIEBjYW5vbmljYWwgQ2FtbC5MYXp5ICopXG5cbiAgbW9kdWxlIExleGluZyA9IENhbWwuTGV4aW5nICgqKiBAY2Fub25pY2FsIENhbWwuTGV4aW5nICopXG5cbiAgbW9kdWxlIExpc3QgPSBDYW1sLlN0ZExhYmVscy5MaXN0ICgqKiBAY2Fub25pY2FsIENhbWwuU3RkTGFiZWxzLkxpc3QgKilcblxuICBtb2R1bGUgTWFwID0gQ2FtbC5Nb3JlTGFiZWxzLk1hcCAoKiogQGNhbm9uaWNhbCBDYW1sLk1vcmVMYWJlbHMuTWFwICopXG5cbiAgbW9kdWxlIE5hdGl2ZWludCA9IENhbWwuTmF0aXZlaW50ICgqKiBAY2Fub25pY2FsIENhbWwuTmF0aXZlaW50ICopXG5cbiAgbW9kdWxlIE9iaiA9IENhbWwuT2JqICgqKiBAY2Fub25pY2FsIENhbWwuT2JqICopXG5cbiAgbW9kdWxlIE9wdGlvbiA9IENhbWwuT3B0aW9uICgqKiBAY2Fub25pY2FsIENhbWwuT3B0aW9uICopXG5cbiAgbW9kdWxlIFBhcnNpbmcgPSBDYW1sLlBhcnNpbmcgKCoqIEBjYW5vbmljYWwgQ2FtbC5QYXJzaW5nICopXG5cbiAgbW9kdWxlIFByaW50ZXhjID0gQ2FtbC5QcmludGV4YyAoKiogQGNhbm9uaWNhbCBDYW1sLlByaW50ZXhjICopXG5cbiAgbW9kdWxlIFByaW50ZiA9IENhbWwuUHJpbnRmICgqKiBAY2Fub25pY2FsIENhbWwuUHJpbnRmICopXG5cbiAgbW9kdWxlIFF1ZXVlID0gQ2FtbC5RdWV1ZSAoKiogQGNhbm9uaWNhbCBDYW1sLlF1ZXVlICopXG5cbiAgbW9kdWxlIFJhbmRvbSA9IENhbWwuUmFuZG9tICgqKiBAY2Fub25pY2FsIENhbWwuUmFuZG9tICopXG5cbiAgbW9kdWxlIFJlc3VsdCA9IENhbWwuUmVzdWx0ICgqKiBAY2Fub25pY2FsIENhbWwuUmVzdWx0ICopXG5cbiAgbW9kdWxlIFNjYW5mID0gQ2FtbC5TY2FuZiAoKiogQGNhbm9uaWNhbCBDYW1sLlNjYW5mICopXG5cbiAgbW9kdWxlIFNlcSA9IENhbWwuU2VxICgqKiBAY2Fub25pY2FsIENhbWwuU2VxICopXG5cbiAgbW9kdWxlIFNldCA9IENhbWwuTW9yZUxhYmVscy5TZXQgKCoqIEBjYW5vbmljYWwgQ2FtbC5Nb3JlTGFiZWxzLlNldCAqKVxuXG4gIG1vZHVsZSBTdGFjayA9IENhbWwuU3RhY2sgKCoqIEBjYW5vbmljYWwgQ2FtbC5TdGFjayAqKVxuXG4gIG1vZHVsZSBTdHJpbmcgPSBDYW1sLlN0ZExhYmVscy5TdHJpbmcgKCoqIEBjYW5vbmljYWwgQ2FtbC5TdGRMYWJlbHMuU3RyaW5nICopXG5cbiAgbW9kdWxlIFN5cyA9IENhbWwuU3lzICgqKiBAY2Fub25pY2FsIENhbWwuU3lzICopXG5cbiAgbW9kdWxlIFVjaGFyID0gQ2FtbC5VY2hhciAoKiogQGNhbm9uaWNhbCBDYW1sLlVjaGFyICopXG5cbiAgbW9kdWxlIFVuaXQgPSBDYW1sLlVuaXQgKCoqIEBjYW5vbmljYWwgQ2FtbC5Vbml0ICopXG5cbiAgZXhjZXB0aW9uIE5vdF9mb3VuZCA9IENhbWwuTm90X2ZvdW5kXG5lbmRcblxuZXh0ZXJuYWwgKCB8PiApIDogJ2EgLT4gKCdhIC0+ICdiKSAtPiAnYiA9IFwiJXJldmFwcGx5XCJcblxuKCogVGhlc2UgbmVlZCB0byBiZSBkZWNsYXJlZCBhcyBhbiBleHRlcm5hbCB0byBnZXQgdGhlIGxhenkgYmVoYXZpb3IgKilcbmV4dGVybmFsICggJiYgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdWFuZFwiXG5leHRlcm5hbCAoIHx8ICkgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9IFwiJXNlcXVvclwiXG5leHRlcm5hbCBub3QgOiBib29sIC0+IGJvb2wgPSBcIiVib29sbm90XCJcblxuKCogV2UgdXNlIFtPYmoubWFnaWNdIGhlcmUgYXMgb3RoZXIgaW1wbGVtZW50YXRpb25zIGdlbmVyYXRlIGEgY29uZGl0aW9uYWwganVtcCBhbmQgdGhlXG4gICBwZXJmb3JtYW5jZSBkaWZmZXJlbmNlIGlzIG5vdGljZWFibGUuICopXG5sZXQgYm9vbF90b19pbnQgKHggOiBib29sKSA6IGludCA9IENhbWwuT2JqLm1hZ2ljIHhcblxuKCogVGhpcyBuZWVkIHRvIGJlIGRlY2xhcmVkIGFzIGFuIGV4dGVybmFsIGZvciB0aGUgd2FybmluZ3MgdG8gd29yayBwcm9wZXJseSAqKVxuZXh0ZXJuYWwgaWdub3JlIDogXyAtPiB1bml0ID0gXCIlaWdub3JlXCJcblxubGV0ICggIT0gKSA9IENhbWwuKCAhPSApXG5sZXQgKCAqICkgPSBDYW1sLiggKiApXG5sZXQgKCAqKiApID0gQ2FtbC4oICoqIClcbmxldCAoICouICkgPSBDYW1sLiggKi4gKVxubGV0ICggKyApID0gQ2FtbC4oICsgKVxubGV0ICggKy4gKSA9IENhbWwuKCArLiApXG5sZXQgKCAtICkgPSBDYW1sLiggLSApXG5sZXQgKCAtLiApID0gQ2FtbC4oIC0uIClcbmxldCAoIC8gKSA9IENhbWwuKCAvIClcbmxldCAoIC8uICkgPSBDYW1sLiggLy4gKVxuXG5tb2R1bGUgUG9seSA9IFBvbHkwICgqKiBAY2Fub25pY2FsIEJhc2UuUG9seSAqKVxuXG5tb2R1bGUgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSA9IHN0cnVjdFxuICAoKiBEZWNsYXJlZCBhcyBleHRlcm5hbHMgc28gdGhhdCB0aGUgY29tcGlsZXIgc2tpcHMgdGhlIGNhbWxfYXBwbHlfWCB3cmFwcGluZyBldmVuIHdoZW5cbiAgICAgY29tcGlsaW5nIHdpdGhvdXQgY3Jvc3MgbGlicmFyeSBpbmxpbmluZy4gKilcbiAgZXh0ZXJuYWwgKCA9ICkgOiBpbnQgLT4gaW50IC0+IGJvb2wgPSBcIiVlcXVhbFwiXG4gIGV4dGVybmFsICggPD4gKSA6IGludCAtPiBpbnQgLT4gYm9vbCA9IFwiJW5vdGVxdWFsXCJcbiAgZXh0ZXJuYWwgKCA8ICkgOiBpbnQgLT4gaW50IC0+IGJvb2wgPSBcIiVsZXNzdGhhblwiXG4gIGV4dGVybmFsICggPiApIDogaW50IC0+IGludCAtPiBib29sID0gXCIlZ3JlYXRlcnRoYW5cIlxuICBleHRlcm5hbCAoIDw9ICkgOiBpbnQgLT4gaW50IC0+IGJvb2wgPSBcIiVsZXNzZXF1YWxcIlxuICBleHRlcm5hbCAoID49ICkgOiBpbnQgLT4gaW50IC0+IGJvb2wgPSBcIiVncmVhdGVyZXF1YWxcIlxuICBleHRlcm5hbCBjb21wYXJlIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVjb21wYXJlXCJcbiAgZXh0ZXJuYWwgZXF1YWwgOiBpbnQgLT4gaW50IC0+IGJvb2wgPSBcIiVlcXVhbFwiXG5cbiAgbGV0IGFzY2VuZGluZyAoeCA6IGludCkgeSA9IGNvbXBhcmUgeCB5XG4gIGxldCBkZXNjZW5kaW5nICh4IDogaW50KSB5ID0gY29tcGFyZSB5IHhcbiAgbGV0IG1heCAoeCA6IGludCkgeSA9IGlmIHggPj0geSB0aGVuIHggZWxzZSB5XG4gIGxldCBtaW4gKHggOiBpbnQpIHkgPSBpZiB4IDw9IHkgdGhlbiB4IGVsc2UgeVxuZW5kXG5cbmluY2x1ZGUgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG5tb2R1bGUgSW50MzJfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlID0gc3RydWN0XG4gIGxldCAoIDwgKSAoeCA6IENhbWwuSW50MzIudCkgeSA9IFBvbHkuKCA8ICkgeCB5XG4gIGxldCAoIDw9ICkgKHggOiBDYW1sLkludDMyLnQpIHkgPSBQb2x5LiggPD0gKSB4IHlcbiAgbGV0ICggPD4gKSAoeCA6IENhbWwuSW50MzIudCkgeSA9IFBvbHkuKCA8PiApIHggeVxuICBsZXQgKCA9ICkgKHggOiBDYW1sLkludDMyLnQpIHkgPSBQb2x5LiggPSApIHggeVxuICBsZXQgKCA+ICkgKHggOiBDYW1sLkludDMyLnQpIHkgPSBQb2x5LiggPiApIHggeVxuICBsZXQgKCA+PSApICh4IDogQ2FtbC5JbnQzMi50KSB5ID0gUG9seS4oID49ICkgeCB5XG4gIGxldCBhc2NlbmRpbmcgKHggOiBDYW1sLkludDMyLnQpIHkgPSBQb2x5LmFzY2VuZGluZyB4IHlcbiAgbGV0IGRlc2NlbmRpbmcgKHggOiBDYW1sLkludDMyLnQpIHkgPSBQb2x5LmRlc2NlbmRpbmcgeCB5XG4gIGxldCBjb21wYXJlICh4IDogQ2FtbC5JbnQzMi50KSB5ID0gUG9seS5jb21wYXJlIHggeVxuICBsZXQgZXF1YWwgKHggOiBDYW1sLkludDMyLnQpIHkgPSBQb2x5LmVxdWFsIHggeVxuICBsZXQgbWF4ICh4IDogQ2FtbC5JbnQzMi50KSB5ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIHlcbiAgbGV0IG1pbiAoeCA6IENhbWwuSW50MzIudCkgeSA9IGlmIHggPD0geSB0aGVuIHggZWxzZSB5XG5lbmRcblxubW9kdWxlIEludDY0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSA9IHN0cnVjdFxuICAoKiBEZWNsYXJlZCBhcyBleHRlcm5hbHMgc28gdGhhdCB0aGUgY29tcGlsZXIgc2tpcHMgdGhlIGNhbWxfYXBwbHlfWCB3cmFwcGluZyBldmVuIHdoZW5cbiAgICAgY29tcGlsaW5nIHdpdGhvdXQgY3Jvc3MgbGlicmFyeSBpbmxpbmluZy4gKilcbiAgZXh0ZXJuYWwgKCA9ICkgOiBDYW1sLkludDY0LnQgLT4gQ2FtbC5JbnQ2NC50IC0+IGJvb2wgPSBcIiVlcXVhbFwiXG4gIGV4dGVybmFsICggPD4gKSA6IENhbWwuSW50NjQudCAtPiBDYW1sLkludDY0LnQgLT4gYm9vbCA9IFwiJW5vdGVxdWFsXCJcbiAgZXh0ZXJuYWwgKCA8ICkgOiBDYW1sLkludDY0LnQgLT4gQ2FtbC5JbnQ2NC50IC0+IGJvb2wgPSBcIiVsZXNzdGhhblwiXG4gIGV4dGVybmFsICggPiApIDogQ2FtbC5JbnQ2NC50IC0+IENhbWwuSW50NjQudCAtPiBib29sID0gXCIlZ3JlYXRlcnRoYW5cIlxuICBleHRlcm5hbCAoIDw9ICkgOiBDYW1sLkludDY0LnQgLT4gQ2FtbC5JbnQ2NC50IC0+IGJvb2wgPSBcIiVsZXNzZXF1YWxcIlxuICBleHRlcm5hbCAoID49ICkgOiBDYW1sLkludDY0LnQgLT4gQ2FtbC5JbnQ2NC50IC0+IGJvb2wgPSBcIiVncmVhdGVyZXF1YWxcIlxuICBleHRlcm5hbCBjb21wYXJlIDogQ2FtbC5JbnQ2NC50IC0+IENhbWwuSW50NjQudCAtPiBpbnQgPSBcIiVjb21wYXJlXCJcbiAgZXh0ZXJuYWwgZXF1YWwgOiBDYW1sLkludDY0LnQgLT4gQ2FtbC5JbnQ2NC50IC0+IGJvb2wgPSBcIiVlcXVhbFwiXG5cbiAgbGV0IGFzY2VuZGluZyAoeCA6IENhbWwuSW50NjQudCkgeSA9IFBvbHkuYXNjZW5kaW5nIHggeVxuICBsZXQgZGVzY2VuZGluZyAoeCA6IENhbWwuSW50NjQudCkgeSA9IFBvbHkuZGVzY2VuZGluZyB4IHlcbiAgbGV0IG1heCAoeCA6IENhbWwuSW50NjQudCkgeSA9IGlmIHggPj0geSB0aGVuIHggZWxzZSB5XG4gIGxldCBtaW4gKHggOiBDYW1sLkludDY0LnQpIHkgPSBpZiB4IDw9IHkgdGhlbiB4IGVsc2UgeVxuZW5kXG5cbm1vZHVsZSBOYXRpdmVpbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlID0gc3RydWN0XG4gIGxldCAoIDwgKSAoeCA6IENhbWwuTmF0aXZlaW50LnQpIHkgPSBQb2x5LiggPCApIHggeVxuICBsZXQgKCA8PSApICh4IDogQ2FtbC5OYXRpdmVpbnQudCkgeSA9IFBvbHkuKCA8PSApIHggeVxuICBsZXQgKCA8PiApICh4IDogQ2FtbC5OYXRpdmVpbnQudCkgeSA9IFBvbHkuKCA8PiApIHggeVxuICBsZXQgKCA9ICkgKHggOiBDYW1sLk5hdGl2ZWludC50KSB5ID0gUG9seS4oID0gKSB4IHlcbiAgbGV0ICggPiApICh4IDogQ2FtbC5OYXRpdmVpbnQudCkgeSA9IFBvbHkuKCA+ICkgeCB5XG4gIGxldCAoID49ICkgKHggOiBDYW1sLk5hdGl2ZWludC50KSB5ID0gUG9seS4oID49ICkgeCB5XG4gIGxldCBhc2NlbmRpbmcgKHggOiBDYW1sLk5hdGl2ZWludC50KSB5ID0gUG9seS5hc2NlbmRpbmcgeCB5XG4gIGxldCBkZXNjZW5kaW5nICh4IDogQ2FtbC5OYXRpdmVpbnQudCkgeSA9IFBvbHkuZGVzY2VuZGluZyB4IHlcbiAgbGV0IGNvbXBhcmUgKHggOiBDYW1sLk5hdGl2ZWludC50KSB5ID0gUG9seS5jb21wYXJlIHggeVxuICBsZXQgZXF1YWwgKHggOiBDYW1sLk5hdGl2ZWludC50KSB5ID0gUG9seS5lcXVhbCB4IHlcbiAgbGV0IG1heCAoeCA6IENhbWwuTmF0aXZlaW50LnQpIHkgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgeVxuICBsZXQgbWluICh4IDogQ2FtbC5OYXRpdmVpbnQudCkgeSA9IGlmIHggPD0geSB0aGVuIHggZWxzZSB5XG5lbmRcblxubW9kdWxlIEJvb2xfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlID0gc3RydWN0XG4gIGxldCAoIDwgKSAoeCA6IGJvb2wpIHkgPSBQb2x5LiggPCApIHggeVxuICBsZXQgKCA8PSApICh4IDogYm9vbCkgeSA9IFBvbHkuKCA8PSApIHggeVxuICBsZXQgKCA8PiApICh4IDogYm9vbCkgeSA9IFBvbHkuKCA8PiApIHggeVxuICBsZXQgKCA9ICkgKHggOiBib29sKSB5ID0gUG9seS4oID0gKSB4IHlcbiAgbGV0ICggPiApICh4IDogYm9vbCkgeSA9IFBvbHkuKCA+ICkgeCB5XG4gIGxldCAoID49ICkgKHggOiBib29sKSB5ID0gUG9seS4oID49ICkgeCB5XG4gIGxldCBhc2NlbmRpbmcgKHggOiBib29sKSB5ID0gUG9seS5hc2NlbmRpbmcgeCB5XG4gIGxldCBkZXNjZW5kaW5nICh4IDogYm9vbCkgeSA9IFBvbHkuZGVzY2VuZGluZyB4IHlcbiAgbGV0IGNvbXBhcmUgKHggOiBib29sKSB5ID0gUG9seS5jb21wYXJlIHggeVxuICBsZXQgZXF1YWwgKHggOiBib29sKSB5ID0gUG9seS5lcXVhbCB4IHlcbiAgbGV0IG1heCAoeCA6IGJvb2wpIHkgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgeVxuICBsZXQgbWluICh4IDogYm9vbCkgeSA9IGlmIHggPD0geSB0aGVuIHggZWxzZSB5XG5lbmRcblxubW9kdWxlIENoYXJfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlID0gc3RydWN0XG4gIGxldCAoIDwgKSAoeCA6IGNoYXIpIHkgPSBQb2x5LiggPCApIHggeVxuICBsZXQgKCA8PSApICh4IDogY2hhcikgeSA9IFBvbHkuKCA8PSApIHggeVxuICBsZXQgKCA8PiApICh4IDogY2hhcikgeSA9IFBvbHkuKCA8PiApIHggeVxuICBsZXQgKCA9ICkgKHggOiBjaGFyKSB5ID0gUG9seS4oID0gKSB4IHlcbiAgbGV0ICggPiApICh4IDogY2hhcikgeSA9IFBvbHkuKCA+ICkgeCB5XG4gIGxldCAoID49ICkgKHggOiBjaGFyKSB5ID0gUG9seS4oID49ICkgeCB5XG4gIGxldCBhc2NlbmRpbmcgKHggOiBjaGFyKSB5ID0gUG9seS5hc2NlbmRpbmcgeCB5XG4gIGxldCBkZXNjZW5kaW5nICh4IDogY2hhcikgeSA9IFBvbHkuZGVzY2VuZGluZyB4IHlcbiAgbGV0IGNvbXBhcmUgKHggOiBjaGFyKSB5ID0gUG9seS5jb21wYXJlIHggeVxuICBsZXQgZXF1YWwgKHggOiBjaGFyKSB5ID0gUG9seS5lcXVhbCB4IHlcbiAgbGV0IG1heCAoeCA6IGNoYXIpIHkgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgeVxuICBsZXQgbWluICh4IDogY2hhcikgeSA9IGlmIHggPD0geSB0aGVuIHggZWxzZSB5XG5lbmRcblxubW9kdWxlIFVjaGFyX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSA9IHN0cnVjdFxuICBsZXQgaSB4ID0gQ2FtbC5VY2hhci50b19pbnQgeFxuICBsZXQgKCA8ICkgKHggOiBDYW1sLlVjaGFyLnQpIHkgPSBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPCApIChpIHgpIChpIHkpXG4gIGxldCAoIDw9ICkgKHggOiBDYW1sLlVjaGFyLnQpIHkgPSBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPD0gKSAoaSB4KSAoaSB5KVxuICBsZXQgKCA8PiApICh4IDogQ2FtbC5VY2hhci50KSB5ID0gSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oIDw+ICkgKGkgeCkgKGkgeSlcbiAgbGV0ICggPSApICh4IDogQ2FtbC5VY2hhci50KSB5ID0gSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oID0gKSAoaSB4KSAoaSB5KVxuICBsZXQgKCA+ICkgKHggOiBDYW1sLlVjaGFyLnQpIHkgPSBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPiApIChpIHgpIChpIHkpXG4gIGxldCAoID49ICkgKHggOiBDYW1sLlVjaGFyLnQpIHkgPSBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPj0gKSAoaSB4KSAoaSB5KVxuXG4gIGxldCBhc2NlbmRpbmcgKHggOiBDYW1sLlVjaGFyLnQpIHkgPVxuICAgIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuYXNjZW5kaW5nIChpIHgpIChpIHkpXG4gIDs7XG5cbiAgbGV0IGRlc2NlbmRpbmcgKHggOiBDYW1sLlVjaGFyLnQpIHkgPVxuICAgIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuZGVzY2VuZGluZyAoaSB4KSAoaSB5KVxuICA7O1xuXG4gIGxldCBjb21wYXJlICh4IDogQ2FtbC5VY2hhci50KSB5ID0gSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS5jb21wYXJlIChpIHgpIChpIHkpXG4gIGxldCBlcXVhbCAoeCA6IENhbWwuVWNoYXIudCkgeSA9IEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuZXF1YWwgKGkgeCkgKGkgeSlcbiAgbGV0IG1heCAoeCA6IENhbWwuVWNoYXIudCkgeSA9IGlmIHggPj0geSB0aGVuIHggZWxzZSB5XG4gIGxldCBtaW4gKHggOiBDYW1sLlVjaGFyLnQpIHkgPSBpZiB4IDw9IHkgdGhlbiB4IGVsc2UgeVxuZW5kXG5cbm1vZHVsZSBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgPSBzdHJ1Y3RcbiAgbGV0ICggPCApICh4IDogZmxvYXQpIHkgPSBQb2x5LiggPCApIHggeVxuICBsZXQgKCA8PSApICh4IDogZmxvYXQpIHkgPSBQb2x5LiggPD0gKSB4IHlcbiAgbGV0ICggPD4gKSAoeCA6IGZsb2F0KSB5ID0gUG9seS4oIDw+ICkgeCB5XG4gIGxldCAoID0gKSAoeCA6IGZsb2F0KSB5ID0gUG9seS4oID0gKSB4IHlcbiAgbGV0ICggPiApICh4IDogZmxvYXQpIHkgPSBQb2x5LiggPiApIHggeVxuICBsZXQgKCA+PSApICh4IDogZmxvYXQpIHkgPSBQb2x5LiggPj0gKSB4IHlcbiAgbGV0IGFzY2VuZGluZyAoeCA6IGZsb2F0KSB5ID0gUG9seS5hc2NlbmRpbmcgeCB5XG4gIGxldCBkZXNjZW5kaW5nICh4IDogZmxvYXQpIHkgPSBQb2x5LmRlc2NlbmRpbmcgeCB5XG4gIGxldCBjb21wYXJlICh4IDogZmxvYXQpIHkgPSBQb2x5LmNvbXBhcmUgeCB5XG4gIGxldCBlcXVhbCAoeCA6IGZsb2F0KSB5ID0gUG9seS5lcXVhbCB4IHlcbiAgbGV0IG1heCAoeCA6IGZsb2F0KSB5ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIHlcbiAgbGV0IG1pbiAoeCA6IGZsb2F0KSB5ID0gaWYgeCA8PSB5IHRoZW4geCBlbHNlIHlcbmVuZFxuXG5tb2R1bGUgU3RyaW5nX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSA9IHN0cnVjdFxuICBsZXQgKCA8ICkgKHggOiBzdHJpbmcpIHkgPSBQb2x5LiggPCApIHggeVxuICBsZXQgKCA8PSApICh4IDogc3RyaW5nKSB5ID0gUG9seS4oIDw9ICkgeCB5XG4gIGxldCAoIDw+ICkgKHggOiBzdHJpbmcpIHkgPSBQb2x5LiggPD4gKSB4IHlcbiAgbGV0ICggPSApICh4IDogc3RyaW5nKSB5ID0gUG9seS4oID0gKSB4IHlcbiAgbGV0ICggPiApICh4IDogc3RyaW5nKSB5ID0gUG9seS4oID4gKSB4IHlcbiAgbGV0ICggPj0gKSAoeCA6IHN0cmluZykgeSA9IFBvbHkuKCA+PSApIHggeVxuICBsZXQgYXNjZW5kaW5nICh4IDogc3RyaW5nKSB5ID0gUG9seS5hc2NlbmRpbmcgeCB5XG4gIGxldCBkZXNjZW5kaW5nICh4IDogc3RyaW5nKSB5ID0gUG9seS5kZXNjZW5kaW5nIHggeVxuICBsZXQgY29tcGFyZSAoeCA6IHN0cmluZykgeSA9IFBvbHkuY29tcGFyZSB4IHlcbiAgbGV0IGVxdWFsICh4IDogc3RyaW5nKSB5ID0gUG9seS5lcXVhbCB4IHlcbiAgbGV0IG1heCAoeCA6IHN0cmluZykgeSA9IGlmIHggPj0geSB0aGVuIHggZWxzZSB5XG4gIGxldCBtaW4gKHggOiBzdHJpbmcpIHkgPSBpZiB4IDw9IHkgdGhlbiB4IGVsc2UgeVxuZW5kXG5cbm1vZHVsZSBCeXRlc19yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgPSBzdHJ1Y3RcbiAgbGV0ICggPCApICh4IDogYnl0ZXMpIHkgPSBQb2x5LiggPCApIHggeVxuICBsZXQgKCA8PSApICh4IDogYnl0ZXMpIHkgPSBQb2x5LiggPD0gKSB4IHlcbiAgbGV0ICggPD4gKSAoeCA6IGJ5dGVzKSB5ID0gUG9seS4oIDw+ICkgeCB5XG4gIGxldCAoID0gKSAoeCA6IGJ5dGVzKSB5ID0gUG9seS4oID0gKSB4IHlcbiAgbGV0ICggPiApICh4IDogYnl0ZXMpIHkgPSBQb2x5LiggPiApIHggeVxuICBsZXQgKCA+PSApICh4IDogYnl0ZXMpIHkgPSBQb2x5LiggPj0gKSB4IHlcbiAgbGV0IGFzY2VuZGluZyAoeCA6IGJ5dGVzKSB5ID0gUG9seS5hc2NlbmRpbmcgeCB5XG4gIGxldCBkZXNjZW5kaW5nICh4IDogYnl0ZXMpIHkgPSBQb2x5LmRlc2NlbmRpbmcgeCB5XG4gIGxldCBjb21wYXJlICh4IDogYnl0ZXMpIHkgPSBQb2x5LmNvbXBhcmUgeCB5XG4gIGxldCBlcXVhbCAoeCA6IGJ5dGVzKSB5ID0gUG9seS5lcXVhbCB4IHlcbiAgbGV0IG1heCAoeCA6IGJ5dGVzKSB5ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIHlcbiAgbGV0IG1pbiAoeCA6IGJ5dGVzKSB5ID0gaWYgeCA8PSB5IHRoZW4geCBlbHNlIHlcbmVuZFxuXG4oKiBUaGlzIG5lZWRzIHRvIGJlIGRlZmluZWQgYXMgYW4gZXh0ZXJuYWwgc28gdGhhdCB0aGUgY29tcGlsZXIgY2FuIHNwZWNpYWxpemUgaXQgYXMgYVxuICAgZGlyZWN0IHNldCBvciBjYW1sX21vZGlmeSAqKVxuZXh0ZXJuYWwgKCA6PSApIDogJ2EgcmVmIC0+ICdhIC0+IHVuaXQgPSBcIiVzZXRmaWVsZDBcIlxuXG4oKiBUaGVzZSBuZWVkIHRvIGJlIGRlZmluZWQgYXMgYW4gZXh0ZXJuYWwgb3RoZXJ3aXNlIHRoZSBjb21waWxlciB3b24ndCB1bmJveFxuICAgcmVmZXJlbmNlcyAqKVxuZXh0ZXJuYWwgKCAhICkgOiAnYSByZWYgLT4gJ2EgPSBcIiVmaWVsZDBcIlxuZXh0ZXJuYWwgcmVmIDogJ2EgLT4gJ2EgcmVmID0gXCIlbWFrZW11dGFibGVcIlxuXG5sZXQgKCBAICkgPSBDYW1sLiggQCApXG5sZXQgKCBeICkgPSBDYW1sLiggXiApXG5sZXQgKCB+LSApID0gQ2FtbC4oIH4tIClcbmxldCAoIH4tLiApID0gQ2FtbC4oIH4tLiApXG5sZXQgKCBhc3IgKSA9IENhbWwuKCBhc3IgKVxubGV0ICggbGFuZCApID0gQ2FtbC4oIGxhbmQgKVxubGV0IGxub3QgPSBDYW1sLmxub3RcbmxldCAoIGxvciApID0gQ2FtbC4oIGxvciApXG5sZXQgKCBsc2wgKSA9IENhbWwuKCBsc2wgKVxubGV0ICggbHNyICkgPSBDYW1sLiggbHNyIClcbmxldCAoIGx4b3IgKSA9IENhbWwuKCBseG9yIClcbmxldCAoIG1vZCApID0gQ2FtbC4oIG1vZCApXG5sZXQgYWJzID0gQ2FtbC5hYnNcbmxldCBmYWlsd2l0aCA9IENhbWwuZmFpbHdpdGhcbmxldCBmc3QgPSBDYW1sLmZzdFxubGV0IGludmFsaWRfYXJnID0gQ2FtbC5pbnZhbGlkX2FyZ1xubGV0IHNuZCA9IENhbWwuc25kXG5cbigqIFtyYWlzZV0gbmVlZHMgdG8gYmUgZGVmaW5lZCBhcyBhbiBleHRlcm5hbCBhcyB0aGUgY29tcGlsZXIgYXV0b21hdGljYWxseSByZXBsYWNlc1xuICAgJyVyYWlzZScgYnkgJyVyZXJhaXNlJyB3aGVuIGFwcHJvcHJpYXRlLiAqKVxuZXh0ZXJuYWwgcmFpc2UgOiBleG4gLT4gXyA9IFwiJXJhaXNlXCJcblxubGV0IHBoeXNfZXF1YWwgPSBDYW1sLiggPT0gKVxubGV0IGRlY3IgPSBDYW1sLmRlY3JcbmxldCBpbmNyID0gQ2FtbC5pbmNyXG5cbigqIHVzZWQgYnkgc2V4cF9jb252LCB3aGljaCBmbG9hdDAgZGVwZW5kcyBvbiB0aHJvdWdoIG9wdGlvbiAqKVxubGV0IGZsb2F0X29mX3N0cmluZyA9IENhbWwuZmxvYXRfb2Zfc3RyaW5nXG5cbigqIFthbV90ZXN0aW5nXSBpcyB1c2VkIGluIGEgZmV3IHBsYWNlcyB0byBiZWhhdmUgZGlmZmVyZW50bHkgd2hlbiBpbiB0ZXN0aW5nIG1vZGUsIHN1Y2hcbiAgIGFzIGluIFtyYW5kb20ubWxdLiAgW2FtX3Rlc3RpbmddIGlzIGltcGxlbWVudGVkIHVzaW5nIFtCYXNlX2FtX3Rlc3RpbmddLCBhIHdlYWsgQy9qc1xuICAgcHJpbWl0aXZlIHRoYXQgcmV0dXJucyBbZmFsc2VdLCBidXQgd2hlbiBsaW5raW5nIGFuIGlubGluZS10ZXN0LXJ1bm5lciBleGVjdXRhYmxlLCBpc1xuICAgb3ZlcnJpZGRlbiBieSBhbm90aGVyIHByaW1pdGl2ZSB0aGF0IHJldHVybnMgW3RydWVdLiAqKVxuZXh0ZXJuYWwgYW1fdGVzdGluZyA6IHVuaXQgLT4gYm9vbCA9IFwiQmFzZV9hbV90ZXN0aW5nXCJcblxubGV0IGFtX3Rlc3RpbmcgPSBhbV90ZXN0aW5nICgpXG4iLCIoKiBbU3RyaW5nMF0gZGVmaW5lcyBzdHJpbmcgZnVuY3Rpb25zIHRoYXQgYXJlIHByaW1pdGl2ZXMgb3IgY2FuIGJlIHNpbXBseSBkZWZpbmVkIGluXG4gICB0ZXJtcyBvZiBbQ2FtbC5TdHJpbmddLiBbU3RyaW5nMF0gaXMgaW50ZW5kZWQgdG8gY29tcGxldGVseSBleHByZXNzIHRoZSBwYXJ0IG9mXG4gICBbQ2FtbC5TdHJpbmddIHRoYXQgW0Jhc2VdIHVzZXMgLS0gbm8gb3RoZXIgZmlsZSBpbiBCYXNlIG90aGVyIHRoYW4gc3RyaW5nMC5tbCBzaG91bGRcbiAgIHVzZSBbQ2FtbC5TdHJpbmddLiAgW1N0cmluZzBdIGhhcyBmZXcgZGVwZW5kZW5jaWVzLCBhbmQgc28gaXMgYXZhaWxhYmxlIGVhcmx5IGluIEJhc2Unc1xuICAgYnVpbGQgb3JkZXIuXG5cbiAgIEFsbCBCYXNlIGZpbGVzIHRoYXQgbmVlZCB0byB1c2Ugc3RyaW5ncywgaW5jbHVkaW5nIHRoZSBzdWJzY3JpcHQgc3ludGF4XG4gICBbeC4oaSldIG9yIFt4LihpKSA8LSBlXSB3aGljaCB0aGUgT0NhbWwgcGFyc2VyIGRlc3VnYXJzIGludG8gY2FsbHMgdG9cbiAgIFtTdHJpbmddLCBhbmQgY29tZSBiZWZvcmUgW0Jhc2UuU3RyaW5nXSBpbiBidWlsZCBvcmRlciBzaG91bGQgZG9cblxuICAge1tcbiAgICAgbW9kdWxlIFN0cmluZyA9IFN0cmluZzBcbiAgIF19XG5cbiAgIERlZmluaW5nIFttb2R1bGUgU3RyaW5nID0gU3RyaW5nMF0gaXMgYWxzbyBuZWNlc3NhcnkgYmVjYXVzZSBpdCBwcmV2ZW50c1xuICAgb2NhbWxkZXAgZnJvbSBtaXN0YWtlbmx5IGNhdXNpbmcgYSBmaWxlIHRvIGRlcGVuZCBvbiBbQmFzZS5TdHJpbmddLiAqKVxuXG5vcGVuISBJbXBvcnQwXG5tb2R1bGUgQnl0ZXMgPSBCeXRlczBcbm1vZHVsZSBTeXMgPSBTeXMwXG5cbm1vZHVsZSBTdHJpbmcgPSBzdHJ1Y3RcbiAgZXh0ZXJuYWwgZ2V0IDogc3RyaW5nIC0+IGludCAtPiBjaGFyID0gXCIlc3RyaW5nX3NhZmVfZ2V0XCJcbiAgZXh0ZXJuYWwgbGVuZ3RoIDogc3RyaW5nIC0+IGludCA9IFwiJXN0cmluZ19sZW5ndGhcIlxuICBleHRlcm5hbCB1bnNhZmVfZ2V0IDogc3RyaW5nIC0+IGludCAtPiBjaGFyID0gXCIlc3RyaW5nX3Vuc2FmZV9nZXRcIlxuICBleHRlcm5hbCBzZXQgICAgICAgIDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgLT4gdW5pdCA9IFwiJWJ5dGVzX3NhZmVfc2V0XCJcbiAgZXh0ZXJuYWwgdW5zYWZlX3NldCA6IGJ5dGVzIC0+IGludCAtPiBjaGFyIC0+IHVuaXQgPSBcIiVieXRlc191bnNhZmVfc2V0XCJcbmVuZFxuXG5pbmNsdWRlIFN0cmluZ1xuXG5sZXQgbWF4X2xlbmd0aCA9IFN5cy5tYXhfc3RyaW5nX2xlbmd0aFxubGV0ICggXiApID0gKCBeIClcbmxldCBjYXBpdGFsaXplID0gQ2FtbC5TdHJpbmcuY2FwaXRhbGl6ZV9hc2NpaVxubGV0IGNvbXBhcmUgPSBDYW1sLlN0cmluZy5jb21wYXJlXG5cbmxldCBjb3B5IHggPVxuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nXG4gICAgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6XG4gICAgICAoQnl0ZXMub2Zfc3RyaW5nIHgpXG47O1xuXG5sZXQgZXNjYXBlZCA9IENhbWwuU3RyaW5nLmVzY2FwZWRcbmxldCBsb3dlcmNhc2UgPSBDYW1sLlN0cmluZy5sb3dlcmNhc2VfYXNjaWlcbmxldCBtYWtlID0gQ2FtbC5TdHJpbmcubWFrZVxubGV0IHN1YiA9IENhbWwuU3RyaW5nLnN1YlxubGV0IHVuY2FwaXRhbGl6ZSA9IENhbWwuU3RyaW5nLnVuY2FwaXRhbGl6ZV9hc2NpaVxubGV0IHVuc2FmZV9ibGl0ID0gQ2FtbC5TdHJpbmcudW5zYWZlX2JsaXRcbmxldCB1cHBlcmNhc2UgPSBDYW1sLlN0cmluZy51cHBlcmNhc2VfYXNjaWlcblxubGV0IGNvbmNhdCA/KHNlcCA9IFwiXCIpIGwgPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPiBcIlwiXG4gICgqIFRoZSBzdGRsaWIgZG9lcyBub3Qgc3BlY2lhbGl6ZSB0aGlzIGNhc2UgYmVjYXVzZSBpdCBjb3VsZCBicmVhayBleGlzdGluZyBwcm9qZWN0cy4gKilcbiAgfCBbIHggXSAtPiB4XG4gIHwgbCAtPiBDYW1sLlN0cmluZy5jb25jYXQgfnNlcCBsXG47O1xuXG4oKiBUaGVzZSBhcmUgZXRhIGV4cGFuZGVkIGluIG9yZGVyIHRvIHBlcm11dGUgcGFyYW1ldGVyIG9yZGVyIHRvIGZvbGxvdyBCYXNlXG4gICBjb252ZW50aW9ucy4gKilcbmxldCBpdGVyIHQgfmYgPSBDYW1sLlN0cmluZy5pdGVyIHQgfmZcbiIsIigqKiBUaGlzIG1vZHVsZSBpcyB0aGUgdG9wbGV2ZWwgb2YgdGhlIEJhc2UgbGlicmFyeTsgaXQncyB3aGF0IHlvdSBnZXQgd2hlbiB5b3Ugd3JpdGVcbiAgICBbb3BlbiBCYXNlXS5cblxuICAgIFRoZSBnb2FsIG9mIEJhc2UgaXMgYm90aCB0byBiZSBhIG1vcmUgY29tcGxldGUgc3RhbmRhcmQgbGlicmFyeSwgd2l0aCByaWNoZXIgQVBJcyxcbiAgICBhbmQgdG8gYmUgbW9yZSBjb25zaXN0ZW50IGluIGl0cyBkZXNpZ24uIEZvciBpbnN0YW5jZSwgaW4gdGhlIHN0YW5kYXJkIGxpYnJhcnlcbiAgICBzb21lIHRoaW5ncyBoYXZlIG1vZHVsZXMgYW5kIG90aGVycyBkb24ndDsgaW4gQmFzZSwgZXZlcnl0aGluZyBpcyBhIG1vZHVsZS5cblxuICAgIEJhc2UgZXh0ZW5kcyBzb21lIG1vZHVsZXMgYW5kIGRhdGEgc3RydWN0dXJlcyBmcm9tIHRoZSBzdGFuZGFyZCBsaWJyYXJ5LCBsaWtlIFtBcnJheV0sXG4gICAgW0J1ZmZlcl0sIFtCeXRlc10sIFtDaGFyXSwgW0hhc2h0YmxdLCBbSW50MzJdLCBbSW50NjRdLCBbTGF6eV0sIFtMaXN0XSwgW01hcF0sXG4gICAgW05hdGl2ZWludF0sIFtQcmludGZdLCBbUmFuZG9tXSwgW1NldF0sIFtTdHJpbmddLCBbU3lzXSwgYW5kIFtVY2hhcl0uIE9uZSBrZXlcbiAgICBkaWZmZXJlbmNlIGlzIHRoYXQgQmFzZSBkb2Vzbid0IHVzZSBleGNlcHRpb25zIGFzIG11Y2ggYXMgdGhlIHN0YW5kYXJkIGxpYnJhcnkgYW5kXG4gICAgaW5zdGVhZCBtYWtlcyBoZWF2eSB1c2Ugb2YgdGhlIFtSZXN1bHRdIHR5cGUsIGFzIGluOlxuXG4gICAge1sgdHlwZSAoJ2EsJ2IpIHJlc3VsdCA9IE9rIG9mICdhIHwgRXJyb3Igb2YgJ2IgXX1cblxuICAgIEJhc2UgYWxzbyBhZGRzIGVudGlyZWx5IG5ldyBtb2R1bGVzLCBtb3N0IG5vdGFibHk6XG5cbiAgICAtIFtDb21wYXJhYmxlXSwgW0NvbXBhcmF0b3JdLCBhbmQgW0NvbXBhcmlzb25zXSBpbiBsaWV1IG9mIHBvbHltb3JwaGljIGNvbXBhcmUuXG4gICAgLSBbQ29udGFpbmVyXSwgd2hpY2ggcHJvdmlkZXMgYSBjb25zaXN0ZW50IGludGVyZmFjZSBhY3Jvc3MgY29udGFpbmVyLWxpa2UgZGF0YVxuICAgICAgc3RydWN0dXJlcyAoYXJyYXlzLCBsaXN0cywgc3RyaW5ncykuXG4gICAgLSBbUmVzdWx0XSwgW0Vycm9yXSwgYW5kIFtPcl9lcnJvcl0sIHN1cHBvcnRpbmcgdGhlIG9yLWVycm9yIHBhdHRlcm4uXG4qKVxuXG4oKl8gV2UgaGlkZSB0aGlzIGZyb20gdGhlIHdlYiBkb2NzIGJlY2F1c2UgdGhlIGxpbmUgd3JhcHBpbmcgaXMgYmFkLCBtYWtpbmcgaXRcbiAgcHJldHR5IG11Y2ggaW5zY3J1dGFibGUuICopXG4oKiovKiopXG5cbigqIFRoZSBpbnRlbnQgaXMgdG8gc2hhZG93IGFsbCBvZiBJTlJJQSdzIHN0YW5kYXJkIGxpYnJhcnkuICBNb2R1bGVzIGJlbG93IHdvdWxkIGNhdXNlXG4gICBjb21waWxhdGlvbiBlcnJvcnMgd2l0aG91dCBiZWluZyByZW1vdmVkIGZyb20gW1NoYWRvd19zdGRsaWJdIGJlZm9yZSBpbmNsdXNpb24uICopXG5cbmluY2x1ZGUgKFxuICBTaGFkb3dfc3RkbGliIDpcbiAgICBtb2R1bGUgdHlwZSBvZiBzdHJ1Y3RcbiAgICBpbmNsdWRlIFNoYWRvd19zdGRsaWJcbiAgZW5kXG4gICgqIE1vZHVsZXMgZGVmaW5lZCBpbiBCYXNlICopXG4gIHdpdGggbW9kdWxlIEFycmF5IDo9IFNoYWRvd19zdGRsaWIuQXJyYXlcbiAgd2l0aCBtb2R1bGUgQXRvbWljIDo9IFNoYWRvd19zdGRsaWIuQXRvbWljXG4gIHdpdGggbW9kdWxlIEJvb2wgOj0gU2hhZG93X3N0ZGxpYi5Cb29sXG4gIHdpdGggbW9kdWxlIEJ1ZmZlciA6PSBTaGFkb3dfc3RkbGliLkJ1ZmZlclxuICB3aXRoIG1vZHVsZSBCeXRlcyA6PSBTaGFkb3dfc3RkbGliLkJ5dGVzXG4gIHdpdGggbW9kdWxlIENoYXIgOj0gU2hhZG93X3N0ZGxpYi5DaGFyXG4gIHdpdGggbW9kdWxlIEVpdGhlciA6PSBTaGFkb3dfc3RkbGliLkVpdGhlclxuICB3aXRoIG1vZHVsZSBGbG9hdCA6PSBTaGFkb3dfc3RkbGliLkZsb2F0XG4gIHdpdGggbW9kdWxlIEhhc2h0YmwgOj0gU2hhZG93X3N0ZGxpYi5IYXNodGJsXG4gIHdpdGggbW9kdWxlIEluX2NoYW5uZWwgOj0gU2hhZG93X3N0ZGxpYi5Jbl9jaGFubmVsXG4gIHdpdGggbW9kdWxlIEludCA6PSBTaGFkb3dfc3RkbGliLkludFxuICB3aXRoIG1vZHVsZSBJbnQzMiA6PSBTaGFkb3dfc3RkbGliLkludDMyXG4gIHdpdGggbW9kdWxlIEludDY0IDo9IFNoYWRvd19zdGRsaWIuSW50NjRcbiAgd2l0aCBtb2R1bGUgTGF6eSA6PSBTaGFkb3dfc3RkbGliLkxhenlcbiAgd2l0aCBtb2R1bGUgTGlzdCA6PSBTaGFkb3dfc3RkbGliLkxpc3RcbiAgd2l0aCBtb2R1bGUgTWFwIDo9IFNoYWRvd19zdGRsaWIuTWFwXG4gIHdpdGggbW9kdWxlIE5hdGl2ZWludCA6PSBTaGFkb3dfc3RkbGliLk5hdGl2ZWludFxuICB3aXRoIG1vZHVsZSBPcHRpb24gOj0gU2hhZG93X3N0ZGxpYi5PcHRpb25cbiAgd2l0aCBtb2R1bGUgT3V0X2NoYW5uZWwgOj0gU2hhZG93X3N0ZGxpYi5PdXRfY2hhbm5lbFxuICB3aXRoIG1vZHVsZSBQcmludGYgOj0gU2hhZG93X3N0ZGxpYi5QcmludGZcbiAgd2l0aCBtb2R1bGUgUXVldWUgOj0gU2hhZG93X3N0ZGxpYi5RdWV1ZVxuICB3aXRoIG1vZHVsZSBSYW5kb20gOj0gU2hhZG93X3N0ZGxpYi5SYW5kb21cbiAgd2l0aCBtb2R1bGUgUmVzdWx0IDo9IFNoYWRvd19zdGRsaWIuUmVzdWx0XG4gIHdpdGggbW9kdWxlIFNldCA6PSBTaGFkb3dfc3RkbGliLlNldFxuICB3aXRoIG1vZHVsZSBTdGFjayA6PSBTaGFkb3dfc3RkbGliLlN0YWNrXG4gIHdpdGggbW9kdWxlIFN0cmluZyA6PSBTaGFkb3dfc3RkbGliLlN0cmluZ1xuICB3aXRoIG1vZHVsZSBTeXMgOj0gU2hhZG93X3N0ZGxpYi5TeXNcbiAgd2l0aCBtb2R1bGUgVWNoYXIgOj0gU2hhZG93X3N0ZGxpYi5VY2hhclxuICB3aXRoIG1vZHVsZSBVbml0IDo9IFNoYWRvd19zdGRsaWIuVW5pdFxuICAoKiBTdXBwb3J0IGZvciBnZW5lcmF0ZWQgbGV4ZXJzICopXG4gIHdpdGggbW9kdWxlIExleGluZyA6PSBTaGFkb3dfc3RkbGliLkxleGluZ1xuICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIGZvcm1hdCA6PSAoJ2EsICdiLCAnYykgZm9ybWF0XG4gIHdpdGggdHlwZSAoJ2EsICdiLCAnYywgJ2QpIGZvcm1hdDQgOj0gKCdhLCAnYiwgJ2MsICdkKSBmb3JtYXQ0XG4gIHdpdGggdHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiA6PSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NlxuICB3aXRoIHR5cGUgJ2EgcmVmIDo9ICdhIHJlZikgW0BvY2FtbC53YXJuaW5nIFwiLTNcIl1cblxuKCoqLyoqKVxuXG5vcGVuISBJbXBvcnRcbm1vZHVsZSBBcHBsaWNhdGl2ZSA9IEFwcGxpY2F0aXZlXG5tb2R1bGUgQXJyYXkgPSBBcnJheVxubW9kdWxlIEF2bHRyZWUgPSBBdmx0cmVlXG5tb2R1bGUgQmFja3RyYWNlID0gQmFja3RyYWNlXG5tb2R1bGUgQmluYXJ5X3NlYXJjaCA9IEJpbmFyeV9zZWFyY2hcbm1vZHVsZSBCaW5hcnlfc2VhcmNoYWJsZSA9IEJpbmFyeV9zZWFyY2hhYmxlXG5tb2R1bGUgQmxpdCA9IEJsaXRcbm1vZHVsZSBCb29sID0gQm9vbFxubW9kdWxlIEJ1ZmZlciA9IEJ1ZmZlclxubW9kdWxlIEJ5dGVzID0gQnl0ZXNcbm1vZHVsZSBDaGFyID0gQ2hhclxubW9kdWxlIENvbXBhcmFibGUgPSBDb21wYXJhYmxlXG5tb2R1bGUgQ29tcGFyYXRvciA9IENvbXBhcmF0b3Jcbm1vZHVsZSBDb21wYXJpc29ucyA9IENvbXBhcmlzb25zXG5tb2R1bGUgQ29udGFpbmVyID0gQ29udGFpbmVyXG5tb2R1bGUgRWl0aGVyID0gRWl0aGVyXG5tb2R1bGUgRXF1YWwgPSBFcXVhbFxubW9kdWxlIEVycm9yID0gRXJyb3Jcbm1vZHVsZSBFeG4gPSBFeG5cbm1vZHVsZSBGaWVsZCA9IEZpZWxkXG5tb2R1bGUgRmxvYXQgPSBGbG9hdFxubW9kdWxlIEZsb2F0YWJsZSA9IEZsb2F0YWJsZVxubW9kdWxlIEZuID0gRm5cbm1vZHVsZSBGb3JtYXR0ZXIgPSBGb3JtYXR0ZXJcbm1vZHVsZSBIYXNoID0gSGFzaFxubW9kdWxlIEhhc2hfc2V0ID0gSGFzaF9zZXRcbm1vZHVsZSBIYXNoYWJsZSA9IEhhc2hhYmxlXG5tb2R1bGUgSGFzaGVyID0gSGFzaGVyXG5tb2R1bGUgSGFzaHRibCA9IEhhc2h0Ymxcbm1vZHVsZSBJZGVudGlmaWFibGUgPSBJZGVudGlmaWFibGVcbm1vZHVsZSBJbmRleGVkX2NvbnRhaW5lciA9IEluZGV4ZWRfY29udGFpbmVyXG5tb2R1bGUgSW5mbyA9IEluZm9cbm1vZHVsZSBJbnQgPSBJbnRcbm1vZHVsZSBJbnRfY29udmVyc2lvbnMgPSBJbnRfY29udmVyc2lvbnNcbm1vZHVsZSBJbnQzMiA9IEludDMyXG5tb2R1bGUgSW50NjMgPSBJbnQ2M1xubW9kdWxlIEludDY0ID0gSW50NjRcbm1vZHVsZSBJbnRhYmxlID0gSW50YWJsZVxubW9kdWxlIEludF9tYXRoID0gSW50X21hdGhcbm1vZHVsZSBJbnZhcmlhbnQgPSBJbnZhcmlhbnRcbm1vZHVsZSBMYXp5ID0gTGF6eVxubW9kdWxlIExpc3QgPSBMaXN0XG5tb2R1bGUgTWFwID0gTWFwXG5tb2R1bGUgTWF5YmVfYm91bmQgPSBNYXliZV9ib3VuZFxubW9kdWxlIE1vbmFkID0gTW9uYWRcbm1vZHVsZSBOYXRpdmVpbnQgPSBOYXRpdmVpbnRcbm1vZHVsZSBOb3RoaW5nID0gTm90aGluZ1xubW9kdWxlIE9wdGlvbiA9IE9wdGlvblxubW9kdWxlIE9wdGlvbl9hcnJheSA9IE9wdGlvbl9hcnJheVxubW9kdWxlIE9yX2Vycm9yID0gT3JfZXJyb3Jcbm1vZHVsZSBPcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uID0gT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vblxubW9kdWxlIE9yZGVyaW5nID0gT3JkZXJpbmdcbm1vZHVsZSBQb2x5ID0gUG9seVxubW9kdWxlIFBvbHltb3JwaGljX2NvbXBhcmUgPSBQb2x5IFtAQGRlcHJlY2F0ZWQgXCJbc2luY2UgMjAxOC0xMV0gdXNlIFtQb2x5XSBpbnN0ZWFkXCJdXG5cbm1vZHVsZSBQb3Bjb3VudCA9IFBvcGNvdW50XG5bQEBkZXByZWNhdGVkIFwiW3NpbmNlIDIwMTgtMTBdIHVzZSBbcG9wY291bnRdIGZ1bmN0aW9ucyBpbiB0aGUgaW5kaXZpZHVhbCBpbnQgbW9kdWxlc1wiXVxuXG5tb2R1bGUgUHJldHR5X3ByaW50ZXIgPSBQcmV0dHlfcHJpbnRlclxubW9kdWxlIFByaW50ZiA9IFByaW50ZlxubW9kdWxlIExpbmtlZF9xdWV1ZSA9IExpbmtlZF9xdWV1ZVxubW9kdWxlIFF1ZXVlID0gUXVldWVcbm1vZHVsZSBSYW5kb20gPSBSYW5kb21cbm1vZHVsZSBSZWYgPSBSZWZcbm1vZHVsZSBSZXN1bHQgPSBSZXN1bHRcbm1vZHVsZSBTZXF1ZW5jZSA9IFNlcXVlbmNlXG5tb2R1bGUgU2V0ID0gU2V0XG5tb2R1bGUgU2V4cGFibGUgPSBTZXhwYWJsZVxubW9kdWxlIFNpZ24gPSBTaWduXG5tb2R1bGUgU2lnbl9vcl9uYW4gPSBTaWduX29yX25hblxubW9kdWxlIFNvdXJjZV9jb2RlX3Bvc2l0aW9uID0gU291cmNlX2NvZGVfcG9zaXRpb25cbm1vZHVsZSBTdGFjayA9IFN0YWNrXG5tb2R1bGUgU3RhZ2VkID0gU3RhZ2VkXG5tb2R1bGUgU3RyaW5nID0gU3RyaW5nXG5tb2R1bGUgU3RyaW5nYWJsZSA9IFN0cmluZ2FibGVcbm1vZHVsZSBTeXMgPSBTeXNcbm1vZHVsZSBUID0gVFxubW9kdWxlIFR5cGVfZXF1YWwgPSBUeXBlX2VxdWFsXG5tb2R1bGUgVW5pZm9ybV9hcnJheSA9IFVuaWZvcm1fYXJyYXlcbm1vZHVsZSBVbml0ID0gVW5pdFxubW9kdWxlIFVjaGFyID0gVWNoYXJcbm1vZHVsZSBWYXJpYW50ID0gVmFyaWFudFxubW9kdWxlIFdpdGhfcmV0dXJuID0gV2l0aF9yZXR1cm5cbm1vZHVsZSBXb3JkX3NpemUgPSBXb3JkX3NpemVcblxuKCogQXZvaWQgYSBsZXZlbCBvZiBpbmRpcmVjdGlvbiBmb3IgdXNlcyBvZiB0aGUgc2lnbmF0dXJlcyBkZWZpbmVkIGluIFtUXS4gKilcbmluY2x1ZGUgVFxuXG4oKiBUaGlzIGlzIGEgaGFjayBzbyB0aGF0IG9kb2MgY3JlYXRlcyBiZXR0ZXIgZG9jdW1lbnRhdGlvbi4gKilcbm1vZHVsZSBTZXhwID0gc3RydWN0XG4gIGluY2x1ZGUgU2V4cF93aXRoX2NvbXBhcmFibGUgKCoqIEBpbmxpbmUgKilcbmVuZFxuXG4oKiovKiopXG5cbm1vZHVsZSBFeHBvcnRlZF9mb3Jfc3BlY2lmaWNfdXNlcyA9IHN0cnVjdFxuICBtb2R1bGUgRmllbGRzbGliID0gRmllbGRzbGliXG4gIG1vZHVsZSBQcHhfaGFzaF9saWIgPSBQcHhfaGFzaF9saWJcbiAgbW9kdWxlIFZhcmlhbnRzbGliID0gVmFyaWFudHNsaWJcbiAgbW9kdWxlIFBweF9jb21wYXJlX2xpYiA9IFBweF9jb21wYXJlX2xpYlxuICBtb2R1bGUgUHB4X2VudW1lcmF0ZV9saWIgPSBQcHhfZW51bWVyYXRlX2xpYlxuXG4gIGxldCBhbV90ZXN0aW5nID0gYW1fdGVzdGluZ1xuZW5kXG5cbigqKi8qKilcblxubW9kdWxlIEV4cG9ydCA9IHN0cnVjdFxuICAoKiBbZGVyaXZpbmcgaGFzaF0gaXMgbWlzc2luZyBmb3IgW2FycmF5XSBhbmQgW3JlZl0gc2luY2UgdGhlc2UgdHlwZXMgYXJlIG11dGFibGUuICopXG4gIHR5cGUgJ2EgYXJyYXkgPSAnYSBBcnJheS50IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlcXVhbCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlX2FycmF5IDogJ2EuICgnYSAtPiAnYSAtPiBpbnQpIC0+ICdhIGFycmF5IC0+ICdhIGFycmF5IC0+IGludCA9IEFycmF5LmNvbXBhcmVcbiAgbGV0IGVxdWFsX2FycmF5IDogJ2EuICgnYSAtPiAnYSAtPiBib29sKSAtPiAnYSBhcnJheSAtPiAnYSBhcnJheSAtPiBib29sID0gQXJyYXkuZXF1YWxcblxuICBsZXQgYXJyYXlfb2Zfc2V4cCA6ICdhLiAoU2V4cGxpYjAuU2V4cC50IC0+ICdhKSAtPiBTZXhwbGliMC5TZXhwLnQgLT4gJ2EgYXJyYXkgPVxuICAgIEFycmF5LnRfb2Zfc2V4cFxuICA7O1xuXG4gIGxldCBzZXhwX29mX2FycmF5IDogJ2EuICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICdhIGFycmF5IC0+IFNleHBsaWIwLlNleHAudCA9XG4gICAgQXJyYXkuc2V4cF9vZl90XG4gIDs7XG5cbiAgbGV0IChhcnJheV9zZXhwX2dyYW1tYXIgOlxuICAgICAgICAgJ2EgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgLT4gJ2EgYXJyYXkgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpXG4gICAgPVxuICAgIGZ1biBfJ2Ffc2V4cF9ncmFtbWFyIC0+IEFycmF5LnRfc2V4cF9ncmFtbWFyIF8nYV9zZXhwX2dyYW1tYXJcbiAgOztcblxuICBbQEBAZW5kXVxuXG4gIHR5cGUgYm9vbCA9IEJvb2wudCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZXF1YWwsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZV9ib29sID0gKEJvb2wuY29tcGFyZSA6IGJvb2wgLT4gYm9vbCAtPiBpbnQpXG4gIGxldCBlcXVhbF9ib29sID0gKEJvb2wuZXF1YWwgOiBib29sIC0+IGJvb2wgLT4gYm9vbClcblxuICBsZXQgKGhhc2hfZm9sZF9ib29sIDpcbiAgICAgICAgIFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiBib29sIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgICA9XG4gICAgQm9vbC5oYXNoX2ZvbGRfdFxuXG4gIGFuZCAoaGFzaF9ib29sIDogYm9vbCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gQm9vbC5oYXNoIGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IGJvb2xfb2Zfc2V4cCA9IChCb29sLnRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiBib29sKVxuICBsZXQgc2V4cF9vZl9ib29sID0gKEJvb2wuc2V4cF9vZl90IDogYm9vbCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAoYm9vbF9zZXhwX2dyYW1tYXIgOiBib29sIFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IEJvb2wudF9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIHR5cGUgY2hhciA9IENoYXIudCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZXF1YWwsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZV9jaGFyID0gKENoYXIuY29tcGFyZSA6IGNoYXIgLT4gY2hhciAtPiBpbnQpXG4gIGxldCBlcXVhbF9jaGFyID0gKENoYXIuZXF1YWwgOiBjaGFyIC0+IGNoYXIgLT4gYm9vbClcblxuICBsZXQgKGhhc2hfZm9sZF9jaGFyIDpcbiAgICAgICAgIFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiBjaGFyIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgICA9XG4gICAgQ2hhci5oYXNoX2ZvbGRfdFxuXG4gIGFuZCAoaGFzaF9jaGFyIDogY2hhciAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gQ2hhci5oYXNoIGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IGNoYXJfb2Zfc2V4cCA9IChDaGFyLnRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiBjaGFyKVxuICBsZXQgc2V4cF9vZl9jaGFyID0gKENoYXIuc2V4cF9vZl90IDogY2hhciAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAoY2hhcl9zZXhwX2dyYW1tYXIgOiBjaGFyIFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IENoYXIudF9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIHR5cGUgZXhuID0gRXhuLnQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgbGV0IHNleHBfb2ZfZXhuID0gKEV4bi5zZXhwX29mX3QgOiBleG4gLT4gU2V4cGxpYjAuU2V4cC50KVxuXG4gIFtAQEBlbmRdXG5cbiAgdHlwZSBmbG9hdCA9IEZsb2F0LnQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmVfZmxvYXQgPSAoRmxvYXQuY29tcGFyZSA6IGZsb2F0IC0+IGZsb2F0IC0+IGludClcbiAgbGV0IGVxdWFsX2Zsb2F0ID0gKEZsb2F0LmVxdWFsIDogZmxvYXQgLT4gZmxvYXQgLT4gYm9vbClcblxuICBsZXQgKGhhc2hfZm9sZF9mbG9hdCA6XG4gICAgICAgICBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gZmxvYXQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgID1cbiAgICBGbG9hdC5oYXNoX2ZvbGRfdFxuXG4gIGFuZCAoaGFzaF9mbG9hdCA6IGZsb2F0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBGbG9hdC5oYXNoIGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IGZsb2F0X29mX3NleHAgPSAoRmxvYXQudF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IGZsb2F0KVxuICBsZXQgc2V4cF9vZl9mbG9hdCA9IChGbG9hdC5zZXhwX29mX3QgOiBmbG9hdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAoZmxvYXRfc2V4cF9ncmFtbWFyIDogZmxvYXQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gRmxvYXQudF9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIHR5cGUgaW50ID0gSW50LnQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmVfaW50ID0gKEludC5jb21wYXJlIDogaW50IC0+IGludCAtPiBpbnQpXG4gIGxldCBlcXVhbF9pbnQgPSAoSW50LmVxdWFsIDogaW50IC0+IGludCAtPiBib29sKVxuXG4gIGxldCAoaGFzaF9mb2xkX2ludCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiBpbnQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgSW50Lmhhc2hfZm9sZF90XG5cbiAgYW5kIChoYXNoX2ludCA6IGludCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gSW50Lmhhc2ggaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgaW50X29mX3NleHAgPSAoSW50LnRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiBpbnQpXG4gIGxldCBzZXhwX29mX2ludCA9IChJbnQuc2V4cF9vZl90IDogaW50IC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0IChpbnRfc2V4cF9ncmFtbWFyIDogaW50IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IEludC50X3NleHBfZ3JhbW1hclxuXG4gIFtAQEBlbmRdXG5cbiAgdHlwZSBpbnQzMiA9IEludDMyLnQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmVfaW50MzIgPSAoSW50MzIuY29tcGFyZSA6IGludDMyIC0+IGludDMyIC0+IGludClcbiAgbGV0IGVxdWFsX2ludDMyID0gKEludDMyLmVxdWFsIDogaW50MzIgLT4gaW50MzIgLT4gYm9vbClcblxuICBsZXQgKGhhc2hfZm9sZF9pbnQzMiA6XG4gICAgICAgICBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gaW50MzIgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgID1cbiAgICBJbnQzMi5oYXNoX2ZvbGRfdFxuXG4gIGFuZCAoaGFzaF9pbnQzMiA6IGludDMyIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBJbnQzMi5oYXNoIGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IGludDMyX29mX3NleHAgPSAoSW50MzIudF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IGludDMyKVxuICBsZXQgc2V4cF9vZl9pbnQzMiA9IChJbnQzMi5zZXhwX29mX3QgOiBpbnQzMiAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAoaW50MzJfc2V4cF9ncmFtbWFyIDogaW50MzIgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gSW50MzIudF9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIHR5cGUgaW50NjQgPSBJbnQ2NC50IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlcXVhbCwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlX2ludDY0ID0gKEludDY0LmNvbXBhcmUgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQpXG4gIGxldCBlcXVhbF9pbnQ2NCA9IChJbnQ2NC5lcXVhbCA6IGludDY0IC0+IGludDY0IC0+IGJvb2wpXG5cbiAgbGV0IChoYXNoX2ZvbGRfaW50NjQgOlxuICAgICAgICAgUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IGludDY0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgICA9XG4gICAgSW50NjQuaGFzaF9mb2xkX3RcblxuICBhbmQgKGhhc2hfaW50NjQgOiBpbnQ2NCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gSW50NjQuaGFzaCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCBpbnQ2NF9vZl9zZXhwID0gKEludDY0LnRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiBpbnQ2NClcbiAgbGV0IHNleHBfb2ZfaW50NjQgPSAoSW50NjQuc2V4cF9vZl90IDogaW50NjQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKGludDY0X3NleHBfZ3JhbW1hciA6IGludDY0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IEludDY0LnRfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICB0eXBlICdhIGxpc3QgPSAnYSBMaXN0LnQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmVfbGlzdCA6ICdhLiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSBsaXN0IC0+ICdhIGxpc3QgLT4gaW50ID0gTGlzdC5jb21wYXJlXG4gIGxldCBlcXVhbF9saXN0IDogJ2EuICgnYSAtPiAnYSAtPiBib29sKSAtPiAnYSBsaXN0IC0+ICdhIGxpc3QgLT4gYm9vbCA9IExpc3QuZXF1YWxcblxuICBsZXQgaGFzaF9mb2xkX2xpc3QgOlxuICAgICdhLlxuICAgIChQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gJ2EgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZVxuICAgIC0+ICdhIGxpc3RcbiAgICAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGVcbiAgICA9XG4gICAgTGlzdC5oYXNoX2ZvbGRfdFxuICA7O1xuXG4gIGxldCBsaXN0X29mX3NleHAgOiAnYS4gKFNleHBsaWIwLlNleHAudCAtPiAnYSkgLT4gU2V4cGxpYjAuU2V4cC50IC0+ICdhIGxpc3QgPVxuICAgIExpc3QudF9vZl9zZXhwXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfbGlzdCA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSBsaXN0IC0+IFNleHBsaWIwLlNleHAudCA9XG4gICAgTGlzdC5zZXhwX29mX3RcbiAgOztcblxuICBsZXQgKGxpc3Rfc2V4cF9ncmFtbWFyIDogJ2EgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgLT4gJ2EgbGlzdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPVxuICAgIGZ1biBfJ2Ffc2V4cF9ncmFtbWFyIC0+IExpc3QudF9zZXhwX2dyYW1tYXIgXydhX3NleHBfZ3JhbW1hclxuICA7O1xuXG4gIFtAQEBlbmRdXG5cbiAgdHlwZSBuYXRpdmVpbnQgPSBOYXRpdmVpbnQudFxuICBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZXF1YWwsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZV9uYXRpdmVpbnQgPSAoTmF0aXZlaW50LmNvbXBhcmUgOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IGludClcbiAgbGV0IGVxdWFsX25hdGl2ZWludCA9IChOYXRpdmVpbnQuZXF1YWwgOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IGJvb2wpXG5cbiAgbGV0IChoYXNoX2ZvbGRfbmF0aXZlaW50IDpcbiAgICAgICAgIFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiBuYXRpdmVpbnQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgID1cbiAgICBOYXRpdmVpbnQuaGFzaF9mb2xkX3RcblxuICBhbmQgKGhhc2hfbmF0aXZlaW50IDogbmF0aXZlaW50IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBOYXRpdmVpbnQuaGFzaCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCBuYXRpdmVpbnRfb2Zfc2V4cCA9IChOYXRpdmVpbnQudF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IG5hdGl2ZWludClcbiAgbGV0IHNleHBfb2ZfbmF0aXZlaW50ID0gKE5hdGl2ZWludC5zZXhwX29mX3QgOiBuYXRpdmVpbnQgLT4gU2V4cGxpYjAuU2V4cC50KVxuXG4gIGxldCAobmF0aXZlaW50X3NleHBfZ3JhbW1hciA6IG5hdGl2ZWludCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPVxuICAgIE5hdGl2ZWludC50X3NleHBfZ3JhbW1hclxuICA7O1xuXG4gIFtAQEBlbmRdXG5cbiAgdHlwZSAnYSBvcHRpb24gPSAnYSBPcHRpb24udFxuICBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZXF1YWwsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZV9vcHRpb24gOiAnYS4gKCdhIC0+ICdhIC0+IGludCkgLT4gJ2Egb3B0aW9uIC0+ICdhIG9wdGlvbiAtPiBpbnQgPVxuICAgIE9wdGlvbi5jb21wYXJlXG4gIDs7XG5cbiAgbGV0IGVxdWFsX29wdGlvbiA6ICdhLiAoJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gJ2Egb3B0aW9uIC0+ICdhIG9wdGlvbiAtPiBib29sID1cbiAgICBPcHRpb24uZXF1YWxcbiAgOztcblxuICBsZXQgaGFzaF9mb2xkX29wdGlvbiA6XG4gICAgJ2EuXG4gICAgKFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiAnYSAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gICAgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlXG4gICAgLT4gJ2Egb3B0aW9uXG4gICAgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlXG4gICAgPVxuICAgIE9wdGlvbi5oYXNoX2ZvbGRfdFxuICA7O1xuXG4gIGxldCBvcHRpb25fb2Zfc2V4cCA6ICdhLiAoU2V4cGxpYjAuU2V4cC50IC0+ICdhKSAtPiBTZXhwbGliMC5TZXhwLnQgLT4gJ2Egb3B0aW9uID1cbiAgICBPcHRpb24udF9vZl9zZXhwXG4gIDs7XG5cbiAgbGV0IHNleHBfb2Zfb3B0aW9uIDogJ2EuICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICdhIG9wdGlvbiAtPiBTZXhwbGliMC5TZXhwLnQgPVxuICAgIE9wdGlvbi5zZXhwX29mX3RcbiAgOztcblxuICBsZXQgKG9wdGlvbl9zZXhwX2dyYW1tYXIgOlxuICAgICAgICAgJ2EgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgLT4gJ2Egb3B0aW9uIFNleHBsaWIwLlNleHBfZ3JhbW1hci50KVxuICAgID1cbiAgICBmdW4gXydhX3NleHBfZ3JhbW1hciAtPiBPcHRpb24udF9zZXhwX2dyYW1tYXIgXydhX3NleHBfZ3JhbW1hclxuICA7O1xuXG4gIFtAQEBlbmRdXG5cbiAgdHlwZSAnYSByZWYgPSAnYSBSZWYudCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZXF1YWwsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZV9yZWYgOiAnYS4gKCdhIC0+ICdhIC0+IGludCkgLT4gJ2EgcmVmIC0+ICdhIHJlZiAtPiBpbnQgPSBSZWYuY29tcGFyZVxuICBsZXQgZXF1YWxfcmVmIDogJ2EuICgnYSAtPiAnYSAtPiBib29sKSAtPiAnYSByZWYgLT4gJ2EgcmVmIC0+IGJvb2wgPSBSZWYuZXF1YWxcblxuICBsZXQgcmVmX29mX3NleHAgOiAnYS4gKFNleHBsaWIwLlNleHAudCAtPiAnYSkgLT4gU2V4cGxpYjAuU2V4cC50IC0+ICdhIHJlZiA9XG4gICAgUmVmLnRfb2Zfc2V4cFxuICA7O1xuXG4gIGxldCBzZXhwX29mX3JlZiA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSByZWYgLT4gU2V4cGxpYjAuU2V4cC50ID1cbiAgICBSZWYuc2V4cF9vZl90XG4gIDs7XG5cbiAgbGV0IChyZWZfc2V4cF9ncmFtbWFyIDogJ2EgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgLT4gJ2EgcmVmIFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9XG4gICAgZnVuIF8nYV9zZXhwX2dyYW1tYXIgLT4gUmVmLnRfc2V4cF9ncmFtbWFyIF8nYV9zZXhwX2dyYW1tYXJcbiAgOztcblxuICBbQEBAZW5kXVxuXG4gIHR5cGUgc3RyaW5nID0gU3RyaW5nLnQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmVfc3RyaW5nID0gKFN0cmluZy5jb21wYXJlIDogc3RyaW5nIC0+IHN0cmluZyAtPiBpbnQpXG4gIGxldCBlcXVhbF9zdHJpbmcgPSAoU3RyaW5nLmVxdWFsIDogc3RyaW5nIC0+IHN0cmluZyAtPiBib29sKVxuXG4gIGxldCAoaGFzaF9mb2xkX3N0cmluZyA6XG4gICAgICAgICBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gc3RyaW5nIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgICA9XG4gICAgU3RyaW5nLmhhc2hfZm9sZF90XG5cbiAgYW5kIChoYXNoX3N0cmluZyA6IHN0cmluZyAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gU3RyaW5nLmhhc2ggaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgc3RyaW5nX29mX3NleHAgPSAoU3RyaW5nLnRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiBzdHJpbmcpXG4gIGxldCBzZXhwX29mX3N0cmluZyA9IChTdHJpbmcuc2V4cF9vZl90IDogc3RyaW5nIC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0IChzdHJpbmdfc2V4cF9ncmFtbWFyIDogc3RyaW5nIFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IFN0cmluZy50X3NleHBfZ3JhbW1hclxuXG4gIFtAQEBlbmRdXG5cbiAgdHlwZSBieXRlcyA9IEJ5dGVzLnQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmVfYnl0ZXMgPSAoQnl0ZXMuY29tcGFyZSA6IGJ5dGVzIC0+IGJ5dGVzIC0+IGludClcbiAgbGV0IGVxdWFsX2J5dGVzID0gKEJ5dGVzLmVxdWFsIDogYnl0ZXMgLT4gYnl0ZXMgLT4gYm9vbClcbiAgbGV0IGJ5dGVzX29mX3NleHAgPSAoQnl0ZXMudF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IGJ5dGVzKVxuICBsZXQgc2V4cF9vZl9ieXRlcyA9IChCeXRlcy5zZXhwX29mX3QgOiBieXRlcyAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAoYnl0ZXNfc2V4cF9ncmFtbWFyIDogYnl0ZXMgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gQnl0ZXMudF9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIHR5cGUgdW5pdCA9IFVuaXQudCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZXF1YWwsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZV91bml0ID0gKFVuaXQuY29tcGFyZSA6IHVuaXQgLT4gdW5pdCAtPiBpbnQpXG4gIGxldCBlcXVhbF91bml0ID0gKFVuaXQuZXF1YWwgOiB1bml0IC0+IHVuaXQgLT4gYm9vbClcblxuICBsZXQgKGhhc2hfZm9sZF91bml0IDpcbiAgICAgICAgIFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB1bml0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgICA9XG4gICAgVW5pdC5oYXNoX2ZvbGRfdFxuXG4gIGFuZCAoaGFzaF91bml0IDogdW5pdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gVW5pdC5oYXNoIGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IHVuaXRfb2Zfc2V4cCA9IChVbml0LnRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB1bml0KVxuICBsZXQgc2V4cF9vZl91bml0ID0gKFVuaXQuc2V4cF9vZl90IDogdW5pdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAodW5pdF9zZXhwX2dyYW1tYXIgOiB1bml0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IFVuaXQudF9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gICgqKiBGb3JtYXQgc3R1ZmYgKilcblxuICB0eXBlIG5vbnJlYyAoJ2EsICdiLCAnYykgZm9ybWF0ID0gKCdhLCAnYiwgJ2MpIGZvcm1hdFxuICB0eXBlIG5vbnJlYyAoJ2EsICdiLCAnYywgJ2QpIGZvcm1hdDQgPSAoJ2EsICdiLCAnYywgJ2QpIGZvcm1hdDRcbiAgdHlwZSBub25yZWMgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgPSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NlxuXG4gICgqKiBMaXN0IG9wZXJhdG9ycyAqKVxuXG4gIGluY2x1ZGUgTGlzdC5JbmZpeFxuXG4gICgqKiBJbnQgb3BlcmF0b3JzIGFuZCBjb21wYXJpc29ucyAqKVxuXG4gIGluY2x1ZGUgSW50Lk9cbiAgaW5jbHVkZSBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbiAgKCoqIEZsb2F0IG9wZXJhdG9ycyAqKVxuXG4gIGluY2x1ZGUgRmxvYXQuT19kb3RcblxuICAoKiBUaGlzIGlzIGRlY2xhcmVkIGFzIGFuIGV4dGVybmFsIHRvIGJlIG9wdGltaXplZCBhd2F5IGluIG1vcmUgY29udGV4dHMuICopXG5cbiAgKCoqIFJldmVyc2UgYXBwbGljYXRpb24gb3BlcmF0b3IuIFt4IHw+IGcgfD4gZl0gaXMgZXF1aXZhbGVudCB0byBbZiAoZyAoeCkpXS4gKilcbiAgZXh0ZXJuYWwgKCB8PiApIDogJ2EgLT4gKCdhIC0+ICdiKSAtPiAnYiA9IFwiJXJldmFwcGx5XCJcblxuICAoKiogQXBwbGljYXRpb24gb3BlcmF0b3IuIFtnIEBAIGYgQEAgeF0gaXMgZXF1aXZhbGVudCB0byBbZyAoZiAoeCkpXS4gKilcbiAgZXh0ZXJuYWwgKCBAQCApIDogKCdhIC0+ICdiKSAtPiAnYSAtPiAnYiA9IFwiJWFwcGx5XCJcblxuICAoKiogQm9vbGVhbiBvcGVyYXRpb25zICopXG5cbiAgKCogVGhlc2UgbmVlZCB0byBiZSBkZWNsYXJlZCBhcyBhbiBleHRlcm5hbCB0byBnZXQgdGhlIGxhenkgYmVoYXZpb3IgKilcbiAgZXh0ZXJuYWwgKCAmJiApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1YW5kXCJcbiAgZXh0ZXJuYWwgKCB8fCApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1b3JcIlxuICBleHRlcm5hbCBub3QgOiBib29sIC0+IGJvb2wgPSBcIiVib29sbm90XCJcblxuICAoKiBUaGlzIG11c3QgYmUgZGVjbGFyZWQgYXMgYW4gZXh0ZXJuYWwgZm9yIHRoZSB3YXJuaW5ncyB0byB3b3JrIHByb3Blcmx5LiAqKVxuICBleHRlcm5hbCBpZ25vcmUgOiBfIC0+IHVuaXQgPSBcIiVpZ25vcmVcIlxuXG4gICgqKiBDb21tb24gc3RyaW5nIG9wZXJhdGlvbnMgKilcbiAgbGV0ICggXiApID0gU3RyaW5nLiggXiApXG5cbiAgKCoqIFJlZmVyZW5jZSBvcGVyYXRpb25zICopXG5cbiAgKCogRGVjbGFyZWQgYXMgYW4gZXh0ZXJuYWxzIHNvIHRoYXQgdGhlIGNvbXBpbGVyIHNraXBzIHRoZSBjYW1sX21vZGlmeSB3aGVuIHBvc3NpYmxlIGFuZFxuICAgICB0byBrZWVwIHJlZmVyZW5jZSB1bmJveGluZyB3b3JraW5nICopXG4gIGV4dGVybmFsICggISApIDogJ2EgcmVmIC0+ICdhID0gXCIlZmllbGQwXCJcbiAgZXh0ZXJuYWwgcmVmIDogJ2EgLT4gJ2EgcmVmID0gXCIlbWFrZW11dGFibGVcIlxuICBleHRlcm5hbCAoIDo9ICkgOiAnYSByZWYgLT4gJ2EgLT4gdW5pdCA9IFwiJXNldGZpZWxkMFwiXG5cbiAgKCoqIFBhaXIgb3BlcmF0aW9ucyAqKVxuXG4gIGxldCBmc3QgPSBmc3RcbiAgbGV0IHNuZCA9IHNuZFxuXG4gICgqKiBFeGNlcHRpb25zIHN0dWZmICopXG5cbiAgKCogRGVjbGFyZWQgYXMgYW4gZXh0ZXJuYWwgc28gdGhhdCB0aGUgY29tcGlsZXIgbWF5IHJld3JpdGUgJyVyYWlzZScgYXMgJyVyZXJhaXNlJy4gKilcbiAgZXh0ZXJuYWwgcmFpc2UgOiBleG4gLT4gXyA9IFwiJXJhaXNlXCJcblxuICBsZXQgZmFpbHdpdGggPSBmYWlsd2l0aFxuICBsZXQgaW52YWxpZF9hcmcgPSBpbnZhbGlkX2FyZ1xuICBsZXQgcmFpc2VfcyA9IEVycm9yLnJhaXNlX3NcblxuICAoKiogTWlzYyAqKVxuXG4gIGxldCBwaHlzX2VxdWFsID0gcGh5c19lcXVhbFxuXG4gIGV4dGVybmFsIGZvcmNlIDogJ2EgTGF6eS50IC0+ICdhID0gXCIlbGF6eV9mb3JjZVwiXG5lbmRcblxuaW5jbHVkZSBFeHBvcnRcblxuaW5jbHVkZSBDb250YWluZXJfaW50Zi5FeHBvcnQgKCoqIEBpbmxpbmUgKilcblxuZXhjZXB0aW9uIE5vdF9mb3VuZF9zID0gTm90X2ZvdW5kX3NcblxuKCogV2UgcGVyZm9ybSB0aGVzZSBzaWRlIGVmZmVjdHMgaGVyZSBiZWNhdXNlIHdlIHdhbnQgdGhlbSB0byBydW4gZm9yIGFueSBjb2RlIHRoYXQgdXNlc1xuICAgW0Jhc2VdLiAgSWYgdGhpcyB3ZXJlIGluIGFub3RoZXIgbW9kdWxlIGluIFtCYXNlXSB0aGF0IHdhcyBub3QgdXNlZCBpbiBzb21lIHByb2dyYW0sXG4gICB0aGVuIHRoZSBzaWRlIGVmZmVjdHMgbWlnaHQgbm90IGJlIHJ1biBpbiB0aGF0IHByb2dyYW0uICBUaGlzIHdpbGwgcnVuIGFzIGxvbmcgYXMgdGhlXG4gICBwcm9ncmFtIHJlZmVycyB0byBhdCBsZWFzdCBvbmUgdmFsdWUgZGlyZWN0bHkgaW4gW0Jhc2VdOyByZWZlcnJpbmcgdG8gdmFsdWVzIGluXG4gICBbQmFzZS5Cb29sXSwgZm9yIGV4YW1wbGUsIGlzIG5vdCBzdWZmaWNpZW50LiAqKVxubGV0ICgpID0gQmFja3RyYWNlLmluaXRpYWxpemVfbW9kdWxlICgpXG4iLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgSGFzaHRibF9pbnRmXG5cbm1vZHVsZSB0eXBlIEtleSA9IEtleS5TXG5cbmxldCB3aXRoX3JldHVybiA9IFdpdGhfcmV0dXJuLndpdGhfcmV0dXJuXG5sZXQgaGFzaF9wYXJhbSA9IEhhc2hhYmxlLmhhc2hfcGFyYW1cbmxldCBoYXNoID0gSGFzaGFibGUuaGFzaFxubGV0IHJhaXNlX3MgPSBFcnJvci5yYWlzZV9zXG5cbnR5cGUgKCdrLCAndikgdCA9XG4gIHsgbXV0YWJsZSB0YWJsZSA6ICgnaywgJ3YpIEF2bHRyZWUudCBhcnJheVxuICA7IG11dGFibGUgbGVuZ3RoIDogaW50XG4gICgqIFtyZWNlbnRseV9hZGRlZF0gaXMgdGhlIHJlZmVyZW5jZSBwYXNzZWQgdG8gW0F2bHRyZWUuYWRkXS4gV2UgcHV0IGl0IGluIHRoZSBoYXNoXG4gICAgIHRhYmxlIHRvIGF2b2lkIGFsbG9jYXRpbmcgaXQgYXQgZXZlcnkgW3NldF0uICopXG4gIDsgcmVjZW50bHlfYWRkZWQgOiBib29sIHJlZlxuICA7IGdyb3d0aF9hbGxvd2VkIDogYm9vbFxuICA7IGhhc2hhYmxlIDogJ2sgSGFzaGFibGUudFxuICA7IG11dGFibGUgbXV0YXRpb25fYWxsb3dlZCA6IGJvb2wgKCogU2V0IGR1cmluZyBhbGwgaXRlcmF0aW9uIG9wZXJhdGlvbnMgKilcbiAgfVxuXG50eXBlICdhIGtleSA9ICdhXG5cbmxldCBzZXhwX29mX2tleSB0ID0gdC5oYXNoYWJsZS5IYXNoYWJsZS5zZXhwX29mX3RcbmxldCBjb21wYXJlX2tleSB0ID0gdC5oYXNoYWJsZS5IYXNoYWJsZS5jb21wYXJlXG5cbmxldCBlbnN1cmVfbXV0YXRpb25fYWxsb3dlZCB0ID1cbiAgaWYgbm90IHQubXV0YXRpb25fYWxsb3dlZCB0aGVuIGZhaWx3aXRoIFwiSGFzaHRibDogbXV0YXRpb24gbm90IGFsbG93ZWQgZHVyaW5nIGl0ZXJhdGlvblwiXG47O1xuXG5sZXQgd2l0aG91dF9tdXRhdGluZyB0IGYgPVxuICBpZiB0Lm11dGF0aW9uX2FsbG93ZWRcbiAgdGhlbiAoXG4gICAgdC5tdXRhdGlvbl9hbGxvd2VkIDwtIGZhbHNlO1xuICAgIG1hdGNoIGYgKCkgd2l0aFxuICAgIHwgeCAtPlxuICAgICAgdC5tdXRhdGlvbl9hbGxvd2VkIDwtIHRydWU7XG4gICAgICB4XG4gICAgfCBleGNlcHRpb24gZXhuIC0+XG4gICAgICB0Lm11dGF0aW9uX2FsbG93ZWQgPC0gdHJ1ZTtcbiAgICAgIHJhaXNlIGV4bilcbiAgZWxzZSBmICgpXG47O1xuXG4oKiogSW50ZXJuYWxseSB1c2UgYSBtYXhpbXVtIHNpemUgdGhhdCBpcyBhIHBvd2VyIG9mIDIuIFJldmVyc2VzIHRoZSBhYm92ZSB0byBmaW5kIHRoZVxuICAgIGZsb29yIHBvd2VyIG9mIDIgYmVsb3cgdGhlIHN5c3RlbSBtYXggYXJyYXkgbGVuZ3RoICopXG5sZXQgbWF4X3RhYmxlX2xlbmd0aCA9IEludC5mbG9vcl9wb3cyIEFycmF5Lm1heF9sZW5ndGhcblxuKCogVGhlIGRlZmF1bHQgc2l6ZSBpcyBjaG9zZW4gdG8gYmUgMCAoYXMgb3Bwb3NlZCB0byAxMjggYXMgaXQgd2FzIGJlZm9yZSkgYmVjYXVzZTpcbiAgIC0gMTI4IGNhbiBjcmVhdGUgc3Vic3RhbnRpYWwgbWVtb3J5IG92ZXJoZWFkICh4MTApIHdoZW4gY3JlYXRpbmcgbWFueSB0YWJsZXMsIG1vc3RcbiAgICAgb2Ygd2hpY2ggYXJlIG5vdCBiaWcgKHNheSwgaWYgeW91IGhhdmUgYSBoYXNodGJsIG9mIGhhc2h0YmwpLiBBbmQgbWVtb3J5IG92ZXJoZWFkIGlzXG4gICAgIG5vdCB0aGF0IGVhc3kgdG8gcHJvZmlsZS5cbiAgIC0gaWYgYSBoYXNodGJsIGlzIGdvaW5nIHRvIGdyb3csIGl0J3Mgbm90IGNsZWFyIHdoeSAxMjggaXMgbWFya2VkbHkgYmV0dGVyIHRoYW4gb3RoZXJcbiAgICAgc2l6ZXMgKGlmIHlvdSBnb2luZyB0byBzdGljayAxMDAwIGVsZW1lbnRzLCB5b3UncmUgZ29pbmcgdG8gZ3JvdyB0aGUgaGFzaHRhYmxlIG9uY2VcbiAgICAgb3IgdHdpY2UgYW55d2F5KVxuICAgLSBpbiBvdGhlciBsYW5ndWFnZXMgKGxpa2UgcnVzdCwgcHl0aG9uLCBhbmQgYXBwYXJlbnRseSBnbyksIHRoZSBkZWZhdWx0IGlzIGFsc28gYVxuICAgICBzbWFsbCBzaXplLiAqKVxubGV0IGNyZWF0ZSA/KGdyb3d0aF9hbGxvd2VkID0gdHJ1ZSkgPyhzaXplID0gMCkgfmhhc2hhYmxlICgpID1cbiAgbGV0IHNpemUgPSBJbnQubWluIChJbnQubWF4IDEgc2l6ZSkgbWF4X3RhYmxlX2xlbmd0aCBpblxuICBsZXQgc2l6ZSA9IEludC5jZWlsX3BvdzIgc2l6ZSBpblxuICB7IHRhYmxlID0gQXJyYXkuY3JlYXRlIH5sZW46c2l6ZSBBdmx0cmVlLmVtcHR5XG4gIDsgbGVuZ3RoID0gMFxuICA7IGdyb3d0aF9hbGxvd2VkXG4gIDsgcmVjZW50bHlfYWRkZWQgPSByZWYgZmFsc2VcbiAgOyBoYXNoYWJsZVxuICA7IG11dGF0aW9uX2FsbG93ZWQgPSB0cnVlXG4gIH1cbjs7XG5cbigqKiBTdXBwbGVtZW50YWwgaGFzaC4gVGhpcyBtYXkgbm90IGJlIG5lY2Vzc2FyeSwgaXQgaXMgaW50ZW5kZWQgYXMgYSBkZWZlbnNlIGFnYWluc3QgcG9vclxuICAgIGhhc2ggZnVuY3Rpb25zLCBmb3Igd2hpY2ggdGhlIHBvd2VyIG9mIDIgc2l6ZWQgdGFibGUgd2lsbCBiZSBlc3BlY2lhbGx5IHNlbnNpdGl2ZS5cbiAgICBXaXRoIHNvbWUgdGVzdGluZyB3ZSBtYXkgY2hvb3NlIHRvIGFkZCBpdCwgYnV0IHRoaXMgdGFibGUgaXMgZGVzaWduZWQgdG8gYmUgcm9idXN0IHRvXG4gICAgY29sbGlzaW9ucywgYW5kIGluIG1vc3Qgb2YgbXkgdGVzdGluZyB0aGlzIGRlZ3JhZGVzIHBlcmZvcm1hbmNlLiAqKVxubGV0IF9zdXBwbGVtZW50YWxfaGFzaCBoID1cbiAgbGV0IGggPSBoIGx4b3IgKChoIGxzciAyMCkgbHhvciAoaCBsc3IgMTIpKSBpblxuICBoIGx4b3IgKGggbHNyIDcpIGx4b3IgKGggbHNyIDQpXG47O1xuXG5sZXQgc2xvdCB0IGtleSA9XG4gIGxldCBoYXNoID0gdC5oYXNoYWJsZS5IYXNoYWJsZS5oYXNoIGtleSBpblxuICAoKiB0aGlzIGlzIGFsd2F5cyBub24tbmVnYXRpdmUgYmVjYXVzZSB3ZSBkbyBbbGFuZF0gd2l0aCBub24tbmVnYXRpdmUgbnVtYmVyICopXG4gIGhhc2ggbGFuZCAoQXJyYXkubGVuZ3RoIHQudGFibGUgLSAxKVxuOztcblxubGV0IGFkZF93b3JrZXIgdCB+cmVwbGFjZSB+a2V5IH5kYXRhID1cbiAgbGV0IGkgPSBzbG90IHQga2V5IGluXG4gIGxldCByb290ID0gdC50YWJsZS4oaSkgaW5cbiAgbGV0IGFkZGVkID0gdC5yZWNlbnRseV9hZGRlZCBpblxuICBhZGRlZCA6PSBmYWxzZTtcbiAgbGV0IG5ld19yb290ID1cbiAgICAoKiBUaGUgYXZsIHRyZWUgbWlnaHQgcmVwbGFjZSB0aGUgdmFsdWUgW3JlcGxhY2U9dHJ1ZV0gb3IgZG8gbm90aGluZyBbcmVwbGFjZT1mYWxzZV1cbiAgICAgICB0byB0aGUgZW50cnksIGluIHRoYXQgY2FzZSB0aGUgdGFibGUgZGlkIG5vdCBnZXQgYmlnZ2VyLCBzbyB3ZSBzaG91bGQgbm90XG4gICAgICAgaW5jcmVtZW50IGxlbmd0aCwgd2UgcGFzcyBpbiB0aGUgYm9vbCByZWYgdC5hZGRlZCBzbyB0aGF0IGl0IGNhbiB0ZWxsIHVzIHdoZXRoZXJcbiAgICAgICBpdCBhZGRlZCBvciByZXBsYWNlZC4gV2UgZG8gaXQgdGhpcyB3YXkgdG8gYXZvaWQgZXh0cmEgYWxsb2NhdGlvbi4gU2luY2UgdGhlIGJvb2xcbiAgICAgICBpcyBhbiBpbW1lZGlhdGUgaXQgZG9lcyBub3QgZ28gdGhyb3VnaCB0aGUgd3JpdGUgYmFycmllci4gKilcbiAgICBBdmx0cmVlLmFkZCB+cmVwbGFjZSByb290IH5jb21wYXJlOihjb21wYXJlX2tleSB0KSB+YWRkZWQgfmtleSB+ZGF0YVxuICBpblxuICBpZiAhYWRkZWQgdGhlbiB0Lmxlbmd0aCA8LSB0Lmxlbmd0aCArIDE7XG4gICgqIFRoaXMgbGl0dGxlIG9wdGltaXphdGlvbiBzYXZlcyBhIGNhbWxfbW9kaWZ5IHdoZW4gdGhlIHRyZWVcbiAgICAgaGFzbid0IGJlZW4gcmViYWxhbmNlZC4gKilcbiAgaWYgbm90IChwaHlzX2VxdWFsIG5ld19yb290IHJvb3QpIHRoZW4gdC50YWJsZS4oaSkgPC0gbmV3X3Jvb3Rcbjs7XG5cbmxldCBtYXliZV9yZXNpemVfdGFibGUgdCA9XG4gIGxldCBsZW4gPSBBcnJheS5sZW5ndGggdC50YWJsZSBpblxuICBsZXQgc2hvdWxkX2dyb3cgPSB0Lmxlbmd0aCA+IGxlbiBpblxuICBpZiBzaG91bGRfZ3JvdyAmJiB0Lmdyb3d0aF9hbGxvd2VkXG4gIHRoZW4gKFxuICAgIGxldCBuZXdfYXJyYXlfbGVuZ3RoID0gSW50Lm1pbiAobGVuICogMikgbWF4X3RhYmxlX2xlbmd0aCBpblxuICAgIGlmIG5ld19hcnJheV9sZW5ndGggPiBsZW5cbiAgICB0aGVuIChcbiAgICAgIGxldCBuZXdfdGFibGUgPSBBcnJheS5jcmVhdGUgfmxlbjpuZXdfYXJyYXlfbGVuZ3RoIEF2bHRyZWUuZW1wdHkgaW5cbiAgICAgIGxldCBvbGRfdGFibGUgPSB0LnRhYmxlIGluXG4gICAgICB0LnRhYmxlIDwtIG5ld190YWJsZTtcbiAgICAgIHQubGVuZ3RoIDwtIDA7XG4gICAgICBsZXQgZiB+a2V5IH5kYXRhID0gYWRkX3dvcmtlciB+cmVwbGFjZTp0cnVlIHQgfmtleSB+ZGF0YSBpblxuICAgICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBvbGRfdGFibGUgLSAxIGRvXG4gICAgICAgIEF2bHRyZWUuaXRlciBvbGRfdGFibGUuKGkpIH5mXG4gICAgICBkb25lKSlcbjs7XG5cbmxldCBzZXQgdCB+a2V5IH5kYXRhID1cbiAgZW5zdXJlX211dGF0aW9uX2FsbG93ZWQgdDtcbiAgYWRkX3dvcmtlciB+cmVwbGFjZTp0cnVlIHQgfmtleSB+ZGF0YTtcbiAgbWF5YmVfcmVzaXplX3RhYmxlIHRcbjs7XG5cbmxldCBhZGQgdCB+a2V5IH5kYXRhID1cbiAgZW5zdXJlX211dGF0aW9uX2FsbG93ZWQgdDtcbiAgYWRkX3dvcmtlciB+cmVwbGFjZTpmYWxzZSB0IH5rZXkgfmRhdGE7XG4gIGlmICEodC5yZWNlbnRseV9hZGRlZClcbiAgdGhlbiAoXG4gICAgbWF5YmVfcmVzaXplX3RhYmxlIHQ7XG4gICAgYE9rKVxuICBlbHNlIGBEdXBsaWNhdGVcbjs7XG5cbmxldCBhZGRfZXhuIHQgfmtleSB+ZGF0YSA9XG4gIG1hdGNoIGFkZCB0IH5rZXkgfmRhdGEgd2l0aFxuICB8IGBPayAtPiAoKVxuICB8IGBEdXBsaWNhdGUgLT5cbiAgICBsZXQgc2V4cF9vZl9rZXkgPSBzZXhwX29mX2tleSB0IGluXG4gICAgbGV0IGVycm9yID0gRXJyb3IuY3JlYXRlIFwiSGFzaHRibC5hZGRfZXhuIGdvdCBrZXkgYWxyZWFkeSBwcmVzZW50XCIga2V5IHNleHBfb2Zfa2V5IGluXG4gICAgRXJyb3IucmFpc2UgZXJyb3Jcbjs7XG5cbmxldCBjbGVhciB0ID1cbiAgZW5zdXJlX211dGF0aW9uX2FsbG93ZWQgdDtcbiAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCB0LnRhYmxlIC0gMSBkb1xuICAgIHQudGFibGUuKGkpIDwtIEF2bHRyZWUuZW1wdHlcbiAgZG9uZTtcbiAgdC5sZW5ndGggPC0gMFxuOztcblxubGV0IGZpbmRfYW5kX2NhbGwgdCBrZXkgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmQgPVxuICAoKiB3aXRoIGEgZ29vZCBoYXNoIGZ1bmN0aW9uIHRoZXNlIGZpcnN0IHR3byBjYXNlcyB3aWxsIGJlIHRoZSBvdmVyd2hlbG1pbmcgbWFqb3JpdHksXG4gICAgIGFuZCBBdmx0cmVlLmZpbmQgaXMgcmVjdXJzaXZlLCBzbyBpdCBjYW4ndCBiZSBpbmxpbmVkLCBzbyBkb2luZyB0aGlzIGF2b2lkcyBhXG4gICAgIGZ1bmN0aW9uIGNhbGwgaW4gbW9zdCBjYXNlcy4gKilcbiAgbWF0Y2ggdC50YWJsZS4oc2xvdCB0IGtleSkgd2l0aFxuICB8IEF2bHRyZWUuRW1wdHkgLT4gaWZfbm90X2ZvdW5kIGtleVxuICB8IEF2bHRyZWUuTGVhZiB7IGtleSA9IGs7IHZhbHVlID0gdiB9IC0+XG4gICAgaWYgY29tcGFyZV9rZXkgdCBrIGtleSA9IDAgdGhlbiBpZl9mb3VuZCB2IGVsc2UgaWZfbm90X2ZvdW5kIGtleVxuICB8IHRyZWUgLT5cbiAgICBBdmx0cmVlLmZpbmRfYW5kX2NhbGwgdHJlZSB+Y29tcGFyZTooY29tcGFyZV9rZXkgdCkga2V5IH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kXG47O1xuXG5sZXQgZmluZF9hbmRfY2FsbDEgdCBrZXkgfmEgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmQgPVxuICBtYXRjaCB0LnRhYmxlLihzbG90IHQga2V5KSB3aXRoXG4gIHwgQXZsdHJlZS5FbXB0eSAtPiBpZl9ub3RfZm91bmQga2V5IGFcbiAgfCBBdmx0cmVlLkxlYWYgeyBrZXkgPSBrOyB2YWx1ZSA9IHYgfSAtPlxuICAgIGlmIGNvbXBhcmVfa2V5IHQgayBrZXkgPSAwIHRoZW4gaWZfZm91bmQgdiBhIGVsc2UgaWZfbm90X2ZvdW5kIGtleSBhXG4gIHwgdHJlZSAtPlxuICAgIEF2bHRyZWUuZmluZF9hbmRfY2FsbDEgdHJlZSB+Y29tcGFyZTooY29tcGFyZV9rZXkgdCkga2V5IH5hIH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kXG47O1xuXG5sZXQgZmluZF9hbmRfY2FsbDIgdCBrZXkgfmEgfmIgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmQgPVxuICBtYXRjaCB0LnRhYmxlLihzbG90IHQga2V5KSB3aXRoXG4gIHwgQXZsdHJlZS5FbXB0eSAtPiBpZl9ub3RfZm91bmQga2V5IGEgYlxuICB8IEF2bHRyZWUuTGVhZiB7IGtleSA9IGs7IHZhbHVlID0gdiB9IC0+XG4gICAgaWYgY29tcGFyZV9rZXkgdCBrIGtleSA9IDAgdGhlbiBpZl9mb3VuZCB2IGEgYiBlbHNlIGlmX25vdF9mb3VuZCBrZXkgYSBiXG4gIHwgdHJlZSAtPlxuICAgIEF2bHRyZWUuZmluZF9hbmRfY2FsbDIgdHJlZSB+Y29tcGFyZTooY29tcGFyZV9rZXkgdCkga2V5IH5hIH5iIH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kXG47O1xuXG5sZXQgZmluZGlfYW5kX2NhbGwgdCBrZXkgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmQgPVxuICAoKiB3aXRoIGEgZ29vZCBoYXNoIGZ1bmN0aW9uIHRoZXNlIGZpcnN0IHR3byBjYXNlcyB3aWxsIGJlIHRoZSBvdmVyd2hlbG1pbmcgbWFqb3JpdHksXG4gICAgIGFuZCBBdmx0cmVlLmZpbmQgaXMgcmVjdXJzaXZlLCBzbyBpdCBjYW4ndCBiZSBpbmxpbmVkLCBzbyBkb2luZyB0aGlzIGF2b2lkcyBhXG4gICAgIGZ1bmN0aW9uIGNhbGwgaW4gbW9zdCBjYXNlcy4gKilcbiAgbWF0Y2ggdC50YWJsZS4oc2xvdCB0IGtleSkgd2l0aFxuICB8IEF2bHRyZWUuRW1wdHkgLT4gaWZfbm90X2ZvdW5kIGtleVxuICB8IEF2bHRyZWUuTGVhZiB7IGtleSA9IGs7IHZhbHVlID0gdiB9IC0+XG4gICAgaWYgY29tcGFyZV9rZXkgdCBrIGtleSA9IDAgdGhlbiBpZl9mb3VuZCB+a2V5OmsgfmRhdGE6diBlbHNlIGlmX25vdF9mb3VuZCBrZXlcbiAgfCB0cmVlIC0+XG4gICAgQXZsdHJlZS5maW5kaV9hbmRfY2FsbCB0cmVlIH5jb21wYXJlOihjb21wYXJlX2tleSB0KSBrZXkgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmRcbjs7XG5cbmxldCBmaW5kaV9hbmRfY2FsbDEgdCBrZXkgfmEgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmQgPVxuICBtYXRjaCB0LnRhYmxlLihzbG90IHQga2V5KSB3aXRoXG4gIHwgQXZsdHJlZS5FbXB0eSAtPiBpZl9ub3RfZm91bmQga2V5IGFcbiAgfCBBdmx0cmVlLkxlYWYgeyBrZXkgPSBrOyB2YWx1ZSA9IHYgfSAtPlxuICAgIGlmIGNvbXBhcmVfa2V5IHQgayBrZXkgPSAwIHRoZW4gaWZfZm91bmQgfmtleTprIH5kYXRhOnYgYSBlbHNlIGlmX25vdF9mb3VuZCBrZXkgYVxuICB8IHRyZWUgLT5cbiAgICBBdmx0cmVlLmZpbmRpX2FuZF9jYWxsMSB0cmVlIH5jb21wYXJlOihjb21wYXJlX2tleSB0KSBrZXkgfmEgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmRcbjs7XG5cbmxldCBmaW5kaV9hbmRfY2FsbDIgdCBrZXkgfmEgfmIgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmQgPVxuICBtYXRjaCB0LnRhYmxlLihzbG90IHQga2V5KSB3aXRoXG4gIHwgQXZsdHJlZS5FbXB0eSAtPiBpZl9ub3RfZm91bmQga2V5IGEgYlxuICB8IEF2bHRyZWUuTGVhZiB7IGtleSA9IGs7IHZhbHVlID0gdiB9IC0+XG4gICAgaWYgY29tcGFyZV9rZXkgdCBrIGtleSA9IDAgdGhlbiBpZl9mb3VuZCB+a2V5OmsgfmRhdGE6diBhIGIgZWxzZSBpZl9ub3RfZm91bmQga2V5IGEgYlxuICB8IHRyZWUgLT5cbiAgICBBdmx0cmVlLmZpbmRpX2FuZF9jYWxsMlxuICAgICAgdHJlZVxuICAgICAgfmNvbXBhcmU6KGNvbXBhcmVfa2V5IHQpXG4gICAgICBrZXlcbiAgICAgIH5hXG4gICAgICB+YlxuICAgICAgfmlmX2ZvdW5kXG4gICAgICB+aWZfbm90X2ZvdW5kXG47O1xuXG5sZXQgZmluZCA9XG4gIGxldCBpZl9mb3VuZCB2ID0gU29tZSB2IGluXG4gIGxldCBpZl9ub3RfZm91bmQgXyA9IE5vbmUgaW5cbiAgZnVuIHQga2V5IC0+IGZpbmRfYW5kX2NhbGwgdCBrZXkgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmRcbjs7XG5cbmxldCBtZW0gdCBrZXkgPVxuICBtYXRjaCB0LnRhYmxlLihzbG90IHQga2V5KSB3aXRoXG4gIHwgQXZsdHJlZS5FbXB0eSAtPiBmYWxzZVxuICB8IEF2bHRyZWUuTGVhZiB7IGtleSA9IGs7IHZhbHVlID0gXyB9IC0+IGNvbXBhcmVfa2V5IHQgayBrZXkgPSAwXG4gIHwgdHJlZSAtPiBBdmx0cmVlLm1lbSB0cmVlIH5jb21wYXJlOihjb21wYXJlX2tleSB0KSBrZXlcbjs7XG5cbmxldCByZW1vdmUgdCBrZXkgPVxuICBlbnN1cmVfbXV0YXRpb25fYWxsb3dlZCB0O1xuICBsZXQgaSA9IHNsb3QgdCBrZXkgaW5cbiAgbGV0IHJvb3QgPSB0LnRhYmxlLihpKSBpblxuICBsZXQgYWRkZWRfb3JfcmVtb3ZlZCA9IHQucmVjZW50bHlfYWRkZWQgaW5cbiAgYWRkZWRfb3JfcmVtb3ZlZCA6PSBmYWxzZTtcbiAgbGV0IG5ld19yb290ID1cbiAgICBBdmx0cmVlLnJlbW92ZSByb290IH5yZW1vdmVkOmFkZGVkX29yX3JlbW92ZWQgfmNvbXBhcmU6KGNvbXBhcmVfa2V5IHQpIGtleVxuICBpblxuICBpZiBub3QgKHBoeXNfZXF1YWwgcm9vdCBuZXdfcm9vdCkgdGhlbiB0LnRhYmxlLihpKSA8LSBuZXdfcm9vdDtcbiAgaWYgIWFkZGVkX29yX3JlbW92ZWQgdGhlbiB0Lmxlbmd0aCA8LSB0Lmxlbmd0aCAtIDFcbjs7XG5cbmxldCBsZW5ndGggdCA9IHQubGVuZ3RoXG5sZXQgaXNfZW1wdHkgdCA9IGxlbmd0aCB0ID0gMFxuXG5sZXQgZm9sZCB0IH5pbml0IH5mID1cbiAgaWYgbGVuZ3RoIHQgPSAwXG4gIHRoZW4gaW5pdFxuICBlbHNlIChcbiAgICBsZXQgbiA9IEFycmF5Lmxlbmd0aCB0LnRhYmxlIGluXG4gICAgbGV0IGFjYyA9IHJlZiBpbml0IGluXG4gICAgbGV0IG0gPSB0Lm11dGF0aW9uX2FsbG93ZWQgaW5cbiAgICBtYXRjaFxuICAgICAgdC5tdXRhdGlvbl9hbGxvd2VkIDwtIGZhbHNlO1xuICAgICAgZm9yIGkgPSAwIHRvIG4gLSAxIGRvXG4gICAgICAgIG1hdGNoIEFycmF5LnVuc2FmZV9nZXQgdC50YWJsZSBpIHdpdGhcbiAgICAgICAgfCBBdmx0cmVlLkVtcHR5IC0+ICgpXG4gICAgICAgIHwgQXZsdHJlZS5MZWFmIHsga2V5OyB2YWx1ZSA9IGRhdGEgfSAtPiBhY2MgOj0gZiB+a2V5IH5kYXRhICFhY2NcbiAgICAgICAgfCBidWNrZXQgLT4gYWNjIDo9IEF2bHRyZWUuZm9sZCBidWNrZXQgfmluaXQ6IWFjYyB+ZlxuICAgICAgZG9uZVxuICAgIHdpdGhcbiAgICB8ICgpIC0+XG4gICAgICB0Lm11dGF0aW9uX2FsbG93ZWQgPC0gbTtcbiAgICAgICFhY2NcbiAgICB8IGV4Y2VwdGlvbiBleG4gLT5cbiAgICAgIHQubXV0YXRpb25fYWxsb3dlZCA8LSBtO1xuICAgICAgcmFpc2UgZXhuKVxuOztcblxubGV0IGl0ZXJpIHQgfmYgPVxuICBpZiB0Lmxlbmd0aCA9IDBcbiAgdGhlbiAoKVxuICBlbHNlIChcbiAgICBsZXQgbiA9IEFycmF5Lmxlbmd0aCB0LnRhYmxlIGluXG4gICAgbGV0IG0gPSB0Lm11dGF0aW9uX2FsbG93ZWQgaW5cbiAgICBtYXRjaFxuICAgICAgdC5tdXRhdGlvbl9hbGxvd2VkIDwtIGZhbHNlO1xuICAgICAgZm9yIGkgPSAwIHRvIG4gLSAxIGRvXG4gICAgICAgIG1hdGNoIEFycmF5LnVuc2FmZV9nZXQgdC50YWJsZSBpIHdpdGhcbiAgICAgICAgfCBBdmx0cmVlLkVtcHR5IC0+ICgpXG4gICAgICAgIHwgQXZsdHJlZS5MZWFmIHsga2V5OyB2YWx1ZSA9IGRhdGEgfSAtPiBmIH5rZXkgfmRhdGFcbiAgICAgICAgfCBidWNrZXQgLT4gQXZsdHJlZS5pdGVyIGJ1Y2tldCB+ZlxuICAgICAgZG9uZVxuICAgIHdpdGhcbiAgICB8ICgpIC0+IHQubXV0YXRpb25fYWxsb3dlZCA8LSBtXG4gICAgfCBleGNlcHRpb24gZXhuIC0+XG4gICAgICB0Lm11dGF0aW9uX2FsbG93ZWQgPC0gbTtcbiAgICAgIHJhaXNlIGV4bilcbjs7XG5cbmxldCBpdGVyIHQgfmYgPSBpdGVyaSB0IH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSlcbmxldCBpdGVyX2tleXMgdCB+ZiA9IGl0ZXJpIHQgfmY6KGZ1biB+a2V5IH5kYXRhOl8gLT4gZiBrZXkpXG5cbmxldCByZWMgY2hvb3NlX25vbmVtcHR5IHRhYmxlIGkgPVxuICBsZXQgYXZsdHJlZSA9IHRhYmxlLihpKSBpblxuICBpZiBBdmx0cmVlLmlzX2VtcHR5IGF2bHRyZWVcbiAgdGhlbiBjaG9vc2Vfbm9uZW1wdHkgdGFibGUgKGkgKyAxKVxuICBlbHNlIEF2bHRyZWUuY2hvb3NlX2V4biBhdmx0cmVlXG47O1xuXG5sZXQgY2hvb3NlX2V4biB0ID1cbiAgaWYgdC5sZW5ndGggPSAwIHRoZW4gcmFpc2VfcyAoU2V4cC5tZXNzYWdlIFwiW0hhc2h0YmwuY2hvb3NlX2V4bl0gb2YgZW1wdHkgaGFzaHRibFwiIFtdKTtcbiAgY2hvb3NlX25vbmVtcHR5IHQudGFibGUgMFxuOztcblxubGV0IGNob29zZSB0ID0gaWYgaXNfZW1wdHkgdCB0aGVuIE5vbmUgZWxzZSBTb21lIChjaG9vc2Vfbm9uZW1wdHkgdC50YWJsZSAwKVxuXG5sZXQgaW52YXJpYW50IGludmFyaWFudF9rZXkgaW52YXJpYW50X2RhdGEgdCA9XG4gIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggdC50YWJsZSAtIDEgZG9cbiAgICBBdmx0cmVlLmludmFyaWFudCB0LnRhYmxlLihpKSB+Y29tcGFyZTooY29tcGFyZV9rZXkgdClcbiAgZG9uZTtcbiAgbGV0IHJlYWxfbGVuID1cbiAgICBmb2xkIHQgfmluaXQ6MCB+ZjooZnVuIH5rZXkgfmRhdGEgaSAtPlxuICAgICAgaW52YXJpYW50X2tleSBrZXk7XG4gICAgICBpbnZhcmlhbnRfZGF0YSBkYXRhO1xuICAgICAgaSArIDEpXG4gIGluXG4gIGFzc2VydCAocmVhbF9sZW4gPSB0Lmxlbmd0aClcbjs7XG5cbmxldCBmaW5kX2V4biA9XG4gIGxldCBpZl9mb3VuZCB2IF8gPSB2IGluXG4gIGxldCBpZl9ub3RfZm91bmQgayB0ID1cbiAgICByYWlzZVxuICAgICAgKE5vdF9mb3VuZF9zIChMaXN0IFsgQXRvbSBcIkhhc2h0YmwuZmluZF9leG46IG5vdCBmb3VuZFwiOyB0Lmhhc2hhYmxlLnNleHBfb2ZfdCBrIF0pKVxuICBpblxuICBsZXQgZmluZF9leG4gdCBrZXkgPSBmaW5kX2FuZF9jYWxsMSB0IGtleSB+YTp0IH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kIGluXG4gICgqIG5hbWVkIHRvIHByZXNlcnZlIHN5bWJvbCBpbiBjb21waWxlZCBiaW5hcnkgKilcbiAgZmluZF9leG5cbjs7XG5cbmxldCBleGlzdHNpIHQgfmYgPVxuICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICBpdGVyaSB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPiBpZiBmIH5rZXkgfmRhdGEgdGhlbiByLnJldHVybiB0cnVlKTtcbiAgICBmYWxzZSlcbjs7XG5cbmxldCBleGlzdHMgdCB+ZiA9IGV4aXN0c2kgdCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXG5sZXQgZm9yX2FsbGkgdCB+ZiA9IG5vdCAoZXhpc3RzaSB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPiBub3QgKGYgfmtleSB+ZGF0YSkpKVxubGV0IGZvcl9hbGwgdCB+ZiA9IG5vdCAoZXhpc3RzaSB0IH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IG5vdCAoZiBkYXRhKSkpXG5cbmxldCBjb3VudGkgdCB+ZiA9XG4gIGZvbGQgdCB+aW5pdDowIH5mOihmdW4gfmtleSB+ZGF0YSBhY2MgLT4gaWYgZiB+a2V5IH5kYXRhIHRoZW4gYWNjICsgMSBlbHNlIGFjYylcbjs7XG5cbmxldCBjb3VudCB0IH5mID1cbiAgZm9sZCB0IH5pbml0OjAgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgYWNjIC0+IGlmIGYgZGF0YSB0aGVuIGFjYyArIDEgZWxzZSBhY2MpXG47O1xuXG5sZXQgbWFwaSB0IH5mID1cbiAgbGV0IG5ld190ID1cbiAgICBjcmVhdGUgfmdyb3d0aF9hbGxvd2VkOnQuZ3Jvd3RoX2FsbG93ZWQgfmhhc2hhYmxlOnQuaGFzaGFibGUgfnNpemU6dC5sZW5ndGggKClcbiAgaW5cbiAgaXRlcmkgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT4gc2V0IG5ld190IH5rZXkgfmRhdGE6KGYgfmtleSB+ZGF0YSkpO1xuICBuZXdfdFxuOztcblxubGV0IG1hcCB0IH5mID0gbWFwaSB0IH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSlcbmxldCBjb3B5IHQgPSBtYXAgdCB+ZjpGbi5pZFxuXG5sZXQgZmlsdGVyX21hcGkgdCB+ZiA9XG4gIGxldCBuZXdfdCA9XG4gICAgY3JlYXRlIH5ncm93dGhfYWxsb3dlZDp0Lmdyb3d0aF9hbGxvd2VkIH5oYXNoYWJsZTp0Lmhhc2hhYmxlIH5zaXplOnQubGVuZ3RoICgpXG4gIGluXG4gIGl0ZXJpIHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+XG4gICAgbWF0Y2ggZiB+a2V5IH5kYXRhIHdpdGhcbiAgICB8IFNvbWUgbmV3X2RhdGEgLT4gc2V0IG5ld190IH5rZXkgfmRhdGE6bmV3X2RhdGFcbiAgICB8IE5vbmUgLT4gKCkpO1xuICBuZXdfdFxuOztcblxubGV0IGZpbHRlcl9tYXAgdCB+ZiA9IGZpbHRlcl9tYXBpIHQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKVxuXG5sZXQgZmlsdGVyaSB0IH5mID1cbiAgZmlsdGVyX21hcGkgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT4gaWYgZiB+a2V5IH5kYXRhIHRoZW4gU29tZSBkYXRhIGVsc2UgTm9uZSlcbjs7XG5cbmxldCBmaWx0ZXIgdCB+ZiA9IGZpbHRlcmkgdCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXG5sZXQgZmlsdGVyX2tleXMgdCB+ZiA9IGZpbHRlcmkgdCB+ZjooZnVuIH5rZXkgfmRhdGE6XyAtPiBmIGtleSlcblxubGV0IHBhcnRpdGlvbl9tYXBpIHQgfmYgPVxuICBsZXQgdDAgPVxuICAgIGNyZWF0ZSB+Z3Jvd3RoX2FsbG93ZWQ6dC5ncm93dGhfYWxsb3dlZCB+aGFzaGFibGU6dC5oYXNoYWJsZSB+c2l6ZTp0Lmxlbmd0aCAoKVxuICBpblxuICBsZXQgdDEgPVxuICAgIGNyZWF0ZSB+Z3Jvd3RoX2FsbG93ZWQ6dC5ncm93dGhfYWxsb3dlZCB+aGFzaGFibGU6dC5oYXNoYWJsZSB+c2l6ZTp0Lmxlbmd0aCAoKVxuICBpblxuICBpdGVyaSB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPlxuICAgIG1hdGNoIChmIH5rZXkgfmRhdGEgOiBfIEVpdGhlci50KSB3aXRoXG4gICAgfCBGaXJzdCBuZXdfZGF0YSAtPiBzZXQgdDAgfmtleSB+ZGF0YTpuZXdfZGF0YVxuICAgIHwgU2Vjb25kIG5ld19kYXRhIC0+IHNldCB0MSB+a2V5IH5kYXRhOm5ld19kYXRhKTtcbiAgdDAsIHQxXG47O1xuXG5sZXQgcGFydGl0aW9uX21hcCB0IH5mID0gcGFydGl0aW9uX21hcGkgdCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXG5cbmxldCBwYXJ0aXRpb25pX3RmIHQgfmYgPVxuICBwYXJ0aXRpb25fbWFwaSB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPiBpZiBmIH5rZXkgfmRhdGEgdGhlbiBGaXJzdCBkYXRhIGVsc2UgU2Vjb25kIGRhdGEpXG47O1xuXG5sZXQgcGFydGl0aW9uX3RmIHQgfmYgPSBwYXJ0aXRpb25pX3RmIHQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKVxuXG5sZXQgZmluZF9vcl9hZGQgdCBpZCB+ZGVmYXVsdCA9XG4gIGZpbmRfYW5kX2NhbGwyXG4gICAgdFxuICAgIGlkXG4gICAgfmE6dFxuICAgIH5iOmRlZmF1bHRcbiAgICB+aWZfZm91bmQ6KGZ1biBkYXRhIF8gXyAtPiBkYXRhKVxuICAgIH5pZl9ub3RfZm91bmQ6KGZ1biBrZXkgdCBkZWZhdWx0IC0+XG4gICAgICBsZXQgZGVmYXVsdCA9IGRlZmF1bHQgKCkgaW5cbiAgICAgIHNldCB0IH5rZXkgfmRhdGE6ZGVmYXVsdDtcbiAgICAgIGRlZmF1bHQpXG47O1xuXG5sZXQgZmluZGlfb3JfYWRkIHQgaWQgfmRlZmF1bHQgPVxuICBmaW5kX2FuZF9jYWxsMlxuICAgIHRcbiAgICBpZFxuICAgIH5hOnRcbiAgICB+YjpkZWZhdWx0XG4gICAgfmlmX2ZvdW5kOihmdW4gZGF0YSBfIF8gLT4gZGF0YSlcbiAgICB+aWZfbm90X2ZvdW5kOihmdW4ga2V5IHQgZGVmYXVsdCAtPlxuICAgICAgbGV0IGRlZmF1bHQgPSBkZWZhdWx0IGtleSBpblxuICAgICAgc2V0IHQgfmtleSB+ZGF0YTpkZWZhdWx0O1xuICAgICAgZGVmYXVsdClcbjs7XG5cbigqIFNvbWUgaGFzaHRibCBpbXBsZW1lbnRhdGlvbnMgbWF5IGJlIGFibGUgdG8gcGVyZm9ybSB0aGlzIG1vcmUgZWZmaWNpZW50bHkgdGhhbiB0d29cbiAgIHNlcGFyYXRlIGxvb2t1cHMgKilcbmxldCBmaW5kX2FuZF9yZW1vdmUgdCBpZCA9XG4gIGxldCByZXN1bHQgPSBmaW5kIHQgaWQgaW5cbiAgaWYgT3B0aW9uLmlzX3NvbWUgcmVzdWx0IHRoZW4gcmVtb3ZlIHQgaWQ7XG4gIHJlc3VsdFxuOztcblxuXG5sZXQgY2hhbmdlIHQgaWQgfmYgPVxuICBtYXRjaCBmIChmaW5kIHQgaWQpIHdpdGhcbiAgfCBOb25lIC0+IHJlbW92ZSB0IGlkXG4gIHwgU29tZSBkYXRhIC0+IHNldCB0IH5rZXk6aWQgfmRhdGFcbjs7XG5cbmxldCB1cGRhdGVfYW5kX3JldHVybiB0IGlkIH5mID1cbiAgbGV0IGRhdGEgPSBmIChmaW5kIHQgaWQpIGluXG4gIHNldCB0IH5rZXk6aWQgfmRhdGE7XG4gIGRhdGFcbjs7XG5cbmxldCB1cGRhdGUgdCBpZCB+ZiA9IGlnbm9yZSAodXBkYXRlX2FuZF9yZXR1cm4gdCBpZCB+ZiA6IF8pXG5cbmxldCBpbmNyX2J5IH5yZW1vdmVfaWZfemVybyB0IGtleSBieSA9XG4gIGlmIHJlbW92ZV9pZl96ZXJvXG4gIHRoZW5cbiAgICBjaGFuZ2UgdCBrZXkgfmY6KGZ1biBvcHQgLT5cbiAgICAgIG1hdGNoIGJ5ICsgT3B0aW9uLnZhbHVlIG9wdCB+ZGVmYXVsdDowIHdpdGhcbiAgICAgIHwgMCAtPiBOb25lXG4gICAgICB8IG4gLT4gU29tZSBuKVxuICBlbHNlXG4gICAgdXBkYXRlIHQga2V5IH5mOihmdW5jdGlvblxuICAgICAgfCBOb25lIC0+IGJ5XG4gICAgICB8IFNvbWUgaSAtPiBieSArIGkpXG47O1xuXG5sZXQgaW5jciA/KGJ5ID0gMSkgPyhyZW1vdmVfaWZfemVybyA9IGZhbHNlKSB0IGtleSA9IGluY3JfYnkgfnJlbW92ZV9pZl96ZXJvIHQga2V5IGJ5XG5sZXQgZGVjciA/KGJ5ID0gMSkgPyhyZW1vdmVfaWZfemVybyA9IGZhbHNlKSB0IGtleSA9IGluY3JfYnkgfnJlbW92ZV9pZl96ZXJvIHQga2V5ICgtYnkpXG5cbmxldCBhZGRfbXVsdGkgdCB+a2V5IH5kYXRhID1cbiAgdXBkYXRlIHQga2V5IH5mOihmdW5jdGlvblxuICAgIHwgTm9uZSAtPiBbIGRhdGEgXVxuICAgIHwgU29tZSBsIC0+IGRhdGEgOjogbClcbjs7XG5cbmxldCByZW1vdmVfbXVsdGkgdCBrZXkgPVxuICBtYXRjaCBmaW5kIHQga2V5IHdpdGhcbiAgfCBOb25lIC0+ICgpXG4gIHwgU29tZSBbXSB8IFNvbWUgWyBfIF0gLT4gcmVtb3ZlIHQga2V5XG4gIHwgU29tZSAoXyA6OiB0bCkgLT4gc2V0IHQgfmtleSB+ZGF0YTp0bFxuOztcblxubGV0IGZpbmRfbXVsdGkgdCBrZXkgPVxuICBtYXRjaCBmaW5kIHQga2V5IHdpdGhcbiAgfCBOb25lIC0+IFtdXG4gIHwgU29tZSBsIC0+IGxcbjs7XG5cbmxldCBjcmVhdGVfbWFwcGVkID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgfmdldF9rZXkgfmdldF9kYXRhIHJvd3MgPVxuICBsZXQgc2l6ZSA9XG4gICAgbWF0Y2ggc2l6ZSB3aXRoXG4gICAgfCBTb21lIHMgLT4gc1xuICAgIHwgTm9uZSAtPiBMaXN0Lmxlbmd0aCByb3dzXG4gIGluXG4gIGxldCByZXMgPSBjcmVhdGUgP2dyb3d0aF9hbGxvd2VkIH5oYXNoYWJsZSB+c2l6ZSAoKSBpblxuICBsZXQgZHVwZXMgPSByZWYgW10gaW5cbiAgTGlzdC5pdGVyIHJvd3MgfmY6KGZ1biByIC0+XG4gICAgbGV0IGtleSA9IGdldF9rZXkgciBpblxuICAgIGxldCBkYXRhID0gZ2V0X2RhdGEgciBpblxuICAgIGlmIG1lbSByZXMga2V5IHRoZW4gZHVwZXMgOj0ga2V5IDo6ICFkdXBlcyBlbHNlIHNldCByZXMgfmtleSB+ZGF0YSk7XG4gIG1hdGNoICFkdXBlcyB3aXRoXG4gIHwgW10gLT4gYE9rIHJlc1xuICB8IGtleXMgLT4gYER1cGxpY2F0ZV9rZXlzIChMaXN0LmRlZHVwX2FuZF9zb3J0IH5jb21wYXJlOmhhc2hhYmxlLkhhc2hhYmxlLmNvbXBhcmUga2V5cylcbjs7XG5cbmxldCBjcmVhdGVfbWFwcGVkX211bHRpID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgfmdldF9rZXkgfmdldF9kYXRhIHJvd3MgPVxuICBsZXQgc2l6ZSA9XG4gICAgbWF0Y2ggc2l6ZSB3aXRoXG4gICAgfCBTb21lIHMgLT4gc1xuICAgIHwgTm9uZSAtPiBMaXN0Lmxlbmd0aCByb3dzXG4gIGluXG4gIGxldCByZXMgPSBjcmVhdGUgP2dyb3d0aF9hbGxvd2VkIH5zaXplIH5oYXNoYWJsZSAoKSBpblxuICBMaXN0Lml0ZXIgcm93cyB+ZjooZnVuIHIgLT5cbiAgICBsZXQga2V5ID0gZ2V0X2tleSByIGluXG4gICAgbGV0IGRhdGEgPSBnZXRfZGF0YSByIGluXG4gICAgYWRkX211bHRpIHJlcyB+a2V5IH5kYXRhKTtcbiAgcmVzXG47O1xuXG5sZXQgb2ZfYWxpc3QgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSBsc3QgPVxuICBtYXRjaCBjcmVhdGVfbWFwcGVkID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgfmdldF9rZXk6ZnN0IH5nZXRfZGF0YTpzbmQgbHN0IHdpdGhcbiAgfCBgT2sgdCAtPiBgT2sgdFxuICB8IGBEdXBsaWNhdGVfa2V5cyBrIC0+IGBEdXBsaWNhdGVfa2V5IChMaXN0LmhkX2V4biBrKVxuOztcblxubGV0IG9mX2FsaXN0X3JlcG9ydF9hbGxfZHVwcyA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIGxzdCA9XG4gIGNyZWF0ZV9tYXBwZWQgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSB+Z2V0X2tleTpmc3QgfmdldF9kYXRhOnNuZCBsc3Rcbjs7XG5cbmxldCBvZl9hbGlzdF9vcl9lcnJvciA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIGxzdCA9XG4gIG1hdGNoIG9mX2FsaXN0ID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgbHN0IHdpdGhcbiAgfCBgT2sgdiAtPiBSZXN1bHQuT2sgdlxuICB8IGBEdXBsaWNhdGVfa2V5IGtleSAtPlxuICAgIGxldCBzZXhwX29mX2tleSA9IGhhc2hhYmxlLkhhc2hhYmxlLnNleHBfb2ZfdCBpblxuICAgIE9yX2Vycm9yLmVycm9yIFwiSGFzaHRibC5vZl9hbGlzdF9leG46IGR1cGxpY2F0ZSBrZXlcIiBrZXkgc2V4cF9vZl9rZXlcbjs7XG5cbmxldCBvZl9hbGlzdF9leG4gP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSBsc3QgPVxuICBtYXRjaCBvZl9hbGlzdF9vcl9lcnJvciA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIGxzdCB3aXRoXG4gIHwgUmVzdWx0Lk9rIHYgLT4gdlxuICB8IFJlc3VsdC5FcnJvciBlIC0+IEVycm9yLnJhaXNlIGVcbjs7XG5cbmxldCBvZl9hbGlzdF9tdWx0aSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIGxzdCA9XG4gIGNyZWF0ZV9tYXBwZWRfbXVsdGkgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSB+Z2V0X2tleTpmc3QgfmdldF9kYXRhOnNuZCBsc3Rcbjs7XG5cbmxldCB0b19hbGlzdCB0ID0gZm9sZCB+ZjooZnVuIH5rZXkgfmRhdGEgbGlzdCAtPiAoa2V5LCBkYXRhKSA6OiBsaXN0KSB+aW5pdDpbXSB0XG5cbmxldCBzZXhwX29mX3Qgc2V4cF9vZl9rZXkgc2V4cF9vZl9kYXRhIHQgPVxuICB0XG4gIHw+IHRvX2FsaXN0XG4gIHw+IExpc3Quc29ydCB+Y29tcGFyZTooZnVuIChrMSwgXykgKGsyLCBfKSAtPiB0Lmhhc2hhYmxlLmNvbXBhcmUgazEgazIpXG4gIHw+IHNleHBfb2ZfbGlzdCAoc2V4cF9vZl9wYWlyIHNleHBfb2Zfa2V5IHNleHBfb2ZfZGF0YSlcbjs7XG5cbmxldCB0X29mX3NleHAgfmhhc2hhYmxlIGtfb2Zfc2V4cCBkX29mX3NleHAgc2V4cCA9XG4gIGxldCBhbGlzdCA9IGxpc3Rfb2Zfc2V4cCAocGFpcl9vZl9zZXhwIGtfb2Zfc2V4cCBkX29mX3NleHApIHNleHAgaW5cbiAgbWF0Y2ggb2ZfYWxpc3Qgfmhhc2hhYmxlIGFsaXN0IH5zaXplOihMaXN0Lmxlbmd0aCBhbGlzdCkgd2l0aFxuICB8IGBPayB2IC0+IHZcbiAgfCBgRHVwbGljYXRlX2tleSBrIC0+XG4gICAgKCogZmluZCB0aGUgc2V4cCBvZiBhIGR1cGxpY2F0ZSBrZXksIHNvIHRoZSBlcnJvciBpcyBuYXJyb3dlZCB0byBhIGtleSBhbmQgbm90XG4gICAgICAgdGhlIHdob2xlIG1hcCAqKVxuICAgIGxldCBhbGlzdF9zZXhwcyA9IGxpc3Rfb2Zfc2V4cCAocGFpcl9vZl9zZXhwIEZuLmlkIEZuLmlkKSBzZXhwIGluXG4gICAgbGV0IGZvdW5kX2ZpcnN0X2sgPSByZWYgZmFsc2UgaW5cbiAgICBMaXN0Lml0ZXIyX2V4biBhbGlzdCBhbGlzdF9zZXhwcyB+ZjooZnVuIChrMiwgXykgKGsyX3NleHAsIF8pIC0+XG4gICAgICBpZiBoYXNoYWJsZS5jb21wYXJlIGsgazIgPSAwXG4gICAgICB0aGVuXG4gICAgICAgIGlmICFmb3VuZF9maXJzdF9rXG4gICAgICAgIHRoZW4gb2Zfc2V4cF9lcnJvciBcIkhhc2h0YmwudF9vZl9zZXhwOiBkdXBsaWNhdGUga2V5XCIgazJfc2V4cFxuICAgICAgICBlbHNlIGZvdW5kX2ZpcnN0X2sgOj0gdHJ1ZSk7XG4gICAgYXNzZXJ0IGZhbHNlXG47O1xuXG5sZXQgdF9zZXhwX2dyYW1tYXJcbiAgICAgICh0eXBlIGsgdilcbiAgICAgIChrX2dyYW1tYXIgOiBrIFNleHBsaWIwLlNleHBfZ3JhbW1hci50KVxuICAgICAgKHZfZ3JhbW1hciA6IHYgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpXG4gIDogKGssIHYpIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgPVxuICBTZXhwbGliMC5TZXhwX2dyYW1tYXIuY29lcmNlIChMaXN0LkFzc29jLnRfc2V4cF9ncmFtbWFyIGtfZ3JhbW1hciB2X2dyYW1tYXIpXG47O1xuXG5sZXQga2V5cyB0ID0gZm9sZCB0IH5pbml0OltdIH5mOihmdW4gfmtleSB+ZGF0YTpfIGFjYyAtPiBrZXkgOjogYWNjKVxubGV0IGRhdGEgdCA9IGZvbGQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgbGlzdCAtPiBkYXRhIDo6IGxpc3QpIH5pbml0OltdIHRcblxubGV0IGFkZF90b19ncm91cHMgZ3JvdXBzIH5nZXRfa2V5IH5nZXRfZGF0YSB+Y29tYmluZSB+cm93cyA9XG4gIExpc3QuaXRlciByb3dzIH5mOihmdW4gcm93IC0+XG4gICAgbGV0IGtleSA9IGdldF9rZXkgcm93IGluXG4gICAgbGV0IGRhdGEgPSBnZXRfZGF0YSByb3cgaW5cbiAgICBsZXQgZGF0YSA9XG4gICAgICBtYXRjaCBmaW5kIGdyb3VwcyBrZXkgd2l0aFxuICAgICAgfCBOb25lIC0+IGRhdGFcbiAgICAgIHwgU29tZSBvbGQgLT4gY29tYmluZSBvbGQgZGF0YVxuICAgIGluXG4gICAgc2V0IGdyb3VwcyB+a2V5IH5kYXRhKVxuOztcblxubGV0IGdyb3VwID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgfmdldF9rZXkgfmdldF9kYXRhIH5jb21iaW5lIHJvd3MgPVxuICBsZXQgcmVzID0gY3JlYXRlID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgKCkgaW5cbiAgYWRkX3RvX2dyb3VwcyByZXMgfmdldF9rZXkgfmdldF9kYXRhIH5jb21iaW5lIH5yb3dzO1xuICByZXNcbjs7XG5cbmxldCBjcmVhdGVfd2l0aF9rZXkgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSB+Z2V0X2tleSByb3dzID1cbiAgY3JlYXRlX21hcHBlZCA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIH5nZXRfa2V5IH5nZXRfZGF0YTpGbi5pZCByb3dzXG47O1xuXG5sZXQgY3JlYXRlX3dpdGhfa2V5X29yX2Vycm9yID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgfmdldF9rZXkgcm93cyA9XG4gIG1hdGNoIGNyZWF0ZV93aXRoX2tleSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIH5nZXRfa2V5IHJvd3Mgd2l0aFxuICB8IGBPayB0IC0+IFJlc3VsdC5PayB0XG4gIHwgYER1cGxpY2F0ZV9rZXlzIGtleXMgLT5cbiAgICBsZXQgc2V4cF9vZl9rZXkgPSBoYXNoYWJsZS5IYXNoYWJsZS5zZXhwX29mX3QgaW5cbiAgICBPcl9lcnJvci5lcnJvcl9zXG4gICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICBcIkhhc2h0YmwuY3JlYXRlX3dpdGhfa2V5OiBkdXBsaWNhdGUga2V5c1wiXG4gICAgICAgICBbIFwia2V5c1wiLCBzZXhwX29mX2xpc3Qgc2V4cF9vZl9rZXkga2V5cyBdKVxuOztcblxubGV0IGNyZWF0ZV93aXRoX2tleV9leG4gP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSB+Z2V0X2tleSByb3dzID1cbiAgT3JfZXJyb3Iub2tfZXhuIChjcmVhdGVfd2l0aF9rZXlfb3JfZXJyb3IgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSB+Z2V0X2tleSByb3dzKVxuOztcblxubGV0IG1lcmdlID1cbiAgbGV0IG1heWJlX3NldCB0IH5rZXkgfmYgZCA9XG4gICAgbWF0Y2ggZiB+a2V5IGQgd2l0aFxuICAgIHwgTm9uZSAtPiAoKVxuICAgIHwgU29tZSB2IC0+IHNldCB0IH5rZXkgfmRhdGE6dlxuICBpblxuICBmdW4gdF9sZWZ0IHRfcmlnaHQgfmYgLT5cbiAgICBpZiBub3QgKEhhc2hhYmxlLmVxdWFsIHRfbGVmdC5oYXNoYWJsZSB0X3JpZ2h0Lmhhc2hhYmxlKVxuICAgIHRoZW4gaW52YWxpZF9hcmcgXCJIYXNodGJsLm1lcmdlOiBkaWZmZXJlbnQgJ2hhc2hhYmxlJyB2YWx1ZXNcIjtcbiAgICBsZXQgbmV3X3QgPVxuICAgICAgY3JlYXRlXG4gICAgICAgIH5ncm93dGhfYWxsb3dlZDp0X2xlZnQuZ3Jvd3RoX2FsbG93ZWRcbiAgICAgICAgfmhhc2hhYmxlOnRfbGVmdC5oYXNoYWJsZVxuICAgICAgICB+c2l6ZTp0X2xlZnQubGVuZ3RoXG4gICAgICAgICgpXG4gICAgaW5cbiAgICB3aXRob3V0X211dGF0aW5nIHRfbGVmdCAoZnVuICgpIC0+XG4gICAgICB3aXRob3V0X211dGF0aW5nIHRfcmlnaHQgKGZ1biAoKSAtPlxuICAgICAgICBpdGVyaSB0X2xlZnQgfmY6KGZ1biB+a2V5IH5kYXRhOmxlZnQgLT5cbiAgICAgICAgICBtYXRjaCBmaW5kIHRfcmlnaHQga2V5IHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gbWF5YmVfc2V0IG5ld190IH5rZXkgfmYgKGBMZWZ0IGxlZnQpXG4gICAgICAgICAgfCBTb21lIHJpZ2h0IC0+IG1heWJlX3NldCBuZXdfdCB+a2V5IH5mIChgQm90aCAobGVmdCwgcmlnaHQpKSk7XG4gICAgICAgIGl0ZXJpIHRfcmlnaHQgfmY6KGZ1biB+a2V5IH5kYXRhOnJpZ2h0IC0+XG4gICAgICAgICAgbWF0Y2ggZmluZCB0X2xlZnQga2V5IHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gbWF5YmVfc2V0IG5ld190IH5rZXkgfmYgKGBSaWdodCByaWdodClcbiAgICAgICAgICB8IFNvbWUgXyAtPiAoKVxuICAgICAgICAgICgqIGFscmVhZHkgZG9uZSBhYm92ZSAqKSkpKTtcbiAgICBuZXdfdFxuOztcblxubGV0IG1lcmdlX2ludG8gfnNyYyB+ZHN0IH5mID1cbiAgaXRlcmkgc3JjIH5mOihmdW4gfmtleSB+ZGF0YSAtPlxuICAgIGxldCBkc3RfZGF0YSA9IGZpbmQgZHN0IGtleSBpblxuICAgIGxldCBhY3Rpb24gPSB3aXRob3V0X211dGF0aW5nIGRzdCAoZnVuICgpIC0+IGYgfmtleSBkYXRhIGRzdF9kYXRhKSBpblxuICAgIG1hdGNoIChhY3Rpb24gOiBfIE1lcmdlX2ludG9fYWN0aW9uLnQpIHdpdGhcbiAgICB8IFJlbW92ZSAtPiByZW1vdmUgZHN0IGtleVxuICAgIHwgU2V0X3RvIGRhdGEgLT5cbiAgICAgIChtYXRjaCBkc3RfZGF0YSB3aXRoXG4gICAgICAgfCBOb25lIC0+IHNldCBkc3QgfmtleSB+ZGF0YVxuICAgICAgIHwgU29tZSBkc3RfZGF0YSAtPiBpZiBub3QgKHBoeXNfZXF1YWwgZHN0X2RhdGEgZGF0YSkgdGhlbiBzZXQgZHN0IH5rZXkgfmRhdGEpKVxuOztcblxubGV0IGZpbHRlcmlfaW5wbGFjZSB0IH5mID1cbiAgbGV0IHRvX3JlbW92ZSA9XG4gICAgZm9sZCB0IH5pbml0OltdIH5mOihmdW4gfmtleSB+ZGF0YSBhYyAtPiBpZiBmIH5rZXkgfmRhdGEgdGhlbiBhYyBlbHNlIGtleSA6OiBhYylcbiAgaW5cbiAgTGlzdC5pdGVyIHRvX3JlbW92ZSB+ZjooZnVuIGtleSAtPiByZW1vdmUgdCBrZXkpXG47O1xuXG5sZXQgZmlsdGVyX2lucGxhY2UgdCB+ZiA9IGZpbHRlcmlfaW5wbGFjZSB0IH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSlcbmxldCBmaWx0ZXJfa2V5c19pbnBsYWNlIHQgfmYgPSBmaWx0ZXJpX2lucGxhY2UgdCB+ZjooZnVuIH5rZXkgfmRhdGE6XyAtPiBmIGtleSlcblxubGV0IGZpbHRlcl9tYXBpX2lucGxhY2UgdCB+ZiA9XG4gIGxldCBtYXBfcmVzdWx0cyA9IGZvbGQgdCB+aW5pdDpbXSB+ZjooZnVuIH5rZXkgfmRhdGEgYWMgLT4gKGtleSwgZiB+a2V5IH5kYXRhKSA6OiBhYykgaW5cbiAgTGlzdC5pdGVyIG1hcF9yZXN1bHRzIH5mOihmdW4gKGtleSwgcmVzdWx0KSAtPlxuICAgIG1hdGNoIHJlc3VsdCB3aXRoXG4gICAgfCBOb25lIC0+IHJlbW92ZSB0IGtleVxuICAgIHwgU29tZSBkYXRhIC0+IHNldCB0IH5rZXkgfmRhdGEpXG47O1xuXG5sZXQgZmlsdGVyX21hcF9pbnBsYWNlIHQgfmYgPSBmaWx0ZXJfbWFwaV9pbnBsYWNlIHQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKVxuXG5sZXQgbWFwaV9pbnBsYWNlIHQgfmYgPVxuICBlbnN1cmVfbXV0YXRpb25fYWxsb3dlZCB0O1xuICB3aXRob3V0X211dGF0aW5nIHQgKGZ1biAoKSAtPiBBcnJheS5pdGVyIHQudGFibGUgfmY6KEF2bHRyZWUubWFwaV9pbnBsYWNlIH5mKSlcbjs7XG5cbmxldCBtYXBfaW5wbGFjZSB0IH5mID0gbWFwaV9pbnBsYWNlIHQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKVxuXG5sZXQgZXF1YWwgZXF1YWwgdCB0JyA9XG4gIGxlbmd0aCB0ID0gbGVuZ3RoIHQnXG4gICYmIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgIHdpdGhvdXRfbXV0YXRpbmcgdCcgKGZ1biAoKSAtPlxuICAgICAgaXRlcmkgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT5cbiAgICAgICAgbWF0Y2ggZmluZCB0JyBrZXkgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gci5yZXR1cm4gZmFsc2VcbiAgICAgICAgfCBTb21lIGRhdGEnIC0+IGlmIG5vdCAoZXF1YWwgZGF0YSBkYXRhJykgdGhlbiByLnJldHVybiBmYWxzZSkpO1xuICAgIHRydWUpXG47O1xuXG5sZXQgc2ltaWxhciA9IGVxdWFsXG5cbm1vZHVsZSBBY2Nlc3NvcnMgPSBzdHJ1Y3RcbiAgbGV0IGludmFyaWFudCA9IGludmFyaWFudFxuICBsZXQgY2hvb3NlID0gY2hvb3NlXG4gIGxldCBjaG9vc2VfZXhuID0gY2hvb3NlX2V4blxuICBsZXQgY2xlYXIgPSBjbGVhclxuICBsZXQgY29weSA9IGNvcHlcbiAgbGV0IHJlbW92ZSA9IHJlbW92ZVxuICBsZXQgc2V0ID0gc2V0XG4gIGxldCBhZGQgPSBhZGRcbiAgbGV0IGFkZF9leG4gPSBhZGRfZXhuXG4gIGxldCBjaGFuZ2UgPSBjaGFuZ2VcbiAgbGV0IHVwZGF0ZSA9IHVwZGF0ZVxuICBsZXQgdXBkYXRlX2FuZF9yZXR1cm4gPSB1cGRhdGVfYW5kX3JldHVyblxuICBsZXQgYWRkX211bHRpID0gYWRkX211bHRpXG4gIGxldCByZW1vdmVfbXVsdGkgPSByZW1vdmVfbXVsdGlcbiAgbGV0IGZpbmRfbXVsdGkgPSBmaW5kX211bHRpXG4gIGxldCBtZW0gPSBtZW1cbiAgbGV0IGl0ZXJfa2V5cyA9IGl0ZXJfa2V5c1xuICBsZXQgaXRlciA9IGl0ZXJcbiAgbGV0IGl0ZXJpID0gaXRlcmlcbiAgbGV0IGV4aXN0cyA9IGV4aXN0c1xuICBsZXQgZXhpc3RzaSA9IGV4aXN0c2lcbiAgbGV0IGZvcl9hbGwgPSBmb3JfYWxsXG4gIGxldCBmb3JfYWxsaSA9IGZvcl9hbGxpXG4gIGxldCBjb3VudCA9IGNvdW50XG4gIGxldCBjb3VudGkgPSBjb3VudGlcbiAgbGV0IGZvbGQgPSBmb2xkXG4gIGxldCBsZW5ndGggPSBsZW5ndGhcbiAgbGV0IGlzX2VtcHR5ID0gaXNfZW1wdHlcbiAgbGV0IG1hcCA9IG1hcFxuICBsZXQgbWFwaSA9IG1hcGlcbiAgbGV0IGZpbHRlcl9tYXAgPSBmaWx0ZXJfbWFwXG4gIGxldCBmaWx0ZXJfbWFwaSA9IGZpbHRlcl9tYXBpXG4gIGxldCBmaWx0ZXJfa2V5cyA9IGZpbHRlcl9rZXlzXG4gIGxldCBmaWx0ZXIgPSBmaWx0ZXJcbiAgbGV0IGZpbHRlcmkgPSBmaWx0ZXJpXG4gIGxldCBwYXJ0aXRpb25fbWFwID0gcGFydGl0aW9uX21hcFxuICBsZXQgcGFydGl0aW9uX21hcGkgPSBwYXJ0aXRpb25fbWFwaVxuICBsZXQgcGFydGl0aW9uX3RmID0gcGFydGl0aW9uX3RmXG4gIGxldCBwYXJ0aXRpb25pX3RmID0gcGFydGl0aW9uaV90ZlxuICBsZXQgZmluZF9vcl9hZGQgPSBmaW5kX29yX2FkZFxuICBsZXQgZmluZGlfb3JfYWRkID0gZmluZGlfb3JfYWRkXG4gIGxldCBmaW5kID0gZmluZFxuICBsZXQgZmluZF9leG4gPSBmaW5kX2V4blxuICBsZXQgZmluZF9hbmRfY2FsbCA9IGZpbmRfYW5kX2NhbGxcbiAgbGV0IGZpbmRfYW5kX2NhbGwxID0gZmluZF9hbmRfY2FsbDFcbiAgbGV0IGZpbmRfYW5kX2NhbGwyID0gZmluZF9hbmRfY2FsbDJcbiAgbGV0IGZpbmRpX2FuZF9jYWxsID0gZmluZGlfYW5kX2NhbGxcbiAgbGV0IGZpbmRpX2FuZF9jYWxsMSA9IGZpbmRpX2FuZF9jYWxsMVxuICBsZXQgZmluZGlfYW5kX2NhbGwyID0gZmluZGlfYW5kX2NhbGwyXG4gIGxldCBmaW5kX2FuZF9yZW1vdmUgPSBmaW5kX2FuZF9yZW1vdmVcbiAgbGV0IHRvX2FsaXN0ID0gdG9fYWxpc3RcbiAgbGV0IG1lcmdlID0gbWVyZ2VcbiAgbGV0IG1lcmdlX2ludG8gPSBtZXJnZV9pbnRvXG4gIGxldCBrZXlzID0ga2V5c1xuICBsZXQgZGF0YSA9IGRhdGFcbiAgbGV0IGZpbHRlcl9rZXlzX2lucGxhY2UgPSBmaWx0ZXJfa2V5c19pbnBsYWNlXG4gIGxldCBmaWx0ZXJfaW5wbGFjZSA9IGZpbHRlcl9pbnBsYWNlXG4gIGxldCBmaWx0ZXJpX2lucGxhY2UgPSBmaWx0ZXJpX2lucGxhY2VcbiAgbGV0IG1hcF9pbnBsYWNlID0gbWFwX2lucGxhY2VcbiAgbGV0IG1hcGlfaW5wbGFjZSA9IG1hcGlfaW5wbGFjZVxuICBsZXQgZmlsdGVyX21hcF9pbnBsYWNlID0gZmlsdGVyX21hcF9pbnBsYWNlXG4gIGxldCBmaWx0ZXJfbWFwaV9pbnBsYWNlID0gZmlsdGVyX21hcGlfaW5wbGFjZVxuICBsZXQgZXF1YWwgPSBlcXVhbFxuICBsZXQgc2ltaWxhciA9IHNpbWlsYXJcbiAgbGV0IGluY3IgPSBpbmNyXG4gIGxldCBkZWNyID0gZGVjclxuICBsZXQgc2V4cF9vZl9rZXkgPSBzZXhwX29mX2tleVxuZW5kXG5cbm1vZHVsZSBDcmVhdG9ycyAoS2V5IDogc2lnXG4gICAgdHlwZSAnYSB0XG5cbiAgICB2YWwgaGFzaGFibGUgOiAnYSB0IEhhc2hhYmxlLnRcbiAgZW5kKSA6IHNpZ1xuICB0eXBlICgnYSwgJ2IpIHRfID0gKCdhIEtleS50LCAnYikgdFxuXG4gIHZhbCB0X29mX3NleHAgOiAoU2V4cC50IC0+ICdhIEtleS50KSAtPiAoU2V4cC50IC0+ICdiKSAtPiBTZXhwLnQgLT4gKCdhLCAnYikgdF9cblxuICBpbmNsdWRlXG4gICAgQ3JlYXRvcnNfZ2VuZXJpY1xuICAgIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHRfXG4gICAgd2l0aCB0eXBlICdhIGtleSA6PSAnYSBLZXkudFxuICAgIHdpdGggdHlwZSAoJ2tleSwgJ2RhdGEsICdhKSBjcmVhdGVfb3B0aW9ucyA6PVxuICAgICAgKCdrZXksICdkYXRhLCAnYSkgY3JlYXRlX29wdGlvbnNfd2l0aG91dF9maXJzdF9jbGFzc19tb2R1bGVcbmVuZCA9IHN0cnVjdFxuICBsZXQgaGFzaGFibGUgPSBLZXkuaGFzaGFibGVcblxuICB0eXBlICgnYSwgJ2IpIHRfID0gKCdhIEtleS50LCAnYikgdFxuXG4gIGxldCBjcmVhdGUgP2dyb3d0aF9hbGxvd2VkID9zaXplICgpID0gY3JlYXRlID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgKClcbiAgbGV0IG9mX2FsaXN0ID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBsID0gb2ZfYWxpc3QgP2dyb3d0aF9hbGxvd2VkIH5oYXNoYWJsZSA/c2l6ZSBsXG5cbiAgbGV0IG9mX2FsaXN0X3JlcG9ydF9hbGxfZHVwcyA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbCA9XG4gICAgb2ZfYWxpc3RfcmVwb3J0X2FsbF9kdXBzID9ncm93dGhfYWxsb3dlZCB+aGFzaGFibGUgP3NpemUgbFxuICA7O1xuXG4gIGxldCBvZl9hbGlzdF9vcl9lcnJvciA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbCA9XG4gICAgb2ZfYWxpc3Rfb3JfZXJyb3IgP2dyb3d0aF9hbGxvd2VkIH5oYXNoYWJsZSA/c2l6ZSBsXG4gIDs7XG5cbiAgbGV0IG9mX2FsaXN0X2V4biA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbCA9XG4gICAgb2ZfYWxpc3RfZXhuID9ncm93dGhfYWxsb3dlZCB+aGFzaGFibGUgP3NpemUgbFxuICA7O1xuXG4gIGxldCB0X29mX3NleHAga19vZl9zZXhwIGRfb2Zfc2V4cCBzZXhwID0gdF9vZl9zZXhwIH5oYXNoYWJsZSBrX29mX3NleHAgZF9vZl9zZXhwIHNleHBcblxuICBsZXQgb2ZfYWxpc3RfbXVsdGkgP2dyb3d0aF9hbGxvd2VkID9zaXplIGwgPVxuICAgIG9mX2FsaXN0X211bHRpID9ncm93dGhfYWxsb3dlZCB+aGFzaGFibGUgP3NpemUgbFxuICA7O1xuXG4gIGxldCBjcmVhdGVfbWFwcGVkID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+Z2V0X2tleSB+Z2V0X2RhdGEgbCA9XG4gICAgY3JlYXRlX21hcHBlZCA/Z3Jvd3RoX2FsbG93ZWQgfmhhc2hhYmxlID9zaXplIH5nZXRfa2V5IH5nZXRfZGF0YSBsXG4gIDs7XG5cbiAgbGV0IGNyZWF0ZV93aXRoX2tleSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmdldF9rZXkgbCA9XG4gICAgY3JlYXRlX3dpdGhfa2V5ID9ncm93dGhfYWxsb3dlZCB+aGFzaGFibGUgP3NpemUgfmdldF9rZXkgbFxuICA7O1xuXG4gIGxldCBjcmVhdGVfd2l0aF9rZXlfb3JfZXJyb3IgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5nZXRfa2V5IGwgPVxuICAgIGNyZWF0ZV93aXRoX2tleV9vcl9lcnJvciA/Z3Jvd3RoX2FsbG93ZWQgfmhhc2hhYmxlID9zaXplIH5nZXRfa2V5IGxcbiAgOztcblxuICBsZXQgY3JlYXRlX3dpdGhfa2V5X2V4biA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmdldF9rZXkgbCA9XG4gICAgY3JlYXRlX3dpdGhfa2V5X2V4biA/Z3Jvd3RoX2FsbG93ZWQgfmhhc2hhYmxlID9zaXplIH5nZXRfa2V5IGxcbiAgOztcblxuICBsZXQgZ3JvdXAgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5nZXRfa2V5IH5nZXRfZGF0YSB+Y29tYmluZSBsID1cbiAgICBncm91cCA/Z3Jvd3RoX2FsbG93ZWQgfmhhc2hhYmxlID9zaXplIH5nZXRfa2V5IH5nZXRfZGF0YSB+Y29tYmluZSBsXG4gIDs7XG5lbmRcblxubW9kdWxlIFBvbHkgPSBzdHJ1Y3RcbiAgdHlwZSBub25yZWMgKCdhLCAnYikgdCA9ICgnYSwgJ2IpIHRcbiAgdHlwZSAnYSBrZXkgPSAnYVxuXG4gIGxldCBoYXNoYWJsZSA9IEhhc2hhYmxlLnBvbHlcblxuICBpbmNsdWRlIENyZWF0b3JzIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9ICdhXG5cbiAgICAgIGxldCBoYXNoYWJsZSA9IGhhc2hhYmxlXG4gICAgZW5kKVxuXG4gIGluY2x1ZGUgQWNjZXNzb3JzXG5cbiAgbGV0IHNleHBfb2ZfdCA9IHNleHBfb2ZfdFxuICBsZXQgdF9zZXhwX2dyYW1tYXIgPSB0X3NleHBfZ3JhbW1hclxuZW5kXG5cbm1vZHVsZSBQcml2YXRlID0gc3RydWN0XG4gIG1vZHVsZSB0eXBlIENyZWF0b3JzX2dlbmVyaWMgPSBDcmVhdG9yc19nZW5lcmljXG4gIG1vZHVsZSB0eXBlIEhhc2hhYmxlID0gSGFzaGFibGUuSGFzaGFibGVcblxuICB0eXBlIG5vbnJlYyAoJ2tleSwgJ2RhdGEsICd6KSBjcmVhdGVfb3B0aW9uc193aXRob3V0X2ZpcnN0X2NsYXNzX21vZHVsZSA9XG4gICAgKCdrZXksICdkYXRhLCAneikgY3JlYXRlX29wdGlvbnNfd2l0aG91dF9maXJzdF9jbGFzc19tb2R1bGVcblxuICBsZXQgaGFzaGFibGUgdCA9IHQuaGFzaGFibGVcbmVuZFxuXG5sZXQgY3JlYXRlID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBtID1cbiAgY3JlYXRlIH5oYXNoYWJsZTooSGFzaGFibGUub2Zfa2V5IG0pID9ncm93dGhfYWxsb3dlZCA/c2l6ZSAoKVxuOztcblxubGV0IG9mX2FsaXN0ID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBtIGwgPVxuICBvZl9hbGlzdCB+aGFzaGFibGU6KEhhc2hhYmxlLm9mX2tleSBtKSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbFxuOztcblxubGV0IG9mX2FsaXN0X3JlcG9ydF9hbGxfZHVwcyA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbSBsID1cbiAgb2ZfYWxpc3RfcmVwb3J0X2FsbF9kdXBzIH5oYXNoYWJsZTooSGFzaGFibGUub2Zfa2V5IG0pID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBsXG47O1xuXG5sZXQgb2ZfYWxpc3Rfb3JfZXJyb3IgP2dyb3d0aF9hbGxvd2VkID9zaXplIG0gbCA9XG4gIG9mX2FsaXN0X29yX2Vycm9yIH5oYXNoYWJsZTooSGFzaGFibGUub2Zfa2V5IG0pID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBsXG47O1xuXG5sZXQgb2ZfYWxpc3RfZXhuID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBtIGwgPVxuICBvZl9hbGlzdF9leG4gfmhhc2hhYmxlOihIYXNoYWJsZS5vZl9rZXkgbSkgP2dyb3d0aF9hbGxvd2VkID9zaXplIGxcbjs7XG5cbmxldCBvZl9hbGlzdF9tdWx0aSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbSBsID1cbiAgb2ZfYWxpc3RfbXVsdGkgfmhhc2hhYmxlOihIYXNoYWJsZS5vZl9rZXkgbSkgP2dyb3d0aF9hbGxvd2VkID9zaXplIGxcbjs7XG5cbmxldCBjcmVhdGVfbWFwcGVkID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBtIH5nZXRfa2V5IH5nZXRfZGF0YSBsID1cbiAgY3JlYXRlX21hcHBlZCB+aGFzaGFibGU6KEhhc2hhYmxlLm9mX2tleSBtKSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmdldF9rZXkgfmdldF9kYXRhIGxcbjs7XG5cbmxldCBjcmVhdGVfd2l0aF9rZXkgP2dyb3d0aF9hbGxvd2VkID9zaXplIG0gfmdldF9rZXkgbCA9XG4gIGNyZWF0ZV93aXRoX2tleSB+aGFzaGFibGU6KEhhc2hhYmxlLm9mX2tleSBtKSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmdldF9rZXkgbFxuOztcblxubGV0IGNyZWF0ZV93aXRoX2tleV9vcl9lcnJvciA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbSB+Z2V0X2tleSBsID1cbiAgY3JlYXRlX3dpdGhfa2V5X29yX2Vycm9yIH5oYXNoYWJsZTooSGFzaGFibGUub2Zfa2V5IG0pID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+Z2V0X2tleSBsXG47O1xuXG5sZXQgY3JlYXRlX3dpdGhfa2V5X2V4biA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbSB+Z2V0X2tleSBsID1cbiAgY3JlYXRlX3dpdGhfa2V5X2V4biB+aGFzaGFibGU6KEhhc2hhYmxlLm9mX2tleSBtKSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmdldF9rZXkgbFxuOztcblxubGV0IGdyb3VwID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBtIH5nZXRfa2V5IH5nZXRfZGF0YSB+Y29tYmluZSBsID1cbiAgZ3JvdXAgfmhhc2hhYmxlOihIYXNoYWJsZS5vZl9rZXkgbSkgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5nZXRfa2V5IH5nZXRfZGF0YSB+Y29tYmluZSBsXG47O1xuXG5sZXQgaGFzaGFibGVfcyB0ID0gSGFzaGFibGUudG9fa2V5IHQuaGFzaGFibGVcblxubW9kdWxlIE0gKEsgOiBULlQpID0gc3RydWN0XG4gIHR5cGUgbm9ucmVjICd2IHQgPSAoSy50LCAndikgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIFNleHBfb2ZfbSA9IHNpZ1xuICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgdmFsIHNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG5tb2R1bGUgdHlwZSBNX29mX3NleHAgPSBzaWdcbiAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBvZl9zZXhwXVxuXG4gIHZhbCB0X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdFxuXG4gIFtAQEBlbmRdXG5cbiAgaW5jbHVkZSBLZXkuUyB3aXRoIHR5cGUgdCA6PSB0XG5lbmRcblxubW9kdWxlIHR5cGUgTV9zZXhwX2dyYW1tYXIgPSBzaWdcbiAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX2dyYW1tYXJdXG5cbiAgdmFsIHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuXG4gIFtAQEBlbmRdXG5lbmRcblxubW9kdWxlIHR5cGUgRXF1YWxfbSA9IHNpZyBlbmRcblxubGV0IHNleHBfb2ZfbV9fdCAodHlwZSBrKSAobW9kdWxlIEsgOiBTZXhwX29mX20gd2l0aCB0eXBlIHQgPSBrKSBzZXhwX29mX3YgdCA9XG4gIHNleHBfb2ZfdCBLLnNleHBfb2ZfdCBzZXhwX29mX3YgdFxuOztcblxubGV0IG1fX3Rfb2Zfc2V4cCAodHlwZSBrKSAobW9kdWxlIEsgOiBNX29mX3NleHAgd2l0aCB0eXBlIHQgPSBrKSB2X29mX3NleHAgc2V4cCA9XG4gIHRfb2Zfc2V4cCB+aGFzaGFibGU6KEhhc2hhYmxlLm9mX2tleSAobW9kdWxlIEspKSBLLnRfb2Zfc2V4cCB2X29mX3NleHAgc2V4cFxuOztcblxubGV0IG1fX3Rfc2V4cF9ncmFtbWFyICh0eXBlIGspIChtb2R1bGUgSyA6IE1fc2V4cF9ncmFtbWFyIHdpdGggdHlwZSB0ID0gaykgdl9ncmFtbWFyID1cbiAgdF9zZXhwX2dyYW1tYXIgSy50X3NleHBfZ3JhbW1hciB2X2dyYW1tYXJcbjs7XG5cbmxldCBlcXVhbF9tX190IChtb2R1bGUgXyA6IEVxdWFsX20pIGVxdWFsX3YgdDEgdDIgPSBlcXVhbCBlcXVhbF92IHQxIHQyXG4iLCJvcGVuISBJbXBvcnQwXG5pbmNsdWRlIENhbWwuUHJpbnRmXG5cbigqKiBmYWlsd2l0aCwgaW52YWxpZF9hcmcsIGFuZCBleGl0IGFjY2VwdGluZyBwcmludGYncyBmb3JtYXQuICopXG5cbmxldCBmYWlsd2l0aGYgZm10ID0ga3NwcmludGYgKGZ1biBzICgpIC0+IGZhaWx3aXRoIHMpIGZtdFxubGV0IGludmFsaWRfYXJnZiBmbXQgPSBrc3ByaW50ZiAoZnVuIHMgKCkgLT4gaW52YWxpZF9hcmcgcykgZm10XG4iLCIoKiBbU3lzMF0gZGVmaW5lcyBmdW5jdGlvbnMgdGhhdCBhcmUgcHJpbWl0aXZlcyBvciBjYW4gYmUgc2ltcGx5IGRlZmluZWQgaW5cbiAgIHRlcm1zIG9mIFtDYW1sLlN5c10uICBbU3lzMF0gaXMgaW50ZW5kZWQgdG8gY29tcGxldGVseSBleHByZXNzIHRoZSBwYXJ0IG9mXG4gICBbQ2FtbC5TeXNdIHRoYXQgW0Jhc2VdIHVzZXMgLS0gbm8gb3RoZXIgZmlsZSBpbiBCYXNlIG90aGVyIHRoYW4gc3lzLm1sXG4gICBzaG91bGQgdXNlIFtDYW1sLlN5c10uIFtTeXMwXSBoYXMgZmV3IGRlcGVuZGVuY2llcywgYW5kIHNvIGlzIGF2YWlsYWJsZVxuICAgZWFybHkgaW4gQmFzZSdzIGJ1aWxkIG9yZGVyLiAgQWxsIEJhc2UgZmlsZXMgdGhhdCBuZWVkIHRvIHVzZSB0aGVzZVxuICAgZnVuY3Rpb25zIGFuZCBjb21lIGJlZm9yZSBbQmFzZS5TeXNdIGluIGJ1aWxkIG9yZGVyIHNob3VsZCBkb1xuICAgW21vZHVsZSBTeXMgPSBTeXMwXS4gIERlZmluaW5nIFttb2R1bGUgU3lzID0gU3lzMF0gaXMgYWxzbyBuZWNlc3NhcnkgYmVjYXVzZVxuICAgaXQgcHJldmVudHMgb2NhbWxkZXAgZnJvbSBtaXN0YWtlbmx5IGNhdXNpbmcgYSBmaWxlIHRvIGRlcGVuZCBvbiBbQmFzZS5TeXNdLiAqKVxuXG5vcGVuISBJbXBvcnQwXG5cbnR5cGUgYmFja2VuZF90eXBlID0gQ2FtbC5TeXMuYmFja2VuZF90eXBlID1cbiAgfCBOYXRpdmVcbiAgfCBCeXRlY29kZVxuICB8IE90aGVyIG9mIHN0cmluZ1xuXG5sZXQgYmFja2VuZF90eXBlID0gQ2FtbC5TeXMuYmFja2VuZF90eXBlXG5sZXQgaW50ZXJhY3RpdmUgPSBDYW1sLlN5cy5pbnRlcmFjdGl2ZVxubGV0IG9zX3R5cGUgPSBDYW1sLlN5cy5vc190eXBlXG5sZXQgdW5peCA9IENhbWwuU3lzLnVuaXhcbmxldCB3aW4zMiA9IENhbWwuU3lzLndpbjMyXG5sZXQgY3lnd2luID0gQ2FtbC5TeXMuY3lnd2luXG5sZXQgd29yZF9zaXplX2luX2JpdHMgPSBDYW1sLlN5cy53b3JkX3NpemVcbmxldCBpbnRfc2l6ZV9pbl9iaXRzID0gQ2FtbC5TeXMuaW50X3NpemVcbmxldCBiaWdfZW5kaWFuID0gQ2FtbC5TeXMuYmlnX2VuZGlhblxubGV0IG1heF9zdHJpbmdfbGVuZ3RoID0gQ2FtbC5TeXMubWF4X3N0cmluZ19sZW5ndGhcbmxldCBtYXhfYXJyYXlfbGVuZ3RoID0gQ2FtbC5TeXMubWF4X2FycmF5X2xlbmd0aFxubGV0IHJ1bnRpbWVfdmFyaWFudCA9IENhbWwuU3lzLnJ1bnRpbWVfdmFyaWFudFxubGV0IHJ1bnRpbWVfcGFyYW1ldGVycyA9IENhbWwuU3lzLnJ1bnRpbWVfcGFyYW1ldGVyc1xubGV0IGFyZ3YgPSBDYW1sLlN5cy5hcmd2XG5sZXQgZ2V0X2FyZ3YgKCkgPSBDYW1sLlN5cy5hcmd2XG5sZXQgb2NhbWxfdmVyc2lvbiA9IENhbWwuU3lzLm9jYW1sX3ZlcnNpb25cbmxldCBlbmFibGVfcnVudGltZV93YXJuaW5ncyA9IENhbWwuU3lzLmVuYWJsZV9ydW50aW1lX3dhcm5pbmdzXG5sZXQgcnVudGltZV93YXJuaW5nc19lbmFibGVkID0gQ2FtbC5TeXMucnVudGltZV93YXJuaW5nc19lbmFibGVkXG5cbmxldCBnZXRlbnZfZXhuIHZhciA9XG4gIHRyeSBDYW1sLlN5cy5nZXRlbnYgdmFyIHdpdGhcbiAgfCBDYW1sLk5vdF9mb3VuZCAtPlxuICAgIFByaW50Zi5mYWlsd2l0aGYgXCJTeXMuZ2V0ZW52X2V4bjogZW52aXJvbm1lbnQgdmFyaWFibGUgJXMgaXMgbm90IHNldFwiIHZhciAoKVxuOztcblxubGV0IGdldGVudiB2YXIgPVxuICBtYXRjaCBDYW1sLlN5cy5nZXRlbnYgdmFyIHdpdGhcbiAgfCB4IC0+IFNvbWUgeFxuICB8IGV4Y2VwdGlvbiBDYW1sLk5vdF9mb3VuZCAtPiBOb25lXG47O1xuXG5leHRlcm5hbCBvcGFxdWVfaWRlbnRpdHkgOiAnYSAtPiAnYSA9IFwiJW9wYXF1ZVwiXG5cbmV4Y2VwdGlvbiBCcmVhayA9IENhbWwuU3lzLkJyZWFrXG4iLCIoKiBbQXJyYXkwXSBkZWZpbmVzIGFycmF5IGZ1bmN0aW9ucyB0aGF0IGFyZSBwcmltaXRpdmVzIG9yIGNhbiBiZSBzaW1wbHkgZGVmaW5lZCBpbiB0ZXJtc1xuICAgb2YgW0NhbWwuQXJyYXldLiAgW0FycmF5MF0gaXMgaW50ZW5kZWQgdG8gY29tcGxldGVseSBleHByZXNzIHRoZSBwYXJ0IG9mIFtDYW1sLkFycmF5XVxuICAgdGhhdCBbQmFzZV0gdXNlcyAtLSBubyBvdGhlciBmaWxlIGluIEJhc2Ugb3RoZXIgdGhhbiBhcnJheTAubWwgc2hvdWxkIHVzZSBbQ2FtbC5BcnJheV0uXG4gICBbQXJyYXkwXSBoYXMgZmV3IGRlcGVuZGVuY2llcywgYW5kIHNvIGlzIGF2YWlsYWJsZSBlYXJseSBpbiBCYXNlJ3MgYnVpbGQgb3JkZXIuICBBbGxcbiAgIEJhc2UgZmlsZXMgdGhhdCBuZWVkIHRvIHVzZSBhcnJheXMgYW5kIGNvbWUgYmVmb3JlIFtCYXNlLkFycmF5XSBpbiBidWlsZCBvcmRlciBzaG91bGRcbiAgIGRvIFttb2R1bGUgQXJyYXkgPSBBcnJheTBdLiAgVGhpcyBpbmNsdWRlcyB1c2VzIG9mIHN1YnNjcmlwdCBzeW50YXggKFt4LihpKV0sIFt4LihpKSA8LVxuICAgZV0pLCB3aGljaCB0aGUgT0NhbWwgcGFyc2VyIGRlc3VnYXJzIGludG8gY2FsbHMgdG8gW0FycmF5LmdldF0gYW5kIFtBcnJheS5zZXRdLlxuICAgRGVmaW5pbmcgW21vZHVsZSBBcnJheSA9IEFycmF5MF0gaXMgYWxzbyBuZWNlc3NhcnkgYmVjYXVzZSBpdCBwcmV2ZW50cyBvY2FtbGRlcCBmcm9tXG4gICBtaXN0YWtlbmx5IGNhdXNpbmcgYSBmaWxlIHRvIGRlcGVuZCBvbiBbQmFzZS5BcnJheV0uICopXG5cbm9wZW4hIEltcG9ydDBcbm1vZHVsZSBTeXMgPSBTeXMwXG5cbmxldCBpbnZhbGlkX2FyZ2YgPSBQcmludGYuaW52YWxpZF9hcmdmXG5cbm1vZHVsZSBBcnJheSA9IHN0cnVjdFxuICBleHRlcm5hbCBjcmVhdGUgOiBpbnQgLT4gJ2EgLT4gJ2EgYXJyYXkgPSBcImNhbWxfbWFrZV92ZWN0XCJcbiAgZXh0ZXJuYWwgY3JlYXRlX2Zsb2F0X3VuaW5pdGlhbGl6ZWQgOiBpbnQgLT4gZmxvYXQgYXJyYXkgPSBcImNhbWxfbWFrZV9mbG9hdF92ZWN0XCJcbiAgZXh0ZXJuYWwgZ2V0IDogJ2EgYXJyYXkgLT4gaW50IC0+ICdhID0gXCIlYXJyYXlfc2FmZV9nZXRcIlxuICBleHRlcm5hbCBsZW5ndGggOiAnYSBhcnJheSAtPiBpbnQgPSBcIiVhcnJheV9sZW5ndGhcIlxuICBleHRlcm5hbCBzZXQgOiAnYSBhcnJheSAtPiBpbnQgLT4gJ2EgLT4gdW5pdCA9IFwiJWFycmF5X3NhZmVfc2V0XCJcbiAgZXh0ZXJuYWwgdW5zYWZlX2dldCA6ICdhIGFycmF5IC0+IGludCAtPiAnYSA9IFwiJWFycmF5X3Vuc2FmZV9nZXRcIlxuICBleHRlcm5hbCB1bnNhZmVfc2V0IDogJ2EgYXJyYXkgLT4gaW50IC0+ICdhIC0+IHVuaXQgPSBcIiVhcnJheV91bnNhZmVfc2V0XCJcblxuICBleHRlcm5hbCB1bnNhZmVfYmxpdFxuICAgIDogIHNyYzonYSBhcnJheVxuICAgIC0+IHNyY19wb3M6aW50XG4gICAgLT4gZHN0OidhIGFycmF5XG4gICAgLT4gZHN0X3BvczppbnRcbiAgICAtPiBsZW46aW50XG4gICAgLT4gdW5pdFxuICAgID0gXCJjYW1sX2FycmF5X2JsaXRcIlxuZW5kXG5cbmluY2x1ZGUgQXJyYXlcblxubGV0IG1heF9sZW5ndGggPSBTeXMubWF4X2FycmF5X2xlbmd0aFxuXG5sZXQgY3JlYXRlIH5sZW4geCA9XG4gIHRyeSBjcmVhdGUgbGVuIHggd2l0aFxuICB8IEludmFsaWRfYXJndW1lbnQgXyAtPiBpbnZhbGlkX2FyZ2YgXCJBcnJheS5jcmVhdGUgfmxlbjolZDogaW52YWxpZCBsZW5ndGhcIiBsZW4gKClcbjs7XG5cbmxldCBjcmVhdGVfZmxvYXRfdW5pbml0aWFsaXplZCB+bGVuID1cbiAgdHJ5IGNyZWF0ZV9mbG9hdF91bmluaXRpYWxpemVkIGxlbiB3aXRoXG4gIHwgSW52YWxpZF9hcmd1bWVudCBfIC0+XG4gICAgaW52YWxpZF9hcmdmIFwiQXJyYXkuY3JlYXRlX2Zsb2F0X3VuaW5pdGlhbGl6ZWQgfmxlbjolZDogaW52YWxpZCBsZW5ndGhcIiBsZW4gKClcbjs7XG5cbmxldCBhcHBlbmQgPSBDYW1sLkFycmF5LmFwcGVuZFxubGV0IGJsaXQgPSBDYW1sLkFycmF5LmJsaXRcbmxldCBjb25jYXQgPSBDYW1sLkFycmF5LmNvbmNhdFxubGV0IGNvcHkgPSBDYW1sLkFycmF5LmNvcHlcbmxldCBmaWxsID0gQ2FtbC5BcnJheS5maWxsXG5sZXQgaW5pdCA9IENhbWwuQXJyYXkuaW5pdFxubGV0IG1ha2VfbWF0cml4ID0gQ2FtbC5BcnJheS5tYWtlX21hdHJpeFxubGV0IG9mX2xpc3QgPSBDYW1sLkFycmF5Lm9mX2xpc3RcbmxldCBzdWIgPSBDYW1sLkFycmF5LnN1YlxubGV0IHRvX2xpc3QgPSBDYW1sLkFycmF5LnRvX2xpc3RcblxuKCogVGhlc2UgYXJlIGV0YSBleHBhbmRlZCBpbiBvcmRlciB0byBwZXJtdXRlIHBhcmFtZXRlciBvcmRlciB0byBmb2xsb3cgQmFzZVxuICAgY29udmVudGlvbnMuICopXG5sZXQgZm9sZCB0IH5pbml0IH5mID0gQ2FtbC5BcnJheS5mb2xkX2xlZnQgdCB+aW5pdCB+ZlxubGV0IGZvbGRfcmlnaHQgdCB+ZiB+aW5pdCA9IENhbWwuQXJyYXkuZm9sZF9yaWdodCB0IH5mIH5pbml0XG5sZXQgaXRlciB0IH5mID0gQ2FtbC5BcnJheS5pdGVyIHQgfmZcbmxldCBpdGVyaSB0IH5mID0gQ2FtbC5BcnJheS5pdGVyaSB0IH5mXG5sZXQgbWFwIHQgfmYgPSBDYW1sLkFycmF5Lm1hcCB0IH5mXG5sZXQgbWFwaSB0IH5mID0gQ2FtbC5BcnJheS5tYXBpIHQgfmZcbmxldCBzdGFibGVfc29ydCB0IH5jb21wYXJlID0gQ2FtbC5BcnJheS5zdGFibGVfc29ydCB0IH5jbXA6Y29tcGFyZVxuXG5sZXQgc3dhcCB0IGkgaiA9XG4gIGxldCBlbHRfaSA9IHQuKGkpIGluXG4gIGxldCBlbHRfaiA9IHQuKGopIGluXG4gIHVuc2FmZV9zZXQgdCBpIGVsdF9qO1xuICB1bnNhZmVfc2V0IHQgaiBlbHRfaVxuOztcbiIsIigqIFtDaGFyMF0gZGVmaW5lcyBjaGFyIGZ1bmN0aW9ucyB0aGF0IGFyZSBwcmltaXRpdmVzIG9yIGNhbiBiZSBzaW1wbHkgZGVmaW5lZCBpbiB0ZXJtcyBvZlxuICAgW0NhbWwuQ2hhcl0uICBbQ2hhcjBdIGlzIGludGVuZGVkIHRvIGNvbXBsZXRlbHkgZXhwcmVzcyB0aGUgcGFydCBvZiBbQ2FtbC5DaGFyXSB0aGF0XG4gICBbQmFzZV0gdXNlcyAtLSBubyBvdGhlciBmaWxlIGluIEJhc2Ugb3RoZXIgdGhhbiBjaGFyMC5tbCBzaG91bGQgdXNlIFtDYW1sLkNoYXJdLlxuICAgW0NoYXIwXSBoYXMgZmV3IGRlcGVuZGVuY2llcywgYW5kIHNvIGlzIGF2YWlsYWJsZSBlYXJseSBpbiBCYXNlJ3MgYnVpbGQgb3JkZXIuICBBbGxcbiAgIEJhc2UgZmlsZXMgdGhhdCBuZWVkIHRvIHVzZSBjaGFycyBhbmQgY29tZSBiZWZvcmUgW0Jhc2UuQ2hhcl0gaW4gYnVpbGQgb3JkZXIgc2hvdWxkIGRvXG4gICBbbW9kdWxlIENoYXIgPSBDaGFyMF0uICBEZWZpbmluZyBbbW9kdWxlIENoYXIgPSBDaGFyMF0gaXMgYWxzbyBuZWNlc3NhcnkgYmVjYXVzZSBpdFxuICAgcHJldmVudHMgb2NhbWxkZXAgZnJvbSBtaXN0YWtlbmx5IGNhdXNpbmcgYSBmaWxlIHRvIGRlcGVuZCBvbiBbQmFzZS5DaGFyXS4gKilcblxub3BlbiEgSW1wb3J0MFxuXG5sZXQgZmFpbHdpdGhmID0gUHJpbnRmLmZhaWx3aXRoZlxubGV0IGVzY2FwZWQgPSBDYW1sLkNoYXIuZXNjYXBlZFxubGV0IGxvd2VyY2FzZSA9IENhbWwuQ2hhci5sb3dlcmNhc2VfYXNjaWlcbmxldCB0b19pbnQgPSBDYW1sLkNoYXIuY29kZVxubGV0IHVuc2FmZV9vZl9pbnQgPSBDYW1sLkNoYXIudW5zYWZlX2NoclxubGV0IHVwcGVyY2FzZSA9IENhbWwuQ2hhci51cHBlcmNhc2VfYXNjaWlcblxuKCogV2UgdXNlIG91ciBvd24gcmFuZ2UgdGVzdCB3aGVuIGNvbnZlcnRpbmcgaW50ZWdlcnMgdG8gY2hhcnMgcmF0aGVyIHRoYW5cbiAgIGNhbGxpbmcgW0NhbWwuQ2hhci5jaHJdIGJlY2F1c2UgaXQncyBzaW1wbGUgYW5kIGl0IHNhdmVzIHVzIGEgZnVuY3Rpb24gY2FsbFxuICAgYW5kIHRoZSB0cnktd2l0aCAoZXhjZXB0aW9ucyBjb3N0LCBlc3BlY2lhbGx5IGluIHRoZSB3b3JsZCB3aXRoIGJhY2t0cmFjZXMpLiAqKVxubGV0IGludF9pc19vayBpID0gMCA8PSBpICYmIGkgPD0gMjU1XG5sZXQgbWluX3ZhbHVlID0gdW5zYWZlX29mX2ludCAwXG5sZXQgbWF4X3ZhbHVlID0gdW5zYWZlX29mX2ludCAyNTVcbmxldCBvZl9pbnQgaSA9IGlmIGludF9pc19vayBpIHRoZW4gU29tZSAodW5zYWZlX29mX2ludCBpKSBlbHNlIE5vbmVcblxubGV0IG9mX2ludF9leG4gaSA9XG4gIGlmIGludF9pc19vayBpXG4gIHRoZW4gdW5zYWZlX29mX2ludCBpXG4gIGVsc2UgZmFpbHdpdGhmIFwiQ2hhci5vZl9pbnRfZXhuIGdvdCBpbnRlZ2VyIG91dCBvZiByYW5nZTogJWRcIiBpICgpXG47O1xuXG5sZXQgZXF1YWwgKHQxIDogY2hhcikgdDIgPSBQb2x5LmVxdWFsIHQxIHQyXG4iLCIoKiBbSW50MF0gZGVmaW5lcyBpbnRlZ2VyIGZ1bmN0aW9ucyB0aGF0IGFyZSBwcmltaXRpdmVzIG9yIGNhbiBiZSBzaW1wbHlcbiAgIGRlZmluZWQgaW4gdGVybXMgb2YgW0NhbWxdLiBbSW50MF0gaXMgaW50ZW5kZWQgdG8gY29tcGxldGVseSBleHByZXNzIHRoZVxuICAgcGFydCBvZiBbQ2FtbF0gdGhhdCBbQmFzZV0gdXNlcyBmb3IgaW50ZWdlcnMgLS0gbm8gb3RoZXIgZmlsZSBpbiBCYXNlIG90aGVyXG4gICB0aGFuIGludDAubWwgc2hvdWxkIHVzZSB0aGVzZSBmdW5jdGlvbnMgZGlyZWN0bHkgdGhyb3VnaCBbQ2FtbF0uIFtJbnQwXSBoYXNcbiAgIGZldyBkZXBlbmRlbmNpZXMsIGFuZCBzbyBpcyBhdmFpbGFibGUgZWFybHkgaW4gQmFzZSdzIGJ1aWxkIG9yZGVyLlxuXG4gICBBbGwgQmFzZSBmaWxlcyB0aGF0IG5lZWQgdG8gdXNlIGludHMgYW5kIGNvbWUgYmVmb3JlIFtCYXNlLkludF0gaW4gYnVpbGRcbiAgIG9yZGVyIHNob3VsZCBkbzpcblxuICAge1tcbiAgICAgbW9kdWxlIEludCAgPSBJbnQwXG4gICBdfVxuXG4gICBEZWZpbmluZyBbbW9kdWxlIEludCA9IEludDBdIGlzIGFsc28gbmVjZXNzYXJ5IGJlY2F1c2UgaXQgcHJldmVudHMgb2NhbWxkZXBcbiAgIGZyb20gbWlzdGFrZW5seSBjYXVzaW5nIGEgZmlsZSB0byBkZXBlbmQgb24gW0Jhc2UuSW50XS4gKilcblxubGV0IHRvX3N0cmluZyA9IENhbWwuc3RyaW5nX29mX2ludFxubGV0IG9mX3N0cmluZyA9IENhbWwuaW50X29mX3N0cmluZ1xubGV0IHRvX2Zsb2F0ID0gQ2FtbC5mbG9hdF9vZl9pbnRcbmxldCBvZl9mbG9hdCA9IENhbWwuaW50X29mX2Zsb2F0XG5sZXQgbWF4X3ZhbHVlID0gQ2FtbC5tYXhfaW50XG5sZXQgbWluX3ZhbHVlID0gQ2FtbC5taW5faW50XG5sZXQgc3VjYyA9IENhbWwuc3VjY1xuIiwiKCogW0xpc3QwXSBkZWZpbmVzIGxpc3QgZnVuY3Rpb25zIHRoYXQgYXJlIHByaW1pdGl2ZXMgb3IgY2FuIGJlIHNpbXBseSBkZWZpbmVkIGluIHRlcm1zIG9mXG4gICBbQ2FtbC5MaXN0XS4gIFtMaXN0MF0gaXMgaW50ZW5kZWQgdG8gY29tcGxldGVseSBleHByZXNzIHRoZSBwYXJ0IG9mIFtDYW1sLkxpc3RdIHRoYXRcbiAgIFtCYXNlXSB1c2VzIC0tIG5vIG90aGVyIGZpbGUgaW4gQmFzZSBvdGhlciB0aGFuIGxpc3QwLm1sIHNob3VsZCB1c2UgW0NhbWwuTGlzdF0uXG4gICBbTGlzdDBdIGhhcyBmZXcgZGVwZW5kZW5jaWVzLCBhbmQgc28gaXMgYXZhaWxhYmxlIGVhcmx5IGluIEJhc2UncyBidWlsZCBvcmRlci4gIEFsbFxuICAgQmFzZSBmaWxlcyB0aGF0IG5lZWQgdG8gdXNlIGxpc3RzIGFuZCBjb21lIGJlZm9yZSBbQmFzZS5MaXN0XSBpbiBidWlsZCBvcmRlciBzaG91bGQgZG9cbiAgIFttb2R1bGUgTGlzdCA9IExpc3QwXS4gIERlZmluaW5nIFttb2R1bGUgTGlzdCA9IExpc3QwXSBpcyBhbHNvIG5lY2Vzc2FyeSBiZWNhdXNlIGl0XG4gICBwcmV2ZW50cyBvY2FtbGRlcCBmcm9tIG1pc3Rha2VubHkgY2F1c2luZyBhIGZpbGUgdG8gZGVwZW5kIG9uIFtCYXNlLkxpc3RdLiAqKVxuXG5vcGVuISBJbXBvcnQwXG5cbmxldCBoZF9leG4gPSBDYW1sLkxpc3QuaGRcbmxldCBsZW5ndGggPSBDYW1sLkxpc3QubGVuZ3RoXG5sZXQgcmV2X2FwcGVuZCA9IENhbWwuTGlzdC5yZXZfYXBwZW5kXG5sZXQgdGxfZXhuID0gQ2FtbC5MaXN0LnRsXG5sZXQgdW56aXAgPSBDYW1sLkxpc3Quc3BsaXRcblxuKCogVGhlc2UgYXJlIGV0YSBleHBhbmRlZCBpbiBvcmRlciB0byBwZXJtdXRlIHBhcmFtZXRlciBvcmRlciB0byBmb2xsb3cgQmFzZVxuICAgY29udmVudGlvbnMuICopXG5sZXQgZXhpc3RzIHQgfmYgPSBDYW1sLkxpc3QuZXhpc3RzIHQgfmZcbmxldCBleGlzdHMyX29rIGwxIGwyIH5mID0gQ2FtbC5MaXN0LmV4aXN0czIgbDEgbDIgfmZcbmxldCBmb2xkIHQgfmluaXQgfmYgPSBDYW1sLkxpc3QuZm9sZF9sZWZ0IHQgfmYgfmluaXRcbmxldCBmb2xkMl9vayBsMSBsMiB+aW5pdCB+ZiA9IENhbWwuTGlzdC5mb2xkX2xlZnQyIGwxIGwyIH5pbml0IH5mXG5sZXQgZm9yX2FsbCB0IH5mID0gQ2FtbC5MaXN0LmZvcl9hbGwgdCB+ZlxubGV0IGZvcl9hbGwyX29rIGwxIGwyIH5mID0gQ2FtbC5MaXN0LmZvcl9hbGwyIGwxIGwyIH5mXG5sZXQgaXRlciB0IH5mID0gQ2FtbC5MaXN0Lml0ZXIgdCB+ZlxubGV0IGl0ZXIyX29rIGwxIGwyIH5mID0gQ2FtbC5MaXN0Lml0ZXIyIGwxIGwyIH5mXG5sZXQgbm9udGFpbF9tYXAgdCB+ZiA9IENhbWwuTGlzdC5tYXAgdCB+ZlxubGV0IG5vbnRhaWxfbWFwaSB0IH5mID0gQ2FtbC5MaXN0Lm1hcGkgdCB+ZlxubGV0IHBhcnRpdGlvbiB0IH5mID0gQ2FtbC5MaXN0LnBhcnRpdGlvbiB0IH5mXG5sZXQgcmV2X21hcCB0IH5mID0gQ2FtbC5MaXN0LnJldl9tYXAgdCB+ZlxubGV0IHJldl9tYXAyX29rIGwxIGwyIH5mID0gQ2FtbC5MaXN0LnJldl9tYXAyIGwxIGwyIH5mXG5sZXQgc29ydCBsIH5jb21wYXJlID0gQ2FtbC5MaXN0LnNvcnQgbCB+Y21wOmNvbXBhcmVcbmxldCBzdGFibGVfc29ydCBsIH5jb21wYXJlID0gQ2FtbC5MaXN0LnN0YWJsZV9zb3J0IGwgfmNtcDpjb21wYXJlXG5cbmxldCByZXYgPSBmdW5jdGlvblxuICB8IChbXSB8IFsgXyBdKSBhcyByZXMgLT4gcmVzXG4gIHwgeCA6OiB5IDo6IHJlc3QgLT4gcmV2X2FwcGVuZCByZXN0IFsgeTsgeCBdXG47O1xuXG5sZXQgZm9sZF9yaWdodCBsIH5mIH5pbml0ID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT4gaW5pdCAoKiBhdm9pZCB0aGUgYWxsb2NhdGlvbiBvZiBbfmZdIGJlbG93ICopXG4gIHwgXyAtPiBmb2xkIH5mOihmdW4gYSBiIC0+IGYgYiBhKSB+aW5pdCAocmV2IGwpXG47O1xuIiwiKCpcbiAgIFRoaXMgaXMgdGhlIGludGVyZmFjZSB0byB0aGUgcnVudGltZSBzdXBwb3J0IGZvciBbcHB4X2hhc2hdLlxuXG4gICBUaGUgW3BweF9oYXNoXSBzeW50YXggZXh0ZW5zaW9uIHN1cHBvcnRzOiBbQEBkZXJpdmluZyBoYXNoXSBhbmQgWyVoYXNoX2ZvbGQ6IFRZUEVdIGFuZFxuICAgWyVoYXNoOiBUWVBFXVxuXG4gICBGb3IgdHlwZSBbdF0gYSBmdW5jdGlvbiBbaGFzaF9mb2xkX3RdIG9mIHR5cGUgW0hhc2guc3RhdGUgLT4gdCAtPiBIYXNoLnN0YXRlXSBpc1xuICAgZ2VuZXJhdGVkLlxuXG4gICBUaGUgZ2VuZXJhdGVkIFtoYXNoX2ZvbGRfPFQ+XSBmdW5jdGlvbiBpcyBjb21wb3NpdGlvbmFsLCBmb2xsb3dpbmcgdGhlIHN0cnVjdHVyZSBvZiB0aGVcbiAgIHR5cGU7IGFsbG93aW5nIHVzZXIgb3ZlcnJpZGVzIGF0IGV2ZXJ5IGxldmVsLiBUaGlzIGlzIGluIGNvbnRyYXN0IHRvIG9jYW1sJ3MgYnVpbHRpblxuICAgcG9seW1vcnBoaWMgaGFzaGluZyBbSGFzaHRibC5oYXNoXSB3aGljaCBpZ25vcmVzIHVzZXIgb3ZlcnJpZGVzLlxuXG4gICBUaGUgZ2VuZXJhdG9yIGFsc28gcHJvdmlkZXMgYSBkaXJlY3QgaGFzaC1mdW5jdGlvbiBbaGFzaF0gKG5hbWVkIFtoYXNoXzxUPl0gd2hlbiA8VD4gIT1cbiAgIFwidFwiKSBvZiB0eXBlOiBbdCAtPiBIYXNoLmhhc2hfdmFsdWVdLlxuXG4gICBUaGUgZm9sZGluZyBoYXNoIGZ1bmN0aW9uIGNhbiBiZSBhY2Nlc3NlZCBhcyBbJWhhc2hfZm9sZDogVFlQRV1cbiAgIFRoZSBkaXJlY3QgaGFzaCBmdW5jdGlvbiBjYW4gYmUgYWNjZXNzZWQgYXMgWyVoYXNoOiBUWVBFXVxuKilcblxub3BlbiEgSW1wb3J0MFxubW9kdWxlIEFycmF5ID0gQXJyYXkwXG5tb2R1bGUgQ2hhciA9IENoYXIwXG5tb2R1bGUgSW50ID0gSW50MFxubW9kdWxlIExpc3QgPSBMaXN0MFxuaW5jbHVkZSBIYXNoX2ludGZcblxuKCoqIEJ1aWx0aW4gZm9sZGluZy1zdHlsZSBoYXNoIGZ1bmN0aW9ucywgYWJzdHJhY3RlZCBvdmVyIFtIYXNoX2ludGYuU10gKilcbm1vZHVsZSBGb2xkaW5nIChIYXNoIDogSGFzaF9pbnRmLlMpIDpcbiAgSGFzaF9pbnRmLkJ1aWx0aW5faW50ZlxuICB3aXRoIHR5cGUgc3RhdGUgPSBIYXNoLnN0YXRlXG4gICBhbmQgdHlwZSBoYXNoX3ZhbHVlID0gSGFzaC5oYXNoX3ZhbHVlID0gc3RydWN0XG4gIHR5cGUgc3RhdGUgPSBIYXNoLnN0YXRlXG4gIHR5cGUgaGFzaF92YWx1ZSA9IEhhc2guaGFzaF92YWx1ZVxuICB0eXBlICdhIGZvbGRlciA9IHN0YXRlIC0+ICdhIC0+IHN0YXRlXG5cbiAgbGV0IGhhc2hfZm9sZF91bml0IHMgKCkgPSBzXG4gIGxldCBoYXNoX2ZvbGRfaW50ID0gSGFzaC5mb2xkX2ludFxuICBsZXQgaGFzaF9mb2xkX2ludDY0ID0gSGFzaC5mb2xkX2ludDY0XG4gIGxldCBoYXNoX2ZvbGRfZmxvYXQgPSBIYXNoLmZvbGRfZmxvYXRcbiAgbGV0IGhhc2hfZm9sZF9zdHJpbmcgPSBIYXNoLmZvbGRfc3RyaW5nXG4gIGxldCBhc19pbnQgZiBzIHggPSBoYXNoX2ZvbGRfaW50IHMgKGYgeClcblxuICAoKiBUaGlzIGlnbm9yZXMgdGhlIHNpZ24gYml0IG9uIDMyLWJpdCBhcmNoaXRlY3R1cmVzLCBidXQgaXQncyB1bmxpa2VseSB0byBsZWFkIHRvXG4gICAgIGZyZXF1ZW50IGNvbGxpc2lvbnMgKG1pbl92YWx1ZSBjb2xsaWRpbmcgd2l0aCAwIGlzIHRoZSBtb3N0IGxpa2VseSBvbmUpLiAgKilcbiAgbGV0IGhhc2hfZm9sZF9pbnQzMiA9IGFzX2ludCBDYW1sLkludDMyLnRvX2ludFxuICBsZXQgaGFzaF9mb2xkX2NoYXIgPSBhc19pbnQgQ2hhci50b19pbnRcblxuICBsZXQgaGFzaF9mb2xkX2Jvb2wgPVxuICAgIGFzX2ludCAoZnVuY3Rpb25cbiAgICAgIHwgdHJ1ZSAtPiAxXG4gICAgICB8IGZhbHNlIC0+IDApXG4gIDs7XG5cbiAgbGV0IGhhc2hfZm9sZF9uYXRpdmVpbnQgcyB4ID0gaGFzaF9mb2xkX2ludDY0IHMgKENhbWwuSW50NjQub2ZfbmF0aXZlaW50IHgpXG5cbiAgbGV0IGhhc2hfZm9sZF9vcHRpb24gaGFzaF9mb2xkX2VsZW0gcyA9IGZ1bmN0aW9uXG4gICAgfCBOb25lIC0+IGhhc2hfZm9sZF9pbnQgcyAwXG4gICAgfCBTb21lIHggLT4gaGFzaF9mb2xkX2VsZW0gKGhhc2hfZm9sZF9pbnQgcyAxKSB4XG4gIDs7XG5cbiAgbGV0IHJlYyBoYXNoX2ZvbGRfbGlzdF9ib2R5IGhhc2hfZm9sZF9lbGVtIHMgbGlzdCA9XG4gICAgbWF0Y2ggbGlzdCB3aXRoXG4gICAgfCBbXSAtPiBzXG4gICAgfCB4IDo6IHhzIC0+IGhhc2hfZm9sZF9saXN0X2JvZHkgaGFzaF9mb2xkX2VsZW0gKGhhc2hfZm9sZF9lbGVtIHMgeCkgeHNcbiAgOztcblxuICBsZXQgaGFzaF9mb2xkX2xpc3QgaGFzaF9mb2xkX2VsZW0gcyBsaXN0ID1cbiAgICAoKiBUaGUgW2xlbmd0aF0gb2YgdGhlIGxpc3QgbXVzdCBiZSBpbmNvcnBvcmF0ZWQgaW50byB0aGUgaGFzaC1zdGF0ZSBzbyB2YWx1ZXMgb2ZcbiAgICAgICB0eXBlcyBzdWNoIGFzIFt1bml0IGxpc3RdIC0gKFtdLCBbKCldLCBbKCk7KCldLC4uKSBhcmUgaGFzaGVkIGRpZmZlcmVudGx5LiAqKVxuICAgICgqIFRoZSBbbGVuZ3RoXSBtdXN0IGNvbWUgYmVmb3JlIHRoZSBlbGVtZW50cyB0byBhdm9pZCBhIHZpb2xhdGlvbiBvZiB0aGUgcnVsZVxuICAgICAgIGVuZm9yY2VkIGJ5IFBlcmZlY3RfaGFzaC4gKilcbiAgICBsZXQgcyA9IGhhc2hfZm9sZF9pbnQgcyAoTGlzdC5sZW5ndGggbGlzdCkgaW5cbiAgICBsZXQgcyA9IGhhc2hfZm9sZF9saXN0X2JvZHkgaGFzaF9mb2xkX2VsZW0gcyBsaXN0IGluXG4gICAgc1xuICA7O1xuXG4gIGxldCBoYXNoX2ZvbGRfbGF6eV90IGhhc2hfZm9sZF9lbGVtIHMgeCA9IGhhc2hfZm9sZF9lbGVtIHMgKENhbWwuTGF6eS5mb3JjZSB4KVxuICBsZXQgaGFzaF9mb2xkX3JlZl9mcm96ZW4gaGFzaF9mb2xkX2VsZW0gcyB4ID0gaGFzaF9mb2xkX2VsZW0gcyAheFxuXG4gIGxldCByZWMgaGFzaF9mb2xkX2FycmF5X2Zyb3plbl9pIGhhc2hfZm9sZF9lbGVtIHMgYXJyYXkgaSA9XG4gICAgaWYgaSA9IEFycmF5Lmxlbmd0aCBhcnJheVxuICAgIHRoZW4gc1xuICAgIGVsc2UgKFxuICAgICAgbGV0IGUgPSBBcnJheS51bnNhZmVfZ2V0IGFycmF5IGkgaW5cbiAgICAgIGhhc2hfZm9sZF9hcnJheV9mcm96ZW5faSBoYXNoX2ZvbGRfZWxlbSAoaGFzaF9mb2xkX2VsZW0gcyBlKSBhcnJheSAoaSArIDEpKVxuICA7O1xuXG4gIGxldCBoYXNoX2ZvbGRfYXJyYXlfZnJvemVuIGhhc2hfZm9sZF9lbGVtIHMgYXJyYXkgPVxuICAgIGhhc2hfZm9sZF9hcnJheV9mcm96ZW5faVxuICAgICAgKCogW2xlbmd0aF0gbXVzdCBiZSBpbmNvcnBvcmF0ZWQgZm9yIGFycmF5cywgYXMgaXQgaXMgZm9yIGxpc3RzLiBTZWUgY29tbWVudCBhYm92ZSAqKVxuICAgICAgaGFzaF9mb2xkX2VsZW1cbiAgICAgIChoYXNoX2ZvbGRfaW50IHMgKEFycmF5Lmxlbmd0aCBhcnJheSkpXG4gICAgICBhcnJheVxuICAgICAgMFxuICA7O1xuXG4gICgqIHRoZSBkdXBsaWNhdGlvbiBoZXJlIGlzIGJlY2F1c2Ugd2UgdGhpbmtcbiAgICAgb2NhbWwgY2FuJ3QgZWxpbWluYXRlIGluZGlyZWN0IGZ1bmN0aW9uIGNhbGxzIG90aGVyd2lzZS4gKilcbiAgbGV0IGhhc2hfbmF0aXZlaW50IHggPVxuICAgIEhhc2guZ2V0X2hhc2hfdmFsdWUgKGhhc2hfZm9sZF9uYXRpdmVpbnQgKEhhc2gucmVzZXQgKEhhc2guYWxsb2MgKCkpKSB4KVxuICA7O1xuXG4gIGxldCBoYXNoX2ludDY0IHggPSBIYXNoLmdldF9oYXNoX3ZhbHVlIChoYXNoX2ZvbGRfaW50NjQgKEhhc2gucmVzZXQgKEhhc2guYWxsb2MgKCkpKSB4KVxuICBsZXQgaGFzaF9pbnQzMiB4ID0gSGFzaC5nZXRfaGFzaF92YWx1ZSAoaGFzaF9mb2xkX2ludDMyIChIYXNoLnJlc2V0IChIYXNoLmFsbG9jICgpKSkgeClcbiAgbGV0IGhhc2hfY2hhciB4ID0gSGFzaC5nZXRfaGFzaF92YWx1ZSAoaGFzaF9mb2xkX2NoYXIgKEhhc2gucmVzZXQgKEhhc2guYWxsb2MgKCkpKSB4KVxuICBsZXQgaGFzaF9pbnQgeCA9IEhhc2guZ2V0X2hhc2hfdmFsdWUgKGhhc2hfZm9sZF9pbnQgKEhhc2gucmVzZXQgKEhhc2guYWxsb2MgKCkpKSB4KVxuICBsZXQgaGFzaF9ib29sIHggPSBIYXNoLmdldF9oYXNoX3ZhbHVlIChoYXNoX2ZvbGRfYm9vbCAoSGFzaC5yZXNldCAoSGFzaC5hbGxvYyAoKSkpIHgpXG5cbiAgbGV0IGhhc2hfc3RyaW5nIHggPVxuICAgIEhhc2guZ2V0X2hhc2hfdmFsdWUgKGhhc2hfZm9sZF9zdHJpbmcgKEhhc2gucmVzZXQgKEhhc2guYWxsb2MgKCkpKSB4KVxuICA7O1xuXG4gIGxldCBoYXNoX2Zsb2F0IHggPSBIYXNoLmdldF9oYXNoX3ZhbHVlIChoYXNoX2ZvbGRfZmxvYXQgKEhhc2gucmVzZXQgKEhhc2guYWxsb2MgKCkpKSB4KVxuICBsZXQgaGFzaF91bml0IHggPSBIYXNoLmdldF9oYXNoX3ZhbHVlIChoYXNoX2ZvbGRfdW5pdCAoSGFzaC5yZXNldCAoSGFzaC5hbGxvYyAoKSkpIHgpXG5lbmRcblxubW9kdWxlIEYgKEhhc2ggOiBIYXNoX2ludGYuUykgOlxuICBIYXNoX2ludGYuRnVsbFxuICB3aXRoIHR5cGUgaGFzaF92YWx1ZSA9IEhhc2guaGFzaF92YWx1ZVxuICAgYW5kIHR5cGUgc3RhdGUgPSBIYXNoLnN0YXRlXG4gICBhbmQgdHlwZSBzZWVkID0gSGFzaC5zZWVkID0gc3RydWN0XG4gIGluY2x1ZGUgSGFzaFxuXG4gIHR5cGUgJ2EgZm9sZGVyID0gc3RhdGUgLT4gJ2EgLT4gc3RhdGVcblxuICBsZXQgY3JlYXRlID9zZWVkICgpID0gcmVzZXQgP3NlZWQgKGFsbG9jICgpKVxuICBsZXQgb2ZfZm9sZCBoYXNoX2ZvbGRfdCB0ID0gZ2V0X2hhc2hfdmFsdWUgKGhhc2hfZm9sZF90IChjcmVhdGUgKCkpIHQpXG5cbiAgbW9kdWxlIEJ1aWx0aW4gPSBGb2xkaW5nIChIYXNoKVxuXG4gIGxldCBydW4gP3NlZWQgZm9sZGVyIHggPVxuICAgIEhhc2guZ2V0X2hhc2hfdmFsdWUgKGZvbGRlciAoSGFzaC5yZXNldCA/c2VlZCAoSGFzaC5hbGxvYyAoKSkpIHgpXG4gIDs7XG5lbmRcblxubW9kdWxlIEludGVybmFsaGFzaCA6IHNpZ1xuICBpbmNsdWRlXG4gICAgSGFzaF9pbnRmLlNcbiAgICB3aXRoIHR5cGUgc3RhdGUgPSBCYXNlX2ludGVybmFsaGFzaF90eXBlcy5zdGF0ZVxuICAgICAoKiBXZSBnaXZlIGEgY29uY3JldGUgdHlwZSBmb3IgW3N0YXRlXSwgYWxiZWl0IG9ubHkgcGFydGlhbGx5IGV4cG9zZWQgKHNlZVxuICAgICAgICBCYXNlX2ludGVybmFsaGFzaF90eXBlcyksIHNvIHRoYXQgaXQgdW5pZmllcyB3aXRoIHRoZSBzYW1lIHR5cGUgaW4gW0Jhc2VfYm9vdF0sXG4gICAgICAgIGFuZCB0byBhbGxvdyBvcHRpbWl6YXRpb25zIGZvciB0aGUgaW1tZWRpYXRlIHR5cGUuICopXG4gICAgIGFuZCB0eXBlIHNlZWQgPSBCYXNlX2ludGVybmFsaGFzaF90eXBlcy5zZWVkXG4gICAgIGFuZCB0eXBlIGhhc2hfdmFsdWUgPSBCYXNlX2ludGVybmFsaGFzaF90eXBlcy5oYXNoX3ZhbHVlXG5cbiAgZXh0ZXJuYWwgZm9sZF9pbnQ2NCA6IHN0YXRlIC0+IGludDY0IC0+IHN0YXRlID0gXCJCYXNlX2ludGVybmFsaGFzaF9mb2xkX2ludDY0XCJcbiAgW0BAbm9hbGxvY11cblxuICBleHRlcm5hbCBmb2xkX2ludCA6IHN0YXRlIC0+IGludCAtPiBzdGF0ZSA9IFwiQmFzZV9pbnRlcm5hbGhhc2hfZm9sZF9pbnRcIiBbQEBub2FsbG9jXVxuXG4gIGV4dGVybmFsIGZvbGRfZmxvYXQgOiBzdGF0ZSAtPiBmbG9hdCAtPiBzdGF0ZSA9IFwiQmFzZV9pbnRlcm5hbGhhc2hfZm9sZF9mbG9hdFwiXG4gIFtAQG5vYWxsb2NdXG5cbiAgZXh0ZXJuYWwgZm9sZF9zdHJpbmcgOiBzdGF0ZSAtPiBzdHJpbmcgLT4gc3RhdGUgPSBcIkJhc2VfaW50ZXJuYWxoYXNoX2ZvbGRfc3RyaW5nXCJcbiAgW0BAbm9hbGxvY11cblxuICBleHRlcm5hbCBnZXRfaGFzaF92YWx1ZSA6IHN0YXRlIC0+IGhhc2hfdmFsdWUgPSBcIkJhc2VfaW50ZXJuYWxoYXNoX2dldF9oYXNoX3ZhbHVlXCJcbiAgW0BAbm9hbGxvY11cbmVuZCA9IHN0cnVjdFxuICBsZXQgZGVzY3JpcHRpb24gPSBcImludGVybmFsaGFzaFwiXG5cbiAgaW5jbHVkZSBCYXNlX2ludGVybmFsaGFzaF90eXBlc1xuXG4gIGxldCBhbGxvYyAoKSA9IGNyZWF0ZV9zZWVkZWQgMFxuICBsZXQgcmVzZXQgPyhzZWVkID0gMCkgX3QgPSBjcmVhdGVfc2VlZGVkIHNlZWRcblxuICBtb2R1bGUgRm9yX3Rlc3RzID0gc3RydWN0XG4gICAgbGV0IGNvbXBhcmVfc3RhdGUgKGEgOiBzdGF0ZSkgKGIgOiBzdGF0ZSkgPSBjb21wYXJlIChhIDo+IGludCkgKGIgOj4gaW50KVxuICAgIGxldCBzdGF0ZV90b19zdHJpbmcgKHN0YXRlIDogc3RhdGUpID0gSW50LnRvX3N0cmluZyAoc3RhdGUgOj4gaW50KVxuICBlbmRcbmVuZFxuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICBpbmNsdWRlIEludGVybmFsaGFzaFxuXG4gIHR5cGUgJ2EgZm9sZGVyID0gc3RhdGUgLT4gJ2EgLT4gc3RhdGVcblxuICBsZXQgY3JlYXRlID9zZWVkICgpID0gcmVzZXQgP3NlZWQgKGFsbG9jICgpKVxuICBsZXQgcnVuID9zZWVkIGZvbGRlciB4ID0gZ2V0X2hhc2hfdmFsdWUgKGZvbGRlciAocmVzZXQgP3NlZWQgKGFsbG9jICgpKSkgeClcbiAgbGV0IG9mX2ZvbGQgaGFzaF9mb2xkX3QgdCA9IGdldF9oYXNoX3ZhbHVlIChoYXNoX2ZvbGRfdCAoY3JlYXRlICgpKSB0KVxuXG4gIG1vZHVsZSBCdWlsdGluID0gc3RydWN0XG4gICAgbW9kdWxlIEZvbGRpbmcgPSBGb2xkaW5nIChJbnRlcm5hbGhhc2gpXG4gICAgaW5jbHVkZSBGb2xkaW5nXG5cbiAgICAoKiBbRm9sZGluZ10gcHJvdmlkZXMgc29tZSBkZWZhdWx0IGltcGxlbWVudGF0aW9ucyBmb3IgdGhlIFtoYXNoXypdIGZ1bmN0aW9ucyBiZWxvdyxcbiAgICAgICBidXQgdGhleSBhcmUgaW5lZmZpY2llbnQgZm9yIHNvbWUgdXNlLWNhc2VzIGJlY2F1c2Ugb2YgdGhlIHVzZSBvZiB0aGUgW2hhc2hfZm9sZF1cbiAgICAgICBmdW5jdGlvbnMuIEF0IHRoaXMgcG9pbnQsIHRoZSBbaGFzaF92YWx1ZV0gdHlwZSBoYXMgYmVlbiBmaXhlZCB0byBbaW50XSwgc28gdGhpc1xuICAgICAgIG1vZHVsZSBjYW4gcHJvdmlkZSBzcGVjaWFsaXplZCBpbXBsZW1lbnRhdGlvbnMuICopXG5cbiAgICBsZXQgaGFzaF9jaGFyID0gQ2hhcjAudG9faW50XG5cbiAgICAoKiBUaGlzIGhhc2ggd2FzIGNob3NlbiBmcm9tIGhlcmU6IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2JhZGJveS82MjY3NzQzXG5cbiAgICAgICBJdCBhdHRlbXB0cyB0byBmdWxmaWxsIHRoZSBwcmltYXJ5IGdvYWxzIG9mIGEgbm9uLWNyeXB0b2dyYXBoaWMgaGFzaCBmdW5jdGlvbjpcblxuICAgICAgIC0gYSBiaXQgY2hhbmdlIGluIHRoZSBpbnB1dCBzaG91bGQgY2hhbmdlIH4xLzIgb2YgdGhlIG91dHB1dCBiaXRzXG4gICAgICAgLSB0aGUgb3V0cHV0IHNob3VsZCBiZSB1bmlmb3JtbHkgZGlzdHJpYnV0ZWQgYWNyb3NzIHRoZSBvdXRwdXQgcmFuZ2VcbiAgICAgICAtIGlucHV0cyB0aGF0IGFyZSBjbG9zZSB0byBlYWNoIG90aGVyIHNob3VsZG4ndCBsZWFkIHRvIG91dHB1dHMgdGhhdCBhcmUgY2xvc2UgdG9cbiAgICAgICAgIGVhY2ggb3RoZXIuXG4gICAgICAgLSBhbGwgYml0cyBvZiB0aGUgaW5wdXQgYXJlIHVzZWQgaW4gZ2VuZXJhdGluZyB0aGUgb3V0cHV0XG5cbiAgICAgICBJbiBvdXIgY2FzZSB3ZSBhbHNvIHdhbnQgaXQgdG8gYmUgZmFzdCwgbm9uLWFsbG9jYXRpbmcsIGFuZCBpbmxpbmFibGUuICAqKVxuICAgIGxldFtAaW5saW5lIGFsd2F5c10gaGFzaF9pbnQgKHQgOiBpbnQpID1cbiAgICAgIGxldCB0ID0gbG5vdCB0ICsgKHQgbHNsIDIxKSBpblxuICAgICAgbGV0IHQgPSB0IGx4b3IgKHQgbHNyIDI0KSBpblxuICAgICAgbGV0IHQgPSB0ICsgKHQgbHNsIDMpICsgKHQgbHNsIDgpIGluXG4gICAgICBsZXQgdCA9IHQgbHhvciAodCBsc3IgMTQpIGluXG4gICAgICBsZXQgdCA9IHQgKyAodCBsc2wgMikgKyAodCBsc2wgNCkgaW5cbiAgICAgIGxldCB0ID0gdCBseG9yICh0IGxzciAyOCkgaW5cbiAgICAgIHQgKyAodCBsc2wgMzEpXG4gICAgOztcblxuICAgIGxldCBoYXNoX2Jvb2wgeCA9IGlmIHggdGhlbiAxIGVsc2UgMFxuXG4gICAgZXh0ZXJuYWwgaGFzaF9mbG9hdCA6IGZsb2F0IC0+IGludCA9IFwiQmFzZV9oYXNoX2RvdWJsZVwiIFtAQG5vYWxsb2NdXG5cbiAgICBsZXQgaGFzaF91bml0ICgpID0gMFxuICBlbmRcbmVuZFxuXG5pbmNsdWRlIFRcbiIsIm9wZW4gSW1wb3J0MFxuXG5sZXQgcGh5c19lcXVhbCA9IHBoeXNfZXF1YWxcblxuZXh0ZXJuYWwgcG9seW1vcnBoaWNfY29tcGFyZSA6ICdhIC0+ICdhIC0+IGludCA9IFwiJWNvbXBhcmVcIlxuZXh0ZXJuYWwgcG9seW1vcnBoaWNfZXF1YWwgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZXF1YWxcIlxuZXh0ZXJuYWwgKCAmJiApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1YW5kXCJcblxubGV0IGNvbXBhcmVfYWJzdHJhY3QgfnR5cGVfbmFtZSBfIF8gPVxuICBQcmludGYua3NwcmludGZcbiAgICBmYWlsd2l0aFxuICAgIFwiQ29tcGFyZSBjYWxsZWQgb24gdGhlIHR5cGUgJXMsIHdoaWNoIGlzIGFic3RyYWN0IGluIGFuIGltcGxlbWVudGF0aW9uLlwiXG4gICAgdHlwZV9uYW1lXG47O1xuXG5sZXQgZXF1YWxfYWJzdHJhY3QgfnR5cGVfbmFtZSBfIF8gPVxuICBQcmludGYua3NwcmludGZcbiAgICBmYWlsd2l0aFxuICAgIFwiRXF1YWwgY2FsbGVkIG9uIHRoZSB0eXBlICVzLCB3aGljaCBpcyBhYnN0cmFjdCBpbiBhbiBpbXBsZW1lbnRhdGlvbi5cIlxuICAgIHR5cGVfbmFtZVxuOztcblxudHlwZSAnYSBjb21wYXJlID0gJ2EgLT4gJ2EgLT4gaW50XG50eXBlICdhIGVxdWFsID0gJ2EgLT4gJ2EgLT4gYm9vbFxuXG5tb2R1bGUgQ29tcGFyYWJsZSA9IHN0cnVjdFxuICBtb2R1bGUgdHlwZSBTID0gc2lnXG4gICAgdHlwZSB0XG5cbiAgICB2YWwgY29tcGFyZSA6IHQgY29tcGFyZVxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTMSA9IHNpZ1xuICAgIHR5cGUgJ2EgdFxuXG4gICAgdmFsIGNvbXBhcmUgOiAnYSBjb21wYXJlIC0+ICdhIHQgY29tcGFyZVxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTMiA9IHNpZ1xuICAgIHR5cGUgKCdhLCAnYikgdFxuXG4gICAgdmFsIGNvbXBhcmUgOiAnYSBjb21wYXJlIC0+ICdiIGNvbXBhcmUgLT4gKCdhLCAnYikgdCBjb21wYXJlXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMzID0gc2lnXG4gICAgdHlwZSAoJ2EsICdiLCAnYykgdFxuXG4gICAgdmFsIGNvbXBhcmUgOiAnYSBjb21wYXJlIC0+ICdiIGNvbXBhcmUgLT4gJ2MgY29tcGFyZSAtPiAoJ2EsICdiLCAnYykgdCBjb21wYXJlXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBFcXVhbCA9IHN0cnVjdFxuICBtb2R1bGUgdHlwZSBTID0gc2lnXG4gICAgdHlwZSB0XG5cbiAgICB2YWwgZXF1YWwgOiB0IGVxdWFsXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMxID0gc2lnXG4gICAgdHlwZSAnYSB0XG5cbiAgICB2YWwgZXF1YWwgOiAnYSBlcXVhbCAtPiAnYSB0IGVxdWFsXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMyID0gc2lnXG4gICAgdHlwZSAoJ2EsICdiKSB0XG5cbiAgICB2YWwgZXF1YWwgOiAnYSBlcXVhbCAtPiAnYiBlcXVhbCAtPiAoJ2EsICdiKSB0IGVxdWFsXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMzID0gc2lnXG4gICAgdHlwZSAoJ2EsICdiLCAnYykgdFxuXG4gICAgdmFsIGVxdWFsIDogJ2EgZXF1YWwgLT4gJ2IgZXF1YWwgLT4gJ2MgZXF1YWwgLT4gKCdhLCAnYiwgJ2MpIHQgZXF1YWxcbiAgZW5kXG5lbmRcblxubW9kdWxlIEJ1aWx0aW4gPSBzdHJ1Y3RcbiAgbGV0IGNvbXBhcmVfYm9vbCA6IGJvb2wgY29tcGFyZSA9IFBvbHkuY29tcGFyZVxuICBsZXQgY29tcGFyZV9jaGFyIDogY2hhciBjb21wYXJlID0gUG9seS5jb21wYXJlXG4gIGxldCBjb21wYXJlX2Zsb2F0IDogZmxvYXQgY29tcGFyZSA9IFBvbHkuY29tcGFyZVxuICBsZXQgY29tcGFyZV9pbnQgOiBpbnQgY29tcGFyZSA9IFBvbHkuY29tcGFyZVxuICBsZXQgY29tcGFyZV9pbnQzMiA6IGludDMyIGNvbXBhcmUgPSBQb2x5LmNvbXBhcmVcbiAgbGV0IGNvbXBhcmVfaW50NjQgOiBpbnQ2NCBjb21wYXJlID0gUG9seS5jb21wYXJlXG4gIGxldCBjb21wYXJlX25hdGl2ZWludCA6IG5hdGl2ZWludCBjb21wYXJlID0gUG9seS5jb21wYXJlXG4gIGxldCBjb21wYXJlX3N0cmluZyA6IHN0cmluZyBjb21wYXJlID0gUG9seS5jb21wYXJlXG4gIGxldCBjb21wYXJlX3VuaXQgOiB1bml0IGNvbXBhcmUgPSBQb2x5LmNvbXBhcmVcblxuICBsZXQgY29tcGFyZV9hcnJheSBjb21wYXJlX2VsdCBhIGIgPVxuICAgIGlmIHBoeXNfZXF1YWwgYSBiXG4gICAgdGhlbiAwXG4gICAgZWxzZSAoXG4gICAgICBsZXQgbGVuX2EgPSBBcnJheTAubGVuZ3RoIGEgaW5cbiAgICAgIGxldCBsZW5fYiA9IEFycmF5MC5sZW5ndGggYiBpblxuICAgICAgbGV0IHJldCA9IGNvbXBhcmUgbGVuX2EgbGVuX2IgaW5cbiAgICAgIGlmIHJldCA8PiAwXG4gICAgICB0aGVuIHJldFxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgICAgICBpZiBpID0gbGVuX2FcbiAgICAgICAgICB0aGVuIDBcbiAgICAgICAgICBlbHNlIChcbiAgICAgICAgICAgIGxldCBsID0gQXJyYXkwLnVuc2FmZV9nZXQgYSBpXG4gICAgICAgICAgICBhbmQgciA9IEFycmF5MC51bnNhZmVfZ2V0IGIgaSBpblxuICAgICAgICAgICAgbGV0IHJlcyA9IGNvbXBhcmVfZWx0IGwgciBpblxuICAgICAgICAgICAgaWYgcmVzIDw+IDAgdGhlbiByZXMgZWxzZSBsb29wIChpICsgMSkpXG4gICAgICAgIGluXG4gICAgICAgIGxvb3AgMCkpXG4gIDs7XG5cbiAgbGV0IHJlYyBjb21wYXJlX2xpc3QgY29tcGFyZV9lbHQgYSBiID1cbiAgICBtYXRjaCBhLCBiIHdpdGhcbiAgICB8IFtdLCBbXSAtPiAwXG4gICAgfCBbXSwgXyAtPiAtMVxuICAgIHwgXywgW10gLT4gMVxuICAgIHwgeCA6OiB4cywgeSA6OiB5cyAtPlxuICAgICAgbGV0IHJlcyA9IGNvbXBhcmVfZWx0IHggeSBpblxuICAgICAgaWYgcmVzIDw+IDAgdGhlbiByZXMgZWxzZSBjb21wYXJlX2xpc3QgY29tcGFyZV9lbHQgeHMgeXNcbiAgOztcblxuICBsZXQgY29tcGFyZV9vcHRpb24gY29tcGFyZV9lbHQgYSBiID1cbiAgICBtYXRjaCBhLCBiIHdpdGhcbiAgICB8IE5vbmUsIE5vbmUgLT4gMFxuICAgIHwgTm9uZSwgU29tZSBfIC0+IC0xXG4gICAgfCBTb21lIF8sIE5vbmUgLT4gMVxuICAgIHwgU29tZSBhLCBTb21lIGIgLT4gY29tcGFyZV9lbHQgYSBiXG4gIDs7XG5cbiAgbGV0IGNvbXBhcmVfcmVmIGNvbXBhcmVfZWx0IGEgYiA9IGNvbXBhcmVfZWx0ICFhICFiXG4gIGxldCBlcXVhbF9ib29sIDogYm9vbCBlcXVhbCA9IFBvbHkuZXF1YWxcbiAgbGV0IGVxdWFsX2NoYXIgOiBjaGFyIGVxdWFsID0gUG9seS5lcXVhbFxuICBsZXQgZXF1YWxfaW50IDogaW50IGVxdWFsID0gUG9seS5lcXVhbFxuICBsZXQgZXF1YWxfaW50MzIgOiBpbnQzMiBlcXVhbCA9IFBvbHkuZXF1YWxcbiAgbGV0IGVxdWFsX2ludDY0IDogaW50NjQgZXF1YWwgPSBQb2x5LmVxdWFsXG4gIGxldCBlcXVhbF9uYXRpdmVpbnQgOiBuYXRpdmVpbnQgZXF1YWwgPSBQb2x5LmVxdWFsXG4gIGxldCBlcXVhbF9zdHJpbmcgOiBzdHJpbmcgZXF1YWwgPSBQb2x5LmVxdWFsXG4gIGxldCBlcXVhbF91bml0IDogdW5pdCBlcXVhbCA9IFBvbHkuZXF1YWxcblxuICAoKiBbUG9seS5lcXVhbF0gaXMgSUVFRSBjb21wbGlhbnQsIHdoaWNoIGlzIG5vdCB3aGF0IHdlIHdhbnQgaGVyZS4gKilcbiAgbGV0IGVxdWFsX2Zsb2F0IHggeSA9IGVxdWFsX2ludCAoY29tcGFyZV9mbG9hdCB4IHkpIDBcblxuICBsZXQgZXF1YWxfYXJyYXkgZXF1YWxfZWx0IGEgYiA9XG4gICAgcGh5c19lcXVhbCBhIGJcbiAgICB8fFxuICAgIGxldCBsZW5fYSA9IEFycmF5MC5sZW5ndGggYSBpblxuICAgIGxldCBsZW5fYiA9IEFycmF5MC5sZW5ndGggYiBpblxuICAgIGVxdWFsIGxlbl9hIGxlbl9iXG4gICAgJiZcbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpID0gbGVuX2FcbiAgICAgIHx8XG4gICAgICBsZXQgbCA9IEFycmF5MC51bnNhZmVfZ2V0IGEgaVxuICAgICAgYW5kIHIgPSBBcnJheTAudW5zYWZlX2dldCBiIGkgaW5cbiAgICAgIGVxdWFsX2VsdCBsIHIgJiYgbG9vcCAoaSArIDEpXG4gICAgaW5cbiAgICBsb29wIDBcbiAgOztcblxuICBsZXQgcmVjIGVxdWFsX2xpc3QgZXF1YWxfZWx0IGEgYiA9XG4gICAgbWF0Y2ggYSwgYiB3aXRoXG4gICAgfCBbXSwgW10gLT4gdHJ1ZVxuICAgIHwgW10sIF8gfCBfLCBbXSAtPiBmYWxzZVxuICAgIHwgeCA6OiB4cywgeSA6OiB5cyAtPiBlcXVhbF9lbHQgeCB5ICYmIGVxdWFsX2xpc3QgZXF1YWxfZWx0IHhzIHlzXG4gIDs7XG5cbiAgbGV0IGVxdWFsX29wdGlvbiBlcXVhbF9lbHQgYSBiID1cbiAgICBtYXRjaCBhLCBiIHdpdGhcbiAgICB8IE5vbmUsIE5vbmUgLT4gdHJ1ZVxuICAgIHwgTm9uZSwgU29tZSBfIHwgU29tZSBfLCBOb25lIC0+IGZhbHNlXG4gICAgfCBTb21lIGEsIFNvbWUgYiAtPiBlcXVhbF9lbHQgYSBiXG4gIDs7XG5cbiAgbGV0IGVxdWFsX3JlZiBlcXVhbF9lbHQgYSBiID0gZXF1YWxfZWx0ICFhICFiXG5lbmRcbiIsIm9wZW4gSGFzaC5CdWlsdGluXG5vcGVuIFBweF9jb21wYXJlX2xpYi5CdWlsdGluXG5pbmNsdWRlIFNleHBsaWIwLlNleHBcblxuKCoqIFR5cGUgb2YgUy1leHByZXNzaW9ucyAqKVxudHlwZSB0ID0gU2V4cGxpYjAuU2V4cC50ID1cbiAgfCBBdG9tIG9mIHN0cmluZ1xuICB8IExpc3Qgb2YgdCBsaXN0XG5bQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgaGFzaF1cblxubGV0IHJlYyBjb21wYXJlID1cbiAgKGZ1biBhX18wMDFfIGJfXzAwMl8gLT5cbiAgICAgaWYgUHB4X2NvbXBhcmVfbGliLnBoeXNfZXF1YWwgYV9fMDAxXyBiX18wMDJfXG4gICAgIHRoZW4gMFxuICAgICBlbHNlIChcbiAgICAgICBtYXRjaCBhX18wMDFfLCBiX18wMDJfIHdpdGhcbiAgICAgICB8IEF0b20gX2FfXzAwM18sIEF0b20gX2JfXzAwNF8gLT4gY29tcGFyZV9zdHJpbmcgX2FfXzAwM18gX2JfXzAwNF9cbiAgICAgICB8IEF0b20gXywgXyAtPiAtMVxuICAgICAgIHwgXywgQXRvbSBfIC0+IDFcbiAgICAgICB8IExpc3QgX2FfXzAwNV8sIExpc3QgX2JfXzAwNl8gLT4gY29tcGFyZV9saXN0IGNvbXBhcmUgX2FfXzAwNV8gX2JfXzAwNl8pXG4gICAgICAgOiB0IC0+IHQgLT4gaW50KVxuOztcblxubGV0IHJlYyAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgKGZ1biBoc3YgYXJnIC0+XG4gICAgIG1hdGNoIGFyZyB3aXRoXG4gICAgIHwgQXRvbSBfYTAgLT5cbiAgICAgICBsZXQgaHN2ID0gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50IGhzdiAwIGluXG4gICAgICAgbGV0IGhzdiA9IGhzdiBpblxuICAgICAgIGhhc2hfZm9sZF9zdHJpbmcgaHN2IF9hMFxuICAgICB8IExpc3QgX2EwIC0+XG4gICAgICAgbGV0IGhzdiA9IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludCBoc3YgMSBpblxuICAgICAgIGxldCBoc3YgPSBoc3YgaW5cbiAgICAgICBoYXNoX2ZvbGRfbGlzdCBoYXNoX2ZvbGRfdCBoc3YgX2EwXG4gICAgICAgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG5cbmFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgbGV0IGZ1bmMgYXJnID1cbiAgICBQcHhfaGFzaF9saWIuU3RkLkhhc2guZ2V0X2hhc2hfdmFsdWVcbiAgICAgIChsZXQgaHN2ID0gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmNyZWF0ZSAoKSBpblxuICAgICAgIGhhc2hfZm9sZF90IGhzdiBhcmcpXG4gIGluXG4gIGZ1biB4IC0+IGZ1bmMgeFxuOztcblxuW0BAQGVuZF1cblxubGV0IHRfc2V4cF9ncmFtbWFyID0gU2V4cGxpYjAuU2V4cF9jb252LnNleHBfdF9zZXhwX2dyYW1tYXJcbmxldCBvZl9zdHJpbmcgPSAoKVxubGV0IGludmFyaWFudCAoXyA6IHQpID0gKClcbiIsIm9wZW4hIEltcG9ydFxubW9kdWxlIEFycmF5ID0gQXJyYXkwXG5pbmNsdWRlIFN0cmluZzBcbm1vZHVsZSBCeXRlcyA9IEJ5dGVzMFxuKCogVGhpcyBhbGlhcyBpcyBuZWNlc3NhcnkgZGVzcGl0ZSBbU3RyaW5nMF0gZGVmaW5pbmcgW0J5dGVzID0gQnl0ZXMwXSwgaW4gb3JkZXIgdG9cbiAgIGNvbnZpbmNlIG9jYW1sZGVwIHRoYXQgdGhpcyBmaWxlIGRvZXNuJ3QgZGVwZW5kIG9uIGJ5dGVzLm1sLiAqKVxuXG5sZXQgaW52YWxpZF9hcmdmID0gUHJpbnRmLmludmFsaWRfYXJnZlxubGV0IHJhaXNlX3MgPSBFcnJvci5yYWlzZV9zXG5sZXQgc3RhZ2UgPSBTdGFnZWQuc3RhZ2VcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gc3RyaW5nIFtAQGRlcml2aW5nX2lubGluZSBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgIGhhc2hfZm9sZF9zdHJpbmdcblxuICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBoYXNoX3N0cmluZyBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCB0X29mX3NleHAgPSAoc3RyaW5nX29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdClcbiAgbGV0IHNleHBfb2ZfdCA9IChzZXhwX29mX3N0cmluZyA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBzdHJpbmdfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICBsZXQgaGFzaGFibGUgOiB0IEhhc2hhYmxlLnQgPSB7IGhhc2g7IGNvbXBhcmU7IHNleHBfb2ZfdCB9XG4gIGxldCBjb21wYXJlID0gY29tcGFyZVxuZW5kXG5cbmluY2x1ZGUgVFxuaW5jbHVkZSBDb21wYXJhdG9yLk1ha2UgKFQpXG5cbnR5cGUgZWx0ID0gY2hhclxuXG5sZXQgaW52YXJpYW50IChfIDogdCkgPSAoKVxuXG4oKiBUaGlzIGlzIGNvcGllZC9hZGFwdGVkIGZyb20gJ2JsaXQubWwnLlxuICAgW3N1Yl0sIFtzdWJvXSBjb3VsZCBiZSBpbXBsZW1lbnRlZCB1c2luZyBbQmxpdC5NYWtlKEJ5dGVzKV0gcGx1cyB1bnNhZmUgY2FzdHMgdG8vZnJvbVxuICAgc3RyaW5nIGJ1dCB3ZXJlIGlubGluZWQgaGVyZSB0byBhdm9pZCB1c2luZyBbQnl0ZXMudW5zYWZlX29mX3N0cmluZ10gYXMgbXVjaCBhcyBwb3NzaWJsZS5cbiopXG5sZXQgc3ViIHNyYyB+cG9zIH5sZW4gPVxuICBpZiBwb3MgPSAwICYmIGxlbiA9IFN0cmluZy5sZW5ndGggc3JjXG4gIHRoZW4gc3JjXG4gIGVsc2UgKFxuICAgIE9yZGVyZWRfY29sbGVjdGlvbl9jb21tb24uY2hlY2tfcG9zX2xlbl9leG4gfnBvcyB+bGVuIH50b3RhbF9sZW5ndGg6KGxlbmd0aCBzcmMpO1xuICAgIGlmIGxlbiA9IDBcbiAgICB0aGVuIFwiXCJcbiAgICBlbHNlIChcbiAgICAgIGxldCBkc3QgPSBCeXRlcy5jcmVhdGUgbGVuIGluXG4gICAgICBCeXRlcy51bnNhZmVfYmxpdF9zdHJpbmcgfnNyYyB+c3JjX3Bvczpwb3MgfmRzdCB+ZHN0X3BvczowIH5sZW47XG4gICAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOmRzdCkpXG47O1xuXG5sZXQgc3VibyA/KHBvcyA9IDApID9sZW4gc3JjID1cbiAgc3ViXG4gICAgc3JjXG4gICAgfnBvc1xuICAgIH5sZW46XG4gICAgICAobWF0Y2ggbGVuIHdpdGhcbiAgICAgICB8IFNvbWUgaSAtPiBpXG4gICAgICAgfCBOb25lIC0+IGxlbmd0aCBzcmMgLSBwb3MpXG47O1xuXG5sZXQgcmVjIGNvbnRhaW5zX3Vuc2FmZSB0IH5wb3MgfmVuZF8gY2hhciA9XG4gIHBvcyA8IGVuZF9cbiAgJiYgKENoYXIuZXF1YWwgKHVuc2FmZV9nZXQgdCBwb3MpIGNoYXIgfHwgY29udGFpbnNfdW5zYWZlIHQgfnBvczoocG9zICsgMSkgfmVuZF8gY2hhcilcbjs7XG5cbmxldCBjb250YWlucyA/KHBvcyA9IDApID9sZW4gdCBjaGFyID1cbiAgbGV0IHRvdGFsX2xlbmd0aCA9IFN0cmluZy5sZW5ndGggdCBpblxuICBsZXQgbGVuID0gT3B0aW9uLnZhbHVlIGxlbiB+ZGVmYXVsdDoodG90YWxfbGVuZ3RoIC0gcG9zKSBpblxuICBPcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uLmNoZWNrX3Bvc19sZW5fZXhuIH5wb3MgfmxlbiB+dG90YWxfbGVuZ3RoO1xuICBjb250YWluc191bnNhZmUgdCB+cG9zIH5lbmRfOihwb3MgKyBsZW4pIGNoYXJcbjs7XG5cbmxldCBpc19lbXB0eSB0ID0gbGVuZ3RoIHQgPSAwXG5cbmxldCByZWMgaW5kZXhfZnJvbV9leG5faW50ZXJuYWwgc3RyaW5nIH5wb3MgfmxlbiB+bm90X2ZvdW5kIGNoYXIgPVxuICBpZiBwb3MgPj0gbGVuXG4gIHRoZW4gcmFpc2Ugbm90X2ZvdW5kXG4gIGVsc2UgaWYgQ2hhci5lcXVhbCAodW5zYWZlX2dldCBzdHJpbmcgcG9zKSBjaGFyXG4gIHRoZW4gcG9zXG4gIGVsc2UgaW5kZXhfZnJvbV9leG5faW50ZXJuYWwgc3RyaW5nIH5wb3M6KHBvcyArIDEpIH5sZW4gfm5vdF9mb3VuZCBjaGFyXG47O1xuXG5sZXQgaW5kZXhfZXhuX2ludGVybmFsIHQgfm5vdF9mb3VuZCBjaGFyID1cbiAgaW5kZXhfZnJvbV9leG5faW50ZXJuYWwgdCB+cG9zOjAgfmxlbjoobGVuZ3RoIHQpIH5ub3RfZm91bmQgY2hhclxuOztcblxubGV0IGluZGV4X2V4biA9XG4gIGxldCBub3RfZm91bmQgPSBOb3RfZm91bmRfcyAoQXRvbSBcIlN0cmluZy5pbmRleF9leG46IG5vdCBmb3VuZFwiKSBpblxuICBsZXQgaW5kZXhfZXhuIHQgY2hhciA9IGluZGV4X2V4bl9pbnRlcm5hbCB0IH5ub3RfZm91bmQgY2hhciBpblxuICAoKiBuYW1lZCB0byBwcmVzZXJ2ZSBzeW1ib2wgaW4gY29tcGlsZWQgYmluYXJ5ICopXG4gIGluZGV4X2V4blxuOztcblxubGV0IGluZGV4X2Zyb21fZXhuID1cbiAgbGV0IG5vdF9mb3VuZCA9IE5vdF9mb3VuZF9zIChBdG9tIFwiU3RyaW5nLmluZGV4X2Zyb21fZXhuOiBub3QgZm91bmRcIikgaW5cbiAgbGV0IGluZGV4X2Zyb21fZXhuIHQgcG9zIGNoYXIgPVxuICAgIGxldCBsZW4gPSBsZW5ndGggdCBpblxuICAgIGlmIHBvcyA8IDAgfHwgcG9zID4gbGVuXG4gICAgdGhlbiBpbnZhbGlkX2FyZyBcIlN0cmluZy5pbmRleF9mcm9tX2V4blwiXG4gICAgZWxzZSBpbmRleF9mcm9tX2V4bl9pbnRlcm5hbCB0IH5wb3MgfmxlbiB+bm90X2ZvdW5kIGNoYXJcbiAgaW5cbiAgKCogbmFtZWQgdG8gcHJlc2VydmUgc3ltYm9sIGluIGNvbXBpbGVkIGJpbmFyeSAqKVxuICBpbmRleF9mcm9tX2V4blxuOztcblxubGV0IHJlYyByaW5kZXhfZnJvbV9leG5faW50ZXJuYWwgc3RyaW5nIH5wb3MgfmxlbiB+bm90X2ZvdW5kIGNoYXIgPVxuICBpZiBwb3MgPCAwXG4gIHRoZW4gcmFpc2Ugbm90X2ZvdW5kXG4gIGVsc2UgaWYgQ2hhci5lcXVhbCAodW5zYWZlX2dldCBzdHJpbmcgcG9zKSBjaGFyXG4gIHRoZW4gcG9zXG4gIGVsc2UgcmluZGV4X2Zyb21fZXhuX2ludGVybmFsIHN0cmluZyB+cG9zOihwb3MgLSAxKSB+bGVuIH5ub3RfZm91bmQgY2hhclxuOztcblxubGV0IHJpbmRleF9leG5faW50ZXJuYWwgdCB+bm90X2ZvdW5kIGNoYXIgPVxuICBsZXQgbGVuID0gbGVuZ3RoIHQgaW5cbiAgcmluZGV4X2Zyb21fZXhuX2ludGVybmFsIHQgfnBvczoobGVuIC0gMSkgfmxlbiB+bm90X2ZvdW5kIGNoYXJcbjs7XG5cbmxldCByaW5kZXhfZXhuID1cbiAgbGV0IG5vdF9mb3VuZCA9IE5vdF9mb3VuZF9zIChBdG9tIFwiU3RyaW5nLnJpbmRleF9leG46IG5vdCBmb3VuZFwiKSBpblxuICBsZXQgcmluZGV4X2V4biB0IGNoYXIgPSByaW5kZXhfZXhuX2ludGVybmFsIHQgfm5vdF9mb3VuZCBjaGFyIGluXG4gICgqIG5hbWVkIHRvIHByZXNlcnZlIHN5bWJvbCBpbiBjb21waWxlZCBiaW5hcnkgKilcbiAgcmluZGV4X2V4blxuOztcblxubGV0IHJpbmRleF9mcm9tX2V4biA9XG4gIGxldCBub3RfZm91bmQgPSBOb3RfZm91bmRfcyAoQXRvbSBcIlN0cmluZy5yaW5kZXhfZnJvbV9leG46IG5vdCBmb3VuZFwiKSBpblxuICBsZXQgcmluZGV4X2Zyb21fZXhuIHQgcG9zIGNoYXIgPVxuICAgIGxldCBsZW4gPSBsZW5ndGggdCBpblxuICAgIGlmIHBvcyA8IC0xIHx8IHBvcyA+PSBsZW5cbiAgICB0aGVuIGludmFsaWRfYXJnIFwiU3RyaW5nLnJpbmRleF9mcm9tX2V4blwiXG4gICAgZWxzZSByaW5kZXhfZnJvbV9leG5faW50ZXJuYWwgdCB+cG9zIH5sZW4gfm5vdF9mb3VuZCBjaGFyXG4gIGluXG4gICgqIG5hbWVkIHRvIHByZXNlcnZlIHN5bWJvbCBpbiBjb21waWxlZCBiaW5hcnkgKilcbiAgcmluZGV4X2Zyb21fZXhuXG47O1xuXG5sZXQgaW5kZXggdCBjaGFyID1cbiAgdHJ5IFNvbWUgKGluZGV4X2V4biB0IGNoYXIpIHdpdGhcbiAgfCBOb3RfZm91bmRfcyBfIHwgQ2FtbC5Ob3RfZm91bmQgLT4gTm9uZVxuOztcblxubGV0IHJpbmRleCB0IGNoYXIgPVxuICB0cnkgU29tZSAocmluZGV4X2V4biB0IGNoYXIpIHdpdGhcbiAgfCBOb3RfZm91bmRfcyBfIHwgQ2FtbC5Ob3RfZm91bmQgLT4gTm9uZVxuOztcblxubGV0IGluZGV4X2Zyb20gdCBwb3MgY2hhciA9XG4gIHRyeSBTb21lIChpbmRleF9mcm9tX2V4biB0IHBvcyBjaGFyKSB3aXRoXG4gIHwgTm90X2ZvdW5kX3MgXyB8IENhbWwuTm90X2ZvdW5kIC0+IE5vbmVcbjs7XG5cbmxldCByaW5kZXhfZnJvbSB0IHBvcyBjaGFyID1cbiAgdHJ5IFNvbWUgKHJpbmRleF9mcm9tX2V4biB0IHBvcyBjaGFyKSB3aXRoXG4gIHwgTm90X2ZvdW5kX3MgXyB8IENhbWwuTm90X2ZvdW5kIC0+IE5vbmVcbjs7XG5cbm1vZHVsZSBTZWFyY2hfcGF0dGVybjAgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB7IHBhdHRlcm4gOiBzdHJpbmdcbiAgICA7IGNhc2Vfc2Vuc2l0aXZlIDogYm9vbFxuICAgIDsga21wX2FycmF5IDogaW50IGFycmF5XG4gICAgfVxuXG4gIGxldCBzZXhwX29mX3QgeyBwYXR0ZXJuOyBjYXNlX3NlbnNpdGl2ZTsga21wX2FycmF5ID0gXyB9IDogU2V4cC50ID1cbiAgICBMaXN0XG4gICAgICBbIExpc3QgWyBBdG9tIFwicGF0dGVyblwiOyBzZXhwX29mX3N0cmluZyBwYXR0ZXJuIF1cbiAgICAgIDsgTGlzdCBbIEF0b20gXCJjYXNlX3NlbnNpdGl2ZVwiOyBzZXhwX29mX2Jvb2wgY2FzZV9zZW5zaXRpdmUgXVxuICAgICAgXVxuICA7O1xuXG4gIGxldCBwYXR0ZXJuIHQgPSB0LnBhdHRlcm5cbiAgbGV0IGNhc2Vfc2Vuc2l0aXZlIHQgPSB0LmNhc2Vfc2Vuc2l0aXZlXG5cbiAgKCogRmluZCBtYXggbnVtYmVyIG9mIG1hdGNoZWQgY2hhcmFjdGVycyBhdCBbbmV4dF90ZXh0X2NoYXJdLCBnaXZlbiB0aGUgY3VycmVudFxuICAgICBbbWF0Y2hlZF9jaGFyc10uIFRyeSB0byBleHRlbmQgdGhlIGN1cnJlbnQgbWF0Y2gsIGlmIGNoYXJzIGRvbid0IG1hdGNoLCB0cnkgdG8gbWF0Y2hcbiAgICAgZmV3ZXIgY2hhcnMuIElmIGNoYXJzIG1hdGNoIHRoZW4gZXh0ZW5kIHRoZSBtYXRjaC4gKilcbiAgbGV0IGttcF9pbnRlcm5hbF9sb29wIH5tYXRjaGVkX2NoYXJzIH5uZXh0X3RleHRfY2hhciB+cGF0dGVybiB+a21wX2FycmF5IH5jaGFyX2VxdWFsID1cbiAgICBsZXQgbWF0Y2hlZF9jaGFycyA9IHJlZiBtYXRjaGVkX2NoYXJzIGluXG4gICAgd2hpbGVcbiAgICAgICFtYXRjaGVkX2NoYXJzID4gMFxuICAgICAgJiYgbm90IChjaGFyX2VxdWFsIG5leHRfdGV4dF9jaGFyICh1bnNhZmVfZ2V0IHBhdHRlcm4gIW1hdGNoZWRfY2hhcnMpKVxuICAgIGRvXG4gICAgICBtYXRjaGVkX2NoYXJzIDo9IEFycmF5LnVuc2FmZV9nZXQga21wX2FycmF5ICghbWF0Y2hlZF9jaGFycyAtIDEpXG4gICAgZG9uZTtcbiAgICBpZiBjaGFyX2VxdWFsIG5leHRfdGV4dF9jaGFyICh1bnNhZmVfZ2V0IHBhdHRlcm4gIW1hdGNoZWRfY2hhcnMpXG4gICAgdGhlbiBtYXRjaGVkX2NoYXJzIDo9ICFtYXRjaGVkX2NoYXJzICsgMTtcbiAgICAhbWF0Y2hlZF9jaGFyc1xuICA7O1xuXG4gIGxldCBnZXRfY2hhcl9lcXVhbCB+Y2FzZV9zZW5zaXRpdmUgPVxuICAgIG1hdGNoIGNhc2Vfc2Vuc2l0aXZlIHdpdGhcbiAgICB8IHRydWUgLT4gQ2hhci5lcXVhbFxuICAgIHwgZmFsc2UgLT4gQ2hhci5DYXNlbGVzcy5lcXVhbFxuICA7O1xuXG4gICgqIENsYXNzaWMgS01QIHByZS1wcm9jZXNzaW5nIG9mIHRoZSBwYXR0ZXJuOiBidWlsZCB0aGUgaW50IGFycmF5LCB3aGljaCwgZm9yIGVhY2ggaSxcbiAgICAgY29udGFpbnMgdGhlIGxlbmd0aCBvZiB0aGUgbG9uZ2VzdCBub24tdHJpdmlhbCBwcmVmaXggb2YgcyB3aGljaCBpcyBlcXVhbCB0byBhIHN1ZmZpeFxuICAgICBlbmRpbmcgYXQgcy5baV0gKilcbiAgbGV0IGNyZWF0ZSBwYXR0ZXJuIH5jYXNlX3NlbnNpdGl2ZSA9XG4gICAgbGV0IG4gPSBsZW5ndGggcGF0dGVybiBpblxuICAgIGxldCBrbXBfYXJyYXkgPSBBcnJheS5jcmVhdGUgfmxlbjpuICgtMSkgaW5cbiAgICBpZiBuID4gMFxuICAgIHRoZW4gKFxuICAgICAgbGV0IGNoYXJfZXF1YWwgPSBnZXRfY2hhcl9lcXVhbCB+Y2FzZV9zZW5zaXRpdmUgaW5cbiAgICAgIEFycmF5LnVuc2FmZV9zZXQga21wX2FycmF5IDAgMDtcbiAgICAgIGxldCBtYXRjaGVkX2NoYXJzID0gcmVmIDAgaW5cbiAgICAgIGZvciBpID0gMSB0byBuIC0gMSBkb1xuICAgICAgICBtYXRjaGVkX2NoYXJzXG4gICAgICAgIDo9IGttcF9pbnRlcm5hbF9sb29wXG4gICAgICAgICAgICAgfm1hdGNoZWRfY2hhcnM6IW1hdGNoZWRfY2hhcnNcbiAgICAgICAgICAgICB+bmV4dF90ZXh0X2NoYXI6KHVuc2FmZV9nZXQgcGF0dGVybiBpKVxuICAgICAgICAgICAgIH5wYXR0ZXJuXG4gICAgICAgICAgICAgfmttcF9hcnJheVxuICAgICAgICAgICAgIH5jaGFyX2VxdWFsO1xuICAgICAgICBBcnJheS51bnNhZmVfc2V0IGttcF9hcnJheSBpICFtYXRjaGVkX2NoYXJzXG4gICAgICBkb25lKTtcbiAgICB7IHBhdHRlcm47IGNhc2Vfc2Vuc2l0aXZlOyBrbXBfYXJyYXkgfVxuICA7O1xuXG4gICgqIENsYXNzaWMgS01QOiB1c2UgdGhlIHByZS1wcm9jZXNzZWQgcGF0dGVybiB0byBvcHRpbWl6ZSBsb29rLWJlaGluZHMgb24gbm9uLW1hdGNoZXMuXG4gICAgIFdlIHJldHVybiBpbnQgdG8gYXZvaWQgYWxsb2NhdGlvbiBpbiBbaW5kZXhfZXhuXS4gLTEgbWVhbnMgbm8gbWF0Y2guICopXG4gIGxldCBpbmRleF9pbnRlcm5hbCA/KHBvcyA9IDApIHsgcGF0dGVybjsgY2FzZV9zZW5zaXRpdmU7IGttcF9hcnJheSB9IH5pbl86dGV4dCA9XG4gICAgaWYgcG9zIDwgMCB8fCBwb3MgPiBsZW5ndGggdGV4dCAtIGxlbmd0aCBwYXR0ZXJuXG4gICAgdGhlbiAtMVxuICAgIGVsc2UgKFxuICAgICAgbGV0IGNoYXJfZXF1YWwgPSBnZXRfY2hhcl9lcXVhbCB+Y2FzZV9zZW5zaXRpdmUgaW5cbiAgICAgIGxldCBqID0gcmVmIHBvcyBpblxuICAgICAgbGV0IG1hdGNoZWRfY2hhcnMgPSByZWYgMCBpblxuICAgICAgbGV0IGsgPSBsZW5ndGggcGF0dGVybiBpblxuICAgICAgbGV0IG4gPSBsZW5ndGggdGV4dCBpblxuICAgICAgd2hpbGUgIWogPCBuICYmICFtYXRjaGVkX2NoYXJzIDwgayBkb1xuICAgICAgICBsZXQgbmV4dF90ZXh0X2NoYXIgPSB1bnNhZmVfZ2V0IHRleHQgIWogaW5cbiAgICAgICAgbWF0Y2hlZF9jaGFyc1xuICAgICAgICA6PSBrbXBfaW50ZXJuYWxfbG9vcFxuICAgICAgICAgICAgIH5tYXRjaGVkX2NoYXJzOiFtYXRjaGVkX2NoYXJzXG4gICAgICAgICAgICAgfm5leHRfdGV4dF9jaGFyXG4gICAgICAgICAgICAgfnBhdHRlcm5cbiAgICAgICAgICAgICB+a21wX2FycmF5XG4gICAgICAgICAgICAgfmNoYXJfZXF1YWw7XG4gICAgICAgIGogOj0gIWogKyAxXG4gICAgICBkb25lO1xuICAgICAgaWYgIW1hdGNoZWRfY2hhcnMgPSBrIHRoZW4gIWogLSBrIGVsc2UgLTEpXG4gIDs7XG5cbiAgbGV0IG1hdGNoZXMgdCBzdHIgPSBpbmRleF9pbnRlcm5hbCB0IH5pbl86c3RyID49IDBcblxuICBsZXQgaW5kZXggP3BvcyB0IH5pbl8gPVxuICAgIGxldCBwID0gaW5kZXhfaW50ZXJuYWwgP3BvcyB0IH5pbl8gaW5cbiAgICBpZiBwIDwgMCB0aGVuIE5vbmUgZWxzZSBTb21lIHBcbiAgOztcblxuICBsZXQgaW5kZXhfZXhuID9wb3MgdCB+aW5fID1cbiAgICBsZXQgcCA9IGluZGV4X2ludGVybmFsID9wb3MgdCB+aW5fIGluXG4gICAgaWYgcCA+PSAwXG4gICAgdGhlbiBwXG4gICAgZWxzZVxuICAgICAgcmFpc2Vfc1xuICAgICAgICAoU2V4cC5tZXNzYWdlIFwiU3Vic3RyaW5nIG5vdCBmb3VuZFwiIFsgXCJzdWJzdHJpbmdcIiwgc2V4cF9vZl9zdHJpbmcgdC5wYXR0ZXJuIF0pXG4gIDs7XG5cbiAgbGV0IGluZGV4X2FsbCB7IHBhdHRlcm47IGNhc2Vfc2Vuc2l0aXZlOyBrbXBfYXJyYXkgfSB+bWF5X292ZXJsYXAgfmluXzp0ZXh0ID1cbiAgICBpZiBsZW5ndGggcGF0dGVybiA9IDBcbiAgICB0aGVuIExpc3QuaW5pdCAoMSArIGxlbmd0aCB0ZXh0KSB+ZjpGbi5pZFxuICAgIGVsc2UgKFxuICAgICAgbGV0IGNoYXJfZXF1YWwgPSBnZXRfY2hhcl9lcXVhbCB+Y2FzZV9zZW5zaXRpdmUgaW5cbiAgICAgIGxldCBtYXRjaGVkX2NoYXJzID0gcmVmIDAgaW5cbiAgICAgIGxldCBrID0gbGVuZ3RoIHBhdHRlcm4gaW5cbiAgICAgIGxldCBuID0gbGVuZ3RoIHRleHQgaW5cbiAgICAgIGxldCBmb3VuZCA9IHJlZiBbXSBpblxuICAgICAgZm9yIGogPSAwIHRvIG4gZG9cbiAgICAgICAgaWYgIW1hdGNoZWRfY2hhcnMgPSBrXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIGZvdW5kIDo9IChqIC0gaykgOjogIWZvdW5kO1xuICAgICAgICAgICgqIHdlIGp1c3QgZm91bmQgYSBtYXRjaCBpbiB0aGUgcHJldmlvdXMgaXRlcmF0aW9uICopXG4gICAgICAgICAgbWF0Y2ggbWF5X292ZXJsYXAgd2l0aFxuICAgICAgICAgIHwgdHJ1ZSAtPiBtYXRjaGVkX2NoYXJzIDo9IEFycmF5LnVuc2FmZV9nZXQga21wX2FycmF5IChrIC0gMSlcbiAgICAgICAgICB8IGZhbHNlIC0+IG1hdGNoZWRfY2hhcnMgOj0gMCk7XG4gICAgICAgIGlmIGogPCBuXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIGxldCBuZXh0X3RleHRfY2hhciA9IHVuc2FmZV9nZXQgdGV4dCBqIGluXG4gICAgICAgICAgbWF0Y2hlZF9jaGFyc1xuICAgICAgICAgIDo9IGttcF9pbnRlcm5hbF9sb29wXG4gICAgICAgICAgICAgICB+bWF0Y2hlZF9jaGFyczohbWF0Y2hlZF9jaGFyc1xuICAgICAgICAgICAgICAgfm5leHRfdGV4dF9jaGFyXG4gICAgICAgICAgICAgICB+cGF0dGVyblxuICAgICAgICAgICAgICAgfmttcF9hcnJheVxuICAgICAgICAgICAgICAgfmNoYXJfZXF1YWwpXG4gICAgICBkb25lO1xuICAgICAgTGlzdC5yZXYgIWZvdW5kKVxuICA7O1xuXG4gIGxldCByZXBsYWNlX2ZpcnN0ID9wb3MgdCB+aW5fOnMgfndpdGhfID1cbiAgICBtYXRjaCBpbmRleCA/cG9zIHQgfmluXzpzIHdpdGhcbiAgICB8IE5vbmUgLT4gc1xuICAgIHwgU29tZSBpIC0+XG4gICAgICBsZXQgbGVuX3MgPSBsZW5ndGggcyBpblxuICAgICAgbGV0IGxlbl90ID0gbGVuZ3RoIHQucGF0dGVybiBpblxuICAgICAgbGV0IGxlbl93aXRoID0gbGVuZ3RoIHdpdGhfIGluXG4gICAgICBsZXQgZHN0ID0gQnl0ZXMuY3JlYXRlIChsZW5fcyArIGxlbl93aXRoIC0gbGVuX3QpIGluXG4gICAgICBCeXRlcy5ibGl0X3N0cmluZyB+c3JjOnMgfnNyY19wb3M6MCB+ZHN0IH5kc3RfcG9zOjAgfmxlbjppO1xuICAgICAgQnl0ZXMuYmxpdF9zdHJpbmcgfnNyYzp3aXRoXyB+c3JjX3BvczowIH5kc3QgfmRzdF9wb3M6aSB+bGVuOmxlbl93aXRoO1xuICAgICAgQnl0ZXMuYmxpdF9zdHJpbmdcbiAgICAgICAgfnNyYzpzXG4gICAgICAgIH5zcmNfcG9zOihpICsgbGVuX3QpXG4gICAgICAgIH5kc3RcbiAgICAgICAgfmRzdF9wb3M6KGkgKyBsZW5fd2l0aClcbiAgICAgICAgfmxlbjoobGVuX3MgLSBpIC0gbGVuX3QpO1xuICAgICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTpkc3RcbiAgOztcblxuXG4gIGxldCByZXBsYWNlX2FsbCB0IH5pbl86cyB+d2l0aF8gPVxuICAgIGxldCBtYXRjaGVzID0gaW5kZXhfYWxsIHQgfm1heV9vdmVybGFwOmZhbHNlIH5pbl86cyBpblxuICAgIG1hdGNoIG1hdGNoZXMgd2l0aFxuICAgIHwgW10gLT4gc1xuICAgIHwgXyA6OiBfIC0+XG4gICAgICBsZXQgbGVuX3MgPSBsZW5ndGggcyBpblxuICAgICAgbGV0IGxlbl90ID0gbGVuZ3RoIHQucGF0dGVybiBpblxuICAgICAgbGV0IGxlbl93aXRoID0gbGVuZ3RoIHdpdGhfIGluXG4gICAgICBsZXQgbnVtX21hdGNoZXMgPSBMaXN0Lmxlbmd0aCBtYXRjaGVzIGluXG4gICAgICBsZXQgZHN0ID0gQnl0ZXMuY3JlYXRlIChsZW5fcyArICgobGVuX3dpdGggLSBsZW5fdCkgKiBudW1fbWF0Y2hlcykpIGluXG4gICAgICBsZXQgbmV4dF9kc3RfcG9zID0gcmVmIDAgaW5cbiAgICAgIGxldCBuZXh0X3NyY19wb3MgPSByZWYgMCBpblxuICAgICAgTGlzdC5pdGVyIG1hdGNoZXMgfmY6KGZ1biBpIC0+XG4gICAgICAgIGxldCBsZW4gPSBpIC0gIW5leHRfc3JjX3BvcyBpblxuICAgICAgICBCeXRlcy5ibGl0X3N0cmluZyB+c3JjOnMgfnNyY19wb3M6IW5leHRfc3JjX3BvcyB+ZHN0IH5kc3RfcG9zOiFuZXh0X2RzdF9wb3MgfmxlbjtcbiAgICAgICAgQnl0ZXMuYmxpdF9zdHJpbmdcbiAgICAgICAgICB+c3JjOndpdGhfXG4gICAgICAgICAgfnNyY19wb3M6MFxuICAgICAgICAgIH5kc3RcbiAgICAgICAgICB+ZHN0X3BvczooIW5leHRfZHN0X3BvcyArIGxlbilcbiAgICAgICAgICB+bGVuOmxlbl93aXRoO1xuICAgICAgICBuZXh0X2RzdF9wb3MgOj0gIW5leHRfZHN0X3BvcyArIGxlbiArIGxlbl93aXRoO1xuICAgICAgICBuZXh0X3NyY19wb3MgOj0gIW5leHRfc3JjX3BvcyArIGxlbiArIGxlbl90KTtcbiAgICAgIEJ5dGVzLmJsaXRfc3RyaW5nXG4gICAgICAgIH5zcmM6c1xuICAgICAgICB+c3JjX3BvczohbmV4dF9zcmNfcG9zXG4gICAgICAgIH5kc3RcbiAgICAgICAgfmRzdF9wb3M6IW5leHRfZHN0X3Bvc1xuICAgICAgICB+bGVuOihsZW5fcyAtICFuZXh0X3NyY19wb3MpO1xuICAgICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTpkc3RcbiAgOztcblxuICBsZXQgc3BsaXRfb24gdCBzID1cbiAgICBsZXQgcGF0dGVybl9sZW4gPSBTdHJpbmcubGVuZ3RoIHQucGF0dGVybiBpblxuICAgIGxldCBtYXRjaGVzID0gaW5kZXhfYWxsIHQgfm1heV9vdmVybGFwOmZhbHNlIH5pbl86cyBpblxuICAgIExpc3QubWFwMl9leG5cbiAgICAgICgtcGF0dGVybl9sZW4gOjogbWF0Y2hlcylcbiAgICAgIChtYXRjaGVzIEAgWyBTdHJpbmcubGVuZ3RoIHMgXSlcbiAgICAgIH5mOihmdW4gaSBqIC0+IHN1YiBzIH5wb3M6KGkgKyBwYXR0ZXJuX2xlbikgfmxlbjooaiAtIGkgLSBwYXR0ZXJuX2xlbikpXG4gIDs7XG5cbiAgbW9kdWxlIFByaXZhdGUgPSBzdHJ1Y3RcbiAgICB0eXBlIHB1YmxpYyA9IHRcblxuICAgIHR5cGUgbm9ucmVjIHQgPSB0ID1cbiAgICAgIHsgcGF0dGVybiA6IHN0cmluZ1xuICAgICAgOyBjYXNlX3NlbnNpdGl2ZSA6IGJvb2xcbiAgICAgIDsga21wX2FycmF5IDogaW50IGFycmF5XG4gICAgICB9XG4gICAgW0BAZGVyaXZpbmdfaW5saW5lIGVxdWFsLCBzZXhwX29mXVxuXG4gICAgbGV0IGVxdWFsID1cbiAgICAgIChmdW4gYV9fMDAyXyBiX18wMDNfIC0+XG4gICAgICAgICBpZiBQcHhfY29tcGFyZV9saWIucGh5c19lcXVhbCBhX18wMDJfIGJfXzAwM19cbiAgICAgICAgIHRoZW4gdHJ1ZVxuICAgICAgICAgZWxzZVxuICAgICAgICAgICBQcHhfY29tcGFyZV9saWIuKCAmJiApXG4gICAgICAgICAgICAgKGVxdWFsX3N0cmluZyBhX18wMDJfLnBhdHRlcm4gYl9fMDAzXy5wYXR0ZXJuKVxuICAgICAgICAgICAgIChQcHhfY29tcGFyZV9saWIuKCAmJiApXG4gICAgICAgICAgICAgICAgKGVxdWFsX2Jvb2wgYV9fMDAyXy5jYXNlX3NlbnNpdGl2ZSBiX18wMDNfLmNhc2Vfc2Vuc2l0aXZlKVxuICAgICAgICAgICAgICAgIChlcXVhbF9hcnJheSBlcXVhbF9pbnQgYV9fMDAyXy5rbXBfYXJyYXkgYl9fMDAzXy5rbXBfYXJyYXkpKVxuICAgICAgICAgICA6IHQgLT4gdCAtPiBib29sKVxuICAgIDs7XG5cbiAgICBsZXQgc2V4cF9vZl90ID1cbiAgICAgIChmdW4geyBwYXR0ZXJuID0gcGF0dGVybl9fMDA3X1xuICAgICAgICAgICA7IGNhc2Vfc2Vuc2l0aXZlID0gY2FzZV9zZW5zaXRpdmVfXzAwOV9cbiAgICAgICAgICAgOyBrbXBfYXJyYXkgPSBrbXBfYXJyYXlfXzAxMV9cbiAgICAgICAgICAgfSAtPlxuICAgICAgICBsZXQgYm5kc19fMDA2XyA9IFtdIGluXG4gICAgICAgIGxldCBibmRzX18wMDZfID1cbiAgICAgICAgICBsZXQgYXJnX18wMTJfID0gc2V4cF9vZl9hcnJheSBzZXhwX29mX2ludCBrbXBfYXJyYXlfXzAxMV8gaW5cbiAgICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJrbXBfYXJyYXlcIjsgYXJnX18wMTJfIF0gOjogYm5kc19fMDA2X1xuICAgICAgICBpblxuICAgICAgICBsZXQgYm5kc19fMDA2XyA9XG4gICAgICAgICAgbGV0IGFyZ19fMDEwXyA9IHNleHBfb2ZfYm9vbCBjYXNlX3NlbnNpdGl2ZV9fMDA5XyBpblxuICAgICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcImNhc2Vfc2Vuc2l0aXZlXCI7IGFyZ19fMDEwXyBdXG4gICAgICAgICAgOjogYm5kc19fMDA2X1xuICAgICAgICBpblxuICAgICAgICBsZXQgYm5kc19fMDA2XyA9XG4gICAgICAgICAgbGV0IGFyZ19fMDA4XyA9IHNleHBfb2Zfc3RyaW5nIHBhdHRlcm5fXzAwN18gaW5cbiAgICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJwYXR0ZXJuXCI7IGFyZ19fMDA4XyBdIDo6IGJuZHNfXzAwNl9cbiAgICAgICAgaW5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IGJuZHNfXzAwNl9cbiAgICAgICAgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgICA7O1xuXG4gICAgW0BAQGVuZF1cblxuICAgIGxldCByZXByZXNlbnRhdGlvbiA9IEZuLmlkXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBTZWFyY2hfcGF0dGVybl9oZWxwZXIgPSBzdHJ1Y3RcbiAgbW9kdWxlIFNlYXJjaF9wYXR0ZXJuID0gU2VhcmNoX3BhdHRlcm4wXG5lbmRcblxub3BlbiBTZWFyY2hfcGF0dGVybl9oZWxwZXJcblxubGV0IHN1YnN0cl9pbmRleF9nZW4gfmNhc2Vfc2Vuc2l0aXZlID9wb3MgdCB+cGF0dGVybiA9XG4gIFNlYXJjaF9wYXR0ZXJuLmluZGV4ID9wb3MgKFNlYXJjaF9wYXR0ZXJuLmNyZWF0ZSB+Y2FzZV9zZW5zaXRpdmUgcGF0dGVybikgfmluXzp0XG47O1xuXG5sZXQgc3Vic3RyX2luZGV4X2V4bl9nZW4gfmNhc2Vfc2Vuc2l0aXZlID9wb3MgdCB+cGF0dGVybiA9XG4gIFNlYXJjaF9wYXR0ZXJuLmluZGV4X2V4biA/cG9zIChTZWFyY2hfcGF0dGVybi5jcmVhdGUgfmNhc2Vfc2Vuc2l0aXZlIHBhdHRlcm4pIH5pbl86dFxuOztcblxubGV0IHN1YnN0cl9pbmRleF9hbGxfZ2VuIH5jYXNlX3NlbnNpdGl2ZSB0IH5tYXlfb3ZlcmxhcCB+cGF0dGVybiA9XG4gIFNlYXJjaF9wYXR0ZXJuLmluZGV4X2FsbFxuICAgIChTZWFyY2hfcGF0dGVybi5jcmVhdGUgfmNhc2Vfc2Vuc2l0aXZlIHBhdHRlcm4pXG4gICAgfm1heV9vdmVybGFwXG4gICAgfmluXzp0XG47O1xuXG5sZXQgc3Vic3RyX3JlcGxhY2VfZmlyc3RfZ2VuIH5jYXNlX3NlbnNpdGl2ZSA/cG9zIHQgfnBhdHRlcm4gPVxuICBTZWFyY2hfcGF0dGVybi5yZXBsYWNlX2ZpcnN0ID9wb3MgKFNlYXJjaF9wYXR0ZXJuLmNyZWF0ZSB+Y2FzZV9zZW5zaXRpdmUgcGF0dGVybikgfmluXzp0XG47O1xuXG5sZXQgc3Vic3RyX3JlcGxhY2VfYWxsX2dlbiB+Y2FzZV9zZW5zaXRpdmUgdCB+cGF0dGVybiA9XG4gIFNlYXJjaF9wYXR0ZXJuLnJlcGxhY2VfYWxsIChTZWFyY2hfcGF0dGVybi5jcmVhdGUgfmNhc2Vfc2Vuc2l0aXZlIHBhdHRlcm4pIH5pbl86dFxuOztcblxubGV0IGlzX3N1YnN0cmluZ19nZW4gfmNhc2Vfc2Vuc2l0aXZlIHQgfnN1YnN0cmluZyA9XG4gIE9wdGlvbi5pc19zb21lIChzdWJzdHJfaW5kZXhfZ2VuIHQgfnBhdHRlcm46c3Vic3RyaW5nIH5jYXNlX3NlbnNpdGl2ZSlcbjs7XG5cbmxldCBzdWJzdHJfaW5kZXggPSBzdWJzdHJfaW5kZXhfZ2VuIH5jYXNlX3NlbnNpdGl2ZTp0cnVlXG5sZXQgc3Vic3RyX2luZGV4X2V4biA9IHN1YnN0cl9pbmRleF9leG5fZ2VuIH5jYXNlX3NlbnNpdGl2ZTp0cnVlXG5sZXQgc3Vic3RyX2luZGV4X2FsbCA9IHN1YnN0cl9pbmRleF9hbGxfZ2VuIH5jYXNlX3NlbnNpdGl2ZTp0cnVlXG5sZXQgc3Vic3RyX3JlcGxhY2VfZmlyc3QgPSBzdWJzdHJfcmVwbGFjZV9maXJzdF9nZW4gfmNhc2Vfc2Vuc2l0aXZlOnRydWVcbmxldCBzdWJzdHJfcmVwbGFjZV9hbGwgPSBzdWJzdHJfcmVwbGFjZV9hbGxfZ2VuIH5jYXNlX3NlbnNpdGl2ZTp0cnVlXG5sZXQgaXNfc3Vic3RyaW5nID0gaXNfc3Vic3RyaW5nX2dlbiB+Y2FzZV9zZW5zaXRpdmU6dHJ1ZVxuXG5sZXQgaXNfc3Vic3RyaW5nX2F0X2dlbiA9XG4gIGxldCByZWMgbG9vcCB+c3RyIH5zdHJfcG9zIH5zdWIgfnN1Yl9wb3MgfnN1Yl9sZW4gfmNoYXJfZXF1YWwgPVxuICAgIGlmIHN1Yl9wb3MgPSBzdWJfbGVuXG4gICAgdGhlbiB0cnVlXG4gICAgZWxzZSBpZiBjaGFyX2VxdWFsICh1bnNhZmVfZ2V0IHN0ciBzdHJfcG9zKSAodW5zYWZlX2dldCBzdWIgc3ViX3BvcylcbiAgICB0aGVuIGxvb3AgfnN0ciB+c3RyX3Bvczooc3RyX3BvcyArIDEpIH5zdWIgfnN1Yl9wb3M6KHN1Yl9wb3MgKyAxKSB+c3ViX2xlbiB+Y2hhcl9lcXVhbFxuICAgIGVsc2UgZmFsc2VcbiAgaW5cbiAgZnVuIHN0ciB+cG9zOnN0cl9wb3MgfnN1YnN0cmluZzpzdWIgfmNoYXJfZXF1YWwgLT5cbiAgICBsZXQgc3RyX2xlbiA9IGxlbmd0aCBzdHIgaW5cbiAgICBsZXQgc3ViX2xlbiA9IGxlbmd0aCBzdWIgaW5cbiAgICBpZiBzdHJfcG9zIDwgMCB8fCBzdHJfcG9zID4gc3RyX2xlblxuICAgIHRoZW5cbiAgICAgIGludmFsaWRfYXJnZlxuICAgICAgICBcIlN0cmluZy5pc19zdWJzdHJpbmdfYXQ6IGludmFsaWQgaW5kZXggJWQgZm9yIHN0cmluZyBvZiBsZW5ndGggJWRcIlxuICAgICAgICBzdHJfcG9zXG4gICAgICAgIHN0cl9sZW5cbiAgICAgICAgKCk7XG4gICAgc3RyX3BvcyArIHN1Yl9sZW4gPD0gc3RyX2xlblxuICAgICYmIGxvb3AgfnN0ciB+c3RyX3BvcyB+c3ViIH5zdWJfcG9zOjAgfnN1Yl9sZW4gfmNoYXJfZXF1YWxcbjs7XG5cbmxldCBpc19zdWZmaXhfZ2VuIHN0cmluZyB+c3VmZml4IH5jaGFyX2VxdWFsID1cbiAgbGV0IHN0cmluZ19sZW4gPSBsZW5ndGggc3RyaW5nIGluXG4gIGxldCBzdWZmaXhfbGVuID0gbGVuZ3RoIHN1ZmZpeCBpblxuICBzdHJpbmdfbGVuID49IHN1ZmZpeF9sZW5cbiAgJiYgaXNfc3Vic3RyaW5nX2F0X2dlblxuICAgICAgIHN0cmluZ1xuICAgICAgIH5wb3M6KHN0cmluZ19sZW4gLSBzdWZmaXhfbGVuKVxuICAgICAgIH5zdWJzdHJpbmc6c3VmZml4XG4gICAgICAgfmNoYXJfZXF1YWxcbjs7XG5cbmxldCBpc19wcmVmaXhfZ2VuIHN0cmluZyB+cHJlZml4IH5jaGFyX2VxdWFsID1cbiAgbGV0IHN0cmluZ19sZW4gPSBsZW5ndGggc3RyaW5nIGluXG4gIGxldCBwcmVmaXhfbGVuID0gbGVuZ3RoIHByZWZpeCBpblxuICBzdHJpbmdfbGVuID49IHByZWZpeF9sZW5cbiAgJiYgaXNfc3Vic3RyaW5nX2F0X2dlbiBzdHJpbmcgfnBvczowIH5zdWJzdHJpbmc6cHJlZml4IH5jaGFyX2VxdWFsXG47O1xuXG5tb2R1bGUgQ2FzZWxlc3MgPSBzdHJ1Y3RcbiAgbW9kdWxlIFQgPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPSBzdHJpbmcgW0BAZGVyaXZpbmdfaW5saW5lIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICAgIGxldCB0X29mX3NleHAgPSAoc3RyaW5nX29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdClcbiAgICBsZXQgc2V4cF9vZl90ID0gKHNleHBfb2Zfc3RyaW5nIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgbGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gc3RyaW5nX3NleHBfZ3JhbW1hclxuXG4gICAgW0BAQGVuZF1cblxuICAgIGxldCBjaGFyX2NvbXBhcmVfY2FzZWxlc3MgYzEgYzIgPSBDaGFyLmNvbXBhcmUgKENoYXIubG93ZXJjYXNlIGMxKSAoQ2hhci5sb3dlcmNhc2UgYzIpXG5cbiAgICBsZXQgcmVjIGNvbXBhcmVfbG9vcCB+cG9zIH5zdHJpbmcxIH5sZW4xIH5zdHJpbmcyIH5sZW4yID1cbiAgICAgIGlmIHBvcyA9IGxlbjFcbiAgICAgIHRoZW4gaWYgcG9zID0gbGVuMiB0aGVuIDAgZWxzZSAtMVxuICAgICAgZWxzZSBpZiBwb3MgPSBsZW4yXG4gICAgICB0aGVuIDFcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgYyA9IGNoYXJfY29tcGFyZV9jYXNlbGVzcyAodW5zYWZlX2dldCBzdHJpbmcxIHBvcykgKHVuc2FmZV9nZXQgc3RyaW5nMiBwb3MpIGluXG4gICAgICAgIG1hdGNoIGMgd2l0aFxuICAgICAgICB8IDAgLT4gY29tcGFyZV9sb29wIH5wb3M6KHBvcyArIDEpIH5zdHJpbmcxIH5sZW4xIH5zdHJpbmcyIH5sZW4yXG4gICAgICAgIHwgXyAtPiBjKVxuICAgIDs7XG5cbiAgICBsZXQgY29tcGFyZSBzdHJpbmcxIHN0cmluZzIgPVxuICAgICAgaWYgcGh5c19lcXVhbCBzdHJpbmcxIHN0cmluZzJcbiAgICAgIHRoZW4gMFxuICAgICAgZWxzZVxuICAgICAgICBjb21wYXJlX2xvb3BcbiAgICAgICAgICB+cG9zOjBcbiAgICAgICAgICB+c3RyaW5nMVxuICAgICAgICAgIH5sZW4xOihTdHJpbmcubGVuZ3RoIHN0cmluZzEpXG4gICAgICAgICAgfnN0cmluZzJcbiAgICAgICAgICB+bGVuMjooU3RyaW5nLmxlbmd0aCBzdHJpbmcyKVxuICAgIDs7XG5cbiAgICBsZXQgaGFzaF9mb2xkX3Qgc3RhdGUgdCA9XG4gICAgICBsZXQgbGVuID0gbGVuZ3RoIHQgaW5cbiAgICAgIGxldCBzdGF0ZSA9IHJlZiAoaGFzaF9mb2xkX2ludCBzdGF0ZSBsZW4pIGluXG4gICAgICBmb3IgcG9zID0gMCB0byBsZW4gLSAxIGRvXG4gICAgICAgIHN0YXRlIDo9IGhhc2hfZm9sZF9jaGFyICFzdGF0ZSAoQ2hhci5sb3dlcmNhc2UgKHVuc2FmZV9nZXQgdCBwb3MpKVxuICAgICAgZG9uZTtcbiAgICAgICFzdGF0ZVxuICAgIDs7XG5cbiAgICBsZXQgaGFzaCB0ID0gSGFzaC5ydW4gaGFzaF9mb2xkX3QgdFxuICAgIGxldCBpc19zdWZmaXggcyB+c3VmZml4ID0gaXNfc3VmZml4X2dlbiBzIH5zdWZmaXggfmNoYXJfZXF1YWw6Q2hhci5DYXNlbGVzcy5lcXVhbFxuICAgIGxldCBpc19wcmVmaXggcyB+cHJlZml4ID0gaXNfcHJlZml4X2dlbiBzIH5wcmVmaXggfmNoYXJfZXF1YWw6Q2hhci5DYXNlbGVzcy5lcXVhbFxuICAgIGxldCBzdWJzdHJfaW5kZXggPSBzdWJzdHJfaW5kZXhfZ2VuIH5jYXNlX3NlbnNpdGl2ZTpmYWxzZVxuICAgIGxldCBzdWJzdHJfaW5kZXhfZXhuID0gc3Vic3RyX2luZGV4X2V4bl9nZW4gfmNhc2Vfc2Vuc2l0aXZlOmZhbHNlXG4gICAgbGV0IHN1YnN0cl9pbmRleF9hbGwgPSBzdWJzdHJfaW5kZXhfYWxsX2dlbiB+Y2FzZV9zZW5zaXRpdmU6ZmFsc2VcbiAgICBsZXQgc3Vic3RyX3JlcGxhY2VfZmlyc3QgPSBzdWJzdHJfcmVwbGFjZV9maXJzdF9nZW4gfmNhc2Vfc2Vuc2l0aXZlOmZhbHNlXG4gICAgbGV0IHN1YnN0cl9yZXBsYWNlX2FsbCA9IHN1YnN0cl9yZXBsYWNlX2FsbF9nZW4gfmNhc2Vfc2Vuc2l0aXZlOmZhbHNlXG4gICAgbGV0IGlzX3N1YnN0cmluZyA9IGlzX3N1YnN0cmluZ19nZW4gfmNhc2Vfc2Vuc2l0aXZlOmZhbHNlXG4gICAgbGV0IGlzX3N1YnN0cmluZ19hdCA9IGlzX3N1YnN0cmluZ19hdF9nZW4gfmNoYXJfZXF1YWw6Q2hhci5DYXNlbGVzcy5lcXVhbFxuICBlbmRcblxuICBpbmNsdWRlIFRcbiAgaW5jbHVkZSBDb21wYXJhYmxlLk1ha2UgKFQpXG5lbmRcblxubGV0IG9mX3N0cmluZyA9IEZuLmlkXG5sZXQgdG9fc3RyaW5nID0gRm4uaWRcblxubGV0IGluaXQgbiB+ZiA9XG4gIGlmIG4gPCAwIHRoZW4gaW52YWxpZF9hcmdmIFwiU3RyaW5nLmluaXQgJWRcIiBuICgpO1xuICBsZXQgdCA9IEJ5dGVzLmNyZWF0ZSBuIGluXG4gIGZvciBpID0gMCB0byBuIC0gMSBkb1xuICAgIEJ5dGVzLnNldCB0IGkgKGYgaSlcbiAgZG9uZTtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTp0XG47O1xuXG5sZXQgdG9fbGlzdCBzID1cbiAgbGV0IHJlYyBsb29wIGFjYyBpID0gaWYgaSA8IDAgdGhlbiBhY2MgZWxzZSBsb29wIChzLltpXSA6OiBhY2MpIChpIC0gMSkgaW5cbiAgbG9vcCBbXSAobGVuZ3RoIHMgLSAxKVxuOztcblxubGV0IHRvX2xpc3RfcmV2IHMgPVxuICBsZXQgbGVuID0gbGVuZ3RoIHMgaW5cbiAgbGV0IHJlYyBsb29wIGFjYyBpID0gaWYgaSA9IGxlbiB0aGVuIGFjYyBlbHNlIGxvb3AgKHMuW2ldIDo6IGFjYykgKGkgKyAxKSBpblxuICBsb29wIFtdIDBcbjs7XG5cbmxldCByZXYgdCA9XG4gIGxldCBsZW4gPSBsZW5ndGggdCBpblxuICBsZXQgcmVzID0gQnl0ZXMuY3JlYXRlIGxlbiBpblxuICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgIHVuc2FmZV9zZXQgcmVzIGkgKHVuc2FmZV9nZXQgdCAobGVuIC0gMSAtIGkpKVxuICBkb25lO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOnJlc1xuOztcblxuKCoqIEVmZmljaWVudCBzdHJpbmcgc3BsaXR0aW5nICopXG5cbmxldCBsc3BsaXQyX2V4biA9XG4gIGxldCBub3RfZm91bmQgPSBOb3RfZm91bmRfcyAoQXRvbSBcIlN0cmluZy5sc3BsaXQyX2V4bjogbm90IGZvdW5kXCIpIGluXG4gIGxldCBsc3BsaXQyX2V4biBsaW5lIH5vbjpkZWxpbSA9XG4gICAgbGV0IHBvcyA9IGluZGV4X2V4bl9pbnRlcm5hbCBsaW5lIH5ub3RfZm91bmQgZGVsaW0gaW5cbiAgICBzdWIgbGluZSB+cG9zOjAgfmxlbjpwb3MsIHN1YiBsaW5lIH5wb3M6KHBvcyArIDEpIH5sZW46KGxlbmd0aCBsaW5lIC0gcG9zIC0gMSlcbiAgaW5cbiAgKCogbmFtZWQgdG8gcHJlc2VydmUgc3ltYm9sIGluIGNvbXBpbGVkIGJpbmFyeSAqKVxuICBsc3BsaXQyX2V4blxuOztcblxubGV0IHJzcGxpdDJfZXhuID1cbiAgbGV0IG5vdF9mb3VuZCA9IE5vdF9mb3VuZF9zIChBdG9tIFwiU3RyaW5nLnJzcGxpdDJfZXhuOiBub3QgZm91bmRcIikgaW5cbiAgbGV0IHJzcGxpdDJfZXhuIGxpbmUgfm9uOmRlbGltID1cbiAgICBsZXQgcG9zID0gcmluZGV4X2V4bl9pbnRlcm5hbCBsaW5lIH5ub3RfZm91bmQgZGVsaW0gaW5cbiAgICBzdWIgbGluZSB+cG9zOjAgfmxlbjpwb3MsIHN1YiBsaW5lIH5wb3M6KHBvcyArIDEpIH5sZW46KGxlbmd0aCBsaW5lIC0gcG9zIC0gMSlcbiAgaW5cbiAgKCogbmFtZWQgdG8gcHJlc2VydmUgc3ltYm9sIGluIGNvbXBpbGVkIGJpbmFyeSAqKVxuICByc3BsaXQyX2V4blxuOztcblxubGV0IGxzcGxpdDIgbGluZSB+b24gPVxuICB0cnkgU29tZSAobHNwbGl0Ml9leG4gbGluZSB+b24pIHdpdGhcbiAgfCBOb3RfZm91bmRfcyBfIHwgQ2FtbC5Ob3RfZm91bmQgLT4gTm9uZVxuOztcblxubGV0IHJzcGxpdDIgbGluZSB+b24gPVxuICB0cnkgU29tZSAocnNwbGl0Ml9leG4gbGluZSB+b24pIHdpdGhcbiAgfCBOb3RfZm91bmRfcyBfIHwgQ2FtbC5Ob3RfZm91bmQgLT4gTm9uZVxuOztcblxubGV0IHJlYyBjaGFyX2xpc3RfbWVtIGwgKGMgOiBjaGFyKSA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+IGZhbHNlXG4gIHwgaGQgOjogdGwgLT4gQ2hhci5lcXVhbCBoZCBjIHx8IGNoYXJfbGlzdF9tZW0gdGwgY1xuOztcblxubGV0IHNwbGl0X2dlbiBzdHIgfm9uID1cbiAgbGV0IGlzX2RlbGltID1cbiAgICBtYXRjaCBvbiB3aXRoXG4gICAgfCBgY2hhciBjJyAtPiBmdW4gYyAtPiBDaGFyLmVxdWFsIGMgYydcbiAgICB8IGBjaGFyX2xpc3QgbCAtPiBmdW4gYyAtPiBjaGFyX2xpc3RfbWVtIGwgY1xuICBpblxuICBsZXQgbGVuID0gbGVuZ3RoIHN0ciBpblxuICBsZXQgcmVjIGxvb3AgYWNjIGxhc3RfcG9zIHBvcyA9XG4gICAgaWYgcG9zID0gLTFcbiAgICB0aGVuIHN1YiBzdHIgfnBvczowIH5sZW46bGFzdF9wb3MgOjogYWNjXG4gICAgZWxzZSBpZiBpc19kZWxpbSBzdHIuW3Bvc11cbiAgICB0aGVuIChcbiAgICAgIGxldCBwb3MxID0gcG9zICsgMSBpblxuICAgICAgbGV0IHN1Yl9zdHIgPSBzdWIgc3RyIH5wb3M6cG9zMSB+bGVuOihsYXN0X3BvcyAtIHBvczEpIGluXG4gICAgICBsb29wIChzdWJfc3RyIDo6IGFjYykgcG9zIChwb3MgLSAxKSlcbiAgICBlbHNlIGxvb3AgYWNjIGxhc3RfcG9zIChwb3MgLSAxKVxuICBpblxuICBsb29wIFtdIGxlbiAobGVuIC0gMSlcbjs7XG5cbmxldCBzcGxpdCBzdHIgfm9uID0gc3BsaXRfZ2VuIHN0ciB+b246KGBjaGFyIG9uKVxubGV0IHNwbGl0X29uX2NoYXJzIHN0ciB+b246Y2hhcnMgPSBzcGxpdF9nZW4gc3RyIH5vbjooYGNoYXJfbGlzdCBjaGFycylcblxubGV0IHNwbGl0X2xpbmVzID1cbiAgbGV0IGJhY2tfdXBfYXRfbmV3bGluZSB+dCB+cG9zIH5lb2wgPVxuICAgIHBvcyA6PSAhcG9zIC0gaWYgIXBvcyA+IDAgJiYgQ2hhci5lcXVhbCB0LlshcG9zIC0gMV0gJ1xccicgdGhlbiAyIGVsc2UgMTtcbiAgICBlb2wgOj0gIXBvcyArIDFcbiAgaW5cbiAgZnVuIHQgLT5cbiAgICBsZXQgbiA9IGxlbmd0aCB0IGluXG4gICAgaWYgbiA9IDBcbiAgICB0aGVuIFtdXG4gICAgZWxzZSAoXG4gICAgICAoKiBJbnZhcmlhbnQ6IFstMSA8PSBwb3MgPCBlb2xdLiAqKVxuICAgICAgbGV0IHBvcyA9IHJlZiAobiAtIDEpIGluXG4gICAgICBsZXQgZW9sID0gcmVmIG4gaW5cbiAgICAgIGxldCBhYyA9IHJlZiBbXSBpblxuICAgICAgKCogV2UgdHJlYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nIHNwZWNpYWxseSwgYmVjYXVzZSBpZiB0aGUgc3RyaW5nIGVuZHMgd2l0aCBhXG4gICAgICAgICBuZXdsaW5lLCB3ZSBkb24ndCB3YW50IGFuIGV4dHJhIGVtcHR5IHN0cmluZyBhdCB0aGUgZW5kIG9mIHRoZSBvdXRwdXQuICopXG4gICAgICBpZiBDaGFyLmVxdWFsIHQuWyFwb3NdICdcXG4nIHRoZW4gYmFja191cF9hdF9uZXdsaW5lIH50IH5wb3MgfmVvbDtcbiAgICAgIHdoaWxlICFwb3MgPj0gMCBkb1xuICAgICAgICBpZiBDaGFyLiggPD4gKSB0LlshcG9zXSAnXFxuJ1xuICAgICAgICB0aGVuIGRlY3IgcG9zXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgICgqIEJlY2F1c2UgW3BvcyA8IGVvbF0sIHdlIGtub3cgdGhhdCBbc3RhcnQgPD0gZW9sXS4gKilcbiAgICAgICAgICBsZXQgc3RhcnQgPSAhcG9zICsgMSBpblxuICAgICAgICAgIGFjIDo9IHN1YiB0IH5wb3M6c3RhcnQgfmxlbjooIWVvbCAtIHN0YXJ0KSA6OiAhYWM7XG4gICAgICAgICAgYmFja191cF9hdF9uZXdsaW5lIH50IH5wb3MgfmVvbClcbiAgICAgIGRvbmU7XG4gICAgICBzdWIgdCB+cG9zOjAgfmxlbjohZW9sIDo6ICFhYylcbjs7XG5cbmxldCBpc19zdWZmaXggcyB+c3VmZml4ID0gaXNfc3VmZml4X2dlbiBzIH5zdWZmaXggfmNoYXJfZXF1YWw6Q2hhci5lcXVhbFxubGV0IGlzX3ByZWZpeCBzIH5wcmVmaXggPSBpc19wcmVmaXhfZ2VuIHMgfnByZWZpeCB+Y2hhcl9lcXVhbDpDaGFyLmVxdWFsXG5cbmxldCBpc19zdWJzdHJpbmdfYXQgcyB+cG9zIH5zdWJzdHJpbmcgPVxuICBpc19zdWJzdHJpbmdfYXRfZ2VuIHMgfnBvcyB+c3Vic3RyaW5nIH5jaGFyX2VxdWFsOkNoYXIuZXF1YWxcbjs7XG5cbmxldCB3cmFwX3N1Yl9uIHQgbiB+bmFtZSB+cG9zIH5sZW4gfm9uX2Vycm9yID1cbiAgaWYgbiA8IDBcbiAgdGhlbiBpbnZhbGlkX2FyZyAobmFtZSBeIFwiIGV4cGVjdGluZyBub25uZWdhdGl2ZSBhcmd1bWVudFwiKVxuICBlbHNlIChcbiAgICB0cnkgc3ViIHQgfnBvcyB+bGVuIHdpdGhcbiAgICB8IF8gLT4gb25fZXJyb3IpXG47O1xuXG5sZXQgZHJvcF9wcmVmaXggdCBuID1cbiAgd3JhcF9zdWJfbiB+bmFtZTpcImRyb3BfcHJlZml4XCIgdCBuIH5wb3M6biB+bGVuOihsZW5ndGggdCAtIG4pIH5vbl9lcnJvcjpcIlwiXG47O1xuXG5sZXQgZHJvcF9zdWZmaXggdCBuID1cbiAgd3JhcF9zdWJfbiB+bmFtZTpcImRyb3Bfc3VmZml4XCIgdCBuIH5wb3M6MCB+bGVuOihsZW5ndGggdCAtIG4pIH5vbl9lcnJvcjpcIlwiXG47O1xuXG5sZXQgcHJlZml4IHQgbiA9IHdyYXBfc3ViX24gfm5hbWU6XCJwcmVmaXhcIiB0IG4gfnBvczowIH5sZW46biB+b25fZXJyb3I6dFxubGV0IHN1ZmZpeCB0IG4gPSB3cmFwX3N1Yl9uIH5uYW1lOlwic3VmZml4XCIgdCBuIH5wb3M6KGxlbmd0aCB0IC0gbikgfmxlbjpuIH5vbl9lcnJvcjp0XG5cbmxldCBsZmluZGkgPyhwb3MgPSAwKSB0IH5mID1cbiAgbGV0IG4gPSBsZW5ndGggdCBpblxuICBsZXQgcmVjIGxvb3AgaSA9IGlmIGkgPSBuIHRoZW4gTm9uZSBlbHNlIGlmIGYgaSB0LltpXSB0aGVuIFNvbWUgaSBlbHNlIGxvb3AgKGkgKyAxKSBpblxuICBsb29wIHBvc1xuOztcblxubGV0IGZpbmQgdCB+ZiA9XG4gIG1hdGNoIGxmaW5kaSB0IH5mOihmdW4gXyBjIC0+IGYgYykgd2l0aFxuICB8IE5vbmUgLT4gTm9uZVxuICB8IFNvbWUgaSAtPiBTb21lIHQuW2ldXG47O1xuXG5sZXQgZmluZF9tYXAgdCB+ZiA9XG4gIGxldCBuID0gbGVuZ3RoIHQgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuXG4gICAgdGhlbiBOb25lXG4gICAgZWxzZSAoXG4gICAgICBtYXRjaCBmIHQuW2ldIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBsb29wIChpICsgMSlcbiAgICAgIHwgU29tZSBfIGFzIHJlcyAtPiByZXMpXG4gIGluXG4gIGxvb3AgMFxuOztcblxubGV0IHJmaW5kaSA/cG9zIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgaSA9IGlmIGkgPCAwIHRoZW4gTm9uZSBlbHNlIGlmIGYgaSB0LltpXSB0aGVuIFNvbWUgaSBlbHNlIGxvb3AgKGkgLSAxKSBpblxuICBsZXQgcG9zID1cbiAgICBtYXRjaCBwb3Mgd2l0aFxuICAgIHwgU29tZSBwb3MgLT4gcG9zXG4gICAgfCBOb25lIC0+IGxlbmd0aCB0IC0gMVxuICBpblxuICBsb29wIHBvc1xuOztcblxubGV0IGxhc3Rfbm9uX2Ryb3AgfmRyb3AgdCA9IHJmaW5kaSB0IH5mOihmdW4gXyBjIC0+IG5vdCAoZHJvcCBjKSlcblxubGV0IHJzdHJpcCA/KGRyb3AgPSBDaGFyLmlzX3doaXRlc3BhY2UpIHQgPVxuICBtYXRjaCBsYXN0X25vbl9kcm9wIHQgfmRyb3Agd2l0aFxuICB8IE5vbmUgLT4gXCJcIlxuICB8IFNvbWUgaSAtPiBpZiBpID0gbGVuZ3RoIHQgLSAxIHRoZW4gdCBlbHNlIHByZWZpeCB0IChpICsgMSlcbjs7XG5cbmxldCBmaXJzdF9ub25fZHJvcCB+ZHJvcCB0ID0gbGZpbmRpIHQgfmY6KGZ1biBfIGMgLT4gbm90IChkcm9wIGMpKVxuXG5sZXQgbHN0cmlwID8oZHJvcCA9IENoYXIuaXNfd2hpdGVzcGFjZSkgdCA9XG4gIG1hdGNoIGZpcnN0X25vbl9kcm9wIHQgfmRyb3Agd2l0aFxuICB8IE5vbmUgLT4gXCJcIlxuICB8IFNvbWUgMCAtPiB0XG4gIHwgU29tZSBuIC0+IGRyb3BfcHJlZml4IHQgblxuOztcblxuKCogW3N0cmlwIHRdIGNvdWxkIGJlIGltcGxlbWVudGVkIGFzIFtsc3RyaXAgKHJzdHJpcCB0KV0uICBUaGUgaW1wbGVtZW50YXRpb25cbiAgIGJlbG93IHNhdmVzIChhdCBsZWFzdCkgYSBmYWN0b3Igb2YgdHdvIGFsbG9jYXRpb24sIGJ5IG9ubHkgYWxsb2NhdGluZyB0aGVcbiAgIGZpbmFsIHJlc3VsdC4gIFRoaXMgYWxzbyBzYXZlcyBzb21lIGFtb3VudCBvZiB0aW1lLiAqKVxubGV0IHN0cmlwID8oZHJvcCA9IENoYXIuaXNfd2hpdGVzcGFjZSkgdCA9XG4gIGxldCBsZW5ndGggPSBsZW5ndGggdCBpblxuICBpZiBsZW5ndGggPSAwIHx8IG5vdCAoZHJvcCB0LlswXSB8fCBkcm9wIHQuW2xlbmd0aCAtIDFdKVxuICB0aGVuIHRcbiAgZWxzZSAoXG4gICAgbWF0Y2ggZmlyc3Rfbm9uX2Ryb3AgdCB+ZHJvcCB3aXRoXG4gICAgfCBOb25lIC0+IFwiXCJcbiAgICB8IFNvbWUgZmlyc3QgLT5cbiAgICAgIChtYXRjaCBsYXN0X25vbl9kcm9wIHQgfmRyb3Agd2l0aFxuICAgICAgIHwgTm9uZSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICB8IFNvbWUgbGFzdCAtPiBzdWIgdCB+cG9zOmZpcnN0IH5sZW46KGxhc3QgLSBmaXJzdCArIDEpKSlcbjs7XG5cbmxldCBtYXBpIHQgfmYgPVxuICBsZXQgbCA9IGxlbmd0aCB0IGluXG4gIGxldCB0JyA9IEJ5dGVzLmNyZWF0ZSBsIGluXG4gIGZvciBpID0gMCB0byBsIC0gMSBkb1xuICAgIEJ5dGVzLnVuc2FmZV9zZXQgdCcgaSAoZiBpIHQuW2ldKVxuICBkb25lO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOnQnXG47O1xuXG4oKiByZXBlYXRlZCBjb2RlIHRvIGF2b2lkIHJlcXVpcmluZyBhbiBleHRyYSBhbGxvY2F0aW9uIGZvciBhIGNsb3N1cmUgb24gZWFjaCBjYWxsLiAqKVxubGV0IG1hcCB0IH5mID1cbiAgbGV0IGwgPSBsZW5ndGggdCBpblxuICBsZXQgdCcgPSBCeXRlcy5jcmVhdGUgbCBpblxuICBmb3IgaSA9IDAgdG8gbCAtIDEgZG9cbiAgICBCeXRlcy51bnNhZmVfc2V0IHQnIGkgKGYgdC5baV0pXG4gIGRvbmU7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6dCdcbjs7XG5cbmxldCB0b19hcnJheSBzID0gQXJyYXkuaW5pdCAobGVuZ3RoIHMpIH5mOihmdW4gaSAtPiBzLltpXSlcblxubGV0IGV4aXN0cyA9XG4gIGxldCByZWMgbG9vcCBzIGkgfmxlbiB+ZiA9IGkgPCBsZW4gJiYgKGYgcy5baV0gfHwgbG9vcCBzIChpICsgMSkgfmxlbiB+ZikgaW5cbiAgZnVuIHMgfmYgLT4gbG9vcCBzIDAgfmxlbjoobGVuZ3RoIHMpIH5mXG47O1xuXG5sZXQgZm9yX2FsbCA9XG4gIGxldCByZWMgbG9vcCBzIGkgfmxlbiB+ZiA9IGkgPSBsZW4gfHwgKGYgcy5baV0gJiYgbG9vcCBzIChpICsgMSkgfmxlbiB+ZikgaW5cbiAgZnVuIHMgfmYgLT4gbG9vcCBzIDAgfmxlbjoobGVuZ3RoIHMpIH5mXG47O1xuXG5sZXQgZm9sZCA9XG4gIGxldCByZWMgbG9vcCB0IGkgYWMgfmYgfmxlbiA9XG4gICAgaWYgaSA9IGxlbiB0aGVuIGFjIGVsc2UgbG9vcCB0IChpICsgMSkgKGYgYWMgdC5baV0pIH5mIH5sZW5cbiAgaW5cbiAgZnVuIHQgfmluaXQgfmYgLT4gbG9vcCB0IDAgaW5pdCB+ZiB+bGVuOihsZW5ndGggdClcbjs7XG5cbmxldCBmb2xkaSA9XG4gIGxldCByZWMgbG9vcCB0IGkgYWMgfmYgfmxlbiA9XG4gICAgaWYgaSA9IGxlbiB0aGVuIGFjIGVsc2UgbG9vcCB0IChpICsgMSkgKGYgaSBhYyB0LltpXSkgfmYgfmxlblxuICBpblxuICBmdW4gdCB+aW5pdCB+ZiAtPiBsb29wIHQgMCBpbml0IH5mIH5sZW46KGxlbmd0aCB0KVxuOztcblxubGV0IGl0ZXJpIHQgfmYgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHQgLSAxIGRvXG4gICAgZiBpICh1bnNhZmVfZ2V0IHQgaSlcbiAgZG9uZVxuOztcblxubGV0IGNvdW50IHQgfmYgPSBDb250YWluZXIuY291bnQgfmZvbGQgdCB+ZlxubGV0IHN1bSBtIHQgfmYgPSBDb250YWluZXIuc3VtIH5mb2xkIG0gdCB+ZlxubGV0IG1pbl9lbHQgdCA9IENvbnRhaW5lci5taW5fZWx0IH5mb2xkIHRcbmxldCBtYXhfZWx0IHQgPSBDb250YWluZXIubWF4X2VsdCB+Zm9sZCB0XG5sZXQgZm9sZF9yZXN1bHQgdCB+aW5pdCB+ZiA9IENvbnRhaW5lci5mb2xkX3Jlc3VsdCB+Zm9sZCB+aW5pdCB+ZiB0XG5sZXQgZm9sZF91bnRpbCB0IH5pbml0IH5mID0gQ29udGFpbmVyLmZvbGRfdW50aWwgfmZvbGQgfmluaXQgfmYgdFxubGV0IGZpbmRfbWFwaSB0IH5mID0gSW5kZXhlZF9jb250YWluZXIuZmluZF9tYXBpIH5pdGVyaSB0IH5mXG5sZXQgZmluZGkgdCB+ZiA9IEluZGV4ZWRfY29udGFpbmVyLmZpbmRpIH5pdGVyaSB0IH5mXG5sZXQgY291bnRpIHQgfmYgPSBJbmRleGVkX2NvbnRhaW5lci5jb3VudGkgfmZvbGRpIHQgfmZcbmxldCBmb3JfYWxsaSB0IH5mID0gSW5kZXhlZF9jb250YWluZXIuZm9yX2FsbGkgfml0ZXJpIHQgfmZcbmxldCBleGlzdHNpIHQgfmYgPSBJbmRleGVkX2NvbnRhaW5lci5leGlzdHNpIH5pdGVyaSB0IH5mXG5cbmxldCBtZW0gPVxuICBsZXQgcmVjIGxvb3AgdCBjIH5wb3M6aSB+bGVuID1cbiAgICBpIDwgbGVuICYmIChDaGFyLmVxdWFsIGMgKHVuc2FmZV9nZXQgdCBpKSB8fCBsb29wIHQgYyB+cG9zOihpICsgMSkgfmxlbilcbiAgaW5cbiAgZnVuIHQgYyAtPiBsb29wIHQgYyB+cG9zOjAgfmxlbjoobGVuZ3RoIHQpXG47O1xuXG5sZXQgdHIgfnRhcmdldCB+cmVwbGFjZW1lbnQgcyA9XG4gIGlmIENoYXIuZXF1YWwgdGFyZ2V0IHJlcGxhY2VtZW50XG4gIHRoZW4gc1xuICBlbHNlIGlmIG1lbSBzIHRhcmdldFxuICB0aGVuIG1hcCBzIH5mOihmdW4gYyAtPiBpZiBDaGFyLmVxdWFsIGMgdGFyZ2V0IHRoZW4gcmVwbGFjZW1lbnQgZWxzZSBjKVxuICBlbHNlIHNcbjs7XG5cbmxldCB0cl9tdWx0aSB+dGFyZ2V0IH5yZXBsYWNlbWVudCA9XG4gIGlmIGlzX2VtcHR5IHRhcmdldFxuICB0aGVuIHN0YWdlIEZuLmlkXG4gIGVsc2UgaWYgaXNfZW1wdHkgcmVwbGFjZW1lbnRcbiAgdGhlbiBpbnZhbGlkX2FyZyBcInRyX211bHRpIHJlcGxhY2VtZW50IGlzIGVtcHR5IHN0cmluZ1wiXG4gIGVsc2UgKFxuICAgIG1hdGNoIEJ5dGVzX3RyLnRyX2NyZWF0ZV9tYXAgfnRhcmdldCB+cmVwbGFjZW1lbnQgd2l0aFxuICAgIHwgTm9uZSAtPiBzdGFnZSBGbi5pZFxuICAgIHwgU29tZSB0cl9tYXAgLT5cbiAgICAgIHN0YWdlIChmdW4gcyAtPlxuICAgICAgICBpZiBleGlzdHMgcyB+ZjooZnVuIGMgLT4gQ2hhci4oIDw+ICkgYyAodW5zYWZlX2dldCB0cl9tYXAgKENoYXIudG9faW50IGMpKSlcbiAgICAgICAgdGhlbiBtYXAgcyB+ZjooZnVuIGMgLT4gdW5zYWZlX2dldCB0cl9tYXAgKENoYXIudG9faW50IGMpKVxuICAgICAgICBlbHNlIHMpKVxuOztcblxuKCogZmFzdCB2ZXJzaW9uLCBpZiB3ZSBldmVyIG5lZWQgaXQ6XG4gICB7W1xuICAgICBsZXQgY29uY2F0X2FycmF5IH5zZXAgYXIgPVxuICAgICAgIGxldCBhcl9sZW4gPSBBcnJheS5sZW5ndGggYXIgaW5cbiAgICAgICBpZiBhcl9sZW4gPSAwIHRoZW4gXCJcIlxuICAgICAgIGVsc2VcbiAgICAgICAgIGxldCBzZXBfbGVuID0gbGVuZ3RoIHNlcCBpblxuICAgICAgICAgbGV0IHJlc19sZW5fcmVmID0gcmVmIChzZXBfbGVuICogKGFyX2xlbiAtIDEpKSBpblxuICAgICAgICAgZm9yIGkgPSAwIHRvIGFyX2xlbiAtIDEgZG9cbiAgICAgICAgICAgcmVzX2xlbl9yZWYgOj0gIXJlc19sZW5fcmVmICsgbGVuZ3RoIGFyLihpKVxuICAgICAgICAgZG9uZTtcbiAgICAgICAgIGxldCByZXMgPSBjcmVhdGUgIXJlc19sZW5fcmVmIGluXG4gICAgICAgICBsZXQgc3RyXzAgPSBhci4oMCkgaW5cbiAgICAgICAgIGxldCBsZW5fMCA9IGxlbmd0aCBzdHJfMCBpblxuICAgICAgICAgYmxpdCB+c3JjOnN0cl8wIH5zcmNfcG9zOjAgfmRzdDpyZXMgfmRzdF9wb3M6MCB+bGVuOmxlbl8wO1xuICAgICAgICAgbGV0IHBvc19yZWYgPSByZWYgbGVuXzAgaW5cbiAgICAgICAgIGZvciBpID0gMSB0byBhcl9sZW4gLSAxIGRvXG4gICAgICAgICAgIGxldCBwb3MgPSAhcG9zX3JlZiBpblxuICAgICAgICAgICBibGl0IH5zcmM6c2VwIH5zcmNfcG9zOjAgfmRzdDpyZXMgfmRzdF9wb3M6cG9zIH5sZW46c2VwX2xlbjtcbiAgICAgICAgICAgbGV0IG5ld19wb3MgPSBwb3MgKyBzZXBfbGVuIGluXG4gICAgICAgICAgIGxldCBzdHJfaSA9IGFyLihpKSBpblxuICAgICAgICAgICBsZXQgbGVuX2kgPSBsZW5ndGggc3RyX2kgaW5cbiAgICAgICAgICAgYmxpdCB+c3JjOnN0cl9pIH5zcmNfcG9zOjAgfmRzdDpyZXMgfmRzdF9wb3M6bmV3X3BvcyB+bGVuOmxlbl9pO1xuICAgICAgICAgICBwb3NfcmVmIDo9IG5ld19wb3MgKyBsZW5faVxuICAgICAgICAgZG9uZTtcbiAgICAgICAgIHJlc1xuICAgXX0gKilcblxubGV0IGNvbmNhdF9hcnJheSA/c2VwIGFyID0gY29uY2F0ID9zZXAgKEFycmF5LnRvX2xpc3QgYXIpXG5sZXQgY29uY2F0X21hcCA/c2VwIHMgfmYgPSBjb25jYXRfYXJyYXkgP3NlcCAoQXJyYXkubWFwICh0b19hcnJheSBzKSB+ZilcblxuKCogW2ZpbHRlciB0IGZdIGlzIGltcGxlbWVudGVkIGJ5IHRoZSBmb2xsb3dpbmcgYWxnb3JpdGhtLlxuXG4gICBMZXQgW24gPSBsZW5ndGggdF0uXG5cbiAgIDEuIEZpbmQgdGhlIGxvd2VzdCBbaV0gc3VjaCB0aGF0IFtub3QgKGYgdC5baV0pXS5cblxuICAgMi4gSWYgdGhlcmUgaXMgbm8gc3VjaCBbaV0sIHRoZW4gcmV0dXJuIFt0XS5cblxuICAgMy4gSWYgdGhlcmUgaXMgc3VjaCBhbiBbaV0sIGFsbG9jYXRlIGEgc3RyaW5nLCBbb3V0XSwgdG8gaG9sZCB0aGUgcmVzdWx0LiAgW291dF0gaGFzXG4gICBsZW5ndGggW24gLSAxXSwgd2hpY2ggaXMgdGhlIG1heGltdW0gcG9zc2libGUgb3V0cHV0IHNpemUgZ2l2ZW4gdGhhdCB0aGVyZSBpcyBhdCBsZWFzdFxuICAgb25lIGNoYXJhY3RlciBub3Qgc2F0aXNmeWluZyBbZl0uXG5cbiAgIDQuIENvcHkgY2hhcmFjdGVycyBhdCBpbmRpY2VzIDAgLi4uIFtpIC0gMV0gZnJvbSBbdF0gdG8gW291dF0uXG5cbiAgIDUuIFdhbGsgdGhyb3VnaCBjaGFyYWN0ZXJzIGF0IGluZGljZXMgW2krMV0gLi4uIFtuLTFdIG9mIFt0XSwgY29weWluZyB0aG9zZSB0aGF0XG4gICBzYXRpc2Z5IFtmXSBmcm9tIFt0XSB0byBbb3V0XS5cblxuICAgNi4gSWYgd2UgY29tcGxldGVseSBmaWxsZWQgW291dF0sIHRoZW4gcmV0dXJuIGl0LiAgSWYgbm90LCByZXR1cm4gdGhlIHByZWZpeCBvZiBbb3V0XVxuICAgdGhhdCB3ZSBkaWQgZmlsbCBpbi5cblxuICAgVGhpcyBhbGdvcml0aG0gaGFzIHRoZSBwcm9wZXJ0eSB0aGF0IGl0IGRvZXNuJ3QgYWxsb2NhdGUgYSBuZXcgc3RyaW5nIGlmIHRoZXJlJ3NcbiAgIG5vdGhpbmcgdG8gZmlsdGVyLCB3aGljaCBpcyBhIGNvbW1vbiBjYXNlLiAqKVxubGV0IGZpbHRlciB0IH5mID1cbiAgbGV0IG4gPSBsZW5ndGggdCBpblxuICBsZXQgaSA9IHJlZiAwIGluXG4gIHdoaWxlICFpIDwgbiAmJiBmIHQuWyFpXSBkb1xuICAgIGluY3IgaVxuICBkb25lO1xuICBpZiAhaSA9IG5cbiAgdGhlbiB0XG4gIGVsc2UgKFxuICAgIGxldCBvdXQgPSBCeXRlcy5jcmVhdGUgKG4gLSAxKSBpblxuICAgIEJ5dGVzLmJsaXRfc3RyaW5nIH5zcmM6dCB+c3JjX3BvczowIH5kc3Q6b3V0IH5kc3RfcG9zOjAgfmxlbjohaTtcbiAgICBsZXQgb3V0X3BvcyA9IHJlZiAhaSBpblxuICAgIGluY3IgaTtcbiAgICB3aGlsZSAhaSA8IG4gZG9cbiAgICAgIGxldCBjID0gdC5bIWldIGluXG4gICAgICBpZiBmIGNcbiAgICAgIHRoZW4gKFxuICAgICAgICBCeXRlcy5zZXQgb3V0ICFvdXRfcG9zIGM7XG4gICAgICAgIGluY3Igb3V0X3Bvcyk7XG4gICAgICBpbmNyIGlcbiAgICBkb25lO1xuICAgIGxldCBvdXQgPSBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOm91dCBpblxuICAgIGlmICFvdXRfcG9zID0gbiAtIDEgdGhlbiBvdXQgZWxzZSBzdWIgb3V0IH5wb3M6MCB+bGVuOiFvdXRfcG9zKVxuOztcblxuKCogcmVwZWF0ZWQgY29kZSB0byBhdm9pZCByZXF1aXJpbmcgYW4gZXh0cmEgYWxsb2NhdGlvbiBmb3IgYSBjbG9zdXJlIG9uIGVhY2ggY2FsbC4gKilcbmxldCBmaWx0ZXJpIHQgfmYgPVxuICBsZXQgbiA9IGxlbmd0aCB0IGluXG4gIGxldCBpID0gcmVmIDAgaW5cbiAgd2hpbGUgIWkgPCBuICYmIGYgIWkgdC5bIWldIGRvXG4gICAgaW5jciBpXG4gIGRvbmU7XG4gIGlmICFpID0gblxuICB0aGVuIHRcbiAgZWxzZSAoXG4gICAgbGV0IG91dCA9IEJ5dGVzLmNyZWF0ZSAobiAtIDEpIGluXG4gICAgQnl0ZXMuYmxpdF9zdHJpbmcgfnNyYzp0IH5zcmNfcG9zOjAgfmRzdDpvdXQgfmRzdF9wb3M6MCB+bGVuOiFpO1xuICAgIGxldCBvdXRfcG9zID0gcmVmICFpIGluXG4gICAgaW5jciBpO1xuICAgIHdoaWxlICFpIDwgbiBkb1xuICAgICAgbGV0IGMgPSB0LlshaV0gaW5cbiAgICAgIGlmIGYgIWkgY1xuICAgICAgdGhlbiAoXG4gICAgICAgIEJ5dGVzLnNldCBvdXQgIW91dF9wb3MgYztcbiAgICAgICAgaW5jciBvdXRfcG9zKTtcbiAgICAgIGluY3IgaVxuICAgIGRvbmU7XG4gICAgbGV0IG91dCA9IEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6b3V0IGluXG4gICAgaWYgIW91dF9wb3MgPSBuIC0gMSB0aGVuIG91dCBlbHNlIHN1YiBvdXQgfnBvczowIH5sZW46IW91dF9wb3MpXG47O1xuXG5sZXQgY2hvcF9wcmVmaXggcyB+cHJlZml4ID1cbiAgaWYgaXNfcHJlZml4IHMgfnByZWZpeCB0aGVuIFNvbWUgKGRyb3BfcHJlZml4IHMgKGxlbmd0aCBwcmVmaXgpKSBlbHNlIE5vbmVcbjs7XG5cbmxldCBjaG9wX3ByZWZpeF9pZl9leGlzdHMgcyB+cHJlZml4ID1cbiAgaWYgaXNfcHJlZml4IHMgfnByZWZpeCB0aGVuIGRyb3BfcHJlZml4IHMgKGxlbmd0aCBwcmVmaXgpIGVsc2Ugc1xuOztcblxubGV0IGNob3BfcHJlZml4X2V4biBzIH5wcmVmaXggPVxuICBtYXRjaCBjaG9wX3ByZWZpeCBzIH5wcmVmaXggd2l0aFxuICB8IFNvbWUgc3RyIC0+IHN0clxuICB8IE5vbmUgLT4gaW52YWxpZF9hcmdmIFwiU3RyaW5nLmNob3BfcHJlZml4X2V4biAlUyAlU1wiIHMgcHJlZml4ICgpXG47O1xuXG5sZXQgY2hvcF9zdWZmaXggcyB+c3VmZml4ID1cbiAgaWYgaXNfc3VmZml4IHMgfnN1ZmZpeCB0aGVuIFNvbWUgKGRyb3Bfc3VmZml4IHMgKGxlbmd0aCBzdWZmaXgpKSBlbHNlIE5vbmVcbjs7XG5cbmxldCBjaG9wX3N1ZmZpeF9pZl9leGlzdHMgcyB+c3VmZml4ID1cbiAgaWYgaXNfc3VmZml4IHMgfnN1ZmZpeCB0aGVuIGRyb3Bfc3VmZml4IHMgKGxlbmd0aCBzdWZmaXgpIGVsc2Ugc1xuOztcblxubGV0IGNob3Bfc3VmZml4X2V4biBzIH5zdWZmaXggPVxuICBtYXRjaCBjaG9wX3N1ZmZpeCBzIH5zdWZmaXggd2l0aFxuICB8IFNvbWUgc3RyIC0+IHN0clxuICB8IE5vbmUgLT4gaW52YWxpZF9hcmdmIFwiU3RyaW5nLmNob3Bfc3VmZml4X2V4biAlUyAlU1wiIHMgc3VmZml4ICgpXG47O1xuXG5tb2R1bGUgRm9yX2NvbW1vbl9wcmVmaXhfYW5kX3N1ZmZpeCA9IHN0cnVjdFxuICAoKiBXaGVuIHRha2luZyBhIHN0cmluZyBwcmVmaXggb3Igc3VmZml4LCB3ZSBleHRyYWN0IGZyb20gdGhlIHNob3J0ZXN0IGlucHV0IGF2YWlsYWJsZVxuICAgICBpbiBjYXNlIHdlIGNhbiBqdXN0IHJldHVybiBvbmUgb2Ygb3VyIGlucHV0cyB3aXRob3V0IGFsbG9jYXRpbmcgYSBuZXcgc3RyaW5nLiAqKVxuXG4gIGxldCBzaG9ydGVyIGEgYiA9IGlmIGxlbmd0aCBhIDw9IGxlbmd0aCBiIHRoZW4gYSBlbHNlIGJcblxuICBsZXQgc2hvcnRlc3QgbGlzdCA9XG4gICAgbWF0Y2ggbGlzdCB3aXRoXG4gICAgfCBbXSAtPiBcIlwiXG4gICAgfCBmaXJzdCA6OiByZXN0IC0+IExpc3QuZm9sZCByZXN0IH5pbml0OmZpcnN0IH5mOnNob3J0ZXJcbiAgOztcblxuICAoKiBPdXIgZ2VuZXJpYyBhY2Nlc3NvcnMgZm9yIGNvbW1vbiBwcmVmaXgvc3VmZml4IGFic3RyYWN0IG92ZXIgW2dldF9wb3NdLCB3aGljaCBpc1xuICAgICBlaXRoZXIgW3Bvc19mcm9tX2xlZnRdIG9yIFtwb3NfZnJvbV9yaWdodF0uICopXG5cbiAgbGV0IHBvc19mcm9tX2xlZnQgKF8gOiB0KSAoaSA6IGludCkgPSBpXG4gIGxldCBwb3NfZnJvbV9yaWdodCB0IGkgPSBsZW5ndGggdCAtIGkgLSAxXG5cbiAgbGV0IHJlYyBjb21tb25fZ2VuZXJpYzJfbGVuZ3RoX2xvb3AgYSBiIH5nZXRfcG9zIH5tYXhfbGVuIH5sZW5fc29fZmFyID1cbiAgICBpZiBsZW5fc29fZmFyID49IG1heF9sZW5cbiAgICB0aGVuIG1heF9sZW5cbiAgICBlbHNlIGlmIENoYXIuZXF1YWxcbiAgICAgICAgICAgICAgKHVuc2FmZV9nZXQgYSAoZ2V0X3BvcyBhIGxlbl9zb19mYXIpKVxuICAgICAgICAgICAgICAodW5zYWZlX2dldCBiIChnZXRfcG9zIGIgbGVuX3NvX2ZhcikpXG4gICAgdGhlbiBjb21tb25fZ2VuZXJpYzJfbGVuZ3RoX2xvb3AgYSBiIH5nZXRfcG9zIH5tYXhfbGVuIH5sZW5fc29fZmFyOihsZW5fc29fZmFyICsgMSlcbiAgICBlbHNlIGxlbl9zb19mYXJcbiAgOztcblxuICBsZXQgY29tbW9uX2dlbmVyaWMyX2xlbmd0aCBhIGIgfmdldF9wb3MgPVxuICAgIGxldCBtYXhfbGVuID0gbWluIChsZW5ndGggYSkgKGxlbmd0aCBiKSBpblxuICAgIGNvbW1vbl9nZW5lcmljMl9sZW5ndGhfbG9vcCBhIGIgfmdldF9wb3Mgfm1heF9sZW4gfmxlbl9zb19mYXI6MFxuICA7O1xuXG4gIGxldCByZWMgY29tbW9uX2dlbmVyaWNfbGVuZ3RoX2xvb3AgZmlyc3QgbGlzdCB+Z2V0X3BvcyB+bWF4X2xlbiA9XG4gICAgbWF0Y2ggbGlzdCB3aXRoXG4gICAgfCBbXSAtPiBtYXhfbGVuXG4gICAgfCBzZWNvbmQgOjogcmVzdCAtPlxuICAgICAgbGV0IG1heF9sZW4gPVxuICAgICAgICAoKiBXZSBjYWxsIFtjb21tb25fZ2VuZXJpYzJfbGVuZ3RoX2xvb3BdIHJhdGhlciB0aGFuIFtjb21tb25fZ2VuZXJpYzJfbGVuZ3RoXSBzb1xuICAgICAgICAgICB0aGF0IFttYXhfbGVuXSBsaW1pdHMgb3VyIHRyYXZlcnNhbCBvZiBbZmlyc3RdIGFuZCBbc2Vjb25kXS4gKilcbiAgICAgICAgY29tbW9uX2dlbmVyaWMyX2xlbmd0aF9sb29wIGZpcnN0IHNlY29uZCB+Z2V0X3BvcyB+bWF4X2xlbiB+bGVuX3NvX2ZhcjowXG4gICAgICBpblxuICAgICAgY29tbW9uX2dlbmVyaWNfbGVuZ3RoX2xvb3Agc2Vjb25kIHJlc3QgfmdldF9wb3Mgfm1heF9sZW5cbiAgOztcblxuICBsZXQgY29tbW9uX2dlbmVyaWNfbGVuZ3RoIGxpc3QgfmdldF9wb3MgPVxuICAgIG1hdGNoIGxpc3Qgd2l0aFxuICAgIHwgW10gLT4gMFxuICAgIHwgZmlyc3QgOjogcmVzdCAtPlxuICAgICAgKCogUHJlY29tcHV0aW5nIFttYXhfbGVuXSBiYXNlZCBvbiBbc2hvcnRlc3QgbGlzdF0gc2F2ZXMgdXMgd29yayBpbiBsb25nZXIgc3RyaW5ncyxcbiAgICAgICAgIGF0IHRoZSBjb3N0IG9mIGFuIGV4dHJhIHBhc3Mgb3ZlciB0aGUgc3BpbmUgb2YgW2xpc3RdLlxuXG4gICAgICAgICBGb3IgZXhhbXBsZSwgaWYgeW91J3JlIGxvb2tpbmcgZm9yIHRoZSBsb25nZXN0IHByZWZpeCBvZiB0aGUgc3RyaW5nczpcblxuICAgICAgICAge3ZcbiAgICAgICAgICAgIGxldCBsb25nX2EgPSBMaXN0LmluaXQgMTAwMCB+ZjooRm4uY29uc3QgJ2EnKVxuICAgICAgICAgICAgWyBsb25nX2E7IGxvbmdfYTsgJ2FhJyBdXG4gICAgICAgICB2fVxuXG4gICAgICAgICB0aGUgYXBwcm9hY2ggYmVsb3cgd2lsbCBqdXN0IGNoZWNrIHRoZSBmaXJzdCB0d28gY2hhcmFjdGVycyBvZiBhbGwgdGhlIHN0cmluZ3MuXG4gICAgICAqKVxuICAgICAgbGV0IG1heF9sZW4gPSBsZW5ndGggKHNob3J0ZXN0IGxpc3QpIGluXG4gICAgICBjb21tb25fZ2VuZXJpY19sZW5ndGhfbG9vcCBmaXJzdCByZXN0IH5nZXRfcG9zIH5tYXhfbGVuXG4gIDs7XG5cbiAgKCogT3VyIGdlbmVyaWMgYWNjZXNzb3JzIHRoYXQgcHJvZHVjZSBhIHN0cmluZyBhYnN0cmFjdCBvdmVyIFt0YWtlXSwgd2hpY2ggaXMgZWl0aGVyXG4gICAgIFtwcmVmaXhdIG9yIFtzdWZmaXhdLiAqKVxuXG4gIGxldCBjb21tb25fZ2VuZXJpYzIgYSBiIH5nZXRfcG9zIH50YWtlID1cbiAgICBsZXQgbGVuID0gY29tbW9uX2dlbmVyaWMyX2xlbmd0aCBhIGIgfmdldF9wb3MgaW5cbiAgICAoKiBVc2UgdGhlIHNob3J0ZXIgb2YgdGhlIHR3byBzdHJpbmdzLCBzbyB0aGF0IGlmIHRoZSBzaG9ydGVyIG9uZSBpcyB0aGUgc2hhcmVkXG4gICAgICAgcHJlZml4LCBbdGFrZV0gd29uJ3QgYWxsb2NhdGUgYW5vdGhlciBzdHJpbmcuICopXG4gICAgdGFrZSAoc2hvcnRlciBhIGIpIGxlblxuICA7O1xuXG4gIGxldCBjb21tb25fZ2VuZXJpYyBsaXN0IH5nZXRfcG9zIH50YWtlID1cbiAgICBtYXRjaCBsaXN0IHdpdGhcbiAgICB8IFtdIC0+IFwiXCJcbiAgICB8IGZpcnN0IDo6IHJlc3QgLT5cbiAgICAgICgqIEFzIHdpdGggW2NvbW1vbl9nZW5lcmljX2xlbmd0aF0sIHdlIGJhc2UgW21heF9sZW5dIG9uIFtzaG9ydGVzdCBsaXN0XS4gV2UgYWxzb1xuICAgICAgICAgdXNlIHRoaXMgcmVzdWx0IGZvciBbdGFrZV0sIGJlbG93LCB0byBwb3RlbnRpYWxseSBhdm9pZCBhbGxvY2F0aW5nIGEgc3RyaW5nLiAqKVxuICAgICAgbGV0IHMgPSBzaG9ydGVzdCBsaXN0IGluXG4gICAgICBsZXQgbWF4X2xlbiA9IGxlbmd0aCBzIGluXG4gICAgICBpZiBtYXhfbGVuID0gMFxuICAgICAgdGhlbiBcIlwiXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IGxlbiA9XG4gICAgICAgICAgKCogV2UgY2FsbCBkaXJlY3RseSBpbnRvIFtjb21tb25fZ2VuZXJpY19sZW5ndGhfbG9vcF0gcmF0aGVyIHRoYW5cbiAgICAgICAgICAgICBbY29tbW9uX2dlbmVyaWNfbGVuZ3RoXSB0byBhdm9pZCByZWNvbXB1dGluZyBbc2hvcnRlc3QgbGlzdF0uICopXG4gICAgICAgICAgY29tbW9uX2dlbmVyaWNfbGVuZ3RoX2xvb3AgZmlyc3QgcmVzdCB+Z2V0X3BvcyB+bWF4X2xlblxuICAgICAgICBpblxuICAgICAgICB0YWtlIHMgbGVuKVxuICA7O1xuZW5kXG5cbmluY2x1ZGUgc3RydWN0XG4gIG9wZW4gRm9yX2NvbW1vbl9wcmVmaXhfYW5kX3N1ZmZpeFxuXG4gIGxldCBjb21tb25fcHJlZml4IGxpc3QgPSBjb21tb25fZ2VuZXJpYyBsaXN0IH50YWtlOnByZWZpeCB+Z2V0X3Bvczpwb3NfZnJvbV9sZWZ0XG4gIGxldCBjb21tb25fc3VmZml4IGxpc3QgPSBjb21tb25fZ2VuZXJpYyBsaXN0IH50YWtlOnN1ZmZpeCB+Z2V0X3Bvczpwb3NfZnJvbV9yaWdodFxuICBsZXQgY29tbW9uX3ByZWZpeDIgYSBiID0gY29tbW9uX2dlbmVyaWMyIGEgYiB+dGFrZTpwcmVmaXggfmdldF9wb3M6cG9zX2Zyb21fbGVmdFxuICBsZXQgY29tbW9uX3N1ZmZpeDIgYSBiID0gY29tbW9uX2dlbmVyaWMyIGEgYiB+dGFrZTpzdWZmaXggfmdldF9wb3M6cG9zX2Zyb21fcmlnaHRcbiAgbGV0IGNvbW1vbl9wcmVmaXhfbGVuZ3RoIGxpc3QgPSBjb21tb25fZ2VuZXJpY19sZW5ndGggbGlzdCB+Z2V0X3Bvczpwb3NfZnJvbV9sZWZ0XG4gIGxldCBjb21tb25fc3VmZml4X2xlbmd0aCBsaXN0ID0gY29tbW9uX2dlbmVyaWNfbGVuZ3RoIGxpc3QgfmdldF9wb3M6cG9zX2Zyb21fcmlnaHRcbiAgbGV0IGNvbW1vbl9wcmVmaXgyX2xlbmd0aCBhIGIgPSBjb21tb25fZ2VuZXJpYzJfbGVuZ3RoIGEgYiB+Z2V0X3Bvczpwb3NfZnJvbV9sZWZ0XG4gIGxldCBjb21tb25fc3VmZml4Ml9sZW5ndGggYSBiID0gY29tbW9uX2dlbmVyaWMyX2xlbmd0aCBhIGIgfmdldF9wb3M6cG9zX2Zyb21fcmlnaHRcbmVuZFxuXG4oKiBUaGVyZSB1c2VkIHRvIGJlIGEgY3VzdG9tIGltcGxlbWVudGF0aW9uIHRoYXQgd2FzIGZhc3RlciBmb3IgdmVyeSBzaG9ydCBzdHJpbmdzXG4gICAocGVha2luZyBhdCA0MCUgZmFzdGVyIGZvciA0LTYgY2hhciBsb25nIHN0cmluZ3MpLlxuICAgVGhpcyBuZXcgZnVuY3Rpb24gaXMgYXJvdW5kIDIwJSBmYXN0ZXIgdGhhbiB0aGUgZGVmYXVsdCBoYXNoIGZ1bmN0aW9uLCBidXQgc2xvd2VyXG4gICB0aGFuIHRoZSBwcmV2aW91cyBjdXN0b20gaW1wbGVtZW50YXRpb24uIEhvd2V2ZXIsIHRoZSBuZXcgT0NhbWwgZnVuY3Rpb24gaXMgd2VsbFxuICAgYmVoYXZlZCwgYW5kIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgbGVzcyBsaWtlbHkgdG8gZGl2ZXJnZSBmcm9tIHRoZSBkZWZhdWx0IE9DYW1sXG4gICBpbXBsZW1lbnRhdGlvbiBkb2VzLCB3aGljaCBpcyBhIGRlc2lyYWJsZSBwcm9wZXJ0eS4gKFRoZSBvbmx5IHdheSB0byBhdm9pZCB0aGVcbiAgIGRpdmVyZ2VuY2UgaXMgdG8gZXhwb3NlIHRoZSBtYWNybyByZWRlZmluZWQgaW4gaGFzaF9zdHVicy5jIGluIHRoZSBoYXNoLmggaGVhZGVyIG9mXG4gICB0aGUgT0NhbWwgY29tcGlsZXIuKSAqKVxubW9kdWxlIEhhc2ggPSBzdHJ1Y3RcbiAgZXh0ZXJuYWwgaGFzaCA6IHN0cmluZyAtPiBpbnQgPSBcIkJhc2VfaGFzaF9zdHJpbmdcIiBbQEBub2FsbG9jXVxuZW5kXG5cbigqIFtpbmNsdWRlIEhhc2hdIHRvIG1ha2UgdGhlIFtleHRlcm5hbF0gdmVyc2lvbiBvdmVycmlkZSB0aGUgW2hhc2hdIGZyb21cbiAgIFtIYXNoYWJsZS5NYWtlX2JpbmFibGVdLCBzbyB0aGF0IHdlIGdldCBhIGxpdHRsZSBiaXQgb2YgYSBzcGVlZHVwIGJ5IGV4cG9zaW5nIGl0IGFzXG4gICBleHRlcm5hbCBpbiB0aGUgbWxpLiAqKVxubGV0IF8gPSBoYXNoXG5cbmluY2x1ZGUgSGFzaFxuXG4oKiBmb3IgaW50ZXJhY3RpdmUgdG9wLWxldmVscyAtLSBtb2R1bGVzIGRlcml2aW5nIGZyb20gU3RyaW5nIHNob3VsZCBoYXZlIFN0cmluZydzIHByZXR0eVxuICAgcHJpbnRlci4gKilcbmxldCBwcCBwcGYgc3RyaW5nID0gQ2FtbC5Gb3JtYXQuZnByaW50ZiBwcGYgXCIlU1wiIHN0cmluZ1xubGV0IG9mX2NoYXIgYyA9IG1ha2UgMSBjXG5cbmxldCBvZl9jaGFyX2xpc3QgbCA9XG4gIGxldCB0ID0gQnl0ZXMuY3JlYXRlIChMaXN0Lmxlbmd0aCBsKSBpblxuICBMaXN0Lml0ZXJpIGwgfmY6KGZ1biBpIGMgLT4gQnl0ZXMuc2V0IHQgaSBjKTtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTp0XG47O1xuXG5tb2R1bGUgRXNjYXBpbmcgPSBzdHJ1Y3RcbiAgKCogSWYgdGhpcyBpcyBjaGFuZ2VkLCBtYWtlIHN1cmUgdG8gdXBkYXRlIFtlc2NhcGVdLCB3aGljaCBhdHRlbXB0cyB0byBlbnN1cmUgYWxsIHRoZVxuICAgICBpbnZhcmlhbnRzIGNoZWNrZWQgaGVyZS4gICopXG4gIGxldCBidWlsZF9hbmRfdmFsaWRhdGVfZXNjYXBld29ydGh5X21hcCBlc2NhcGV3b3J0aHlfbWFwIGVzY2FwZV9jaGFyIGZ1bmMgPVxuICAgIGxldCBlc2NhcGV3b3J0aHlfbWFwID1cbiAgICAgIGlmIExpc3QuQXNzb2MubWVtIGVzY2FwZXdvcnRoeV9tYXAgfmVxdWFsOkNoYXIuZXF1YWwgZXNjYXBlX2NoYXJcbiAgICAgIHRoZW4gZXNjYXBld29ydGh5X21hcFxuICAgICAgZWxzZSAoZXNjYXBlX2NoYXIsIGVzY2FwZV9jaGFyKSA6OiBlc2NhcGV3b3J0aHlfbWFwXG4gICAgaW5cbiAgICBsZXQgYXJyID0gQXJyYXkuY3JlYXRlIH5sZW46MjU2ICgtMSkgaW5cbiAgICBsZXQgdmFscyA9IEFycmF5LmNyZWF0ZSB+bGVuOjI1NiBmYWxzZSBpblxuICAgIGxldCByZWMgbG9vcCA9IGZ1bmN0aW9uXG4gICAgICB8IFtdIC0+IE9rIGFyclxuICAgICAgfCAoY19mcm9tLCBjX3RvKSA6OiBsIC0+XG4gICAgICAgIGxldCBrLCB2ID1cbiAgICAgICAgICBtYXRjaCBmdW5jIHdpdGhcbiAgICAgICAgICB8IGBFc2NhcGUgLT4gQ2hhci50b19pbnQgY19mcm9tLCBjX3RvXG4gICAgICAgICAgfCBgVW5lc2NhcGUgLT4gQ2hhci50b19pbnQgY190bywgY19mcm9tXG4gICAgICAgIGluXG4gICAgICAgIGlmIGFyci4oaykgPD4gLTEgfHwgdmFscy4oQ2hhci50b19pbnQgdilcbiAgICAgICAgdGhlblxuICAgICAgICAgIE9yX2Vycm9yLmVycm9yX3NcbiAgICAgICAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgICAgICAgIFwiZXNjYXBld29ydGh5X21hcCBub3Qgb25lLXRvLW9uZVwiXG4gICAgICAgICAgICAgICBbIFwiY19mcm9tXCIsIHNleHBfb2ZfY2hhciBjX2Zyb21cbiAgICAgICAgICAgICAgIDsgXCJjX3RvXCIsIHNleHBfb2ZfY2hhciBjX3RvXG4gICAgICAgICAgICAgICA7ICggXCJlc2NhcGV3b3J0aHlfbWFwXCJcbiAgICAgICAgICAgICAgICAgLCBzZXhwX29mX2xpc3QgKHNleHBfb2ZfcGFpciBzZXhwX29mX2NoYXIgc2V4cF9vZl9jaGFyKSBlc2NhcGV3b3J0aHlfbWFwXG4gICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgIF0pXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIGFyci4oaykgPC0gQ2hhci50b19pbnQgdjtcbiAgICAgICAgICB2YWxzLihDaGFyLnRvX2ludCB2KSA8LSB0cnVlO1xuICAgICAgICAgIGxvb3AgbClcbiAgICBpblxuICAgIGxvb3AgZXNjYXBld29ydGh5X21hcFxuICA7O1xuXG4gIGxldCBlc2NhcGVfZ2VuIH5lc2NhcGV3b3J0aHlfbWFwIH5lc2NhcGVfY2hhciA9XG4gICAgbWF0Y2ggYnVpbGRfYW5kX3ZhbGlkYXRlX2VzY2FwZXdvcnRoeV9tYXAgZXNjYXBld29ydGh5X21hcCBlc2NhcGVfY2hhciBgRXNjYXBlIHdpdGhcbiAgICB8IEVycm9yIF8gYXMgeCAtPiB4XG4gICAgfCBPayBlc2NhcGV3b3J0aHkgLT5cbiAgICAgIE9rXG4gICAgICAgIChmdW4gc3JjIC0+XG4gICAgICAgICAgICgqIGNhbGN1bGF0ZSBhIGxpc3Qgb2YgKGluZGV4IG9mIGNoYXIgdG8gZXNjYXBlICogZXNjYXBlZCBjaGFyKSBmaXJzdCwgdGhlIG9yZGVyXG4gICAgICAgICAgICAgIGlzIGZyb20gdGFpbCB0byBoZWFkICopXG4gICAgICAgICAgIGxldCB0b19lc2NhcGVfbGVuID0gcmVmIDAgaW5cbiAgICAgICAgICAgbGV0IHRvX2VzY2FwZSA9XG4gICAgICAgICAgICAgZm9sZGkgc3JjIH5pbml0OltdIH5mOihmdW4gaSBhY2MgYyAtPlxuICAgICAgICAgICAgICAgbWF0Y2ggZXNjYXBld29ydGh5LihDaGFyLnRvX2ludCBjKSB3aXRoXG4gICAgICAgICAgICAgICB8IC0xIC0+IGFjY1xuICAgICAgICAgICAgICAgfCBuIC0+XG4gICAgICAgICAgICAgICAgICgqIChpbmRleCBvZiBjaGFyIHRvIGVzY2FwZSAqIGVzY2FwZWQgY2hhcikgKilcbiAgICAgICAgICAgICAgICAgaW5jciB0b19lc2NhcGVfbGVuO1xuICAgICAgICAgICAgICAgICAoaSwgQ2hhci51bnNhZmVfb2ZfaW50IG4pIDo6IGFjYylcbiAgICAgICAgICAgaW5cbiAgICAgICAgICAgbWF0Y2ggdG9fZXNjYXBlIHdpdGhcbiAgICAgICAgICAgfCBbXSAtPiBzcmNcbiAgICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAgKCogW3RvX2VzY2FwZV0gZGl2aWRlIFtzcmNdIHRvIFtMaXN0Lmxlbmd0aCB0b19lc2NhcGUgKyAxXSBwaWVjZXMgc2VwYXJhdGVkIGJ5XG4gICAgICAgICAgICAgICAgdGhlIGNoYXJzIHRvIGVzY2FwZS5cblxuICAgICAgICAgICAgICAgIExldHMgdGFrZVxuICAgICAgICAgICAgICAgIHtbXG4gICAgICAgICAgICAgICAgICBlc2NhcGVfZ2VuX2V4blxuICAgICAgICAgICAgICAgICAgICB+ZXNjYXBld29ydGh5X21hcDpbKCdhJywgJ0EnKTsgKCdiJywgJ0InKTsgKCdjJywgJ0MnKV1cbiAgICAgICAgICAgICAgICAgICAgfmVzY2FwZV9jaGFyOidfJ1xuICAgICAgICAgICAgICAgIF19XG4gICAgICAgICAgICAgICAgZm9yIGV4YW1wbGUsIGFuZCBhc3N1bWUgdGhlIHN0cmluZyB0byBlc2NhcGUgaXNcblxuICAgICAgICAgICAgICAgIFwiMDAwYTExMWIyMjJjMzMzXCJcblxuICAgICAgICAgICAgICAgIHRoZW4gW3RvX2VzY2FwZV0gaXMgWygxMSwgJ0MnKTsgKDcsICdCJyk7ICgzLCAnQScpXS5cblxuICAgICAgICAgICAgICAgIFRoZW4gd2UgY3JlYXRlIGEgW2RzdF0gb2YgbGVuZ3RoIFtsZW5ndGggc3JjICsgM10gdG8gc3RvcmUgdGhlXG4gICAgICAgICAgICAgICAgcmVzdWx0LCBjb3B5IHBpZWNlIFwiMzMzXCIgdG8gW2RzdF0gZGlyZWN0bHksIHRoZW4gY29weSAnXycgYW5kICdDJyB0byBbZHN0XTtcbiAgICAgICAgICAgICAgICB0aGVuIG1vdmUgb24gdG8gbmV4dDsgYWZ0ZXIgMyBpdGVyYXRpb25zLCBjb3B5IHBpZWNlIFwiMDAwXCIgYW5kIHdlIGFyZSBkb25lLlxuXG4gICAgICAgICAgICAgICAgRmluYWxseSB0aGUgcmVzdWx0IHdpbGwgYmVcblxuICAgICAgICAgICAgICAgIFwiMDAwX0ExMTFfQjIyMl9DMzMzXCIgKilcbiAgICAgICAgICAgICBsZXQgc3JjX2xlbiA9IGxlbmd0aCBzcmMgaW5cbiAgICAgICAgICAgICBsZXQgZHN0X2xlbiA9IHNyY19sZW4gKyAhdG9fZXNjYXBlX2xlbiBpblxuICAgICAgICAgICAgIGxldCBkc3QgPSBCeXRlcy5jcmVhdGUgZHN0X2xlbiBpblxuICAgICAgICAgICAgIGxldCByZWMgbG9vcCBsYXN0X2lkeCBsYXN0X2RzdF9wb3MgPSBmdW5jdGlvblxuICAgICAgICAgICAgICAgfCBbXSAtPlxuICAgICAgICAgICAgICAgICAoKiBjb3B5IFwiMDAwXCIgYXQgbGFzdCAqKVxuICAgICAgICAgICAgICAgICBCeXRlcy5ibGl0X3N0cmluZyB+c3JjIH5zcmNfcG9zOjAgfmRzdCB+ZHN0X3BvczowIH5sZW46bGFzdF9pZHhcbiAgICAgICAgICAgICAgIHwgKGlkeCwgZXNjYXBlZF9jaGFyKSA6OiB0b19lc2NhcGUgLT5cbiAgICAgICAgICAgICAgICAgKCpbaWR4XSA9IHRoZSBjaGFyIHRvIGVzY2FwZSopXG4gICAgICAgICAgICAgICAgICgqIHRha2UgZmlyc3QgaXRlcmF0aW9uIGZvciBleGFtcGxlICopXG4gICAgICAgICAgICAgICAgICgqIGNhbGN1bGF0ZSBsZW5ndGggb2YgXCIzMzNcIiwgbWludXMgMSBiZWNhdXNlIHdlIGRvbid0IGNvcHkgJ2MnICopXG4gICAgICAgICAgICAgICAgIGxldCBsZW4gPSBsYXN0X2lkeCAtIGlkeCAtIDEgaW5cbiAgICAgICAgICAgICAgICAgKCogc2V0IHRoZSBkc3RfcG9zIHRvIGNvcHkgdG8gKilcbiAgICAgICAgICAgICAgICAgbGV0IGRzdF9wb3MgPSBsYXN0X2RzdF9wb3MgLSBsZW4gaW5cbiAgICAgICAgICAgICAgICAgKCogY29weSBcIjMzM1wiLCBzZXQgW3NyY19wb3NdIHRvIFtpZHggKyAxXSB0byBza2lwICdjJyAqKVxuICAgICAgICAgICAgICAgICBCeXRlcy5ibGl0X3N0cmluZyB+c3JjIH5zcmNfcG9zOihpZHggKyAxKSB+ZHN0IH5kc3RfcG9zIH5sZW47XG4gICAgICAgICAgICAgICAgICgqIGJhY2tvZmYgW2RzdF9wb3NdIGJ5IDIgdG8gY29weSAnXycgYW5kICdDJyAqKVxuICAgICAgICAgICAgICAgICBsZXQgZHN0X3BvcyA9IGRzdF9wb3MgLSAyIGluXG4gICAgICAgICAgICAgICAgIEJ5dGVzLnNldCBkc3QgZHN0X3BvcyBlc2NhcGVfY2hhcjtcbiAgICAgICAgICAgICAgICAgQnl0ZXMuc2V0IGRzdCAoZHN0X3BvcyArIDEpIGVzY2FwZWRfY2hhcjtcbiAgICAgICAgICAgICAgICAgbG9vcCBpZHggZHN0X3BvcyB0b19lc2NhcGVcbiAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICgqIHNldCBbbGFzdF9kc3RfcG9zXSBhbmQgW2xhc3RfaWR4XSB0byBsZW5ndGggb2YgW2RzdF0gYW5kIFtzcmNdIGZpcnN0ICopXG4gICAgICAgICAgICAgbG9vcCBzcmNfbGVuIGRzdF9sZW4gdG9fZXNjYXBlO1xuICAgICAgICAgICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6ZHN0KVxuICA7O1xuXG4gIGxldCBlc2NhcGVfZ2VuX2V4biB+ZXNjYXBld29ydGh5X21hcCB+ZXNjYXBlX2NoYXIgPVxuICAgIE9yX2Vycm9yLm9rX2V4biAoZXNjYXBlX2dlbiB+ZXNjYXBld29ydGh5X21hcCB+ZXNjYXBlX2NoYXIpIHw+IHN0YWdlXG4gIDs7XG5cbiAgbGV0IGVzY2FwZSB+ZXNjYXBld29ydGh5IH5lc2NhcGVfY2hhciA9XG4gICAgKCogRm9yIFtlc2NhcGVfZ2VuX2V4bl0sIHdlIGRvbid0IGtub3cgaG93IHRvIGZpeCBpbnZhbGlkIGVzY2FwZXdvcnRoeV9tYXAgc28gd2UgaGF2ZVxuICAgICAgIHRvIHJhaXNlIGV4Y2VwdGlvbjsgYnV0IGluIHRoaXMgY2FzZSwgd2Uga25vdyBob3cgdG8gZml4IGR1cGxpY2F0ZWQgZWxlbWVudHMgaW5cbiAgICAgICBlc2NhcGV3b3J0aHkgbGlzdCwgc28gd2UganVzdCBmaXggaXQgaW5zdGVhZCBvZiByYWlzaW5nIGV4Y2VwdGlvbiB0byBtYWtlIHRoaXNcbiAgICAgICBmdW5jdGlvbiBlYXNpZXIgdG8gdXNlLiAgKilcbiAgICBsZXQgZXNjYXBld29ydGh5X21hcCA9XG4gICAgICBlc2NhcGV3b3J0aHlcbiAgICAgIHw+IExpc3QuZGVkdXBfYW5kX3NvcnQgfmNvbXBhcmU6Q2hhci5jb21wYXJlXG4gICAgICB8PiBMaXN0Lm1hcCB+ZjooZnVuIGMgLT4gYywgYylcbiAgICBpblxuICAgIGVzY2FwZV9nZW5fZXhuIH5lc2NhcGV3b3J0aHlfbWFwIH5lc2NhcGVfY2hhclxuICA7O1xuXG4gICgqIEluIGFuIGVzY2FwZWQgc3RyaW5nLCBhbnkgY2hhciBpcyBlaXRoZXIgYEVzY2FwaW5nLCBgRXNjYXBlZCBvciBgTGl0ZXJhbC4gRm9yXG4gICAgIGV4YW1wbGUsIHRoZSBlc2NhcGUgc3RhdHVzZXMgb2YgY2hhcnMgaW4gc3RyaW5nIFwiYV9hX19cIiB3aXRoIGVzY2FwZV9jaGFyID0gJ18nIGFyZVxuXG4gICAgIGEgOiBgTGl0ZXJhbFxuICAgICBfIDogYEVzY2FwaW5nXG4gICAgIGEgOiBgRXNjYXBlZFxuICAgICBfIDogYEVzY2FwaW5nXG4gICAgIF8gOiBgRXNjYXBlZFxuXG4gICAgIFt1cGRhdGVfZXNjYXBlX3N0YXR1cyBzdHIgfmVzY2FwZV9jaGFyIGkgcHJldmlvdXNfc3RhdHVzXSBnZXRzIGVzY2FwZSBzdGF0dXMgb2ZcbiAgICAgc3RyLltpXSBiYXNpbmcgb24gZXNjYXBlIHN0YXR1cyBvZiBzdHIuW2kgLSAxXSAqKVxuICBsZXQgdXBkYXRlX2VzY2FwZV9zdGF0dXMgc3RyIH5lc2NhcGVfY2hhciBpID0gZnVuY3Rpb25cbiAgICB8IGBFc2NhcGluZyAtPiBgRXNjYXBlZFxuICAgIHwgYExpdGVyYWwgfCBgRXNjYXBlZCAtPlxuICAgICAgaWYgQ2hhci5lcXVhbCBzdHIuW2ldIGVzY2FwZV9jaGFyIHRoZW4gYEVzY2FwaW5nIGVsc2UgYExpdGVyYWxcbiAgOztcblxuICBsZXQgdW5lc2NhcGVfZ2VuIH5lc2NhcGV3b3J0aHlfbWFwIH5lc2NhcGVfY2hhciA9XG4gICAgbWF0Y2ggYnVpbGRfYW5kX3ZhbGlkYXRlX2VzY2FwZXdvcnRoeV9tYXAgZXNjYXBld29ydGh5X21hcCBlc2NhcGVfY2hhciBgVW5lc2NhcGUgd2l0aFxuICAgIHwgRXJyb3IgXyBhcyB4IC0+IHhcbiAgICB8IE9rIGVzY2FwZXdvcnRoeSAtPlxuICAgICAgT2tcbiAgICAgICAgKGZ1biBzcmMgLT5cbiAgICAgICAgICAgKCogQ29udGludWUgdGhlIGV4YW1wbGUgaW4gW2VzY2FwZV9nZW5fZXhuXSwgbm93IHdlIHVuZXNjYXBlXG5cbiAgICAgICAgICAgICAgXCIwMDBfQTExMV9CMjIyX0MzMzNcIlxuXG4gICAgICAgICAgICAgIGJhY2sgdG9cblxuICAgICAgICAgICAgICBcIjAwMGExMTFiMjIyYzMzM1wiXG5cbiAgICAgICAgICAgICAgVGhlbiBbdG9fdW5lc2NhcGVdIGlzIFsxNDsgOTsgNF0sIHdoaWNoIGlzIGluZGV4ZXMgb2YgJ18ncy5cblxuICAgICAgICAgICAgICBUaGVuIHdlIGNyZWF0ZSBhIHN0cmluZyBbZHN0XSB0byBzdG9yZSB0aGUgcmVzdWx0LCBjb3B5IFwiMzMzXCIgdG8gaXQsIHRoZW4gY29weVxuICAgICAgICAgICAgICAnYycsIHRoZW4gbW92ZSBvbiB0byBuZXh0IGl0ZXJhdGlvbi4gQWZ0ZXIgMyBpdGVyYXRpb25zIGNvcHkgXCIwMDBcIiBhbmQgd2UgYXJlXG4gICAgICAgICAgICAgIGRvbmUuICAqKVxuICAgICAgICAgICAoKiBpbmRleGVzIG9mIGVzY2FwZSBjaGFycyAqKVxuICAgICAgICAgICBsZXQgdG9fdW5lc2NhcGUgPVxuICAgICAgICAgICAgIGxldCByZWMgbG9vcCBpIHN0YXR1cyBhY2MgPVxuICAgICAgICAgICAgICAgaWYgaSA+PSBsZW5ndGggc3JjXG4gICAgICAgICAgICAgICB0aGVuIGFjY1xuICAgICAgICAgICAgICAgZWxzZSAoXG4gICAgICAgICAgICAgICAgIGxldCBzdGF0dXMgPSB1cGRhdGVfZXNjYXBlX3N0YXR1cyBzcmMgfmVzY2FwZV9jaGFyIGkgc3RhdHVzIGluXG4gICAgICAgICAgICAgICAgIGxvb3BcbiAgICAgICAgICAgICAgICAgICAoaSArIDEpXG4gICAgICAgICAgICAgICAgICAgc3RhdHVzXG4gICAgICAgICAgICAgICAgICAgKG1hdGNoIHN0YXR1cyB3aXRoXG4gICAgICAgICAgICAgICAgICAgIHwgYEVzY2FwaW5nIC0+IGkgOjogYWNjXG4gICAgICAgICAgICAgICAgICAgIHwgYEVzY2FwZWQgfCBgTGl0ZXJhbCAtPiBhY2MpKVxuICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgbG9vcCAwIGBMaXRlcmFsIFtdXG4gICAgICAgICAgIGluXG4gICAgICAgICAgIG1hdGNoIHRvX3VuZXNjYXBlIHdpdGhcbiAgICAgICAgICAgfCBbXSAtPiBzcmNcbiAgICAgICAgICAgfCBpZHggOjogdG9fdW5lc2NhcGUnIC0+XG4gICAgICAgICAgICAgbGV0IGRzdCA9IEJ5dGVzLmNyZWF0ZSAobGVuZ3RoIHNyYyAtIExpc3QubGVuZ3RoIHRvX3VuZXNjYXBlKSBpblxuICAgICAgICAgICAgIGxldCByZWMgbG9vcCBsYXN0X2lkeCBsYXN0X2RzdF9wb3MgPSBmdW5jdGlvblxuICAgICAgICAgICAgICAgfCBbXSAtPlxuICAgICAgICAgICAgICAgICAoKiBjb3B5IFwiMDAwXCIgYXQgbGFzdCAqKVxuICAgICAgICAgICAgICAgICBCeXRlcy5ibGl0X3N0cmluZyB+c3JjIH5zcmNfcG9zOjAgfmRzdCB+ZHN0X3BvczowIH5sZW46bGFzdF9pZHhcbiAgICAgICAgICAgICAgIHwgaWR4IDo6IHRvX3VuZXNjYXBlIC0+XG4gICAgICAgICAgICAgICAgICgqIFtpZHhdID0gaW5kZXggb2YgZXNjYXBpbmcgY2hhciAqKVxuICAgICAgICAgICAgICAgICAoKiB0YWtlIDFzdCBpdGVyYXRpb24gYXMgZXhhbXBsZSwgY2FsY3VsYXRlIHRoZSBsZW5ndGggb2YgXCIzMzNcIiwgbWludXMgMiB0b1xuICAgICAgICAgICAgICAgICAgICBza2lwICdfQycgKilcbiAgICAgICAgICAgICAgICAgbGV0IGxlbiA9IGxhc3RfaWR4IC0gaWR4IC0gMiBpblxuICAgICAgICAgICAgICAgICAoKiBwb2ludCBbZHN0X3Bvc10gdG8gdGhlIHBvc2l0aW9uIHRvIGNvcHkgXCIzMzNcIiB0byAqKVxuICAgICAgICAgICAgICAgICBsZXQgZHN0X3BvcyA9IGxhc3RfZHN0X3BvcyAtIGxlbiBpblxuICAgICAgICAgICAgICAgICAoKiBjb3B5IFwiMzMzXCIgKilcbiAgICAgICAgICAgICAgICAgQnl0ZXMuYmxpdF9zdHJpbmcgfnNyYyB+c3JjX3BvczooaWR4ICsgMikgfmRzdCB+ZHN0X3BvcyB+bGVuO1xuICAgICAgICAgICAgICAgICAoKiBiYWNrb2ZmIFtkc3RfcG9zXSBieSAxIHRvIGNvcHkgJ2MnICopXG4gICAgICAgICAgICAgICAgIGxldCBkc3RfcG9zID0gZHN0X3BvcyAtIDEgaW5cbiAgICAgICAgICAgICAgICAgQnl0ZXMuc2V0XG4gICAgICAgICAgICAgICAgICAgZHN0XG4gICAgICAgICAgICAgICAgICAgZHN0X3Bvc1xuICAgICAgICAgICAgICAgICAgIChtYXRjaCBlc2NhcGV3b3J0aHkuKENoYXIudG9faW50IHNyYy5baWR4ICsgMV0pIHdpdGhcbiAgICAgICAgICAgICAgICAgICAgfCAtMSAtPiBzcmMuW2lkeCArIDFdXG4gICAgICAgICAgICAgICAgICAgIHwgbiAtPiBDaGFyLnVuc2FmZV9vZl9pbnQgbik7XG4gICAgICAgICAgICAgICAgICgqIHVwZGF0ZSBbbGFzdF9kc3RfcG9zXSBhbmQgW2xhc3RfaWR4XSAqKVxuICAgICAgICAgICAgICAgICBsb29wIGlkeCBkc3RfcG9zIHRvX3VuZXNjYXBlXG4gICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICBpZiBpZHggPCBsZW5ndGggc3JjIC0gMVxuICAgICAgICAgICAgIHRoZW5cbiAgICAgICAgICAgICAgICgqIHNldCBbbGFzdF9kc3RfcG9zXSBhbmQgW2xhc3RfaWR4XSB0byBsZW5ndGggb2YgW2RzdF0gYW5kIFtzcmNdICopXG4gICAgICAgICAgICAgICBsb29wIChsZW5ndGggc3JjKSAoQnl0ZXMubGVuZ3RoIGRzdCkgdG9fdW5lc2NhcGVcbiAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAoKiBmb3IgZXNjYXBlZCBzdHJpbmcgZW5kaW5nIHdpdGggYW4gZXNjYXBpbmcgY2hhciBsaWtlIFwiMDAwX1wiLCBqdXN0IGlnbm9yZVxuICAgICAgICAgICAgICAgICAgdGhlIGxhc3QgZXNjYXBpbmcgY2hhciAqKVxuICAgICAgICAgICAgICAgbG9vcCAobGVuZ3RoIHNyYyAtIDEpIChCeXRlcy5sZW5ndGggZHN0KSB0b191bmVzY2FwZSc7XG4gICAgICAgICAgICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTpkc3QpXG4gIDs7XG5cbiAgbGV0IHVuZXNjYXBlX2dlbl9leG4gfmVzY2FwZXdvcnRoeV9tYXAgfmVzY2FwZV9jaGFyID1cbiAgICBPcl9lcnJvci5va19leG4gKHVuZXNjYXBlX2dlbiB+ZXNjYXBld29ydGh5X21hcCB+ZXNjYXBlX2NoYXIpIHw+IHN0YWdlXG4gIDs7XG5cbiAgbGV0IHVuZXNjYXBlIH5lc2NhcGVfY2hhciA9IHVuZXNjYXBlX2dlbl9leG4gfmVzY2FwZXdvcnRoeV9tYXA6W10gfmVzY2FwZV9jaGFyXG5cbiAgbGV0IHByZWNlZGluZ19lc2NhcGVfY2hhcnMgc3RyIH5lc2NhcGVfY2hhciBwb3MgPVxuICAgIGxldCByZWMgbG9vcCBwIGNudCA9XG4gICAgICBpZiBwIDwgMCB8fCBDaGFyLiggPD4gKSBzdHIuW3BdIGVzY2FwZV9jaGFyIHRoZW4gY250IGVsc2UgbG9vcCAocCAtIDEpIChjbnQgKyAxKVxuICAgIGluXG4gICAgbG9vcCAocG9zIC0gMSkgMFxuICA7O1xuXG4gICgqIEluIGFuIGVzY2FwZWQgc3RyaW5nLCBhbnkgY2hhciBpcyBlaXRoZXIgYEVzY2FwaW5nLCBgRXNjYXBlZCBvciBgTGl0ZXJhbC4gRm9yXG4gICAgIGV4YW1wbGUsIHRoZSBlc2NhcGUgc3RhdHVzZXMgb2YgY2hhcnMgaW4gc3RyaW5nIFwiYV9hX19cIiB3aXRoIGVzY2FwZV9jaGFyID0gJ18nIGFyZVxuXG4gICAgIGEgOiBgTGl0ZXJhbFxuICAgICBfIDogYEVzY2FwaW5nXG4gICAgIGEgOiBgRXNjYXBlZFxuICAgICBfIDogYEVzY2FwaW5nXG4gICAgIF8gOiBgRXNjYXBlZFxuXG4gICAgIFt1cGRhdGVfZXNjYXBlX3N0YXR1cyBzdHIgfmVzY2FwZV9jaGFyIGkgcHJldmlvdXNfc3RhdHVzXSBnZXRzIGVzY2FwZSBzdGF0dXMgb2ZcbiAgICAgc3RyLltpXSBiYXNpbmcgb24gZXNjYXBlIHN0YXR1cyBvZiBzdHIuW2kgLSAxXSAqKVxuICBsZXQgdXBkYXRlX2VzY2FwZV9zdGF0dXMgc3RyIH5lc2NhcGVfY2hhciBpID0gZnVuY3Rpb25cbiAgICB8IGBFc2NhcGluZyAtPiBgRXNjYXBlZFxuICAgIHwgYExpdGVyYWwgfCBgRXNjYXBlZCAtPlxuICAgICAgaWYgQ2hhci5lcXVhbCBzdHIuW2ldIGVzY2FwZV9jaGFyIHRoZW4gYEVzY2FwaW5nIGVsc2UgYExpdGVyYWxcbiAgOztcblxuICBsZXQgZXNjYXBlX3N0YXR1cyBzdHIgfmVzY2FwZV9jaGFyIHBvcyA9XG4gICAgbGV0IG9kZCA9IHByZWNlZGluZ19lc2NhcGVfY2hhcnMgc3RyIH5lc2NhcGVfY2hhciBwb3MgbW9kIDIgPSAxIGluXG4gICAgbWF0Y2ggb2RkLCBDaGFyLmVxdWFsIHN0ci5bcG9zXSBlc2NhcGVfY2hhciB3aXRoXG4gICAgfCB0cnVlLCAodHJ1ZSB8IGZhbHNlKSAtPiBgRXNjYXBlZFxuICAgIHwgZmFsc2UsIHRydWUgLT4gYEVzY2FwaW5nXG4gICAgfCBmYWxzZSwgZmFsc2UgLT4gYExpdGVyYWxcbiAgOztcblxuICBsZXQgY2hlY2tfYm91bmQgc3RyIHBvcyBmdW5jdGlvbl9uYW1lID1cbiAgICBpZiBwb3MgPj0gbGVuZ3RoIHN0ciB8fCBwb3MgPCAwIHRoZW4gaW52YWxpZF9hcmdmIFwiJXM6IG91dCBvZiBib3VuZHNcIiBmdW5jdGlvbl9uYW1lICgpXG4gIDs7XG5cbiAgbGV0IGlzX2NoYXJfZXNjYXBpbmcgc3RyIH5lc2NhcGVfY2hhciBwb3MgPVxuICAgIGNoZWNrX2JvdW5kIHN0ciBwb3MgXCJpc19jaGFyX2VzY2FwaW5nXCI7XG4gICAgbWF0Y2ggZXNjYXBlX3N0YXR1cyBzdHIgfmVzY2FwZV9jaGFyIHBvcyB3aXRoXG4gICAgfCBgRXNjYXBpbmcgLT4gdHJ1ZVxuICAgIHwgYEVzY2FwZWQgfCBgTGl0ZXJhbCAtPiBmYWxzZVxuICA7O1xuXG4gIGxldCBpc19jaGFyX2VzY2FwZWQgc3RyIH5lc2NhcGVfY2hhciBwb3MgPVxuICAgIGNoZWNrX2JvdW5kIHN0ciBwb3MgXCJpc19jaGFyX2VzY2FwZWRcIjtcbiAgICBtYXRjaCBlc2NhcGVfc3RhdHVzIHN0ciB+ZXNjYXBlX2NoYXIgcG9zIHdpdGhcbiAgICB8IGBFc2NhcGVkIC0+IHRydWVcbiAgICB8IGBFc2NhcGluZyB8IGBMaXRlcmFsIC0+IGZhbHNlXG4gIDs7XG5cbiAgbGV0IGlzX2NoYXJfbGl0ZXJhbCBzdHIgfmVzY2FwZV9jaGFyIHBvcyA9XG4gICAgY2hlY2tfYm91bmQgc3RyIHBvcyBcImlzX2NoYXJfbGl0ZXJhbFwiO1xuICAgIG1hdGNoIGVzY2FwZV9zdGF0dXMgc3RyIH5lc2NhcGVfY2hhciBwb3Mgd2l0aFxuICAgIHwgYExpdGVyYWwgLT4gdHJ1ZVxuICAgIHwgYEVzY2FwZWQgfCBgRXNjYXBpbmcgLT4gZmFsc2VcbiAgOztcblxuICBsZXQgaW5kZXhfZnJvbSBzdHIgfmVzY2FwZV9jaGFyIHBvcyBjaGFyID1cbiAgICBjaGVja19ib3VuZCBzdHIgcG9zIFwiaW5kZXhfZnJvbVwiO1xuICAgIGxldCByZWMgbG9vcCBpIHN0YXR1cyA9XG4gICAgICBpZiBpID49IHBvc1xuICAgICAgJiYgKG1hdGNoIHN0YXR1cyB3aXRoXG4gICAgICAgICAgfCBgTGl0ZXJhbCAtPiB0cnVlXG4gICAgICAgICAgfCBgRXNjYXBlZCB8IGBFc2NhcGluZyAtPiBmYWxzZSlcbiAgICAgICYmIENoYXIuZXF1YWwgc3RyLltpXSBjaGFyXG4gICAgICB0aGVuIFNvbWUgaVxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBpID0gaSArIDEgaW5cbiAgICAgICAgaWYgaSA+PSBsZW5ndGggc3RyXG4gICAgICAgIHRoZW4gTm9uZVxuICAgICAgICBlbHNlIGxvb3AgaSAodXBkYXRlX2VzY2FwZV9zdGF0dXMgc3RyIH5lc2NhcGVfY2hhciBpIHN0YXR1cykpXG4gICAgaW5cbiAgICBsb29wIHBvcyAoZXNjYXBlX3N0YXR1cyBzdHIgfmVzY2FwZV9jaGFyIHBvcylcbiAgOztcblxuICBsZXQgaW5kZXhfZnJvbV9leG4gc3RyIH5lc2NhcGVfY2hhciBwb3MgY2hhciA9XG4gICAgbWF0Y2ggaW5kZXhfZnJvbSBzdHIgfmVzY2FwZV9jaGFyIHBvcyBjaGFyIHdpdGhcbiAgICB8IE5vbmUgLT5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgICBcImluZGV4X2Zyb21fZXhuOiBub3QgZm91bmRcIlxuICAgICAgICAgICBbIFwic3RyXCIsIHNleHBfb2ZfdCBzdHJcbiAgICAgICAgICAgOyBcImVzY2FwZV9jaGFyXCIsIHNleHBfb2ZfY2hhciBlc2NhcGVfY2hhclxuICAgICAgICAgICA7IFwicG9zXCIsIHNleHBfb2ZfaW50IHBvc1xuICAgICAgICAgICA7IFwiY2hhclwiLCBzZXhwX29mX2NoYXIgY2hhclxuICAgICAgICAgICBdKVxuICAgIHwgU29tZSBwb3MgLT4gcG9zXG4gIDs7XG5cbiAgbGV0IGluZGV4IHN0ciB+ZXNjYXBlX2NoYXIgY2hhciA9IGluZGV4X2Zyb20gc3RyIH5lc2NhcGVfY2hhciAwIGNoYXJcbiAgbGV0IGluZGV4X2V4biBzdHIgfmVzY2FwZV9jaGFyIGNoYXIgPSBpbmRleF9mcm9tX2V4biBzdHIgfmVzY2FwZV9jaGFyIDAgY2hhclxuXG4gIGxldCByaW5kZXhfZnJvbSBzdHIgfmVzY2FwZV9jaGFyIHBvcyBjaGFyID1cbiAgICBjaGVja19ib3VuZCBzdHIgcG9zIFwicmluZGV4X2Zyb21cIjtcbiAgICAoKiBpZiB0aGUgdGFyZ2V0IGNoYXIgaXMgdGhlIHNhbWUgYXMgW2VzY2FwZV9jaGFyXSwgd2UgaGF2ZSBubyB3YXkgdG8gZGV0ZXJtaW5lIHdoaWNoXG4gICAgICAgZXNjYXBlX2NoYXIgaXMgbGl0ZXJhbCwgc28ganVzdCByZXR1cm4gTm9uZSAqKVxuICAgIGlmIENoYXIuZXF1YWwgY2hhciBlc2NhcGVfY2hhclxuICAgIHRoZW4gTm9uZVxuICAgIGVsc2UgKFxuICAgICAgbGV0IHJlYyBsb29wIHBvcyA9XG4gICAgICAgIGlmIHBvcyA8IDBcbiAgICAgICAgdGhlbiBOb25lXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIGxldCBlc2NhcGVfY2hhcnMgPSBwcmVjZWRpbmdfZXNjYXBlX2NoYXJzIHN0ciB+ZXNjYXBlX2NoYXIgcG9zIGluXG4gICAgICAgICAgaWYgZXNjYXBlX2NoYXJzIG1vZCAyID0gMCAmJiBDaGFyLmVxdWFsIHN0ci5bcG9zXSBjaGFyXG4gICAgICAgICAgdGhlbiBTb21lIHBvc1xuICAgICAgICAgIGVsc2UgbG9vcCAocG9zIC0gZXNjYXBlX2NoYXJzIC0gMSkpXG4gICAgICBpblxuICAgICAgbG9vcCBwb3MpXG4gIDs7XG5cbiAgbGV0IHJpbmRleF9mcm9tX2V4biBzdHIgfmVzY2FwZV9jaGFyIHBvcyBjaGFyID1cbiAgICBtYXRjaCByaW5kZXhfZnJvbSBzdHIgfmVzY2FwZV9jaGFyIHBvcyBjaGFyIHdpdGhcbiAgICB8IE5vbmUgLT5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgICBcInJpbmRleF9mcm9tX2V4bjogbm90IGZvdW5kXCJcbiAgICAgICAgICAgWyBcInN0clwiLCBzZXhwX29mX3Qgc3RyXG4gICAgICAgICAgIDsgXCJlc2NhcGVfY2hhclwiLCBzZXhwX29mX2NoYXIgZXNjYXBlX2NoYXJcbiAgICAgICAgICAgOyBcInBvc1wiLCBzZXhwX29mX2ludCBwb3NcbiAgICAgICAgICAgOyBcImNoYXJcIiwgc2V4cF9vZl9jaGFyIGNoYXJcbiAgICAgICAgICAgXSlcbiAgICB8IFNvbWUgcG9zIC0+IHBvc1xuICA7O1xuXG4gIGxldCByaW5kZXggc3RyIH5lc2NhcGVfY2hhciBjaGFyID1cbiAgICBpZiBpc19lbXB0eSBzdHIgdGhlbiBOb25lIGVsc2UgcmluZGV4X2Zyb20gc3RyIH5lc2NhcGVfY2hhciAobGVuZ3RoIHN0ciAtIDEpIGNoYXJcbiAgOztcblxuICBsZXQgcmluZGV4X2V4biBzdHIgfmVzY2FwZV9jaGFyIGNoYXIgPVxuICAgIHJpbmRleF9mcm9tX2V4biBzdHIgfmVzY2FwZV9jaGFyIChsZW5ndGggc3RyIC0gMSkgY2hhclxuICA7O1xuXG4gICgqIFtzcGxpdF9nZW4gc3RyIH5lc2NhcGVfY2hhciB+b25dIHdvcmtzIHNpbWlsYXJseSB0byBbU3RyaW5nLnNwbGl0X2dlbl0sIHdpdGggYW5cbiAgICAgYWRkaXRpb25hbCByZXF1aXJlbWVudDogb25seSBzcGxpdCBvbiBsaXRlcmFsIGNoYXJzLCBub3QgZXNjYXBpbmcgb3IgZXNjYXBlZCAqKVxuICBsZXQgc3BsaXRfZ2VuIHN0ciB+ZXNjYXBlX2NoYXIgfm9uID1cbiAgICBsZXQgaXNfZGVsaW0gPVxuICAgICAgbWF0Y2ggb24gd2l0aFxuICAgICAgfCBgY2hhciBjJyAtPiBmdW4gYyAtPiBDaGFyLmVxdWFsIGMgYydcbiAgICAgIHwgYGNoYXJfbGlzdCBsIC0+IGZ1biBjIC0+IGNoYXJfbGlzdF9tZW0gbCBjXG4gICAgaW5cbiAgICBsZXQgbGVuID0gbGVuZ3RoIHN0ciBpblxuICAgIGxldCByZWMgbG9vcCBhY2Mgc3RhdHVzIGxhc3RfcG9zIHBvcyA9XG4gICAgICBpZiBwb3MgPSBsZW5cbiAgICAgIHRoZW4gTGlzdC5yZXYgKHN1YiBzdHIgfnBvczpsYXN0X3BvcyB+bGVuOihsZW4gLSBsYXN0X3BvcykgOjogYWNjKVxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBzdGF0dXMgPSB1cGRhdGVfZXNjYXBlX3N0YXR1cyBzdHIgfmVzY2FwZV9jaGFyIHBvcyBzdGF0dXMgaW5cbiAgICAgICAgaWYgKG1hdGNoIHN0YXR1cyB3aXRoXG4gICAgICAgICAgfCBgTGl0ZXJhbCAtPiB0cnVlXG4gICAgICAgICAgfCBgRXNjYXBlZCB8IGBFc2NhcGluZyAtPiBmYWxzZSlcbiAgICAgICAgJiYgaXNfZGVsaW0gc3RyLltwb3NdXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIGxldCBzdWJfc3RyID0gc3ViIHN0ciB+cG9zOmxhc3RfcG9zIH5sZW46KHBvcyAtIGxhc3RfcG9zKSBpblxuICAgICAgICAgIGxvb3AgKHN1Yl9zdHIgOjogYWNjKSBzdGF0dXMgKHBvcyArIDEpIChwb3MgKyAxKSlcbiAgICAgICAgZWxzZSBsb29wIGFjYyBzdGF0dXMgbGFzdF9wb3MgKHBvcyArIDEpKVxuICAgIGluXG4gICAgbG9vcCBbXSBgTGl0ZXJhbCAwIDBcbiAgOztcblxuICBsZXQgc3BsaXQgc3RyIH5vbiA9IHNwbGl0X2dlbiBzdHIgfm9uOihgY2hhciBvbilcbiAgbGV0IHNwbGl0X29uX2NoYXJzIHN0ciB+b246Y2hhcnMgPSBzcGxpdF9nZW4gc3RyIH5vbjooYGNoYXJfbGlzdCBjaGFycylcblxuICBsZXQgc3BsaXRfYXQgc3RyIHBvcyA9XG4gICAgc3ViIHN0ciB+cG9zOjAgfmxlbjpwb3MsIHN1YiBzdHIgfnBvczoocG9zICsgMSkgfmxlbjoobGVuZ3RoIHN0ciAtIHBvcyAtIDEpXG4gIDs7XG5cbiAgbGV0IGxzcGxpdDIgc3RyIH5vbiB+ZXNjYXBlX2NoYXIgPVxuICAgIE9wdGlvbi5tYXAgKGluZGV4IHN0ciB+ZXNjYXBlX2NoYXIgb24pIH5mOihmdW4geCAtPiBzcGxpdF9hdCBzdHIgeClcbiAgOztcblxuICBsZXQgcnNwbGl0MiBzdHIgfm9uIH5lc2NhcGVfY2hhciA9XG4gICAgT3B0aW9uLm1hcCAocmluZGV4IHN0ciB+ZXNjYXBlX2NoYXIgb24pIH5mOihmdW4geCAtPiBzcGxpdF9hdCBzdHIgeClcbiAgOztcblxuICBsZXQgbHNwbGl0Ml9leG4gc3RyIH5vbiB+ZXNjYXBlX2NoYXIgPSBzcGxpdF9hdCBzdHIgKGluZGV4X2V4biBzdHIgfmVzY2FwZV9jaGFyIG9uKVxuICBsZXQgcnNwbGl0Ml9leG4gc3RyIH5vbiB+ZXNjYXBlX2NoYXIgPSBzcGxpdF9hdCBzdHIgKHJpbmRleF9leG4gc3RyIH5lc2NhcGVfY2hhciBvbilcblxuICAoKiBbbGFzdF9ub25fZHJvcF9saXRlcmFsXSBhbmQgW2ZpcnN0X25vbl9kcm9wX2xpdGVyYWxdIGFyZSBlaXRoZXIgYm90aCBbTm9uZV0gb3IgYm90aFxuICAgICBbU29tZV0uIElmIFtTb21lXSwgdGhlbiB0aGUgZm9ybWVyIGlzID49IHRoZSBsYXR0ZXIuICopXG4gIGxldCBsYXN0X25vbl9kcm9wX2xpdGVyYWwgfmRyb3AgfmVzY2FwZV9jaGFyIHQgPVxuICAgIHJmaW5kaSB0IH5mOihmdW4gaSBjIC0+XG4gICAgICAobm90IChkcm9wIGMpKVxuICAgICAgfHwgaXNfY2hhcl9lc2NhcGluZyB0IH5lc2NhcGVfY2hhciBpXG4gICAgICB8fCBpc19jaGFyX2VzY2FwZWQgdCB+ZXNjYXBlX2NoYXIgaSlcbiAgOztcblxuICBsZXQgZmlyc3Rfbm9uX2Ryb3BfbGl0ZXJhbCB+ZHJvcCB+ZXNjYXBlX2NoYXIgdCA9XG4gICAgbGZpbmRpIHQgfmY6KGZ1biBpIGMgLT5cbiAgICAgIChub3QgKGRyb3AgYykpXG4gICAgICB8fCBpc19jaGFyX2VzY2FwaW5nIHQgfmVzY2FwZV9jaGFyIGlcbiAgICAgIHx8IGlzX2NoYXJfZXNjYXBlZCB0IH5lc2NhcGVfY2hhciBpKVxuICA7O1xuXG4gIGxldCByc3RyaXBfbGl0ZXJhbCA/KGRyb3AgPSBDaGFyLmlzX3doaXRlc3BhY2UpIHQgfmVzY2FwZV9jaGFyID1cbiAgICBtYXRjaCBsYXN0X25vbl9kcm9wX2xpdGVyYWwgdCB+ZHJvcCB+ZXNjYXBlX2NoYXIgd2l0aFxuICAgIHwgTm9uZSAtPiBcIlwiXG4gICAgfCBTb21lIGkgLT4gaWYgaSA9IGxlbmd0aCB0IC0gMSB0aGVuIHQgZWxzZSBwcmVmaXggdCAoaSArIDEpXG4gIDs7XG5cbiAgbGV0IGxzdHJpcF9saXRlcmFsID8oZHJvcCA9IENoYXIuaXNfd2hpdGVzcGFjZSkgdCB+ZXNjYXBlX2NoYXIgPVxuICAgIG1hdGNoIGZpcnN0X25vbl9kcm9wX2xpdGVyYWwgdCB+ZHJvcCB+ZXNjYXBlX2NoYXIgd2l0aFxuICAgIHwgTm9uZSAtPiBcIlwiXG4gICAgfCBTb21lIDAgLT4gdFxuICAgIHwgU29tZSBuIC0+IGRyb3BfcHJlZml4IHQgblxuICA7O1xuXG4gICgqIFtzdHJpcCB0XSBjb3VsZCBiZSBpbXBsZW1lbnRlZCBhcyBbbHN0cmlwIChyc3RyaXAgdCldLiAgVGhlIGltcGxlbWVudGF0aW9uXG4gICAgIGJlbG93IHNhdmVzIChhdCBsZWFzdCkgYSBmYWN0b3Igb2YgdHdvIGFsbG9jYXRpb24sIGJ5IG9ubHkgYWxsb2NhdGluZyB0aGVcbiAgICAgZmluYWwgcmVzdWx0LiAgVGhpcyBhbHNvIHNhdmVzIHNvbWUgYW1vdW50IG9mIHRpbWUuICopXG4gIGxldCBzdHJpcF9saXRlcmFsID8oZHJvcCA9IENoYXIuaXNfd2hpdGVzcGFjZSkgdCB+ZXNjYXBlX2NoYXIgPVxuICAgIGxldCBsZW5ndGggPSBsZW5ndGggdCBpblxuICAgICgqIHBlcmZvcm1hbmNlIGhhY2s6IGF2b2lkIGNvcHlpbmcgW3RdIGluIGNvbW1vbiBjYXNlcyAqKVxuICAgIGlmIGxlbmd0aCA9IDAgfHwgbm90IChkcm9wIHQuWzBdIHx8IGRyb3AgdC5bbGVuZ3RoIC0gMV0pXG4gICAgdGhlbiB0XG4gICAgZWxzZSAoXG4gICAgICBtYXRjaCBmaXJzdF9ub25fZHJvcF9saXRlcmFsIHQgfmRyb3AgfmVzY2FwZV9jaGFyIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBcIlwiXG4gICAgICB8IFNvbWUgZmlyc3QgLT5cbiAgICAgICAgKG1hdGNoIGxhc3Rfbm9uX2Ryb3BfbGl0ZXJhbCB0IH5kcm9wIH5lc2NhcGVfY2hhciB3aXRoXG4gICAgICAgICB8IE5vbmUgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgICB8IFNvbWUgbGFzdCAtPiBzdWIgdCB+cG9zOmZpcnN0IH5sZW46KGxhc3QgLSBmaXJzdCArIDEpKSlcbiAgOztcbmVuZFxuXG4oKiBPcGVuIHJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBhZnRlciBpbmNsdWRpbmcgZnVuY3RvciBpbnN0YW50aWF0aW9ucyBzbyB0aGV5IGRvIG5vdFxuICAgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpcyBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uXG4gICBmdW5jdGlvbnMgYXJlIGF2YWlsYWJsZSB3aXRoaW4gdGhpcyBtb2R1bGUuICopXG5vcGVuISBTdHJpbmdfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbmxldCBiZXR3ZWVuIHQgfmxvdyB+aGlnaCA9IGxvdyA8PSB0ICYmIHQgPD0gaGlnaFxubGV0IGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heCA9IGlmIHQgPCBtaW4gdGhlbiBtaW4gZWxzZSBpZiB0IDw9IG1heCB0aGVuIHQgZWxzZSBtYXhcblxubGV0IGNsYW1wX2V4biB0IH5taW4gfm1heCA9XG4gIGFzc2VydCAobWluIDw9IG1heCk7XG4gIGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heFxuOztcblxubGV0IGNsYW1wIHQgfm1pbiB+bWF4ID1cbiAgaWYgbWluID4gbWF4XG4gIHRoZW5cbiAgICBPcl9lcnJvci5lcnJvcl9zXG4gICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICBcImNsYW1wIHJlcXVpcmVzIFttaW4gPD0gbWF4XVwiXG4gICAgICAgICBbIFwibWluXCIsIFQuc2V4cF9vZl90IG1pbjsgXCJtYXhcIiwgVC5zZXhwX29mX3QgbWF4IF0pXG4gIGVsc2UgT2sgKGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heClcbjs7XG5cbigqIE92ZXJyaWRlIFtTZWFyY2hfcGF0dGVybl0gd2l0aCBkZWZhdWx0IGNhc2Utc2Vuc2l0aXZpdHkgYXJndW1lbnQgYXQgdGhlIGVuZCBvZiB0aGVcbiAgIGZpbGUsIHNvIHRoYXQgY2FsbCBzaXRlcyBhYm92ZSBhcmUgZm9yY2VkIHRvIHN1cHBseSBjYXNlLXNlbnNpdGl2aXR5IGV4cGxpY2l0bHkuICopXG5tb2R1bGUgU2VhcmNoX3BhdHRlcm4gPSBzdHJ1Y3RcbiAgaW5jbHVkZSBTZWFyY2hfcGF0dGVybjBcblxuICBsZXQgY3JlYXRlID8oY2FzZV9zZW5zaXRpdmUgPSB0cnVlKSBwYXR0ZXJuID0gY3JlYXRlIHBhdHRlcm4gfmNhc2Vfc2Vuc2l0aXZlXG5lbmRcblxuKCogSW5jbHVkZSB0eXBlLXNwZWNpZmljIFtSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVdIGF0IHRoZSBlbmQsIGFmdGVyXG4gICBpbmNsdWRpbmcgZnVuY3RvciBhcHBsaWNhdGlvbiB0aGF0IGNvdWxkIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXNcbiAgIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25zIGFyZSBleHBvcnRlZCBieVxuICAgdGhpcyBtb2R1bGUuICopXG5pbmNsdWRlIFN0cmluZ19yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcbiIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBDYW1sLkxhenlcblxudHlwZSAnYSB0ID0gJ2EgbGF6eV90IFtAQGRlcml2aW5nX2lubGluZSBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbmxldCB0X29mX3NleHAgOiAnYS4gKFNleHBsaWIwLlNleHAudCAtPiAnYSkgLT4gU2V4cGxpYjAuU2V4cC50IC0+ICdhIHQgPSBsYXp5X3Rfb2Zfc2V4cFxubGV0IHNleHBfb2ZfdCA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSB0IC0+IFNleHBsaWIwLlNleHAudCA9IHNleHBfb2ZfbGF6eV90XG5cbmxldCAodF9zZXhwX2dyYW1tYXIgOiAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCAtPiAnYSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9XG4gIGZ1biBfJ2Ffc2V4cF9ncmFtbWFyIC0+IGxhenlfdF9zZXhwX2dyYW1tYXIgXydhX3NleHBfZ3JhbW1hclxuOztcblxuW0BAQGVuZF1cblxubGV0IG1hcCB0IH5mID0gbGF6eSAoZiAoZm9yY2UgdCkpXG5cbmxldCBjb21wYXJlIGNvbXBhcmVfYSB0MSB0MiA9XG4gIGlmIHBoeXNfZXF1YWwgdDEgdDIgdGhlbiAwIGVsc2UgY29tcGFyZV9hIChmb3JjZSB0MSkgKGZvcmNlIHQyKVxuOztcblxubGV0IGVxdWFsIGVxdWFsX2EgdDEgdDIgPSBpZiBwaHlzX2VxdWFsIHQxIHQyIHRoZW4gdHJ1ZSBlbHNlIGVxdWFsX2EgKGZvcmNlIHQxKSAoZm9yY2UgdDIpXG5sZXQgaGFzaF9mb2xkX3QgPSBIYXNoLkJ1aWx0aW4uaGFzaF9mb2xkX2xhenlfdFxuXG5pbmNsdWRlIE1vbmFkLk1ha2UgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgICBsZXQgcmV0dXJuIHggPSBmcm9tX3ZhbCB4XG4gICAgbGV0IGJpbmQgdCB+ZiA9IGxhenkgKGZvcmNlIChmIChmb3JjZSB0KSkpXG4gICAgbGV0IG1hcCA9IG1hcFxuICAgIGxldCBtYXAgPSBgQ3VzdG9tIG1hcFxuICBlbmQpXG5cbm1vZHVsZSBUX3VuZm9yY2luZyA9IHN0cnVjdFxuICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gIGxldCBzZXhwX29mX3Qgc2V4cF9vZl9hIHQgPVxuICAgIGlmIGlzX3ZhbCB0IHRoZW4gc2V4cF9vZl9hIChmb3JjZSB0KSBlbHNlIHNleHBfb2Zfc3RyaW5nIFwiPHVuZm9yY2VkIGxhenk+XCJcbiAgOztcbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5tb2R1bGUgU3lzID0gU3lzMFxuXG50eXBlIHQgPVxuICB8IFczMlxuICB8IFc2NFxuW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbmxldCBzZXhwX29mX3QgPVxuICAoZnVuY3Rpb25cbiAgICB8IFczMiAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJXMzJcIlxuICAgIHwgVzY0IC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIlc2NFwiXG4gICAgICAgICAgICAgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbjs7XG5cbltAQEBlbmRdXG5cbmxldCBudW1fYml0cyA9IGZ1bmN0aW9uXG4gIHwgVzMyIC0+IDMyXG4gIHwgVzY0IC0+IDY0XG47O1xuXG5sZXQgd29yZF9zaXplID1cbiAgbWF0Y2ggU3lzLndvcmRfc2l6ZV9pbl9iaXRzIHdpdGhcbiAgfCAzMiAtPiBXMzJcbiAgfCA2NCAtPiBXNjRcbiAgfCBfIC0+IGZhaWx3aXRoIFwidW5rbm93biB3b3JkIHNpemVcIlxuOztcbiIsIm9wZW4hIEltcG9ydFxuXG5sZXQgciA9IHJlZiBbIFwiQmFzZS5TZXhwLnBwX2h1bVwiIF1cbmxldCBhbGwgKCkgPSAhclxubGV0IHJlZ2lzdGVyIHAgPSByIDo9IHAgOjogIXJcblxubW9kdWxlIHR5cGUgUyA9IHNpZ1xuICB0eXBlIHRcblxuICB2YWwgcHAgOiBGb3JtYXR0ZXIudCAtPiB0IC0+IHVuaXRcbmVuZFxuXG5tb2R1bGUgUmVnaXN0ZXJfcHAgKE0gOiBzaWdcbiAgICBpbmNsdWRlIFNcblxuICAgIHZhbCBtb2R1bGVfbmFtZSA6IHN0cmluZ1xuICBlbmQpID1cbnN0cnVjdFxuICBpbmNsdWRlIE1cblxuICBsZXQgKCkgPSByZWdpc3RlciAoTS5tb2R1bGVfbmFtZSBeIFwiLnBwXCIpXG5lbmRcblxubW9kdWxlIFJlZ2lzdGVyIChNIDogc2lnXG4gICAgdHlwZSB0XG5cbiAgICB2YWwgbW9kdWxlX25hbWUgOiBzdHJpbmdcbiAgICB2YWwgdG9fc3RyaW5nIDogdCAtPiBzdHJpbmdcbiAgZW5kKSA9XG4gIFJlZ2lzdGVyX3BwIChzdHJ1Y3RcbiAgICBpbmNsdWRlIE1cblxuICAgIGxldCBwcCBmb3JtYXR0ZXIgdCA9IENhbWwuRm9ybWF0LnBwX3ByaW50X3N0cmluZyBmb3JtYXR0ZXIgKE0udG9fc3RyaW5nIHQpXG4gIGVuZClcbiIsIigqIGJlbG9uZ3MgaW4gQ29tbW9uLCBidXQgbW92ZWQgaGVyZSB0byBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmNpZXMgKilcblxub3BlbiEgSW1wb3J0XG5cbnR5cGUgJ2EgcmV0dXJuID0geyByZXR1cm4gOiAnYi4gJ2EgLT4gJ2IgfSBbQEB1bmJveGVkXVxuXG5sZXQgd2l0aF9yZXR1cm4gKHR5cGUgYSkgZiA9XG4gIGxldCBtb2R1bGUgTSA9IHN0cnVjdFxuICAgICgqIFJhaXNlZCB0byBpbmRpY2F0ZSB+cmV0dXJuIHdhcyBjYWxsZWQuICBMb2NhbCBzbyB0aGF0IHRoZSBleGNlcHRpb24gaXMgdGllZCB0byBhXG4gICAgICAgcGFydGljdWxhciBjYWxsIG9mIFt3aXRoX3JldHVybl0uICopXG4gICAgZXhjZXB0aW9uIFJldHVybiBvZiBhXG4gIGVuZFxuICBpblxuICBsZXQgaXNfYWxpdmUgPSByZWYgdHJ1ZSBpblxuICBsZXQgcmV0dXJuIGEgPVxuICAgIGlmIG5vdCAhaXNfYWxpdmVcbiAgICB0aGVuIGZhaWx3aXRoIFwidXNlIG9mIFtyZXR1cm5dIGZyb20gYSBbd2l0aF9yZXR1cm5dIHRoYXQgYWxyZWFkeSByZXR1cm5lZFwiO1xuICAgIEV4bi5yYWlzZV93aXRob3V0X2JhY2t0cmFjZSAoTS5SZXR1cm4gYSlcbiAgaW5cbiAgdHJ5XG4gICAgbGV0IGEgPSBmIHsgcmV0dXJuIH0gaW5cbiAgICBpc19hbGl2ZSA6PSBmYWxzZTtcbiAgICBhXG4gIHdpdGhcbiAgfCBleG4gLT5cbiAgICBpc19hbGl2ZSA6PSBmYWxzZTtcbiAgICAobWF0Y2ggZXhuIHdpdGhcbiAgICAgfCBNLlJldHVybiBhIC0+IGFcbiAgICAgfCBfIC0+IHJhaXNlIGV4bilcbjs7XG5cbmxldCB3aXRoX3JldHVybl9vcHRpb24gZiA9XG4gIHdpdGhfcmV0dXJuIChmdW4gcmV0dXJuIC0+XG4gICAgZiB7IHJldHVybiA9IChmdW4gYSAtPiByZXR1cm4ucmV0dXJuIChTb21lIGEpKSB9O1xuICAgIE5vbmUpXG47O1xuXG5sZXQgcHJlcGVuZCB7IHJldHVybiB9IH5mID0geyByZXR1cm4gPSAoZnVuIHggLT4gcmV0dXJuIChmIHgpKSB9XG4iLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgSGFzaF9zZXRfaW50ZlxuXG5sZXQgaGFzaGFibGVfcyA9IEhhc2h0YmwuaGFzaGFibGVfc1xubGV0IGhhc2hhYmxlID0gSGFzaHRibC5Qcml2YXRlLmhhc2hhYmxlXG5sZXQgcG9seV9oYXNoYWJsZSA9IEhhc2h0YmwuUG9seS5oYXNoYWJsZVxubGV0IHdpdGhfcmV0dXJuID0gV2l0aF9yZXR1cm4ud2l0aF9yZXR1cm5cblxudHlwZSAnYSB0ID0gKCdhLCB1bml0KSBIYXNodGJsLnRcbnR5cGUgJ2EgaGFzaF9zZXQgPSAnYSB0XG50eXBlICdhIGVsdCA9ICdhXG5cbm1vZHVsZSBBY2Nlc3NvcnMgPSBzdHJ1Y3RcbiAgbGV0IGhhc2hhYmxlID0gaGFzaGFibGVcbiAgbGV0IGNsZWFyID0gSGFzaHRibC5jbGVhclxuICBsZXQgbGVuZ3RoID0gSGFzaHRibC5sZW5ndGhcbiAgbGV0IG1lbSA9IEhhc2h0YmwubWVtXG4gIGxldCBpc19lbXB0eSB0ID0gSGFzaHRibC5pc19lbXB0eSB0XG5cbiAgbGV0IGZpbmRfbWFwIHQgfmYgPVxuICAgIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgICAgSGFzaHRibC5pdGVyX2tleXMgdCB+ZjooZnVuIGVsdCAtPlxuICAgICAgICBtYXRjaCBmIGVsdCB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiAoKVxuICAgICAgICB8IFNvbWUgXyBhcyBvIC0+IHIucmV0dXJuIG8pO1xuICAgICAgTm9uZSlcbiAgOztcblxuICBsZXQgZmluZCB0IH5mID0gZmluZF9tYXAgdCB+ZjooZnVuIGEgLT4gaWYgZiBhIHRoZW4gU29tZSBhIGVsc2UgTm9uZSlcbiAgbGV0IGFkZCB0IGsgPSBIYXNodGJsLnNldCB0IH5rZXk6ayB+ZGF0YTooKVxuXG4gIGxldCBzdHJpY3RfYWRkIHQgayA9XG4gICAgaWYgbWVtIHQga1xuICAgIHRoZW4gT3JfZXJyb3IuZXJyb3Jfc3RyaW5nIFwiZWxlbWVudCBhbHJlYWR5IGV4aXN0c1wiXG4gICAgZWxzZSAoXG4gICAgICBIYXNodGJsLnNldCB0IH5rZXk6ayB+ZGF0YTooKTtcbiAgICAgIFJlc3VsdC5PayAoKSlcbiAgOztcblxuICBsZXQgc3RyaWN0X2FkZF9leG4gdCBrID0gT3JfZXJyb3Iub2tfZXhuIChzdHJpY3RfYWRkIHQgaylcbiAgbGV0IHJlbW92ZSA9IEhhc2h0YmwucmVtb3ZlXG5cbiAgbGV0IHN0cmljdF9yZW1vdmUgdCBrID1cbiAgICBpZiBtZW0gdCBrXG4gICAgdGhlbiAoXG4gICAgICByZW1vdmUgdCBrO1xuICAgICAgUmVzdWx0Lk9rICgpKVxuICAgIGVsc2UgT3JfZXJyb3IuZXJyb3IgXCJlbGVtZW50IG5vdCBpbiBzZXRcIiBrIChIYXNodGJsLnNleHBfb2Zfa2V5IHQpXG4gIDs7XG5cbiAgbGV0IHN0cmljdF9yZW1vdmVfZXhuIHQgayA9IE9yX2Vycm9yLm9rX2V4biAoc3RyaWN0X3JlbW92ZSB0IGspXG4gIGxldCBmb2xkIHQgfmluaXQgfmYgPSBIYXNodGJsLmZvbGQgdCB+aW5pdCB+ZjooZnVuIH5rZXkgfmRhdGE6KCkgYWNjIC0+IGYgYWNjIGtleSlcbiAgbGV0IGl0ZXIgdCB+ZiA9IEhhc2h0YmwuaXRlcl9rZXlzIHQgfmZcbiAgbGV0IGNvdW50IHQgfmYgPSBDb250YWluZXIuY291bnQgfmZvbGQgdCB+ZlxuICBsZXQgc3VtIG0gdCB+ZiA9IENvbnRhaW5lci5zdW0gfmZvbGQgbSB0IH5mXG4gIGxldCBtaW5fZWx0IHQgfmNvbXBhcmUgPSBDb250YWluZXIubWluX2VsdCB+Zm9sZCB0IH5jb21wYXJlXG4gIGxldCBtYXhfZWx0IHQgfmNvbXBhcmUgPSBDb250YWluZXIubWF4X2VsdCB+Zm9sZCB0IH5jb21wYXJlXG4gIGxldCBmb2xkX3Jlc3VsdCB0IH5pbml0IH5mID0gQ29udGFpbmVyLmZvbGRfcmVzdWx0IH5mb2xkIH5pbml0IH5mIHRcbiAgbGV0IGZvbGRfdW50aWwgdCB+aW5pdCB+ZiA9IENvbnRhaW5lci5mb2xkX3VudGlsIH5mb2xkIH5pbml0IH5mIHRcbiAgbGV0IHRvX2xpc3QgPSBIYXNodGJsLmtleXNcblxuICBsZXQgc2V4cF9vZl90IHNleHBfb2ZfZSB0ID1cbiAgICBzZXhwX29mX2xpc3Qgc2V4cF9vZl9lICh0b19saXN0IHQgfD4gTGlzdC5zb3J0IH5jb21wYXJlOihoYXNoYWJsZSB0KS5jb21wYXJlKVxuICA7O1xuXG4gIGxldCB0b19hcnJheSB0ID1cbiAgICBsZXQgbGVuID0gbGVuZ3RoIHQgaW5cbiAgICBsZXQgaW5kZXggPSByZWYgKGxlbiAtIDEpIGluXG4gICAgZm9sZCB0IH5pbml0Olt8fF0gfmY6KGZ1biBhY2Mga2V5IC0+XG4gICAgICBpZiBBcnJheS5sZW5ndGggYWNjID0gMFxuICAgICAgdGhlbiBBcnJheS5jcmVhdGUgfmxlbiBrZXlcbiAgICAgIGVsc2UgKFxuICAgICAgICBpbmRleCA6PSAhaW5kZXggLSAxO1xuICAgICAgICBhY2MuKCFpbmRleCkgPC0ga2V5O1xuICAgICAgICBhY2MpKVxuICA7O1xuXG4gIGxldCBleGlzdHMgdCB+ZiA9IEhhc2h0YmwuZXhpc3RzaSB0IH5mOihmdW4gfmtleSB+ZGF0YTooKSAtPiBmIGtleSlcbiAgbGV0IGZvcl9hbGwgdCB+ZiA9IG5vdCAoSGFzaHRibC5leGlzdHNpIHQgfmY6KGZ1biB+a2V5IH5kYXRhOigpIC0+IG5vdCAoZiBrZXkpKSlcbiAgbGV0IGVxdWFsIHQxIHQyID0gSGFzaHRibC5lcXVhbCAoZnVuICgpICgpIC0+IHRydWUpIHQxIHQyXG4gIGxldCBjb3B5IHQgPSBIYXNodGJsLmNvcHkgdFxuICBsZXQgZmlsdGVyIHQgfmYgPSBIYXNodGJsLmZpbHRlcmkgdCB+ZjooZnVuIH5rZXkgfmRhdGE6KCkgLT4gZiBrZXkpXG4gIGxldCB1bmlvbiB0MSB0MiA9IEhhc2h0YmwubWVyZ2UgdDEgdDIgfmY6KGZ1biB+a2V5Ol8gXyAtPiBTb21lICgpKVxuICBsZXQgZGlmZiB0MSB0MiA9IGZpbHRlciB0MSB+ZjooZnVuIGtleSAtPiBub3QgKEhhc2h0YmwubWVtIHQyIGtleSkpXG5cbiAgbGV0IGludGVyIHQxIHQyID1cbiAgICBsZXQgc21hbGxlciwgbGFyZ2VyID0gaWYgbGVuZ3RoIHQxID4gbGVuZ3RoIHQyIHRoZW4gdDIsIHQxIGVsc2UgdDEsIHQyIGluXG4gICAgSGFzaHRibC5maWx0ZXJpIHNtYWxsZXIgfmY6KGZ1biB+a2V5IH5kYXRhOigpIC0+IEhhc2h0YmwubWVtIGxhcmdlciBrZXkpXG4gIDs7XG5cbiAgbGV0IGZpbHRlcl9pbnBsYWNlIHQgfmYgPVxuICAgIGxldCB0b19yZW1vdmUgPSBmb2xkIHQgfmluaXQ6W10gfmY6KGZ1biBhYyB4IC0+IGlmIGYgeCB0aGVuIGFjIGVsc2UgeCA6OiBhYykgaW5cbiAgICBMaXN0Lml0ZXIgdG9fcmVtb3ZlIH5mOihmdW4geCAtPiByZW1vdmUgdCB4KVxuICA7O1xuXG4gIGxldCBvZl9oYXNodGJsX2tleXMgaGFzaHRibCA9IEhhc2h0YmwubWFwIGhhc2h0YmwgfmY6aWdub3JlXG4gIGxldCB0b19oYXNodGJsIHQgfmYgPSBIYXNodGJsLm1hcGkgdCB+ZjooZnVuIH5rZXkgfmRhdGE6KCkgLT4gZiBrZXkpXG5lbmRcblxuaW5jbHVkZSBBY2Nlc3NvcnNcblxubGV0IGNyZWF0ZSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbSA9IEhhc2h0YmwuY3JlYXRlID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBtXG5cbmxldCBvZl9saXN0ID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBtIGwgPVxuICBsZXQgc2l6ZSA9XG4gICAgbWF0Y2ggc2l6ZSB3aXRoXG4gICAgfCBTb21lIHggLT4geFxuICAgIHwgTm9uZSAtPiBMaXN0Lmxlbmd0aCBsXG4gIGluXG4gIGxldCB0ID0gSGFzaHRibC5jcmVhdGUgP2dyb3d0aF9hbGxvd2VkIH5zaXplIG0gaW5cbiAgTGlzdC5pdGVyIGwgfmY6KGZ1biBrIC0+IGFkZCB0IGspO1xuICB0XG47O1xuXG5sZXQgdF9vZl9zZXhwIG0gZV9vZl9zZXhwIHNleHAgPVxuICBtYXRjaCBzZXhwIHdpdGhcbiAgfCBTZXhwLkF0b20gXyAtPiBvZl9zZXhwX2Vycm9yIFwiSGFzaF9zZXQudF9vZl9zZXhwIHJlcXVpcmVzIGEgbGlzdFwiIHNleHBcbiAgfCBTZXhwLkxpc3QgbGlzdCAtPlxuICAgIGxldCB0ID0gY3JlYXRlIG0gfnNpemU6KExpc3QubGVuZ3RoIGxpc3QpIGluXG4gICAgTGlzdC5pdGVyIGxpc3QgfmY6KGZ1biBzZXhwIC0+XG4gICAgICBsZXQgZSA9IGVfb2Zfc2V4cCBzZXhwIGluXG4gICAgICBtYXRjaCBzdHJpY3RfYWRkIHQgZSB3aXRoXG4gICAgICB8IE9rICgpIC0+ICgpXG4gICAgICB8IEVycm9yIF8gLT4gb2Zfc2V4cF9lcnJvciBcIkhhc2hfc2V0LnRfb2Zfc2V4cCBnb3QgYSBkdXBsaWNhdGUgZWxlbWVudFwiIHNleHApO1xuICAgIHRcbjs7XG5cbm1vZHVsZSBDcmVhdG9ycyAoRWx0IDogc2lnXG4gICAgdHlwZSAnYSB0XG5cbiAgICB2YWwgaGFzaGFibGUgOiAnYSB0IEhhc2hhYmxlLnRcbiAgZW5kKSA6IHNpZ1xuICB2YWwgdF9vZl9zZXhwIDogKFNleHAudCAtPiAnYSBFbHQudCkgLT4gU2V4cC50IC0+ICdhIEVsdC50IHRcblxuICBpbmNsdWRlXG4gICAgQ3JlYXRvcnNfZ2VuZXJpY1xuICAgIHdpdGggdHlwZSAnYSB0IDo9ICdhIEVsdC50IHRcbiAgICB3aXRoIHR5cGUgJ2EgZWx0IDo9ICdhIEVsdC50XG4gICAgd2l0aCB0eXBlICgnZWx0LCAneikgY3JlYXRlX29wdGlvbnMgOj1cbiAgICAgICgnZWx0LCAneikgY3JlYXRlX29wdGlvbnNfd2l0aG91dF9maXJzdF9jbGFzc19tb2R1bGVcbmVuZCA9IHN0cnVjdFxuICBsZXQgY3JlYXRlID9ncm93dGhfYWxsb3dlZCA/c2l6ZSAoKSA9XG4gICAgY3JlYXRlID9ncm93dGhfYWxsb3dlZCA/c2l6ZSAoSGFzaGFibGUudG9fa2V5IEVsdC5oYXNoYWJsZSlcbiAgOztcblxuICBsZXQgb2ZfbGlzdCA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbCA9XG4gICAgb2ZfbGlzdCA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgKEhhc2hhYmxlLnRvX2tleSBFbHQuaGFzaGFibGUpIGxcbiAgOztcblxuICBsZXQgdF9vZl9zZXhwIGVfb2Zfc2V4cCBzZXhwID0gdF9vZl9zZXhwIChIYXNoYWJsZS50b19rZXkgRWx0Lmhhc2hhYmxlKSBlX29mX3NleHAgc2V4cFxuZW5kXG5cbm1vZHVsZSBQb2x5ID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9ICdhIGhhc2hfc2V0XG4gIHR5cGUgJ2EgZWx0ID0gJ2FcblxuICBsZXQgaGFzaGFibGUgPSBwb2x5X2hhc2hhYmxlXG5cbiAgaW5jbHVkZSBDcmVhdG9ycyAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYVxuXG4gICAgICBsZXQgaGFzaGFibGUgPSBoYXNoYWJsZVxuICAgIGVuZClcblxuICBpbmNsdWRlIEFjY2Vzc29yc1xuXG4gIGxldCBzZXhwX29mX3QgPSBzZXhwX29mX3RcbiAgbGV0IHRfc2V4cF9ncmFtbWFyIGdyYW1tYXIgPSBTZXhwbGliMC5TZXhwX2dyYW1tYXIuY29lcmNlIChMaXN0LnRfc2V4cF9ncmFtbWFyIGdyYW1tYXIpXG5lbmRcblxubW9kdWxlIE0gKEVsdCA6IFQuVCkgPSBzdHJ1Y3RcbiAgdHlwZSBub25yZWMgdCA9IEVsdC50IHRcbmVuZFxuXG5sZXQgc2V4cF9vZl9tX190ICh0eXBlIGVsdCkgKG1vZHVsZSBFbHQgOiBTZXhwX29mX20gd2l0aCB0eXBlIHQgPSBlbHQpIHQgPVxuICBzZXhwX29mX3QgRWx0LnNleHBfb2ZfdCB0XG47O1xuXG5sZXQgbV9fdF9vZl9zZXhwICh0eXBlIGVsdCkgKG1vZHVsZSBFbHQgOiBNX29mX3NleHAgd2l0aCB0eXBlIHQgPSBlbHQpIHNleHAgPVxuICB0X29mX3NleHAgKG1vZHVsZSBFbHQpIEVsdC50X29mX3NleHAgc2V4cFxuOztcblxubGV0IG1fX3Rfc2V4cF9ncmFtbWFyICh0eXBlIGVsdCkgKG1vZHVsZSBFbHQgOiBNX3NleHBfZ3JhbW1hciB3aXRoIHR5cGUgdCA9IGVsdCkgPVxuICBTZXhwbGliMC5TZXhwX2dyYW1tYXIuY29lcmNlIChsaXN0X3NleHBfZ3JhbW1hciBFbHQudF9zZXhwX2dyYW1tYXIpXG47O1xuXG5sZXQgZXF1YWxfbV9fdCAobW9kdWxlIF8gOiBFcXVhbF9tKSB0MSB0MiA9IGVxdWFsIHQxIHQyXG5cbm1vZHVsZSBQcml2YXRlID0gc3RydWN0XG4gIGxldCBoYXNoYWJsZSA9IEhhc2h0YmwuUHJpdmF0ZS5oYXNoYWJsZVxuZW5kXG4iLCJvcGVuISBJbXBvcnRcblxubW9kdWxlIHR5cGUgQmFzaWMgPSBzaWdcbiAgdHlwZSAnYSB0XG5cbiAgdmFsIGJpbmQgOiAnYSB0IC0+IGY6KCdhIC0+ICdiIHQpIC0+ICdiIHRcbiAgdmFsIHJldHVybiA6ICdhIC0+ICdhIHRcblxuICAoKiogVGhlIGZvbGxvd2luZyBpZGVudGl0aWVzIG91Z2h0IHRvIGhvbGQgKGZvciBzb21lIHZhbHVlIG9mID0pOlxuXG4gICAgICAtIFtyZXR1cm4geCA+Pj0gZiA9IGYgeF1cbiAgICAgIC0gW3QgPj49IGZ1biB4IC0+IHJldHVybiB4ID0gdF1cbiAgICAgIC0gWyh0ID4+PSBmKSA+Pj0gZyA9IHQgPj49IGZ1biB4IC0+IChmIHggPj49IGcpXVxuXG4gICAgICBOb3RlOiBbPj49XSBpcyB0aGUgaW5maXggbm90YXRpb24gZm9yIFtiaW5kXSkgKilcblxuICAoKiogVGhlIFttYXBdIGFyZ3VtZW50IHRvIFtNb25hZC5NYWtlXSBzYXlzIGhvdyB0byBpbXBsZW1lbnQgdGhlIG1vbmFkJ3MgW21hcF0gZnVuY3Rpb24uXG4gICAgICBbYERlZmluZV91c2luZ19iaW5kXSBtZWFucyB0byBkZWZpbmUgW21hcCB0IH5mID0gYmluZCB0IH5mOihmdW4gYSAtPiByZXR1cm4gKGYgYSkpXS5cbiAgICAgIFtgQ3VzdG9tXSBvdmVycmlkZXMgdGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24sIHByZXN1bWFibHkgd2l0aCBzb21ldGhpbmcgbW9yZVxuICAgICAgZWZmaWNpZW50LlxuXG4gICAgICBTb21lIG90aGVyIGZ1bmN0aW9ucyByZXR1cm5lZCBieSBbTW9uYWQuTWFrZV0gYXJlIGRlZmluZWQgaW4gdGVybXMgb2YgW21hcF0sIHNvXG4gICAgICBwYXNzaW5nIGluIGEgbW9yZSBlZmZpY2llbnQgW21hcF0gd2lsbCBpbXByb3ZlIHRoZWlyIGVmZmljaWVuY3kgYXMgd2VsbC4gKilcbiAgdmFsIG1hcCA6IFsgYERlZmluZV91c2luZ19iaW5kIHwgYEN1c3RvbSBvZiAnYSB0IC0+IGY6KCdhIC0+ICdiKSAtPiAnYiB0IF1cbmVuZFxuXG5tb2R1bGUgdHlwZSBJbmZpeCA9IHNpZ1xuICB0eXBlICdhIHRcblxuICAoKiogW3QgPj49IGZdIHJldHVybnMgYSBjb21wdXRhdGlvbiB0aGF0IHNlcXVlbmNlcyB0aGUgY29tcHV0YXRpb25zIHJlcHJlc2VudGVkIGJ5IHR3b1xuICAgICAgbW9uYWQgZWxlbWVudHMuICBUaGUgcmVzdWx0aW5nIGNvbXB1dGF0aW9uIGZpcnN0IGRvZXMgW3RdIHRvIHlpZWxkIGEgdmFsdWUgW3ZdLCBhbmRcbiAgICAgIHRoZW4gcnVucyB0aGUgY29tcHV0YXRpb24gcmV0dXJuZWQgYnkgW2Ygdl0uICopXG4gIHZhbCAoID4+PSApIDogJ2EgdCAtPiAoJ2EgLT4gJ2IgdCkgLT4gJ2IgdFxuXG4gICgqKiBbdCA+PnwgZl0gaXMgW3QgPj49IChmdW4gYSAtPiByZXR1cm4gKGYgYSkpXS4gKilcbiAgdmFsICggPj58ICkgOiAnYSB0IC0+ICgnYSAtPiAnYikgLT4gJ2IgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIFN5bnRheCA9IHNpZ1xuICAoKiogT3BlbmluZyBhIG1vZHVsZSBvZiB0aGlzIHR5cGUgYWxsb3dzIG9uZSB0byB1c2UgdGhlIFslYmluZF0gYW5kIFslbWFwXSBzeW50YXhcbiAgICAgIGV4dGVuc2lvbnMgZGVmaW5lZCBieSBwcHhfbGV0LCBhbmQgYnJpbmdzIFtyZXR1cm5dIGludG8gc2NvcGUuICopXG5cbiAgdHlwZSAnYSB0XG5cbiAgbW9kdWxlIExldF9zeW50YXggOiBzaWdcbiAgICAoKiogVGhlc2UgYXJlIGNvbnZlbmllbnQgdG8gaGF2ZSBpbiBzY29wZSB3aGVuIHByb2dyYW1taW5nIHdpdGggYSBtb25hZDogKilcblxuICAgIHZhbCByZXR1cm4gOiAnYSAtPiAnYSB0XG5cbiAgICBpbmNsdWRlIEluZml4IHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcblxuICAgIG1vZHVsZSBMZXRfc3ludGF4IDogc2lnXG4gICAgICB2YWwgcmV0dXJuIDogJ2EgLT4gJ2EgdFxuICAgICAgdmFsIGJpbmQgOiAnYSB0IC0+IGY6KCdhIC0+ICdiIHQpIC0+ICdiIHRcbiAgICAgIHZhbCBtYXAgOiAnYSB0IC0+IGY6KCdhIC0+ICdiKSAtPiAnYiB0XG4gICAgICB2YWwgYm90aCA6ICdhIHQgLT4gJ2IgdCAtPiAoJ2EgKiAnYikgdFxuXG4gICAgICBtb2R1bGUgT3Blbl9vbl9yaHMgOiBzaWcgZW5kXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSB0eXBlIFNfd2l0aG91dF9zeW50YXggPSBzaWdcbiAgdHlwZSAnYSB0XG5cbiAgaW5jbHVkZSBJbmZpeCB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG4gIG1vZHVsZSBNb25hZF9pbmZpeCA6IEluZml4IHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcblxuICAoKiogW2JpbmQgdCB+Zl0gPSBbdCA+Pj0gZl0gKilcbiAgdmFsIGJpbmQgOiAnYSB0IC0+IGY6KCdhIC0+ICdiIHQpIC0+ICdiIHRcblxuICAoKiogW3JldHVybiB2XSByZXR1cm5zIHRoZSAodHJpdmlhbCkgY29tcHV0YXRpb24gdGhhdCByZXR1cm5zIHYuICopXG4gIHZhbCByZXR1cm4gOiAnYSAtPiAnYSB0XG5cbiAgKCoqIFttYXAgdCB+Zl0gaXMgdCA+PnwgZi4gKilcbiAgdmFsIG1hcCA6ICdhIHQgLT4gZjooJ2EgLT4gJ2IpIC0+ICdiIHRcblxuICAoKiogW2pvaW4gdF0gaXMgW3QgPj49IChmdW4gdCcgLT4gdCcpXS4gKilcbiAgdmFsIGpvaW4gOiAnYSB0IHQgLT4gJ2EgdFxuXG4gICgqKiBbaWdub3JlX20gdF0gaXMgW21hcCB0IH5mOihmdW4gXyAtPiAoKSldLiAgW2lnbm9yZV9tXSB1c2VkIHRvIGJlIGNhbGxlZCBbaWdub3JlXSxcbiAgICAgIGJ1dCB3ZSBkZWNpZGVkIHRoYXQgd2FzIGEgYmFkIG5hbWUsIGJlY2F1c2UgaXQgc2hhZG93ZWQgdGhlIHdpZGVseSB1c2VkXG4gICAgICBbQ2FtbC5pZ25vcmVdLiAgU29tZSBtb25hZHMgc3RpbGwgZG8gW2xldCBpZ25vcmUgPSBpZ25vcmVfbV0gZm9yIGhpc3RvcmljYWxcbiAgICAgIHJlYXNvbnMuICopXG4gIHZhbCBpZ25vcmVfbSA6ICdhIHQgLT4gdW5pdCB0XG5cbiAgdmFsIGFsbCA6ICdhIHQgbGlzdCAtPiAnYSBsaXN0IHRcblxuICAoKiogTGlrZSBbYWxsXSwgYnV0IGVuc3VyZXMgdGhhdCBldmVyeSBtb25hZGljIHZhbHVlIGluIHRoZSBsaXN0IHByb2R1Y2VzIGEgdW5pdCB2YWx1ZSxcbiAgICAgIGFsbCBvZiB3aGljaCBhcmUgZGlzY2FyZGVkIHJhdGhlciB0aGFuIGJlaW5nIGNvbGxlY3RlZCBpbnRvIGEgbGlzdC4gKilcbiAgdmFsIGFsbF91bml0IDogdW5pdCB0IGxpc3QgLT4gdW5pdCB0XG5lbmRcblxubW9kdWxlIHR5cGUgUyA9IHNpZ1xuICB0eXBlICdhIHRcblxuICBpbmNsdWRlIFNfd2l0aG91dF9zeW50YXggd2l0aCB0eXBlICdhIHQgOj0gJ2EgdFxuICBpbmNsdWRlIFN5bnRheCB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG5lbmRcblxubW9kdWxlIHR5cGUgQmFzaWMyID0gc2lnXG4gICgqKiBNdWx0aSBwYXJhbWV0ZXIgbW9uYWQuIFRoZSBzZWNvbmQgcGFyYW1ldGVyIGdldHMgdW5pZmllZCBhY3Jvc3MgYWxsIHRoZSBjb21wdXRhdGlvbi5cbiAgICAgIFRoaXMgaXMgdXNlZCB0byBlbmNvZGUgbW9uYWRzIHdvcmtpbmcgb24gYSBtdWx0aSBwYXJhbWV0ZXIgZGF0YSBzdHJ1Y3R1cmUgbGlrZVxuICAgICAgKFsoJ2EsJ2IpIHJlc3VsdF0pLiAqKVxuXG4gIHR5cGUgKCdhLCAnZSkgdFxuXG4gIHZhbCBiaW5kIDogKCdhLCAnZSkgdCAtPiBmOignYSAtPiAoJ2IsICdlKSB0KSAtPiAoJ2IsICdlKSB0XG4gIHZhbCBtYXAgOiBbIGBEZWZpbmVfdXNpbmdfYmluZCB8IGBDdXN0b20gb2YgKCdhLCAnZSkgdCAtPiBmOignYSAtPiAnYikgLT4gKCdiLCAnZSkgdCBdXG4gIHZhbCByZXR1cm4gOiAnYSAtPiAoJ2EsIF8pIHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBJbmZpeDIgPSBzaWdcbiAgKCoqIFNhbWUgYXMgeyFJbmZpeH0sIGV4Y2VwdCB0aGUgbW9uYWQgdHlwZSBoYXMgdHdvIGFyZ3VtZW50cy4gVGhlIHNlY29uZCBpcyBhbHdheXMganVzdFxuICAgICAgcGFzc2VkIHRocm91Z2guICopXG5cbiAgdHlwZSAoJ2EsICdlKSB0XG5cbiAgdmFsICggPj49ICkgOiAoJ2EsICdlKSB0IC0+ICgnYSAtPiAoJ2IsICdlKSB0KSAtPiAoJ2IsICdlKSB0XG4gIHZhbCAoID4+fCApIDogKCdhLCAnZSkgdCAtPiAoJ2EgLT4gJ2IpIC0+ICgnYiwgJ2UpIHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBTeW50YXgyID0gc2lnXG4gIHR5cGUgKCdhLCAnZSkgdFxuXG4gIG1vZHVsZSBMZXRfc3ludGF4IDogc2lnXG4gICAgdmFsIHJldHVybiA6ICdhIC0+ICgnYSwgXykgdFxuXG4gICAgaW5jbHVkZSBJbmZpeDIgd2l0aCB0eXBlICgnYSwgJ2UpIHQgOj0gKCdhLCAnZSkgdFxuXG4gICAgbW9kdWxlIExldF9zeW50YXggOiBzaWdcbiAgICAgIHZhbCByZXR1cm4gOiAnYSAtPiAoJ2EsIF8pIHRcbiAgICAgIHZhbCBiaW5kIDogKCdhLCAnZSkgdCAtPiBmOignYSAtPiAoJ2IsICdlKSB0KSAtPiAoJ2IsICdlKSB0XG4gICAgICB2YWwgbWFwIDogKCdhLCAnZSkgdCAtPiBmOignYSAtPiAnYikgLT4gKCdiLCAnZSkgdFxuICAgICAgdmFsIGJvdGggOiAoJ2EsICdlKSB0IC0+ICgnYiwgJ2UpIHQgLT4gKCdhICogJ2IsICdlKSB0XG5cbiAgICAgIG1vZHVsZSBPcGVuX29uX3JocyA6IHNpZyBlbmRcbiAgICBlbmRcbiAgZW5kXG5lbmRcblxubW9kdWxlIHR5cGUgUzIgPSBzaWdcbiAgKCoqIFRoZSBzYW1lIGFzIHshU30gZXhjZXB0IHRoZSBtb25hZCB0eXBlIGhhcyB0d28gYXJndW1lbnRzLiBUaGUgc2Vjb25kIGlzIGFsd2F5cyBqdXN0XG4gICAgICBwYXNzZWQgdGhyb3VnaC4gKilcblxuICB0eXBlICgnYSwgJ2UpIHRcblxuICBpbmNsdWRlIEluZml4MiB3aXRoIHR5cGUgKCdhLCAnZSkgdCA6PSAoJ2EsICdlKSB0XG4gIGluY2x1ZGUgU3ludGF4MiB3aXRoIHR5cGUgKCdhLCAnZSkgdCA6PSAoJ2EsICdlKSB0XG4gIG1vZHVsZSBNb25hZF9pbmZpeCA6IEluZml4MiB3aXRoIHR5cGUgKCdhLCAnZSkgdCA6PSAoJ2EsICdlKSB0XG5cbiAgdmFsIGJpbmQgOiAoJ2EsICdlKSB0IC0+IGY6KCdhIC0+ICgnYiwgJ2UpIHQpIC0+ICgnYiwgJ2UpIHRcbiAgdmFsIHJldHVybiA6ICdhIC0+ICgnYSwgXykgdFxuICB2YWwgbWFwIDogKCdhLCAnZSkgdCAtPiBmOignYSAtPiAnYikgLT4gKCdiLCAnZSkgdFxuICB2YWwgam9pbiA6ICgoJ2EsICdlKSB0LCAnZSkgdCAtPiAoJ2EsICdlKSB0XG4gIHZhbCBpZ25vcmVfbSA6IChfLCAnZSkgdCAtPiAodW5pdCwgJ2UpIHRcbiAgdmFsIGFsbCA6ICgnYSwgJ2UpIHQgbGlzdCAtPiAoJ2EgbGlzdCwgJ2UpIHRcbiAgdmFsIGFsbF91bml0IDogKHVuaXQsICdlKSB0IGxpc3QgLT4gKHVuaXQsICdlKSB0XG5lbmRcblxubW9kdWxlIHR5cGUgQmFzaWMzID0gc2lnXG4gICgqKiBNdWx0aSBwYXJhbWV0ZXIgbW9uYWQuIFRoZSBzZWNvbmQgYW5kIHRoaXJkIHBhcmFtZXRlcnMgZ2V0IHVuaWZpZWQgYWNyb3NzIGFsbCB0aGVcbiAgICAgIGNvbXB1dGF0aW9uLiAqKVxuXG4gIHR5cGUgKCdhLCAnZCwgJ2UpIHRcblxuICB2YWwgYmluZCA6ICgnYSwgJ2QsICdlKSB0IC0+IGY6KCdhIC0+ICgnYiwgJ2QsICdlKSB0KSAtPiAoJ2IsICdkLCAnZSkgdFxuXG4gIHZhbCBtYXBcbiAgICA6IFsgYERlZmluZV91c2luZ19iaW5kIHwgYEN1c3RvbSBvZiAoJ2EsICdkLCAnZSkgdCAtPiBmOignYSAtPiAnYikgLT4gKCdiLCAnZCwgJ2UpIHQgXVxuXG4gIHZhbCByZXR1cm4gOiAnYSAtPiAoJ2EsIF8sIF8pIHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBJbmZpeDMgPSBzaWdcbiAgKCoqIFNhbWUgYXMgSW5maXgsIGV4Y2VwdCB0aGUgbW9uYWQgdHlwZSBoYXMgdGhyZWUgYXJndW1lbnRzLiBUaGUgc2Vjb25kIGFuZCB0aGlyZCBhcmVcbiAgICAgIGFsd2F5cyBqdXN0IHBhc3NlZCB0aHJvdWdoLiAqKVxuXG4gIHR5cGUgKCdhLCAnZCwgJ2UpIHRcblxuICB2YWwgKCA+Pj0gKSA6ICgnYSwgJ2QsICdlKSB0IC0+ICgnYSAtPiAoJ2IsICdkLCAnZSkgdCkgLT4gKCdiLCAnZCwgJ2UpIHRcbiAgdmFsICggPj58ICkgOiAoJ2EsICdkLCAnZSkgdCAtPiAoJ2EgLT4gJ2IpIC0+ICgnYiwgJ2QsICdlKSB0XG5lbmRcblxubW9kdWxlIHR5cGUgU3ludGF4MyA9IHNpZ1xuICB0eXBlICgnYSwgJ2QsICdlKSB0XG5cbiAgbW9kdWxlIExldF9zeW50YXggOiBzaWdcbiAgICB2YWwgcmV0dXJuIDogJ2EgLT4gKCdhLCBfLCBfKSB0XG5cbiAgICBpbmNsdWRlIEluZml4MyB3aXRoIHR5cGUgKCdhLCAnZCwgJ2UpIHQgOj0gKCdhLCAnZCwgJ2UpIHRcblxuICAgIG1vZHVsZSBMZXRfc3ludGF4IDogc2lnXG4gICAgICB2YWwgcmV0dXJuIDogJ2EgLT4gKCdhLCBfLCBfKSB0XG4gICAgICB2YWwgYmluZCA6ICgnYSwgJ2QsICdlKSB0IC0+IGY6KCdhIC0+ICgnYiwgJ2QsICdlKSB0KSAtPiAoJ2IsICdkLCAnZSkgdFxuICAgICAgdmFsIG1hcCA6ICgnYSwgJ2QsICdlKSB0IC0+IGY6KCdhIC0+ICdiKSAtPiAoJ2IsICdkLCAnZSkgdFxuICAgICAgdmFsIGJvdGggOiAoJ2EsICdkLCAnZSkgdCAtPiAoJ2IsICdkLCAnZSkgdCAtPiAoJ2EgKiAnYiwgJ2QsICdlKSB0XG5cbiAgICAgIG1vZHVsZSBPcGVuX29uX3JocyA6IHNpZyBlbmRcbiAgICBlbmRcbiAgZW5kXG5lbmRcblxubW9kdWxlIHR5cGUgUzMgPSBzaWdcbiAgKCoqIFRoZSBzYW1lIGFzIHshU30gZXhjZXB0IHRoZSBtb25hZCB0eXBlIGhhcyB0aHJlZSBhcmd1bWVudHMuIFRoZSBzZWNvbmRcbiAgICAgIGFuZCB0aGlyZCBhcmUgYWx3YXlzIGp1c3QgcGFzc2VkIHRocm91Z2guICopXG5cbiAgdHlwZSAoJ2EsICdkLCAnZSkgdFxuXG4gIGluY2x1ZGUgSW5maXgzIHdpdGggdHlwZSAoJ2EsICdkLCAnZSkgdCA6PSAoJ2EsICdkLCAnZSkgdFxuICBpbmNsdWRlIFN5bnRheDMgd2l0aCB0eXBlICgnYSwgJ2QsICdlKSB0IDo9ICgnYSwgJ2QsICdlKSB0XG4gIG1vZHVsZSBNb25hZF9pbmZpeCA6IEluZml4MyB3aXRoIHR5cGUgKCdhLCAnZCwgJ2UpIHQgOj0gKCdhLCAnZCwgJ2UpIHRcblxuICB2YWwgYmluZCA6ICgnYSwgJ2QsICdlKSB0IC0+IGY6KCdhIC0+ICgnYiwgJ2QsICdlKSB0KSAtPiAoJ2IsICdkLCAnZSkgdFxuICB2YWwgcmV0dXJuIDogJ2EgLT4gKCdhLCBfLCBfKSB0XG4gIHZhbCBtYXAgOiAoJ2EsICdkLCAnZSkgdCAtPiBmOignYSAtPiAnYikgLT4gKCdiLCAnZCwgJ2UpIHRcbiAgdmFsIGpvaW4gOiAoKCdhLCAnZCwgJ2UpIHQsICdkLCAnZSkgdCAtPiAoJ2EsICdkLCAnZSkgdFxuICB2YWwgaWdub3JlX20gOiAoXywgJ2QsICdlKSB0IC0+ICh1bml0LCAnZCwgJ2UpIHRcbiAgdmFsIGFsbCA6ICgnYSwgJ2QsICdlKSB0IGxpc3QgLT4gKCdhIGxpc3QsICdkLCAnZSkgdFxuICB2YWwgYWxsX3VuaXQgOiAodW5pdCwgJ2QsICdlKSB0IGxpc3QgLT4gKHVuaXQsICdkLCAnZSkgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIEJhc2ljX2luZGV4ZWQgPSBzaWdcbiAgKCoqIEluZGV4ZWQgbW9uYWQsIGluIHRoZSBzdHlsZSBvZiBBdGtleS4gVGhlIHNlY29uZCBhbmQgdGhpcmQgcGFyYW1ldGVycyBhcmUgY29tcG9zZWRcbiAgICAgIGFjcm9zcyBhbGwgY29tcHV0YXRpb24uIFRvIHNlZSB0aGlzIG1vcmUgY2xlYXJseSwgeW91IGNhbiBsb29rIGF0IHRoZSB0eXBlIG9mIGJpbmQ6XG5cbiAgICAgIHtbXG4gICAgICAgIHZhbCBiaW5kIDogKCdhLCAnaSwgJ2opIHQgLT4gZjooJ2EgLT4gKCdiLCAnaiwgJ2spIHQpIC0+ICgnYiwgJ2ksICdrKSB0XG4gICAgICBdfVxuXG4gICAgICBhbmQgaXNvbGF0ZSBzb21lIG9mIHRoZSB0eXBlIHZhcmlhYmxlcyB0byBzZWUgdGhlaXIgaW5kaXZpZHVhbCBiZWhhdmlvcnM6XG5cbiAgICAgIHtbXG4gICAgICAgIHZhbCBiaW5kIDogJ2EgICAgICAgICAgICAgLT4gZjooJ2EgLT4gICdiICAgICAgICAgICApIC0+ICAnYlxuICAgICAgICB2YWwgYmluZCA6ICAgICAgJ2ksICdqICAgIC0+ICAgICAgICAgICAgICAgJ2osICdrICAgICAtPiAgICAgJ2ksICdrXG4gICAgICBdfVxuXG4gICAgICBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBBdGtleS1zdHlsZSBpbmRleGVkIG1vbmFkcywgc2VlOlxuXG4gICAgICB7dlxuICAgICAgICBQYXJhbWV0ZXJpc2VkIE5vdGlvbnMgb2YgQ29tcHV0YXRpb25cbiAgICAgICAgUm9iZXJ0IEF0a2V5XG4gICAgICAgIGh0dHA6Ly9iZW50bmliLm9yZy9wYXJhbW5vdGlvbnMtamZwLnBkZlxuICAgICAgdn0gKilcblxuICB0eXBlICgnYSwgJ2ksICdqKSB0XG5cbiAgdmFsIGJpbmQgOiAoJ2EsICdpLCAnaikgdCAtPiBmOignYSAtPiAoJ2IsICdqLCAnaykgdCkgLT4gKCdiLCAnaSwgJ2spIHRcblxuICB2YWwgbWFwXG4gICAgOiBbIGBEZWZpbmVfdXNpbmdfYmluZCB8IGBDdXN0b20gb2YgKCdhLCAnaSwgJ2opIHQgLT4gZjooJ2EgLT4gJ2IpIC0+ICgnYiwgJ2ksICdqKSB0IF1cblxuICB2YWwgcmV0dXJuIDogJ2EgLT4gKCdhLCAnaSwgJ2kpIHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBJbmZpeF9pbmRleGVkID0gc2lnXG4gICgqKiBTYW1lIGFzIHshSW5maXh9LCBleGNlcHQgdGhlIG1vbmFkIHR5cGUgaGFzIHRocmVlIGFyZ3VtZW50cy4gVGhlIHNlY29uZCBhbmRcbiAgICAgIHRoaXJkIGFyZSBjb21wb3NlZCBhY3Jvc3MgYWxsIGNvbXB1dGF0aW9uLiAqKVxuXG4gIHR5cGUgKCdhLCAnaSwgJ2opIHRcblxuICB2YWwgKCA+Pj0gKSA6ICgnYSwgJ2ksICdqKSB0IC0+ICgnYSAtPiAoJ2IsICdqLCAnaykgdCkgLT4gKCdiLCAnaSwgJ2spIHRcbiAgdmFsICggPj58ICkgOiAoJ2EsICdpLCAnaikgdCAtPiAoJ2EgLT4gJ2IpIC0+ICgnYiwgJ2ksICdqKSB0XG5lbmRcblxubW9kdWxlIHR5cGUgU3ludGF4X2luZGV4ZWQgPSBzaWdcbiAgdHlwZSAoJ2EsICdpLCAnaikgdFxuXG4gIG1vZHVsZSBMZXRfc3ludGF4IDogc2lnXG4gICAgdmFsIHJldHVybiA6ICdhIC0+ICgnYSwgJ2ksICdpKSB0XG5cbiAgICBpbmNsdWRlIEluZml4X2luZGV4ZWQgd2l0aCB0eXBlICgnYSwgJ2ksICdqKSB0IDo9ICgnYSwgJ2ksICdqKSB0XG5cbiAgICBtb2R1bGUgTGV0X3N5bnRheCA6IHNpZ1xuICAgICAgdmFsIHJldHVybiA6ICdhIC0+ICgnYSwgJ2ksICdpKSB0XG4gICAgICB2YWwgYmluZCA6ICgnYSwgJ2ksICdqKSB0IC0+IGY6KCdhIC0+ICgnYiwgJ2osICdrKSB0KSAtPiAoJ2IsICdpLCAnaykgdFxuICAgICAgdmFsIG1hcCA6ICgnYSwgJ2ksICdqKSB0IC0+IGY6KCdhIC0+ICdiKSAtPiAoJ2IsICdpLCAnaikgdFxuICAgICAgdmFsIGJvdGggOiAoJ2EsICdpLCAnaikgdCAtPiAoJ2IsICdqLCAnaykgdCAtPiAoJ2EgKiAnYiwgJ2ksICdrKSB0XG5cbiAgICAgIG1vZHVsZSBPcGVuX29uX3JocyA6IHNpZyBlbmRcbiAgICBlbmRcbiAgZW5kXG5lbmRcblxubW9kdWxlIHR5cGUgU19pbmRleGVkID0gc2lnXG4gICgqKiBUaGUgc2FtZSBhcyB7IVN9IGV4Y2VwdCB0aGUgbW9uYWQgdHlwZSBoYXMgdGhyZWUgYXJndW1lbnRzLiBUaGUgc2Vjb25kIGFuZFxuICAgICAgdGhpcmQgYXJlIGNvbXBvc2VkIGFjcm9zcyBhbGwgY29tcHV0YXRpb24uICopXG5cbiAgdHlwZSAoJ2EsICdpLCAnaikgdFxuXG4gIGluY2x1ZGUgSW5maXhfaW5kZXhlZCB3aXRoIHR5cGUgKCdhLCAnaSwgJ2opIHQgOj0gKCdhLCAnaSwgJ2opIHRcbiAgaW5jbHVkZSBTeW50YXhfaW5kZXhlZCB3aXRoIHR5cGUgKCdhLCAnaSwgJ2opIHQgOj0gKCdhLCAnaSwgJ2opIHRcbiAgbW9kdWxlIE1vbmFkX2luZml4IDogSW5maXhfaW5kZXhlZCB3aXRoIHR5cGUgKCdhLCAnaSwgJ2opIHQgOj0gKCdhLCAnaSwgJ2opIHRcblxuICB2YWwgYmluZCA6ICgnYSwgJ2ksICdqKSB0IC0+IGY6KCdhIC0+ICgnYiwgJ2osICdrKSB0KSAtPiAoJ2IsICdpLCAnaykgdFxuICB2YWwgcmV0dXJuIDogJ2EgLT4gKCdhLCAnaSwgJ2kpIHRcbiAgdmFsIG1hcCA6ICgnYSwgJ2ksICdqKSB0IC0+IGY6KCdhIC0+ICdiKSAtPiAoJ2IsICdpLCAnaikgdFxuICB2YWwgam9pbiA6ICgoJ2EsICdqLCAnaykgdCwgJ2ksICdqKSB0IC0+ICgnYSwgJ2ksICdrKSB0XG4gIHZhbCBpZ25vcmVfbSA6IChfLCAnaSwgJ2opIHQgLT4gKHVuaXQsICdpLCAnaikgdFxuICB2YWwgYWxsIDogKCdhLCAnaSwgJ2kpIHQgbGlzdCAtPiAoJ2EgbGlzdCwgJ2ksICdpKSB0XG4gIHZhbCBhbGxfdW5pdCA6ICh1bml0LCAnaSwgJ2kpIHQgbGlzdCAtPiAodW5pdCwgJ2ksICdpKSB0XG5lbmRcblxubW9kdWxlIFNfdG9fUzIgKFggOiBTKSA6IFMyIHdpdGggdHlwZSAoJ2EsICdlKSB0ID0gJ2EgWC50ID0gc3RydWN0XG4gIGluY2x1ZGUgWFxuXG4gIHR5cGUgKCdhLCAnZSkgdCA9ICdhIFgudFxuZW5kXG5cbm1vZHVsZSBTMl90b19TMyAoWCA6IFMyKSA6IFMzIHdpdGggdHlwZSAoJ2EsICdkLCAnZSkgdCA9ICgnYSwgJ2QpIFgudCA9IHN0cnVjdFxuICBpbmNsdWRlIFhcblxuICB0eXBlICgnYSwgJ2QsICdlKSB0ID0gKCdhLCAnZCkgWC50XG5lbmRcblxubW9kdWxlIFNfdG9fU19pbmRleGVkIChYIDogUykgOiBTX2luZGV4ZWQgd2l0aCB0eXBlICgnYSwgJ2ksICdqKSB0ID0gJ2EgWC50ID0gc3RydWN0XG4gIGluY2x1ZGUgWFxuXG4gIHR5cGUgKCdhLCAnaSwgJ2opIHQgPSAnYSBYLnRcbmVuZFxuXG5tb2R1bGUgUzJfdG9fUyAoWCA6IFMyKSA6IFMgd2l0aCB0eXBlICdhIHQgPSAoJ2EsIHVuaXQpIFgudCA9IHN0cnVjdFxuICBpbmNsdWRlIFhcblxuICB0eXBlICdhIHQgPSAoJ2EsIHVuaXQpIFgudFxuZW5kXG5cbm1vZHVsZSBTM190b19TMiAoWCA6IFMzKSA6IFMyIHdpdGggdHlwZSAoJ2EsICdlKSB0ID0gKCdhLCAnZSwgdW5pdCkgWC50ID0gc3RydWN0XG4gIGluY2x1ZGUgWFxuXG4gIHR5cGUgKCdhLCAnZSkgdCA9ICgnYSwgJ2UsIHVuaXQpIFgudFxuZW5kXG5cbm1vZHVsZSBTX2luZGV4ZWRfdG9fUzIgKFggOiBTX2luZGV4ZWQpIDogUzIgd2l0aCB0eXBlICgnYSwgJ2UpIHQgPSAoJ2EsICdlLCAnZSkgWC50ID1cbnN0cnVjdFxuICBpbmNsdWRlIFhcblxuICB0eXBlICgnYSwgJ2UpIHQgPSAoJ2EsICdlLCAnZSkgWC50XG5lbmRcblxubW9kdWxlIHR5cGUgTW9uYWQgPSBzaWdcbiAgKCoqIEEgbW9uYWQgaXMgYW4gYWJzdHJhY3Rpb24gb2YgdGhlIGNvbmNlcHQgb2Ygc2VxdWVuY2luZyBvZiBjb21wdXRhdGlvbnMuICBBIHZhbHVlIG9mXG4gICAgICB0eXBlIFsnYSBtb25hZF0gcmVwcmVzZW50cyBhIGNvbXB1dGF0aW9uIHRoYXQgcmV0dXJucyBhIHZhbHVlIG9mIHR5cGUgWydhXS4gKilcblxuICBtb2R1bGUgdHlwZSBCYXNpYyA9IEJhc2ljXG4gIG1vZHVsZSB0eXBlIEJhc2ljMiA9IEJhc2ljMlxuICBtb2R1bGUgdHlwZSBCYXNpYzMgPSBCYXNpYzNcbiAgbW9kdWxlIHR5cGUgQmFzaWNfaW5kZXhlZCA9IEJhc2ljX2luZGV4ZWRcbiAgbW9kdWxlIHR5cGUgSW5maXggPSBJbmZpeFxuICBtb2R1bGUgdHlwZSBJbmZpeDIgPSBJbmZpeDJcbiAgbW9kdWxlIHR5cGUgSW5maXgzID0gSW5maXgzXG4gIG1vZHVsZSB0eXBlIEluZml4X2luZGV4ZWQgPSBJbmZpeF9pbmRleGVkXG4gIG1vZHVsZSB0eXBlIFN5bnRheCA9IFN5bnRheFxuICBtb2R1bGUgdHlwZSBTeW50YXgyID0gU3ludGF4MlxuICBtb2R1bGUgdHlwZSBTeW50YXgzID0gU3ludGF4M1xuICBtb2R1bGUgdHlwZSBTeW50YXhfaW5kZXhlZCA9IFN5bnRheF9pbmRleGVkXG4gIG1vZHVsZSB0eXBlIFNfd2l0aG91dF9zeW50YXggPSBTX3dpdGhvdXRfc3ludGF4XG4gIG1vZHVsZSB0eXBlIFMgPSBTXG4gIG1vZHVsZSB0eXBlIFMyID0gUzJcbiAgbW9kdWxlIHR5cGUgUzMgPSBTM1xuICBtb2R1bGUgdHlwZSBTX2luZGV4ZWQgPSBTX2luZGV4ZWRcblxuICBtb2R1bGUgTWFrZSAoWCA6IEJhc2ljKSA6IFMgd2l0aCB0eXBlICdhIHQgOj0gJ2EgWC50XG4gIG1vZHVsZSBNYWtlMiAoWCA6IEJhc2ljMikgOiBTMiB3aXRoIHR5cGUgKCdhLCAnZSkgdCA6PSAoJ2EsICdlKSBYLnRcbiAgbW9kdWxlIE1ha2UzIChYIDogQmFzaWMzKSA6IFMzIHdpdGggdHlwZSAoJ2EsICdkLCAnZSkgdCA6PSAoJ2EsICdkLCAnZSkgWC50XG5cbiAgbW9kdWxlIE1ha2VfaW5kZXhlZCAoWCA6IEJhc2ljX2luZGV4ZWQpIDpcbiAgICBTX2luZGV4ZWQgd2l0aCB0eXBlICgnYSwgJ2QsICdlKSB0IDo9ICgnYSwgJ2QsICdlKSBYLnRcblxuICAoKiogRGVmaW5lIGEgbW9uYWQgdGhyb3VnaCBhbiBpc29tb3JwaGlzbSB3aXRoIGFuIGV4aXN0aW5nIG1vbmFkLiBGb3IgZXhhbXBsZTpcblxuICAgICAge1tcbiAgICAgICAgdHlwZSAnYSB0ID0geyB2YWx1ZSA6ICdhIH1cblxuICAgICAgICBpbmNsdWRlIE1vbmFkLk9mX21vbmFkIChNb25hZC5JZGVudCkgKHN0cnVjdFxuICAgICAgICAgICAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICAgICAgICAgICAgbGV0IHRvX21vbmFkIHsgdmFsdWUgfSA9IHZhbHVlXG4gICAgICAgICAgICBsZXQgb2ZfbW9uYWQgdmFsdWUgPSB7IHZhbHVlIH1cbiAgICAgICAgICBlbmQpXG4gICAgICBdfSAqKVxuICBtb2R1bGUgT2ZfbW9uYWRcbiAgICAgIChNb25hZCA6IFMpIChNIDogc2lnXG4gICAgICAgICAgICAgICAgICAgICB0eXBlICdhIHRcblxuICAgICAgICAgICAgICAgICAgICAgdmFsIHRvX21vbmFkIDogJ2EgdCAtPiAnYSBNb25hZC50XG4gICAgICAgICAgICAgICAgICAgICB2YWwgb2ZfbW9uYWQgOiAnYSBNb25hZC50IC0+ICdhIHRcbiAgICAgICAgICAgICAgICAgICBlbmQpIDogUyB3aXRoIHR5cGUgJ2EgdCA6PSAnYSBNLnRcblxuICBtb2R1bGUgT2ZfbW9uYWQyXG4gICAgICAoTW9uYWQgOiBTMikgKE0gOiBzaWdcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlICgnYSwgJ2IpIHRcblxuICAgICAgICAgICAgICAgICAgICAgIHZhbCB0b19tb25hZCA6ICgnYSwgJ2IpIHQgLT4gKCdhLCAnYikgTW9uYWQudFxuICAgICAgICAgICAgICAgICAgICAgIHZhbCBvZl9tb25hZCA6ICgnYSwgJ2IpIE1vbmFkLnQgLT4gKCdhLCAnYikgdFxuICAgICAgICAgICAgICAgICAgICBlbmQpIDogUzIgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgTS50XG5cbiAgbW9kdWxlIE9mX21vbmFkM1xuICAgICAgKE1vbmFkIDogUzMpIChNIDogc2lnXG4gICAgICAgICAgICAgICAgICAgICAgdHlwZSAoJ2EsICdiLCAnYykgdFxuXG4gICAgICAgICAgICAgICAgICAgICAgdmFsIHRvX21vbmFkIDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYiwgJ2MpIE1vbmFkLnRcbiAgICAgICAgICAgICAgICAgICAgICB2YWwgb2ZfbW9uYWQgOiAoJ2EsICdiLCAnYykgTW9uYWQudCAtPiAoJ2EsICdiLCAnYykgdFxuICAgICAgICAgICAgICAgICAgICBlbmQpIDogUzMgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSB0IDo9ICgnYSwgJ2IsICdjKSBNLnRcblxuICBtb2R1bGUgT2ZfbW9uYWRfaW5kZXhlZFxuICAgICAgKE1vbmFkIDogU19pbmRleGVkKSAoTSA6IHNpZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlICgnYSwgJ2ksICdqKSB0XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsIHRvX21vbmFkIDogKCdhLCAnaSwgJ2opIHQgLT4gKCdhLCAnaSwgJ2opIE1vbmFkLnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsIG9mX21vbmFkIDogKCdhLCAnaSwgJ2opIE1vbmFkLnQgLT4gKCdhLCAnaSwgJ2opIHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCkgOiBTX2luZGV4ZWQgd2l0aCB0eXBlICgnYSwgJ2ksICdqKSB0IDo9ICgnYSwgJ2ksICdqKSBNLnRcblxuICBtb2R1bGUgSWRlbnQgOiBTIHdpdGggdHlwZSAnYSB0ID0gJ2FcbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5tb2R1bGUgTGlzdCA9IExpc3QwXG5pbmNsdWRlIE1vbmFkX2ludGZcblxubW9kdWxlIHR5cGUgQmFzaWNfZ2VuZXJhbCA9IHNpZ1xuICB0eXBlICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHRcblxuICB2YWwgYmluZFxuICAgIDogICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHRcbiAgICAtPiBmOignYSAtPiAoJ2IsICdqLCAnaywgJ2QsICdlKSB0KVxuICAgIC0+ICgnYiwgJ2ksICdrLCAnZCwgJ2UpIHRcblxuICB2YWwgbWFwXG4gICAgOiBbIGBEZWZpbmVfdXNpbmdfYmluZFxuICAgICAgfCBgQ3VzdG9tIG9mICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHQgLT4gZjooJ2EgLT4gJ2IpIC0+ICgnYiwgJ2ksICdqLCAnZCwgJ2UpIHRcbiAgICAgIF1cblxuICB2YWwgcmV0dXJuIDogJ2EgLT4gKCdhLCAnaSwgJ2ksICdkLCAnZSkgdFxuZW5kXG5cbm1vZHVsZSBNYWtlX2dlbmVyYWwgKE0gOiBCYXNpY19nZW5lcmFsKSA9IHN0cnVjdFxuICBsZXQgYmluZCA9IE0uYmluZFxuICBsZXQgcmV0dXJuID0gTS5yZXR1cm5cbiAgbGV0IG1hcF92aWFfYmluZCBtYSB+ZiA9IE0uYmluZCBtYSB+ZjooZnVuIGEgLT4gTS5yZXR1cm4gKGYgYSkpXG5cbiAgbGV0IG1hcCA9XG4gICAgbWF0Y2ggTS5tYXAgd2l0aFxuICAgIHwgYERlZmluZV91c2luZ19iaW5kIC0+IG1hcF92aWFfYmluZFxuICAgIHwgYEN1c3RvbSB4IC0+IHhcbiAgOztcblxuICBtb2R1bGUgTW9uYWRfaW5maXggPSBzdHJ1Y3RcbiAgICBsZXQgKCA+Pj0gKSB0IGYgPSBiaW5kIHQgfmZcbiAgICBsZXQgKCA+PnwgKSB0IGYgPSBtYXAgdCB+ZlxuICBlbmRcblxuICBpbmNsdWRlIE1vbmFkX2luZml4XG5cbiAgbW9kdWxlIExldF9zeW50YXggPSBzdHJ1Y3RcbiAgICBsZXQgcmV0dXJuID0gcmV0dXJuXG5cbiAgICBpbmNsdWRlIE1vbmFkX2luZml4XG5cbiAgICBtb2R1bGUgTGV0X3N5bnRheCA9IHN0cnVjdFxuICAgICAgbGV0IHJldHVybiA9IHJldHVyblxuICAgICAgbGV0IGJpbmQgPSBiaW5kXG4gICAgICBsZXQgbWFwID0gbWFwXG4gICAgICBsZXQgYm90aCBhIGIgPSBhID4+PSBmdW4gYSAtPiBiID4+fCBmdW4gYiAtPiBhLCBiXG5cbiAgICAgIG1vZHVsZSBPcGVuX29uX3JocyA9IHN0cnVjdCBlbmRcbiAgICBlbmRcbiAgZW5kXG5cbiAgbGV0IGpvaW4gdCA9IHQgPj49IGZ1biB0JyAtPiB0J1xuICBsZXQgaWdub3JlX20gdCA9IG1hcCB0IH5mOihmdW4gXyAtPiAoKSlcblxuICBsZXQgYWxsID1cbiAgICBsZXQgcmVjIGxvb3AgdnMgPSBmdW5jdGlvblxuICAgICAgfCBbXSAtPiByZXR1cm4gKExpc3QucmV2IHZzKVxuICAgICAgfCB0IDo6IHRzIC0+IHQgPj49IGZ1biB2IC0+IGxvb3AgKHYgOjogdnMpIHRzXG4gICAgaW5cbiAgICBmdW4gdHMgLT4gbG9vcCBbXSB0c1xuICA7O1xuXG4gIGxldCByZWMgYWxsX3VuaXQgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gcmV0dXJuICgpXG4gICAgfCB0IDo6IHRzIC0+IHQgPj49IGZ1biAoKSAtPiBhbGxfdW5pdCB0c1xuICA7O1xuZW5kXG5cbm1vZHVsZSBNYWtlX2luZGV4ZWQgKE0gOiBCYXNpY19pbmRleGVkKSA6XG4gIFNfaW5kZXhlZCB3aXRoIHR5cGUgKCdhLCAnaSwgJ2opIHQgOj0gKCdhLCAnaSwgJ2opIE0udCA9IE1ha2VfZ2VuZXJhbCAoc3RydWN0XG4gICAgaW5jbHVkZSBNXG5cbiAgICB0eXBlICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHQgPSAoJ2EsICdpLCAnaikgTS50XG4gIGVuZClcblxubW9kdWxlIE1ha2UzIChNIDogQmFzaWMzKSA6IFMzIHdpdGggdHlwZSAoJ2EsICdkLCAnZSkgdCA6PSAoJ2EsICdkLCAnZSkgTS50ID1cbiAgTWFrZV9nZW5lcmFsIChzdHJ1Y3RcbiAgICBpbmNsdWRlIE1cblxuICAgIHR5cGUgKCdhLCAnaSwgJ2osICdkLCAnZSkgdCA9ICgnYSwgJ2QsICdlKSBNLnRcbiAgZW5kKVxuXG5tb2R1bGUgTWFrZTIgKE0gOiBCYXNpYzIpIDogUzIgd2l0aCB0eXBlICgnYSwgJ2QpIHQgOj0gKCdhLCAnZCkgTS50ID0gTWFrZV9nZW5lcmFsIChzdHJ1Y3RcbiAgICBpbmNsdWRlIE1cblxuICAgIHR5cGUgKCdhLCAnaSwgJ2osICdkLCAnZSkgdCA9ICgnYSwgJ2QpIE0udFxuICBlbmQpXG5cbm1vZHVsZSBNYWtlIChNIDogQmFzaWMpIDogUyB3aXRoIHR5cGUgJ2EgdCA6PSAnYSBNLnQgPSBNYWtlX2dlbmVyYWwgKHN0cnVjdFxuICAgIGluY2x1ZGUgTVxuXG4gICAgdHlwZSAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0ID0gJ2EgTS50XG4gIGVuZClcblxubW9kdWxlIE9mX21vbmFkX2dlbmVyYWwgKE1vbmFkIDogc2lnXG4gICAgdHlwZSAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0XG5cbiAgICB2YWwgYmluZFxuICAgICAgOiAgKCdhLCAnaSwgJ2osICdkLCAnZSkgdFxuICAgICAgLT4gZjooJ2EgLT4gKCdiLCAnaiwgJ2ssICdkLCAnZSkgdClcbiAgICAgIC0+ICgnYiwgJ2ksICdrLCAnZCwgJ2UpIHRcblxuICAgIHZhbCBtYXAgOiAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0IC0+IGY6KCdhIC0+ICdiKSAtPiAoJ2IsICdpLCAnaiwgJ2QsICdlKSB0XG4gICAgdmFsIHJldHVybiA6ICdhIC0+ICgnYSwgJ2ksICdpLCAnZCwgJ2UpIHRcbiAgZW5kKSAoTSA6IHNpZ1xuICAgICAgICAgIHR5cGUgKCdhLCAnaSwgJ2osICdkLCAnZSkgdFxuXG4gICAgICAgICAgdmFsIHRvX21vbmFkIDogKCdhLCAnaSwgJ2osICdkLCAnZSkgdCAtPiAoJ2EsICdpLCAnaiwgJ2QsICdlKSBNb25hZC50XG4gICAgICAgICAgdmFsIG9mX21vbmFkIDogKCdhLCAnaSwgJ2osICdkLCAnZSkgTW9uYWQudCAtPiAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0XG4gICAgICAgIGVuZCkgPVxuICBNYWtlX2dlbmVyYWwgKHN0cnVjdFxuICAgIHR5cGUgKCdhLCAnaSwgJ2osICdkLCAnZSkgdCA9ICgnYSwgJ2ksICdqLCAnZCwgJ2UpIE0udFxuXG4gICAgbGV0IHJldHVybiBhID0gTS5vZl9tb25hZCAoTW9uYWQucmV0dXJuIGEpXG4gICAgbGV0IGJpbmQgdCB+ZiA9IE0ub2ZfbW9uYWQgKE1vbmFkLmJpbmQgKE0udG9fbW9uYWQgdCkgfmY6KGZ1biBhIC0+IE0udG9fbW9uYWQgKGYgYSkpKVxuICAgIGxldCBtYXAgPSBgQ3VzdG9tIChmdW4gdCB+ZiAtPiBNLm9mX21vbmFkIChNb25hZC5tYXAgKE0udG9fbW9uYWQgdCkgfmYpKVxuICBlbmQpXG5cbm1vZHVsZSBPZl9tb25hZF9pbmRleGVkXG4gICAgKE1vbmFkIDogU19pbmRleGVkKSAoTSA6IHNpZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSAoJ2EsICdpLCAnaikgdFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgdG9fbW9uYWQgOiAoJ2EsICdpLCAnaikgdCAtPiAoJ2EsICdpLCAnaikgTW9uYWQudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsIG9mX21vbmFkIDogKCdhLCAnaSwgJ2opIE1vbmFkLnQgLT4gKCdhLCAnaSwgJ2opIHRcbiAgICAgICAgICAgICAgICAgICAgICAgICBlbmQpID1cbiAgT2ZfbW9uYWRfZ2VuZXJhbFxuICAgIChzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgTW9uYWRcblxuICAgICAgdHlwZSAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0ID0gKCdhLCAnaSwgJ2opIE1vbmFkLnRcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgaW5jbHVkZSBNXG5cbiAgICAgIHR5cGUgKCdhLCAnaSwgJ2osICdkLCAnZSkgdCA9ICgnYSwgJ2ksICdqKSBNLnRcbiAgICBlbmQpXG5cbm1vZHVsZSBPZl9tb25hZDNcbiAgICAoTW9uYWQgOiBTMykgKE0gOiBzaWdcbiAgICAgICAgICAgICAgICAgICAgdHlwZSAoJ2EsICdiLCAnYykgdFxuXG4gICAgICAgICAgICAgICAgICAgIHZhbCB0b19tb25hZCA6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IsICdjKSBNb25hZC50XG4gICAgICAgICAgICAgICAgICAgIHZhbCBvZl9tb25hZCA6ICgnYSwgJ2IsICdjKSBNb25hZC50IC0+ICgnYSwgJ2IsICdjKSB0XG4gICAgICAgICAgICAgICAgICBlbmQpID1cbiAgT2ZfbW9uYWRfZ2VuZXJhbFxuICAgIChzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgTW9uYWRcblxuICAgICAgdHlwZSAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0ID0gKCdhLCAnZCwgJ2UpIE1vbmFkLnRcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgaW5jbHVkZSBNXG5cbiAgICAgIHR5cGUgKCdhLCAnaSwgJ2osICdkLCAnZSkgdCA9ICgnYSwgJ2QsICdlKSBNLnRcbiAgICBlbmQpXG5cbm1vZHVsZSBPZl9tb25hZDJcbiAgICAoTW9uYWQgOiBTMikgKE0gOiBzaWdcbiAgICAgICAgICAgICAgICAgICAgdHlwZSAoJ2EsICdiKSB0XG5cbiAgICAgICAgICAgICAgICAgICAgdmFsIHRvX21vbmFkIDogKCdhLCAnYikgdCAtPiAoJ2EsICdiKSBNb25hZC50XG4gICAgICAgICAgICAgICAgICAgIHZhbCBvZl9tb25hZCA6ICgnYSwgJ2IpIE1vbmFkLnQgLT4gKCdhLCAnYikgdFxuICAgICAgICAgICAgICAgICAgZW5kKSA9XG4gIE9mX21vbmFkX2dlbmVyYWxcbiAgICAoc3RydWN0XG4gICAgICBpbmNsdWRlIE1vbmFkXG5cbiAgICAgIHR5cGUgKCdhLCAnaSwgJ2osICdkLCAnZSkgdCA9ICgnYSwgJ2QpIE1vbmFkLnRcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgaW5jbHVkZSBNXG5cbiAgICAgIHR5cGUgKCdhLCAnaSwgJ2osICdkLCAnZSkgdCA9ICgnYSwgJ2QpIE0udFxuICAgIGVuZClcblxubW9kdWxlIE9mX21vbmFkXG4gICAgKE1vbmFkIDogUykgKE0gOiBzaWdcbiAgICAgICAgICAgICAgICAgICB0eXBlICdhIHRcblxuICAgICAgICAgICAgICAgICAgIHZhbCB0b19tb25hZCA6ICdhIHQgLT4gJ2EgTW9uYWQudFxuICAgICAgICAgICAgICAgICAgIHZhbCBvZl9tb25hZCA6ICdhIE1vbmFkLnQgLT4gJ2EgdFxuICAgICAgICAgICAgICAgICBlbmQpID1cbiAgT2ZfbW9uYWRfZ2VuZXJhbFxuICAgIChzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgTW9uYWRcblxuICAgICAgdHlwZSAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0ID0gJ2EgTW9uYWQudFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICBpbmNsdWRlIE1cblxuICAgICAgdHlwZSAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0ID0gJ2EgTS50XG4gICAgZW5kKVxuXG5tb2R1bGUgSWRlbnQgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gJ2FcblxuICBpbmNsdWRlIE1ha2UgKHN0cnVjdFxuICAgICAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICAgICAgbGV0IGJpbmQgYSB+ZiA9IGYgYVxuICAgICAgbGV0IHJldHVybiBhID0gYVxuICAgICAgbGV0IG1hcCA9IGBDdXN0b20gKGZ1biBhIH5mIC0+IGYgYSlcbiAgICBlbmQpXG5lbmRcbiIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBBcHBsaWNhdGl2ZV9pbnRmXG5tb2R1bGUgTGlzdCA9IExpc3QwXG5cbigqKiBUaGlzIG1vZHVsZSBzZXJ2ZXMgbW9zdGx5IGFzIGEgcGFydGlhbCBjaGVjayB0aGF0IFtTMl0gYW5kIFtTXSBhcmUgaW4gc3luYywgYnV0XG4gICAgYWN0dWFsbHkgY2FsbGluZyBpdCBpcyBvY2Nhc2lvbmFsbHkgdXNlZnVsLiAqKVxubW9kdWxlIFNfdG9fUzIgKFggOiBTKSA6IFMyIHdpdGggdHlwZSAoJ2EsICdlKSB0ID0gJ2EgWC50ID0gc3RydWN0XG4gIGluY2x1ZGUgWFxuXG4gIHR5cGUgKCdhLCAnZSkgdCA9ICdhIFgudFxuZW5kXG5cbm1vZHVsZSBTMl90b19TIChYIDogUzIpIDogUyB3aXRoIHR5cGUgJ2EgdCA9ICgnYSwgdW5pdCkgWC50ID0gc3RydWN0XG4gIGluY2x1ZGUgWFxuXG4gIHR5cGUgJ2EgdCA9ICgnYSwgdW5pdCkgWC50XG5lbmRcblxubW9kdWxlIFMyX3RvX1MzIChYIDogUzIpIDogUzMgd2l0aCB0eXBlICgnYSwgJ2QsICdlKSB0ID0gKCdhLCAnZCkgWC50ID0gc3RydWN0XG4gIGluY2x1ZGUgWFxuXG4gIHR5cGUgKCdhLCAnZCwgJ2UpIHQgPSAoJ2EsICdkKSBYLnRcbmVuZFxuXG5tb2R1bGUgUzNfdG9fUzIgKFggOiBTMykgOiBTMiB3aXRoIHR5cGUgKCdhLCAnZCkgdCA9ICgnYSwgJ2QsIHVuaXQpIFgudCA9IHN0cnVjdFxuICBpbmNsdWRlIFhcblxuICB0eXBlICgnYSwgJ2QpIHQgPSAoJ2EsICdkLCB1bml0KSBYLnRcbmVuZFxuXG5tb2R1bGUgTWFrZTMgKFggOiBCYXNpYzMpIDogUzMgd2l0aCB0eXBlICgnYSwgJ2QsICdlKSB0IDo9ICgnYSwgJ2QsICdlKSBYLnQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBYXG5cbiAgbGV0ICggPCo+ICkgPSBhcHBseVxuICBsZXQgZGVyaXZlZF9tYXAgdCB+ZiA9IHJldHVybiBmIDwqPiB0XG5cbiAgbGV0IG1hcCA9XG4gICAgbWF0Y2ggWC5tYXAgd2l0aFxuICAgIHwgYERlZmluZV91c2luZ19hcHBseSAtPiBkZXJpdmVkX21hcFxuICAgIHwgYEN1c3RvbSB4IC0+IHhcbiAgOztcblxuICBsZXQgKCA+PnwgKSB0IGYgPSBtYXAgdCB+ZlxuICBsZXQgbWFwMiB0YSB0YiB+ZiA9IG1hcCB+ZiB0YSA8Kj4gdGJcbiAgbGV0IG1hcDMgdGEgdGIgdGMgfmYgPSBtYXAgfmYgdGEgPCo+IHRiIDwqPiB0Y1xuICBsZXQgYWxsIHRzID0gTGlzdC5mb2xkX3JpZ2h0IHRzIH5pbml0OihyZXR1cm4gW10pIH5mOihtYXAyIH5mOihmdW4geCB4cyAtPiB4IDo6IHhzKSlcbiAgbGV0IGJvdGggdGEgdGIgPSBtYXAyIHRhIHRiIH5mOihmdW4gYSBiIC0+IGEsIGIpXG4gIGxldCAoICo+ICkgdSB2ID0gcmV0dXJuIChmdW4gKCkgeSAtPiB5KSA8Kj4gdSA8Kj4gdlxuICBsZXQgKCA8KiApIHUgdiA9IHJldHVybiAoZnVuIHggKCkgLT4geCkgPCo+IHUgPCo+IHZcbiAgbGV0IGFsbF91bml0IHRzID0gTGlzdC5mb2xkIHRzIH5pbml0OihyZXR1cm4gKCkpIH5mOiggKj4gKVxuXG4gIG1vZHVsZSBBcHBsaWNhdGl2ZV9pbmZpeCA9IHN0cnVjdFxuICAgIGxldCAoIDwqPiApID0gKCA8Kj4gKVxuICAgIGxldCAoICo+ICkgPSAoICo+IClcbiAgICBsZXQgKCA8KiApID0gKCA8KiApXG4gICAgbGV0ICggPj58ICkgPSAoID4+fCApXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBNYWtlMiAoWCA6IEJhc2ljMikgOiBTMiB3aXRoIHR5cGUgKCdhLCAnZSkgdCA6PSAoJ2EsICdlKSBYLnQgPSBNYWtlMyAoc3RydWN0XG4gICAgaW5jbHVkZSBYXG5cbiAgICB0eXBlICgnYSwgJ2QsICdlKSB0ID0gKCdhLCAnZCkgWC50XG4gIGVuZClcblxubW9kdWxlIE1ha2UgKFggOiBCYXNpYykgOiBTIHdpdGggdHlwZSAnYSB0IDo9ICdhIFgudCA9IE1ha2UyIChzdHJ1Y3RcbiAgICBpbmNsdWRlIFhcblxuICAgIHR5cGUgKCdhLCAnZSkgdCA9ICdhIFgudFxuICBlbmQpXG5cbm1vZHVsZSBNYWtlX2xldF9zeW50YXgzXG4gICAgKFggOiBGb3JfbGV0X3N5bnRheDMpIChJbnRmIDogc2lnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZSB0eXBlIFNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZClcbiAgICAoSW1wbCA6IEludGYuUykgPVxuc3RydWN0XG4gIG1vZHVsZSBMZXRfc3ludGF4ID0gc3RydWN0XG4gICAgaW5jbHVkZSBYXG5cbiAgICBtb2R1bGUgTGV0X3N5bnRheCA9IHN0cnVjdFxuICAgICAgaW5jbHVkZSBYXG4gICAgICBtb2R1bGUgT3Blbl9vbl9yaHMgPSBJbXBsXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBNYWtlX2xldF9zeW50YXgyXG4gICAgKFggOiBGb3JfbGV0X3N5bnRheDIpIChJbnRmIDogc2lnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZSB0eXBlIFNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZClcbiAgICAoSW1wbCA6IEludGYuUykgPVxuICBNYWtlX2xldF9zeW50YXgzXG4gICAgKHN0cnVjdFxuICAgICAgaW5jbHVkZSBYXG5cbiAgICAgIHR5cGUgKCdhLCAnZCwgXykgdCA9ICgnYSwgJ2QpIFgudFxuICAgIGVuZClcbiAgICAoSW50ZilcbiAgICAoSW1wbClcblxubW9kdWxlIE1ha2VfbGV0X3N5bnRheFxuICAgIChYIDogRm9yX2xldF9zeW50YXgpIChJbnRmIDogc2lnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxlIHR5cGUgU1xuICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQpXG4gICAgKEltcGwgOiBJbnRmLlMpID1cbiAgTWFrZV9sZXRfc3ludGF4MlxuICAgIChzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgWFxuXG4gICAgICB0eXBlICgnYSwgXykgdCA9ICdhIFgudFxuICAgIGVuZClcbiAgICAoSW50ZilcbiAgICAoSW1wbClcblxuKCoqIFRoaXMgZnVuY3RvciBjbG9zZWx5IHJlc2VtYmxlcyBbTWFrZTNdLCBhbmQgaW5kZWVkIGl0IGNvdWxkIGJlIGltcGxlbWVudGVkXG4gICAgbXVjaCBzaG9ydGVyIGluIHRlcm1zIG9mIFtNYWtlM10uIEhvd2V2ZXIsIHdlIGltcGxlbWVudCBpdCBieSBoYW5kIHNvIHRoYXRcbiAgICB0aGUgcmVzdWx0aW5nIGZ1bmN0aW9ucyBhcmUgbW9yZSBlZmZpY2llbnQsIGUuZy4gdXNpbmcgW21hcDJdIGRpcmVjdGx5IGluc3RlYWQgb2ZcbiAgICBkZWZpbmluZyBbYXBwbHldIGluIHRlcm1zIG9mIGl0IGFuZCB0aGVuIFttYXAyXSBpbiB0ZXJtcyBvZiB0aGF0LiBGb3IgbW9zdFxuICAgIGFwcGxpY2F0aXZlcyB0aGlzIGRvZXMgbm90IG1hdHRlciwgYnV0IGZvciBzb21lIChzdWNoIGFzIEJvbnNhaS5WYWx1ZS50KSwgaXQgaGFzIGFcbiAgICBsYXJnZXIgaW1wYWN0LiAqKVxubW9kdWxlIE1ha2UzX3VzaW5nX21hcDIgKFggOiBCYXNpYzNfdXNpbmdfbWFwMikgOlxuICBTMyB3aXRoIHR5cGUgKCdhLCAnZCwgJ2UpIHQgOj0gKCdhLCAnZCwgJ2UpIFgudCA9IHN0cnVjdFxuICBpbmNsdWRlIFhcblxuICBsZXQgYXBwbHkgdGYgdGEgPSBtYXAyIHRmIHRhIH5mOihmdW4gZiBhIC0+IGYgYSlcbiAgbGV0ICggPCo+ICkgPSBhcHBseVxuICBsZXQgZGVyaXZlZF9tYXAgdCB+ZiA9IHJldHVybiBmIDwqPiB0XG5cbiAgbGV0IG1hcCA9XG4gICAgbWF0Y2ggWC5tYXAgd2l0aFxuICAgIHwgYERlZmluZV91c2luZ19tYXAyIC0+IGRlcml2ZWRfbWFwXG4gICAgfCBgQ3VzdG9tIHggLT4geFxuICA7O1xuXG4gIGxldCAoID4+fCApIHQgZiA9IG1hcCB0IH5mXG4gIGxldCBib3RoIHRhIHRiID0gbWFwMiB0YSB0YiB+ZjooZnVuIGEgYiAtPiBhLCBiKVxuICBsZXQgbWFwMyB0YSB0YiB0YyB+ZiA9IG1hcDIgKG1hcDIgdGEgdGIgfmYpIHRjIH5mOihmdW4gZmFiIGMgLT4gZmFiIGMpXG4gIGxldCBhbGwgdHMgPSBMaXN0LmZvbGRfcmlnaHQgdHMgfmluaXQ6KHJldHVybiBbXSkgfmY6KG1hcDIgfmY6KGZ1biB4IHhzIC0+IHggOjogeHMpKVxuICBsZXQgKCAqPiApIHUgdiA9IG1hcDIgdSB2IH5mOihmdW4gKCkgeSAtPiB5KVxuICBsZXQgKCA8KiApIHUgdiA9IG1hcDIgdSB2IH5mOihmdW4geCAoKSAtPiB4KVxuICBsZXQgYWxsX3VuaXQgdHMgPSBMaXN0LmZvbGQgdHMgfmluaXQ6KHJldHVybiAoKSkgfmY6KCAqPiApXG5cbiAgbW9kdWxlIEFwcGxpY2F0aXZlX2luZml4ID0gc3RydWN0XG4gICAgbGV0ICggPCo+ICkgPSAoIDwqPiApXG4gICAgbGV0ICggKj4gKSA9ICggKj4gKVxuICAgIGxldCAoIDwqICkgPSAoIDwqIClcbiAgICBsZXQgKCA+PnwgKSA9ICggPj58IClcbiAgZW5kXG5lbmRcblxubW9kdWxlIE1ha2UyX3VzaW5nX21hcDIgKFggOiBCYXNpYzJfdXNpbmdfbWFwMikgOlxuICBTMiB3aXRoIHR5cGUgKCdhLCAnZSkgdCA6PSAoJ2EsICdlKSBYLnQgPSBNYWtlM191c2luZ19tYXAyIChzdHJ1Y3RcbiAgICBpbmNsdWRlIFhcblxuICAgIHR5cGUgKCdhLCAnZCwgJ2UpIHQgPSAoJ2EsICdkKSBYLnRcbiAgZW5kKVxuXG5tb2R1bGUgTWFrZV91c2luZ19tYXAyIChYIDogQmFzaWNfdXNpbmdfbWFwMikgOiBTIHdpdGggdHlwZSAnYSB0IDo9ICdhIFgudCA9XG4gIE1ha2UyX3VzaW5nX21hcDIgKHN0cnVjdFxuICAgIGluY2x1ZGUgWFxuXG4gICAgdHlwZSAoJ2EsICdlKSB0ID0gJ2EgWC50XG4gIGVuZClcblxubW9kdWxlIE9mX21vbmFkMiAoTSA6IE1vbmFkLlMyKSA6IFMyIHdpdGggdHlwZSAoJ2EsICdlKSB0IDo9ICgnYSwgJ2UpIE0udCA9IE1ha2UyIChzdHJ1Y3RcbiAgICB0eXBlICgnYSwgJ2UpIHQgPSAoJ2EsICdlKSBNLnRcblxuICAgIGxldCByZXR1cm4gPSBNLnJldHVyblxuICAgIGxldCBhcHBseSBtZiBteCA9IE0uYmluZCBtZiB+ZjooZnVuIGYgLT4gTS5tYXAgbXggfmYpXG4gICAgbGV0IG1hcCA9IGBDdXN0b20gTS5tYXBcbiAgZW5kKVxuXG5tb2R1bGUgT2ZfbW9uYWQgKE0gOiBNb25hZC5TKSA6IFMgd2l0aCB0eXBlICdhIHQgOj0gJ2EgTS50ID0gT2ZfbW9uYWQyIChzdHJ1Y3RcbiAgICBpbmNsdWRlIE1cblxuICAgIHR5cGUgKCdhLCBfKSB0ID0gJ2EgTS50XG4gIGVuZClcblxubW9kdWxlIENvbXBvc2UgKEYgOiBTKSAoRyA6IFMpIDogUyB3aXRoIHR5cGUgJ2EgdCA9ICdhIEYudCBHLnQgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gJ2EgRi50IEcudFxuXG4gIGluY2x1ZGUgTWFrZSAoc3RydWN0XG4gICAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gICAgICBsZXQgcmV0dXJuIGEgPSBHLnJldHVybiAoRi5yZXR1cm4gYSlcbiAgICAgIGxldCBhcHBseSB0ZiB0eCA9IEcuYXBwbHkgKEcubWFwIH5mOkYuYXBwbHkgdGYpIHR4XG4gICAgICBsZXQgY3VzdG9tX21hcCB0IH5mID0gRy5tYXAgfmY6KEYubWFwIH5mKSB0XG4gICAgICBsZXQgbWFwID0gYEN1c3RvbSBjdXN0b21fbWFwXG4gICAgZW5kKVxuZW5kXG5cbm1vZHVsZSBQYWlyIChGIDogUykgKEcgOiBTKSA6IFMgd2l0aCB0eXBlICdhIHQgPSAnYSBGLnQgKiAnYSBHLnQgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gJ2EgRi50ICogJ2EgRy50XG5cbiAgaW5jbHVkZSBNYWtlIChzdHJ1Y3RcbiAgICAgIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgICAgIGxldCByZXR1cm4gYSA9IEYucmV0dXJuIGEsIEcucmV0dXJuIGFcbiAgICAgIGxldCBhcHBseSB0ZiB0eCA9IEYuYXBwbHkgKGZzdCB0ZikgKGZzdCB0eCksIEcuYXBwbHkgKHNuZCB0ZikgKHNuZCB0eClcbiAgICAgIGxldCBjdXN0b21fbWFwIHQgfmYgPSBGLm1hcCB+ZiAoZnN0IHQpLCBHLm1hcCB+ZiAoc25kIHQpXG4gICAgICBsZXQgbWFwID0gYEN1c3RvbSBjdXN0b21fbWFwXG4gICAgZW5kKVxuZW5kXG4iLCIoKiBbQnl0ZXMwXSBkZWZpbmVzIHN0cmluZyBmdW5jdGlvbnMgdGhhdCBhcmUgcHJpbWl0aXZlcyBvciBjYW4gYmUgc2ltcGx5XG4gICBkZWZpbmVkIGluIHRlcm1zIG9mIFtDYW1sLkJ5dGVzXS4gW0J5dGVzMF0gaXMgaW50ZW5kZWQgdG8gY29tcGxldGVseSBleHByZXNzXG4gICB0aGUgcGFydCBvZiBbQ2FtbC5CeXRlc10gdGhhdCBbQmFzZV0gdXNlcyAtLSBubyBvdGhlciBmaWxlIGluIEJhc2Ugb3RoZXJcbiAgIHRoYW4gYnl0ZXMwLm1sIHNob3VsZCB1c2UgW0NhbWwuQnl0ZXNdLiBbQnl0ZXMwXSBoYXMgZmV3IGRlcGVuZGVuY2llcywgYW5kXG4gICBzbyBpcyBhdmFpbGFibGUgZWFybHkgaW4gQmFzZSdzIGJ1aWxkIG9yZGVyLlxuXG4gICBBbGwgQmFzZSBmaWxlcyB0aGF0IG5lZWQgdG8gdXNlIHN0cmluZ3MgYW5kIGNvbWUgYmVmb3JlIFtCYXNlLkJ5dGVzXSBpblxuICAgYnVpbGQgb3JkZXIgc2hvdWxkIGRvOlxuXG4gICB7W1xuICAgICBtb2R1bGUgQnl0ZXMgID0gQnl0ZXMwXG4gICBdfVxuXG4gICBEZWZpbmluZyBbbW9kdWxlIEJ5dGVzID0gQnl0ZXMwXSBpcyBhbHNvIG5lY2Vzc2FyeSBiZWNhdXNlIGl0IHByZXZlbnRzXG4gICBvY2FtbGRlcCBmcm9tIG1pc3Rha2VubHkgY2F1c2luZyBhIGZpbGUgdG8gZGVwZW5kIG9uIFtCYXNlLkJ5dGVzXS4gKilcblxub3BlbiEgSW1wb3J0MFxubW9kdWxlIFN5cyA9IFN5czBcblxubW9kdWxlIFByaW1pdGl2ZXMgPSBzdHJ1Y3RcbiAgZXh0ZXJuYWwgZ2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgPSBcIiVieXRlc19zYWZlX2dldFwiXG4gIGV4dGVybmFsIGxlbmd0aCA6IGJ5dGVzIC0+IGludCA9IFwiJWJ5dGVzX2xlbmd0aFwiXG4gIGV4dGVybmFsIHVuc2FmZV9nZXQgOiBieXRlcyAtPiBpbnQgLT4gY2hhciA9IFwiJWJ5dGVzX3Vuc2FmZV9nZXRcIlxuICBleHRlcm5hbCBzZXQgICAgICAgIDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgLT4gdW5pdCA9IFwiJWJ5dGVzX3NhZmVfc2V0XCJcbiAgZXh0ZXJuYWwgdW5zYWZlX3NldCA6IGJ5dGVzIC0+IGludCAtPiBjaGFyIC0+IHVuaXQgPSBcIiVieXRlc191bnNhZmVfc2V0XCJcblxuICAoKiBbdW5zYWZlX2JsaXRfc3RyaW5nXSBpcyBub3QgZXhwb3J0ZWQgaW4gdGhlIFtzdGRsaWJdIHNvIHdlIGV4cG9ydCBpdCBoZXJlICopXG4gIGV4dGVybmFsIHVuc2FmZV9ibGl0X3N0cmluZ1xuICAgIDogIHNyYzpzdHJpbmdcbiAgICAtPiBzcmNfcG9zOmludFxuICAgIC0+IGRzdDpieXRlc1xuICAgIC0+IGRzdF9wb3M6aW50XG4gICAgLT4gbGVuOmludFxuICAgIC0+IHVuaXRcbiAgICA9IFwiY2FtbF9ibGl0X3N0cmluZ1wiXG4gIFtAQG5vYWxsb2NdXG5cbiAgZXh0ZXJuYWwgdW5zYWZlX2dldF9pbnQ2NCA6IGJ5dGVzIC0+IGludCAtPiBpbnQ2NCA9IFwiJWNhbWxfYnl0ZXNfZ2V0NjR1XCJcbiAgZXh0ZXJuYWwgdW5zYWZlX3NldF9pbnQ2NCA6IGJ5dGVzIC0+IGludCAtPiBpbnQ2NCAtPiB1bml0ID0gXCIlY2FtbF9ieXRlc19zZXQ2NHVcIlxuZW5kXG5cbmluY2x1ZGUgUHJpbWl0aXZlc1xuXG5sZXQgbWF4X2xlbmd0aCA9IFN5cy5tYXhfc3RyaW5nX2xlbmd0aFxubGV0IGJsaXQgPSBDYW1sLkJ5dGVzLmJsaXRcbmxldCBibGl0X3N0cmluZyA9IENhbWwuQnl0ZXMuYmxpdF9zdHJpbmdcbmxldCBjb21wYXJlID0gQ2FtbC5CeXRlcy5jb21wYXJlXG5sZXQgY29weSA9IENhbWwuQnl0ZXMuY29weVxubGV0IGNyZWF0ZSA9IENhbWwuQnl0ZXMuY3JlYXRlXG5sZXQgZmlsbCA9IENhbWwuQnl0ZXMuZmlsbFxubGV0IG1ha2UgPSBDYW1sLkJ5dGVzLm1ha2VcbmxldCBtYXAgPSBDYW1sLkJ5dGVzLm1hcFxubGV0IG1hcGkgPSBDYW1sLkJ5dGVzLm1hcGlcbmxldCBzdWIgPSBDYW1sLkJ5dGVzLnN1YlxubGV0IHVuc2FmZV9ibGl0ID0gQ2FtbC5CeXRlcy51bnNhZmVfYmxpdFxubGV0IHRvX3N0cmluZyA9IENhbWwuQnl0ZXMudG9fc3RyaW5nXG5sZXQgb2Zfc3RyaW5nID0gQ2FtbC5CeXRlcy5vZl9zdHJpbmdcbmxldCB1bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOnMgPSBDYW1sLkJ5dGVzLnVuc2FmZV90b19zdHJpbmcgc1xubGV0IHVuc2FmZV9vZl9zdHJpbmdfcHJvbWlzZV9ub19tdXRhdGlvbiA9IENhbWwuQnl0ZXMudW5zYWZlX29mX3N0cmluZ1xuIiwib3BlbiEgSW1wb3J0XG5cbnR5cGUgKCdhLCAnd2l0bmVzcykgdCA9XG4gIHsgY29tcGFyZSA6ICdhIC0+ICdhIC0+IGludFxuICA7IHNleHBfb2ZfdCA6ICdhIC0+IFNleHAudFxuICB9XG5cbnR5cGUgKCdhLCAnYikgY29tcGFyYXRvciA9ICgnYSwgJ2IpIHRcblxubW9kdWxlIHR5cGUgUyA9IHNpZ1xuICB0eXBlIHRcbiAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3NcblxuICB2YWwgY29tcGFyYXRvciA6ICh0LCBjb21wYXJhdG9yX3dpdG5lc3MpIGNvbXBhcmF0b3JcbmVuZFxuXG5tb2R1bGUgdHlwZSBTMSA9IHNpZ1xuICB0eXBlICdhIHRcbiAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3NcblxuICB2YWwgY29tcGFyYXRvciA6ICgnYSB0LCBjb21wYXJhdG9yX3dpdG5lc3MpIGNvbXBhcmF0b3JcbmVuZFxuXG5tb2R1bGUgdHlwZSBTX2ZjID0gc2lnXG4gIHR5cGUgY29tcGFyYWJsZV90XG5cbiAgaW5jbHVkZSBTIHdpdGggdHlwZSB0IDo9IGNvbXBhcmFibGVfdFxuZW5kXG5cbm1vZHVsZSBNb2R1bGUgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2EsICdiKSB0ID0gKG1vZHVsZSBTIHdpdGggdHlwZSB0ID0gJ2EgYW5kIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gJ2IpXG5lbmRcblxubGV0IG1ha2UgKHR5cGUgdCkgfmNvbXBhcmUgfnNleHBfb2ZfdCA9XG4gIChtb2R1bGUgc3RydWN0XG4gICAgdHlwZSBjb21wYXJhYmxlX3QgPSB0XG4gICAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3NcblxuICAgIGxldCBjb21wYXJhdG9yID0geyBjb21wYXJlOyBzZXhwX29mX3QgfVxuICBlbmQgOiBTX2ZjXG4gICAgd2l0aCB0eXBlIGNvbXBhcmFibGVfdCA9IHQpXG47O1xuXG5tb2R1bGUgU190b19TMSAoUyA6IFMpID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9IFMudFxuICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA9IFMuY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgb3BlbiBTXG5cbiAgbGV0IGNvbXBhcmF0b3IgPSBjb21wYXJhdG9yXG5lbmRcblxubW9kdWxlIE1ha2UgKE0gOiBzaWdcbiAgICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIHNleHBfb2ZdXG5cbiAgICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gICAgdmFsIHNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgICBbQEBAZW5kXVxuICBlbmQpID1cbnN0cnVjdFxuICBpbmNsdWRlIE1cblxuICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIGxldCBjb21wYXJhdG9yID0gTS57IGNvbXBhcmU7IHNleHBfb2ZfdCB9XG5lbmRcblxubW9kdWxlIE1ha2UxIChNIDogc2lnXG4gICAgdHlwZSAnYSB0XG5cbiAgICB2YWwgY29tcGFyZSA6ICdhIHQgLT4gJ2EgdCAtPiBpbnRcbiAgICB2YWwgc2V4cF9vZl90IDogJ2EgdCAtPiBTZXhwLnRcbiAgZW5kKSA9XG5zdHJ1Y3RcbiAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3NcblxuICBsZXQgY29tcGFyYXRvciA9IE0ueyBjb21wYXJlOyBzZXhwX29mX3QgfVxuZW5kXG5cbm1vZHVsZSBQb2x5ID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9ICdhXG5cbiAgaW5jbHVkZSBNYWtlMSAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYVxuXG4gICAgICBsZXQgY29tcGFyZSA9IFBvbHkuY29tcGFyZVxuICAgICAgbGV0IHNleHBfb2ZfdCBfID0gU2V4cC5BdG9tIFwiX1wiXG4gICAgZW5kKVxuZW5kXG5cbm1vZHVsZSB0eXBlIERlcml2ZWQgPSBzaWdcbiAgdHlwZSAnYSB0XG4gIHR5cGUgJ2NtcCBjb21wYXJhdG9yX3dpdG5lc3NcblxuICB2YWwgY29tcGFyYXRvciA6ICgnYSwgJ2NtcCkgY29tcGFyYXRvciAtPiAoJ2EgdCwgJ2NtcCBjb21wYXJhdG9yX3dpdG5lc3MpIGNvbXBhcmF0b3JcbmVuZFxuXG5tb2R1bGUgRGVyaXZlZCAoTSA6IHNpZ1xuICAgIHR5cGUgJ2EgdCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgc2V4cF9vZl1cblxuICAgIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkNvbXBhcmFibGUuUzEgd2l0aCB0eXBlICdhIHQgOj0gJ2EgdFxuXG4gICAgdmFsIHNleHBfb2ZfdCA6ICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICdhIHQgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgICBbQEBAZW5kXVxuICBlbmQpID1cbnN0cnVjdFxuICB0eXBlICdjbXAgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgbGV0IGNvbXBhcmF0b3IgYSA9XG4gICAgeyBjb21wYXJlID0gTS5jb21wYXJlIGEuY29tcGFyZTsgc2V4cF9vZl90ID0gTS5zZXhwX29mX3QgYS5zZXhwX29mX3QgfVxuICA7O1xuZW5kXG5cbm1vZHVsZSB0eXBlIERlcml2ZWQyID0gc2lnXG4gIHR5cGUgKCdhLCAnYikgdFxuICB0eXBlICgnY21wX2EsICdjbXBfYikgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgdmFsIGNvbXBhcmF0b3JcbiAgICA6ICAoJ2EsICdjbXBfYSkgY29tcGFyYXRvclxuICAgIC0+ICgnYiwgJ2NtcF9iKSBjb21wYXJhdG9yXG4gICAgLT4gKCgnYSwgJ2IpIHQsICgnY21wX2EsICdjbXBfYikgY29tcGFyYXRvcl93aXRuZXNzKSBjb21wYXJhdG9yXG5lbmRcblxubW9kdWxlIERlcml2ZWQyIChNIDogc2lnXG4gICAgdHlwZSAoJ2EsICdiKSB0IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBzZXhwX29mXVxuXG4gICAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TMiB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0XG5cbiAgICB2YWwgc2V4cF9vZl90XG4gICAgICA6ICAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgLT4gKCdiIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgIC0+ICgnYSwgJ2IpIHRcbiAgICAgIC0+IFNleHBsaWIwLlNleHAudFxuXG4gICAgW0BAQGVuZF1cbiAgZW5kKSA9XG5zdHJ1Y3RcbiAgdHlwZSAoJ2NtcF9hLCAnY21wX2IpIGNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIGxldCBjb21wYXJhdG9yIGEgYiA9XG4gICAgeyBjb21wYXJlID0gTS5jb21wYXJlIGEuY29tcGFyZSBiLmNvbXBhcmVcbiAgICA7IHNleHBfb2ZfdCA9IE0uc2V4cF9vZl90IGEuc2V4cF9vZl90IGIuc2V4cF9vZl90XG4gICAgfVxuICA7O1xuZW5kXG5cbm1vZHVsZSB0eXBlIERlcml2ZWRfcGhhbnRvbSA9IHNpZ1xuICB0eXBlICgnYSwgJ2IpIHRcbiAgdHlwZSAnY21wIGNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIHZhbCBjb21wYXJhdG9yXG4gICAgOiAgKCdhLCAnY21wKSBjb21wYXJhdG9yXG4gICAgLT4gKCgnYSwgXykgdCwgJ2NtcCBjb21wYXJhdG9yX3dpdG5lc3MpIGNvbXBhcmF0b3JcbmVuZFxuXG5tb2R1bGUgRGVyaXZlZF9waGFudG9tIChNIDogc2lnXG4gICAgdHlwZSAoJ2EsICdiKSB0XG5cbiAgICB2YWwgY29tcGFyZSA6ICgnYSAtPiAnYSAtPiBpbnQpIC0+ICgnYSwgJ2IpIHQgLT4gKCdhLCAnYikgdCAtPiBpbnRcbiAgICB2YWwgc2V4cF9vZl90IDogKCdhIC0+IFNleHAudCkgLT4gKCdhLCBfKSB0IC0+IFNleHAudFxuICBlbmQpID1cbnN0cnVjdFxuICB0eXBlICdjbXBfYSBjb21wYXJhdG9yX3dpdG5lc3NcblxuICBsZXQgY29tcGFyYXRvciBhID1cbiAgICB7IGNvbXBhcmUgPSBNLmNvbXBhcmUgYS5jb21wYXJlOyBzZXhwX29mX3QgPSBNLnNleHBfb2ZfdCBhLnNleHBfb2ZfdCB9XG4gIDs7XG5lbmRcbiIsIigqIFRoZSB0eXBlIFt0XSBzaG91bGQgYmUgYWJzdHJhY3QgdG8gbWFrZSB0aGUgZnNldCBhbmQgc2V0IGZ1bmN0aW9ucyB1bmF2YWlsYWJsZVxuICAgZm9yIHByaXZhdGUgdHlwZXMgYXQgdGhlIGxldmVsIG9mIHR5cGVzIChhbmQgbm90IGJ5IHB1dHRpbmcgTm9uZSBpbiB0aGUgZmllbGQpLlxuICAgVW5mb3J0dW5hdGVseSwgbWFraW5nIHRoZSB0eXBlIGFic3RyYWN0IG1lYW5zIHRoYXQgd2hlbiBjcmVhdGluZyBmaWVsZHMgKHRocm91Z2hcbiAgIGEgW2NyZWF0ZV0gZnVuY3Rpb24pIHZhbHVlIHJlc3RyaWN0aW9uIGtpY2tzIGluLiBUaGlzIGlzIHdvcmtlZCBhcm91bmQgYnkgaW5zdGVhZFxuICAgbm90IG1ha2luZyB0aGUgdHlwZSBhYnN0cmFjdCwgYnV0IGZvcmNpbmcgYW55b25lIGJyZWFraW5nIHRoZSBhYnN0cmFjdGlvbiB0byB1c2VcbiAgIHRoZSBbRm9yX2dlbmVyYXRlZF9jb2RlXSBtb2R1bGUsIG1ha2luZyBpdCBvYnZpb3VzIHRvIGFueSByZWFkZXIgdGhhdCBzb21ldGhpbmcgdWdseVxuICAgaXMgZ29pbmcgb24uXG4gICB0X3dpdGhfcGVybSAoYW5kIGRlcml2YXRpdmVzKSBpcyB0aGUgdHlwZSB0aGF0IHVzZXJzIHJlYWxseSB1c2UuIEl0IGlzIGEgY29uc3RydWN0b3JcbiAgIGJlY2F1c2U6XG4gICAxLiBpdCBtYWtlcyB0eXBlIGVycm9ycyBtb3JlIHJlYWRhYmxlIChsZXNzIGFsaWFzaW5nKVxuICAgMi4gdGhlIHR5cGVyIGluIG9jYW1sIDQuMDEgYWxsb3dzIHRoaXM6XG5cbiAgIHtbXG4gICAgIG1vZHVsZSBBID0gc3RydWN0XG4gICAgICAgdHlwZSB0ID0ge2EgOiBpbnR9XG4gICAgIGVuZFxuICAgICB0eXBlIHQgPSBBLnRcbiAgICAgbGV0IGYgKHggOiB0KSA9IHguYVxuICAgXX1cblxuICAgKGFsdGhvdWdoIHdpdGggV2FybmluZyA0MDogYSBpcyB1c2VkIG91dCBvZiBzY29wZSlcbiAgIHdoaWNoIG1lYW5zIHRoYXQgaWYgW3Rfd2l0aF9wZXJtXSB3YXMgcmVhbGx5IGFuIGFsaWFzIG9uIFtGb3JfZ2VuZXJhdGVkX2NvZGUudF0sXG4gICBwZW9wbGUgY291bGQgc2F5IFt0LnNldHRlcl0gYW5kIGJyZWFrIHRoZSBhYnN0cmFjdGlvbiB3aXRoIG5vIGluZGljYXRpb24gdGhhdFxuICAgc29tZXRoaW5nIHVnbHkgaXMgZ29pbmcgb24gaW4gdGhlIHNvdXJjZSBjb2RlLlxuICAgVGhlIHdhcm5pbmcgaXMgKEkgdGhpbmspIGZvciBwZW9wbGUgd2hvIHdhbnQgdG8gbWFrZSB0aGVpciBjb2RlIGNvbXBhdGlibGUgd2l0aFxuICAgcHJldmlvdXMgdmVyc2lvbnMgb2Ygb2NhbWwsIHNvIHdlIG1heSB2ZXJ5IHdlbGwgdHVybiBpdCBvZmYuXG5cbiAgIFRoZSB0eXBlIHRfd2l0aF9wZXJtIGNvdWxkIGFsc28gaGF2ZSBiZWVuIGEgW3VuaXQgLT4gRm9yX2dlbmVyYXRlZF9jb2RlLnRdIHRvIHdvcmtcbiAgIGFyb3VuZCB2YWx1ZSByZXN0cmljdGlvbiBhbmQgdGhlbiBbRm9yX2dlbmVyYXRlZF9jb2RlLnRdIHdvdWxkIGhhdmUgYmVlbiBhIHByb3BlclxuICAgYWJzdHJhY3QgdHlwZSwgYnV0IGl0IGxvb2tzIGxpa2UgaXQgY291bGQgaW1wYWN0IHBlcmZvcm1hbmNlIChmb3IgZXhhbXBsZSwgYSBmb2xkIG9uIGFcbiAgIHJlY29yZCB0eXBlIHdpdGggNDAgZmllbGRzIHdvdWxkIGFjdHVhbGx5IGFsbG9jYXRlIHRoZSA0MCBbRm9yX2dlbmVyYXRlZF9jb2RlLnRdJ3MgYXRcbiAgIGV2ZXJ5IHNpbmdsZSBmb2xkLikgKilcblxubW9kdWxlIEZvcl9nZW5lcmF0ZWRfY29kZSA9IHN0cnVjdFxuICB0eXBlICgncGVybSwgJ3JlY29yZCwgJ2ZpZWxkKSB0ID1cbiAgICB7IGZvcmNlX3ZhcmlhbmNlIDogJ3Blcm0gLT4gdW5pdFxuICAgIDsgKCogZm9yY2UgW3RdIHRvIGJlIGNvbnRyYXZhcmlhbnQgaW4gWydwZXJtXSwgYmVjYXVzZSBwaGFudG9tIHR5cGUgdmFyaWFibGVzIG9uXG4gICAgICAgICBjb25jcmV0ZSB0eXBlcyBkb24ndCB3b3JrIHRoYXQgd2VsbCBvdGhlcndpc2UgKHVzaW5nIDo+IGNhbiByZW1vdmUgdGhlbSBlYXNpbHkpICopXG4gICAgICBuYW1lIDogc3RyaW5nXG4gICAgOyBzZXR0ZXIgOiAoJ3JlY29yZCAtPiAnZmllbGQgLT4gdW5pdCkgb3B0aW9uXG4gICAgOyBnZXR0ZXIgOiAncmVjb3JkIC0+ICdmaWVsZFxuICAgIDsgZnNldCA6ICdyZWNvcmQgLT4gJ2ZpZWxkIC0+ICdyZWNvcmRcbiAgICB9XG5cbiAgbGV0IG9wYXF1ZV9pZGVudGl0eSA9IFN5czAub3BhcXVlX2lkZW50aXR5XG5lbmRcblxudHlwZSAoJ3Blcm0sICdyZWNvcmQsICdmaWVsZCkgdF93aXRoX3Blcm0gPVxuICB8IEZpZWxkIG9mICgncGVybSwgJ3JlY29yZCwgJ2ZpZWxkKSBGb3JfZ2VuZXJhdGVkX2NvZGUudFxuW0BAdW5ib3hlZF1cblxudHlwZSAoJ3JlY29yZCwgJ2ZpZWxkKSB0ID0gKFsgYFJlYWQgfCBgU2V0X2FuZF9jcmVhdGUgXSwgJ3JlY29yZCwgJ2ZpZWxkKSB0X3dpdGhfcGVybVxudHlwZSAoJ3JlY29yZCwgJ2ZpZWxkKSByZWFkb25seV90ID0gKFsgYFJlYWQgXSwgJ3JlY29yZCwgJ2ZpZWxkKSB0X3dpdGhfcGVybVxuXG5sZXQgbmFtZSAoRmllbGQgZmllbGQpID0gZmllbGQubmFtZVxubGV0IGdldCAoRmllbGQgZmllbGQpIHIgPSBmaWVsZC5nZXR0ZXIgclxubGV0IGZzZXQgKEZpZWxkIGZpZWxkKSByIHYgPSBmaWVsZC5mc2V0IHIgdlxubGV0IHNldHRlciAoRmllbGQgZmllbGQpID0gZmllbGQuc2V0dGVyXG5cbnR5cGUgKCdwZXJtLCAncmVjb3JkLCAncmVzdWx0KSB1c2VyID1cbiAgeyBmIDogJ2ZpZWxkLiAoJ3Blcm0sICdyZWNvcmQsICdmaWVsZCkgdF93aXRoX3Blcm0gLT4gJ3Jlc3VsdCB9XG5cbmxldCBtYXAgKEZpZWxkIGZpZWxkKSByIH5mID0gZmllbGQuZnNldCByIChmIChmaWVsZC5nZXR0ZXIgcikpXG5cbmxldCB1cGRhdGVyIChGaWVsZCBmaWVsZCkgPVxuICBtYXRjaCBmaWVsZC5zZXR0ZXIgd2l0aFxuICB8IE5vbmUgLT4gTm9uZVxuICB8IFNvbWUgc2V0dGVyIC0+IFNvbWUgKGZ1biByIH5mIC0+IHNldHRlciByIChmIChmaWVsZC5nZXR0ZXIgcikpKVxuOztcbiIsIm9wZW4hIEltcG9ydFxubW9kdWxlIEludCA9IEludDBcbm1vZHVsZSBTdHJpbmcgPSBTdHJpbmcwXG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIHR5cGUgdCA9IENhbWwuTGV4aW5nLnBvc2l0aW9uID1cbiAgICB7IHBvc19mbmFtZSA6IHN0cmluZ1xuICAgIDsgcG9zX2xudW0gOiBpbnRcbiAgICA7IHBvc19ib2wgOiBpbnRcbiAgICA7IHBvc19jbnVtIDogaW50XG4gICAgfVxuICBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgaGFzaCwgc2V4cF9vZl1cblxuICBsZXQgY29tcGFyZSA9XG4gICAgKGZ1biBhX18wMDFfIGJfXzAwMl8gLT5cbiAgICAgICBpZiBQcHhfY29tcGFyZV9saWIucGh5c19lcXVhbCBhX18wMDFfIGJfXzAwMl9cbiAgICAgICB0aGVuIDBcbiAgICAgICBlbHNlIChcbiAgICAgICAgIG1hdGNoIGNvbXBhcmVfc3RyaW5nIGFfXzAwMV8ucG9zX2ZuYW1lIGJfXzAwMl8ucG9zX2ZuYW1lIHdpdGhcbiAgICAgICAgIHwgMCAtPlxuICAgICAgICAgICAobWF0Y2ggY29tcGFyZV9pbnQgYV9fMDAxXy5wb3NfbG51bSBiX18wMDJfLnBvc19sbnVtIHdpdGhcbiAgICAgICAgICAgIHwgMCAtPlxuICAgICAgICAgICAgICAobWF0Y2ggY29tcGFyZV9pbnQgYV9fMDAxXy5wb3NfYm9sIGJfXzAwMl8ucG9zX2JvbCB3aXRoXG4gICAgICAgICAgICAgICB8IDAgLT4gY29tcGFyZV9pbnQgYV9fMDAxXy5wb3NfY251bSBiX18wMDJfLnBvc19jbnVtXG4gICAgICAgICAgICAgICB8IG4gLT4gbilcbiAgICAgICAgICAgIHwgbiAtPiBuKVxuICAgICAgICAgfCBuIC0+IG4pXG4gICAgICAgICA6IHQgLT4gdCAtPiBpbnQpXG4gIDs7XG5cbiAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgIGZ1biBoc3YgYXJnIC0+XG4gICAgICBsZXQgaHN2ID1cbiAgICAgICAgbGV0IGhzdiA9XG4gICAgICAgICAgbGV0IGhzdiA9XG4gICAgICAgICAgICBsZXQgaHN2ID0gaHN2IGluXG4gICAgICAgICAgICBoYXNoX2ZvbGRfc3RyaW5nIGhzdiBhcmcucG9zX2ZuYW1lXG4gICAgICAgICAgaW5cbiAgICAgICAgICBoYXNoX2ZvbGRfaW50IGhzdiBhcmcucG9zX2xudW1cbiAgICAgICAgaW5cbiAgICAgICAgaGFzaF9mb2xkX2ludCBoc3YgYXJnLnBvc19ib2xcbiAgICAgIGluXG4gICAgICBoYXNoX2ZvbGRfaW50IGhzdiBhcmcucG9zX2NudW1cbiAgOztcblxuICBsZXQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgYXJnID1cbiAgICAgIFBweF9oYXNoX2xpYi5TdGQuSGFzaC5nZXRfaGFzaF92YWx1ZVxuICAgICAgICAobGV0IGhzdiA9IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5jcmVhdGUgKCkgaW5cbiAgICAgICAgIGhhc2hfZm9sZF90IGhzdiBhcmcpXG4gICAgaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgc2V4cF9vZl90ID1cbiAgICAoZnVuIHsgcG9zX2ZuYW1lID0gcG9zX2ZuYW1lX18wMDRfXG4gICAgICAgICA7IHBvc19sbnVtID0gcG9zX2xudW1fXzAwNl9cbiAgICAgICAgIDsgcG9zX2JvbCA9IHBvc19ib2xfXzAwOF9cbiAgICAgICAgIDsgcG9zX2NudW0gPSBwb3NfY251bV9fMDEwX1xuICAgICAgICAgfSAtPlxuICAgICAgbGV0IGJuZHNfXzAwM18gPSBbXSBpblxuICAgICAgbGV0IGJuZHNfXzAwM18gPVxuICAgICAgICBsZXQgYXJnX18wMTFfID0gc2V4cF9vZl9pbnQgcG9zX2NudW1fXzAxMF8gaW5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwicG9zX2NudW1cIjsgYXJnX18wMTFfIF0gOjogYm5kc19fMDAzX1xuICAgICAgaW5cbiAgICAgIGxldCBibmRzX18wMDNfID1cbiAgICAgICAgbGV0IGFyZ19fMDA5XyA9IHNleHBfb2ZfaW50IHBvc19ib2xfXzAwOF8gaW5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwicG9zX2JvbFwiOyBhcmdfXzAwOV8gXSA6OiBibmRzX18wMDNfXG4gICAgICBpblxuICAgICAgbGV0IGJuZHNfXzAwM18gPVxuICAgICAgICBsZXQgYXJnX18wMDdfID0gc2V4cF9vZl9pbnQgcG9zX2xudW1fXzAwNl8gaW5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwicG9zX2xudW1cIjsgYXJnX18wMDdfIF0gOjogYm5kc19fMDAzX1xuICAgICAgaW5cbiAgICAgIGxldCBibmRzX18wMDNfID1cbiAgICAgICAgbGV0IGFyZ19fMDA1XyA9IHNleHBfb2Zfc3RyaW5nIHBvc19mbmFtZV9fMDA0XyBpblxuICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJwb3NfZm5hbWVcIjsgYXJnX18wMDVfIF0gOjogYm5kc19fMDAzX1xuICAgICAgaW5cbiAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBibmRzX18wMDNfXG4gICAgICA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICA7O1xuXG4gIFtAQEBlbmRdXG5lbmRcblxuaW5jbHVkZSBUXG5pbmNsdWRlIENvbXBhcmF0b3IuTWFrZSAoVClcblxuKCogVGhpcyBpcyB0aGUgc2FtZSBmdW5jdGlvbiBhcyBQcHhfaGVyZS5saWZ0X3Bvc2l0aW9uX2FzX3N0cmluZy4gKilcbmxldCBtYWtlX2xvY2F0aW9uX3N0cmluZyB+cG9zX2ZuYW1lIH5wb3NfbG51bSB+cG9zX2NudW0gfnBvc19ib2wgPVxuICBTdHJpbmcuY29uY2F0XG4gICAgWyBwb3NfZm5hbWU7IFwiOlwiOyBJbnQudG9fc3RyaW5nIHBvc19sbnVtOyBcIjpcIjsgSW50LnRvX3N0cmluZyAocG9zX2NudW0gLSBwb3NfYm9sKSBdXG47O1xuXG5sZXQgdG9fc3RyaW5nIHsgQ2FtbC5MZXhpbmcucG9zX2ZuYW1lOyBwb3NfbG51bTsgcG9zX2NudW07IHBvc19ib2wgfSA9XG4gIG1ha2VfbG9jYXRpb25fc3RyaW5nIH5wb3NfZm5hbWUgfnBvc19sbnVtIH5wb3NfY251bSB+cG9zX2JvbFxuOztcblxubGV0IHNleHBfb2ZfdCB0ID0gU2V4cC5BdG9tICh0b19zdHJpbmcgdClcbiIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBMaXN0MFxuXG5sZXQgaXNfZW1wdHkgPSBmdW5jdGlvblxuICB8IFtdIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG47O1xuXG5sZXQgcGFydGl0aW9uX21hcCB0IH5mID1cbiAgbGV0IHJlYyBsb29wIHQgZnN0IHNuZCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBbXSAtPiByZXYgZnN0LCByZXYgc25kXG4gICAgfCB4IDo6IHQgLT5cbiAgICAgIChtYXRjaCAoZiB4IDogXyBFaXRoZXIwLnQpIHdpdGhcbiAgICAgICB8IEZpcnN0IHkgLT4gbG9vcCB0ICh5IDo6IGZzdCkgc25kXG4gICAgICAgfCBTZWNvbmQgeSAtPiBsb29wIHQgZnN0ICh5IDo6IHNuZCkpXG4gIGluXG4gIGxvb3AgdCBbXSBbXVxuOztcbiIsIm9wZW4hIEltcG9ydFxuXG5pbmNsdWRlIChcbiAgUmVzdWx0IDpcbiAgICBtb2R1bGUgdHlwZSBvZiBzdHJ1Y3RcbiAgICBpbmNsdWRlIFJlc3VsdFxuICBlbmRcbiAgd2l0aCBtb2R1bGUgRXJyb3IgOj0gUmVzdWx0LkVycm9yKVxuXG50eXBlICdhIHQgPSAoJ2EsIEVycm9yLnQpIFJlc3VsdC50XG5bQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZXF1YWwsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxubGV0IGNvbXBhcmUgOiAnYS4gKCdhIC0+ICdhIC0+IGludCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGludCA9XG4gIGZ1biBfY21wX19hIGFfXzAwMV8gYl9fMDAyXyAtPiBSZXN1bHQuY29tcGFyZSBfY21wX19hIEVycm9yLmNvbXBhcmUgYV9fMDAxXyBiX18wMDJfXG47O1xuXG5sZXQgZXF1YWwgOiAnYS4gKCdhIC0+ICdhIC0+IGJvb2wpIC0+ICdhIHQgLT4gJ2EgdCAtPiBib29sID1cbiAgZnVuIF9jbXBfX2EgYV9fMDA3XyBiX18wMDhfIC0+IFJlc3VsdC5lcXVhbCBfY21wX19hIEVycm9yLmVxdWFsIGFfXzAwN18gYl9fMDA4X1xuOztcblxubGV0IGhhc2hfZm9sZF90IDpcbiAgJ2EuXG4gIChQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gJ2EgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGVcbiAgLT4gJ2EgdFxuICAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGVcbiAgPVxuICBmdW4gX2hhc2hfZm9sZF9hIGhzdiBhcmcgLT4gUmVzdWx0Lmhhc2hfZm9sZF90IF9oYXNoX2ZvbGRfYSBFcnJvci5oYXNoX2ZvbGRfdCBoc3YgYXJnXG47O1xuXG5sZXQgdF9vZl9zZXhwIDogJ2EuIChTZXhwbGliMC5TZXhwLnQgLT4gJ2EpIC0+IFNleHBsaWIwLlNleHAudCAtPiAnYSB0ID1cbiAgZnVuIF9vZl9hX18wMTNfIHhfXzAxNV8gLT4gUmVzdWx0LnRfb2Zfc2V4cCBfb2ZfYV9fMDEzXyBFcnJvci50X29mX3NleHAgeF9fMDE1X1xuOztcblxubGV0IHNleHBfb2ZfdCA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSB0IC0+IFNleHBsaWIwLlNleHAudCA9XG4gIGZ1biBfb2ZfYV9fMDE2XyB4X18wMTdfIC0+IFJlc3VsdC5zZXhwX29mX3QgX29mX2FfXzAxNl8gRXJyb3Iuc2V4cF9vZl90IHhfXzAxN19cbjs7XG5cbmxldCAodF9zZXhwX2dyYW1tYXIgOiAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCAtPiAnYSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9XG4gIGZ1biBfJ2Ffc2V4cF9ncmFtbWFyIC0+IFJlc3VsdC50X3NleHBfZ3JhbW1hciBfJ2Ffc2V4cF9ncmFtbWFyIEVycm9yLnRfc2V4cF9ncmFtbWFyXG47O1xuXG5bQEBAZW5kXVxuXG5sZXQgaW52YXJpYW50IGludmFyaWFudF9hIHQgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBPayBhIC0+IGludmFyaWFudF9hIGFcbiAgfCBFcnJvciBlcnJvciAtPiBFcnJvci5pbnZhcmlhbnQgZXJyb3Jcbjs7XG5cbmluY2x1ZGUgQXBwbGljYXRpdmUuTWFrZSAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICAgIGxldCByZXR1cm4gPSByZXR1cm5cblxuICAgIGxldCBhcHBseSBmIHggPVxuICAgICAgUmVzdWx0LmNvbWJpbmUgZiB4IH5vazooZnVuIGYgeCAtPiBmIHgpIH5lcnI6KGZ1biBlMSBlMiAtPiBFcnJvci5vZl9saXN0IFsgZTE7IGUyIF0pXG4gICAgOztcblxuICAgIGxldCBtYXAgPSBgQ3VzdG9tIG1hcFxuICBlbmQpXG5cbm1vZHVsZSBMZXRfc3ludGF4ID0gc3RydWN0XG4gIGxldCByZXR1cm4gPSByZXR1cm5cblxuICBpbmNsdWRlIE1vbmFkX2luZml4XG5cbiAgbW9kdWxlIExldF9zeW50YXggPSBzdHJ1Y3RcbiAgICBsZXQgcmV0dXJuID0gcmV0dXJuXG4gICAgbGV0IG1hcCA9IG1hcFxuICAgIGxldCBiaW5kID0gYmluZFxuICAgIGxldCBib3RoID0gYm90aFxuXG4gICAgKCogZnJvbSBBcHBsaWNhdGl2ZS5NYWtlICopXG4gICAgbW9kdWxlIE9wZW5fb25fcmhzID0gc3RydWN0IGVuZFxuICBlbmRcbmVuZFxuXG5sZXQgb2sgPSBSZXN1bHQub2tcbmxldCBpc19vayA9IFJlc3VsdC5pc19va1xubGV0IGlzX2Vycm9yID0gUmVzdWx0LmlzX2Vycm9yXG5cbmxldCB0cnlfd2l0aCA/KGJhY2t0cmFjZSA9IGZhbHNlKSBmID1cbiAgdHJ5IE9rIChmICgpKSB3aXRoXG4gIHwgZXhuIC0+IEVycm9yIChFcnJvci5vZl9leG4gZXhuID9iYWNrdHJhY2U6KGlmIGJhY2t0cmFjZSB0aGVuIFNvbWUgYEdldCBlbHNlIE5vbmUpKVxuOztcblxubGV0IHRyeV93aXRoX2pvaW4gP2JhY2t0cmFjZSBmID0gam9pbiAodHJ5X3dpdGggP2JhY2t0cmFjZSBmKVxuXG5sZXQgb2tfZXhuID0gZnVuY3Rpb25cbiAgfCBPayB4IC0+IHhcbiAgfCBFcnJvciBlcnIgLT4gRXJyb3IucmFpc2UgZXJyXG47O1xuXG5sZXQgb2ZfZXhuID9iYWNrdHJhY2UgZXhuID0gRXJyb3IgKEVycm9yLm9mX2V4biA/YmFja3RyYWNlIGV4bilcblxubGV0IG9mX2V4bl9yZXN1bHQgP2JhY2t0cmFjZSA9IGZ1bmN0aW9uXG4gIHwgT2sgXyBhcyB6IC0+IHpcbiAgfCBFcnJvciBleG4gLT4gb2ZfZXhuID9iYWNrdHJhY2UgZXhuXG47O1xuXG5sZXQgZXJyb3IgP2hlcmUgP3N0cmljdCBtZXNzYWdlIGEgc2V4cF9vZl9hID1cbiAgRXJyb3IgKEVycm9yLmNyZWF0ZSA/aGVyZSA/c3RyaWN0IG1lc3NhZ2UgYSBzZXhwX29mX2EpXG47O1xuXG5sZXQgZXJyb3JfcyBzZXhwID0gRXJyb3IgKEVycm9yLmNyZWF0ZV9zIHNleHApXG5sZXQgZXJyb3Jfc3RyaW5nIG1lc3NhZ2UgPSBFcnJvciAoRXJyb3Iub2Zfc3RyaW5nIG1lc3NhZ2UpXG5sZXQgZXJyb3JmIGZvcm1hdCA9IFByaW50Zi5rc3ByaW50ZiBlcnJvcl9zdHJpbmcgZm9ybWF0XG5sZXQgdGFnIHQgfnRhZyA9IFJlc3VsdC5tYXBfZXJyb3IgdCB+ZjooRXJyb3IudGFnIH50YWcpXG5sZXQgdGFnX3MgdCB+dGFnID0gUmVzdWx0Lm1hcF9lcnJvciB0IH5mOihFcnJvci50YWdfcyB+dGFnKVxubGV0IHRhZ19zX2xhenkgdCB+dGFnID0gUmVzdWx0Lm1hcF9lcnJvciB0IH5mOihFcnJvci50YWdfc19sYXp5IH50YWcpXG5cbmxldCB0YWdfYXJnIHQgbWVzc2FnZSBhIHNleHBfb2ZfYSA9XG4gIFJlc3VsdC5tYXBfZXJyb3IgdCB+ZjooZnVuIGUgLT4gRXJyb3IudGFnX2FyZyBlIG1lc3NhZ2UgYSBzZXhwX29mX2EpXG47O1xuXG5sZXQgdW5pbXBsZW1lbnRlZCBzID0gZXJyb3IgXCJ1bmltcGxlbWVudGVkXCIgcyBzZXhwX29mX3N0cmluZ1xubGV0IGNvbWJpbmVfZXJyb3JzIGwgPSBSZXN1bHQubWFwX2Vycm9yIChSZXN1bHQuY29tYmluZV9lcnJvcnMgbCkgfmY6RXJyb3Iub2ZfbGlzdFxubGV0IGNvbWJpbmVfZXJyb3JzX3VuaXQgbCA9IFJlc3VsdC5tYXAgKGNvbWJpbmVfZXJyb3JzIGwpIH5mOihmdW4gKF8gOiB1bml0IGxpc3QpIC0+ICgpKVxuXG5sZXQgZmlsdGVyX29rX2F0X2xlYXN0X29uZSBsID1cbiAgbGV0IG9rLCBlcnJzID0gTGlzdC5wYXJ0aXRpb25fbWFwIGwgfmY6UmVzdWx0LnRvX2VpdGhlciBpblxuICBtYXRjaCBvayB3aXRoXG4gIHwgW10gLT4gRXJyb3IgKEVycm9yLm9mX2xpc3QgZXJycylcbiAgfCBfIC0+IE9rIG9rXG47O1xuXG5sZXQgZmluZF9vayBsID1cbiAgbWF0Y2ggTGlzdC5maW5kX21hcCBsIH5mOlJlc3VsdC5vayB3aXRoXG4gIHwgU29tZSB4IC0+IE9rIHhcbiAgfCBOb25lIC0+XG4gICAgRXJyb3JcbiAgICAgIChFcnJvci5vZl9saXN0XG4gICAgICAgICAoTGlzdC5tYXAgbCB+ZjooZnVuY3Rpb25cbiAgICAgICAgICAgIHwgT2sgXyAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgICAgIHwgRXJyb3IgZXJyIC0+IGVycikpKVxuOztcblxubGV0IGZpbmRfbWFwX29rIGwgfmYgPVxuICBXaXRoX3JldHVybi53aXRoX3JldHVybiAoZnVuIHsgcmV0dXJuIH0gLT5cbiAgICBFcnJvclxuICAgICAgKEVycm9yLm9mX2xpc3RcbiAgICAgICAgIChMaXN0Lm1hcCBsIH5mOihmdW4gZWx0IC0+XG4gICAgICAgICAgICBtYXRjaCBmIGVsdCB3aXRoXG4gICAgICAgICAgICB8IE9rIF8gYXMgeCAtPiByZXR1cm4geFxuICAgICAgICAgICAgfCBFcnJvciBlcnIgLT4gZXJyKSkpKVxuOztcblxubGV0IG1hcCA9IFJlc3VsdC5tYXBcbmxldCBpdGVyID0gUmVzdWx0Lml0ZXJcbmxldCBpdGVyX2Vycm9yID0gUmVzdWx0Lml0ZXJfZXJyb3JcbiIsIm9wZW4hIEltcG9ydFxubW9kdWxlIEFycmF5ID0gQXJyYXkwXG5tb2R1bGUgTGlzdCA9IExpc3QwXG5pbmNsdWRlIENvbnRhaW5lcl9pbnRmXG5cbmxldCB3aXRoX3JldHVybiA9IFdpdGhfcmV0dXJuLndpdGhfcmV0dXJuXG5cbnR5cGUgKCd0LCAnYSwgJ2FjY3VtKSBmb2xkID0gJ3QgLT4gaW5pdDonYWNjdW0gLT4gZjooJ2FjY3VtIC0+ICdhIC0+ICdhY2N1bSkgLT4gJ2FjY3VtXG50eXBlICgndCwgJ2EpIGl0ZXIgPSAndCAtPiBmOignYSAtPiB1bml0KSAtPiB1bml0XG50eXBlICd0IGxlbmd0aCA9ICd0IC0+IGludFxuXG5sZXQgaXRlciB+Zm9sZCB0IH5mID0gZm9sZCB0IH5pbml0OigpIH5mOihmdW4gKCkgYSAtPiBmIGEpXG5sZXQgY291bnQgfmZvbGQgdCB+ZiA9IGZvbGQgdCB+aW5pdDowIH5mOihmdW4gbiBhIC0+IGlmIGYgYSB0aGVuIG4gKyAxIGVsc2UgbilcblxubGV0IHN1bSAodHlwZSBhKSB+Zm9sZCAobW9kdWxlIE0gOiBTdW1tYWJsZSB3aXRoIHR5cGUgdCA9IGEpIHQgfmYgPVxuICBmb2xkIHQgfmluaXQ6TS56ZXJvIH5mOihmdW4gbiBhIC0+IE0uKCArICkgbiAoZiBhKSlcbjs7XG5cbmxldCBmb2xkX3Jlc3VsdCB+Zm9sZCB+aW5pdCB+ZiB0ID1cbiAgd2l0aF9yZXR1cm4gKGZ1biB7IHJldHVybiB9IC0+XG4gICAgUmVzdWx0Lk9rXG4gICAgICAoZm9sZCB0IH5pbml0IH5mOihmdW4gYWNjIGl0ZW0gLT5cbiAgICAgICAgIG1hdGNoIGYgYWNjIGl0ZW0gd2l0aFxuICAgICAgICAgfCBSZXN1bHQuT2sgeCAtPiB4XG4gICAgICAgICB8IEVycm9yIF8gYXMgZSAtPiByZXR1cm4gZSkpKVxuOztcblxubGV0IGZvbGRfdW50aWwgfmZvbGQgfmluaXQgfmYgfmZpbmlzaCB0ID1cbiAgd2l0aF9yZXR1cm4gKGZ1biB7IHJldHVybiB9IC0+XG4gICAgZmluaXNoXG4gICAgICAoZm9sZCB0IH5pbml0IH5mOihmdW4gYWNjIGl0ZW0gLT5cbiAgICAgICAgIG1hdGNoIGYgYWNjIGl0ZW0gd2l0aFxuICAgICAgICAgfCBDb250aW51ZV9vcl9zdG9wLkNvbnRpbnVlIHggLT4geFxuICAgICAgICAgfCBTdG9wIHggLT4gcmV0dXJuIHgpKSlcbjs7XG5cbmxldCBtaW5fZWx0IH5mb2xkIHQgfmNvbXBhcmUgPVxuICBmb2xkIHQgfmluaXQ6Tm9uZSB+ZjooZnVuIGFjYyBlbHQgLT5cbiAgICBtYXRjaCBhY2Mgd2l0aFxuICAgIHwgTm9uZSAtPiBTb21lIGVsdFxuICAgIHwgU29tZSBtaW4gLT4gaWYgY29tcGFyZSBtaW4gZWx0ID4gMCB0aGVuIFNvbWUgZWx0IGVsc2UgYWNjKVxuOztcblxubGV0IG1heF9lbHQgfmZvbGQgdCB+Y29tcGFyZSA9XG4gIGZvbGQgdCB+aW5pdDpOb25lIH5mOihmdW4gYWNjIGVsdCAtPlxuICAgIG1hdGNoIGFjYyB3aXRoXG4gICAgfCBOb25lIC0+IFNvbWUgZWx0XG4gICAgfCBTb21lIG1heCAtPiBpZiBjb21wYXJlIG1heCBlbHQgPCAwIHRoZW4gU29tZSBlbHQgZWxzZSBhY2MpXG47O1xuXG5sZXQgbGVuZ3RoIH5mb2xkIGMgPSBmb2xkIGMgfmluaXQ6MCB+ZjooZnVuIGFjYyBfIC0+IGFjYyArIDEpXG5cbmxldCBpc19lbXB0eSB+aXRlciBjID1cbiAgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgaXRlciBjIH5mOihmdW4gXyAtPiByLnJldHVybiBmYWxzZSk7XG4gICAgdHJ1ZSlcbjs7XG5cbmxldCBleGlzdHMgfml0ZXIgYyB+ZiA9XG4gIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgIGl0ZXIgYyB+ZjooZnVuIHggLT4gaWYgZiB4IHRoZW4gci5yZXR1cm4gdHJ1ZSk7XG4gICAgZmFsc2UpXG47O1xuXG5sZXQgZm9yX2FsbCB+aXRlciBjIH5mID1cbiAgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgaXRlciBjIH5mOihmdW4geCAtPiBpZiBub3QgKGYgeCkgdGhlbiByLnJldHVybiBmYWxzZSk7XG4gICAgdHJ1ZSlcbjs7XG5cbmxldCBmaW5kX21hcCB+aXRlciB0IH5mID1cbiAgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgaXRlciB0IH5mOihmdW4geCAtPlxuICAgICAgbWF0Y2ggZiB4IHdpdGhcbiAgICAgIHwgTm9uZSAtPiAoKVxuICAgICAgfCBTb21lIF8gYXMgcmVzIC0+IHIucmV0dXJuIHJlcyk7XG4gICAgTm9uZSlcbjs7XG5cbmxldCBmaW5kIH5pdGVyIGMgfmYgPVxuICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICBpdGVyIGMgfmY6KGZ1biB4IC0+IGlmIGYgeCB0aGVuIHIucmV0dXJuIChTb21lIHgpKTtcbiAgICBOb25lKVxuOztcblxubGV0IHRvX2xpc3QgfmZvbGQgYyA9IExpc3QucmV2IChmb2xkIGMgfmluaXQ6W10gfmY6KGZ1biBhY2MgeCAtPiB4IDo6IGFjYykpXG5cbmxldCB0b19hcnJheSB+bGVuZ3RoIH5pdGVyIGMgPVxuICBsZXQgYXJyYXkgPSByZWYgW3x8XSBpblxuICBsZXQgaSA9IHJlZiAwIGluXG4gIGl0ZXIgYyB+ZjooZnVuIHggLT5cbiAgICBpZiAhaSA9IDAgdGhlbiBhcnJheSA6PSBBcnJheS5jcmVhdGUgfmxlbjoobGVuZ3RoIGMpIHg7XG4gICAgIWFycmF5LighaSkgPC0geDtcbiAgICBpbmNyIGkpO1xuICAhYXJyYXlcbjs7XG5cbm1vZHVsZSBNYWtlX2dlbiAoVCA6IE1ha2VfZ2VuX2FyZykgOiBzaWdcbiAgaW5jbHVkZSBHZW5lcmljIHdpdGggdHlwZSAnYSB0IDo9ICdhIFQudCB3aXRoIHR5cGUgJ2EgZWx0IDo9ICdhIFQuZWx0XG5lbmQgPSBzdHJ1Y3RcbiAgbGV0IGZvbGQgPSBULmZvbGRcblxuICBsZXQgaXRlciA9XG4gICAgbWF0Y2ggVC5pdGVyIHdpdGhcbiAgICB8IGBDdXN0b20gaXRlciAtPiBpdGVyXG4gICAgfCBgRGVmaW5lX3VzaW5nX2ZvbGQgLT4gZnVuIHQgfmYgLT4gaXRlciB+Zm9sZCB0IH5mXG4gIDs7XG5cbiAgbGV0IGxlbmd0aCA9XG4gICAgbWF0Y2ggVC5sZW5ndGggd2l0aFxuICAgIHwgYEN1c3RvbSBsZW5ndGggLT4gbGVuZ3RoXG4gICAgfCBgRGVmaW5lX3VzaW5nX2ZvbGQgLT4gZnVuIHQgLT4gbGVuZ3RoIH5mb2xkIHRcbiAgOztcblxuICBsZXQgaXNfZW1wdHkgdCA9IGlzX2VtcHR5IH5pdGVyIHRcbiAgbGV0IHN1bSBtIHQgPSBzdW0gfmZvbGQgbSB0XG4gIGxldCBjb3VudCB0IH5mID0gY291bnQgfmZvbGQgdCB+ZlxuICBsZXQgZXhpc3RzIHQgfmYgPSBleGlzdHMgfml0ZXIgdCB+ZlxuICBsZXQgZm9yX2FsbCB0IH5mID0gZm9yX2FsbCB+aXRlciB0IH5mXG4gIGxldCBmaW5kX21hcCB0IH5mID0gZmluZF9tYXAgfml0ZXIgdCB+ZlxuICBsZXQgZmluZCB0IH5mID0gZmluZCB+aXRlciB0IH5mXG4gIGxldCB0b19saXN0IHQgPSB0b19saXN0IH5mb2xkIHRcbiAgbGV0IHRvX2FycmF5IHQgPSB0b19hcnJheSB+bGVuZ3RoIH5pdGVyIHRcbiAgbGV0IG1pbl9lbHQgdCB+Y29tcGFyZSA9IG1pbl9lbHQgfmZvbGQgdCB+Y29tcGFyZVxuICBsZXQgbWF4X2VsdCB0IH5jb21wYXJlID0gbWF4X2VsdCB+Zm9sZCB0IH5jb21wYXJlXG4gIGxldCBmb2xkX3Jlc3VsdCB0IH5pbml0IH5mID0gZm9sZF9yZXN1bHQgdCB+Zm9sZCB+aW5pdCB+ZlxuICBsZXQgZm9sZF91bnRpbCB0IH5pbml0IH5mIH5maW5pc2ggPSBmb2xkX3VudGlsIHQgfmZvbGQgfmluaXQgfmYgfmZpbmlzaFxuZW5kXG5cbm1vZHVsZSBNYWtlIChUIDogTWFrZV9hcmcpID0gc3RydWN0XG4gIGluY2x1ZGUgTWFrZV9nZW4gKHN0cnVjdFxuICAgICAgaW5jbHVkZSBUXG5cbiAgICAgIHR5cGUgJ2EgZWx0ID0gJ2FcbiAgICBlbmQpXG5cbiAgbGV0IG1lbSB0IGEgfmVxdWFsID0gZXhpc3RzIHQgfmY6KGVxdWFsIGEpXG5lbmRcblxubW9kdWxlIE1ha2UwIChUIDogTWFrZTBfYXJnKSA9IHN0cnVjdFxuICBpbmNsdWRlIE1ha2VfZ2VuIChzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgVFxuXG4gICAgICB0eXBlICdhIHQgPSBULnRcbiAgICAgIHR5cGUgJ2EgZWx0ID0gVC5FbHQudFxuICAgIGVuZClcblxuICBsZXQgbWVtIHQgZWx0ID0gZXhpc3RzIHQgfmY6KFQuRWx0LmVxdWFsIGVsdClcbmVuZFxuIiwiKCoqIFByb3ZpZGVzIGdlbmVyaWMgc2lnbmF0dXJlcyBmb3IgY29udGFpbmVyIGRhdGEgc3RydWN0dXJlcy5cblxuICAgIFRoZXNlIHNpZ25hdHVyZXMgaW5jbHVkZSBmdW5jdGlvbnMgKFtpdGVyXSwgW2ZvbGRdLCBbZXhpc3RzXSwgW2Zvcl9hbGxdLCAuLi4pIHRoYXRcbiAgICB5b3Ugd291bGQgZXhwZWN0IHRvIGZpbmQgaW4gYW55IGNvbnRhaW5lci4gVXNlZCBieSBpbmNsdWRpbmcgW0NvbnRhaW5lci5TMF0gb3JcbiAgICBbQ29udGFpbmVyLlMxXSBpbiB0aGUgc2lnbmF0dXJlIGZvciBldmVyeSBjb250YWluZXItbGlrZSBkYXRhIHN0cnVjdHVyZSAoW0FycmF5XSxcbiAgICBbTGlzdF0sIFtTdHJpbmddLCAuLi4pIHRvIGVuc3VyZSBhIGNvbnNpc3RlbnQgaW50ZXJmYWNlLiAqKVxuXG5vcGVuISBJbXBvcnRcblxubW9kdWxlIEV4cG9ydCA9IHN0cnVjdFxuICAoKiogW0NvbnRpbnVlX29yX3N0b3AudF0gaXMgdXNlZCBieSB0aGUgW2ZdIGFyZ3VtZW50IHRvIFtmb2xkX3VudGlsXSBpbiBvcmRlciB0b1xuICAgICAgaW5kaWNhdGUgd2hldGhlciBmb2xkaW5nIHNob3VsZCBjb250aW51ZSwgb3Igc3RvcCBlYXJseS5cblxuICAgICAgQGNhbm9uaWNhbCBCYXNlLkNvbnRhaW5lci5Db250aW51ZV9vcl9zdG9wXG4gICopXG4gIG1vZHVsZSBDb250aW51ZV9vcl9zdG9wID0gc3RydWN0XG4gICAgdHlwZSAoJ2EsICdiKSB0ID1cbiAgICAgIHwgQ29udGludWUgb2YgJ2FcbiAgICAgIHwgU3RvcCBvZiAnYlxuICBlbmRcbmVuZFxuXG5pbmNsdWRlIEV4cG9ydFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkNvbnRhaW5lci5TdW1tYWJsZSAqKVxubW9kdWxlIHR5cGUgU3VtbWFibGUgPSBzaWdcbiAgdHlwZSB0XG5cbiAgKCoqIFRoZSByZXN1bHQgb2Ygc3VtbWluZyBubyB2YWx1ZXMuICopXG4gIHZhbCB6ZXJvIDogdFxuXG4gICgqKiBBbiBvcGVyYXRpb24gdGhhdCBjb21iaW5lcyB0d28gW3RdJ3MgYW5kIGhhbmRsZXMgW3plcm8gKyB4XSBieSBqdXN0IHJldHVybmluZyBbeF0sXG4gICAgICBhcyB3ZWxsIGFzIGluIHRoZSBzeW1tZXRyaWMgY2FzZS4gKilcbiAgdmFsICggKyApIDogdCAtPiB0IC0+IHRcbmVuZFxuXG4oKiogU2lnbmF0dXJlIGZvciBtb25vbW9ycGhpYyBjb250YWluZXIgLSBhIGNvbnRhaW5lciBmb3IgYSBzcGVjaWZpYyBlbGVtZW50IHR5cGUsIGUuZy4sXG4gICAgc3RyaW5nLCB3aGljaCBpcyBhIGNvbnRhaW5lciBvZiBjaGFyYWN0ZXJzIChbdHlwZSBlbHQgPSBjaGFyXSkgYW5kIG5ldmVyIG9mIGFueXRoaW5nXG4gICAgZWxzZS4gKilcbm1vZHVsZSB0eXBlIFMwID0gc2lnXG4gIHR5cGUgdFxuICB0eXBlIGVsdFxuXG4gICgqKiBDaGVja3Mgd2hldGhlciB0aGUgcHJvdmlkZWQgZWxlbWVudCBpcyB0aGVyZSwgdXNpbmcgZXF1YWxpdHkgb24gW2VsdF1zLiAqKVxuICB2YWwgbWVtIDogdCAtPiBlbHQgLT4gYm9vbFxuXG4gIHZhbCBsZW5ndGggOiB0IC0+IGludFxuICB2YWwgaXNfZW1wdHkgOiB0IC0+IGJvb2xcblxuICAoKiogW2l0ZXJdIG11c3QgYWxsb3cgZXhjZXB0aW9ucyByYWlzZWQgaW4gW2ZdIHRvIGVzY2FwZSwgdGVybWluYXRpbmcgdGhlIGl0ZXJhdGlvblxuICAgICAgY2xlYW5seS4gIFRoZSBzYW1lIGhvbGRzIGZvciBhbGwgZnVuY3Rpb25zIGJlbG93IHRha2luZyBhbiBbZl0uICopXG4gIHZhbCBpdGVyIDogdCAtPiBmOihlbHQgLT4gdW5pdCkgLT4gdW5pdFxuXG4gICgqKiBbZm9sZCB0IH5pbml0IH5mXSByZXR1cm5zIFtmICguLi4gZiAoZiAoZiBpbml0IGUxKSBlMikgZTMgLi4uKSBlbl0sIHdoZXJlIFtlMS4uZW5dXG4gICAgICBhcmUgdGhlIGVsZW1lbnRzIG9mIFt0XS4gKilcbiAgdmFsIGZvbGQgOiB0IC0+IGluaXQ6J2FjY3VtIC0+IGY6KCdhY2N1bSAtPiBlbHQgLT4gJ2FjY3VtKSAtPiAnYWNjdW1cblxuICAoKiogW2ZvbGRfcmVzdWx0IHQgfmluaXQgfmZdIGlzIGEgc2hvcnQtY2lyY3VpdGluZyB2ZXJzaW9uIG9mIFtmb2xkXSB0aGF0IHJ1bnMgaW4gdGhlXG4gICAgICBbUmVzdWx0XSBtb25hZC4gIElmIFtmXSByZXR1cm5zIGFuIFtFcnJvciBfXSwgdGhhdCB2YWx1ZSBpcyByZXR1cm5lZCB3aXRob3V0IGFueVxuICAgICAgYWRkaXRpb25hbCBpbnZvY2F0aW9ucyBvZiBbZl0uICopXG4gIHZhbCBmb2xkX3Jlc3VsdFxuICAgIDogIHRcbiAgICAtPiBpbml0OidhY2N1bVxuICAgIC0+IGY6KCdhY2N1bSAtPiBlbHQgLT4gKCdhY2N1bSwgJ2UpIFJlc3VsdC50KVxuICAgIC0+ICgnYWNjdW0sICdlKSBSZXN1bHQudFxuXG4gICgqKiBbZm9sZF91bnRpbCB0IH5pbml0IH5mIH5maW5pc2hdIGlzIGEgc2hvcnQtY2lyY3VpdGluZyB2ZXJzaW9uIG9mIFtmb2xkXS4gSWYgW2ZdXG4gICAgICByZXR1cm5zIFtTdG9wIF9dIHRoZSBjb21wdXRhdGlvbiBjZWFzZXMgYW5kIHJlc3VsdHMgaW4gdGhhdCB2YWx1ZS4gSWYgW2ZdIHJldHVybnNcbiAgICAgIFtDb250aW51ZSBfXSwgdGhlIGZvbGQgd2lsbCBwcm9jZWVkLiBJZiBbZl0gbmV2ZXIgcmV0dXJucyBbU3RvcCBfXSwgdGhlIGZpbmFsIHJlc3VsdFxuICAgICAgaXMgY29tcHV0ZWQgYnkgW2ZpbmlzaF0uXG5cbiAgICAgIEV4YW1wbGU6XG5cbiAgICAgIHtbXG4gICAgICAgIHR5cGUgbWF5YmVfbmVnYXRpdmUgPVxuICAgICAgICAgIHwgRm91bmRfbmVnYXRpdmUgb2YgaW50XG4gICAgICAgICAgfCBBbGxfbm9ubmVnYXRpdmUgb2YgeyBzdW0gOiBpbnQgfVxuXG4gICAgICAgICgqKiBbZmlyc3RfbmVnX29yX3N1bSBsaXN0XSByZXR1cm5zIHRoZSBmaXJzdCBuZWdhdGl2ZSBudW1iZXIgaW4gW2xpc3RdLCBpZiBhbnksXG4gICAgICAgICAgICBvdGhlcndpc2UgcmV0dXJucyB0aGUgc3VtIG9mIHRoZSBsaXN0LiAqKVxuICAgICAgICBsZXQgZmlyc3RfbmVnX29yX3N1bSA9XG4gICAgICAgICAgTGlzdC5mb2xkX3VudGlsIH5pbml0OjBcbiAgICAgICAgICAgIH5mOihmdW4gc3VtIHggLT5cbiAgICAgICAgICAgICAgaWYgeCA8IDBcbiAgICAgICAgICAgICAgdGhlbiBTdG9wIChGb3VuZF9uZWdhdGl2ZSB4KVxuICAgICAgICAgICAgICBlbHNlIENvbnRpbnVlIChzdW0gKyB4KSlcbiAgICAgICAgICAgIH5maW5pc2g6KGZ1biBzdW0gLT4gQWxsX25vbm5lZ2F0aXZlIHsgc3VtIH0pXG4gICAgICAgIDs7XG5cbiAgICAgICAgbGV0IHggPSBmaXJzdF9uZWdfb3Jfc3VtIFsxOyAyOyAzOyA0OyA1XVxuICAgICAgICB2YWwgeCA6IG1heWJlX25lZ2F0aXZlID0gQWxsX25vbm5lZ2F0aXZlIHtzdW0gPSAxNX1cblxuICAgICAgICBsZXQgeSA9IGZpcnN0X25lZ19vcl9zdW0gWzE7IDI7IC0zOyA0OyA1XVxuICAgICAgICB2YWwgeSA6IG1heWJlX25lZ2F0aXZlID0gRm91bmRfbmVnYXRpdmUgLTNcbiAgICAgIF19ICopXG4gIHZhbCBmb2xkX3VudGlsXG4gICAgOiAgdFxuICAgIC0+IGluaXQ6J2FjY3VtXG4gICAgLT4gZjooJ2FjY3VtIC0+IGVsdCAtPiAoJ2FjY3VtLCAnZmluYWwpIENvbnRpbnVlX29yX3N0b3AudClcbiAgICAtPiBmaW5pc2g6KCdhY2N1bSAtPiAnZmluYWwpXG4gICAgLT4gJ2ZpbmFsXG5cbiAgKCoqIFJldHVybnMgW3RydWVdIGlmIGFuZCBvbmx5IGlmIHRoZXJlIGV4aXN0cyBhbiBlbGVtZW50IGZvciB3aGljaCB0aGUgcHJvdmlkZWRcbiAgICAgIGZ1bmN0aW9uIGV2YWx1YXRlcyB0byBbdHJ1ZV0uIFRoaXMgaXMgYSBzaG9ydC1jaXJjdWl0aW5nIG9wZXJhdGlvbi4gKilcbiAgdmFsIGV4aXN0cyA6IHQgLT4gZjooZWx0IC0+IGJvb2wpIC0+IGJvb2xcblxuICAoKiogUmV0dXJucyBbdHJ1ZV0gaWYgYW5kIG9ubHkgaWYgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIGV2YWx1YXRlcyB0byBbdHJ1ZV0gZm9yIGFsbFxuICAgICAgZWxlbWVudHMuIFRoaXMgaXMgYSBzaG9ydC1jaXJjdWl0aW5nIG9wZXJhdGlvbi4gKilcbiAgdmFsIGZvcl9hbGwgOiB0IC0+IGY6KGVsdCAtPiBib29sKSAtPiBib29sXG5cbiAgKCoqIFJldHVybnMgdGhlIG51bWJlciBvZiBlbGVtZW50cyBmb3Igd2hpY2ggdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIGV2YWx1YXRlcyB0byB0cnVlLiAqKVxuICB2YWwgY291bnQgOiB0IC0+IGY6KGVsdCAtPiBib29sKSAtPiBpbnRcblxuICAoKiogUmV0dXJucyB0aGUgc3VtIG9mIFtmIGldIGZvciBhbGwgW2ldIGluIHRoZSBjb250YWluZXIuICopXG4gIHZhbCBzdW0gOiAobW9kdWxlIFN1bW1hYmxlIHdpdGggdHlwZSB0ID0gJ3N1bSkgLT4gdCAtPiBmOihlbHQgLT4gJ3N1bSkgLT4gJ3N1bVxuXG4gICgqKiBSZXR1cm5zIGFzIGFuIFtvcHRpb25dIHRoZSBmaXJzdCBlbGVtZW50IGZvciB3aGljaCBbZl0gZXZhbHVhdGVzIHRvIHRydWUuICopXG4gIHZhbCBmaW5kIDogdCAtPiBmOihlbHQgLT4gYm9vbCkgLT4gZWx0IG9wdGlvblxuXG4gICgqKiBSZXR1cm5zIHRoZSBmaXJzdCBldmFsdWF0aW9uIG9mIFtmXSB0aGF0IHJldHVybnMgW1NvbWVdLCBhbmQgcmV0dXJucyBbTm9uZV0gaWYgdGhlcmVcbiAgICAgIGlzIG5vIHN1Y2ggZWxlbWVudC4gICopXG4gIHZhbCBmaW5kX21hcCA6IHQgLT4gZjooZWx0IC0+ICdhIG9wdGlvbikgLT4gJ2Egb3B0aW9uXG5cbiAgdmFsIHRvX2xpc3QgOiB0IC0+IGVsdCBsaXN0XG4gIHZhbCB0b19hcnJheSA6IHQgLT4gZWx0IGFycmF5XG5cbiAgKCoqIFJldHVybnMgYSBtaW4gKHJlc3AuIG1heCkgZWxlbWVudCBmcm9tIHRoZSBjb2xsZWN0aW9uIHVzaW5nIHRoZSBwcm92aWRlZCBbY29tcGFyZV1cbiAgICAgIGZ1bmN0aW9uLiBJbiBjYXNlIG9mIGEgdGllLCB0aGUgZmlyc3QgZWxlbWVudCBlbmNvdW50ZXJlZCB3aGlsZSB0cmF2ZXJzaW5nIHRoZVxuICAgICAgY29sbGVjdGlvbiBpcyByZXR1cm5lZC4gVGhlIGltcGxlbWVudGF0aW9uIHVzZXMgW2ZvbGRdIHNvIGl0IGhhcyB0aGUgc2FtZVxuICAgICAgY29tcGxleGl0eSBhcyBbZm9sZF0uIFJldHVybnMgW05vbmVdIGlmZiB0aGUgY29sbGVjdGlvbiBpcyBlbXB0eS4gKilcbiAgdmFsIG1pbl9lbHQgOiB0IC0+IGNvbXBhcmU6KGVsdCAtPiBlbHQgLT4gaW50KSAtPiBlbHQgb3B0aW9uXG5cbiAgdmFsIG1heF9lbHQgOiB0IC0+IGNvbXBhcmU6KGVsdCAtPiBlbHQgLT4gaW50KSAtPiBlbHQgb3B0aW9uXG5lbmRcblxubW9kdWxlIHR5cGUgUzBfcGhhbnRvbSA9IHNpZ1xuICB0eXBlIGVsdFxuICB0eXBlICdhIHRcblxuICAoKiogQ2hlY2tzIHdoZXRoZXIgdGhlIHByb3ZpZGVkIGVsZW1lbnQgaXMgdGhlcmUsIHVzaW5nIGVxdWFsaXR5IG9uIFtlbHRdcy4gKilcbiAgdmFsIG1lbSA6IF8gdCAtPiBlbHQgLT4gYm9vbFxuXG4gIHZhbCBsZW5ndGggOiBfIHQgLT4gaW50XG4gIHZhbCBpc19lbXB0eSA6IF8gdCAtPiBib29sXG4gIHZhbCBpdGVyIDogXyB0IC0+IGY6KGVsdCAtPiB1bml0KSAtPiB1bml0XG5cbiAgKCoqIFtmb2xkIHQgfmluaXQgfmZdIHJldHVybnMgW2YgKC4uLiBmIChmIChmIGluaXQgZTEpIGUyKSBlMyAuLi4pIGVuXSwgd2hlcmUgW2UxLi5lbl1cbiAgICAgIGFyZSB0aGUgZWxlbWVudHMgb2YgW3RdLiAqKVxuICB2YWwgZm9sZCA6IF8gdCAtPiBpbml0OidhY2N1bSAtPiBmOignYWNjdW0gLT4gZWx0IC0+ICdhY2N1bSkgLT4gJ2FjY3VtXG5cbiAgKCoqIFtmb2xkX3Jlc3VsdCB0IH5pbml0IH5mXSBpcyBhIHNob3J0LWNpcmN1aXRpbmcgdmVyc2lvbiBvZiBbZm9sZF0gdGhhdCBydW5zIGluIHRoZVxuICAgICAgW1Jlc3VsdF0gbW9uYWQuICBJZiBbZl0gcmV0dXJucyBhbiBbRXJyb3IgX10sIHRoYXQgdmFsdWUgaXMgcmV0dXJuZWQgd2l0aG91dCBhbnlcbiAgICAgIGFkZGl0aW9uYWwgaW52b2NhdGlvbnMgb2YgW2ZdLiAqKVxuICB2YWwgZm9sZF9yZXN1bHRcbiAgICA6ICBfIHRcbiAgICAtPiBpbml0OidhY2N1bVxuICAgIC0+IGY6KCdhY2N1bSAtPiBlbHQgLT4gKCdhY2N1bSwgJ2UpIFJlc3VsdC50KVxuICAgIC0+ICgnYWNjdW0sICdlKSBSZXN1bHQudFxuXG4gICgqKiBbZm9sZF91bnRpbCB0IH5pbml0IH5mIH5maW5pc2hdIGlzIGEgc2hvcnQtY2lyY3VpdGluZyB2ZXJzaW9uIG9mIFtmb2xkXS4gSWYgW2ZdXG4gICAgICByZXR1cm5zIFtTdG9wIF9dIHRoZSBjb21wdXRhdGlvbiBjZWFzZXMgYW5kIHJlc3VsdHMgaW4gdGhhdCB2YWx1ZS4gSWYgW2ZdIHJldHVybnNcbiAgICAgIFtDb250aW51ZSBfXSwgdGhlIGZvbGQgd2lsbCBwcm9jZWVkLiBJZiBbZl0gbmV2ZXIgcmV0dXJucyBbU3RvcCBfXSwgdGhlIGZpbmFsIHJlc3VsdFxuICAgICAgaXMgY29tcHV0ZWQgYnkgW2ZpbmlzaF0uXG5cbiAgICAgIEV4YW1wbGU6XG5cbiAgICAgIHtbXG4gICAgICAgIHR5cGUgbWF5YmVfbmVnYXRpdmUgPVxuICAgICAgICAgIHwgRm91bmRfbmVnYXRpdmUgb2YgaW50XG4gICAgICAgICAgfCBBbGxfbm9ubmVnYXRpdmUgb2YgeyBzdW0gOiBpbnQgfVxuXG4gICAgICAgICgqKiBbZmlyc3RfbmVnX29yX3N1bSBsaXN0XSByZXR1cm5zIHRoZSBmaXJzdCBuZWdhdGl2ZSBudW1iZXIgaW4gW2xpc3RdLCBpZiBhbnksXG4gICAgICAgICAgICBvdGhlcndpc2UgcmV0dXJucyB0aGUgc3VtIG9mIHRoZSBsaXN0LiAqKVxuICAgICAgICBsZXQgZmlyc3RfbmVnX29yX3N1bSA9XG4gICAgICAgICAgTGlzdC5mb2xkX3VudGlsIH5pbml0OjBcbiAgICAgICAgICAgIH5mOihmdW4gc3VtIHggLT5cbiAgICAgICAgICAgICAgaWYgeCA8IDBcbiAgICAgICAgICAgICAgdGhlbiBTdG9wIChGb3VuZF9uZWdhdGl2ZSB4KVxuICAgICAgICAgICAgICBlbHNlIENvbnRpbnVlIChzdW0gKyB4KSlcbiAgICAgICAgICAgIH5maW5pc2g6KGZ1biBzdW0gLT4gQWxsX25vbm5lZ2F0aXZlIHsgc3VtIH0pXG4gICAgICAgIDs7XG5cbiAgICAgICAgbGV0IHggPSBmaXJzdF9uZWdfb3Jfc3VtIFsxOyAyOyAzOyA0OyA1XVxuICAgICAgICB2YWwgeCA6IG1heWJlX25lZ2F0aXZlID0gQWxsX25vbm5lZ2F0aXZlIHtzdW0gPSAxNX1cblxuICAgICAgICBsZXQgeSA9IGZpcnN0X25lZ19vcl9zdW0gWzE7IDI7IC0zOyA0OyA1XVxuICAgICAgICB2YWwgeSA6IG1heWJlX25lZ2F0aXZlID0gRm91bmRfbmVnYXRpdmUgLTNcbiAgICAgIF19ICopXG4gIHZhbCBmb2xkX3VudGlsXG4gICAgOiAgXyB0XG4gICAgLT4gaW5pdDonYWNjdW1cbiAgICAtPiBmOignYWNjdW0gLT4gZWx0IC0+ICgnYWNjdW0sICdmaW5hbCkgQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IGZpbmlzaDooJ2FjY3VtIC0+ICdmaW5hbClcbiAgICAtPiAnZmluYWxcblxuICAoKiogUmV0dXJucyBbdHJ1ZV0gaWYgYW5kIG9ubHkgaWYgdGhlcmUgZXhpc3RzIGFuIGVsZW1lbnQgZm9yIHdoaWNoIHRoZSBwcm92aWRlZFxuICAgICAgZnVuY3Rpb24gZXZhbHVhdGVzIHRvIFt0cnVlXS4gIFRoaXMgaXMgYSBzaG9ydC1jaXJjdWl0aW5nIG9wZXJhdGlvbi4gKilcbiAgdmFsIGV4aXN0cyA6IF8gdCAtPiBmOihlbHQgLT4gYm9vbCkgLT4gYm9vbFxuXG4gICgqKiBSZXR1cm5zIFt0cnVlXSBpZiBhbmQgb25seSBpZiB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gZXZhbHVhdGVzIHRvIFt0cnVlXSBmb3IgYWxsXG4gICAgICBlbGVtZW50cy4gIFRoaXMgaXMgYSBzaG9ydC1jaXJjdWl0aW5nIG9wZXJhdGlvbi4gKilcbiAgdmFsIGZvcl9hbGwgOiBfIHQgLT4gZjooZWx0IC0+IGJvb2wpIC0+IGJvb2xcblxuICAoKiogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGZvciB3aGljaCB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gZXZhbHVhdGVzIHRvIHRydWUuICopXG4gIHZhbCBjb3VudCA6IF8gdCAtPiBmOihlbHQgLT4gYm9vbCkgLT4gaW50XG5cbiAgKCoqIFJldHVybnMgdGhlIHN1bSBvZiBbZiBpXSBmb3IgYWxsIFtpXSBpbiB0aGUgY29udGFpbmVyLiBUaGUgb3JkZXIgaW4gd2hpY2ggdGhlXG4gICAgICBlbGVtZW50cyB3aWxsIGJlIHN1bW1lZCBpcyB1bnNwZWNpZmllZC4gKilcbiAgdmFsIHN1bSA6IChtb2R1bGUgU3VtbWFibGUgd2l0aCB0eXBlIHQgPSAnc3VtKSAtPiBfIHQgLT4gZjooZWx0IC0+ICdzdW0pIC0+ICdzdW1cblxuICAoKiogUmV0dXJucyBhcyBhbiBbb3B0aW9uXSB0aGUgZmlyc3QgZWxlbWVudCBmb3Igd2hpY2ggW2ZdIGV2YWx1YXRlcyB0byB0cnVlLiAqKVxuICB2YWwgZmluZCA6IF8gdCAtPiBmOihlbHQgLT4gYm9vbCkgLT4gZWx0IG9wdGlvblxuXG4gICgqKiBSZXR1cm5zIHRoZSBmaXJzdCBldmFsdWF0aW9uIG9mIFtmXSB0aGF0IHJldHVybnMgW1NvbWVdLCBhbmQgcmV0dXJucyBbTm9uZV0gaWYgdGhlcmVcbiAgICAgIGlzIG5vIHN1Y2ggZWxlbWVudC4gICopXG4gIHZhbCBmaW5kX21hcCA6IF8gdCAtPiBmOihlbHQgLT4gJ2Egb3B0aW9uKSAtPiAnYSBvcHRpb25cblxuICB2YWwgdG9fbGlzdCA6IF8gdCAtPiBlbHQgbGlzdFxuICB2YWwgdG9fYXJyYXkgOiBfIHQgLT4gZWx0IGFycmF5XG5cbiAgKCoqIFJldHVybnMgYSBtaW4gKHJlc3AgbWF4KSBlbGVtZW50IGZyb20gdGhlIGNvbGxlY3Rpb24gdXNpbmcgdGhlIHByb3ZpZGVkIFtjb21wYXJlXVxuICAgICAgZnVuY3Rpb24sIG9yIFtOb25lXSBpZiB0aGUgY29sbGVjdGlvbiBpcyBlbXB0eS4gIEluIGNhc2Ugb2YgYSB0aWUsIHRoZSBmaXJzdCBlbGVtZW50XG4gICAgICBlbmNvdW50ZXJlZCB3aGlsZSB0cmF2ZXJzaW5nIHRoZSBjb2xsZWN0aW9uIGlzIHJldHVybmVkLiAqKVxuICB2YWwgbWluX2VsdCA6IF8gdCAtPiBjb21wYXJlOihlbHQgLT4gZWx0IC0+IGludCkgLT4gZWx0IG9wdGlvblxuXG4gIHZhbCBtYXhfZWx0IDogXyB0IC0+IGNvbXBhcmU6KGVsdCAtPiBlbHQgLT4gaW50KSAtPiBlbHQgb3B0aW9uXG5lbmRcblxuKCoqIFNpZ25hdHVyZSBmb3IgcG9seW1vcnBoaWMgY29udGFpbmVyLCBlLmcuLCBbJ2EgbGlzdF0gb3IgWydhIGFycmF5XS4gKilcbm1vZHVsZSB0eXBlIFMxID0gc2lnXG4gIHR5cGUgJ2EgdFxuXG4gICgqKiBDaGVja3Mgd2hldGhlciB0aGUgcHJvdmlkZWQgZWxlbWVudCBpcyB0aGVyZSwgdXNpbmcgW2VxdWFsXS4gKilcbiAgdmFsIG1lbSA6ICdhIHQgLT4gJ2EgLT4gZXF1YWw6KCdhIC0+ICdhIC0+IGJvb2wpIC0+IGJvb2xcblxuICB2YWwgbGVuZ3RoIDogJ2EgdCAtPiBpbnRcbiAgdmFsIGlzX2VtcHR5IDogJ2EgdCAtPiBib29sXG4gIHZhbCBpdGVyIDogJ2EgdCAtPiBmOignYSAtPiB1bml0KSAtPiB1bml0XG5cbiAgKCoqIFtmb2xkIHQgfmluaXQgfmZdIHJldHVybnMgW2YgKC4uLiBmIChmIChmIGluaXQgZTEpIGUyKSBlMyAuLi4pIGVuXSwgd2hlcmUgW2UxLi5lbl1cbiAgICAgIGFyZSB0aGUgZWxlbWVudHMgb2YgW3RdICAqKVxuICB2YWwgZm9sZCA6ICdhIHQgLT4gaW5pdDonYWNjdW0gLT4gZjooJ2FjY3VtIC0+ICdhIC0+ICdhY2N1bSkgLT4gJ2FjY3VtXG5cbiAgKCoqIFtmb2xkX3Jlc3VsdCB0IH5pbml0IH5mXSBpcyBhIHNob3J0LWNpcmN1aXRpbmcgdmVyc2lvbiBvZiBbZm9sZF0gdGhhdCBydW5zIGluIHRoZVxuICAgICAgW1Jlc3VsdF0gbW9uYWQuICBJZiBbZl0gcmV0dXJucyBhbiBbRXJyb3IgX10sIHRoYXQgdmFsdWUgaXMgcmV0dXJuZWQgd2l0aG91dCBhbnlcbiAgICAgIGFkZGl0aW9uYWwgaW52b2NhdGlvbnMgb2YgW2ZdLiAqKVxuICB2YWwgZm9sZF9yZXN1bHRcbiAgICA6ICAnYSB0XG4gICAgLT4gaW5pdDonYWNjdW1cbiAgICAtPiBmOignYWNjdW0gLT4gJ2EgLT4gKCdhY2N1bSwgJ2UpIFJlc3VsdC50KVxuICAgIC0+ICgnYWNjdW0sICdlKSBSZXN1bHQudFxuXG4gICgqKiBbZm9sZF91bnRpbCB0IH5pbml0IH5mIH5maW5pc2hdIGlzIGEgc2hvcnQtY2lyY3VpdGluZyB2ZXJzaW9uIG9mIFtmb2xkXS4gSWYgW2ZdXG4gICAgICByZXR1cm5zIFtTdG9wIF9dIHRoZSBjb21wdXRhdGlvbiBjZWFzZXMgYW5kIHJlc3VsdHMgaW4gdGhhdCB2YWx1ZS4gSWYgW2ZdIHJldHVybnNcbiAgICAgIFtDb250aW51ZSBfXSwgdGhlIGZvbGQgd2lsbCBwcm9jZWVkLiBJZiBbZl0gbmV2ZXIgcmV0dXJucyBbU3RvcCBfXSwgdGhlIGZpbmFsIHJlc3VsdFxuICAgICAgaXMgY29tcHV0ZWQgYnkgW2ZpbmlzaF0uXG5cbiAgICAgIEV4YW1wbGU6XG5cbiAgICAgIHtbXG4gICAgICAgIHR5cGUgbWF5YmVfbmVnYXRpdmUgPVxuICAgICAgICAgIHwgRm91bmRfbmVnYXRpdmUgb2YgaW50XG4gICAgICAgICAgfCBBbGxfbm9ubmVnYXRpdmUgb2YgeyBzdW0gOiBpbnQgfVxuXG4gICAgICAgICgqKiBbZmlyc3RfbmVnX29yX3N1bSBsaXN0XSByZXR1cm5zIHRoZSBmaXJzdCBuZWdhdGl2ZSBudW1iZXIgaW4gW2xpc3RdLCBpZiBhbnksXG4gICAgICAgICAgICBvdGhlcndpc2UgcmV0dXJucyB0aGUgc3VtIG9mIHRoZSBsaXN0LiAqKVxuICAgICAgICBsZXQgZmlyc3RfbmVnX29yX3N1bSA9XG4gICAgICAgICAgTGlzdC5mb2xkX3VudGlsIH5pbml0OjBcbiAgICAgICAgICAgIH5mOihmdW4gc3VtIHggLT5cbiAgICAgICAgICAgICAgaWYgeCA8IDBcbiAgICAgICAgICAgICAgdGhlbiBTdG9wIChGb3VuZF9uZWdhdGl2ZSB4KVxuICAgICAgICAgICAgICBlbHNlIENvbnRpbnVlIChzdW0gKyB4KSlcbiAgICAgICAgICAgIH5maW5pc2g6KGZ1biBzdW0gLT4gQWxsX25vbm5lZ2F0aXZlIHsgc3VtIH0pXG4gICAgICAgIDs7XG5cbiAgICAgICAgbGV0IHggPSBmaXJzdF9uZWdfb3Jfc3VtIFsxOyAyOyAzOyA0OyA1XVxuICAgICAgICB2YWwgeCA6IG1heWJlX25lZ2F0aXZlID0gQWxsX25vbm5lZ2F0aXZlIHtzdW0gPSAxNX1cblxuICAgICAgICBsZXQgeSA9IGZpcnN0X25lZ19vcl9zdW0gWzE7IDI7IC0zOyA0OyA1XVxuICAgICAgICB2YWwgeSA6IG1heWJlX25lZ2F0aXZlID0gRm91bmRfbmVnYXRpdmUgLTNcbiAgICAgIF19ICopXG4gIHZhbCBmb2xkX3VudGlsXG4gICAgOiAgJ2EgdFxuICAgIC0+IGluaXQ6J2FjY3VtXG4gICAgLT4gZjooJ2FjY3VtIC0+ICdhIC0+ICgnYWNjdW0sICdmaW5hbCkgQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IGZpbmlzaDooJ2FjY3VtIC0+ICdmaW5hbClcbiAgICAtPiAnZmluYWxcblxuICAoKiogUmV0dXJucyBbdHJ1ZV0gaWYgYW5kIG9ubHkgaWYgdGhlcmUgZXhpc3RzIGFuIGVsZW1lbnQgZm9yIHdoaWNoIHRoZSBwcm92aWRlZFxuICAgICAgZnVuY3Rpb24gZXZhbHVhdGVzIHRvIFt0cnVlXS4gIFRoaXMgaXMgYSBzaG9ydC1jaXJjdWl0aW5nIG9wZXJhdGlvbi4gKilcbiAgdmFsIGV4aXN0cyA6ICdhIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gYm9vbFxuXG4gICgqKiBSZXR1cm5zIFt0cnVlXSBpZiBhbmQgb25seSBpZiB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gZXZhbHVhdGVzIHRvIFt0cnVlXSBmb3IgYWxsXG4gICAgICBlbGVtZW50cy4gIFRoaXMgaXMgYSBzaG9ydC1jaXJjdWl0aW5nIG9wZXJhdGlvbi4gKilcbiAgdmFsIGZvcl9hbGwgOiAnYSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+IGJvb2xcblxuICAoKiogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGZvciB3aGljaCB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gZXZhbHVhdGVzIHRvIHRydWUuICopXG4gIHZhbCBjb3VudCA6ICdhIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gaW50XG5cbiAgKCoqIFJldHVybnMgdGhlIHN1bSBvZiBbZiBpXSBmb3IgYWxsIFtpXSBpbiB0aGUgY29udGFpbmVyLiAqKVxuICB2YWwgc3VtIDogKG1vZHVsZSBTdW1tYWJsZSB3aXRoIHR5cGUgdCA9ICdzdW0pIC0+ICdhIHQgLT4gZjooJ2EgLT4gJ3N1bSkgLT4gJ3N1bVxuXG4gICgqKiBSZXR1cm5zIGFzIGFuIFtvcHRpb25dIHRoZSBmaXJzdCBlbGVtZW50IGZvciB3aGljaCBbZl0gZXZhbHVhdGVzIHRvIHRydWUuICopXG4gIHZhbCBmaW5kIDogJ2EgdCAtPiBmOignYSAtPiBib29sKSAtPiAnYSBvcHRpb25cblxuICAoKiogUmV0dXJucyB0aGUgZmlyc3QgZXZhbHVhdGlvbiBvZiBbZl0gdGhhdCByZXR1cm5zIFtTb21lXSwgYW5kIHJldHVybnMgW05vbmVdIGlmIHRoZXJlXG4gICAgICBpcyBubyBzdWNoIGVsZW1lbnQuICAqKVxuICB2YWwgZmluZF9tYXAgOiAnYSB0IC0+IGY6KCdhIC0+ICdiIG9wdGlvbikgLT4gJ2Igb3B0aW9uXG5cbiAgdmFsIHRvX2xpc3QgOiAnYSB0IC0+ICdhIGxpc3RcbiAgdmFsIHRvX2FycmF5IDogJ2EgdCAtPiAnYSBhcnJheVxuXG4gICgqKiBSZXR1cm5zIGEgbWluaW11bSAocmVzcCBtYXhpbXVtKSBlbGVtZW50IGZyb20gdGhlIGNvbGxlY3Rpb24gdXNpbmcgdGhlIHByb3ZpZGVkXG4gICAgICBbY29tcGFyZV0gZnVuY3Rpb24sIG9yIFtOb25lXSBpZiB0aGUgY29sbGVjdGlvbiBpcyBlbXB0eS4gSW4gY2FzZSBvZiBhIHRpZSwgdGhlIGZpcnN0XG4gICAgICBlbGVtZW50IGVuY291bnRlcmVkIHdoaWxlIHRyYXZlcnNpbmcgdGhlIGNvbGxlY3Rpb24gaXMgcmV0dXJuZWQuIFRoZSBpbXBsZW1lbnRhdGlvblxuICAgICAgdXNlcyBbZm9sZF0gc28gaXQgaGFzIHRoZSBzYW1lIGNvbXBsZXhpdHkgYXMgW2ZvbGRdLiAqKVxuICB2YWwgbWluX2VsdCA6ICdhIHQgLT4gY29tcGFyZTooJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSBvcHRpb25cblxuICB2YWwgbWF4X2VsdCA6ICdhIHQgLT4gY29tcGFyZTooJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSBvcHRpb25cbmVuZFxuXG5tb2R1bGUgdHlwZSBTMV9waGFudG9tX2ludmFyaWFudCA9IHNpZ1xuICB0eXBlICgnYSwgJ3BoYW50b20pIHRcblxuICAoKiogQ2hlY2tzIHdoZXRoZXIgdGhlIHByb3ZpZGVkIGVsZW1lbnQgaXMgdGhlcmUsIHVzaW5nIFtlcXVhbF0uICopXG4gIHZhbCBtZW0gOiAoJ2EsIF8pIHQgLT4gJ2EgLT4gZXF1YWw6KCdhIC0+ICdhIC0+IGJvb2wpIC0+IGJvb2xcblxuICB2YWwgbGVuZ3RoIDogKF8sIF8pIHQgLT4gaW50XG4gIHZhbCBpc19lbXB0eSA6IChfLCBfKSB0IC0+IGJvb2xcbiAgdmFsIGl0ZXIgOiAoJ2EsIF8pIHQgLT4gZjooJ2EgLT4gdW5pdCkgLT4gdW5pdFxuXG4gICgqKiBbZm9sZCB0IH5pbml0IH5mXSByZXR1cm5zIFtmICguLi4gZiAoZiAoZiBpbml0IGUxKSBlMikgZTMgLi4uKSBlbl0sIHdoZXJlIFtlMS4uZW5dXG4gICAgICBhcmUgdGhlIGVsZW1lbnRzIG9mIFt0XS4gKilcbiAgdmFsIGZvbGQgOiAoJ2EsIF8pIHQgLT4gaW5pdDonYWNjdW0gLT4gZjooJ2FjY3VtIC0+ICdhIC0+ICdhY2N1bSkgLT4gJ2FjY3VtXG5cbiAgKCoqIFtmb2xkX3Jlc3VsdCB0IH5pbml0IH5mXSBpcyBhIHNob3J0LWNpcmN1aXRpbmcgdmVyc2lvbiBvZiBbZm9sZF0gdGhhdCBydW5zIGluIHRoZVxuICAgICAgW1Jlc3VsdF0gbW9uYWQuICBJZiBbZl0gcmV0dXJucyBhbiBbRXJyb3IgX10sIHRoYXQgdmFsdWUgaXMgcmV0dXJuZWQgd2l0aG91dCBhbnlcbiAgICAgIGFkZGl0aW9uYWwgaW52b2NhdGlvbnMgb2YgW2ZdLiAqKVxuICB2YWwgZm9sZF9yZXN1bHRcbiAgICA6ICAoJ2EsIF8pIHRcbiAgICAtPiBpbml0OidhY2N1bVxuICAgIC0+IGY6KCdhY2N1bSAtPiAnYSAtPiAoJ2FjY3VtLCAnZSkgUmVzdWx0LnQpXG4gICAgLT4gKCdhY2N1bSwgJ2UpIFJlc3VsdC50XG5cbiAgKCoqIFtmb2xkX3VudGlsIHQgfmluaXQgfmYgfmZpbmlzaF0gaXMgYSBzaG9ydC1jaXJjdWl0aW5nIHZlcnNpb24gb2YgW2ZvbGRdLiBJZiBbZl1cbiAgICAgIHJldHVybnMgW1N0b3AgX10gdGhlIGNvbXB1dGF0aW9uIGNlYXNlcyBhbmQgcmVzdWx0cyBpbiB0aGF0IHZhbHVlLiBJZiBbZl0gcmV0dXJuc1xuICAgICAgW0NvbnRpbnVlIF9dLCB0aGUgZm9sZCB3aWxsIHByb2NlZWQuIElmIFtmXSBuZXZlciByZXR1cm5zIFtTdG9wIF9dLCB0aGUgZmluYWwgcmVzdWx0XG4gICAgICBpcyBjb21wdXRlZCBieSBbZmluaXNoXS5cblxuICAgICAgRXhhbXBsZTpcblxuICAgICAge1tcbiAgICAgICAgdHlwZSBtYXliZV9uZWdhdGl2ZSA9XG4gICAgICAgICAgfCBGb3VuZF9uZWdhdGl2ZSBvZiBpbnRcbiAgICAgICAgICB8IEFsbF9ub25uZWdhdGl2ZSBvZiB7IHN1bSA6IGludCB9XG5cbiAgICAgICAgKCoqIFtmaXJzdF9uZWdfb3Jfc3VtIGxpc3RdIHJldHVybnMgdGhlIGZpcnN0IG5lZ2F0aXZlIG51bWJlciBpbiBbbGlzdF0sIGlmIGFueSxcbiAgICAgICAgICAgIG90aGVyd2lzZSByZXR1cm5zIHRoZSBzdW0gb2YgdGhlIGxpc3QuICopXG4gICAgICAgIGxldCBmaXJzdF9uZWdfb3Jfc3VtID1cbiAgICAgICAgICBMaXN0LmZvbGRfdW50aWwgfmluaXQ6MFxuICAgICAgICAgICAgfmY6KGZ1biBzdW0geCAtPlxuICAgICAgICAgICAgICBpZiB4IDwgMFxuICAgICAgICAgICAgICB0aGVuIFN0b3AgKEZvdW5kX25lZ2F0aXZlIHgpXG4gICAgICAgICAgICAgIGVsc2UgQ29udGludWUgKHN1bSArIHgpKVxuICAgICAgICAgICAgfmZpbmlzaDooZnVuIHN1bSAtPiBBbGxfbm9ubmVnYXRpdmUgeyBzdW0gfSlcbiAgICAgICAgOztcblxuICAgICAgICBsZXQgeCA9IGZpcnN0X25lZ19vcl9zdW0gWzE7IDI7IDM7IDQ7IDVdXG4gICAgICAgIHZhbCB4IDogbWF5YmVfbmVnYXRpdmUgPSBBbGxfbm9ubmVnYXRpdmUge3N1bSA9IDE1fVxuXG4gICAgICAgIGxldCB5ID0gZmlyc3RfbmVnX29yX3N1bSBbMTsgMjsgLTM7IDQ7IDVdXG4gICAgICAgIHZhbCB5IDogbWF5YmVfbmVnYXRpdmUgPSBGb3VuZF9uZWdhdGl2ZSAtM1xuICAgICAgXX0gKilcbiAgdmFsIGZvbGRfdW50aWxcbiAgICA6ICAoJ2EsIF8pIHRcbiAgICAtPiBpbml0OidhY2N1bVxuICAgIC0+IGY6KCdhY2N1bSAtPiAnYSAtPiAoJ2FjY3VtLCAnZmluYWwpIENvbnRpbnVlX29yX3N0b3AudClcbiAgICAtPiBmaW5pc2g6KCdhY2N1bSAtPiAnZmluYWwpXG4gICAgLT4gJ2ZpbmFsXG5cbiAgKCoqIFJldHVybnMgW3RydWVdIGlmIGFuZCBvbmx5IGlmIHRoZXJlIGV4aXN0cyBhbiBlbGVtZW50IGZvciB3aGljaCB0aGUgcHJvdmlkZWRcbiAgICAgIGZ1bmN0aW9uIGV2YWx1YXRlcyB0byBbdHJ1ZV0uICBUaGlzIGlzIGEgc2hvcnQtY2lyY3VpdGluZyBvcGVyYXRpb24uICopXG4gIHZhbCBleGlzdHMgOiAoJ2EsIF8pIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gYm9vbFxuXG4gICgqKiBSZXR1cm5zIFt0cnVlXSBpZiBhbmQgb25seSBpZiB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gZXZhbHVhdGVzIHRvIFt0cnVlXSBmb3IgYWxsXG4gICAgICBlbGVtZW50cy4gIFRoaXMgaXMgYSBzaG9ydC1jaXJjdWl0aW5nIG9wZXJhdGlvbi4gKilcbiAgdmFsIGZvcl9hbGwgOiAoJ2EsIF8pIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gYm9vbFxuXG4gICgqKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgZm9yIHdoaWNoIHRoZSBwcm92aWRlZCBmdW5jdGlvbiBldmFsdWF0ZXMgdG8gdHJ1ZS4gKilcbiAgdmFsIGNvdW50IDogKCdhLCBfKSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+IGludFxuXG4gICgqKiBSZXR1cm5zIHRoZSBzdW0gb2YgW2YgaV0gZm9yIGFsbCBbaV0gaW4gdGhlIGNvbnRhaW5lci4gKilcbiAgdmFsIHN1bSA6IChtb2R1bGUgU3VtbWFibGUgd2l0aCB0eXBlIHQgPSAnc3VtKSAtPiAoJ2EsIF8pIHQgLT4gZjooJ2EgLT4gJ3N1bSkgLT4gJ3N1bVxuXG4gICgqKiBSZXR1cm5zIGFzIGFuIFtvcHRpb25dIHRoZSBmaXJzdCBlbGVtZW50IGZvciB3aGljaCBbZl0gZXZhbHVhdGVzIHRvIHRydWUuICopXG4gIHZhbCBmaW5kIDogKCdhLCBfKSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+ICdhIG9wdGlvblxuXG4gICgqKiBSZXR1cm5zIHRoZSBmaXJzdCBldmFsdWF0aW9uIG9mIFtmXSB0aGF0IHJldHVybnMgW1NvbWVdLCBhbmQgcmV0dXJucyBbTm9uZV0gaWYgdGhlcmVcbiAgICAgIGlzIG5vIHN1Y2ggZWxlbWVudC4gICopXG4gIHZhbCBmaW5kX21hcCA6ICgnYSwgXykgdCAtPiBmOignYSAtPiAnYiBvcHRpb24pIC0+ICdiIG9wdGlvblxuXG4gIHZhbCB0b19saXN0IDogKCdhLCBfKSB0IC0+ICdhIGxpc3RcbiAgdmFsIHRvX2FycmF5IDogKCdhLCBfKSB0IC0+ICdhIGFycmF5XG5cbiAgKCoqIFJldHVybnMgYSBtaW4gKHJlc3AgbWF4KSBlbGVtZW50IGZyb20gdGhlIGNvbGxlY3Rpb24gdXNpbmcgdGhlIHByb3ZpZGVkIFtjb21wYXJlXVxuICAgICAgZnVuY3Rpb24uIEluIGNhc2Ugb2YgYSB0aWUsIHRoZSBmaXJzdCBlbGVtZW50IGVuY291bnRlcmVkIHdoaWxlIHRyYXZlcnNpbmcgdGhlXG4gICAgICBjb2xsZWN0aW9uIGlzIHJldHVybmVkLiBUaGUgaW1wbGVtZW50YXRpb24gdXNlcyBbZm9sZF0gc28gaXQgaGFzIHRoZSBzYW1lIGNvbXBsZXhpdHlcbiAgICAgIGFzIFtmb2xkXS4gUmV0dXJucyBbTm9uZV0gaWZmIHRoZSBjb2xsZWN0aW9uIGlzIGVtcHR5LiAqKVxuICB2YWwgbWluX2VsdCA6ICgnYSwgXykgdCAtPiBjb21wYXJlOignYSAtPiAnYSAtPiBpbnQpIC0+ICdhIG9wdGlvblxuXG4gIHZhbCBtYXhfZWx0IDogKCdhLCBfKSB0IC0+IGNvbXBhcmU6KCdhIC0+ICdhIC0+IGludCkgLT4gJ2Egb3B0aW9uXG5lbmRcblxubW9kdWxlIHR5cGUgUzFfcGhhbnRvbSA9IHNpZ1xuICB0eXBlICgnYSwgKydwaGFudG9tKSB0XG5cbiAgaW5jbHVkZSBTMV9waGFudG9tX2ludmFyaWFudCB3aXRoIHR5cGUgKCdhLCAncGhhbnRvbSkgdCA6PSAoJ2EsICdwaGFudG9tKSB0XG5lbmRcblxubW9kdWxlIHR5cGUgR2VuZXJpYyA9IHNpZ1xuICB0eXBlICdhIHRcbiAgdHlwZSAnYSBlbHRcblxuICB2YWwgbGVuZ3RoIDogXyB0IC0+IGludFxuICB2YWwgaXNfZW1wdHkgOiBfIHQgLT4gYm9vbFxuICB2YWwgaXRlciA6ICdhIHQgLT4gZjooJ2EgZWx0IC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIGZvbGQgOiAnYSB0IC0+IGluaXQ6J2FjY3VtIC0+IGY6KCdhY2N1bSAtPiAnYSBlbHQgLT4gJ2FjY3VtKSAtPiAnYWNjdW1cblxuICB2YWwgZm9sZF9yZXN1bHRcbiAgICA6ICAnYSB0XG4gICAgLT4gaW5pdDonYWNjdW1cbiAgICAtPiBmOignYWNjdW0gLT4gJ2EgZWx0IC0+ICgnYWNjdW0sICdlKSBSZXN1bHQudClcbiAgICAtPiAoJ2FjY3VtLCAnZSkgUmVzdWx0LnRcblxuICB2YWwgZm9sZF91bnRpbFxuICAgIDogICdhIHRcbiAgICAtPiBpbml0OidhY2N1bVxuICAgIC0+IGY6KCdhY2N1bSAtPiAnYSBlbHQgLT4gKCdhY2N1bSwgJ2ZpbmFsKSBDb250aW51ZV9vcl9zdG9wLnQpXG4gICAgLT4gZmluaXNoOignYWNjdW0gLT4gJ2ZpbmFsKVxuICAgIC0+ICdmaW5hbFxuXG4gIHZhbCBleGlzdHMgOiAnYSB0IC0+IGY6KCdhIGVsdCAtPiBib29sKSAtPiBib29sXG4gIHZhbCBmb3JfYWxsIDogJ2EgdCAtPiBmOignYSBlbHQgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgY291bnQgOiAnYSB0IC0+IGY6KCdhIGVsdCAtPiBib29sKSAtPiBpbnRcbiAgdmFsIHN1bSA6IChtb2R1bGUgU3VtbWFibGUgd2l0aCB0eXBlIHQgPSAnc3VtKSAtPiAnYSB0IC0+IGY6KCdhIGVsdCAtPiAnc3VtKSAtPiAnc3VtXG4gIHZhbCBmaW5kIDogJ2EgdCAtPiBmOignYSBlbHQgLT4gYm9vbCkgLT4gJ2EgZWx0IG9wdGlvblxuICB2YWwgZmluZF9tYXAgOiAnYSB0IC0+IGY6KCdhIGVsdCAtPiAnYiBvcHRpb24pIC0+ICdiIG9wdGlvblxuICB2YWwgdG9fbGlzdCA6ICdhIHQgLT4gJ2EgZWx0IGxpc3RcbiAgdmFsIHRvX2FycmF5IDogJ2EgdCAtPiAnYSBlbHQgYXJyYXlcbiAgdmFsIG1pbl9lbHQgOiAnYSB0IC0+IGNvbXBhcmU6KCdhIGVsdCAtPiAnYSBlbHQgLT4gaW50KSAtPiAnYSBlbHQgb3B0aW9uXG4gIHZhbCBtYXhfZWx0IDogJ2EgdCAtPiBjb21wYXJlOignYSBlbHQgLT4gJ2EgZWx0IC0+IGludCkgLT4gJ2EgZWx0IG9wdGlvblxuZW5kXG5cbm1vZHVsZSB0eXBlIEdlbmVyaWNfcGhhbnRvbSA9IHNpZ1xuICB0eXBlICgnYSwgJ3BoYW50b20pIHRcbiAgdHlwZSAnYSBlbHRcblxuICB2YWwgbGVuZ3RoIDogKF8sIF8pIHQgLT4gaW50XG4gIHZhbCBpc19lbXB0eSA6IChfLCBfKSB0IC0+IGJvb2xcbiAgdmFsIGl0ZXIgOiAoJ2EsIF8pIHQgLT4gZjooJ2EgZWx0IC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIGZvbGQgOiAoJ2EsIF8pIHQgLT4gaW5pdDonYWNjdW0gLT4gZjooJ2FjY3VtIC0+ICdhIGVsdCAtPiAnYWNjdW0pIC0+ICdhY2N1bVxuXG4gIHZhbCBmb2xkX3Jlc3VsdFxuICAgIDogICgnYSwgXykgdFxuICAgIC0+IGluaXQ6J2FjY3VtXG4gICAgLT4gZjooJ2FjY3VtIC0+ICdhIGVsdCAtPiAoJ2FjY3VtLCAnZSkgUmVzdWx0LnQpXG4gICAgLT4gKCdhY2N1bSwgJ2UpIFJlc3VsdC50XG5cbiAgdmFsIGZvbGRfdW50aWxcbiAgICA6ICAoJ2EsIF8pIHRcbiAgICAtPiBpbml0OidhY2N1bVxuICAgIC0+IGY6KCdhY2N1bSAtPiAnYSBlbHQgLT4gKCdhY2N1bSwgJ2ZpbmFsKSBDb250aW51ZV9vcl9zdG9wLnQpXG4gICAgLT4gZmluaXNoOignYWNjdW0gLT4gJ2ZpbmFsKVxuICAgIC0+ICdmaW5hbFxuXG4gIHZhbCBleGlzdHMgOiAoJ2EsIF8pIHQgLT4gZjooJ2EgZWx0IC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGZvcl9hbGwgOiAoJ2EsIF8pIHQgLT4gZjooJ2EgZWx0IC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGNvdW50IDogKCdhLCBfKSB0IC0+IGY6KCdhIGVsdCAtPiBib29sKSAtPiBpbnRcblxuICB2YWwgc3VtXG4gICAgOiAgKG1vZHVsZSBTdW1tYWJsZSB3aXRoIHR5cGUgdCA9ICdzdW0pXG4gICAgLT4gKCdhLCBfKSB0XG4gICAgLT4gZjooJ2EgZWx0IC0+ICdzdW0pXG4gICAgLT4gJ3N1bVxuXG4gIHZhbCBmaW5kIDogKCdhLCBfKSB0IC0+IGY6KCdhIGVsdCAtPiBib29sKSAtPiAnYSBlbHQgb3B0aW9uXG4gIHZhbCBmaW5kX21hcCA6ICgnYSwgXykgdCAtPiBmOignYSBlbHQgLT4gJ2Igb3B0aW9uKSAtPiAnYiBvcHRpb25cbiAgdmFsIHRvX2xpc3QgOiAoJ2EsIF8pIHQgLT4gJ2EgZWx0IGxpc3RcbiAgdmFsIHRvX2FycmF5IDogKCdhLCBfKSB0IC0+ICdhIGVsdCBhcnJheVxuICB2YWwgbWluX2VsdCA6ICgnYSwgXykgdCAtPiBjb21wYXJlOignYSBlbHQgLT4gJ2EgZWx0IC0+IGludCkgLT4gJ2EgZWx0IG9wdGlvblxuICB2YWwgbWF4X2VsdCA6ICgnYSwgXykgdCAtPiBjb21wYXJlOignYSBlbHQgLT4gJ2EgZWx0IC0+IGludCkgLT4gJ2EgZWx0IG9wdGlvblxuZW5kXG5cbm1vZHVsZSB0eXBlIE1ha2VfZ2VuX2FyZyA9IHNpZ1xuICB0eXBlICdhIHRcbiAgdHlwZSAnYSBlbHRcblxuICB2YWwgZm9sZCA6ICdhIHQgLT4gaW5pdDonYWNjdW0gLT4gZjooJ2FjY3VtIC0+ICdhIGVsdCAtPiAnYWNjdW0pIC0+ICdhY2N1bVxuXG4gICgqKiBUaGUgW2l0ZXJdIGFyZ3VtZW50IHRvIFtDb250YWluZXIuTWFrZV0gc3BlY2lmaWVzIGhvdyB0byBpbXBsZW1lbnQgdGhlXG4gICAgICBjb250YWluZXIncyBbaXRlcl0gZnVuY3Rpb24uICBbYERlZmluZV91c2luZ19mb2xkXSBtZWFucyB0byBkZWZpbmUgW2l0ZXJdXG4gICAgICB2aWE6XG5cbiAgICAgIHtbXG4gICAgICAgIGl0ZXIgdCB+ZiA9IENvbnRhaW5lci5pdGVyIH5mb2xkIHQgfmZcbiAgICAgIF19XG5cbiAgICAgIFtgQ3VzdG9tXSBvdmVycmlkZXMgdGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24sIHByZXN1bWFibHkgd2l0aCBzb21ldGhpbmcgbW9yZVxuICAgICAgZWZmaWNpZW50LiAgU2V2ZXJhbCBvdGhlciBmdW5jdGlvbnMgcmV0dXJuZWQgYnkgW0NvbnRhaW5lci5NYWtlXSBhcmUgZGVmaW5lZCBpblxuICAgICAgdGVybXMgb2YgW2l0ZXJdLCBzbyBwYXNzaW5nIGluIGEgbW9yZSBlZmZpY2llbnQgW2l0ZXJdIHdpbGwgaW1wcm92ZSB0aGVpciBlZmZpY2llbmN5XG4gICAgICBhcyB3ZWxsLiAqKVxuICB2YWwgaXRlciA6IFsgYERlZmluZV91c2luZ19mb2xkIHwgYEN1c3RvbSBvZiAnYSB0IC0+IGY6KCdhIGVsdCAtPiB1bml0KSAtPiB1bml0IF1cblxuICAoKiogVGhlIFtsZW5ndGhdIGFyZ3VtZW50IHRvIFtDb250YWluZXIuTWFrZV0gc3BlY2lmaWVzIGhvdyB0byBpbXBsZW1lbnQgdGhlXG4gICAgICBjb250YWluZXIncyBbbGVuZ3RoXSBmdW5jdGlvbi4gIFtgRGVmaW5lX3VzaW5nX2ZvbGRdIG1lYW5zIHRvIGRlZmluZVxuICAgICAgW2xlbmd0aF0gdmlhOlxuXG4gICAgICB7W1xuICAgICAgICBsZW5ndGggdCB+ZiA9IENvbnRhaW5lci5sZW5ndGggfmZvbGQgdCB+ZlxuICAgICAgXX1cblxuICAgICAgW2BDdXN0b21dIG92ZXJyaWRlcyB0aGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiwgcHJlc3VtYWJseSB3aXRoIHNvbWV0aGluZyBtb3JlXG4gICAgICBlZmZpY2llbnQuICBTZXZlcmFsIG90aGVyIGZ1bmN0aW9ucyByZXR1cm5lZCBieSBbQ29udGFpbmVyLk1ha2VdIGFyZSBkZWZpbmVkIGluXG4gICAgICB0ZXJtcyBvZiBbbGVuZ3RoXSwgc28gcGFzc2luZyBpbiBhIG1vcmUgZWZmaWNpZW50IFtsZW5ndGhdIHdpbGwgaW1wcm92ZSB0aGVpclxuICAgICAgZWZmaWNpZW5jeSBhcyB3ZWxsLiAqKVxuICB2YWwgbGVuZ3RoIDogWyBgRGVmaW5lX3VzaW5nX2ZvbGQgfCBgQ3VzdG9tIG9mICdhIHQgLT4gaW50IF1cbmVuZFxuXG5tb2R1bGUgdHlwZSBNYWtlX2FyZyA9IE1ha2VfZ2VuX2FyZyB3aXRoIHR5cGUgJ2EgZWx0IDo9ICdhIE1vbmFkLklkZW50LnRcblxubW9kdWxlIHR5cGUgTWFrZTBfYXJnID0gc2lnXG4gIG1vZHVsZSBFbHQgOiBzaWdcbiAgICB0eXBlIHRcblxuICAgIHZhbCBlcXVhbCA6IHQgLT4gdCAtPiBib29sXG4gIGVuZFxuXG4gIHR5cGUgdFxuXG4gIGluY2x1ZGUgTWFrZV9nZW5fYXJnIHdpdGggdHlwZSAnYSB0IDo9IHQgYW5kIHR5cGUgJ2EgZWx0IDo9IEVsdC50XG5lbmRcblxubW9kdWxlIHR5cGUgQ29udGFpbmVyID0gc2lnXG4gIGluY2x1ZGUgbW9kdWxlIHR5cGUgb2Ygc3RydWN0XG4gICAgaW5jbHVkZSBFeHBvcnRcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzAgPSBTMFxuICBtb2R1bGUgdHlwZSBTMF9waGFudG9tID0gUzBfcGhhbnRvbVxuICBtb2R1bGUgdHlwZSBTMSA9IFMxXG4gIG1vZHVsZSB0eXBlIFMxX3BoYW50b21faW52YXJpYW50ID0gUzFfcGhhbnRvbV9pbnZhcmlhbnRcbiAgbW9kdWxlIHR5cGUgUzFfcGhhbnRvbSA9IFMxX3BoYW50b21cbiAgbW9kdWxlIHR5cGUgR2VuZXJpYyA9IEdlbmVyaWNcbiAgbW9kdWxlIHR5cGUgR2VuZXJpY19waGFudG9tID0gR2VuZXJpY19waGFudG9tXG4gIG1vZHVsZSB0eXBlIFN1bW1hYmxlID0gU3VtbWFibGVcblxuICAoKiogR2VuZXJpYyBkZWZpbml0aW9ucyBvZiBjb250YWluZXIgb3BlcmF0aW9ucyBpbiB0ZXJtcyBvZiBbZm9sZF0uXG5cbiAgICAgIEUuZy46IFtpdGVyIH5mb2xkIHQgfmYgPSBmb2xkIHQgfmluaXQ6KCkgfmY6KGZ1biAoKSBhIC0+IGYgYSldLiAqKVxuXG4gIHR5cGUgKCd0LCAnYSwgJ2FjY3VtKSBmb2xkID0gJ3QgLT4gaW5pdDonYWNjdW0gLT4gZjooJ2FjY3VtIC0+ICdhIC0+ICdhY2N1bSkgLT4gJ2FjY3VtXG4gIHR5cGUgKCd0LCAnYSkgaXRlciA9ICd0IC0+IGY6KCdhIC0+IHVuaXQpIC0+IHVuaXRcbiAgdHlwZSAndCBsZW5ndGggPSAndCAtPiBpbnRcblxuICB2YWwgaXRlciA6IGZvbGQ6KCd0LCAnYSwgdW5pdCkgZm9sZCAtPiAoJ3QsICdhKSBpdGVyXG4gIHZhbCBjb3VudCA6IGZvbGQ6KCd0LCAnYSwgaW50KSBmb2xkIC0+ICd0IC0+IGY6KCdhIC0+IGJvb2wpIC0+IGludFxuXG4gIHZhbCBtaW5fZWx0XG4gICAgOiAgZm9sZDooJ3QsICdhLCAnYSBvcHRpb24pIGZvbGRcbiAgICAtPiAndFxuICAgIC0+IGNvbXBhcmU6KCdhIC0+ICdhIC0+IGludClcbiAgICAtPiAnYSBvcHRpb25cblxuICB2YWwgbWF4X2VsdFxuICAgIDogIGZvbGQ6KCd0LCAnYSwgJ2Egb3B0aW9uKSBmb2xkXG4gICAgLT4gJ3RcbiAgICAtPiBjb21wYXJlOignYSAtPiAnYSAtPiBpbnQpXG4gICAgLT4gJ2Egb3B0aW9uXG5cbiAgdmFsIGxlbmd0aCA6IGZvbGQ6KCd0LCBfLCBpbnQpIGZvbGQgLT4gJ3QgLT4gaW50XG4gIHZhbCB0b19saXN0IDogZm9sZDooJ3QsICdhLCAnYSBsaXN0KSBmb2xkIC0+ICd0IC0+ICdhIGxpc3RcblxuICB2YWwgc3VtXG4gICAgOiAgZm9sZDooJ3QsICdhLCAnc3VtKSBmb2xkXG4gICAgLT4gKG1vZHVsZSBTdW1tYWJsZSB3aXRoIHR5cGUgdCA9ICdzdW0pXG4gICAgLT4gJ3RcbiAgICAtPiBmOignYSAtPiAnc3VtKVxuICAgIC0+ICdzdW1cblxuICB2YWwgZm9sZF9yZXN1bHRcbiAgICA6ICBmb2xkOigndCwgJ2EsICdiKSBmb2xkXG4gICAgLT4gaW5pdDonYlxuICAgIC0+IGY6KCdiIC0+ICdhIC0+ICgnYiwgJ2UpIFJlc3VsdC50KVxuICAgIC0+ICd0XG4gICAgLT4gKCdiLCAnZSkgUmVzdWx0LnRcblxuICB2YWwgZm9sZF91bnRpbFxuICAgIDogIGZvbGQ6KCd0LCAnYSwgJ2IpIGZvbGRcbiAgICAtPiBpbml0OidiXG4gICAgLT4gZjooJ2IgLT4gJ2EgLT4gKCdiLCAnZmluYWwpIENvbnRpbnVlX29yX3N0b3AudClcbiAgICAtPiBmaW5pc2g6KCdiIC0+ICdmaW5hbClcbiAgICAtPiAndFxuICAgIC0+ICdmaW5hbFxuXG4gICgqKiBHZW5lcmljIGRlZmluaXRpb25zIG9mIGNvbnRhaW5lciBvcGVyYXRpb25zIGluIHRlcm1zIG9mIFtpdGVyXSBhbmQgW2xlbmd0aF0uICopXG4gIHZhbCBpc19lbXB0eSA6IGl0ZXI6KCd0LCAnYSkgaXRlciAtPiAndCAtPiBib29sXG5cbiAgdmFsIGV4aXN0cyA6IGl0ZXI6KCd0LCAnYSkgaXRlciAtPiAndCAtPiBmOignYSAtPiBib29sKSAtPiBib29sXG4gIHZhbCBmb3JfYWxsIDogaXRlcjooJ3QsICdhKSBpdGVyIC0+ICd0IC0+IGY6KCdhIC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGZpbmQgOiBpdGVyOigndCwgJ2EpIGl0ZXIgLT4gJ3QgLT4gZjooJ2EgLT4gYm9vbCkgLT4gJ2Egb3B0aW9uXG4gIHZhbCBmaW5kX21hcCA6IGl0ZXI6KCd0LCAnYSkgaXRlciAtPiAndCAtPiBmOignYSAtPiAnYiBvcHRpb24pIC0+ICdiIG9wdGlvblxuICB2YWwgdG9fYXJyYXkgOiBsZW5ndGg6J3QgbGVuZ3RoIC0+IGl0ZXI6KCd0LCAnYSkgaXRlciAtPiAndCAtPiAnYSBhcnJheVxuXG4gICgqKiBUaGUgaWRpb20gZm9yIHVzaW5nIFtDb250YWluZXIuTWFrZV0gaXMgdG8gYmluZCB0aGUgcmVzdWx0aW5nIG1vZHVsZSBhbmQgdG9cbiAgICAgIGV4cGxpY2l0bHkgaW1wb3J0IGVhY2ggb2YgdGhlIGZ1bmN0aW9ucyB0aGF0IG9uZSB3YW50czpcblxuICAgICAge1tcbiAgICAgICAgbW9kdWxlIEMgPSBDb250YWluZXIuTWFrZSAoc3RydWN0IC4uLiBlbmQpXG4gICAgICAgIGxldCBjb3VudCAgICA9IEMuY291bnRcbiAgICAgICAgbGV0IGV4aXN0cyAgID0gQy5leGlzdHNcbiAgICAgICAgbGV0IGZpbmQgICAgID0gQy5maW5kXG4gICAgICAgICgqIC4uLiAqKVxuICAgICAgXX1cblxuICAgICAgVGhpcyBpcyBwcmVmZXJhYmxlIHRvOlxuXG4gICAgICB7W1xuICAgICAgICBpbmNsdWRlIENvbnRhaW5lci5NYWtlIChzdHJ1Y3QgLi4uIGVuZClcbiAgICAgIF19XG5cbiAgICAgIGJlY2F1c2UgdGhlIFtpbmNsdWRlXSBtYWtlcyBpdCB0b28gZWFzeSB0byBzaGFkb3cgc3BlY2lhbGl6ZWQgaW1wbGVtZW50YXRpb25zIG9mXG4gICAgICBjb250YWluZXIgZnVuY3Rpb25zIChbbGVuZ3RoXSBiZWluZyBhIGNvbW1vbiBvbmUpLlxuXG4gICAgICBbQ29udGFpbmVyLk1ha2UwXSBpcyBsaWtlIFtDb250YWluZXIuTWFrZV0sIGJ1dCBmb3IgbW9ub21vcnBoaWMgY29udGFpbmVycyBsaWtlXG4gICAgICBbc3RyaW5nXS4gKilcbiAgbW9kdWxlIE1ha2UgKFQgOiBNYWtlX2FyZykgOiBTMSB3aXRoIHR5cGUgJ2EgdCA6PSAnYSBULnRcblxuICBtb2R1bGUgTWFrZTAgKFQgOiBNYWtlMF9hcmcpIDogUzAgd2l0aCB0eXBlIHQgOj0gVC50IGFuZCB0eXBlIGVsdCA6PSBULkVsdC50XG5cbiAgbW9kdWxlIE1ha2VfZ2VuIChUIDogTWFrZV9nZW5fYXJnKSA6XG4gICAgR2VuZXJpYyB3aXRoIHR5cGUgJ2EgdCA6PSAnYSBULnQgYW5kIHR5cGUgJ2EgZWx0IDo9ICdhIFQuZWx0XG5lbmRcbiIsIigqIFNwbGl0IG9mZiB0byBhdm9pZCBhIGN5Y2xpYyBkZXBlbmRlbmN5IHdpdGggW09yX2Vycm9yXS4gKilcblxub3BlbiEgSW1wb3J0XG5cbmxldCBpbnZhbGlkX2FyZ2YgPSBQcmludGYuaW52YWxpZF9hcmdmXG5cbmxldCBzbG93X2NoZWNrX3Bvc19sZW5fZXhuIH5wb3MgfmxlbiB+dG90YWxfbGVuZ3RoID1cbiAgaWYgcG9zIDwgMCB0aGVuIGludmFsaWRfYXJnZiBcIk5lZ2F0aXZlIHBvc2l0aW9uOiAlZFwiIHBvcyAoKTtcbiAgaWYgbGVuIDwgMCB0aGVuIGludmFsaWRfYXJnZiBcIk5lZ2F0aXZlIGxlbmd0aDogJWRcIiBsZW4gKCk7XG4gICgqIFdlIHVzZSBbcG9zID4gdG90YWxfbGVuZ3RoIC0gbGVuXSByYXRoZXIgdGhhbiBbcG9zICsgbGVuID4gdG90YWxfbGVuZ3RoXSB0byBhdm9pZCB0aGVcbiAgICAgcG9zc2liaWxpdHkgb2Ygb3ZlcmZsb3cuICopXG4gIGlmIHBvcyA+IHRvdGFsX2xlbmd0aCAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnZiBcInBvcyArIGxlbiBwYXN0IGVuZDogJWQgKyAlZCA+ICVkXCIgcG9zIGxlbiB0b3RhbF9sZW5ndGggKClcbltAQGNvbGRdIFtAQGlubGluZSBuZXZlcl0gW0BAbG9jYWwgbmV2ZXJdIFtAQHNwZWNpYWxpc2UgbmV2ZXJdXG47O1xuXG5sZXQgY2hlY2tfcG9zX2xlbl9leG4gfnBvcyB+bGVuIH50b3RhbF9sZW5ndGggPVxuICAoKiBUaGlzIGlzIGJldHRlciB0aGFuIFtzbG93X2NoZWNrX3Bvc19sZW5fZXhuXSBmb3IgdHdvIHJlYXNvbnM6XG5cbiAgICAgLSBtdWNoIGxlc3MgaW5saW5lZCBjb2RlXG4gICAgIC0gb25seSBvbmUgY29uZGl0aW9uYWwganVtcFxuXG4gICAgIFRoZSByZWFzb24gaXQgd29ya3MgaXMgdGhhdCBjaGVja2luZyBbPCAwXSBpcyB0ZXN0aW5nIHRoZSBoaWdoZXN0IG9yZGVyIGJpdCwgc29cbiAgICAgW2EgPCAwIHx8IGIgPCAwXSBpcyB0aGUgc2FtZSBhcyBbYSBsb3IgYiA8IDBdLlxuXG4gICAgIFtwb3MgKyBsZW5dIGNhbiBvdmVyZmxvdywgc28gW3BvcyA+IHRvdGFsX2xlbmd0aCAtIGxlbl0gaXMgbm90IGVxdWl2YWxlbnQgdG9cbiAgICAgW3RvdGFsX2xlbmd0aCAtIGxlbiAtIHBvcyA8IDBdLCB3ZSBuZWVkIHRvIHRlc3QgZm9yIFtwb3MgKyBsZW5dIG92ZXJmbG93IGFzXG4gICAgIHdlbGwuICopXG4gIGxldCBzdG9wID0gcG9zICsgbGVuIGluXG4gIGlmIHBvcyBsb3IgbGVuIGxvciBzdG9wIGxvciAodG90YWxfbGVuZ3RoIC0gc3RvcCkgPCAwXG4gIHRoZW4gc2xvd19jaGVja19wb3NfbGVuX2V4biB+cG9zIH5sZW4gfnRvdGFsX2xlbmd0aFxuOztcblxubGV0IGdldF9wb3NfbGVuX2V4biA/KHBvcyA9IDApID9sZW4gKCkgfnRvdGFsX2xlbmd0aCA9XG4gIGxldCBsZW4gPVxuICAgIG1hdGNoIGxlbiB3aXRoXG4gICAgfCBTb21lIGkgLT4gaVxuICAgIHwgTm9uZSAtPiB0b3RhbF9sZW5ndGggLSBwb3NcbiAgaW5cbiAgY2hlY2tfcG9zX2xlbl9leG4gfnBvcyB+bGVuIH50b3RhbF9sZW5ndGg7XG4gIHBvcywgbGVuXG47O1xuXG5tb2R1bGUgUHJpdmF0ZSA9IHN0cnVjdFxuICBsZXQgc2xvd19jaGVja19wb3NfbGVuX2V4biA9IHNsb3dfY2hlY2tfcG9zX2xlbl9leG5cbmVuZFxuIiwiXG5tb2R1bGUgQXJyYXkgPSBBcnJheTBcblxubW9kdWxlIFJlcHIgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB7IHN0IDogaW50IGFycmF5XG4gICAgOyBtdXRhYmxlIGlkeCA6IGludFxuICAgIH1cblxuICBsZXQgb2Zfc3RhdGUgOiBDYW1sLlJhbmRvbS5TdGF0ZS50IC0+IHQgPSBDYW1sLk9iai5tYWdpY1xuZW5kXG5cbmxldCBhc3NpZ24gdDEgdDIgPVxuICBsZXQgdDEgPSBSZXByLm9mX3N0YXRlIChMYXp5LmZvcmNlIHQxKSBpblxuICBsZXQgdDIgPSBSZXByLm9mX3N0YXRlIChMYXp5LmZvcmNlIHQyKSBpblxuICBBcnJheS5ibGl0IH5zcmM6dDIuc3QgfnNyY19wb3M6MCB+ZHN0OnQxLnN0IH5kc3RfcG9zOjAgfmxlbjooQXJyYXkubGVuZ3RoIHQxLnN0KTtcbiAgdDEuaWR4IDwtIHQyLmlkeFxuXG5sZXQgbWFrZV9kZWZhdWx0IGRlZmF1bHQgPSBkZWZhdWx0XG5cbmxldFtAaW5saW5lIGFsd2F5c10gZ2V0X3N0YXRlIHN0YXRlID0gc3RhdGVcbiIsIm9wZW4hIEltcG9ydFxubW9kdWxlIEludCA9IEludDBcbm1vZHVsZSBDaGFyID0gQ2hhcjBcblxuKCogVW5mb3J0dW5hdGVseSwgYmVjYXVzZSB0aGUgc3RhbmRhcmQgbGlicmFyeSBkb2VzIG5vdCBleHBvc2VcbiAgIFtDYW1sLlJhbmRvbS5TdGF0ZS5kZWZhdWx0XSwgd2UgaGF2ZSB0byBjb25zdHJ1Y3Qgb3VyIG93bi4gIFdlIHRoZW4gYnVpbGQgdGhlXG4gICBbQ2FtbC5SYW5kb20uaW50XSwgW0NhbWwuUmFuZG9tLmJvb2xdIGZ1bmN0aW9ucyBhbmQgZnJpZW5kcyB1c2luZyB0aGF0IGRlZmF1bHQgc3RhdGUgaW5cbiAgIGV4YWN0bHkgdGhlIHNhbWUgd2F5IGFzIHRoZSBzdGFuZGFyZCBsaWJyYXJ5LlxuXG4gICBPbmUgb3RoZXIgdHJpY2tpbmVzcyBpcyB0aGF0IHdlIG5lZWQgYWNjZXNzIHRvIHRoZSB1bmV4cG9zZWQgW0NhbWwuUmFuZG9tLlN0YXRlLmFzc2lnbl1cbiAgIGZ1bmN0aW9uLCB3aGljaCBhY2Nlc3NlcyB0aGUgdW5leHBvc2VkIHN0YXRlIHJlcHJlc2VudGF0aW9uLiAgU28sIHdlIGNvcHkgdGhlXG4gICBbU3RhdGUucmVwcl0gdHlwZSBkZWZpbml0aW9uIGFuZCBbYXNzaWduXSBmdW5jdGlvbiB0byBoZXJlIGZyb20gdGhlIHN0YW5kYXJkIGxpYnJhcnksXG4gICBhbmQgdXNlIFtPYmoubWFnaWNdIHRvIGdldCBhY2Nlc3MgdG8gdGhlIHVuZGVybHlpbmcgaW1wbGVtZW50YXRpb24uICopXG5cbigqIFJlZ3Jlc3Npb24gdGVzdHMgb3VnaHQgdG8gYmUgZGV0ZXJtaW5pc3RpYyBiZWNhdXNlIHRoYXQgd2F5IGFueW9uZSB3aG8gYnJlYWtzIHRoZSB0ZXN0XG4gICBrbm93cyB0aGF0IGl0J3MgdGhlaXIgY29kZSB0aGF0IGJyb2tlIHRoZSB0ZXN0LiAgSWYgdGVzdHMgYXJlIG5vbmRldGVybWluaXN0aWMsIGEgdGVzdFxuICAgZmFpbHVyZSBtYXkgaW5zdGVhZCBoYXBwZW4gYmVjYXVzZSB0aGUgdGVzdCBydW5uZXIgZ290IHVubHVja3kgYW5kIHVuY292ZXJlZCBhblxuICAgZXhpc3RpbmcgYnVnIGluIHRoZSBjb2RlIHN1cHBvc2VkbHkgYmVpbmcgXCJwcm90ZWN0ZWRcIiBieSB0aGUgdGVzdCBpbiBxdWVzdGlvbi4gKilcbmxldCBmb3JiaWRfbm9uZGV0ZXJtaW5pc21faW5fdGVzdHMgfmFsbG93X2luX3Rlc3RzID1cbiAgaWYgYW1fdGVzdGluZ1xuICB0aGVuIChcbiAgICBtYXRjaCBhbGxvd19pbl90ZXN0cyB3aXRoXG4gICAgfCBTb21lIHRydWUgLT4gKClcbiAgICB8IE5vbmUgfCBTb21lIGZhbHNlIC0+XG4gICAgICBmYWlsd2l0aFxuICAgICAgICBcImluaXRpYWxpemluZyBSYW5kb20gd2l0aCBhIG5vbmRldGVybWluaXN0aWMgc2VlZCBpcyBmb3JiaWRkZW4gaW4gaW5saW5lIHRlc3RzXCIpXG47O1xuXG5leHRlcm5hbCByYW5kb21fc2VlZCA6IHVuaXQgLT4gaW50IGFycmF5ID0gXCJjYW1sX3N5c19yYW5kb21fc2VlZFwiXG5cbmxldCByYW5kb21fc2VlZCA/YWxsb3dfaW5fdGVzdHMgKCkgPVxuICBmb3JiaWRfbm9uZGV0ZXJtaW5pc21faW5fdGVzdHMgfmFsbG93X2luX3Rlc3RzO1xuICByYW5kb21fc2VlZCAoKVxuOztcblxubW9kdWxlIFN0YXRlID0gc3RydWN0XG4gICgqIFdlIGFsbG93IGxhemluZXNzIG9ubHkgZm9yIHRoZSBkZWZpbml0aW9uIG9mIFtkZWZhdWx0XSwgYmVsb3csIHdoaWNoIG1heSBsYXppbHkgY2FsbFxuICAgICBbbWFrZV9zZWxmX2luaXRdLiBGb3IgYWxsIG90aGVyIHB1cnBvc2VzLCB3ZSBjcmVhdGUgYW5kIHVzZSBbdF0gZWFnZXJseS4gKilcbiAgdHlwZSB0ID0gQ2FtbC5SYW5kb20uU3RhdGUudCBMYXp5LnRcblxuICBsZXQgYml0cyB0ID0gQ2FtbC5SYW5kb20uU3RhdGUuYml0cyAoTGF6eS5mb3JjZSB0KVxuICBsZXQgYm9vbCB0ID0gQ2FtbC5SYW5kb20uU3RhdGUuYm9vbCAoTGF6eS5mb3JjZSB0KVxuICBsZXQgaW50IHQgeCA9IENhbWwuUmFuZG9tLlN0YXRlLmludCAoTGF6eS5mb3JjZSB0KSB4XG4gIGxldCBpbnQzMiB0IHggPSBDYW1sLlJhbmRvbS5TdGF0ZS5pbnQzMiAoTGF6eS5mb3JjZSB0KSB4XG4gIGxldCBpbnQ2NCB0IHggPSBDYW1sLlJhbmRvbS5TdGF0ZS5pbnQ2NCAoTGF6eS5mb3JjZSB0KSB4XG4gIGxldCBuYXRpdmVpbnQgdCB4ID0gQ2FtbC5SYW5kb20uU3RhdGUubmF0aXZlaW50IChMYXp5LmZvcmNlIHQpIHhcbiAgbGV0IG1ha2Ugc2VlZCA9IExhenkuZnJvbV92YWwgKENhbWwuUmFuZG9tLlN0YXRlLm1ha2Ugc2VlZClcbiAgbGV0IGNvcHkgdCA9IExhenkuZnJvbV92YWwgKENhbWwuUmFuZG9tLlN0YXRlLmNvcHkgKExhenkuZm9yY2UgdCkpXG4gIGxldCBjaGFyIHQgPSBpbnQgdCAyNTYgfD4gQ2hhci51bnNhZmVfb2ZfaW50XG4gIGxldCBhc2NpaSB0ID0gaW50IHQgMTI4IHw+IENoYXIudW5zYWZlX29mX2ludFxuXG4gIGxldCBtYWtlX3NlbGZfaW5pdCA/YWxsb3dfaW5fdGVzdHMgKCkgPVxuICAgIGZvcmJpZF9ub25kZXRlcm1pbmlzbV9pbl90ZXN0cyB+YWxsb3dfaW5fdGVzdHM7XG4gICAgTGF6eS5mcm9tX3ZhbCAoQ2FtbC5SYW5kb20uU3RhdGUubWFrZV9zZWxmX2luaXQgKCkpXG4gIDs7XG5cbiAgbGV0IGFzc2lnbiA9IFJhbmRvbV9yZXByLmFzc2lnblxuXG4gIGxldCBmdWxsX2luaXQgdCBzZWVkID0gYXNzaWduIHQgKG1ha2Ugc2VlZClcblxuICBsZXQgZGVmYXVsdCA9XG4gICAgaWYgYW1fdGVzdGluZ1xuICAgIHRoZW4gKFxuICAgICAgKCogV2UgZGVmaW5lIEJhc2UncyBkZWZhdWx0IHJhbmRvbSBzdGF0ZSBhcyBhIGNvcHkgb2YgT0NhbWwncyBkZWZhdWx0IHJhbmRvbSBzdGF0ZS5cbiAgICAgICAgIFRoaXMgbWVhbnMgdGhhdCBwcm9ncmFtcyB0aGF0IHVzZSBCYXNlLlJhbmRvbSB3aWxsIHNlZSB0aGUgc2FtZSBzZXF1ZW5jZSBvZlxuICAgICAgICAgcmFuZG9tIGJpdHMgYXMgaWYgdGhleSBoYWQgdXNlZCBDYW1sLlJhbmRvbS4gSG93ZXZlciwgYmVjYXVzZSBbZ2V0X3N0YXRlXSByZXR1cm5zXG4gICAgICAgICBhIGNvcHksIEJhc2UuUmFuZG9tIGFuZCBPQ2FtbC5SYW5kb20gYXJlIG5vdCB1c2luZyB0aGUgc2FtZSBzdGF0ZS4gSWYgYSBwcm9ncmFtXG4gICAgICAgICB1c2VkIGJvdGgsIGVhY2ggb2YgdGhlbSB3b3VsZCBnbyB0aHJvdWdoIHRoZSBzYW1lIHNlcXVlbmNlIG9mIHJhbmRvbSBiaXRzLiBUb1xuICAgICAgICAgYXZvaWQgdGhhdCwgd2UgcmVzZXQgT0NhbWwncyByYW5kb20gc3RhdGUgdG8gYSBkaWZmZXJlbnQgc2VlZCwgZ2l2aW5nIGl0IGFcbiAgICAgICAgIGRpZmZlcmVudCBzZXF1ZW5jZS4gKilcbiAgICAgIGxldCB0ID0gQ2FtbC5SYW5kb20uZ2V0X3N0YXRlICgpIGluXG4gICAgICBDYW1sLlJhbmRvbS5pbml0IDEzNztcbiAgICAgIExhenkuZnJvbV92YWwgdClcbiAgICBlbHNlXG4gICAgICBsYXp5XG4gICAgICAgICgqIE91dHNpZGUgb2YgdGVzdHMsIHdlIGluaXRpYWxpemUgcmFuZG9tIHN0YXRlIG5vbmRldGVybWluaXN0aWNhbGx5IGFuZCBsYXppbHkuXG4gICAgICAgICAgIFdlIGZvcmNlIHRoZSByYW5kb20gaW5pdGlhbGl6YXRpb24gdG8gYmUgbGF6eSBzbyB0aGF0IHdlIGRvIG5vdCBwYXkgYW55IGNvc3RcbiAgICAgICAgICAgZm9yIGl0IGluIHByb2dyYW1zIHRoYXQgZG8gbm90IHVzZSByYW5kb21uZXNzLiAqKVxuICAgICAgICAoTGF6eS5mb3JjZSAobWFrZV9zZWxmX2luaXQgKCkpKVxuICA7O1xuXG4gIGxldCBpbnRfb25fNjRiaXRzIHQgYm91bmQgPVxuICAgIGlmIGJvdW5kIDw9IDB4M0ZGRkZGRkYgKCogKDEgbHNsIDMwKSAtIDEgKilcbiAgICB0aGVuIGludCB0IGJvdW5kXG4gICAgZWxzZSBDYW1sLkludDY0LnRvX2ludCAoaW50NjQgdCAoQ2FtbC5JbnQ2NC5vZl9pbnQgYm91bmQpKVxuICA7O1xuXG4gIGxldCBpbnRfb25fMzJiaXRzIHQgYm91bmQgPVxuICAgICgqIE5vdCBhbHdheXMgdHJ1ZSB3aXRoIHRoZSBKYXZhU2NyaXB0IGJhY2tlbmQuICopXG4gICAgaWYgYm91bmQgPD0gMHgzRkZGRkZGRiAoKiAoMSBsc2wgMzApIC0gMSAqKVxuICAgIHRoZW4gaW50IHQgYm91bmRcbiAgICBlbHNlIENhbWwuSW50MzIudG9faW50IChpbnQzMiB0IChDYW1sLkludDMyLm9mX2ludCBib3VuZCkpXG4gIDs7XG5cbiAgbGV0IGludCA9XG4gICAgbWF0Y2ggV29yZF9zaXplLndvcmRfc2l6ZSB3aXRoXG4gICAgfCBXNjQgLT4gaW50X29uXzY0Yml0c1xuICAgIHwgVzMyIC0+IGludF9vbl8zMmJpdHNcbiAgOztcblxuICBsZXQgZnVsbF9yYW5nZV9pbnQ2NCA9XG4gICAgbGV0IG9wZW4gQ2FtbC5JbnQ2NCBpblxuICAgIGxldCBiaXRzIHN0YXRlID0gb2ZfaW50IChiaXRzIHN0YXRlKSBpblxuICAgIGZ1biBzdGF0ZSAtPlxuICAgICAgbG9neG9yXG4gICAgICAgIChiaXRzIHN0YXRlKVxuICAgICAgICAobG9neG9yIChzaGlmdF9sZWZ0IChiaXRzIHN0YXRlKSAzMCkgKHNoaWZ0X2xlZnQgKGJpdHMgc3RhdGUpIDYwKSlcbiAgOztcblxuICBsZXQgZnVsbF9yYW5nZV9pbnQzMiA9XG4gICAgbGV0IG9wZW4gQ2FtbC5JbnQzMiBpblxuICAgIGxldCBiaXRzIHN0YXRlID0gb2ZfaW50IChiaXRzIHN0YXRlKSBpblxuICAgIGZ1biBzdGF0ZSAtPiBsb2d4b3IgKGJpdHMgc3RhdGUpIChzaGlmdF9sZWZ0IChiaXRzIHN0YXRlKSAzMClcbiAgOztcblxuICBsZXQgZnVsbF9yYW5nZV9pbnRfb25fNjRiaXRzIHN0YXRlID0gQ2FtbC5JbnQ2NC50b19pbnQgKGZ1bGxfcmFuZ2VfaW50NjQgc3RhdGUpXG4gIGxldCBmdWxsX3JhbmdlX2ludF9vbl8zMmJpdHMgc3RhdGUgPSBDYW1sLkludDMyLnRvX2ludCAoZnVsbF9yYW5nZV9pbnQzMiBzdGF0ZSlcblxuICBsZXQgZnVsbF9yYW5nZV9pbnQgPVxuICAgIG1hdGNoIFdvcmRfc2l6ZS53b3JkX3NpemUgd2l0aFxuICAgIHwgVzY0IC0+IGZ1bGxfcmFuZ2VfaW50X29uXzY0Yml0c1xuICAgIHwgVzMyIC0+IGZ1bGxfcmFuZ2VfaW50X29uXzMyYml0c1xuICA7O1xuXG4gIGxldCBmdWxsX3JhbmdlX25hdGl2ZWludF9vbl82NGJpdHMgc3RhdGUgPVxuICAgIENhbWwuSW50NjQudG9fbmF0aXZlaW50IChmdWxsX3JhbmdlX2ludDY0IHN0YXRlKVxuICA7O1xuXG4gIGxldCBmdWxsX3JhbmdlX25hdGl2ZWludF9vbl8zMmJpdHMgc3RhdGUgPVxuICAgIENhbWwuTmF0aXZlaW50Lm9mX2ludDMyIChmdWxsX3JhbmdlX2ludDMyIHN0YXRlKVxuICA7O1xuXG4gIGxldCBmdWxsX3JhbmdlX25hdGl2ZWludCA9XG4gICAgbWF0Y2ggV29yZF9zaXplLndvcmRfc2l6ZSB3aXRoXG4gICAgfCBXNjQgLT4gZnVsbF9yYW5nZV9uYXRpdmVpbnRfb25fNjRiaXRzXG4gICAgfCBXMzIgLT4gZnVsbF9yYW5nZV9uYXRpdmVpbnRfb25fMzJiaXRzXG4gIDs7XG5cbiAgbGV0IHJhaXNlX2Nyb3NzZWRfYm91bmRzIG5hbWUgbG93ZXJfYm91bmQgdXBwZXJfYm91bmQgc3RyaW5nX29mX2JvdW5kID1cbiAgICBQcmludGYuZmFpbHdpdGhmXG4gICAgICBcIlJhbmRvbS4lczogY3Jvc3NlZCBib3VuZHMgWyVzID4gJXNdXCJcbiAgICAgIG5hbWVcbiAgICAgIChzdHJpbmdfb2ZfYm91bmQgbG93ZXJfYm91bmQpXG4gICAgICAoc3RyaW5nX29mX2JvdW5kIHVwcGVyX2JvdW5kKVxuICAgICAgKClcbiAgW0BAY29sZF0gW0BAaW5saW5lIG5ldmVyXSBbQEBsb2NhbCBuZXZlcl0gW0BAc3BlY2lhbGlzZSBuZXZlcl1cbiAgOztcblxuICBsZXQgaW50X2luY2wgPVxuICAgIGxldCByZWMgaW5fcmFuZ2Ugc3RhdGUgbG8gaGkgPVxuICAgICAgbGV0IGludCA9IGZ1bGxfcmFuZ2VfaW50IHN0YXRlIGluXG4gICAgICBpZiBpbnQgPj0gbG8gJiYgaW50IDw9IGhpIHRoZW4gaW50IGVsc2UgaW5fcmFuZ2Ugc3RhdGUgbG8gaGlcbiAgICBpblxuICAgIGZ1biBzdGF0ZSBsbyBoaSAtPlxuICAgICAgaWYgbG8gPiBoaSB0aGVuIHJhaXNlX2Nyb3NzZWRfYm91bmRzIFwiaW50XCIgbG8gaGkgSW50LnRvX3N0cmluZztcbiAgICAgIGxldCBkaWZmID0gaGkgLSBsbyBpblxuICAgICAgaWYgZGlmZiA9IEludC5tYXhfdmFsdWVcbiAgICAgIHRoZW4gbG8gKyAoZnVsbF9yYW5nZV9pbnQgc3RhdGUgbGFuZCBJbnQubWF4X3ZhbHVlKVxuICAgICAgZWxzZSBpZiBkaWZmID49IDBcbiAgICAgIHRoZW4gbG8gKyBpbnQgc3RhdGUgKEludC5zdWNjIGRpZmYpXG4gICAgICBlbHNlIGluX3JhbmdlIHN0YXRlIGxvIGhpXG4gIDs7XG5cbiAgbGV0IGludDMyX2luY2wgPVxuICAgIGxldCBvcGVuIEludDMyX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBpblxuICAgIGxldCByZWMgaW5fcmFuZ2Ugc3RhdGUgbG8gaGkgPVxuICAgICAgbGV0IGludCA9IGZ1bGxfcmFuZ2VfaW50MzIgc3RhdGUgaW5cbiAgICAgIGlmIGludCA+PSBsbyAmJiBpbnQgPD0gaGkgdGhlbiBpbnQgZWxzZSBpbl9yYW5nZSBzdGF0ZSBsbyBoaVxuICAgIGluXG4gICAgbGV0IG9wZW4gQ2FtbC5JbnQzMiBpblxuICAgIGZ1biBzdGF0ZSBsbyBoaSAtPlxuICAgICAgaWYgbG8gPiBoaSB0aGVuIHJhaXNlX2Nyb3NzZWRfYm91bmRzIFwiaW50MzJcIiBsbyBoaSB0b19zdHJpbmc7XG4gICAgICBsZXQgZGlmZiA9IHN1YiBoaSBsbyBpblxuICAgICAgaWYgZGlmZiA9IG1heF9pbnRcbiAgICAgIHRoZW4gYWRkIGxvIChsb2dhbmQgKGZ1bGxfcmFuZ2VfaW50MzIgc3RhdGUpIG1heF9pbnQpXG4gICAgICBlbHNlIGlmIGRpZmYgPj0gMGxcbiAgICAgIHRoZW4gYWRkIGxvIChpbnQzMiBzdGF0ZSAoc3VjYyBkaWZmKSlcbiAgICAgIGVsc2UgaW5fcmFuZ2Ugc3RhdGUgbG8gaGlcbiAgOztcblxuICBsZXQgbmF0aXZlaW50X2luY2wgPVxuICAgIGxldCBvcGVuIE5hdGl2ZWludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgaW5cbiAgICBsZXQgcmVjIGluX3JhbmdlIHN0YXRlIGxvIGhpID1cbiAgICAgIGxldCBpbnQgPSBmdWxsX3JhbmdlX25hdGl2ZWludCBzdGF0ZSBpblxuICAgICAgaWYgaW50ID49IGxvICYmIGludCA8PSBoaSB0aGVuIGludCBlbHNlIGluX3JhbmdlIHN0YXRlIGxvIGhpXG4gICAgaW5cbiAgICBsZXQgb3BlbiBDYW1sLk5hdGl2ZWludCBpblxuICAgIGZ1biBzdGF0ZSBsbyBoaSAtPlxuICAgICAgaWYgbG8gPiBoaSB0aGVuIHJhaXNlX2Nyb3NzZWRfYm91bmRzIFwibmF0aXZlaW50XCIgbG8gaGkgdG9fc3RyaW5nO1xuICAgICAgbGV0IGRpZmYgPSBzdWIgaGkgbG8gaW5cbiAgICAgIGlmIGRpZmYgPSBtYXhfaW50XG4gICAgICB0aGVuIGFkZCBsbyAobG9nYW5kIChmdWxsX3JhbmdlX25hdGl2ZWludCBzdGF0ZSkgbWF4X2ludClcbiAgICAgIGVsc2UgaWYgZGlmZiA+PSAwblxuICAgICAgdGhlbiBhZGQgbG8gKG5hdGl2ZWludCBzdGF0ZSAoc3VjYyBkaWZmKSlcbiAgICAgIGVsc2UgaW5fcmFuZ2Ugc3RhdGUgbG8gaGlcbiAgOztcblxuICBsZXQgaW50NjRfaW5jbCA9XG4gICAgbGV0IG9wZW4gSW50NjRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGluXG4gICAgbGV0IHJlYyBpbl9yYW5nZSBzdGF0ZSBsbyBoaSA9XG4gICAgICBsZXQgaW50ID0gZnVsbF9yYW5nZV9pbnQ2NCBzdGF0ZSBpblxuICAgICAgaWYgaW50ID49IGxvICYmIGludCA8PSBoaSB0aGVuIGludCBlbHNlIGluX3JhbmdlIHN0YXRlIGxvIGhpXG4gICAgaW5cbiAgICBsZXQgb3BlbiBDYW1sLkludDY0IGluXG4gICAgZnVuIHN0YXRlIGxvIGhpIC0+XG4gICAgICBpZiBsbyA+IGhpIHRoZW4gcmFpc2VfY3Jvc3NlZF9ib3VuZHMgXCJpbnQ2NFwiIGxvIGhpIHRvX3N0cmluZztcbiAgICAgIGxldCBkaWZmID0gc3ViIGhpIGxvIGluXG4gICAgICBpZiBkaWZmID0gbWF4X2ludFxuICAgICAgdGhlbiBhZGQgbG8gKGxvZ2FuZCAoZnVsbF9yYW5nZV9pbnQ2NCBzdGF0ZSkgbWF4X2ludClcbiAgICAgIGVsc2UgaWYgZGlmZiA+PSAwTFxuICAgICAgdGhlbiBhZGQgbG8gKGludDY0IHN0YXRlIChzdWNjIGRpZmYpKVxuICAgICAgZWxzZSBpbl9yYW5nZSBzdGF0ZSBsbyBoaVxuICA7O1xuXG4gICgqIFJldHVybiBhIHVuaWZvcm1seSByYW5kb20gZmxvYXQgaW4gWzAsIDEpLiAqKVxuICBsZXQgcmVjIHJhd2Zsb2F0IHN0YXRlID1cbiAgICBsZXQgb3BlbiBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgaW5cbiAgICBsZXQgc2NhbGUgPSAweDFwLTMwIGluXG4gICAgKCogMl4tMzAgKilcbiAgICBsZXQgcjEgPSBDYW1sLmZsb2F0X29mX2ludCAoYml0cyBzdGF0ZSkgaW5cbiAgICBsZXQgcjIgPSBDYW1sLmZsb2F0X29mX2ludCAoYml0cyBzdGF0ZSkgaW5cbiAgICBsZXQgcmVzdWx0ID0gKChyMSAqLiBzY2FsZSkgKy4gcjIpICouIHNjYWxlIGluXG4gICAgKCogV2l0aCB2ZXJ5IHNtYWxsIHByb2JhYmlsaXR5LCByZXN1bHQgY2FuIHJvdW5kIHVwIHRvIDEuMCwgc28gaW4gdGhhdCBjYXNlLCB3ZSBqdXN0XG4gICAgICAgdHJ5IGFnYWluLiAqKVxuICAgIGlmIHJlc3VsdCA8IDEuMCB0aGVuIHJlc3VsdCBlbHNlIHJhd2Zsb2F0IHN0YXRlXG4gIDs7XG5cbiAgbGV0IGZsb2F0IHN0YXRlIGhpID0gcmF3ZmxvYXQgc3RhdGUgKi4gaGlcblxuICBsZXQgZmxvYXRfcmFuZ2Ugc3RhdGUgbG8gaGkgPVxuICAgIGxldCBvcGVuIEZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBpblxuICAgIGlmIGxvID4gaGkgdGhlbiByYWlzZV9jcm9zc2VkX2JvdW5kcyBcImZsb2F0XCIgbG8gaGkgQ2FtbC5zdHJpbmdfb2ZfZmxvYXQ7XG4gICAgbG8gKy4gZmxvYXQgc3RhdGUgKGhpIC0uIGxvKVxuICA7O1xuZW5kXG5cbmxldCBkZWZhdWx0ID0gUmFuZG9tX3JlcHIubWFrZV9kZWZhdWx0IFN0YXRlLmRlZmF1bHRcblxubGV0IGJpdHMgKCkgPSBTdGF0ZS5iaXRzIChSYW5kb21fcmVwci5nZXRfc3RhdGUgZGVmYXVsdClcbmxldCBpbnQgeCA9IFN0YXRlLmludCAoUmFuZG9tX3JlcHIuZ2V0X3N0YXRlIGRlZmF1bHQpIHhcbmxldCBpbnQzMiB4ID0gU3RhdGUuaW50MzIgKFJhbmRvbV9yZXByLmdldF9zdGF0ZSBkZWZhdWx0KSB4XG5sZXQgbmF0aXZlaW50IHggPSBTdGF0ZS5uYXRpdmVpbnQgKFJhbmRvbV9yZXByLmdldF9zdGF0ZSBkZWZhdWx0KSB4XG5sZXQgaW50NjQgeCA9IFN0YXRlLmludDY0IChSYW5kb21fcmVwci5nZXRfc3RhdGUgZGVmYXVsdCkgeFxubGV0IGZsb2F0IHggPSBTdGF0ZS5mbG9hdCAoUmFuZG9tX3JlcHIuZ2V0X3N0YXRlIGRlZmF1bHQpIHhcbmxldCBpbnRfaW5jbCB4IHkgPSBTdGF0ZS5pbnRfaW5jbCAoUmFuZG9tX3JlcHIuZ2V0X3N0YXRlIGRlZmF1bHQpIHggeVxubGV0IGludDMyX2luY2wgeCB5ID0gU3RhdGUuaW50MzJfaW5jbCAoUmFuZG9tX3JlcHIuZ2V0X3N0YXRlIGRlZmF1bHQpIHggeVxubGV0IG5hdGl2ZWludF9pbmNsIHggeSA9IFN0YXRlLm5hdGl2ZWludF9pbmNsIChSYW5kb21fcmVwci5nZXRfc3RhdGUgZGVmYXVsdCkgeCB5XG5sZXQgaW50NjRfaW5jbCB4IHkgPSBTdGF0ZS5pbnQ2NF9pbmNsIChSYW5kb21fcmVwci5nZXRfc3RhdGUgZGVmYXVsdCkgeCB5XG5sZXQgZmxvYXRfcmFuZ2UgeCB5ID0gU3RhdGUuZmxvYXRfcmFuZ2UgKFJhbmRvbV9yZXByLmdldF9zdGF0ZSBkZWZhdWx0KSB4IHlcbmxldCBib29sICgpID0gU3RhdGUuYm9vbCAoUmFuZG9tX3JlcHIuZ2V0X3N0YXRlIGRlZmF1bHQpXG5sZXQgY2hhciAoKSA9IFN0YXRlLmNoYXIgKFJhbmRvbV9yZXByLmdldF9zdGF0ZSBkZWZhdWx0KVxubGV0IGFzY2lpICgpID0gU3RhdGUuYXNjaWkgKFJhbmRvbV9yZXByLmdldF9zdGF0ZSBkZWZhdWx0KVxubGV0IGZ1bGxfaW5pdCBzZWVkID0gU3RhdGUuZnVsbF9pbml0IChSYW5kb21fcmVwci5nZXRfc3RhdGUgZGVmYXVsdCkgc2VlZFxubGV0IGluaXQgc2VlZCA9IGZ1bGxfaW5pdCBbfCBzZWVkIHxdXG5sZXQgc2VsZl9pbml0ID9hbGxvd19pbl90ZXN0cyAoKSA9IGZ1bGxfaW5pdCAocmFuZG9tX3NlZWQgP2FsbG93X2luX3Rlc3RzICgpKVxubGV0IHNldF9zdGF0ZSBzID0gU3RhdGUuYXNzaWduIChSYW5kb21fcmVwci5nZXRfc3RhdGUgZGVmYXVsdCkgc1xuIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIEFycmF5MFxuXG50eXBlICdhIHQgPSAnYSBhcnJheSBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG5sZXQgY29tcGFyZSA6ICdhLiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSB0IC0+ICdhIHQgLT4gaW50ID0gY29tcGFyZV9hcnJheVxubGV0IHRfb2Zfc2V4cCA6ICdhLiAoU2V4cGxpYjAuU2V4cC50IC0+ICdhKSAtPiBTZXhwbGliMC5TZXhwLnQgLT4gJ2EgdCA9IGFycmF5X29mX3NleHBcbmxldCBzZXhwX29mX3QgOiAnYS4gKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgdCAtPiBTZXhwbGliMC5TZXhwLnQgPSBzZXhwX29mX2FycmF5XG5cbmxldCAodF9zZXhwX2dyYW1tYXIgOiAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCAtPiAnYSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9XG4gIGZ1biBfJ2Ffc2V4cF9ncmFtbWFyIC0+IGFycmF5X3NleHBfZ3JhbW1hciBfJ2Ffc2V4cF9ncmFtbWFyXG47O1xuXG5bQEBAZW5kXVxuXG4oKiBUaGlzIG1vZHVsZSBpbXBsZW1lbnRzIGEgbmV3IGluLXBsYWNlLCBjb25zdGFudCBoZWFwIHNvcnRpbmcgYWxnb3JpdGhtIHRvIHJlcGxhY2UgdGhlXG4gICBvbmUgdXNlZCBieSB0aGUgc3RhbmRhcmQgbGlicmFyaWVzLiAgSXRzIG9ubHkgcHVycG9zZSBpcyB0byBiZSBmYXN0ZXIgKGhvcGVmdWxseVxuICAgc3RyaWN0bHkgZmFzdGVyKSB0aGFuIHRoZSBiYXNlIHNvcnQgYW5kIHN0YWJsZV9zb3J0LlxuXG4gICBBdCBhIGhpZ2ggbGV2ZWwgdGhlIGFsZ29yaXRobSBpczpcbiAgIC0gcGljayB0d28gcGl2b3QgcG9pbnRzIGJ5OlxuICAgLSBwaWNrIDUgYXJiaXRyYXJ5IGVsZW1lbnRzIGZyb20gdGhlIGFycmF5XG4gICAtIHNvcnQgdGhlbSB3aXRoaW4gdGhlIGFycmF5XG4gICAtIHRha2UgdGhlIGVsZW1lbnRzIG9uIGVpdGhlciBzaWRlIG9mIHRoZSBtaWRkbGUgZWxlbWVudCBvZiB0aGUgc29ydCBhcyB0aGUgcGl2b3RzXG4gICAtIHNvcnQgdGhlIGFycmF5IHdpdGg6XG4gICAtIGFsbCBlbGVtZW50cyBsZXNzIHRoYW4gcGl2b3QxIHRvIHRoZSBsZWZ0IChyYW5nZSAxKVxuICAgLSBhbGwgZWxlbWVudHMgPj0gcGl2b3QxIGFuZCA8PSBwaXZvdDIgaW4gdGhlIG1pZGRsZSAocmFuZ2UgMilcbiAgIC0gYWxsIGVsZW1lbnRzID4gcGl2b3QyIHRvIHRoZSByaWdodCAocmFuZ2UgMylcbiAgIC0gaWYgcGl2b3QxIGFuZCBwaXZvdDIgYXJlIGVxdWFsLCB0aGVuIHRoZSBtaWRkbGUgcmFuZ2UgaXMgc29ydGVkLCBzbyBpZ25vcmUgaXRcbiAgIC0gcmVjdXJzZSBpbnRvIHJhbmdlIDEsIDIgKGlmIHBpdm90MSBhbmQgcGl2b3QyIGFyZSB1bmVxdWFsKSwgYW5kIDNcbiAgIC0gZHVyaW5nIHJlY3Vyc2lvbiB0aGVyZSBhcmUgdHdvIGluZmxlY3Rpb24gcG9pbnRzOlxuICAgLSBpZiB0aGUgc2l6ZSBvZiB0aGUgY3VycmVudCByYW5nZSBpcyBzbWFsbCwgdXNlIGluc2VydGlvbiBzb3J0IHRvIHNvcnQgaXRcbiAgIC0gaWYgdGhlIHN0YWNrIGRlcHRoIGlzIGxhcmdlLCBzb3J0IHRoZSByYW5nZSB3aXRoIGhlYXAtc29ydCB0byBhdm9pZCBuXjIgd29yc3QtY2FzZVxuICAgICBiZWhhdmlvclxuXG4gICBTZWUgdGhlIGZvbGxvd2luZyBmb3IgbW9yZSBpbmZvcm1hdGlvbjpcbiAgIC0gXCJEdWFsLVBpdm90IFF1aWNrc29ydFwiIGJ5IFZsYWRpbWlyIFlhcm9zbGF2c2tpeS5cbiAgICAgQXZhaWxhYmxlIGF0XG4gICAgIGh0dHA6Ly93d3cua3JpY2hlLmNvbS5hci9yb290L3Byb2dyYW1taW5nL3NwYWNlVGltZUNvbXBsZXhpdHkvRHVhbFBpdm90UXVpY2tzb3J0LnBkZlxuICAgLSBcIlF1aWNrc29ydCBpcyBPcHRpbWFsXCIgYnkgU2VkZ2V3aWNrIGFuZCBCZW50bGV5LlxuICAgICBTbGlkZXMgYXQgaHR0cDovL3d3dy5jcy5wcmluY2V0b24uZWR1L35ycy90YWxrcy9RdWlja3NvcnRJc09wdGltYWwucGRmXG4gICAtIGh0dHA6Ly93d3cuc29ydGluZy1hbGdvcml0aG1zLmNvbS9xdWljay1zb3J0LTMtd2F5ICopXG5cbm1vZHVsZSBTb3J0ID0gc3RydWN0XG4gICgqIEZvciB0aGUgc2FrZSBvZiBzcGVlZCB3ZSBjb3VsZCB1c2UgdW5zYWZlIGdldC9zZXQgdGhyb3VnaG91dCwgYnV0IHNwZWVkIHRlc3RzIGRvbid0XG4gICAgIHNob3cgYSBzaWduaWZpY2FudCBpbXByb3ZlbWVudC4gKilcbiAgbGV0IGdldCA9IGdldFxuICBsZXQgc2V0ID0gc2V0XG5cbiAgbGV0IHN3YXAgYXJyIGkgaiA9XG4gICAgbGV0IHRtcCA9IGdldCBhcnIgaSBpblxuICAgIHNldCBhcnIgaSAoZ2V0IGFyciBqKTtcbiAgICBzZXQgYXJyIGogdG1wXG4gIDs7XG5cbiAgbW9kdWxlIHR5cGUgU29ydCA9IHNpZ1xuICAgIHZhbCBzb3J0XG4gICAgICA6ICAnYSB0XG4gICAgICAtPiBjb21wYXJlOignYSAtPiAnYSAtPiBpbnQpXG4gICAgICAtPiBsZWZ0OmludCAoKiBsZWZ0bW9zdCBpbmRleCBvZiBzdWItYXJyYXkgdG8gc29ydCAqKVxuICAgICAgLT4gcmlnaHQ6aW50ICgqIHJpZ2h0bW9zdCBpbmRleCBvZiBzdWItYXJyYXkgdG8gc29ydCAqKVxuICAgICAgLT4gdW5pdFxuICBlbmRcblxuICAoKiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0luc2VydGlvbl9zb3J0ICopXG4gIG1vZHVsZSBJbnNlcnRpb25fc29ydCA6IFNvcnQgPSBzdHJ1Y3RcbiAgICBsZXQgc29ydCBhcnIgfmNvbXBhcmUgfmxlZnQgfnJpZ2h0ID1cbiAgICAgICgqIGxvb3AgaW52YXJpYW50OlxuICAgICAgICAgW2Fycl0gaXMgc29ydGVkIGZyb20gW2xlZnRdIHRvIFtwb3MgLSAxXSwgaW5jbHVzaXZlICopXG4gICAgICBmb3IgcG9zID0gbGVmdCArIDEgdG8gcmlnaHQgZG9cbiAgICAgICAgKCogbG9vcCBpbnZhcmlhbnRzOlxuICAgICAgICAgICAxLiAgdGhlIHN1YmFycmF5IGFycltsZWZ0IC4uIGktMV0gaXMgc29ydGVkXG4gICAgICAgICAgIDIuICB0aGUgc3ViYXJyYXkgYXJyW2krMSAuLiBwb3NdIGlzIHNvcnRlZCBhbmQgY29udGFpbnMgb25seSBlbGVtZW50cyA+IHZcbiAgICAgICAgICAgMy4gIGFycltpXSBtYXkgYmUgdGhvdWdodCBvZiBhcyBjb250YWluaW5nIHZcblxuICAgICAgICAgICBOb3RlIHRoYXQgdGhpcyBkb2VzIG5vdCBhbGxvY2F0ZSBhIGNsb3N1cmUsIGJ1dCBpcyBsZWZ0IGluIHRoZSBmb3JcbiAgICAgICAgICAgbG9vcCBmb3IgdGhlIHJlYWRhYmlsaXR5IG9mIHRoZSBkb2N1bWVudGF0aW9uLiAqKVxuICAgICAgICBsZXQgcmVjIGxvb3AgYXJyIH5sZWZ0IH5jb21wYXJlIGkgdiA9XG4gICAgICAgICAgbGV0IGlfbmV4dCA9IGkgLSAxIGluXG4gICAgICAgICAgaWYgaV9uZXh0ID49IGxlZnQgJiYgY29tcGFyZSAoZ2V0IGFyciBpX25leHQpIHYgPiAwXG4gICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICBzZXQgYXJyIGkgKGdldCBhcnIgaV9uZXh0KTtcbiAgICAgICAgICAgIGxvb3AgYXJyIH5sZWZ0IH5jb21wYXJlIGlfbmV4dCB2KVxuICAgICAgICAgIGVsc2UgaVxuICAgICAgICBpblxuICAgICAgICBsZXQgdiA9IGdldCBhcnIgcG9zIGluXG4gICAgICAgIGxldCBmaW5hbF9wb3MgPSBsb29wIGFyciB+bGVmdCB+Y29tcGFyZSBwb3MgdiBpblxuICAgICAgICBzZXQgYXJyIGZpbmFsX3BvcyB2XG4gICAgICBkb25lXG4gICAgOztcbiAgZW5kXG5cbiAgKCogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IZWFwc29ydCAqKVxuICBtb2R1bGUgSGVhcF9zb3J0IDogU29ydCA9IHN0cnVjdFxuICAgICgqIGxvb3AgaW52YXJpYW50OlxuICAgICAgIHJvb3QncyBjaGlsZHJlbiBhcmUgYm90aCBlaXRoZXIgcm9vdHMgb2YgbWF4LWhlYXBzIG9yID4gcmlnaHQgKilcbiAgICBsZXQgcmVjIGhlYXBpZnkgYXJyIH5jb21wYXJlIHJvb3QgfmxlZnQgfnJpZ2h0ID1cbiAgICAgIGxldCByZWxhdGl2ZV9yb290ID0gcm9vdCAtIGxlZnQgaW5cbiAgICAgIGxldCBsZWZ0X2NoaWxkID0gKDIgKiByZWxhdGl2ZV9yb290KSArIGxlZnQgKyAxIGluXG4gICAgICBsZXQgcmlnaHRfY2hpbGQgPSAoMiAqIHJlbGF0aXZlX3Jvb3QpICsgbGVmdCArIDIgaW5cbiAgICAgIGxldCBsYXJnZXN0ID1cbiAgICAgICAgaWYgbGVmdF9jaGlsZCA8PSByaWdodCAmJiBjb21wYXJlIChnZXQgYXJyIGxlZnRfY2hpbGQpIChnZXQgYXJyIHJvb3QpID4gMFxuICAgICAgICB0aGVuIGxlZnRfY2hpbGRcbiAgICAgICAgZWxzZSByb290XG4gICAgICBpblxuICAgICAgbGV0IGxhcmdlc3QgPVxuICAgICAgICBpZiByaWdodF9jaGlsZCA8PSByaWdodCAmJiBjb21wYXJlIChnZXQgYXJyIHJpZ2h0X2NoaWxkKSAoZ2V0IGFyciBsYXJnZXN0KSA+IDBcbiAgICAgICAgdGhlbiByaWdodF9jaGlsZFxuICAgICAgICBlbHNlIGxhcmdlc3RcbiAgICAgIGluXG4gICAgICBpZiBsYXJnZXN0IDw+IHJvb3RcbiAgICAgIHRoZW4gKFxuICAgICAgICBzd2FwIGFyciByb290IGxhcmdlc3Q7XG4gICAgICAgIGhlYXBpZnkgYXJyIH5jb21wYXJlIGxhcmdlc3QgfmxlZnQgfnJpZ2h0KVxuICAgIDs7XG5cbiAgICBsZXQgYnVpbGRfaGVhcCBhcnIgfmNvbXBhcmUgfmxlZnQgfnJpZ2h0ID1cbiAgICAgICgqIEVsZW1lbnRzIGluIHRoZSBzZWNvbmQgaGFsZiBvZiB0aGUgYXJyYXkgYXJlIGFscmVhZHkgaGVhcHMgb2Ygc2l6ZSAxLiAgV2UgbW92ZVxuICAgICAgICAgdGhyb3VnaCB0aGUgZmlyc3QgaGFsZiBvZiB0aGUgYXJyYXkgZnJvbSBiYWNrIHRvIGZyb250IGV4YW1pbmluZyB0aGUgZWxlbWVudCBhdFxuICAgICAgICAgaGFuZCwgYW5kIHRoZSBsZWZ0IGFuZCByaWdodCBjaGlsZHJlbiwgZml4aW5nIHRoZSBoZWFwIHByb3BlcnR5IGFzIHdlIGdvLiAqKVxuICAgICAgZm9yIGkgPSAobGVmdCArIHJpZ2h0KSAvIDIgZG93bnRvIGxlZnQgZG9cbiAgICAgICAgaGVhcGlmeSBhcnIgfmNvbXBhcmUgaSB+bGVmdCB+cmlnaHRcbiAgICAgIGRvbmVcbiAgICA7O1xuXG4gICAgbGV0IHNvcnQgYXJyIH5jb21wYXJlIH5sZWZ0IH5yaWdodCA9XG4gICAgICBidWlsZF9oZWFwIGFyciB+Y29tcGFyZSB+bGVmdCB+cmlnaHQ7XG4gICAgICAoKiBsb29wIGludmFyaWFudHM6XG4gICAgICAgICAxLiAgdGhlIHN1YmFycmF5IGFycltsZWZ0IC4uLiBpXSBpcyBhIG1heC1oZWFwIEhcbiAgICAgICAgIDIuICB0aGUgc3ViYXJyYXkgYXJyW2krMSAuLi4gcmlnaHRdIGlzIHNvcnRlZCAoY2FsbCBpdCBTKVxuICAgICAgICAgMy4gIGV2ZXJ5IGVsZW1lbnQgb2YgSCBpcyBsZXNzIHRoYW4gZXZlcnkgZWxlbWVudCBvZiBTICopXG4gICAgICBmb3IgaSA9IHJpZ2h0IGRvd250byBsZWZ0ICsgMSBkb1xuICAgICAgICBzd2FwIGFyciBsZWZ0IGk7XG4gICAgICAgIGhlYXBpZnkgYXJyIH5jb21wYXJlIGxlZnQgfmxlZnQgfnJpZ2h0OihpIC0gMSlcbiAgICAgIGRvbmVcbiAgICA7O1xuICBlbmRcblxuICAoKiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0ludHJvc29ydCAqKVxuICBtb2R1bGUgSW50cm9fc29ydCA6IHNpZ1xuICAgIGluY2x1ZGUgU29ydFxuXG4gICAgdmFsIGZpdmVfZWxlbWVudF9zb3J0XG4gICAgICA6ICAnYSB0XG4gICAgICAtPiBjb21wYXJlOignYSAtPiAnYSAtPiBpbnQpXG4gICAgICAtPiBpbnRcbiAgICAgIC0+IGludFxuICAgICAgLT4gaW50XG4gICAgICAtPiBpbnRcbiAgICAgIC0+IGludFxuICAgICAgLT4gdW5pdFxuICBlbmQgPSBzdHJ1Y3RcbiAgICBsZXQgZml2ZV9lbGVtZW50X3NvcnQgYXJyIH5jb21wYXJlIG0xIG0yIG0zIG00IG01ID1cbiAgICAgIGxldCBjb21wYXJlX2FuZF9zd2FwIGkgaiA9XG4gICAgICAgIGlmIGNvbXBhcmUgKGdldCBhcnIgaSkgKGdldCBhcnIgaikgPiAwIHRoZW4gc3dhcCBhcnIgaSBqXG4gICAgICBpblxuICAgICAgKCogT3B0aW1hbCA1LWVsZW1lbnQgc29ydGluZyBuZXR3b3JrOlxuXG4gICAgICAgICB7dlxuICAgICAgICAgICAgMS0tby0tLS0tby0tLS0tby0tLS0tLS0tLS0tLS0tMVxuICAgICAgICAgICAgICAgfCAgICAgfCAgICAgfFxuICAgICAgICAgICAgMi0tby0tLS0tfC0tby0tfC0tLS0tby0tby0tLS0tMlxuICAgICAgICAgICAgICAgICAgICAgfCAgfCAgfCAgICAgfCAgfFxuICAgICAgICAgICAgMy0tLS0tLS0tby0tby0tfC0tby0tfC0tby0tLS0tM1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgfCAgfFxuICAgICAgICAgICAgNC0tLS0tby0tLS0tLS0tby0tby0tfC0tLS0tby0tNFxuICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfCAgICAgfFxuICAgICAgICAgICAgNS0tLS0tby0tLS0tLS0tLS0tLS0tby0tLS0tby0tNVxuICAgICAgICAgIHZ9ICopXG4gICAgICBjb21wYXJlX2FuZF9zd2FwIG0xIG0yO1xuICAgICAgY29tcGFyZV9hbmRfc3dhcCBtNCBtNTtcbiAgICAgIGNvbXBhcmVfYW5kX3N3YXAgbTEgbTM7XG4gICAgICBjb21wYXJlX2FuZF9zd2FwIG0yIG0zO1xuICAgICAgY29tcGFyZV9hbmRfc3dhcCBtMSBtNDtcbiAgICAgIGNvbXBhcmVfYW5kX3N3YXAgbTMgbTQ7XG4gICAgICBjb21wYXJlX2FuZF9zd2FwIG0yIG01O1xuICAgICAgY29tcGFyZV9hbmRfc3dhcCBtMiBtMztcbiAgICAgIGNvbXBhcmVfYW5kX3N3YXAgbTQgbTVcbiAgICA7O1xuXG4gICAgKCogY2hvb3NlIHBpdm90cyBmb3IgdGhlIGFycmF5IGJ5IHNvcnRpbmcgNSBlbGVtZW50cyBhbmQgZXhhbWluaW5nIHRoZSBjZW50ZXIgdGhyZWVcbiAgICAgICBlbGVtZW50cy4gIFRoZSBnb2FsIGlzIHRvIGNob29zZSB0d28gcGl2b3RzIHRoYXQgd2lsbCBlaXRoZXI6XG4gICAgICAgLSBicmVhayB0aGUgcmFuZ2UgdXAgaW50byAzIGV2ZW4gcGFydGl0aW9uc1xuICAgICAgICAgb3JcbiAgICAgICAtIGVsaW1pbmF0ZSBhIGNvbW1vbmx5IGFwcGVhcmluZyBlbGVtZW50IGJ5IHNvcnRpbmcgaXQgaW50byB0aGUgY2VudGVyIHBhcnRpdGlvblxuICAgICAgICAgYnkgaXRzZWxmXG4gICAgICAgICBUbyB0aGlzIGVuZCB3ZSBsb29rIGF0IHRoZSBjZW50ZXIgMyBlbGVtZW50cyBvZiB0aGUgNSBhbmQgcmV0dXJuIHBhaXJzIG9mIGVxdWFsXG4gICAgICAgICBlbGVtZW50cyBvciB0aGUgd2lkZXN0IHJhbmdlICopXG4gICAgbGV0IGNob29zZV9waXZvdHMgYXJyIH5jb21wYXJlIH5sZWZ0IH5yaWdodCA9XG4gICAgICBsZXQgc2l4dGggPSAocmlnaHQgLSBsZWZ0KSAvIDYgaW5cbiAgICAgIGxldCBtMSA9IGxlZnQgKyBzaXh0aCBpblxuICAgICAgbGV0IG0yID0gbTEgKyBzaXh0aCBpblxuICAgICAgbGV0IG0zID0gbTIgKyBzaXh0aCBpblxuICAgICAgbGV0IG00ID0gbTMgKyBzaXh0aCBpblxuICAgICAgbGV0IG01ID0gbTQgKyBzaXh0aCBpblxuICAgICAgZml2ZV9lbGVtZW50X3NvcnQgYXJyIH5jb21wYXJlIG0xIG0yIG0zIG00IG01O1xuICAgICAgbGV0IG0yX3ZhbCA9IGdldCBhcnIgbTIgaW5cbiAgICAgIGxldCBtM192YWwgPSBnZXQgYXJyIG0zIGluXG4gICAgICBsZXQgbTRfdmFsID0gZ2V0IGFyciBtNCBpblxuICAgICAgaWYgY29tcGFyZSBtMl92YWwgbTNfdmFsID0gMFxuICAgICAgdGhlbiBtMl92YWwsIG0zX3ZhbCwgdHJ1ZVxuICAgICAgZWxzZSBpZiBjb21wYXJlIG0zX3ZhbCBtNF92YWwgPSAwXG4gICAgICB0aGVuIG0zX3ZhbCwgbTRfdmFsLCB0cnVlXG4gICAgICBlbHNlIG0yX3ZhbCwgbTRfdmFsLCBmYWxzZVxuICAgIDs7XG5cbiAgICBsZXQgZHVhbF9waXZvdF9wYXJ0aXRpb24gYXJyIH5jb21wYXJlIH5sZWZ0IH5yaWdodCA9XG4gICAgICBsZXQgcGl2b3QxLCBwaXZvdDIsIHBpdm90c19lcXVhbCA9IGNob29zZV9waXZvdHMgYXJyIH5jb21wYXJlIH5sZWZ0IH5yaWdodCBpblxuICAgICAgKCogbG9vcCBpbnZhcmlhbnRzOlxuICAgICAgICAgMS4gIGxlZnQgPD0gbCA8IHIgPD0gcmlnaHRcbiAgICAgICAgIDIuICBsIDw9IHAgPD0gclxuICAgICAgICAgMy4gIGwgPD0geCA8IHAgICAgIGltcGxpZXMgYXJyW3hdID49IHBpdm90MVxuICAgICAgICAgYW5kIGFyclt4XSA8PSBwaXZvdDJcbiAgICAgICAgIDQuICBsZWZ0IDw9IHggPCBsICBpbXBsaWVzIGFyclt4XSA8IHBpdm90MVxuICAgICAgICAgNS4gIHIgPCB4IDw9IHJpZ2h0IGltcGxpZXMgYXJyW3hdID4gcGl2b3QyICopXG4gICAgICBsZXQgcmVjIGxvb3AgbCBwIHIgPVxuICAgICAgICBsZXQgcHYgPSBnZXQgYXJyIHAgaW5cbiAgICAgICAgaWYgY29tcGFyZSBwdiBwaXZvdDEgPCAwXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIHN3YXAgYXJyIHAgbDtcbiAgICAgICAgICBjb250IChsICsgMSkgKHAgKyAxKSByKVxuICAgICAgICBlbHNlIGlmIGNvbXBhcmUgcHYgcGl2b3QyID4gMFxuICAgICAgICB0aGVuIChcbiAgICAgICAgICAoKiBsb29wIGludmFyaWFudHM6ICBzYW1lIGFzIHRob3NlIG9mIHRoZSBvdXRlciBsb29wICopXG4gICAgICAgICAgbGV0IHJlYyBzY2FuX2JhY2t3YXJkcyByID1cbiAgICAgICAgICAgIGlmIHIgPiBwICYmIGNvbXBhcmUgKGdldCBhcnIgcikgcGl2b3QyID4gMCB0aGVuIHNjYW5fYmFja3dhcmRzIChyIC0gMSkgZWxzZSByXG4gICAgICAgICAgaW5cbiAgICAgICAgICBsZXQgciA9IHNjYW5fYmFja3dhcmRzIHIgaW5cbiAgICAgICAgICBzd2FwIGFyciByIHA7XG4gICAgICAgICAgY29udCBsIHAgKHIgLSAxKSlcbiAgICAgICAgZWxzZSBjb250IGwgKHAgKyAxKSByXG4gICAgICBhbmQgY29udCBsIHAgciA9IGlmIHAgPiByIHRoZW4gbCwgciBlbHNlIGxvb3AgbCBwIHIgaW5cbiAgICAgIGxldCBsLCByID0gY29udCBsZWZ0IGxlZnQgcmlnaHQgaW5cbiAgICAgIGwsIHIsIHBpdm90c19lcXVhbFxuICAgIDs7XG5cbiAgICBsZXQgcmVjIGludHJvX3NvcnQgYXJyIH5tYXhfZGVwdGggfmNvbXBhcmUgfmxlZnQgfnJpZ2h0ID1cbiAgICAgIGxldCBsZW4gPSByaWdodCAtIGxlZnQgKyAxIGluXG4gICAgICAoKiBUaGlzIHRha2VzIGNhcmUgb2Ygc29tZSBlZGdlIGNhc2VzLCBzdWNoIGFzIGxlZnQgPiByaWdodCBvciB2ZXJ5IHNob3J0IGFycmF5cyxcbiAgICAgICAgIHNpbmNlIEluc2VydGlvbl9zb3J0LnNvcnQgaGFuZGxlcyB0aGVzZSBjYXNlcyBwcm9wZXJseS4gIFRodXMgd2UgZG9uJ3QgbmVlZCB0b1xuICAgICAgICAgbWFrZSBzdXJlIHRoYXQgbGVmdCBhbmQgcmlnaHQgYXJlIHZhbGlkIGluIHJlY3Vyc2l2ZSBjYWxscy4gKilcbiAgICAgIGlmIGxlbiA8PSAzMlxuICAgICAgdGhlbiBJbnNlcnRpb25fc29ydC5zb3J0IGFyciB+Y29tcGFyZSB+bGVmdCB+cmlnaHRcbiAgICAgIGVsc2UgaWYgbWF4X2RlcHRoIDwgMFxuICAgICAgdGhlbiBIZWFwX3NvcnQuc29ydCBhcnIgfmNvbXBhcmUgfmxlZnQgfnJpZ2h0XG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IG1heF9kZXB0aCA9IG1heF9kZXB0aCAtIDEgaW5cbiAgICAgICAgbGV0IGwsIHIsIG1pZGRsZV9zb3J0ZWQgPSBkdWFsX3Bpdm90X3BhcnRpdGlvbiBhcnIgfmNvbXBhcmUgfmxlZnQgfnJpZ2h0IGluXG4gICAgICAgIGludHJvX3NvcnQgYXJyIH5tYXhfZGVwdGggfmNvbXBhcmUgfmxlZnQgfnJpZ2h0OihsIC0gMSk7XG4gICAgICAgIGlmIG5vdCBtaWRkbGVfc29ydGVkIHRoZW4gaW50cm9fc29ydCBhcnIgfm1heF9kZXB0aCB+Y29tcGFyZSB+bGVmdDpsIH5yaWdodDpyO1xuICAgICAgICBpbnRyb19zb3J0IGFyciB+bWF4X2RlcHRoIH5jb21wYXJlIH5sZWZ0OihyICsgMSkgfnJpZ2h0KVxuICAgIDs7XG5cbiAgICBsZXQgc29ydCBhcnIgfmNvbXBhcmUgfmxlZnQgfnJpZ2h0ID1cbiAgICAgIGxldCBoZWFwX3NvcnRfc3dpdGNoX2RlcHRoID1cbiAgICAgICAgKCogV2UgYmFpbCBvdXQgdG8gaGVhcCBzb3J0IGF0IGEgcmVjdXJzaW9uIGRlcHRoIG9mIDMyLiBHTlUgaW50cm9zb3J0IHVzZXMgMmxnKG4pLlxuICAgICAgICAgICBUaGUgZXhwZWN0ZWQgcmVjdXJzaW9uIGRlcHRoIGZvciBwZXJmZWN0IDMtd2F5IHNwbGl0cyBpcyBsb2dfMyhuKS5cblxuICAgICAgICAgICBVc2luZyAzMiBtZWFucyBhIGJhbGFuY2VkIDMtd2F5IHNwbGl0IHdvdWxkIHdvcmsgdXAgdG8gM14zMiBlbGVtZW50cyAocm91Z2hseVxuICAgICAgICAgICAyXjUwIG9yIDEwXjE1KS4gR05VIHJlYWNoZXMgYSBkZXB0aCBvZiAzMiBhdCA2NTUzNiBlbGVtZW50cy5cblxuICAgICAgICAgICBGb3Igc21hbGwgYXJyYXlzLCB0aGlzIG1ha2VzIHVzIGxlc3MgbGlrZWx5IHRvIGJhaWwgb3V0IHRvIGhlYXAgc29ydCwgYnV0IHRoZVxuICAgICAgICAgICAzMipOIGNvc3QgYmVmb3JlIHdlIGRvIGlzIG5vdCB0aGF0IG11Y2guXG5cbiAgICAgICAgICAgRm9yIGxhcmdlIGFycmF5cywgdGhpcyBtZWFucyB3ZSBhcmUgbW9yZSBsaWtlbHkgdG8gYmFpbCBvdXQgdG8gaGVhcCBzb3J0IGF0XG4gICAgICAgICAgIHNvbWUgcG9pbnQgaWYgd2UgZ2V0IHNvbWUgYmFkIHNwbGl0cyBvciBpZiB0aGUgYXJyYXkgaXMgaHVnZS4gQnV0IHRoYXQncyBvbmx5IGFcbiAgICAgICAgICAgY29uc3RhbnQgZmFjdG9yIGNvc3QgaW4gdGhlIGZpbmFsIHN0YWdlcyBvZiByZWN1cnNpb24uXG5cbiAgICAgICAgICAgQWxsIGluIGFsbCwgdGhpcyBzZWVtcyB0byBiZSBhIHNtYWxsIHRyYWRlb2ZmIGFuZCBhdm9pZHMgcGF5aW5nIGEgY29zdCB0b1xuICAgICAgICAgICBjb21wdXRlIGEgbG9nYXJpdGhtIGF0IHRoZSBzdGFydC4gKilcbiAgICAgICAgMzJcbiAgICAgIGluXG4gICAgICBpbnRyb19zb3J0IGFyciB+bWF4X2RlcHRoOmhlYXBfc29ydF9zd2l0Y2hfZGVwdGggfmNvbXBhcmUgfmxlZnQgfnJpZ2h0XG4gICAgOztcbiAgZW5kXG5lbmRcblxubGV0IHNvcnQgP3BvcyA/bGVuIGFyciB+Y29tcGFyZSA9XG4gIGxldCBwb3MsIGxlbiA9XG4gICAgT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbi5nZXRfcG9zX2xlbl9leG4gKCkgP3BvcyA/bGVuIH50b3RhbF9sZW5ndGg6KGxlbmd0aCBhcnIpXG4gIGluXG4gIFNvcnQuSW50cm9fc29ydC5zb3J0IGFyciB+Y29tcGFyZSB+bGVmdDpwb3MgfnJpZ2h0Oihwb3MgKyBsZW4gLSAxKVxuOztcblxubGV0IHRvX2FycmF5IHQgPSB0XG5sZXQgaXNfZW1wdHkgdCA9IGxlbmd0aCB0ID0gMFxuXG5sZXQgaXNfc29ydGVkIHQgfmNvbXBhcmUgPVxuICBsZXQgaSA9IHJlZiAobGVuZ3RoIHQgLSAxKSBpblxuICBsZXQgcmVzdWx0ID0gcmVmIHRydWUgaW5cbiAgd2hpbGUgIWkgPiAwICYmICFyZXN1bHQgZG9cbiAgICBsZXQgZWx0X2kgPSB1bnNhZmVfZ2V0IHQgIWkgaW5cbiAgICBsZXQgZWx0X2lfbWludXNfMSA9IHVuc2FmZV9nZXQgdCAoIWkgLSAxKSBpblxuICAgIGlmIGNvbXBhcmUgZWx0X2lfbWludXNfMSBlbHRfaSA+IDAgdGhlbiByZXN1bHQgOj0gZmFsc2U7XG4gICAgZGVjciBpXG4gIGRvbmU7XG4gICFyZXN1bHRcbjs7XG5cbmxldCBpc19zb3J0ZWRfc3RyaWN0bHkgdCB+Y29tcGFyZSA9XG4gIGxldCBpID0gcmVmIChsZW5ndGggdCAtIDEpIGluXG4gIGxldCByZXN1bHQgPSByZWYgdHJ1ZSBpblxuICB3aGlsZSAhaSA+IDAgJiYgIXJlc3VsdCBkb1xuICAgIGxldCBlbHRfaSA9IHVuc2FmZV9nZXQgdCAhaSBpblxuICAgIGxldCBlbHRfaV9taW51c18xID0gdW5zYWZlX2dldCB0ICghaSAtIDEpIGluXG4gICAgaWYgY29tcGFyZSBlbHRfaV9taW51c18xIGVsdF9pID49IDAgdGhlbiByZXN1bHQgOj0gZmFsc2U7XG4gICAgZGVjciBpXG4gIGRvbmU7XG4gICFyZXN1bHRcbjs7XG5cbmxldCBtZXJnZSBhMSBhMiB+Y29tcGFyZSA9XG4gIGxldCBsMSA9IEFycmF5Lmxlbmd0aCBhMSBpblxuICBsZXQgbDIgPSBBcnJheS5sZW5ndGggYTIgaW5cbiAgaWYgbDEgPSAwXG4gIHRoZW4gY29weSBhMlxuICBlbHNlIGlmIGwyID0gMFxuICB0aGVuIGNvcHkgYTFcbiAgZWxzZSBpZiBjb21wYXJlICh1bnNhZmVfZ2V0IGEyIDApICh1bnNhZmVfZ2V0IGExIChsMSAtIDEpKSA+PSAwXG4gIHRoZW4gYXBwZW5kIGExIGEyXG4gIGVsc2UgaWYgY29tcGFyZSAodW5zYWZlX2dldCBhMSAwKSAodW5zYWZlX2dldCBhMiAobDIgLSAxKSkgPiAwXG4gIHRoZW4gYXBwZW5kIGEyIGExXG4gIGVsc2UgKFxuICAgIGxldCBsZW4gPSBsMSArIGwyIGluXG4gICAgbGV0IG1lcmdlZCA9IGNyZWF0ZSB+bGVuICh1bnNhZmVfZ2V0IGExIDApIGluXG4gICAgbGV0IGExX2luZGV4ID0gcmVmIDAgaW5cbiAgICBsZXQgYTJfaW5kZXggPSByZWYgMCBpblxuICAgIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgICBsZXQgdXNlX2ExID1cbiAgICAgICAgaWYgbDEgPSAhYTFfaW5kZXhcbiAgICAgICAgdGhlbiBmYWxzZVxuICAgICAgICBlbHNlIGlmIGwyID0gIWEyX2luZGV4XG4gICAgICAgIHRoZW4gdHJ1ZVxuICAgICAgICBlbHNlIGNvbXBhcmUgKHVuc2FmZV9nZXQgYTEgIWExX2luZGV4KSAodW5zYWZlX2dldCBhMiAhYTJfaW5kZXgpIDw9IDBcbiAgICAgIGluXG4gICAgICBpZiB1c2VfYTFcbiAgICAgIHRoZW4gKFxuICAgICAgICB1bnNhZmVfc2V0IG1lcmdlZCBpICh1bnNhZmVfZ2V0IGExICFhMV9pbmRleCk7XG4gICAgICAgIGExX2luZGV4IDo9ICFhMV9pbmRleCArIDEpXG4gICAgICBlbHNlIChcbiAgICAgICAgdW5zYWZlX3NldCBtZXJnZWQgaSAodW5zYWZlX2dldCBhMiAhYTJfaW5kZXgpO1xuICAgICAgICBhMl9pbmRleCA6PSAhYTJfaW5kZXggKyAxKVxuICAgIGRvbmU7XG4gICAgbWVyZ2VkKVxuOztcblxubGV0IGNvcHlfbWF0cml4ID0gbWFwIH5mOmNvcHlcblxubGV0IGZvbGRpbmdfbWFwIHQgfmluaXQgfmYgPVxuICBsZXQgYWNjID0gcmVmIGluaXQgaW5cbiAgbWFwIHQgfmY6KGZ1biB4IC0+XG4gICAgbGV0IG5ld19hY2MsIHkgPSBmICFhY2MgeCBpblxuICAgIGFjYyA6PSBuZXdfYWNjO1xuICAgIHkpXG47O1xuXG5sZXQgZm9sZF9tYXAgdCB+aW5pdCB+ZiA9XG4gIGxldCBhY2MgPSByZWYgaW5pdCBpblxuICBsZXQgcmVzdWx0ID1cbiAgICBtYXAgdCB+ZjooZnVuIHggLT5cbiAgICAgIGxldCBuZXdfYWNjLCB5ID0gZiAhYWNjIHggaW5cbiAgICAgIGFjYyA6PSBuZXdfYWNjO1xuICAgICAgeSlcbiAgaW5cbiAgIWFjYywgcmVzdWx0XG47O1xuXG5sZXQgZm9sZF9yZXN1bHQgdCB+aW5pdCB+ZiA9IENvbnRhaW5lci5mb2xkX3Jlc3VsdCB+Zm9sZCB+aW5pdCB+ZiB0XG5sZXQgZm9sZF91bnRpbCB0IH5pbml0IH5mID0gQ29udGFpbmVyLmZvbGRfdW50aWwgfmZvbGQgfmluaXQgfmYgdFxubGV0IGNvdW50IHQgfmYgPSBDb250YWluZXIuY291bnQgfmZvbGQgdCB+ZlxubGV0IHN1bSBtIHQgfmYgPSBDb250YWluZXIuc3VtIH5mb2xkIG0gdCB+ZlxubGV0IG1pbl9lbHQgdCB+Y29tcGFyZSA9IENvbnRhaW5lci5taW5fZWx0IH5mb2xkIHQgfmNvbXBhcmVcbmxldCBtYXhfZWx0IHQgfmNvbXBhcmUgPSBDb250YWluZXIubWF4X2VsdCB+Zm9sZCB0IH5jb21wYXJlXG5cbmxldCBmb2xkaSB0IH5pbml0IH5mID1cbiAgbGV0IGFjYyA9IHJlZiBpbml0IGluXG4gIGZvciBpID0gMCB0byBsZW5ndGggdCAtIDEgZG9cbiAgICBhY2MgOj0gZiBpICFhY2MgKHVuc2FmZV9nZXQgdCBpKVxuICBkb25lO1xuICAhYWNjXG47O1xuXG5sZXQgZm9sZGluZ19tYXBpIHQgfmluaXQgfmYgPVxuICBsZXQgYWNjID0gcmVmIGluaXQgaW5cbiAgbWFwaSB0IH5mOihmdW4gaSB4IC0+XG4gICAgbGV0IG5ld19hY2MsIHkgPSBmIGkgIWFjYyB4IGluXG4gICAgYWNjIDo9IG5ld19hY2M7XG4gICAgeSlcbjs7XG5cbmxldCBmb2xkX21hcGkgdCB+aW5pdCB+ZiA9XG4gIGxldCBhY2MgPSByZWYgaW5pdCBpblxuICBsZXQgcmVzdWx0ID1cbiAgICBtYXBpIHQgfmY6KGZ1biBpIHggLT5cbiAgICAgIGxldCBuZXdfYWNjLCB5ID0gZiBpICFhY2MgeCBpblxuICAgICAgYWNjIDo9IG5ld19hY2M7XG4gICAgICB5KVxuICBpblxuICAhYWNjLCByZXN1bHRcbjs7XG5cbmxldCBjb3VudGkgdCB+ZiA9XG4gIGZvbGRpIHQgfmluaXQ6MCB+ZjooZnVuIGlkeCBjb3VudCBhIC0+IGlmIGYgaWR4IGEgdGhlbiBjb3VudCArIDEgZWxzZSBjb3VudClcbjs7XG5cbmxldCBjb25jYXRfbWFwIHQgfmYgPSBjb25jYXQgKHRvX2xpc3QgKG1hcCB+ZiB0KSlcbmxldCBjb25jYXRfbWFwaSB0IH5mID0gY29uY2F0ICh0b19saXN0IChtYXBpIH5mIHQpKVxuXG5sZXQgcmV2X2lucGxhY2UgdCA9XG4gIGxldCBpID0gcmVmIDAgaW5cbiAgbGV0IGogPSByZWYgKGxlbmd0aCB0IC0gMSkgaW5cbiAgd2hpbGUgIWkgPCAhaiBkb1xuICAgIHN3YXAgdCAhaSAhajtcbiAgICBpbmNyIGk7XG4gICAgZGVjciBqXG4gIGRvbmVcbjs7XG5cbmxldCByZXYgdCA9XG4gIGxldCB0ID0gY29weSB0IGluXG4gIHJldl9pbnBsYWNlIHQ7XG4gIHRcbjs7XG5cbmxldCBvZl9saXN0X3JldiBsID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT4gW3x8XVxuICB8IGEgOjogbCAtPlxuICAgIGxldCBsZW4gPSAxICsgTGlzdC5sZW5ndGggbCBpblxuICAgIGxldCB0ID0gY3JlYXRlIH5sZW4gYSBpblxuICAgIGxldCByID0gcmVmIGwgaW5cbiAgICAoKiBXZSBzdGFydCBhdCBbbGVuIC0gMl0gYmVjYXVzZSB3ZSBhbHJlYWR5IHB1dCBbYV0gYXQgW3QuKGxlbiAtIDEpXS4gKilcbiAgICBmb3IgaSA9IGxlbiAtIDIgZG93bnRvIDAgZG9cbiAgICAgIG1hdGNoICFyIHdpdGhcbiAgICAgIHwgW10gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICB8IGEgOjogbCAtPlxuICAgICAgICB0LihpKSA8LSBhO1xuICAgICAgICByIDo9IGxcbiAgICBkb25lO1xuICAgIHRcbjs7XG5cbigqIFtvZl9saXN0X21hcF0gYW5kIFtvZl9saXN0X3Jldl9tYXBdIGFyZSBiYXNlZCBvbiBmdW5jdGlvbnMgZnJvbSB0aGUgT0NhbWxcbiAgIGRpc3RyaWJ1dGlvbi4gKilcblxubGV0IG9mX2xpc3RfbWFwIHhzIH5mID1cbiAgbWF0Y2ggeHMgd2l0aFxuICB8IFtdIC0+IFt8fF1cbiAgfCBoZCA6OiB0bCAtPlxuICAgIGxldCBhID0gY3JlYXRlIH5sZW46KDEgKyBMaXN0Lmxlbmd0aCB0bCkgKGYgaGQpIGluXG4gICAgbGV0IHJlYyBmaWxsIGkgPSBmdW5jdGlvblxuICAgICAgfCBbXSAtPiBhXG4gICAgICB8IGhkIDo6IHRsIC0+XG4gICAgICAgIHVuc2FmZV9zZXQgYSBpIChmIGhkKTtcbiAgICAgICAgZmlsbCAoaSArIDEpIHRsXG4gICAgaW5cbiAgICBmaWxsIDEgdGxcbjs7XG5cbmxldCBvZl9saXN0X21hcGkgeHMgfmYgPVxuICBtYXRjaCB4cyB3aXRoXG4gIHwgW10gLT4gW3x8XVxuICB8IGhkIDo6IHRsIC0+XG4gICAgbGV0IGEgPSBjcmVhdGUgfmxlbjooMSArIExpc3QubGVuZ3RoIHRsKSAoZiAwIGhkKSBpblxuICAgIGxldCByZWMgZmlsbCBhIGkgPSBmdW5jdGlvblxuICAgICAgfCBbXSAtPiBhXG4gICAgICB8IGhkIDo6IHRsIC0+XG4gICAgICAgIHVuc2FmZV9zZXQgYSBpIChmIGkgaGQpO1xuICAgICAgICBmaWxsIGEgKGkgKyAxKSB0bFxuICAgIGluXG4gICAgZmlsbCBhIDEgdGxcbjs7XG5cbmxldCBvZl9saXN0X3Jldl9tYXAgeHMgfmYgPVxuICBsZXQgdCA9IG9mX2xpc3RfbWFwIHhzIH5mIGluXG4gIHJldl9pbnBsYWNlIHQ7XG4gIHRcbjs7XG5cbmxldCBvZl9saXN0X3Jldl9tYXBpIHhzIH5mID1cbiAgbGV0IHQgPSBvZl9saXN0X21hcGkgeHMgfmYgaW5cbiAgcmV2X2lucGxhY2UgdDtcbiAgdFxuOztcblxubGV0IGZpbHRlcl9tYXBpIHQgfmYgPVxuICBsZXQgciA9IHJlZiBbfHxdIGluXG4gIGxldCBrID0gcmVmIDAgaW5cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCB0IC0gMSBkb1xuICAgIG1hdGNoIGYgaSAodW5zYWZlX2dldCB0IGkpIHdpdGhcbiAgICB8IE5vbmUgLT4gKClcbiAgICB8IFNvbWUgYSAtPlxuICAgICAgaWYgIWsgPSAwIHRoZW4gciA6PSBjcmVhdGUgfmxlbjoobGVuZ3RoIHQpIGE7XG4gICAgICB1bnNhZmVfc2V0ICFyICFrIGE7XG4gICAgICBpbmNyIGtcbiAgZG9uZTtcbiAgaWYgIWsgPSBsZW5ndGggdCB0aGVuICFyIGVsc2UgaWYgIWsgPiAwIHRoZW4gc3ViIH5wb3M6MCB+bGVuOiFrICFyIGVsc2UgW3x8XVxuOztcblxubGV0IGZpbHRlcl9tYXAgdCB+ZiA9IGZpbHRlcl9tYXBpIHQgfmY6KGZ1biBfaSBhIC0+IGYgYSlcbmxldCBmaWx0ZXJfb3B0IHQgPSBmaWx0ZXJfbWFwIHQgfmY6Rm4uaWRcblxubGV0IHJhaXNlX2xlbmd0aF9taXNtYXRjaCBuYW1lIG4xIG4yID1cbiAgaW52YWxpZF9hcmdmIFwibGVuZ3RoIG1pc21hdGNoIGluICVzOiAlZCA8PiAlZFwiIG5hbWUgbjEgbjIgKClcbltAQGNvbGRdIFtAQGlubGluZSBuZXZlcl0gW0BAbG9jYWwgbmV2ZXJdIFtAQHNwZWNpYWxpc2UgbmV2ZXJdXG47O1xuXG5sZXQgY2hlY2tfbGVuZ3RoMl9leG4gbmFtZSB0MSB0MiA9XG4gIGxldCBuMSA9IGxlbmd0aCB0MSBpblxuICBsZXQgbjIgPSBsZW5ndGggdDIgaW5cbiAgaWYgbjEgPD4gbjIgdGhlbiByYWlzZV9sZW5ndGhfbWlzbWF0Y2ggbmFtZSBuMSBuMlxuOztcblxubGV0IGl0ZXIyX2V4biB0MSB0MiB+ZiA9XG4gIGNoZWNrX2xlbmd0aDJfZXhuIFwiQXJyYXkuaXRlcjJfZXhuXCIgdDEgdDI7XG4gIGl0ZXJpIHQxIH5mOihmdW4gaSB4MSAtPiBmIHgxICh1bnNhZmVfZ2V0IHQyIGkpKVxuOztcblxubGV0IG1hcDJfZXhuIHQxIHQyIH5mID1cbiAgY2hlY2tfbGVuZ3RoMl9leG4gXCJBcnJheS5tYXAyX2V4blwiIHQxIHQyO1xuICBpbml0IChsZW5ndGggdDEpIH5mOihmdW4gaSAtPiBmICh1bnNhZmVfZ2V0IHQxIGkpICh1bnNhZmVfZ2V0IHQyIGkpKVxuOztcblxubGV0IGZvbGQyX2V4biB0MSB0MiB+aW5pdCB+ZiA9XG4gIGNoZWNrX2xlbmd0aDJfZXhuIFwiQXJyYXkuZm9sZDJfZXhuXCIgdDEgdDI7XG4gIGZvbGRpIHQxIH5pbml0IH5mOihmdW4gaSBhYyB4IC0+IGYgYWMgeCAodW5zYWZlX2dldCB0MiBpKSlcbjs7XG5cbmxldCBmaWx0ZXIgdCB+ZiA9IGZpbHRlcl9tYXAgdCB+ZjooZnVuIHggLT4gaWYgZiB4IHRoZW4gU29tZSB4IGVsc2UgTm9uZSlcbmxldCBmaWx0ZXJpIHQgfmYgPSBmaWx0ZXJfbWFwaSB0IH5mOihmdW4gaSB4IC0+IGlmIGYgaSB4IHRoZW4gU29tZSB4IGVsc2UgTm9uZSlcblxuXG5sZXQgZXhpc3RzIHQgfmYgPVxuICBsZXQgaSA9IHJlZiAobGVuZ3RoIHQgLSAxKSBpblxuICBsZXQgcmVzdWx0ID0gcmVmIGZhbHNlIGluXG4gIHdoaWxlICFpID49IDAgJiYgbm90ICFyZXN1bHQgZG9cbiAgICBpZiBmICh1bnNhZmVfZ2V0IHQgIWkpIHRoZW4gcmVzdWx0IDo9IHRydWUgZWxzZSBkZWNyIGlcbiAgZG9uZTtcbiAgIXJlc3VsdFxuOztcblxubGV0IGV4aXN0c2kgdCB+ZiA9XG4gIGxldCBpID0gcmVmIChsZW5ndGggdCAtIDEpIGluXG4gIGxldCByZXN1bHQgPSByZWYgZmFsc2UgaW5cbiAgd2hpbGUgIWkgPj0gMCAmJiBub3QgIXJlc3VsdCBkb1xuICAgIGlmIGYgIWkgKHVuc2FmZV9nZXQgdCAhaSkgdGhlbiByZXN1bHQgOj0gdHJ1ZSBlbHNlIGRlY3IgaVxuICBkb25lO1xuICAhcmVzdWx0XG47O1xuXG5sZXQgbWVtIHQgYSB+ZXF1YWwgPSBleGlzdHMgdCB+ZjooZXF1YWwgYSlcblxubGV0IGZvcl9hbGwgdCB+ZiA9XG4gIGxldCBpID0gcmVmIChsZW5ndGggdCAtIDEpIGluXG4gIGxldCByZXN1bHQgPSByZWYgdHJ1ZSBpblxuICB3aGlsZSAhaSA+PSAwICYmICFyZXN1bHQgZG9cbiAgICBpZiBub3QgKGYgKHVuc2FmZV9nZXQgdCAhaSkpIHRoZW4gcmVzdWx0IDo9IGZhbHNlIGVsc2UgZGVjciBpXG4gIGRvbmU7XG4gICFyZXN1bHRcbjs7XG5cbmxldCBmb3JfYWxsaSB0IH5mID1cbiAgbGV0IGxlbmd0aCA9IGxlbmd0aCB0IGluXG4gIGxldCBpID0gcmVmIChsZW5ndGggLSAxKSBpblxuICBsZXQgcmVzdWx0ID0gcmVmIHRydWUgaW5cbiAgd2hpbGUgIWkgPj0gMCAmJiAhcmVzdWx0IGRvXG4gICAgaWYgbm90IChmICFpICh1bnNhZmVfZ2V0IHQgIWkpKSB0aGVuIHJlc3VsdCA6PSBmYWxzZSBlbHNlIGRlY3IgaVxuICBkb25lO1xuICAhcmVzdWx0XG47O1xuXG5sZXQgZXhpc3RzMl9leG4gdDEgdDIgfmYgPVxuICBjaGVja19sZW5ndGgyX2V4biBcIkFycmF5LmV4aXN0czJfZXhuXCIgdDEgdDI7XG4gIGxldCBpID0gcmVmIChsZW5ndGggdDEgLSAxKSBpblxuICBsZXQgcmVzdWx0ID0gcmVmIGZhbHNlIGluXG4gIHdoaWxlICFpID49IDAgJiYgbm90ICFyZXN1bHQgZG9cbiAgICBpZiBmICh1bnNhZmVfZ2V0IHQxICFpKSAodW5zYWZlX2dldCB0MiAhaSkgdGhlbiByZXN1bHQgOj0gdHJ1ZSBlbHNlIGRlY3IgaVxuICBkb25lO1xuICAhcmVzdWx0XG47O1xuXG5sZXQgZm9yX2FsbDJfZXhuIHQxIHQyIH5mID1cbiAgY2hlY2tfbGVuZ3RoMl9leG4gXCJBcnJheS5mb3JfYWxsMl9leG5cIiB0MSB0MjtcbiAgbGV0IGkgPSByZWYgKGxlbmd0aCB0MSAtIDEpIGluXG4gIGxldCByZXN1bHQgPSByZWYgdHJ1ZSBpblxuICB3aGlsZSAhaSA+PSAwICYmICFyZXN1bHQgZG9cbiAgICBpZiBub3QgKGYgKHVuc2FmZV9nZXQgdDEgIWkpICh1bnNhZmVfZ2V0IHQyICFpKSkgdGhlbiByZXN1bHQgOj0gZmFsc2UgZWxzZSBkZWNyIGlcbiAgZG9uZTtcbiAgIXJlc3VsdFxuOztcblxubGV0IGVxdWFsIGVxdWFsIHQxIHQyID0gbGVuZ3RoIHQxID0gbGVuZ3RoIHQyICYmIGZvcl9hbGwyX2V4biB0MSB0MiB+ZjplcXVhbFxuXG5cbmxldCBtYXBfaW5wbGFjZSB0IH5mID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCB0IC0gMSBkb1xuICAgIHVuc2FmZV9zZXQgdCBpIChmICh1bnNhZmVfZ2V0IHQgaSkpXG4gIGRvbmVcbjs7XG5cbmxldFtAaW5saW5lIGFsd2F5c10gZmluZGlfaW50ZXJuYWwgdCB+ZiB+aWZfZm91bmQgfmlmX25vdF9mb3VuZCA9XG4gIGxldCBsZW5ndGggPSBsZW5ndGggdCBpblxuICBpZiBsZW5ndGggPSAwXG4gIHRoZW4gaWZfbm90X2ZvdW5kICgpXG4gIGVsc2UgKFxuICAgIGxldCBpID0gcmVmIDAgaW5cbiAgICBsZXQgZm91bmQgPSByZWYgZmFsc2UgaW5cbiAgICBsZXQgdmFsdWVfZm91bmQgPSByZWYgKHVuc2FmZV9nZXQgdCAwKSBpblxuICAgIHdoaWxlIChub3QgIWZvdW5kKSAmJiAhaSA8IGxlbmd0aCBkb1xuICAgICAgbGV0IHZhbHVlID0gdW5zYWZlX2dldCB0ICFpIGluXG4gICAgICBpZiBmICFpIHZhbHVlXG4gICAgICB0aGVuIChcbiAgICAgICAgdmFsdWVfZm91bmQgOj0gdmFsdWU7XG4gICAgICAgIGZvdW5kIDo9IHRydWUpXG4gICAgICBlbHNlIGluY3IgaVxuICAgIGRvbmU7XG4gICAgaWYgIWZvdW5kIHRoZW4gaWZfZm91bmQgfmk6IWkgfnZhbHVlOiF2YWx1ZV9mb3VuZCBlbHNlIGlmX25vdF9mb3VuZCAoKSlcbjs7XG5cbmxldCBmaW5kaSB0IH5mID1cbiAgZmluZGlfaW50ZXJuYWxcbiAgICB0XG4gICAgfmZcbiAgICB+aWZfZm91bmQ6KGZ1biB+aSB+dmFsdWUgLT4gU29tZSAoaSwgdmFsdWUpKVxuICAgIH5pZl9ub3RfZm91bmQ6KGZ1biAoKSAtPiBOb25lKVxuOztcblxubGV0IGZpbmRpX2V4biB0IH5mID1cbiAgZmluZGlfaW50ZXJuYWxcbiAgICB0XG4gICAgfmZcbiAgICB+aWZfZm91bmQ6KGZ1biB+aSB+dmFsdWUgLT4gaSwgdmFsdWUpXG4gICAgfmlmX25vdF9mb3VuZDooZnVuICgpIC0+IHJhaXNlIChOb3RfZm91bmRfcyAoQXRvbSBcIkFycmF5LmZpbmRpX2V4bjogbm90IGZvdW5kXCIpKSlcbjs7XG5cbmxldCBmaW5kX2V4biB0IH5mID1cbiAgZmluZGlfaW50ZXJuYWxcbiAgICB0XG4gICAgfmY6KGZ1biBfaSB4IC0+IGYgeClcbiAgICB+aWZfZm91bmQ6KGZ1biB+aTpfIH52YWx1ZSAtPiB2YWx1ZSlcbiAgICB+aWZfbm90X2ZvdW5kOihmdW4gKCkgLT4gcmFpc2UgKE5vdF9mb3VuZF9zIChBdG9tIFwiQXJyYXkuZmluZF9leG46IG5vdCBmb3VuZFwiKSkpXG47O1xuXG5sZXQgZmluZCB0IH5mID0gT3B0aW9uLm1hcCAoZmluZGkgdCB+ZjooZnVuIF9pIHggLT4gZiB4KSkgfmY6KGZ1biAoX2ksIHgpIC0+IHgpXG5cbmxldCBmaW5kX21hcCB0IH5mID1cbiAgbGV0IGxlbmd0aCA9IGxlbmd0aCB0IGluXG4gIGlmIGxlbmd0aCA9IDBcbiAgdGhlbiBOb25lXG4gIGVsc2UgKFxuICAgIGxldCBpID0gcmVmIDAgaW5cbiAgICBsZXQgdmFsdWVfZm91bmQgPSByZWYgTm9uZSBpblxuICAgIHdoaWxlIE9wdGlvbi5pc19ub25lICF2YWx1ZV9mb3VuZCAmJiAhaSA8IGxlbmd0aCBkb1xuICAgICAgbGV0IHZhbHVlID0gdW5zYWZlX2dldCB0ICFpIGluXG4gICAgICB2YWx1ZV9mb3VuZCA6PSBmIHZhbHVlO1xuICAgICAgaW5jciBpXG4gICAgZG9uZTtcbiAgICAhdmFsdWVfZm91bmQpXG47O1xuXG5sZXQgZmluZF9tYXBfZXhuID1cbiAgbGV0IG5vdF9mb3VuZCA9IE5vdF9mb3VuZF9zIChBdG9tIFwiQXJyYXkuZmluZF9tYXBfZXhuOiBub3QgZm91bmRcIikgaW5cbiAgbGV0IGZpbmRfbWFwX2V4biB0IH5mID1cbiAgICBtYXRjaCBmaW5kX21hcCB0IH5mIHdpdGhcbiAgICB8IE5vbmUgLT4gcmFpc2Ugbm90X2ZvdW5kXG4gICAgfCBTb21lIHggLT4geFxuICBpblxuICAoKiBuYW1lZCB0byBwcmVzZXJ2ZSBzeW1ib2wgaW4gY29tcGlsZWQgYmluYXJ5ICopXG4gIGZpbmRfbWFwX2V4blxuOztcblxubGV0IGZpbmRfbWFwaSB0IH5mID1cbiAgbGV0IGxlbmd0aCA9IGxlbmd0aCB0IGluXG4gIGlmIGxlbmd0aCA9IDBcbiAgdGhlbiBOb25lXG4gIGVsc2UgKFxuICAgIGxldCBpID0gcmVmIDAgaW5cbiAgICBsZXQgdmFsdWVfZm91bmQgPSByZWYgTm9uZSBpblxuICAgIHdoaWxlIE9wdGlvbi5pc19ub25lICF2YWx1ZV9mb3VuZCAmJiAhaSA8IGxlbmd0aCBkb1xuICAgICAgbGV0IHZhbHVlID0gdW5zYWZlX2dldCB0ICFpIGluXG4gICAgICB2YWx1ZV9mb3VuZCA6PSBmICFpIHZhbHVlO1xuICAgICAgaW5jciBpXG4gICAgZG9uZTtcbiAgICAhdmFsdWVfZm91bmQpXG47O1xuXG5sZXQgZmluZF9tYXBpX2V4biA9XG4gIGxldCBub3RfZm91bmQgPSBOb3RfZm91bmRfcyAoQXRvbSBcIkFycmF5LmZpbmRfbWFwaV9leG46IG5vdCBmb3VuZFwiKSBpblxuICBsZXQgZmluZF9tYXBpX2V4biB0IH5mID1cbiAgICBtYXRjaCBmaW5kX21hcGkgdCB+ZiB3aXRoXG4gICAgfCBOb25lIC0+IHJhaXNlIG5vdF9mb3VuZFxuICAgIHwgU29tZSB4IC0+IHhcbiAgaW5cbiAgKCogbmFtZWQgdG8gcHJlc2VydmUgc3ltYm9sIGluIGNvbXBpbGVkIGJpbmFyeSAqKVxuICBmaW5kX21hcGlfZXhuXG47O1xuXG5sZXQgZmluZF9jb25zZWN1dGl2ZV9kdXBsaWNhdGUgdCB+ZXF1YWwgPVxuICBsZXQgbiA9IGxlbmd0aCB0IGluXG4gIGlmIG4gPD0gMVxuICB0aGVuIE5vbmVcbiAgZWxzZSAoXG4gICAgbGV0IHJlc3VsdCA9IHJlZiBOb25lIGluXG4gICAgbGV0IGkgPSByZWYgMSBpblxuICAgIGxldCBwcmV2ID0gcmVmICh1bnNhZmVfZ2V0IHQgMCkgaW5cbiAgICB3aGlsZSAhaSA8IG4gZG9cbiAgICAgIGxldCBjdXIgPSB1bnNhZmVfZ2V0IHQgIWkgaW5cbiAgICAgIGlmIGVxdWFsIGN1ciAhcHJldlxuICAgICAgdGhlbiAoXG4gICAgICAgIHJlc3VsdCA6PSBTb21lICghcHJldiwgY3VyKTtcbiAgICAgICAgaSA6PSBuKVxuICAgICAgZWxzZSAoXG4gICAgICAgIHByZXYgOj0gY3VyO1xuICAgICAgICBpbmNyIGkpXG4gICAgZG9uZTtcbiAgICAhcmVzdWx0KVxuOztcblxubGV0IHJlZHVjZSB0IH5mID1cbiAgaWYgbGVuZ3RoIHQgPSAwXG4gIHRoZW4gTm9uZVxuICBlbHNlIChcbiAgICBsZXQgciA9IHJlZiAodW5zYWZlX2dldCB0IDApIGluXG4gICAgZm9yIGkgPSAxIHRvIGxlbmd0aCB0IC0gMSBkb1xuICAgICAgciA6PSBmICFyICh1bnNhZmVfZ2V0IHQgaSlcbiAgICBkb25lO1xuICAgIFNvbWUgIXIpXG47O1xuXG5sZXQgcmVkdWNlX2V4biB0IH5mID1cbiAgbWF0Y2ggcmVkdWNlIHQgfmYgd2l0aFxuICB8IE5vbmUgLT4gaW52YWxpZF9hcmcgXCJBcnJheS5yZWR1Y2VfZXhuXCJcbiAgfCBTb21lIHYgLT4gdlxuOztcblxubGV0IHBlcm11dGUgPSBBcnJheV9wZXJtdXRlLnBlcm11dGVcblxubGV0IHJhbmRvbV9lbGVtZW50X2V4biA/KHJhbmRvbV9zdGF0ZSA9IFJhbmRvbS5TdGF0ZS5kZWZhdWx0KSB0ID1cbiAgaWYgaXNfZW1wdHkgdFxuICB0aGVuIGZhaWx3aXRoIFwiQXJyYXkucmFuZG9tX2VsZW1lbnRfZXhuOiBlbXB0eSBhcnJheVwiXG4gIGVsc2UgdC4oUmFuZG9tLlN0YXRlLmludCByYW5kb21fc3RhdGUgKGxlbmd0aCB0KSlcbjs7XG5cbmxldCByYW5kb21fZWxlbWVudCA/KHJhbmRvbV9zdGF0ZSA9IFJhbmRvbS5TdGF0ZS5kZWZhdWx0KSB0ID1cbiAgdHJ5IFNvbWUgKHJhbmRvbV9lbGVtZW50X2V4biB+cmFuZG9tX3N0YXRlIHQpIHdpdGhcbiAgfCBfIC0+IE5vbmVcbjs7XG5cbmxldCB6aXAgdDEgdDIgPVxuICBpZiBsZW5ndGggdDEgPD4gbGVuZ3RoIHQyIHRoZW4gTm9uZSBlbHNlIFNvbWUgKG1hcDJfZXhuIHQxIHQyIH5mOihmdW4geDEgeDIgLT4geDEsIHgyKSlcbjs7XG5cbmxldCB6aXBfZXhuIHQxIHQyID1cbiAgaWYgbGVuZ3RoIHQxIDw+IGxlbmd0aCB0MlxuICB0aGVuIGZhaWx3aXRoIFwiQXJyYXkuemlwX2V4blwiXG4gIGVsc2UgbWFwMl9leG4gdDEgdDIgfmY6KGZ1biB4MSB4MiAtPiB4MSwgeDIpXG47O1xuXG5sZXQgdW56aXAgdCA9XG4gIGxldCBuID0gbGVuZ3RoIHQgaW5cbiAgaWYgbiA9IDBcbiAgdGhlbiBbfHxdLCBbfHxdXG4gIGVsc2UgKFxuICAgIGxldCB4LCB5ID0gdC4oMCkgaW5cbiAgICBsZXQgcmVzMSA9IGNyZWF0ZSB+bGVuOm4geCBpblxuICAgIGxldCByZXMyID0gY3JlYXRlIH5sZW46biB5IGluXG4gICAgZm9yIGkgPSAxIHRvIG4gLSAxIGRvXG4gICAgICBsZXQgeCwgeSA9IHQuKGkpIGluXG4gICAgICByZXMxLihpKSA8LSB4O1xuICAgICAgcmVzMi4oaSkgPC0geVxuICAgIGRvbmU7XG4gICAgcmVzMSwgcmVzMilcbjs7XG5cbmxldCBzb3J0ZWRfY29weSB0IH5jb21wYXJlID1cbiAgbGV0IHQxID0gY29weSB0IGluXG4gIHNvcnQgdDEgfmNvbXBhcmU7XG4gIHQxXG47O1xuXG5sZXQgcGFydGl0aW9uaV90ZiB0IH5mID1cbiAgbGV0IGJvdGggPSBtYXBpIHQgfmY6KGZ1biBpIHggLT4gaWYgZiBpIHggdGhlbiBFaXRoZXIuRmlyc3QgeCBlbHNlIEVpdGhlci5TZWNvbmQgeCkgaW5cbiAgbGV0IHRydWVzID1cbiAgICBmaWx0ZXJfbWFwIGJvdGggfmY6KGZ1bmN0aW9uXG4gICAgICB8IEZpcnN0IHggLT4gU29tZSB4XG4gICAgICB8IFNlY29uZCBfIC0+IE5vbmUpXG4gIGluXG4gIGxldCBmYWxzZXMgPVxuICAgIGZpbHRlcl9tYXAgYm90aCB+ZjooZnVuY3Rpb25cbiAgICAgIHwgRmlyc3QgXyAtPiBOb25lXG4gICAgICB8IFNlY29uZCB4IC0+IFNvbWUgeClcbiAgaW5cbiAgdHJ1ZXMsIGZhbHNlc1xuOztcblxubGV0IHBhcnRpdGlvbl90ZiB0IH5mID0gcGFydGl0aW9uaV90ZiB0IH5mOihmdW4gX2kgeCAtPiBmIHgpXG5sZXQgbGFzdCB0ID0gdC4obGVuZ3RoIHQgLSAxKVxuXG4oKiBDb252ZXJ0IHRvIGEgc2VxdWVuY2UgYnV0IGRvZXMgbm90IGF0dGVtcHQgdG8gcHJvdGVjdCBhZ2FpbnN0IG1vZGlmaWNhdGlvblxuICAgaW4gdGhlIGFycmF5LiAqKVxubGV0IHRvX3NlcXVlbmNlX211dGFibGUgdCA9XG4gIFNlcXVlbmNlLnVuZm9sZF9zdGVwIH5pbml0OjAgfmY6KGZ1biBpIC0+XG4gICAgaWYgaSA+PSBsZW5ndGggdCB0aGVuIFNlcXVlbmNlLlN0ZXAuRG9uZSBlbHNlIFNlcXVlbmNlLlN0ZXAuWWllbGQgKHQuKGkpLCBpICsgMSkpXG47O1xuXG5sZXQgdG9fc2VxdWVuY2UgdCA9IHRvX3NlcXVlbmNlX211dGFibGUgKGNvcHkgdClcblxubGV0IGNhcnRlc2lhbl9wcm9kdWN0IHQxIHQyID1cbiAgaWYgaXNfZW1wdHkgdDEgfHwgaXNfZW1wdHkgdDJcbiAgdGhlbiBbfHxdXG4gIGVsc2UgKFxuICAgIGxldCBuMSA9IGxlbmd0aCB0MSBpblxuICAgIGxldCBuMiA9IGxlbmd0aCB0MiBpblxuICAgIGxldCB0ID0gY3JlYXRlIH5sZW46KG4xICogbjIpICh0MS4oMCksIHQyLigwKSkgaW5cbiAgICBsZXQgciA9IHJlZiAwIGluXG4gICAgZm9yIGkxID0gMCB0byBuMSAtIDEgZG9cbiAgICAgIGZvciBpMiA9IDAgdG8gbjIgLSAxIGRvXG4gICAgICAgIHQuKCFyKSA8LSB0MS4oaTEpLCB0Mi4oaTIpO1xuICAgICAgICBpbmNyIHJcbiAgICAgIGRvbmVcbiAgICBkb25lO1xuICAgIHQpXG47O1xuXG5sZXQgdHJhbnNwb3NlIHR0ID1cbiAgaWYgbGVuZ3RoIHR0ID0gMFxuICB0aGVuIFNvbWUgW3x8XVxuICBlbHNlIChcbiAgICBsZXQgd2lkdGggPSBsZW5ndGggdHQgaW5cbiAgICBsZXQgZGVwdGggPSBsZW5ndGggdHQuKDApIGluXG4gICAgaWYgZXhpc3RzIHR0IH5mOihmdW4gdCAtPiBsZW5ndGggdCA8PiBkZXB0aClcbiAgICB0aGVuIE5vbmVcbiAgICBlbHNlIFNvbWUgKGluaXQgZGVwdGggfmY6KGZ1biBkIC0+IGluaXQgd2lkdGggfmY6KGZ1biB3IC0+IHR0Lih3KS4oZCkpKSkpXG47O1xuXG5sZXQgdHJhbnNwb3NlX2V4biB0dCA9XG4gIG1hdGNoIHRyYW5zcG9zZSB0dCB3aXRoXG4gIHwgTm9uZSAtPiBpbnZhbGlkX2FyZyBcIkFycmF5LnRyYW5zcG9zZV9leG5cIlxuICB8IFNvbWUgdHQnIC0+IHR0J1xuOztcblxuaW5jbHVkZSBCaW5hcnlfc2VhcmNoYWJsZS5NYWtlMSAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICAgIGxldCBnZXQgPSBnZXRcbiAgICBsZXQgbGVuZ3RoID0gbGVuZ3RoXG4gIGVuZClcblxuaW5jbHVkZSBCbGl0Lk1ha2UxIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gICAgbGV0IGxlbmd0aCA9IGxlbmd0aFxuXG4gICAgbGV0IGNyZWF0ZV9saWtlIH5sZW4gdCA9XG4gICAgICBpZiBsZW4gPSAwXG4gICAgICB0aGVuIFt8fF1cbiAgICAgIGVsc2UgKFxuICAgICAgICBhc3NlcnQgKGxlbmd0aCB0ID4gMCk7XG4gICAgICAgIGNyZWF0ZSB+bGVuIHQuKDApKVxuICAgIDs7XG5cbiAgICBsZXQgdW5zYWZlX2JsaXQgPSB1bnNhZmVfYmxpdFxuICBlbmQpXG5cbmxldCBpbnZhcmlhbnQgaW52YXJpYW50X2EgdCA9IGl0ZXIgdCB+ZjppbnZhcmlhbnRfYVxuXG5tb2R1bGUgUHJpdmF0ZSA9IHN0cnVjdFxuICBtb2R1bGUgU29ydCA9IFNvcnRcbmVuZFxuIiwiKCoqIEFuIGludGVybmFsLW9ubHkgbW9kdWxlIGZhY3RvcmVkIG91dCBkdWUgdG8gYSBjaXJjdWxhciBkZXBlbmRlbmN5IGJldHdlZW4gY29yZV9hcnJheVxuICAgIGFuZCBjb3JlX2xpc3QuICBDb250YWlucyBjb2RlIGZvciBwZXJtdXRpbmcgYW4gYXJyYXkuICopXG5cbm9wZW4hIEltcG9ydFxuaW5jbHVkZSBBcnJheTBcblxubGV0IHBlcm11dGUgPyhyYW5kb21fc3RhdGUgPSBSYW5kb20uU3RhdGUuZGVmYXVsdCkgPyhwb3MgPSAwKSA/bGVuIHQgPVxuICAoKiBDb3BpZWQgZnJvbSBbT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbjBdIHRvIGF2b2lkIGFsbG9jYXRpbmcgYSB0dXBsZSB3aGVuIGNvbXBpbGluZ1xuICAgICB3aXRob3V0IGZsYW1iZGEuICopXG4gIGxldCB0b3RhbF9sZW5ndGggPSBsZW5ndGggdCBpblxuICBsZXQgbGVuID1cbiAgICBtYXRjaCBsZW4gd2l0aFxuICAgIHwgU29tZSBsIC0+IGxcbiAgICB8IE5vbmUgLT4gdG90YWxfbGVuZ3RoIC0gcG9zXG4gIGluXG4gIE9yZGVyZWRfY29sbGVjdGlvbl9jb21tb24wLmNoZWNrX3Bvc19sZW5fZXhuIH5wb3MgfmxlbiB+dG90YWxfbGVuZ3RoO1xuICBsZXQgbnVtX3N3YXBzID0gbGVuIC0gMSBpblxuICBmb3IgaSA9IG51bV9zd2FwcyBkb3dudG8gMSBkb1xuICAgIGxldCB0aGlzX2kgPSBwb3MgKyBpIGluXG4gICAgKCogW3JhbmRvbV9pXSBpcyBkcmF3biBmcm9tIFtwb3MsdGhpc19pXSAqKVxuICAgIGxldCByYW5kb21faSA9IHBvcyArIFJhbmRvbS5TdGF0ZS5pbnQgcmFuZG9tX3N0YXRlIChpICsgMSkgaW5cbiAgICBzd2FwIHQgdGhpc19pIHJhbmRvbV9pXG4gIGRvbmVcbjs7XG4iLCJvcGVuISBJbXBvcnRcblxubGV0IGNvbnN0IGMgXyA9IGNcblxuZXh0ZXJuYWwgaWdub3JlIDogXyAtPiB1bml0ID0gXCIlaWdub3JlXCJcblxuKCogdGhpcyBoYXMgdGhlIHNhbWUgYmVoYXZpb3IgYXMgW0NhbWwuaWdub3JlXSAqKVxuXG5sZXQgbm9uIGYgeCA9IG5vdCAoZiB4KVxuXG5sZXQgZm9yZXZlciBmID1cbiAgbGV0IHJlYyBmb3JldmVyICgpID1cbiAgICBmICgpO1xuICAgIGZvcmV2ZXIgKClcbiAgaW5cbiAgdHJ5IGZvcmV2ZXIgKCkgd2l0aFxuICB8IGUgLT4gZVxuOztcblxuZXh0ZXJuYWwgaWQgOiAnYSAtPiAnYSA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsICggfD4gKSA6ICdhIC0+ICgnYSAtPiAnYikgLT4gJ2IgPSBcIiVyZXZhcHBseVwiXG5cbigqIFRoZSB0eXBpY2FsIHVzZSBjYXNlIGZvciB0aGVzZSBmdW5jdGlvbnMgaXMgdG8gcGFzcyBpbiBmdW5jdGlvbmFsIGFyZ3VtZW50cyBhbmQgZ2V0XG4gICBmdW5jdGlvbnMgYXMgYSByZXN1bHQuICopXG5sZXQgY29tcG9zZSBmIGcgeCA9IGYgKGcgeClcbmxldCBmbGlwIGYgeCB5ID0gZiB5IHhcbmxldCByZWMgYXBwbHlfbl90aW1lcyB+biBmIHggPSBpZiBuIDw9IDAgdGhlbiB4IGVsc2UgYXBwbHlfbl90aW1lcyB+bjoobiAtIDEpIGYgKGYgeClcbiIsIm9wZW4hIEltcG9ydFxuXG5sZXQgcmFpc2VfcyA9IEVycm9yLnJhaXNlX3NcblxubW9kdWxlIFJlcHIgPSBJbnQ2M19lbXVsLlJlcHJcblxuKCogSW4gYSB3b3JsZCB3aGVyZSB0aGUgY29tcGlsZXIgd291bGQgdW5kZXJzdGFuZCBbQEBpbW1lZGlhdGU2NF0gYXR0cmlidXRlcyBvbiB0eXBlXG4gICBkZWNsYXJhdGlvbnMsIHRoaXMgbW9kdWxlIGlzIGhvdyBvbmUgd291bGQgcHJvZHVjZSBhIFt0eXBlIHRdIHdpdGggdGhpcyBhdHRyaWJ1dGUuICopXG5tb2R1bGUgSW1tZWRpYXRlNjQgOiBzaWdcbiAgbW9kdWxlIHR5cGUgTm9uX2ltbWVkaWF0ZSA9IHNpZ1xuICAgIHR5cGUgdFxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBJbW1lZGlhdGUgPSBzaWdcbiAgICB0eXBlIHQgW0BAaW1tZWRpYXRlXVxuICBlbmRcblxuICBtb2R1bGUgTWFrZSAoSW1tZWRpYXRlIDogSW1tZWRpYXRlKSAoTm9uX2ltbWVkaWF0ZSA6IE5vbl9pbW1lZGlhdGUpIDogc2lnXG4gICAgdHlwZSB0IFtAQGltbWVkaWF0ZTY0XVxuXG4gICAgdHlwZSAnYSByZXByID1cbiAgICAgIHwgSW1tZWRpYXRlIDogSW1tZWRpYXRlLnQgcmVwclxuICAgICAgfCBOb25faW1tZWRpYXRlIDogTm9uX2ltbWVkaWF0ZS50IHJlcHJcblxuICAgIHZhbCByZXByIDogdCByZXByXG4gIGVuZFxuZW5kID0gc3RydWN0XG4gIG1vZHVsZSB0eXBlIE5vbl9pbW1lZGlhdGUgPSBzaWdcbiAgICB0eXBlIHRcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgSW1tZWRpYXRlID0gc2lnXG4gICAgdHlwZSB0IFtAQGltbWVkaWF0ZV1cbiAgZW5kXG5cbiAgbW9kdWxlIE1ha2UgKEltbWVkaWF0ZSA6IEltbWVkaWF0ZSkgKE5vbl9pbW1lZGlhdGUgOiBOb25faW1tZWRpYXRlKSA9IHN0cnVjdFxuICAgIHR5cGUgdCBbQEBpbW1lZGlhdGU2NF1cblxuICAgIHR5cGUgJ2EgcmVwciA9XG4gICAgICB8IEltbWVkaWF0ZSA6IEltbWVkaWF0ZS50IHJlcHJcbiAgICAgIHwgTm9uX2ltbWVkaWF0ZSA6IE5vbl9pbW1lZGlhdGUudCByZXByXG5cbiAgICBsZXQgcmVwciA9XG4gICAgICBtYXRjaCBXb3JkX3NpemUud29yZF9zaXplIHdpdGhcbiAgICAgIHwgVzY0IC0+IChDYW1sLk9iai5tYWdpYyBJbW1lZGlhdGUgOiB0IHJlcHIpXG4gICAgICB8IFczMiAtPiAoQ2FtbC5PYmoubWFnaWMgTm9uX2ltbWVkaWF0ZSA6IHQgcmVwcilcbiAgICA7O1xuICBlbmRcbmVuZFxuXG5pbmNsdWRlIEltbWVkaWF0ZTY0Lk1ha2UgKEludCkgKEludDYzX2VtdWwpXG5cbm1vZHVsZSBCYWNrZW5kID0gc3RydWN0XG4gIG1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgICB0eXBlIHRcblxuICAgIGluY2x1ZGUgSW50X2ludGYuUyB3aXRoIHR5cGUgdCA6PSB0XG5cbiAgICB2YWwgb2ZfaW50IDogaW50IC0+IHRcbiAgICB2YWwgdG9faW50IDogdCAtPiBpbnQgb3B0aW9uXG4gICAgdmFsIHRvX2ludF90cnVuYyA6IHQgLT4gaW50XG4gICAgdmFsIG9mX2ludDMyIDogaW50MzIgLT4gdFxuICAgIHZhbCB0b19pbnQzMiA6IHQgLT4gSW50MzIudCBvcHRpb25cbiAgICB2YWwgdG9faW50MzJfdHJ1bmMgOiB0IC0+IEludDMyLnRcbiAgICB2YWwgb2ZfaW50NjQgOiBJbnQ2NC50IC0+IHQgb3B0aW9uXG4gICAgdmFsIG9mX2ludDY0X3RydW5jIDogSW50NjQudCAtPiB0XG4gICAgdmFsIG9mX25hdGl2ZWludCA6IG5hdGl2ZWludCAtPiB0IG9wdGlvblxuICAgIHZhbCB0b19uYXRpdmVpbnQgOiB0IC0+IG5hdGl2ZWludCBvcHRpb25cbiAgICB2YWwgb2ZfbmF0aXZlaW50X3RydW5jIDogbmF0aXZlaW50IC0+IHRcbiAgICB2YWwgdG9fbmF0aXZlaW50X3RydW5jIDogdCAtPiBuYXRpdmVpbnRcbiAgICB2YWwgb2ZfZmxvYXRfdW5jaGVja2VkIDogZmxvYXQgLT4gdFxuICAgIHZhbCByZXByIDogKHQsIHQpIEludDYzX2VtdWwuUmVwci50XG4gICAgdmFsIGJzd2FwMTYgOiB0IC0+IHRcbiAgICB2YWwgYnN3YXAzMiA6IHQgLT4gdFxuICAgIHZhbCBic3dhcDQ4IDogdCAtPiB0XG4gIGVuZFxuICB3aXRoIHR5cGUgdCA6PSB0XG5cbiAgbW9kdWxlIE5hdGl2ZSA9IHN0cnVjdFxuICAgIGluY2x1ZGUgSW50XG5cbiAgICBsZXQgdG9faW50IHggPSBTb21lIHhcbiAgICBsZXQgdG9faW50X3RydW5jIHggPSB4XG5cbiAgICAoKiBbb2ZfaW50MzJfZXhuXSBpcyBhIHNhZmUgb3BlcmF0aW9uIG9uIHBsYXRmb3JtcyB3aXRoIDY0LWJpdCB3b3JkIHNpemVzLiAqKVxuICAgIGxldCBvZl9pbnQzMiA9IG9mX2ludDMyX2V4blxuICAgIGxldCB0b19uYXRpdmVpbnRfdHJ1bmMgeCA9IHRvX25hdGl2ZWludCB4XG4gICAgbGV0IHRvX25hdGl2ZWludCB4ID0gU29tZSAodG9fbmF0aXZlaW50IHgpXG4gICAgbGV0IHJlcHIgPSBJbnQ2M19lbXVsLlJlcHIuSW50XG4gICAgbGV0IGJzd2FwMzIgdCA9IEludDY0LnRvX2ludF90cnVuYyAoSW50NjQuYnN3YXAzMiAoSW50NjQub2ZfaW50IHQpKVxuICAgIGxldCBic3dhcDQ4IHQgPSBJbnQ2NC50b19pbnRfdHJ1bmMgKEludDY0LmJzd2FwNDggKEludDY0Lm9mX2ludCB0KSlcbiAgZW5kXG5cbiAgbGV0IGltcGwgOiAobW9kdWxlIFMpID1cbiAgICBtYXRjaCByZXByIHdpdGhcbiAgICB8IEltbWVkaWF0ZSAtPiAobW9kdWxlIE5hdGl2ZSA6IFMpXG4gICAgfCBOb25faW1tZWRpYXRlIC0+IChtb2R1bGUgSW50NjNfZW11bCA6IFMpXG4gIDs7XG5lbmRcblxuaW5jbHVkZSAodmFsIEJhY2tlbmQuaW1wbCA6IEJhY2tlbmQuUylcblxubW9kdWxlIE92ZXJmbG93X2V4biA9IHN0cnVjdFxuICBsZXQgKCArICkgdCB1ID1cbiAgICBsZXQgc3VtID0gdCArIHUgaW5cbiAgICBpZiBiaXRfb3IgKGJpdF94b3IgdCB1KSAoYml0X3hvciB0IChiaXRfbm90IHN1bSkpIDwgemVyb1xuICAgIHRoZW4gc3VtXG4gICAgZWxzZVxuICAgICAgcmFpc2Vfc1xuICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgIFwiKCArICkgb3ZlcmZsb3dcIlxuICAgICAgICAgICBbIFwidFwiLCBzZXhwX29mX3QgdDsgXCJ1XCIsIHNleHBfb2ZfdCB1OyBcInN1bVwiLCBzZXhwX29mX3Qgc3VtIF0pXG4gIDs7XG5cbiAgbGV0ICggLSApIHQgdSA9XG4gICAgbGV0IGRpZmYgPSB0IC0gdSBpblxuICAgIGxldCBwb3NfZGlmZiA9IHQgPiB1IGluXG4gICAgaWYgdCA8PiB1ICYmIEJvb2wuKCA8PiApIHBvc19kaWZmIChpc19wb3NpdGl2ZSBkaWZmKVxuICAgIHRoZW5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgICBcIiggLSApIG92ZXJmbG93XCJcbiAgICAgICAgICAgWyBcInRcIiwgc2V4cF9vZl90IHQ7IFwidVwiLCBzZXhwX29mX3QgdTsgXCJkaWZmXCIsIHNleHBfb2ZfdCBkaWZmIF0pXG4gICAgZWxzZSBkaWZmXG4gIDs7XG5cbiAgbGV0IG5lZ2F0aXZlX29uZSA9IG9mX2ludCAoLTEpXG4gIGxldCBkaXZfd291bGRfb3ZlcmZsb3cgdCB1ID0gdCA9IG1pbl92YWx1ZSAmJiB1ID0gbmVnYXRpdmVfb25lXG5cbiAgbGV0ICggKiApIHQgdSA9XG4gICAgbGV0IHByb2R1Y3QgPSB0ICogdSBpblxuICAgIGlmIHUgPD4gemVybyAmJiAoZGl2X3dvdWxkX292ZXJmbG93IHByb2R1Y3QgdSB8fCBwcm9kdWN0IC8gdSA8PiB0KVxuICAgIHRoZW5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgICBcIiggKiApIG92ZXJmbG93XCJcbiAgICAgICAgICAgWyBcInRcIiwgc2V4cF9vZl90IHQ7IFwidVwiLCBzZXhwX29mX3QgdTsgXCJwcm9kdWN0XCIsIHNleHBfb2ZfdCBwcm9kdWN0IF0pXG4gICAgZWxzZSBwcm9kdWN0XG4gIDs7XG5cbiAgbGV0ICggLyApIHQgdSA9XG4gICAgaWYgZGl2X3dvdWxkX292ZXJmbG93IHQgdVxuICAgIHRoZW5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgICBcIiggLyApIG92ZXJmbG93XCJcbiAgICAgICAgICAgWyBcInRcIiwgc2V4cF9vZl90IHQ7IFwidVwiLCBzZXhwX29mX3QgdTsgXCJwcm9kdWN0XCIsIHNleHBfb2ZfdCAodCAvIHUpIF0pXG4gICAgZWxzZSB0IC8gdVxuICA7O1xuXG4gIGxldCBhYnMgdCA9IGlmIHQgPSBtaW5fdmFsdWUgdGhlbiBmYWlsd2l0aCBcImFicyBvdmVyZmxvd1wiIGVsc2UgYWJzIHRcbiAgbGV0IG5lZyB0ID0gaWYgdCA9IG1pbl92YWx1ZSB0aGVuIGZhaWx3aXRoIFwibmVnIG92ZXJmbG93XCIgZWxzZSBuZWcgdFxuZW5kXG5cbmxldCAoKSA9IGFzc2VydCAoSW50LiggPSApIG51bV9iaXRzIDYzKVxuXG5sZXQgcmFuZG9tX29mX2ludCA/KHN0YXRlID0gUmFuZG9tLlN0YXRlLmRlZmF1bHQpIGJvdW5kID1cbiAgb2ZfaW50IChSYW5kb20uU3RhdGUuaW50IHN0YXRlICh0b19pbnRfZXhuIGJvdW5kKSlcbjs7XG5cbmxldCByYW5kb21fb2ZfaW50NjQgPyhzdGF0ZSA9IFJhbmRvbS5TdGF0ZS5kZWZhdWx0KSBib3VuZCA9XG4gIG9mX2ludDY0X2V4biAoUmFuZG9tLlN0YXRlLmludDY0IHN0YXRlICh0b19pbnQ2NCBib3VuZCkpXG47O1xuXG5sZXQgcmFuZG9tID1cbiAgbWF0Y2ggV29yZF9zaXplLndvcmRfc2l6ZSB3aXRoXG4gIHwgVzY0IC0+IHJhbmRvbV9vZl9pbnRcbiAgfCBXMzIgLT4gcmFuZG9tX29mX2ludDY0XG47O1xuXG5sZXQgcmFuZG9tX2luY2xfb2ZfaW50ID8oc3RhdGUgPSBSYW5kb20uU3RhdGUuZGVmYXVsdCkgbG8gaGkgPVxuICBvZl9pbnQgKFJhbmRvbS5TdGF0ZS5pbnRfaW5jbCBzdGF0ZSAodG9faW50X2V4biBsbykgKHRvX2ludF9leG4gaGkpKVxuOztcblxubGV0IHJhbmRvbV9pbmNsX29mX2ludDY0ID8oc3RhdGUgPSBSYW5kb20uU3RhdGUuZGVmYXVsdCkgbG8gaGkgPVxuICBvZl9pbnQ2NF9leG4gKFJhbmRvbS5TdGF0ZS5pbnQ2NF9pbmNsIHN0YXRlICh0b19pbnQ2NCBsbykgKHRvX2ludDY0IGhpKSlcbjs7XG5cbmxldCByYW5kb21faW5jbCA9XG4gIG1hdGNoIFdvcmRfc2l6ZS53b3JkX3NpemUgd2l0aFxuICB8IFc2NCAtPiByYW5kb21faW5jbF9vZl9pbnRcbiAgfCBXMzIgLT4gcmFuZG9tX2luY2xfb2ZfaW50NjRcbjs7XG5cbmxldCBmbG9vcl9sb2cyIHQgPVxuICBtYXRjaCBXb3JkX3NpemUud29yZF9zaXplIHdpdGhcbiAgfCBXNjQgLT4gdCB8PiB0b19pbnRfZXhuIHw+IEludC5mbG9vcl9sb2cyXG4gIHwgVzMyIC0+XG4gICAgaWYgdCA8PSB6ZXJvXG4gICAgdGhlbiByYWlzZV9zIChTZXhwLm1lc3NhZ2UgXCJbSW50LmZsb29yX2xvZzJdIGdvdCBpbnZhbGlkIGlucHV0XCIgWyBcIlwiLCBzZXhwX29mX3QgdCBdKTtcbiAgICBsZXQgZmxvb3JfbG9nMiA9IHJlZiAoSW50LiggLSApIG51bV9iaXRzIDIpIGluXG4gICAgd2hpbGUgZXF1YWwgemVybyAoYml0X2FuZCB0IChzaGlmdF9sZWZ0IG9uZSAhZmxvb3JfbG9nMikpIGRvXG4gICAgICBmbG9vcl9sb2cyIDo9IEludC4oIC0gKSAhZmxvb3JfbG9nMiAxXG4gICAgZG9uZTtcbiAgICAhZmxvb3JfbG9nMlxuOztcblxubW9kdWxlIFByaXZhdGUgPSBzdHJ1Y3RcbiAgbW9kdWxlIFJlcHIgPSBSZXByXG5cbiAgbGV0IHJlcHIgPSByZXByXG5cbiAgbW9kdWxlIEVtdWwgPSBJbnQ2M19lbXVsXG5lbmRcbiIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBJbnZhcmlhbnRfaW50ZlxuXG5sZXQgcmFpc2VfcyA9IEVycm9yLnJhaXNlX3NcblxubGV0IGludmFyaWFudCBoZXJlIHQgc2V4cF9vZl90IGYgOiB1bml0ID1cbiAgdHJ5IGYgKCkgd2l0aFxuICB8IGV4biAtPlxuICAgIHJhaXNlX3NcbiAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgIFwiaW52YXJpYW50IGZhaWxlZFwiXG4gICAgICAgICBbIFwiXCIsIFNvdXJjZV9jb2RlX3Bvc2l0aW9uMC5zZXhwX29mX3QgaGVyZVxuICAgICAgICAgOyBcImV4blwiLCBzZXhwX29mX2V4biBleG5cbiAgICAgICAgIDsgXCJcIiwgc2V4cF9vZl90IHRcbiAgICAgICAgIF0pXG47O1xuXG5sZXQgY2hlY2tfZmllbGQgdCBmIGZpZWxkID1cbiAgdHJ5IGYgKEZpZWxkLmdldCBmaWVsZCB0KSB3aXRoXG4gIHwgZXhuIC0+XG4gICAgcmFpc2Vfc1xuICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgXCJwcm9ibGVtIHdpdGggZmllbGRcIlxuICAgICAgICAgWyBcImZpZWxkXCIsIHNleHBfb2Zfc3RyaW5nIChGaWVsZC5uYW1lIGZpZWxkKTsgXCJleG5cIiwgc2V4cF9vZl9leG4gZXhuIF0pXG47O1xuIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIENvbXBhcmFibGVfaW50ZlxuXG5tb2R1bGUgV2l0aF96ZXJvIChUIDogc2lnXG4gICAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlXVxuXG4gICAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcblxuICAgIFtAQEBlbmRdXG5cbiAgICB2YWwgemVybyA6IHRcbiAgZW5kKSA9XG5zdHJ1Y3RcbiAgb3BlbiBUXG5cbiAgbGV0IGlzX3Bvc2l0aXZlIHQgPSBjb21wYXJlIHQgemVybyA+IDBcbiAgbGV0IGlzX25vbl9uZWdhdGl2ZSB0ID0gY29tcGFyZSB0IHplcm8gPj0gMFxuICBsZXQgaXNfbmVnYXRpdmUgdCA9IGNvbXBhcmUgdCB6ZXJvIDwgMFxuICBsZXQgaXNfbm9uX3Bvc2l0aXZlIHQgPSBjb21wYXJlIHQgemVybyA8PSAwXG4gIGxldCBzaWduIHQgPSBTaWduMC5vZl9pbnQgKGNvbXBhcmUgdCB6ZXJvKVxuZW5kXG5cbm1vZHVsZSBQb2x5IChUIDogc2lnXG4gICAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gICAgdmFsIHNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgICBbQEBAZW5kXVxuICBlbmQpID1cbnN0cnVjdFxuICBtb2R1bGUgUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlID0gc3RydWN0XG4gICAgdHlwZSB0ID0gVC50IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gICAgbGV0IHNleHBfb2ZfdCA9IChULnNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuXG4gICAgW0BAQGVuZF1cblxuICAgIGluY2x1ZGUgUG9seVxuICBlbmRcblxuICBpbmNsdWRlIFBvbHlcblxuICBsZXQgYmV0d2VlbiB0IH5sb3cgfmhpZ2ggPSBsb3cgPD0gdCAmJiB0IDw9IGhpZ2hcbiAgbGV0IGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heCA9IGlmIHQgPCBtaW4gdGhlbiBtaW4gZWxzZSBpZiB0IDw9IG1heCB0aGVuIHQgZWxzZSBtYXhcblxuICBsZXQgY2xhbXBfZXhuIHQgfm1pbiB+bWF4ID1cbiAgICBhc3NlcnQgKG1pbiA8PSBtYXgpO1xuICAgIGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heFxuICA7O1xuXG4gIGxldCBjbGFtcCB0IH5taW4gfm1heCA9XG4gICAgaWYgbWluID4gbWF4XG4gICAgdGhlblxuICAgICAgT3JfZXJyb3IuZXJyb3Jfc1xuICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgIFwiY2xhbXAgcmVxdWlyZXMgW21pbiA8PSBtYXhdXCJcbiAgICAgICAgICAgWyBcIm1pblwiLCBULnNleHBfb2ZfdCBtaW47IFwibWF4XCIsIFQuc2V4cF9vZl90IG1heCBdKVxuICAgIGVsc2UgT2sgKGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heClcbiAgOztcblxuICBtb2R1bGUgQyA9IHN0cnVjdFxuICAgIGluY2x1ZGUgVFxuICAgIGluY2x1ZGUgQ29tcGFyYXRvci5NYWtlIChSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUpXG4gIGVuZFxuXG4gIGluY2x1ZGUgQ1xuZW5kXG5cbmxldCBndCBjbXAgYSBiID0gY21wIGEgYiA+IDBcbmxldCBsdCBjbXAgYSBiID0gY21wIGEgYiA8IDBcbmxldCBnZXEgY21wIGEgYiA9IGNtcCBhIGIgPj0gMFxubGV0IGxlcSBjbXAgYSBiID0gY21wIGEgYiA8PSAwXG5sZXQgZXF1YWwgY21wIGEgYiA9IGNtcCBhIGIgPSAwXG5sZXQgbm90X2VxdWFsIGNtcCBhIGIgPSBjbXAgYSBiIDw+IDBcbmxldCBtaW4gY21wIHQgdCcgPSBpZiBsZXEgY21wIHQgdCcgdGhlbiB0IGVsc2UgdCdcbmxldCBtYXggY21wIHQgdCcgPSBpZiBnZXEgY21wIHQgdCcgdGhlbiB0IGVsc2UgdCdcblxubW9kdWxlIEluZml4IChUIDogc2lnXG4gICAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlXVxuXG4gICAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcblxuICAgIFtAQEBlbmRdXG4gIGVuZCkgOiBJbmZpeCB3aXRoIHR5cGUgdCA6PSBULnQgPSBzdHJ1Y3RcbiAgbGV0ICggPiApIGEgYiA9IGd0IFQuY29tcGFyZSBhIGJcbiAgbGV0ICggPCApIGEgYiA9IGx0IFQuY29tcGFyZSBhIGJcbiAgbGV0ICggPj0gKSBhIGIgPSBnZXEgVC5jb21wYXJlIGEgYlxuICBsZXQgKCA8PSApIGEgYiA9IGxlcSBULmNvbXBhcmUgYSBiXG4gIGxldCAoID0gKSBhIGIgPSBlcXVhbCBULmNvbXBhcmUgYSBiXG4gIGxldCAoIDw+ICkgYSBiID0gbm90X2VxdWFsIFQuY29tcGFyZSBhIGJcbmVuZFxuXG5tb2R1bGUgUG9seW1vcnBoaWNfY29tcGFyZSAoVCA6IHNpZ1xuICAgIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZV1cblxuICAgIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkNvbXBhcmFibGUuUyB3aXRoIHR5cGUgdCA6PSB0XG5cbiAgICBbQEBAZW5kXVxuICBlbmQpIDogUG9seW1vcnBoaWNfY29tcGFyZSB3aXRoIHR5cGUgdCA6PSBULnQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBJbmZpeCAoVClcblxuICBsZXQgY29tcGFyZSA9IFQuY29tcGFyZVxuICBsZXQgZXF1YWwgPSAoID0gKVxuICBsZXQgbWluIHQgdCcgPSBtaW4gY29tcGFyZSB0IHQnXG4gIGxldCBtYXggdCB0JyA9IG1heCBjb21wYXJlIHQgdCdcbmVuZFxuXG5tb2R1bGUgTWFrZV91c2luZ19jb21wYXJhdG9yIChUIDogc2lnXG4gICAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gICAgdmFsIHNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgICBbQEBAZW5kXVxuXG4gICAgaW5jbHVkZSBDb21wYXJhdG9yLlMgd2l0aCB0eXBlIHQgOj0gdFxuICBlbmQpIDogUyB3aXRoIHR5cGUgdCA6PSBULnQgYW5kIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gVC5jb21wYXJhdG9yX3dpdG5lc3MgPSBzdHJ1Y3RcbiAgbW9kdWxlIFQgPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIFRcblxuICAgIGxldCBjb21wYXJlID0gY29tcGFyYXRvci5jb21wYXJlXG4gIGVuZFxuXG4gIGluY2x1ZGUgVFxuICBtb2R1bGUgUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlID0gUG9seW1vcnBoaWNfY29tcGFyZSAoVClcbiAgaW5jbHVkZSBSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxuICBsZXQgYXNjZW5kaW5nID0gY29tcGFyZVxuICBsZXQgZGVzY2VuZGluZyB0IHQnID0gY29tcGFyZSB0JyB0XG4gIGxldCBiZXR3ZWVuIHQgfmxvdyB+aGlnaCA9IGxvdyA8PSB0ICYmIHQgPD0gaGlnaFxuICBsZXQgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4ID0gaWYgdCA8IG1pbiB0aGVuIG1pbiBlbHNlIGlmIHQgPD0gbWF4IHRoZW4gdCBlbHNlIG1heFxuXG4gIGxldCBjbGFtcF9leG4gdCB+bWluIH5tYXggPVxuICAgIGFzc2VydCAobWluIDw9IG1heCk7XG4gICAgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4XG4gIDs7XG5cbiAgbGV0IGNsYW1wIHQgfm1pbiB+bWF4ID1cbiAgICBpZiBtaW4gPiBtYXhcbiAgICB0aGVuXG4gICAgICBPcl9lcnJvci5lcnJvcl9zXG4gICAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgICAgXCJjbGFtcCByZXF1aXJlcyBbbWluIDw9IG1heF1cIlxuICAgICAgICAgICBbIFwibWluXCIsIFQuc2V4cF9vZl90IG1pbjsgXCJtYXhcIiwgVC5zZXhwX29mX3QgbWF4IF0pXG4gICAgZWxzZSBPayAoY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4KVxuICA7O1xuZW5kXG5cbm1vZHVsZSBNYWtlIChUIDogc2lnXG4gICAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBzZXhwX29mXVxuXG4gICAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcblxuICAgIHZhbCBzZXhwX29mX3QgOiB0IC0+IFNleHBsaWIwLlNleHAudFxuXG4gICAgW0BAQGVuZF1cbiAgZW5kKSA9XG4gIE1ha2VfdXNpbmdfY29tcGFyYXRvciAoc3RydWN0XG4gICAgaW5jbHVkZSBUXG4gICAgaW5jbHVkZSBDb21wYXJhdG9yLk1ha2UgKFQpXG4gIGVuZClcblxubW9kdWxlIEluaGVyaXQgKEMgOiBzaWdcbiAgICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmVdXG5cbiAgICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gICAgW0BAQGVuZF1cbiAgZW5kKSAoVCA6IHNpZ1xuICAgICAgICAgIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICAgICAgICAgIHZhbCBzZXhwX29mX3QgOiB0IC0+IFNleHBsaWIwLlNleHAudFxuXG4gICAgICAgICAgW0BAQGVuZF1cblxuICAgICAgICAgIHZhbCBjb21wb25lbnQgOiB0IC0+IEMudFxuICAgICAgICBlbmQpID1cbiAgTWFrZSAoc3RydWN0XG4gICAgdHlwZSB0ID0gVC50IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gICAgbGV0IHNleHBfb2ZfdCA9IChULnNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuXG4gICAgW0BAQGVuZF1cblxuICAgIGxldCBjb21wYXJlIHQgdCcgPSBDLmNvbXBhcmUgKFQuY29tcG9uZW50IHQpIChULmNvbXBvbmVudCB0JylcbiAgZW5kKVxuXG4oKiBjb21wYXJlIFt4XSBhbmQgW3ldIGxleGljb2dyYXBoaWNhbGx5IHVzaW5nIGZ1bmN0aW9ucyBpbiB0aGUgbGlzdCBbY21wc10gKilcbmxldCBsZXhpY29ncmFwaGljIGNtcHMgeCB5ID1cbiAgbGV0IHJlYyBsb29wID0gZnVuY3Rpb25cbiAgICB8IGNtcCA6OiBjbXBzIC0+XG4gICAgICBsZXQgcmVzID0gY21wIHggeSBpblxuICAgICAgaWYgcmVzID0gMCB0aGVuIGxvb3AgY21wcyBlbHNlIHJlc1xuICAgIHwgW10gLT4gMFxuICBpblxuICBsb29wIGNtcHNcbjs7XG5cbmxldCBsaWZ0IGNtcCB+ZiB4IHkgPSBjbXAgKGYgeCkgKGYgeSlcbmxldCByZXZlcnNlIGNtcCB4IHkgPSBjbXAgeSB4XG4iLCJvcGVuISBJbXBvcnRcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5IYXNoYWJsZS5LZXkgKilcbm1vZHVsZSB0eXBlIEtleSA9IHNpZ1xuICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIHNleHBfb2ZdXG5cbiAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcblxuICB2YWwgc2V4cF9vZl90IDogdCAtPiBTZXhwbGliMC5TZXhwLnRcblxuICBbQEBAZW5kXVxuXG4gICgqKiBWYWx1ZXMgcmV0dXJuZWQgYnkgW2hhc2hdIG11c3QgYmUgbm9uLW5lZ2F0aXZlLiAgQW4gZXhjZXB0aW9uIHdpbGwgYmUgcmFpc2VkIGluIHRoZVxuICAgICAgY2FzZSB0aGF0IFtoYXNoXSByZXR1cm5zIGEgbmVnYXRpdmUgdmFsdWUuICopXG4gIHZhbCBoYXNoIDogdCAtPiBpbnRcbmVuZFxuXG5tb2R1bGUgSGFzaGFibGUgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID1cbiAgICB7IGhhc2ggOiAnYSAtPiBpbnRcbiAgICA7IGNvbXBhcmUgOiAnYSAtPiAnYSAtPiBpbnRcbiAgICA7IHNleHBfb2ZfdCA6ICdhIC0+IFNleHAudFxuICAgIH1cblxuICAoKiogVGhpcyBmdW5jdGlvbiBpcyBzb3VuZCBidXQgbm90IGNvbXBsZXRlLCBtZWFuaW5nIHRoYXQgaWYgaXQgcmV0dXJucyBbdHJ1ZV0gdGhlbiBpdCdzXG4gICAgICBzYWZlIHRvIHVzZSB0aGUgdHdvIGludGVyY2hhbmdlYWJseS4gIElmIGl0J3MgW2ZhbHNlXSwgeW91IGhhdmUgbm8gZ3VhcmFudGVlcy4gIEZvclxuICAgICAgZXhhbXBsZTpcblxuICAgICAge1tcbiAgICAgICAgPiB1dG9wXG4gICAgICAgIG9wZW4gQ29yZTs7XG4gICAgICAgIGxldCBlcXVhbCAoYSA6ICdhIEhhc2h0YmxfaW50Zi5IYXNoYWJsZS50KSBiID1cbiAgICAgICAgICBwaHlzX2VxdWFsIGEgYlxuICAgICAgICAgIHx8IChwaHlzX2VxdWFsIGEuaGFzaCBiLmhhc2hcbiAgICAgICAgICAgICAgJiYgcGh5c19lcXVhbCBhLmNvbXBhcmUgYi5jb21wYXJlXG4gICAgICAgICAgICAgICYmIHBoeXNfZXF1YWwgYS5zZXhwX29mX3QgYi5zZXhwX29mX3QpXG4gICAgICAgIDs7XG4gICAgICAgIGxldCBhID0gSGFzaHRibF9pbnRmLkhhc2hhYmxlLnsgaGFzaDsgY29tcGFyZTsgc2V4cF9vZl90ID0gSW50LnNleHBfb2ZfdCB9OztcbiAgICAgICAgbGV0IGIgPSBIYXNodGJsX2ludGYuSGFzaGFibGUueyBoYXNoOyBjb21wYXJlOyBzZXhwX29mX3QgPSBJbnQuc2V4cF9vZl90IH07O1xuICAgICAgICBlcXVhbCBhIGI7OyAgKCogZmFsc2U/ISAqKVxuICAgICAgXX1cbiAgKilcbiAgbGV0IGVxdWFsIGEgYiA9XG4gICAgcGh5c19lcXVhbCBhIGJcbiAgICB8fCAocGh5c19lcXVhbCBhLmhhc2ggYi5oYXNoXG4gICAgICAgICYmIHBoeXNfZXF1YWwgYS5jb21wYXJlIGIuY29tcGFyZVxuICAgICAgICAmJiBwaHlzX2VxdWFsIGEuc2V4cF9vZl90IGIuc2V4cF9vZl90KVxuICA7O1xuXG4gIGxldCBoYXNoX3BhcmFtID0gQ2FtbC5IYXNodGJsLmhhc2hfcGFyYW1cbiAgbGV0IGhhc2ggPSBDYW1sLkhhc2h0YmwuaGFzaFxuICBsZXQgcG9seSA9IHsgaGFzaDsgY29tcGFyZSA9IFBvbHkuY29tcGFyZTsgc2V4cF9vZl90ID0gKGZ1biBfIC0+IFNleHAuQXRvbSBcIl9cIikgfVxuXG4gIGxldCBvZl9rZXkgKHR5cGUgYSkgKG1vZHVsZSBLZXkgOiBLZXkgd2l0aCB0eXBlIHQgPSBhKSA9XG4gICAgeyBoYXNoID0gS2V5Lmhhc2g7IGNvbXBhcmUgPSBLZXkuY29tcGFyZTsgc2V4cF9vZl90ID0gS2V5LnNleHBfb2ZfdCB9XG4gIDs7XG5cbiAgbGV0IHRvX2tleSAodHlwZSBhKSB7IGhhc2g7IGNvbXBhcmU7IHNleHBfb2ZfdCB9ID1cbiAgICAobW9kdWxlIHN0cnVjdFxuICAgICAgdHlwZSB0ID0gYVxuXG4gICAgICBsZXQgaGFzaCA9IGhhc2hcbiAgICAgIGxldCBjb21wYXJlID0gY29tcGFyZVxuICAgICAgbGV0IHNleHBfb2ZfdCA9IHNleHBfb2ZfdFxuICAgIGVuZCA6IEtleVxuICAgICAgd2l0aCB0eXBlIHQgPSBhKVxuICA7O1xuZW5kXG5cbmluY2x1ZGUgSGFzaGFibGVcblxubW9kdWxlIHR5cGUgSGFzaGFibGUgPSBzaWdcbiAgdHlwZSAnYSB0ID0gJ2EgSGFzaGFibGUudCA9XG4gICAgeyBoYXNoIDogJ2EgLT4gaW50XG4gICAgOyBjb21wYXJlIDogJ2EgLT4gJ2EgLT4gaW50XG4gICAgOyBzZXhwX29mX3QgOiAnYSAtPiBTZXhwLnRcbiAgICB9XG5cbiAgdmFsIGVxdWFsIDogJ2EgdCAtPiAnYSB0IC0+IGJvb2xcbiAgdmFsIHBvbHkgOiAnYSB0XG4gIHZhbCBvZl9rZXkgOiAobW9kdWxlIEtleSB3aXRoIHR5cGUgdCA9ICdhKSAtPiAnYSB0XG4gIHZhbCB0b19rZXkgOiAnYSB0IC0+IChtb2R1bGUgS2V5IHdpdGggdHlwZSB0ID0gJ2EpXG4gIHZhbCBoYXNoX3BhcmFtIDogaW50IC0+IGludCAtPiAnYSAtPiBpbnRcbiAgdmFsIGhhc2ggOiAnYSAtPiBpbnRcbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIElkZW50aWZpYWJsZV9pbnRmXG5cbm1vZHVsZSBNYWtlIChUIDogQXJnKSA9IHN0cnVjdFxuICBpbmNsdWRlIFRcbiAgaW5jbHVkZSBDb21wYXJhYmxlLk1ha2UgKFQpXG4gIGluY2x1ZGUgUHJldHR5X3ByaW50ZXIuUmVnaXN0ZXIgKFQpXG5cbiAgbGV0IGhhc2hhYmxlIDogdCBIYXNoYWJsZS50ID0geyBoYXNoOyBjb21wYXJlOyBzZXhwX29mX3QgfVxuZW5kXG5cbm1vZHVsZSBNYWtlX3VzaW5nX2NvbXBhcmF0b3IgKFQgOiBBcmdfd2l0aF9jb21wYXJhdG9yKSA9IHN0cnVjdFxuICBpbmNsdWRlIFRcbiAgaW5jbHVkZSBDb21wYXJhYmxlLk1ha2VfdXNpbmdfY29tcGFyYXRvciAoVClcbiAgaW5jbHVkZSBQcmV0dHlfcHJpbnRlci5SZWdpc3RlciAoVClcblxuICBsZXQgaGFzaGFibGUgOiB0IEhhc2hhYmxlLnQgPSB7IGhhc2g7IGNvbXBhcmU7IHNleHBfb2ZfdCB9XG5lbmRcbiIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBPcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uMFxuXG5sZXQgZ2V0X3Bvc19sZW4gP3BvcyA/bGVuICgpIH50b3RhbF9sZW5ndGggPVxuICB0cnkgUmVzdWx0Lk9rIChnZXRfcG9zX2xlbl9leG4gKCkgP3BvcyA/bGVuIH50b3RhbF9sZW5ndGgpIHdpdGhcbiAgfCBJbnZhbGlkX2FyZ3VtZW50IHMgLT4gT3JfZXJyb3IuZXJyb3Jfc3RyaW5nIHNcbjs7XG4iLCJvcGVuISBJbXBvcnRcblxuKCogVGhlc2UgZnVuY3Rpb25zIGltcGxlbWVudCBhIHNlYXJjaCBmb3IgdGhlIGZpcnN0IChyZXNwLiBsYXN0KSBlbGVtZW50XG4gICBzYXRpc2Z5aW5nIGEgcHJlZGljYXRlLCBhc3N1bWluZyB0aGF0IHRoZSBwcmVkaWNhdGUgaXMgaW5jcmVhc2luZyBvblxuICAgdGhlIGNvbnRhaW5lciwgbWVhbmluZyB0aGF0LCBpZiB0aGUgY29udGFpbmVyIGlzIFt1MS4uLnVuXSwgdGhlcmUgZXhpc3RzIGFcbiAgIGsgc3VjaCB0aGF0IHAodTEpPS4uLi49cCh1aykgPSBmYWxzZSBhbmQgcCh1aysxKT0uLi4uPXAodW4pPSB0cnVlLlxuICAgSWYgdGhpcyBrID0gMSAocmVzcCBuKSwgZmluZF9sYXN0X25vdF9zYXRpc2Z5aW5nIChyZXNwIGZpbmRfZmlyc3Rfc2F0aXNmeWluZylcbiAgIHdpbGwgcmV0dXJuIE5vbmUuICopXG5cbmxldCByZWMgbGluZWFyX3NlYXJjaF9maXJzdF9zYXRpc2Z5aW5nIHQgfmdldCB+bG8gfmhpIH5wcmVkID1cbiAgaWYgbG8gPiBoaVxuICB0aGVuIE5vbmVcbiAgZWxzZSBpZiBwcmVkIChnZXQgdCBsbylcbiAgdGhlbiBTb21lIGxvXG4gIGVsc2UgbGluZWFyX3NlYXJjaF9maXJzdF9zYXRpc2Z5aW5nIHQgfmdldCB+bG86KGxvICsgMSkgfmhpIH5wcmVkXG47O1xuXG4oKiBUYWtlcyBhIGNvbnRhaW5lciBbdF0sIGEgcHJlZGljYXRlIFtwcmVkXSBhbmQgdHdvIGluZGljZXMgW2xvIDwgaGldLCBzdWNoIHRoYXRcbiAgIFtwcmVkXSBpcyBpbmNyZWFzaW5nIG9uIFt0XSBiZXR3ZWVuIFtsb10gYW5kIFtoaV0uXG5cbiAgIHJldHVybiBhIHJhbmdlIChsbywgaGkpIHdoZXJlOlxuICAgLSBsbyBhbmQgaGkgYXJlIGNsb3NlIGVub3VnaCB0b2dldGhlciBmb3IgYSBsaW5lYXIgc2VhcmNoXG4gICAtIElmIFtwcmVkXSBpcyBub3QgY29uc3RhbnRseSBbZmFsc2VdIG9uIFt0XSBiZXR3ZWVuIFtsb10gYW5kIFtoaV0sIHRoZSBmaXJzdCBlbGVtZW50XG4gICAgIG9uIHdoaWNoIFtwcmVkXSBpcyBbdHJ1ZV0gaXMgYmV0d2VlbiBbbG9dIGFuZCBbaGldLiAqKVxuKCogSW52YXJpYW50OiB0aGUgZmlyc3QgZWxlbWVudCBzYXRpc2Z5aW5nIFtwcmVkXSwgaWYgaXQgZXhpc3RzIGlzIGJldHdlZW4gW2xvXSBhbmQgW2hpXSAqKVxubGV0IHJlYyBmaW5kX3JhbmdlX25lYXJfZmlyc3Rfc2F0aXNmeWluZyB0IH5nZXQgfmxvIH5oaSB+cHJlZCA9XG4gICgqIFdhcm5pbmc6IHRoaXMgZnVuY3Rpb24gd2lsbCBub3QgdGVybWluYXRlIGlmIHRoZSBjb25zdGFudCAoY3VycmVudGx5IDgpIGlzXG4gICAgIHNldCA8PSAxICopXG4gIGlmIGhpIC0gbG8gPD0gOFxuICB0aGVuIGxvLCBoaVxuICBlbHNlIChcbiAgICBsZXQgbWlkID0gbG8gKyAoKGhpIC0gbG8pIC8gMikgaW5cbiAgICBpZiBwcmVkIChnZXQgdCBtaWQpXG4gICAgKCogSU5WQVJJQU5UIGNoZWNrOiBpdCBtZWFucyB0aGUgZmlyc3Qgc2F0aXNmeWluZyBlbGVtZW50IGlzIGJldHdlZW4gW2xvXSBhbmQgW21pZF0gKilcbiAgICB0aGVuXG4gICAgICBmaW5kX3JhbmdlX25lYXJfZmlyc3Rfc2F0aXNmeWluZyB0IH5nZXQgfmxvIH5oaTptaWQgfnByZWRcbiAgICAgICgqIElOVkFSSUFOVCBjaGVjazogaXQgbWVhbnMgdGhlIGZpcnN0IHNhdGlzZnlpbmcgZWxlbWVudCwgaWYgaXQgZXhpc3RzLFxuICAgICAgICAgaXMgYmV0d2VlbiBbbWlkKzFdIGFuZCBbaGldICopXG4gICAgZWxzZSBmaW5kX3JhbmdlX25lYXJfZmlyc3Rfc2F0aXNmeWluZyB0IH5nZXQgfmxvOihtaWQgKyAxKSB+aGkgfnByZWQpXG47O1xuXG5sZXQgZmluZF9maXJzdF9zYXRpc2Z5aW5nID9wb3MgP2xlbiB0IH5nZXQgfmxlbmd0aCB+cHJlZCA9XG4gIGxldCBwb3MsIGxlbiA9XG4gICAgT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbi5nZXRfcG9zX2xlbl9leG4gKCkgP3BvcyA/bGVuIH50b3RhbF9sZW5ndGg6KGxlbmd0aCB0KVxuICBpblxuICBsZXQgbG8gPSBwb3MgaW5cbiAgbGV0IGhpID0gcG9zICsgbGVuIC0gMSBpblxuICBsZXQgbG8sIGhpID0gZmluZF9yYW5nZV9uZWFyX2ZpcnN0X3NhdGlzZnlpbmcgdCB+Z2V0IH5sbyB+aGkgfnByZWQgaW5cbiAgbGluZWFyX3NlYXJjaF9maXJzdF9zYXRpc2Z5aW5nIHQgfmdldCB+bG8gfmhpIH5wcmVkXG47O1xuXG4oKiBUYWtlcyBhbiBhcnJheSB3aXRoIHNoYXBlIFt0cnVlLC4uLnRydWUsZmFsc2UsLi4uZmFsc2VdIChpLmUuLCB0aGUgX3JldmVyc2VfIG9mIHdoYXRcbiAgIGlzIGRlc2NyaWJlZCBhYm92ZSkgYW5kIHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBsYXN0IHRydWUgb3IgTm9uZSBpZiB0aGVyZSBhcmUgbm9cbiAgIHRydWUqKVxubGV0IGZpbmRfbGFzdF9zYXRpc2Z5aW5nID9wb3MgP2xlbiB0IH5wcmVkIH5nZXQgfmxlbmd0aCA9XG4gIGxldCBwb3MsIGxlbiA9XG4gICAgT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbi5nZXRfcG9zX2xlbl9leG4gKCkgP3BvcyA/bGVuIH50b3RhbF9sZW5ndGg6KGxlbmd0aCB0KVxuICBpblxuICBpZiBsZW4gPSAwXG4gIHRoZW4gTm9uZVxuICBlbHNlIChcbiAgICAoKiBUaGUgbGFzdCBzYXRpc2Z5aW5nIGlzIHRoZSBvbmUganVzdCBiZWZvcmUgdGhlIGZpcnN0IG5vdCBzYXRpc2Z5aW5nICopXG4gICAgbWF0Y2ggZmluZF9maXJzdF9zYXRpc2Z5aW5nIH5wb3MgfmxlbiB0IH5nZXQgfmxlbmd0aCB+cHJlZDooRm4ubm9uIHByZWQpIHdpdGhcbiAgICB8IE5vbmUgLT4gU29tZSAocG9zICsgbGVuIC0gMSlcbiAgICAoKiBUaGlzIG1lYW5zIHRoYXQgYWxsIGVsZW1lbnRzIHNhdGlzZnkgcHJlZC5cbiAgICAgICBUaGVyZSBpcyBhdCBsZWFzdCBhbiBlbGVtZW50IGFzIChsZW4gPiAwKSAqKVxuICAgIHwgU29tZSBpIHdoZW4gaSA9IHBvcyAtPiBOb25lICgqIG5vIGVsZW1lbnQgc2F0aXNmaWVzIHByZWQgKilcbiAgICB8IFNvbWUgaSAtPiBTb21lIChpIC0gMSkpXG47O1xuXG5sZXQgYmluYXJ5X3NlYXJjaCA/cG9zID9sZW4gdCB+bGVuZ3RoIH5nZXQgfmNvbXBhcmUgaG93IHYgPVxuICBtYXRjaCBob3cgd2l0aFxuICB8IGBMYXN0X3N0cmljdGx5X2xlc3NfdGhhbiAtPlxuICAgIGZpbmRfbGFzdF9zYXRpc2Z5aW5nID9wb3MgP2xlbiB0IH5nZXQgfmxlbmd0aCB+cHJlZDooZnVuIHggLT4gY29tcGFyZSB4IHYgPCAwKVxuICB8IGBMYXN0X2xlc3NfdGhhbl9vcl9lcXVhbF90byAtPlxuICAgIGZpbmRfbGFzdF9zYXRpc2Z5aW5nID9wb3MgP2xlbiB0IH5nZXQgfmxlbmd0aCB+cHJlZDooZnVuIHggLT4gY29tcGFyZSB4IHYgPD0gMClcbiAgfCBgRmlyc3RfZXF1YWxfdG8gLT5cbiAgICAobWF0Y2hcbiAgICAgICBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgP3BvcyA/bGVuIHQgfmdldCB+bGVuZ3RoIH5wcmVkOihmdW4geCAtPiBjb21wYXJlIHggdiA+PSAwKVxuICAgICB3aXRoXG4gICAgIHwgU29tZSB4IHdoZW4gY29tcGFyZSAoZ2V0IHQgeCkgdiA9IDAgLT4gU29tZSB4XG4gICAgIHwgTm9uZSB8IFNvbWUgXyAtPiBOb25lKVxuICB8IGBMYXN0X2VxdWFsX3RvIC0+XG4gICAgKG1hdGNoXG4gICAgICAgZmluZF9sYXN0X3NhdGlzZnlpbmcgP3BvcyA/bGVuIHQgfmdldCB+bGVuZ3RoIH5wcmVkOihmdW4geCAtPiBjb21wYXJlIHggdiA8PSAwKVxuICAgICB3aXRoXG4gICAgIHwgU29tZSB4IHdoZW4gY29tcGFyZSAoZ2V0IHQgeCkgdiA9IDAgLT4gU29tZSB4XG4gICAgIHwgTm9uZSB8IFNvbWUgXyAtPiBOb25lKVxuICB8IGBGaXJzdF9ncmVhdGVyX3RoYW5fb3JfZXF1YWxfdG8gLT5cbiAgICBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgP3BvcyA/bGVuIHQgfmdldCB+bGVuZ3RoIH5wcmVkOihmdW4geCAtPiBjb21wYXJlIHggdiA+PSAwKVxuICB8IGBGaXJzdF9zdHJpY3RseV9ncmVhdGVyX3RoYW4gLT5cbiAgICBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgP3BvcyA/bGVuIHQgfmdldCB+bGVuZ3RoIH5wcmVkOihmdW4geCAtPiBjb21wYXJlIHggdiA+IDApXG47O1xuXG5sZXQgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQgP3BvcyA/bGVuIHQgfmxlbmd0aCB+Z2V0IH5zZWdtZW50X29mIGhvdyA9XG4gIGxldCBpc19sZWZ0IHggPVxuICAgIG1hdGNoIHNlZ21lbnRfb2YgeCB3aXRoXG4gICAgfCBgTGVmdCAtPiB0cnVlXG4gICAgfCBgUmlnaHQgLT4gZmFsc2VcbiAgaW5cbiAgbGV0IGlzX3JpZ2h0IHggPSBub3QgKGlzX2xlZnQgeCkgaW5cbiAgbWF0Y2ggaG93IHdpdGhcbiAgfCBgTGFzdF9vbl9sZWZ0IC0+IGZpbmRfbGFzdF9zYXRpc2Z5aW5nID9wb3MgP2xlbiB0IH5sZW5ndGggfmdldCB+cHJlZDppc19sZWZ0XG4gIHwgYEZpcnN0X29uX3JpZ2h0IC0+IGZpbmRfZmlyc3Rfc2F0aXNmeWluZyA/cG9zID9sZW4gdCB+bGVuZ3RoIH5nZXQgfnByZWQ6aXNfcmlnaHRcbjs7XG4iLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgQmluYXJ5X3NlYXJjaGFibGVfaW50ZlxuXG5tb2R1bGUgdHlwZSBBcmcgPSBzaWdcbiAgdHlwZSAnYSBlbHRcbiAgdHlwZSAnYSB0XG5cbiAgdmFsIGdldCA6ICdhIHQgLT4gaW50IC0+ICdhIGVsdFxuICB2YWwgbGVuZ3RoIDogXyB0IC0+IGludFxuZW5kXG5cbm1vZHVsZSBNYWtlX2dlbiAoVCA6IEFyZykgPSBzdHJ1Y3RcbiAgbGV0IGdldCA9IFQuZ2V0XG4gIGxldCBsZW5ndGggPSBULmxlbmd0aFxuXG4gIGxldCBiaW5hcnlfc2VhcmNoID9wb3MgP2xlbiB0IH5jb21wYXJlIGhvdyB2ID1cbiAgICBCaW5hcnlfc2VhcmNoLmJpbmFyeV9zZWFyY2ggP3BvcyA/bGVuIHQgfmdldCB+bGVuZ3RoIH5jb21wYXJlIGhvdyB2XG4gIDs7XG5cbiAgbGV0IGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkID9wb3MgP2xlbiB0IH5zZWdtZW50X29mIGhvdyA9XG4gICAgQmluYXJ5X3NlYXJjaC5iaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCA/cG9zID9sZW4gdCB+Z2V0IH5sZW5ndGggfnNlZ21lbnRfb2YgaG93XG4gIDs7XG5lbmRcblxubW9kdWxlIE1ha2UgKFQgOiBJbmRleGFibGUpID0gTWFrZV9nZW4gKHN0cnVjdFxuICAgIGluY2x1ZGUgVFxuXG4gICAgdHlwZSAnYSBlbHQgPSBULmVsdFxuICAgIHR5cGUgJ2EgdCA9IFQudFxuICBlbmQpXG5cbm1vZHVsZSBNYWtlMSAoVCA6IEluZGV4YWJsZTEpID0gTWFrZV9nZW4gKHN0cnVjdFxuICAgIHR5cGUgJ2EgZWx0ID0gJ2FcbiAgICB0eXBlICdhIHQgPSAnYSBULnRcblxuICAgIGxldCBnZXQgPSBULmdldFxuICAgIGxldCBsZW5ndGggPSBULmxlbmd0aFxuICBlbmQpXG4iLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgQmxpdF9pbnRmXG5cbm1vZHVsZSB0eXBlIFNlcXVlbmNlX2dlbiA9IHNpZ1xuICB0eXBlICdhIHRcblxuICB2YWwgbGVuZ3RoIDogXyB0IC0+IGludFxuZW5kXG5cbm1vZHVsZSBNYWtlX2dlblxuICAgIChTcmMgOiBTZXF1ZW5jZV9nZW4pIChEc3QgOiBzaWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmNsdWRlIFNlcXVlbmNlX2dlblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsIGNyZWF0ZV9saWtlIDogbGVuOmludCAtPiAnYSBTcmMudCAtPiAnYSB0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsIHVuc2FmZV9ibGl0IDogKCdhIFNyYy50LCAnYSB0KSBibGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCkgPVxuc3RydWN0XG4gIGxldCB1bnNhZmVfYmxpdCA9IERzdC51bnNhZmVfYmxpdFxuXG4gIGxldCBibGl0IH5zcmMgfnNyY19wb3MgfmRzdCB+ZHN0X3BvcyB+bGVuID1cbiAgICBPcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uLmNoZWNrX3Bvc19sZW5fZXhuXG4gICAgICB+cG9zOnNyY19wb3NcbiAgICAgIH5sZW5cbiAgICAgIH50b3RhbF9sZW5ndGg6KFNyYy5sZW5ndGggc3JjKTtcbiAgICBPcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uLmNoZWNrX3Bvc19sZW5fZXhuXG4gICAgICB+cG9zOmRzdF9wb3NcbiAgICAgIH5sZW5cbiAgICAgIH50b3RhbF9sZW5ndGg6KERzdC5sZW5ndGggZHN0KTtcbiAgICBpZiBsZW4gPiAwIHRoZW4gdW5zYWZlX2JsaXQgfnNyYyB+c3JjX3BvcyB+ZHN0IH5kc3RfcG9zIH5sZW5cbiAgOztcblxuICBsZXQgYmxpdG9cbiAgICAgICAgfnNyY1xuICAgICAgICA/KHNyY19wb3MgPSAwKVxuICAgICAgICA/KHNyY19sZW4gPSBTcmMubGVuZ3RoIHNyYyAtIHNyY19wb3MpXG4gICAgICAgIH5kc3RcbiAgICAgICAgPyhkc3RfcG9zID0gMClcbiAgICAgICAgKClcbiAgICA9XG4gICAgYmxpdCB+c3JjIH5zcmNfcG9zIH5sZW46c3JjX2xlbiB+ZHN0IH5kc3RfcG9zXG4gIDs7XG5cbiAgKCogW3N1Yl0gYW5kIFtzdWJvXSBlbnN1cmUgdGhhdCBldmVyeSBwb3NpdGlvbiBvZiB0aGUgY3JlYXRlZCBzZXF1ZW5jZSBpcyBwb3B1bGF0ZWQgYnlcbiAgICAgYW4gZWxlbWVudCBvZiB0aGUgc291cmNlIGFycmF5LiAgVGh1cyBldmVyeSBlbGVtZW50IG9mIFtkc3RdIGJlbG93IGlzIHdlbGxcbiAgICAgZGVmaW5lZC4gKilcbiAgbGV0IHN1YiBzcmMgfnBvcyB+bGVuID1cbiAgICBPcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uLmNoZWNrX3Bvc19sZW5fZXhuIH5wb3MgfmxlbiB+dG90YWxfbGVuZ3RoOihTcmMubGVuZ3RoIHNyYyk7XG4gICAgbGV0IGRzdCA9IERzdC5jcmVhdGVfbGlrZSB+bGVuIHNyYyBpblxuICAgIGlmIGxlbiA+IDAgdGhlbiB1bnNhZmVfYmxpdCB+c3JjIH5zcmNfcG9zOnBvcyB+ZHN0IH5kc3RfcG9zOjAgfmxlbjtcbiAgICBkc3RcbiAgOztcblxuICBsZXQgc3VibyA/KHBvcyA9IDApID9sZW4gc3JjID1cbiAgICBzdWJcbiAgICAgIHNyY1xuICAgICAgfnBvc1xuICAgICAgfmxlbjpcbiAgICAgICAgKG1hdGNoIGxlbiB3aXRoXG4gICAgICAgICB8IFNvbWUgaSAtPiBpXG4gICAgICAgICB8IE5vbmUgLT4gU3JjLmxlbmd0aCBzcmMgLSBwb3MpXG4gIDs7XG5lbmRcblxubW9kdWxlIE1ha2UxIChTZXF1ZW5jZSA6IHNpZ1xuICAgIGluY2x1ZGUgU2VxdWVuY2VfZ2VuXG5cbiAgICB2YWwgY3JlYXRlX2xpa2UgOiBsZW46aW50IC0+ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCB1bnNhZmVfYmxpdCA6ICgnYSB0LCAnYSB0KSBibGl0XG4gIGVuZCkgPVxuICBNYWtlX2dlbiAoU2VxdWVuY2UpIChTZXF1ZW5jZSlcblxubW9kdWxlIE1ha2UxX2dlbmVyaWMgKFNlcXVlbmNlIDogU2VxdWVuY2UxKSA9IE1ha2VfZ2VuIChTZXF1ZW5jZSkgKFNlcXVlbmNlKVxuXG5tb2R1bGUgTWFrZSAoU2VxdWVuY2UgOiBzaWdcbiAgICBpbmNsdWRlIFNlcXVlbmNlXG5cbiAgICB2YWwgY3JlYXRlIDogbGVuOmludCAtPiB0XG4gICAgdmFsIHVuc2FmZV9ibGl0IDogKHQsIHQpIGJsaXRcbiAgZW5kKSA9XG5zdHJ1Y3RcbiAgbW9kdWxlIFNlcXVlbmNlID0gc3RydWN0XG4gICAgdHlwZSAnYSB0ID0gU2VxdWVuY2UudFxuXG4gICAgb3BlbiBTZXF1ZW5jZVxuXG4gICAgbGV0IGNyZWF0ZV9saWtlIH5sZW4gXyA9IGNyZWF0ZSB+bGVuXG4gICAgbGV0IGxlbmd0aCA9IGxlbmd0aFxuICAgIGxldCB1bnNhZmVfYmxpdCA9IHVuc2FmZV9ibGl0XG4gIGVuZFxuXG4gIGluY2x1ZGUgTWFrZV9nZW4gKFNlcXVlbmNlKSAoU2VxdWVuY2UpXG5lbmRcblxubW9kdWxlIE1ha2VfZGlzdGluY3RcbiAgICAoU3JjIDogU2VxdWVuY2UpIChEc3QgOiBzaWdcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1ZGUgU2VxdWVuY2VcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsIGNyZWF0ZSA6IGxlbjppbnQgLT4gdFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsIHVuc2FmZV9ibGl0IDogKFNyYy50LCB0KSBibGl0XG4gICAgICAgICAgICAgICAgICAgICAgZW5kKSA9XG4gIE1ha2VfZ2VuXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gU3JjLnRcblxuICAgICAgb3BlbiBTcmNcblxuICAgICAgbGV0IGxlbmd0aCA9IGxlbmd0aFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSBEc3QudFxuXG4gICAgICBvcGVuIERzdFxuXG4gICAgICBsZXQgbGVuZ3RoID0gbGVuZ3RoXG4gICAgICBsZXQgY3JlYXRlX2xpa2UgfmxlbiBfID0gY3JlYXRlIH5sZW5cbiAgICAgIGxldCB1bnNhZmVfYmxpdCA9IHVuc2FmZV9ibGl0XG4gICAgZW5kKVxuXG5tb2R1bGUgTWFrZV90b19zdHJpbmcgKFQgOiBzaWdcbiAgICB0eXBlIHRcbiAgZW5kKVxuICAgIChUb19ieXRlcyA6IFNfZGlzdGluY3Qgd2l0aCB0eXBlIHNyYyA6PSBULnQgd2l0aCB0eXBlIGRzdCA6PSBieXRlcykgPVxuc3RydWN0XG4gIG9wZW4gVG9fYnl0ZXNcblxuICBsZXQgc3ViIHNyYyB+cG9zIH5sZW4gPVxuICAgIEJ5dGVzMC51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOihzdWIgc3JjIH5wb3MgfmxlbilcbiAgOztcblxuICBsZXQgc3VibyA/cG9zID9sZW4gc3JjID1cbiAgICBCeXRlczAudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTooc3VibyA/cG9zID9sZW4gc3JjKVxuICA7O1xuZW5kXG4iLCJvcGVuISBJbXBvcnRcblxuaW5jbHVkZSAoXG5zdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gJ2Egb3B0aW9uIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmUgOiAnYS4gKCdhIC0+ICdhIC0+IGludCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGludCA9IGNvbXBhcmVfb3B0aW9uXG5cbiAgbGV0IGhhc2hfZm9sZF90IDpcbiAgICAnYS5cbiAgICAoUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+ICdhIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgICAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGVcbiAgICAtPiAnYSB0XG4gICAgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlXG4gICAgPVxuICAgIGhhc2hfZm9sZF9vcHRpb25cbiAgOztcblxuICBsZXQgdF9vZl9zZXhwIDogJ2EuIChTZXhwbGliMC5TZXhwLnQgLT4gJ2EpIC0+IFNleHBsaWIwLlNleHAudCAtPiAnYSB0ID1cbiAgICBvcHRpb25fb2Zfc2V4cFxuICA7O1xuXG4gIGxldCBzZXhwX29mX3QgOiAnYS4gKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgdCAtPiBTZXhwbGliMC5TZXhwLnQgPVxuICAgIHNleHBfb2Zfb3B0aW9uXG4gIDs7XG5cbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6ICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50IC0+ICdhIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID1cbiAgICBmdW4gXydhX3NleHBfZ3JhbW1hciAtPiBvcHRpb25fc2V4cF9ncmFtbWFyIF8nYV9zZXhwX2dyYW1tYXJcbiAgOztcblxuICBbQEBAZW5kXVxuZW5kIDpcbnNpZ1xuICB0eXBlICdhIHQgPSAnYSBvcHRpb24gW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlMxIHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcbiAgaW5jbHVkZSBQcHhfaGFzaF9saWIuSGFzaGFibGUuUzEgd2l0aCB0eXBlICdhIHQgOj0gJ2EgdFxuICBpbmNsdWRlIFNleHBsaWIwLlNleHBhYmxlLlMxIHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcblxuICB2YWwgdF9zZXhwX2dyYW1tYXIgOiAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCAtPiAnYSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG5cbiAgW0BAQGVuZF1cbmVuZClcblxudHlwZSAnYSB0ID0gJ2Egb3B0aW9uID1cbiAgfCBOb25lXG4gIHwgU29tZSBvZiAnYVxuXG5sZXQgaXNfbm9uZSA9IGZ1bmN0aW9uXG4gIHwgTm9uZSAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuOztcblxubGV0IGlzX3NvbWUgPSBmdW5jdGlvblxuICB8IFNvbWUgXyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuOztcblxubGV0IHZhbHVlX21hcCBvIH5kZWZhdWx0IH5mID1cbiAgbWF0Y2ggbyB3aXRoXG4gIHwgU29tZSB4IC0+IGYgeFxuICB8IE5vbmUgLT4gZGVmYXVsdFxuOztcblxubGV0IGl0ZXIgbyB+ZiA9XG4gIG1hdGNoIG8gd2l0aFxuICB8IE5vbmUgLT4gKClcbiAgfCBTb21lIGEgLT4gZiBhXG47O1xuXG5sZXQgaW52YXJpYW50IGYgdCA9IGl0ZXIgdCB+ZlxuXG5sZXQgY2FsbCB4IH5mID1cbiAgbWF0Y2ggZiB3aXRoXG4gIHwgTm9uZSAtPiAoKVxuICB8IFNvbWUgZiAtPiBmIHhcbjs7XG5cbmxldCB2YWx1ZSB0IH5kZWZhdWx0ID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgTm9uZSAtPiBkZWZhdWx0XG4gIHwgU29tZSB4IC0+IHhcbjs7XG5cbmxldCB2YWx1ZV9leG4gP2hlcmUgP2Vycm9yID9tZXNzYWdlIHQgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBTb21lIHggLT4geFxuICB8IE5vbmUgLT5cbiAgICBsZXQgZXJyb3IgPVxuICAgICAgbWF0Y2ggaGVyZSwgZXJyb3IsIG1lc3NhZ2Ugd2l0aFxuICAgICAgfCBOb25lLCBOb25lLCBOb25lIC0+IEVycm9yLm9mX3N0cmluZyBcIk9wdGlvbi52YWx1ZV9leG4gTm9uZVwiXG4gICAgICB8IE5vbmUsIE5vbmUsIFNvbWUgbSAtPiBFcnJvci5vZl9zdHJpbmcgbVxuICAgICAgfCBOb25lLCBTb21lIGUsIE5vbmUgLT4gZVxuICAgICAgfCBOb25lLCBTb21lIGUsIFNvbWUgbSAtPiBFcnJvci50YWcgZSB+dGFnOm1cbiAgICAgIHwgU29tZSBwLCBOb25lLCBOb25lIC0+XG4gICAgICAgIEVycm9yLmNyZWF0ZSBcIk9wdGlvbi52YWx1ZV9leG5cIiBwIFNvdXJjZV9jb2RlX3Bvc2l0aW9uMC5zZXhwX29mX3RcbiAgICAgIHwgU29tZSBwLCBOb25lLCBTb21lIG0gLT4gRXJyb3IuY3JlYXRlIG0gcCBTb3VyY2VfY29kZV9wb3NpdGlvbjAuc2V4cF9vZl90XG4gICAgICB8IFNvbWUgcCwgU29tZSBlLCBfIC0+XG4gICAgICAgIEVycm9yLmNyZWF0ZVxuICAgICAgICAgICh2YWx1ZSBtZXNzYWdlIH5kZWZhdWx0OlwiXCIpXG4gICAgICAgICAgKGUsIHApXG4gICAgICAgICAgKHNleHBfb2ZfcGFpciBFcnJvci5zZXhwX29mX3QgU291cmNlX2NvZGVfcG9zaXRpb24wLnNleHBfb2ZfdClcbiAgICBpblxuICAgIEVycm9yLnJhaXNlIGVycm9yXG47O1xuXG5sZXQgdmFsdWVfb3JfdGh1bmsgbyB+ZGVmYXVsdCA9XG4gIG1hdGNoIG8gd2l0aFxuICB8IFNvbWUgeCAtPiB4XG4gIHwgTm9uZSAtPiBkZWZhdWx0ICgpXG47O1xuXG5sZXQgdG9fYXJyYXkgdCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IE5vbmUgLT4gW3x8XVxuICB8IFNvbWUgeCAtPiBbfCB4IHxdXG47O1xuXG5sZXQgdG9fbGlzdCB0ID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgTm9uZSAtPiBbXVxuICB8IFNvbWUgeCAtPiBbIHggXVxuOztcblxubGV0IG1pbl9lbHQgdCB+Y29tcGFyZTpfID0gdFxubGV0IG1heF9lbHQgdCB+Y29tcGFyZTpfID0gdFxuXG5sZXQgc3VtICh0eXBlIGEpIChtb2R1bGUgTSA6IENvbnRhaW5lci5TdW1tYWJsZSB3aXRoIHR5cGUgdCA9IGEpIHQgfmYgPVxuICB2YWx1ZV9tYXAgdCB+ZGVmYXVsdDpNLnplcm8gfmZcbjs7XG5cbmxldCBmb3JfYWxsIHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBOb25lIC0+IHRydWVcbiAgfCBTb21lIHggLT4gZiB4XG47O1xuXG5sZXQgZXhpc3RzIHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBOb25lIC0+IGZhbHNlXG4gIHwgU29tZSB4IC0+IGYgeFxuOztcblxubGV0IG1lbSB0IGEgfmVxdWFsID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgTm9uZSAtPiBmYWxzZVxuICB8IFNvbWUgYScgLT4gZXF1YWwgYSBhJ1xuOztcblxubGV0IGxlbmd0aCB0ID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgTm9uZSAtPiAwXG4gIHwgU29tZSBfIC0+IDFcbjs7XG5cbmxldCBpc19lbXB0eSA9IGlzX25vbmVcblxubGV0IGZvbGQgdCB+aW5pdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IE5vbmUgLT4gaW5pdFxuICB8IFNvbWUgeCAtPiBmIGluaXQgeFxuOztcblxubGV0IGNvdW50IHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBOb25lIC0+IDBcbiAgfCBTb21lIGEgLT4gaWYgZiBhIHRoZW4gMSBlbHNlIDBcbjs7XG5cbmxldCBmaW5kIHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBOb25lIC0+IE5vbmVcbiAgfCBTb21lIHggLT4gaWYgZiB4IHRoZW4gdCBlbHNlIE5vbmVcbjs7XG5cbmxldCBmaW5kX21hcCB0IH5mID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgTm9uZSAtPiBOb25lXG4gIHwgU29tZSBhIC0+IGYgYVxuOztcblxubGV0IGVxdWFsIGYgdCB0JyA9XG4gIG1hdGNoIHQsIHQnIHdpdGhcbiAgfCBOb25lLCBOb25lIC0+IHRydWVcbiAgfCBTb21lIHgsIFNvbWUgeCcgLT4gZiB4IHgnXG4gIHwgXyAtPiBmYWxzZVxuOztcblxubGV0IHNvbWUgeCA9IFNvbWUgeFxuXG5sZXQgZmlyc3Rfc29tZSB4IHkgPVxuICBtYXRjaCB4IHdpdGhcbiAgfCBTb21lIF8gLT4geFxuICB8IE5vbmUgLT4geVxuOztcblxubGV0IHNvbWVfaWYgY29uZCB4ID0gaWYgY29uZCB0aGVuIFNvbWUgeCBlbHNlIE5vbmVcblxubGV0IG1lcmdlIGEgYiB+ZiA9XG4gIG1hdGNoIGEsIGIgd2l0aFxuICB8IE5vbmUsIHggfCB4LCBOb25lIC0+IHhcbiAgfCBTb21lIGEsIFNvbWUgYiAtPiBTb21lIChmIGEgYilcbjs7XG5cbmxldCBmaWx0ZXIgdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IFNvbWUgdiBhcyBvIHdoZW4gZiB2IC0+IG9cbiAgfCBfIC0+IE5vbmVcbjs7XG5cbmxldCB0cnlfd2l0aCBmID1cbiAgbWF0Y2ggZiAoKSB3aXRoXG4gIHwgeCAtPiBTb21lIHhcbiAgfCBleGNlcHRpb24gXyAtPiBOb25lXG47O1xuXG5sZXQgdHJ5X3dpdGhfam9pbiBmID1cbiAgbWF0Y2ggZiAoKSB3aXRoXG4gIHwgeCAtPiB4XG4gIHwgZXhjZXB0aW9uIF8gLT4gTm9uZVxuOztcblxubGV0IG1hcCB0IH5mID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgTm9uZSAtPiBOb25lXG4gIHwgU29tZSBhIC0+IFNvbWUgKGYgYSlcbjs7XG5cbmxldCBhcHBseSBmIHggPVxuICBtYXRjaCBmIHdpdGhcbiAgfCBOb25lIC0+IE5vbmVcbiAgfCBTb21lIGYgLT4gbWFwIH5mIHhcbjs7XG5cbm1vZHVsZSBNb25hZF9hcmcgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gJ2Egb3B0aW9uXG5cbiAgbGV0IHJldHVybiB4ID0gU29tZSB4XG4gIGxldCBhcHBseSA9IGFwcGx5XG4gIGxldCBtYXAgPSBgQ3VzdG9tIG1hcFxuXG4gIGxldCBiaW5kIG8gfmYgPVxuICAgIG1hdGNoIG8gd2l0aFxuICAgIHwgTm9uZSAtPiBOb25lXG4gICAgfCBTb21lIHggLT4gZiB4XG4gIDs7XG5lbmRcblxuaW5jbHVkZSBNb25hZC5NYWtlIChNb25hZF9hcmcpXG5pbmNsdWRlIEFwcGxpY2F0aXZlLk1ha2UgKE1vbmFkX2FyZylcblxubGV0IGZvbGRfcmVzdWx0IHQgfmluaXQgfmYgPSBDb250YWluZXIuZm9sZF9yZXN1bHQgfmZvbGQgfmluaXQgfmYgdFxubGV0IGZvbGRfdW50aWwgdCB+aW5pdCB+ZiA9IENvbnRhaW5lci5mb2xkX3VudGlsIH5mb2xkIH5pbml0IH5mIHRcbiIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBTZXhwbGliMC5TZXhwYWJsZVxuXG5tb2R1bGUgT2Zfc2V4cGFibGVcbiAgICAoU2V4cGFibGUgOiBTKSAoTSA6IHNpZ1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGUgdFxuXG4gICAgICAgICAgICAgICAgICAgICAgdmFsIHRvX3NleHBhYmxlIDogdCAtPiBTZXhwYWJsZS50XG4gICAgICAgICAgICAgICAgICAgICAgdmFsIG9mX3NleHBhYmxlIDogU2V4cGFibGUudCAtPiB0XG4gICAgICAgICAgICAgICAgICAgIGVuZCkgOiBTIHdpdGggdHlwZSB0IDo9IE0udCA9IHN0cnVjdFxuICBsZXQgdF9vZl9zZXhwIHNleHAgPVxuICAgIGxldCBzID0gU2V4cGFibGUudF9vZl9zZXhwIHNleHAgaW5cbiAgICB0cnkgTS5vZl9zZXhwYWJsZSBzIHdpdGhcbiAgICB8IGV4biAtPiBvZl9zZXhwX2Vycm9yX2V4biBleG4gc2V4cFxuICA7O1xuXG4gIGxldCBzZXhwX29mX3QgdCA9IFNleHBhYmxlLnNleHBfb2ZfdCAoTS50b19zZXhwYWJsZSB0KVxuZW5kXG5cbm1vZHVsZSBPZl9zZXhwYWJsZTFcbiAgICAoU2V4cGFibGUgOiBTMSkgKE0gOiBzaWdcbiAgICAgICAgICAgICAgICAgICAgICAgdHlwZSAnYSB0XG5cbiAgICAgICAgICAgICAgICAgICAgICAgdmFsIHRvX3NleHBhYmxlIDogJ2EgdCAtPiAnYSBTZXhwYWJsZS50XG4gICAgICAgICAgICAgICAgICAgICAgIHZhbCBvZl9zZXhwYWJsZSA6ICdhIFNleHBhYmxlLnQgLT4gJ2EgdFxuICAgICAgICAgICAgICAgICAgICAgZW5kKSA6IFMxIHdpdGggdHlwZSAnYSB0IDo9ICdhIE0udCA9IHN0cnVjdFxuICBsZXQgdF9vZl9zZXhwIGFfb2Zfc2V4cCBzZXhwID1cbiAgICBsZXQgcyA9IFNleHBhYmxlLnRfb2Zfc2V4cCBhX29mX3NleHAgc2V4cCBpblxuICAgIHRyeSBNLm9mX3NleHBhYmxlIHMgd2l0aFxuICAgIHwgZXhuIC0+IG9mX3NleHBfZXJyb3JfZXhuIGV4biBzZXhwXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCBzZXhwX29mX2EgdCA9IFNleHBhYmxlLnNleHBfb2ZfdCBzZXhwX29mX2EgKE0udG9fc2V4cGFibGUgdClcbmVuZFxuXG5tb2R1bGUgT2Zfc2V4cGFibGUyXG4gICAgKFNleHBhYmxlIDogUzIpIChNIDogc2lnXG4gICAgICAgICAgICAgICAgICAgICAgIHR5cGUgKCdhLCAnYikgdFxuXG4gICAgICAgICAgICAgICAgICAgICAgIHZhbCB0b19zZXhwYWJsZSA6ICgnYSwgJ2IpIHQgLT4gKCdhLCAnYikgU2V4cGFibGUudFxuICAgICAgICAgICAgICAgICAgICAgICB2YWwgb2Zfc2V4cGFibGUgOiAoJ2EsICdiKSBTZXhwYWJsZS50IC0+ICgnYSwgJ2IpIHRcbiAgICAgICAgICAgICAgICAgICAgIGVuZCkgOiBTMiB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSBNLnQgPSBzdHJ1Y3RcbiAgbGV0IHRfb2Zfc2V4cCBhX29mX3NleHAgYl9vZl9zZXhwIHNleHAgPVxuICAgIGxldCBzID0gU2V4cGFibGUudF9vZl9zZXhwIGFfb2Zfc2V4cCBiX29mX3NleHAgc2V4cCBpblxuICAgIHRyeSBNLm9mX3NleHBhYmxlIHMgd2l0aFxuICAgIHwgZXhuIC0+IG9mX3NleHBfZXJyb3JfZXhuIGV4biBzZXhwXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCBzZXhwX29mX2Egc2V4cF9vZl9iIHQgPVxuICAgIFNleHBhYmxlLnNleHBfb2ZfdCBzZXhwX29mX2Egc2V4cF9vZl9iIChNLnRvX3NleHBhYmxlIHQpXG4gIDs7XG5lbmRcblxubW9kdWxlIE9mX3NleHBhYmxlM1xuICAgIChTZXhwYWJsZSA6IFMzKSAoTSA6IHNpZ1xuICAgICAgICAgICAgICAgICAgICAgICB0eXBlICgnYSwgJ2IsICdjKSB0XG5cbiAgICAgICAgICAgICAgICAgICAgICAgdmFsIHRvX3NleHBhYmxlIDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYiwgJ2MpIFNleHBhYmxlLnRcbiAgICAgICAgICAgICAgICAgICAgICAgdmFsIG9mX3NleHBhYmxlIDogKCdhLCAnYiwgJ2MpIFNleHBhYmxlLnQgLT4gKCdhLCAnYiwgJ2MpIHRcbiAgICAgICAgICAgICAgICAgICAgIGVuZCkgOiBTMyB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHQgOj0gKCdhLCAnYiwgJ2MpIE0udCA9IHN0cnVjdFxuICBsZXQgdF9vZl9zZXhwIGFfb2Zfc2V4cCBiX29mX3NleHAgY19vZl9zZXhwIHNleHAgPVxuICAgIGxldCBzID0gU2V4cGFibGUudF9vZl9zZXhwIGFfb2Zfc2V4cCBiX29mX3NleHAgY19vZl9zZXhwIHNleHAgaW5cbiAgICB0cnkgTS5vZl9zZXhwYWJsZSBzIHdpdGhcbiAgICB8IGV4biAtPiBvZl9zZXhwX2Vycm9yX2V4biBleG4gc2V4cFxuICA7O1xuXG4gIGxldCBzZXhwX29mX3Qgc2V4cF9vZl9hIHNleHBfb2ZfYiBzZXhwX29mX2MgdCA9XG4gICAgU2V4cGFibGUuc2V4cF9vZl90IHNleHBfb2ZfYSBzZXhwX29mX2Igc2V4cF9vZl9jIChNLnRvX3NleHBhYmxlIHQpXG4gIDs7XG5lbmRcblxubW9kdWxlIE9mX3N0cmluZ2FibGUgKE0gOiBTdHJpbmdhYmxlLlMpIDogUyB3aXRoIHR5cGUgdCA6PSBNLnQgPSBzdHJ1Y3RcbiAgbGV0IHRfb2Zfc2V4cCBzZXhwID1cbiAgICBtYXRjaCBzZXhwIHdpdGhcbiAgICB8IFNleHAuQXRvbSBzIC0+XG4gICAgICAodHJ5IE0ub2Zfc3RyaW5nIHMgd2l0aFxuICAgICAgIHwgZXhuIC0+IG9mX3NleHBfZXJyb3JfZXhuIGV4biBzZXhwKVxuICAgIHwgU2V4cC5MaXN0IF8gLT5cbiAgICAgIG9mX3NleHBfZXJyb3JcbiAgICAgICAgXCJTZXhwYWJsZS5PZl9zdHJpbmdhYmxlLnRfb2Zfc2V4cCBleHBlY3RlZCBhbiBhdG9tLCBidXQgZ290IGEgbGlzdFwiXG4gICAgICAgIHNleHBcbiAgOztcblxuICBsZXQgc2V4cF9vZl90IHQgPSBTZXhwLkF0b20gKE0udG9fc3RyaW5nIHQpXG5lbmRcbiIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBFaXRoZXJfaW50ZlxubW9kdWxlIExpc3QgPSBMaXN0MFxuaW5jbHVkZSBFaXRoZXIwXG5cbmxldCBzd2FwID0gZnVuY3Rpb25cbiAgfCBGaXJzdCB4IC0+IFNlY29uZCB4XG4gIHwgU2Vjb25kIHggLT4gRmlyc3QgeFxuOztcblxubGV0IGlzX2ZpcnN0ID0gZnVuY3Rpb25cbiAgfCBGaXJzdCBfIC0+IHRydWVcbiAgfCBTZWNvbmQgXyAtPiBmYWxzZVxuOztcblxubGV0IGlzX3NlY29uZCA9IGZ1bmN0aW9uXG4gIHwgRmlyc3QgXyAtPiBmYWxzZVxuICB8IFNlY29uZCBfIC0+IHRydWVcbjs7XG5cbmxldCB2YWx1ZSAoRmlyc3QgeCB8IFNlY29uZCB4KSA9IHhcblxubGV0IHZhbHVlX21hcCB0IH5maXJzdCB+c2Vjb25kID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgRmlyc3QgeCAtPiBmaXJzdCB4XG4gIHwgU2Vjb25kIHggLT4gc2Vjb25kIHhcbjs7XG5cbmxldCBpdGVyID0gdmFsdWVfbWFwXG5cbmxldCBtYXAgdCB+Zmlyc3QgfnNlY29uZCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IEZpcnN0IHggLT4gRmlyc3QgKGZpcnN0IHgpXG4gIHwgU2Vjb25kIHggLT4gU2Vjb25kIChzZWNvbmQgeClcbjs7XG5cbmxldCBmaXJzdCB4ID0gRmlyc3QgeFxubGV0IHNlY29uZCB4ID0gU2Vjb25kIHhcblxubGV0IGVxdWFsIGVxMSBlcTIgdDEgdDIgPVxuICBtYXRjaCB0MSwgdDIgd2l0aFxuICB8IEZpcnN0IHgsIEZpcnN0IHkgLT4gZXExIHggeVxuICB8IFNlY29uZCB4LCBTZWNvbmQgeSAtPiBlcTIgeCB5XG4gIHwgRmlyc3QgXywgU2Vjb25kIF8gfCBTZWNvbmQgXywgRmlyc3QgXyAtPiBmYWxzZVxuOztcblxubGV0IGludmFyaWFudCBmIHMgPSBmdW5jdGlvblxuICB8IEZpcnN0IHggLT4gZiB4XG4gIHwgU2Vjb25kIHkgLT4gcyB5XG47O1xuXG5tb2R1bGUgTWFrZV9mb2N1c2VkIChNIDogc2lnXG4gICAgdHlwZSAoKydhLCArJ2IpIHRcblxuICAgIHZhbCByZXR1cm4gOiAnYSAtPiAoJ2EsIF8pIHRcbiAgICB2YWwgb3RoZXIgOiAnYiAtPiAoXywgJ2IpIHRcbiAgICB2YWwgZWl0aGVyIDogKCdhLCAnYikgdCAtPiByZXR1cm46KCdhIC0+ICdjKSAtPiBvdGhlcjooJ2IgLT4gJ2MpIC0+ICdjXG5cbiAgICB2YWwgY29tYmluZVxuICAgICAgOiAgKCdhLCAnZCkgdFxuICAgICAgLT4gKCdiLCAnZCkgdFxuICAgICAgLT4gZjooJ2EgLT4gJ2IgLT4gJ2MpXG4gICAgICAtPiBvdGhlcjooJ2QgLT4gJ2QgLT4gJ2QpXG4gICAgICAtPiAoJ2MsICdkKSB0XG5cbiAgICB2YWwgYmluZCA6ICgnYSwgJ2IpIHQgLT4gZjooJ2EgLT4gKCdjLCAnYikgdCkgLT4gKCdjLCAnYikgdFxuICBlbmQpID1cbnN0cnVjdFxuICBpbmNsdWRlIE1cbiAgb3BlbiBXaXRoX3JldHVyblxuXG4gIGxldCBtYXAgdCB+ZiA9IGJpbmQgdCB+ZjooZnVuIHggLT4gcmV0dXJuIChmIHgpKVxuXG4gIGluY2x1ZGUgTW9uYWQuTWFrZTIgKHN0cnVjdFxuICAgICAgdHlwZSBub25yZWMgKCdhLCAnYikgdCA9ICgnYSwgJ2IpIHRcblxuICAgICAgbGV0IHJldHVybiA9IHJldHVyblxuICAgICAgbGV0IGJpbmQgPSBiaW5kXG4gICAgICBsZXQgbWFwID0gYEN1c3RvbSBtYXBcbiAgICBlbmQpXG5cbiAgbW9kdWxlIEFwcCA9IEFwcGxpY2F0aXZlLk1ha2UyIChzdHJ1Y3RcbiAgICAgIHR5cGUgbm9ucmVjICgnYSwgJ2IpIHQgPSAoJ2EsICdiKSB0XG5cbiAgICAgIGxldCByZXR1cm4gPSByZXR1cm5cbiAgICAgIGxldCBhcHBseSB0MSB0MiA9IGJpbmQgdDEgfmY6KGZ1biBmIC0+IGJpbmQgdDIgfmY6KGZ1biB4IC0+IHJldHVybiAoZiB4KSkpXG4gICAgICBsZXQgbWFwID0gYEN1c3RvbSBtYXBcbiAgICBlbmQpXG5cbiAgaW5jbHVkZSBBcHBcblxuICBsZXQgY29tYmluZV9hbGwgPVxuICAgIGxldCByZWMgb3RoZXJfbG9vcCBmIGFjYyA9IGZ1bmN0aW9uXG4gICAgICB8IFtdIC0+IG90aGVyIGFjY1xuICAgICAgfCB0IDo6IHRzIC0+XG4gICAgICAgIGVpdGhlclxuICAgICAgICAgIHRcbiAgICAgICAgICB+cmV0dXJuOihmdW4gXyAtPiBvdGhlcl9sb29wIGYgYWNjIHRzKVxuICAgICAgICAgIH5vdGhlcjooZnVuIG8gLT4gb3RoZXJfbG9vcCBmIChmIGFjYyBvKSB0cylcbiAgICBpblxuICAgIGxldCByZWMgcmV0dXJuX2xvb3AgZiBhY2MgPSBmdW5jdGlvblxuICAgICAgfCBbXSAtPiByZXR1cm4gKExpc3QucmV2IGFjYylcbiAgICAgIHwgdCA6OiB0cyAtPlxuICAgICAgICBlaXRoZXJcbiAgICAgICAgICB0XG4gICAgICAgICAgfnJldHVybjooZnVuIHggLT4gcmV0dXJuX2xvb3AgZiAoeCA6OiBhY2MpIHRzKVxuICAgICAgICAgIH5vdGhlcjooZnVuIG8gLT4gb3RoZXJfbG9vcCBmIG8gdHMpXG4gICAgaW5cbiAgICBmdW4gdHMgfmYgLT4gcmV0dXJuX2xvb3AgZiBbXSB0c1xuICA7O1xuXG4gIGxldCBjb21iaW5lX2FsbF91bml0ID1cbiAgICBsZXQgcmVjIG90aGVyX2xvb3AgZiBhY2MgPSBmdW5jdGlvblxuICAgICAgfCBbXSAtPiBvdGhlciBhY2NcbiAgICAgIHwgdCA6OiB0cyAtPlxuICAgICAgICBlaXRoZXJcbiAgICAgICAgICB0XG4gICAgICAgICAgfnJldHVybjooZnVuICgpIC0+IG90aGVyX2xvb3AgZiBhY2MgdHMpXG4gICAgICAgICAgfm90aGVyOihmdW4gbyAtPiBvdGhlcl9sb29wIGYgKGYgYWNjIG8pIHRzKVxuICAgIGluXG4gICAgbGV0IHJlYyByZXR1cm5fbG9vcCBmID0gZnVuY3Rpb25cbiAgICAgIHwgW10gLT4gcmV0dXJuICgpXG4gICAgICB8IHQgOjogdHMgLT5cbiAgICAgICAgZWl0aGVyIHQgfnJldHVybjooZnVuICgpIC0+IHJldHVybl9sb29wIGYgdHMpIH5vdGhlcjooZnVuIG8gLT4gb3RoZXJfbG9vcCBmIG8gdHMpXG4gICAgaW5cbiAgICBmdW4gdHMgfmYgLT4gcmV0dXJuX2xvb3AgZiB0c1xuICA7O1xuXG4gIGxldCB0b19vcHRpb24gdCA9IGVpdGhlciB0IH5yZXR1cm46T3B0aW9uLnNvbWUgfm90aGVyOihmdW4gXyAtPiBOb25lKVxuICBsZXQgdmFsdWUgdCB+ZGVmYXVsdCA9IGVpdGhlciB0IH5yZXR1cm46Rm4uaWQgfm90aGVyOihmdW4gXyAtPiBkZWZhdWx0KVxuXG4gIGxldCB3aXRoX3JldHVybiBmID1cbiAgICB3aXRoX3JldHVybiAoZnVuIHJldCAtPiBvdGhlciAoZiAoV2l0aF9yZXR1cm4ucHJlcGVuZCByZXQgfmY6cmV0dXJuKSkpXG4gIDs7XG5lbmRcblxubW9kdWxlIEZpcnN0ID0gTWFrZV9mb2N1c2VkIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyAoJ2EsICdiKSB0ID0gKCdhLCAnYikgdFxuXG4gICAgbGV0IHJldHVybiA9IGZpcnN0XG4gICAgbGV0IG90aGVyID0gc2Vjb25kXG5cbiAgICBsZXQgZWl0aGVyIHQgfnJldHVybiB+b3RoZXIgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IEZpcnN0IHggLT4gcmV0dXJuIHhcbiAgICAgIHwgU2Vjb25kIHkgLT4gb3RoZXIgeVxuICAgIDs7XG5cbiAgICBsZXQgY29tYmluZSB0MSB0MiB+ZiB+b3RoZXIgPVxuICAgICAgbWF0Y2ggdDEsIHQyIHdpdGhcbiAgICAgIHwgRmlyc3QgeCwgRmlyc3QgeSAtPiBGaXJzdCAoZiB4IHkpXG4gICAgICB8IFNlY29uZCB4LCBTZWNvbmQgeSAtPiBTZWNvbmQgKG90aGVyIHggeSlcbiAgICAgIHwgU2Vjb25kIHgsIF8gfCBfLCBTZWNvbmQgeCAtPiBTZWNvbmQgeFxuICAgIDs7XG5cbiAgICBsZXQgYmluZCB0IH5mID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBGaXJzdCB4IC0+IGYgeFxuICAgICAgKCogUmV1c2UgdGhlIHZhbHVlIGluIG9yZGVyIHRvIGF2b2lkIGFsbG9jYXRpb24uICopXG4gICAgICB8IFNlY29uZCBfIGFzIHkgLT4geVxuICAgIDs7XG4gIGVuZClcblxubW9kdWxlIFNlY29uZCA9IE1ha2VfZm9jdXNlZCAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgKCdhLCAnYikgdCA9ICgnYiwgJ2EpIHRcblxuICAgIGxldCByZXR1cm4gPSBzZWNvbmRcbiAgICBsZXQgb3RoZXIgPSBmaXJzdFxuXG4gICAgbGV0IGVpdGhlciB0IH5yZXR1cm4gfm90aGVyID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBTZWNvbmQgeSAtPiByZXR1cm4geVxuICAgICAgfCBGaXJzdCB4IC0+IG90aGVyIHhcbiAgICA7O1xuXG4gICAgbGV0IGNvbWJpbmUgdDEgdDIgfmYgfm90aGVyID1cbiAgICAgIG1hdGNoIHQxLCB0MiB3aXRoXG4gICAgICB8IFNlY29uZCB4LCBTZWNvbmQgeSAtPiBTZWNvbmQgKGYgeCB5KVxuICAgICAgfCBGaXJzdCB4LCBGaXJzdCB5IC0+IEZpcnN0IChvdGhlciB4IHkpXG4gICAgICB8IEZpcnN0IHgsIF8gfCBfLCBGaXJzdCB4IC0+IEZpcnN0IHhcbiAgICA7O1xuXG4gICAgbGV0IGJpbmQgdCB+ZiA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgU2Vjb25kIHggLT4gZiB4XG4gICAgICAoKiBSZXVzZSB0aGUgdmFsdWUgaW4gb3JkZXIgdG8gYXZvaWQgYWxsb2NhdGlvbiwgbGlrZSBbRmlyc3QuYmluZF0gYWJvdmUuICopXG4gICAgICB8IEZpcnN0IF8gYXMgeSAtPiB5XG4gICAgOztcbiAgZW5kKVxuXG5tb2R1bGUgRXhwb3J0ID0gc3RydWN0XG4gIHR5cGUgKCdmLCAncykgX2VpdGhlciA9ICgnZiwgJ3MpIHQgPVxuICAgIHwgRmlyc3Qgb2YgJ2ZcbiAgICB8IFNlY29uZCBvZiAnc1xuZW5kXG4iLCJpbmNsdWRlIEluZGV4ZWRfY29udGFpbmVyX2ludGZcblxubGV0IHdpdGhfcmV0dXJuID0gV2l0aF9yZXR1cm4ud2l0aF9yZXR1cm5cblxubGV0IGl0ZXJpIH5mb2xkIHQgfmYgPVxuICBpZ25vcmVcbiAgICAoZm9sZCB0IH5pbml0OjAgfmY6KGZ1biBpIHggLT5cbiAgICAgICBmIGkgeDtcbiAgICAgICBpICsgMSlcbiAgICAgOiBpbnQpXG47O1xuXG5sZXQgZm9sZGkgfmZvbGQgdCB+aW5pdCB+ZiA9XG4gIGxldCBpID0gcmVmIDAgaW5cbiAgZm9sZCB0IH5pbml0IH5mOihmdW4gYWNjIHYgLT5cbiAgICBsZXQgYWNjID0gZiAhaSBhY2MgdiBpblxuICAgIGkgOj0gIWkgKyAxO1xuICAgIGFjYylcbjs7XG5cbmxldCBjb3VudGkgfmZvbGRpIHQgfmYgPSBmb2xkaSB0IH5pbml0OjAgfmY6KGZ1biBpIG4gYSAtPiBpZiBmIGkgYSB0aGVuIG4gKyAxIGVsc2UgbilcblxubGV0IGV4aXN0c2kgfml0ZXJpIGMgfmYgPVxuICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICBpdGVyaSBjIH5mOihmdW4gaSB4IC0+IGlmIGYgaSB4IHRoZW4gci5yZXR1cm4gdHJ1ZSk7XG4gICAgZmFsc2UpXG47O1xuXG5sZXQgZm9yX2FsbGkgfml0ZXJpIGMgfmYgPVxuICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICBpdGVyaSBjIH5mOihmdW4gaSB4IC0+IGlmIG5vdCAoZiBpIHgpIHRoZW4gci5yZXR1cm4gZmFsc2UpO1xuICAgIHRydWUpXG47O1xuXG5sZXQgZmluZF9tYXBpIH5pdGVyaSB0IH5mID1cbiAgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgaXRlcmkgdCB+ZjooZnVuIGkgeCAtPlxuICAgICAgbWF0Y2ggZiBpIHggd2l0aFxuICAgICAgfCBOb25lIC0+ICgpXG4gICAgICB8IFNvbWUgXyBhcyByZXMgLT4gci5yZXR1cm4gcmVzKTtcbiAgICBOb25lKVxuOztcblxubGV0IGZpbmRpIH5pdGVyaSBjIH5mID1cbiAgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgaXRlcmkgYyB+ZjooZnVuIGkgeCAtPiBpZiBmIGkgeCB0aGVuIHIucmV0dXJuIChTb21lIChpLCB4KSkpO1xuICAgIE5vbmUpXG47O1xuXG5tb2R1bGUgTWFrZV9nZW4gKFQgOiBzaWdcbiAgICBpbmNsdWRlIENvbnRhaW5lcl9pbnRmLk1ha2VfZ2VuX2FyZ1xuXG4gICAgdmFsIGl0ZXJpIDogWyBgRGVmaW5lX3VzaW5nX2ZvbGQgfCBgQ3VzdG9tIG9mICgnYSB0LCAnYSBlbHQpIGl0ZXJpIF1cbiAgICB2YWwgZm9sZGkgOiBbIGBEZWZpbmVfdXNpbmdfZm9sZCB8IGBDdXN0b20gb2YgKCdhIHQsICdhIGVsdCwgXykgZm9sZGkgXVxuICBlbmQpIDogR2VuZXJpYyB3aXRoIHR5cGUgJ2EgdCA6PSAnYSBULnQgd2l0aCB0eXBlICdhIGVsdCA6PSAnYSBULmVsdCA9IHN0cnVjdFxuICBpbmNsdWRlIENvbnRhaW5lci5NYWtlX2dlbiAoVClcblxuICBsZXQgaXRlcmkgPVxuICAgIG1hdGNoIFQuaXRlcmkgd2l0aFxuICAgIHwgYEN1c3RvbSBpdGVyaSAtPiBpdGVyaVxuICAgIHwgYERlZmluZV91c2luZ19mb2xkIC0+IGZ1biB0IH5mIC0+IGl0ZXJpIH5mb2xkIHQgfmZcbiAgOztcblxuICBsZXQgZm9sZGkgPVxuICAgIG1hdGNoIFQuZm9sZGkgd2l0aFxuICAgIHwgYEN1c3RvbSBmb2xkaSAtPiBmb2xkaVxuICAgIHwgYERlZmluZV91c2luZ19mb2xkIC0+IGZ1biB0IH5pbml0IH5mIC0+IGZvbGRpIH5mb2xkIHQgfmluaXQgfmZcbiAgOztcblxuICBsZXQgY291bnRpIHQgfmYgPSBjb3VudGkgfmZvbGRpIHQgfmZcbiAgbGV0IGV4aXN0c2kgdCB+ZiA9IGV4aXN0c2kgfml0ZXJpIHQgfmZcbiAgbGV0IGZvcl9hbGxpIHQgfmYgPSBmb3JfYWxsaSB+aXRlcmkgdCB+ZlxuICBsZXQgZmluZF9tYXBpIHQgfmYgPSBmaW5kX21hcGkgfml0ZXJpIHQgfmZcbiAgbGV0IGZpbmRpIHQgfmYgPSBmaW5kaSB+aXRlcmkgdCB+ZlxuZW5kXG5cbm1vZHVsZSBNYWtlIChUIDogTWFrZV9hcmcpID0gc3RydWN0XG4gIG1vZHVsZSBDID0gQ29udGFpbmVyLk1ha2UgKFQpXG5cbiAgKCogTm90IHBhcnQgb2YgW0NvbnRhaW5lci5HZW5lcmljXS4gKilcbiAgbGV0IG1lbSA9IEMubWVtXG5cbiAgaW5jbHVkZSBNYWtlX2dlbiAoc3RydWN0XG4gICAgICBpbmNsdWRlIFRcblxuICAgICAgdHlwZSAnYSB0ID0gJ2EgVC50XG4gICAgICB0eXBlICdhIGVsdCA9ICdhXG4gICAgZW5kKVxuZW5kXG5cbm1vZHVsZSBNYWtlMCAoVCA6IE1ha2UwX2FyZykgPSBzdHJ1Y3RcbiAgbW9kdWxlIEMgPSBDb250YWluZXIuTWFrZTAgKFQpXG5cbiAgKCogTm90IHBhcnQgb2YgW0NvbnRhaW5lci5HZW5lcmljXS4gKilcbiAgbGV0IG1lbSA9IEMubWVtXG5cbiAgaW5jbHVkZSBNYWtlX2dlbiAoc3RydWN0XG4gICAgICBpbmNsdWRlIFRcblxuICAgICAgdHlwZSAnYSB0ID0gVC50XG4gICAgICB0eXBlICdhIGVsdCA9IFQuRWx0LnRcbiAgICBlbmQpXG5lbmRcbiIsIm9wZW4hIEltcG9ydFxubW9kdWxlIEludCA9IEludDBcbm1vZHVsZSBTdHJpbmcgPSBTdHJpbmcwXG5tb2R1bGUgQXJyYXkgPSBBcnJheTBcblxuKCogV2UgbWFpbnRhaW4gdGhlIHByb3BlcnR5IHRoYXQgYWxsIHZhbHVlcyBvZiB0eXBlIFt0XSBkbyBub3QgaGF2ZSB0aGUgdGFnXG4gICBbZG91YmxlX2FycmF5X3RhZ10uICBTb21lIGZ1bmN0aW9ucyBiZWxvdyBhc3N1bWUgdGhpcyBpbiBvcmRlciB0byBhdm9pZCB0ZXN0aW5nIHRoZVxuICAgdGFnLCBhbmQgd2lsbCBzZWdmYXVsdCBpZiB0aGlzIHByb3BlcnR5IGRvZXNuJ3QgaG9sZC4gKilcbnR5cGUgdCA9IENhbWwuT2JqLnQgYXJyYXlcblxubGV0IGludmFyaWFudCB0ID0gYXNzZXJ0IChDYW1sLk9iai50YWcgKENhbWwuT2JqLnJlcHIgdCkgPD4gQ2FtbC5PYmouZG91YmxlX2FycmF5X3RhZylcbmxldCBsZW5ndGggPSBBcnJheS5sZW5ndGggKCogd291bGQgY2hlY2sgZm9yIGZsb2F0IGFycmF5cyBpbiAzMiBiaXQsIGJ1dCB3aGF0ZXZlciAqKVxuXG5sZXQgc2V4cF9vZl90IHQgPVxuICBTZXhwLkF0b21cbiAgICAoU3RyaW5nLmNvbmNhdCB+c2VwOlwiXCIgWyBcIjxPYmpfYXJyYXkudCBvZiBsZW5ndGggXCI7IEludC50b19zdHJpbmcgKGxlbmd0aCB0KTsgXCI+XCIgXSlcbjs7XG5cbmxldCB6ZXJvX29iaiA9IENhbWwuT2JqLnJlcHIgKDAgOiBpbnQpXG5cbigqIFdlIGNhbGwgW0FycmF5LmNyZWF0ZV0gd2l0aCBhIHZhbHVlIHRoYXQgaXMgbm90IGEgZmxvYXQgc28gdGhhdCB0aGUgYXJyYXkgZG9lc24ndCBnZXRcbiAgIHRhZ2dlZCB3aXRoIFtEb3VibGVfYXJyYXlfdGFnXS4gKilcbmxldCBjcmVhdGVfemVybyB+bGVuID0gQXJyYXkuY3JlYXRlIH5sZW4gemVyb19vYmpcbmxldCBlbXB0eSA9IFt8fF1cblxudHlwZSBub3RfYV9mbG9hdCA9XG4gIHwgTm90X2FfZmxvYXRfMFxuICB8IE5vdF9hX2Zsb2F0XzEgb2YgaW50XG5cbmxldCBfbm90X2FfZmxvYXRfMCA9IE5vdF9hX2Zsb2F0XzBcbmxldCBfbm90X2FfZmxvYXRfMSA9IE5vdF9hX2Zsb2F0XzEgNDJcblxubGV0IGdldCB0IGkgPVxuICAoKiBNYWtlIHRoZSBjb21waWxlciBiZWxpZXZlIFt0XSBpcyBhbiBhcnJheSBub3QgY29udGFpbmluZyBmbG9hdHMgc28gaXQgZG9lcyBub3QgY2hlY2tcbiAgICAgaWYgW3RdIGlzIHRhZ2dlZCB3aXRoIFtEb3VibGVfYXJyYXlfdGFnXS4gIEl0IGlzIE5PVCBvayB0byB1c2UgW2ludCBhcnJheV0gc2luY2UgKGlmXG4gICAgIHRoaXMgZnVuY3Rpb24gaXMgaW5saW5lZCBhbmQgdGhlIGFycmF5IGNvbnRhaW5zIGluLWhlYXAgYm94ZWQgdmFsdWVzKSB3cm9uZyByZWdpc3RlclxuICAgICB0eXBpbmcgbWF5IHJlc3VsdCwgbGVhZGluZyB0byBhIGZhaWx1cmUgdG8gcmVnaXN0ZXIgbmVjZXNzYXJ5IEdDIHJvb3RzLiAqKVxuICBDYW1sLk9iai5yZXByICgoQ2FtbC5PYmoubWFnaWMgKHQgOiB0KSA6IG5vdF9hX2Zsb2F0IGFycmF5KS4oaSkgOiBub3RfYV9mbG9hdClcbjs7XG5cbmxldFtAaW5saW5lIGFsd2F5c10gdW5zYWZlX2dldCB0IGkgPVxuICAoKiBNYWtlIHRoZSBjb21waWxlciBiZWxpZXZlIFt0XSBpcyBhbiBhcnJheSBub3QgY29udGFpbmluZyBmbG9hdHMgc28gaXQgZG9lcyBub3QgY2hlY2tcbiAgICAgaWYgW3RdIGlzIHRhZ2dlZCB3aXRoIFtEb3VibGVfYXJyYXlfdGFnXS4gKilcbiAgQ2FtbC5PYmoucmVwclxuICAgIChBcnJheS51bnNhZmVfZ2V0IChDYW1sLk9iai5tYWdpYyAodCA6IHQpIDogbm90X2FfZmxvYXQgYXJyYXkpIGkgOiBub3RfYV9mbG9hdClcbjs7XG5cbmxldFtAaW5saW5lIGFsd2F5c10gdW5zYWZlX3NldF93aXRoX2NhbWxfbW9kaWZ5IHQgaSBvYmogPVxuICAoKiBTYW1lIGNvbW1lbnQgYXMgW3Vuc2FmZV9nZXRdLiBTeXMub3BhcXVlX2lkZW50aXR5IHByZXZlbnRzIHRoZSBjb21waWxlciBmcm9tXG4gICAgIHBvdGVudGlhbGx5IHdyb25nbHkgZ3Vlc3NpbmcgdGhlIHR5cGUgb2YgdGhlIGFycmF5IGJhc2VkIG9uIHRoZSB0eXBlIG9mIGVsZW1lbnQsIHRoYXRcbiAgICAgaXMgcHJldmVudCB0aGUgaW1wbGljYXRpb246IChPYmoudGFnIG9iaiA9IE9iai5kb3VibGVfdGFnKSA9PiAoT2JqLnRhZyB0ID1cbiAgICAgT2JqLmRvdWJsZV9hcnJheV90YWcpIHdoaWNoIGZsYW1iZGEgaGFzIHRyaWVkIGluIHRoZSBwYXN0IChhdCBsZWFzdCB0aGF0J3MgYXNzdW1pbmdcbiAgICAgdGhlIGNvbXBpbGVyIHJlc3BlY3RzIFN5cy5vcGFxdWVfaWRlbnRpdHksIHdoaWNoIGlzIG5vdCBhbHdheXMgdGhlIGNhc2UpLiAqKVxuICBBcnJheS51bnNhZmVfc2V0XG4gICAgKENhbWwuT2JqLm1hZ2ljICh0IDogdCkgOiBub3RfYV9mbG9hdCBhcnJheSlcbiAgICBpXG4gICAgKENhbWwuT2JqLm9iaiAoU3lzLm9wYXF1ZV9pZGVudGl0eSBvYmopIDogbm90X2FfZmxvYXQpXG47O1xuXG5sZXRbQGlubGluZSBhbHdheXNdIHNldF93aXRoX2NhbWxfbW9kaWZ5IHQgaSBvYmogPVxuICAoKiBzYW1lIGFzIHVuc2FmZV9zZXRfd2l0aF9jYW1sX21vZGlmeSBidXQgc2FmZSAqKVxuICAoQ2FtbC5PYmoubWFnaWMgKHQgOiB0KSA6IG5vdF9hX2Zsb2F0IGFycmF5KS4oaSlcbiAgPC0gKENhbWwuT2JqLm9iaiAoU3lzLm9wYXF1ZV9pZGVudGl0eSBvYmopIDogbm90X2FfZmxvYXQpXG47O1xuXG5sZXRbQGlubGluZSBhbHdheXNdIHVuc2FmZV9zZXRfaW50X2Fzc3VtaW5nX2N1cnJlbnRseV9pbnQgdCBpIGludCA9XG4gICgqIFRoaXMgc2tpcHMgW2NhbWxfbW9kaWZ5XSwgd2hpY2ggaXMgT0sgaWYgYm90aCB0aGUgb2xkIGFuZCBuZXcgdmFsdWVzIGFyZSBpbnRlZ2Vycy4gKilcbiAgQXJyYXkudW5zYWZlX3NldCAoQ2FtbC5PYmoubWFnaWMgKHQgOiB0KSA6IGludCBhcnJheSkgaSAoU3lzLm9wYXF1ZV9pZGVudGl0eSBpbnQpXG47O1xuXG4oKiBGb3IgW3NldF0gYW5kIFt1bnNhZmVfc2V0XSwgaWYgYSBwb2ludGVyIGlzIGludm9sdmVkLCB3ZSBmaXJzdCBkbyBhIHBoeXNpY2FsLWVxdWFsaXR5XG4gICB0ZXN0IHRvIHNlZSBpZiB0aGUgcG9pbnRlciBpcyBjaGFuZ2luZy4gIElmIG5vdCwgd2UgZG9uJ3QgbmVlZCB0byBkbyB0aGUgW3NldF0sIHdoaWNoXG4gICBzYXZlcyBhIGNhbGwgdG8gW2NhbWxfbW9kaWZ5XS4gIFdlIHRoaW5rIHRoaXMgcGh5c2ljYWwtZXF1YWxpdHkgdGVzdCBpcyB3b3J0aCBpdFxuICAgYmVjYXVzZSBpdCBpcyB2ZXJ5IGNoZWFwIChib3RoIHZhbHVlcyBhcmUgYWxyZWFkeSBhdmFpbGFibGUgZnJvbSB0aGUgW2lzX2ludF0gdGVzdClcbiAgIGFuZCBiZWNhdXNlIFtjYW1sX21vZGlmeV0gaXMgZXhwZW5zaXZlLiAqKVxuXG5sZXQgc2V0IHQgaSBvYmogPVxuICAoKiBXZSB1c2UgW2dldF0gZmlyc3QgYnV0IHRoZW4gd2UgdXNlIFtBcnJheS51bnNhZmVfc2V0XSBzaW5jZSB3ZSBrbm93IHRoYXQgW2ldIGlzXG4gICAgIHZhbGlkLiAqKVxuICBsZXQgb2xkX29iaiA9IGdldCB0IGkgaW5cbiAgaWYgQ2FtbC5PYmouaXNfaW50IG9sZF9vYmogJiYgQ2FtbC5PYmouaXNfaW50IG9ialxuICB0aGVuIHVuc2FmZV9zZXRfaW50X2Fzc3VtaW5nX2N1cnJlbnRseV9pbnQgdCBpIChDYW1sLk9iai5vYmogb2JqIDogaW50KVxuICBlbHNlIGlmIG5vdCAocGh5c19lcXVhbCBvbGRfb2JqIG9iailcbiAgdGhlbiB1bnNhZmVfc2V0X3dpdGhfY2FtbF9tb2RpZnkgdCBpIG9ialxuOztcblxubGV0W0BpbmxpbmUgYWx3YXlzXSB1bnNhZmVfc2V0IHQgaSBvYmogPVxuICBsZXQgb2xkX29iaiA9IHVuc2FmZV9nZXQgdCBpIGluXG4gIGlmIENhbWwuT2JqLmlzX2ludCBvbGRfb2JqICYmIENhbWwuT2JqLmlzX2ludCBvYmpcbiAgdGhlbiB1bnNhZmVfc2V0X2ludF9hc3N1bWluZ19jdXJyZW50bHlfaW50IHQgaSAoQ2FtbC5PYmoub2JqIG9iaiA6IGludClcbiAgZWxzZSBpZiBub3QgKHBoeXNfZXF1YWwgb2xkX29iaiBvYmopXG4gIHRoZW4gdW5zYWZlX3NldF93aXRoX2NhbWxfbW9kaWZ5IHQgaSBvYmpcbjs7XG5cbmxldFtAaW5saW5lIGFsd2F5c10gdW5zYWZlX3NldF9vbWl0X3BoeXNfZXF1YWxfY2hlY2sgdCBpIG9iaiA9XG4gIGxldCBvbGRfb2JqID0gdW5zYWZlX2dldCB0IGkgaW5cbiAgaWYgQ2FtbC5PYmouaXNfaW50IG9sZF9vYmogJiYgQ2FtbC5PYmouaXNfaW50IG9ialxuICB0aGVuIHVuc2FmZV9zZXRfaW50X2Fzc3VtaW5nX2N1cnJlbnRseV9pbnQgdCBpIChDYW1sLk9iai5vYmogb2JqIDogaW50KVxuICBlbHNlIHVuc2FmZV9zZXRfd2l0aF9jYW1sX21vZGlmeSB0IGkgb2JqXG47O1xuXG5sZXQgc3dhcCB0IGkgaiA9XG4gIGxldCBhID0gZ2V0IHQgaSBpblxuICBsZXQgYiA9IGdldCB0IGogaW5cbiAgdW5zYWZlX3NldCB0IGkgYjtcbiAgdW5zYWZlX3NldCB0IGogYVxuOztcblxubGV0IGNyZWF0ZSB+bGVuIHggPVxuICAoKiBJZiB3ZSBjYW4sIHVzZSBbQXJyYXkuY3JlYXRlXSBkaXJlY3RseS4gKilcbiAgaWYgQ2FtbC5PYmoudGFnIHggPD4gQ2FtbC5PYmouZG91YmxlX3RhZ1xuICB0aGVuIEFycmF5LmNyZWF0ZSB+bGVuIHhcbiAgZWxzZSAoXG4gICAgKCogT3RoZXJ3aXNlIHVzZSBbY3JlYXRlX3plcm9dIGFuZCBzZXQgdGhlIGNvbnRlbnRzICopXG4gICAgbGV0IHQgPSBjcmVhdGVfemVybyB+bGVuIGluXG4gICAgbGV0IHggPSBTeXMub3BhcXVlX2lkZW50aXR5IHggaW5cbiAgICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgICAgdW5zYWZlX3NldF93aXRoX2NhbWxfbW9kaWZ5IHQgaSB4XG4gICAgZG9uZTtcbiAgICB0KVxuOztcblxubGV0IHNpbmdsZXRvbiBvYmogPSBjcmVhdGUgfmxlbjoxIG9ialxuXG4oKiBQcmUtY29uZGl0aW9uOiB0LihpKSBpcyBhbiBpbnRlZ2VyLiAqKVxubGV0IHVuc2FmZV9zZXRfYXNzdW1pbmdfY3VycmVudGx5X2ludCB0IGkgb2JqID1cbiAgaWYgQ2FtbC5PYmouaXNfaW50IG9ialxuICB0aGVuIHVuc2FmZV9zZXRfaW50X2Fzc3VtaW5nX2N1cnJlbnRseV9pbnQgdCBpIChDYW1sLk9iai5vYmogb2JqIDogaW50KVxuICBlbHNlXG4gICAgKCogW3QuKGkpXSBpcyBhbiBpbnRlZ2VyIGFuZCBbb2JqXSBpcyBub3QsIHNvIHdlIGRvIG5vdCBuZWVkIHRvIGNoZWNrIGlmIHRoZXkgYXJlXG4gICAgICAgZXF1YWwuICopXG4gICAgdW5zYWZlX3NldF93aXRoX2NhbWxfbW9kaWZ5IHQgaSBvYmpcbjs7XG5cbmxldCB1bnNhZmVfc2V0X2ludCB0IGkgaW50ID1cbiAgbGV0IG9sZF9vYmogPSB1bnNhZmVfZ2V0IHQgaSBpblxuICBpZiBDYW1sLk9iai5pc19pbnQgb2xkX29ialxuICB0aGVuIHVuc2FmZV9zZXRfaW50X2Fzc3VtaW5nX2N1cnJlbnRseV9pbnQgdCBpIGludFxuICBlbHNlIHVuc2FmZV9zZXRfd2l0aF9jYW1sX21vZGlmeSB0IGkgKENhbWwuT2JqLnJlcHIgaW50KVxuOztcblxubGV0IHVuc2FmZV9jbGVhcl9pZl9wb2ludGVyIHQgaSA9XG4gIGxldCBvbGRfb2JqID0gdW5zYWZlX2dldCB0IGkgaW5cbiAgaWYgbm90IChDYW1sLk9iai5pc19pbnQgb2xkX29iaikgdGhlbiB1bnNhZmVfc2V0X3dpdGhfY2FtbF9tb2RpZnkgdCBpIChDYW1sLk9iai5yZXByIDApXG47O1xuXG4oKiogW3Vuc2FmZV9ibGl0XSBpcyBsaWtlIFtBcnJheS5ibGl0XSwgZXhjZXB0IGl0IHVzZXMgb3VyIG93biBmb3ItbG9vcCB0byBhdm9pZFxuICAgIGNhbWxfbW9kaWZ5IHdoZW4gcG9zc2libGUuICBJdHMgcGVyZm9ybWFuY2UgaXMgc3RpbGwgbm90IGNvbXBhcmFibGUgdG8gYSBtZW1jcHkuICopXG5sZXQgdW5zYWZlX2JsaXQgfnNyYyB+c3JjX3BvcyB+ZHN0IH5kc3RfcG9zIH5sZW4gPVxuICAoKiBXaGVuIFtwaHlzX2VxdWFsIHNyYyBkc3RdLCB3ZSBuZWVkIHRvIGNoZWNrIHdoZXRoZXIgW2RzdF9wb3MgPCBzcmNfcG9zXSBhbmQgaGF2ZSB0aGVcbiAgICAgZm9yIGxvb3AgZ28gaW4gdGhlIHJpZ2h0IGRpcmVjdGlvbiBzbyB0aGF0IHdlIGRvbid0IG92ZXJ3cml0ZSBkYXRhIHRoYXQgd2Ugc3RpbGwgbmVlZFxuICAgICB0byByZWFkLiAgV2hlbiBbbm90IChwaHlzX2VxdWFsIHNyYyBkc3QpXSwgZG9pbmcgdGhpcyBpcyBoYXJtbGVzcy4gIEZyb20gYVxuICAgICBtZW1vcnktcGVyZm9ybWFuY2UgcGVyc3BlY3RpdmUsIGl0IGRvZXNuJ3QgbWF0dGVyIHdoZXRoZXIgb25lIGxvb3BzIHVwIG9yIGRvd24uXG4gICAgIENvbnN0YW50LXN0cmlkZSBhY2Nlc3MsIGZvcndhcmQgb3IgYmFja3dhcmQsIHNob3VsZCBiZSBpbmRpc3Rpbmd1aXNoYWJsZSAoYXQgbGVhc3Qgb25cbiAgICAgYW4gaW50ZWwgaTcpLiAgU28sIHdlIGRvbid0IGRvIGEgY2hlY2sgZm9yIFtwaHlzX2VxdWFsIHNyYyBkc3RdIGFuZCBhbHdheXMgbG9vcCB1cCBpblxuICAgICB0aGF0IGNhc2UuICopXG4gIGlmIGRzdF9wb3MgPCBzcmNfcG9zXG4gIHRoZW5cbiAgICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgICAgdW5zYWZlX3NldCBkc3QgKGRzdF9wb3MgKyBpKSAodW5zYWZlX2dldCBzcmMgKHNyY19wb3MgKyBpKSlcbiAgICBkb25lXG4gIGVsc2VcbiAgICBmb3IgaSA9IGxlbiAtIDEgZG93bnRvIDAgZG9cbiAgICAgIHVuc2FmZV9zZXQgZHN0IChkc3RfcG9zICsgaSkgKHVuc2FmZV9nZXQgc3JjIChzcmNfcG9zICsgaSkpXG4gICAgZG9uZVxuOztcblxuaW5jbHVkZSBCbGl0Lk1ha2UgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgICBsZXQgY3JlYXRlID0gY3JlYXRlX3plcm9cbiAgICBsZXQgbGVuZ3RoID0gbGVuZ3RoXG4gICAgbGV0IHVuc2FmZV9ibGl0ID0gdW5zYWZlX2JsaXRcbiAgZW5kKVxuXG5sZXQgY29weSBzcmMgPVxuICBsZXQgZHN0ID0gY3JlYXRlX3plcm8gfmxlbjoobGVuZ3RoIHNyYykgaW5cbiAgYmxpdG8gfnNyYyB+ZHN0ICgpO1xuICBkc3Rcbjs7XG4iLCJvcGVuISBJbXBvcnRcblxuKCogV0FSTklORzpcbiAgIFdlIHVzZSBub24tbWVtb3J5LXNhZmUgdGhpbmdzIHRocm91Z2hvdXQgdGhlIFtUcnVzdGVkXSBtb2R1bGUuXG4gICBNb3N0IG9mIGl0IGlzIG9ubHkgc2FmZSBpbiBjb21iaW5hdGlvbiB3aXRoIHRoZSB0eXBlIHNpZ25hdHVyZSAoZS5nLiBleHBvc2luZ1xuICAgW3ZhbCBjb3B5IDogJ2EgdCAtPiAnYiB0XSB3b3VsZCBiZSBhIGJpZyBtaXN0YWtlKS4gKilcbm1vZHVsZSBUcnVzdGVkIDogc2lnXG4gIHR5cGUgJ2EgdFxuXG4gIHZhbCBlbXB0eSA6ICdhIHRcbiAgdmFsIHVuc2FmZV9jcmVhdGVfdW5pbml0aWFsaXplZCA6IGxlbjppbnQgLT4gJ2EgdFxuICB2YWwgY3JlYXRlX29ial9hcnJheSA6IGxlbjppbnQgLT4gJ2EgdFxuICB2YWwgY3JlYXRlIDogbGVuOmludCAtPiAnYSAtPiAnYSB0XG4gIHZhbCBzaW5nbGV0b24gOiAnYSAtPiAnYSB0XG4gIHZhbCBnZXQgOiAnYSB0IC0+IGludCAtPiAnYVxuICB2YWwgc2V0IDogJ2EgdCAtPiBpbnQgLT4gJ2EgLT4gdW5pdFxuICB2YWwgc3dhcCA6IF8gdCAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgdmFsIHVuc2FmZV9nZXQgOiAnYSB0IC0+IGludCAtPiAnYVxuICB2YWwgdW5zYWZlX3NldCA6ICdhIHQgLT4gaW50IC0+ICdhIC0+IHVuaXRcbiAgdmFsIHVuc2FmZV9zZXRfb21pdF9waHlzX2VxdWFsX2NoZWNrIDogJ2EgdCAtPiBpbnQgLT4gJ2EgLT4gdW5pdFxuICB2YWwgdW5zYWZlX3NldF9pbnQgOiAnYSB0IC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICB2YWwgdW5zYWZlX3NldF9pbnRfYXNzdW1pbmdfY3VycmVudGx5X2ludCA6ICdhIHQgLT4gaW50IC0+IGludCAtPiB1bml0XG4gIHZhbCB1bnNhZmVfc2V0X2Fzc3VtaW5nX2N1cnJlbnRseV9pbnQgOiAnYSB0IC0+IGludCAtPiAnYSAtPiB1bml0XG4gIHZhbCB1bnNhZmVfc2V0X3dpdGhfY2FtbF9tb2RpZnkgOiAnYSB0IC0+IGludCAtPiAnYSAtPiB1bml0XG4gIHZhbCBzZXRfd2l0aF9jYW1sX21vZGlmeSA6ICdhIHQgLT4gaW50IC0+ICdhIC0+IHVuaXRcbiAgdmFsIGxlbmd0aCA6ICdhIHQgLT4gaW50XG4gIHZhbCB1bnNhZmVfYmxpdCA6ICgnYSB0LCAnYSB0KSBCbGl0LmJsaXRcbiAgdmFsIGNvcHkgOiAnYSB0IC0+ICdhIHRcbiAgdmFsIHVuc2FmZV9jbGVhcl9pZl9wb2ludGVyIDogXyB0IC0+IGludCAtPiB1bml0XG5lbmQgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gT2JqX2FycmF5LnRcblxuICBsZXQgZW1wdHkgPSBPYmpfYXJyYXkuZW1wdHlcbiAgbGV0IHVuc2FmZV9jcmVhdGVfdW5pbml0aWFsaXplZCB+bGVuID0gT2JqX2FycmF5LmNyZWF0ZV96ZXJvIH5sZW5cbiAgbGV0IGNyZWF0ZV9vYmpfYXJyYXkgfmxlbiA9IE9ial9hcnJheS5jcmVhdGVfemVybyB+bGVuXG4gIGxldCBjcmVhdGUgfmxlbiB4ID0gT2JqX2FycmF5LmNyZWF0ZSB+bGVuIChDYW1sLk9iai5yZXByIHgpXG4gIGxldCBzaW5nbGV0b24geCA9IE9ial9hcnJheS5zaW5nbGV0b24gKENhbWwuT2JqLnJlcHIgeClcbiAgbGV0IHN3YXAgdCBpIGogPSBPYmpfYXJyYXkuc3dhcCB0IGkgalxuICBsZXQgZ2V0IGFyciBpID0gQ2FtbC5PYmoub2JqIChPYmpfYXJyYXkuZ2V0IGFyciBpKVxuICBsZXQgc2V0IGFyciBpIHggPSBPYmpfYXJyYXkuc2V0IGFyciBpIChDYW1sLk9iai5yZXByIHgpXG4gIGxldCB1bnNhZmVfZ2V0IGFyciBpID0gQ2FtbC5PYmoub2JqIChPYmpfYXJyYXkudW5zYWZlX2dldCBhcnIgaSlcbiAgbGV0IHVuc2FmZV9zZXQgYXJyIGkgeCA9IE9ial9hcnJheS51bnNhZmVfc2V0IGFyciBpIChDYW1sLk9iai5yZXByIHgpXG4gIGxldCB1bnNhZmVfc2V0X2ludCBhcnIgaSB4ID0gT2JqX2FycmF5LnVuc2FmZV9zZXRfaW50IGFyciBpIHhcblxuICBsZXQgdW5zYWZlX3NldF9pbnRfYXNzdW1pbmdfY3VycmVudGx5X2ludCBhcnIgaSB4ID1cbiAgICBPYmpfYXJyYXkudW5zYWZlX3NldF9pbnRfYXNzdW1pbmdfY3VycmVudGx5X2ludCBhcnIgaSB4XG4gIDs7XG5cbiAgbGV0IHVuc2FmZV9zZXRfYXNzdW1pbmdfY3VycmVudGx5X2ludCBhcnIgaSB4ID1cbiAgICBPYmpfYXJyYXkudW5zYWZlX3NldF9hc3N1bWluZ19jdXJyZW50bHlfaW50IGFyciBpIChDYW1sLk9iai5yZXByIHgpXG4gIDs7XG5cbiAgbGV0IGxlbmd0aCA9IE9ial9hcnJheS5sZW5ndGhcbiAgbGV0IHVuc2FmZV9ibGl0ID0gT2JqX2FycmF5LnVuc2FmZV9ibGl0XG4gIGxldCBjb3B5ID0gT2JqX2FycmF5LmNvcHlcblxuICBsZXQgdW5zYWZlX3NldF9vbWl0X3BoeXNfZXF1YWxfY2hlY2sgdCBpIHggPVxuICAgIE9ial9hcnJheS51bnNhZmVfc2V0X29taXRfcGh5c19lcXVhbF9jaGVjayB0IGkgKENhbWwuT2JqLnJlcHIgeClcbiAgOztcblxuICBsZXQgdW5zYWZlX3NldF93aXRoX2NhbWxfbW9kaWZ5IHQgaSB4ID1cbiAgICBPYmpfYXJyYXkudW5zYWZlX3NldF93aXRoX2NhbWxfbW9kaWZ5IHQgaSAoQ2FtbC5PYmoucmVwciB4KVxuICA7O1xuXG4gIGxldCBzZXRfd2l0aF9jYW1sX21vZGlmeSB0IGkgeCA9IE9ial9hcnJheS5zZXRfd2l0aF9jYW1sX21vZGlmeSB0IGkgKENhbWwuT2JqLnJlcHIgeClcbiAgbGV0IHVuc2FmZV9jbGVhcl9pZl9wb2ludGVyID0gT2JqX2FycmF5LnVuc2FmZV9jbGVhcl9pZl9wb2ludGVyXG5lbmRcblxuaW5jbHVkZSBUcnVzdGVkXG5cbmxldCBpbnZhcmlhbnQgdCA9IGFzc2VydCAoQ2FtbC5PYmoudGFnIChDYW1sLk9iai5yZXByIHQpIDw+IENhbWwuT2JqLmRvdWJsZV9hcnJheV90YWcpXG5cbmxldCBpbml0IGwgfmYgPVxuICBpZiBsIDwgMFxuICB0aGVuIGludmFsaWRfYXJnIFwiVW5pZm9ybV9hcnJheS5pbml0XCJcbiAgZWxzZSAoXG4gICAgbGV0IHJlcyA9IHVuc2FmZV9jcmVhdGVfdW5pbml0aWFsaXplZCB+bGVuOmwgaW5cbiAgICBmb3IgaSA9IDAgdG8gbCAtIDEgZG9cbiAgICAgIHVuc2FmZV9zZXQgcmVzIGkgKGYgaSlcbiAgICBkb25lO1xuICAgIHJlcylcbjs7XG5cbmxldCBvZl9hcnJheSBhcnIgPSBpbml0IH5mOihBcnJheS51bnNhZmVfZ2V0IGFycikgKEFycmF5Lmxlbmd0aCBhcnIpXG5sZXQgbWFwIGEgfmYgPSBpbml0IH5mOihmdW4gaSAtPiBmICh1bnNhZmVfZ2V0IGEgaSkpIChsZW5ndGggYSlcbmxldCBtYXBpIGEgfmYgPSBpbml0IH5mOihmdW4gaSAtPiBmIGkgKHVuc2FmZV9nZXQgYSBpKSkgKGxlbmd0aCBhKVxuXG5sZXQgaXRlciBhIH5mID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkb1xuICAgIGYgKHVuc2FmZV9nZXQgYSBpKVxuICBkb25lXG47O1xuXG5sZXQgaXRlcmkgYSB+ZiA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG9cbiAgICBmIGkgKHVuc2FmZV9nZXQgYSBpKVxuICBkb25lXG47O1xuXG5sZXQgZm9sZGkgYSB+aW5pdCB+ZiA9XG4gIGxldCBhY2MgPSByZWYgaW5pdCBpblxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvXG4gICAgYWNjIDo9IGYgaSAhYWNjICh1bnNhZmVfZ2V0IGEgaSlcbiAgZG9uZTtcbiAgIWFjY1xuOztcblxubGV0IHRvX2xpc3QgdCA9IExpc3QuaW5pdCB+ZjooZ2V0IHQpIChsZW5ndGggdClcblxubGV0IG9mX2xpc3QgbCA9XG4gIGxldCBsZW4gPSBMaXN0Lmxlbmd0aCBsIGluXG4gIGxldCByZXMgPSB1bnNhZmVfY3JlYXRlX3VuaW5pdGlhbGl6ZWQgfmxlbiBpblxuICBMaXN0Lml0ZXJpIGwgfmY6KGZ1biBpIHggLT4gc2V0IHJlcyBpIHgpO1xuICByZXNcbjs7XG5cbigqIEl0IGlzIG5vdCBzYWZlIGZvciBbdG9fYXJyYXldIHRvIGJlIHRoZSBpZGVudGl0eSBmdW5jdGlvbiBiZWNhdXNlIHdlIGhhdmUgY29kZSB0aGF0XG4gICByZWxpZXMgb24gW2Zsb2F0IGFycmF5XXMgYmVpbmcgdW5ib3hlZCwgZm9yIGV4YW1wbGUgaW4gW2Jpbl93cml0ZV9hcnJheV0uICopXG5sZXQgdG9fYXJyYXkgdCA9IEFycmF5LmluaXQgKGxlbmd0aCB0KSB+ZjooZnVuIGkgLT4gdW5zYWZlX2dldCB0IGkpXG5cbmxldCBleGlzdHMgdCB+ZiA9XG4gIGxldCByZWMgbG9vcCB0IH5mIGkgPVxuICAgIGlmIGkgPCAwIHRoZW4gZmFsc2UgZWxzZSBmICh1bnNhZmVfZ2V0IHQgaSkgfHwgbG9vcCB0IH5mIChpIC0gMSlcbiAgaW5cbiAgbG9vcCB0IH5mIChsZW5ndGggdCAtIDEpXG47O1xuXG5sZXQgZm9yX2FsbCB0IH5mID1cbiAgbGV0IHJlYyBsb29wIHQgfmYgaSA9IGlmIGkgPCAwIHRoZW4gdHJ1ZSBlbHNlIGYgKHVuc2FmZV9nZXQgdCBpKSAmJiBsb29wIHQgfmYgKGkgLSAxKSBpblxuICBsb29wIHQgfmYgKGxlbmd0aCB0IC0gMSlcbjs7XG5cbmxldCBtYXAyX2V4biB0MSB0MiB+ZiA9XG4gIGxldCBsZW4gPSBsZW5ndGggdDEgaW5cbiAgaWYgbGVuZ3RoIHQyIDw+IGxlbiB0aGVuIGludmFsaWRfYXJnIFwiQXJyYXkubWFwMl9leG5cIjtcbiAgaW5pdCBsZW4gfmY6KGZ1biBpIC0+IGYgKHVuc2FmZV9nZXQgdDEgaSkgKHVuc2FmZV9nZXQgdDIgaSkpXG47O1xuXG5sZXQgdF9zZXhwX2dyYW1tYXIgKHR5cGUgZWx0KSAoZ3JhbW1hciA6IGVsdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudClcbiAgOiBlbHQgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICA9XG4gIFNleHBsaWIwLlNleHBfZ3JhbW1hci5jb2VyY2UgKEFycmF5LnRfc2V4cF9ncmFtbWFyIGdyYW1tYXIpXG47O1xuXG5pbmNsdWRlXG4gIFNleHBhYmxlLk9mX3NleHBhYmxlMVxuICAgIChBcnJheSlcbiAgICAoc3RydWN0XG4gICAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gICAgICBsZXQgdG9fc2V4cGFibGUgPSB0b19hcnJheVxuICAgICAgbGV0IG9mX3NleHBhYmxlID0gb2ZfYXJyYXlcbiAgICBlbmQpXG5cbmluY2x1ZGUgQmxpdC5NYWtlMSAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICAgIGxldCBsZW5ndGggPSBsZW5ndGhcblxuICAgIGxldCBjcmVhdGVfbGlrZSB+bGVuIHQgPVxuICAgICAgaWYgbGVuID0gMFxuICAgICAgdGhlbiBlbXB0eVxuICAgICAgZWxzZSAoXG4gICAgICAgIGFzc2VydCAobGVuZ3RoIHQgPiAwKTtcbiAgICAgICAgY3JlYXRlIH5sZW4gKGdldCB0IDApKVxuICAgIDs7XG5cbiAgICBsZXQgdW5zYWZlX2JsaXQgPSB1bnNhZmVfYmxpdFxuICBlbmQpXG5cbmxldCBmb2xkIHQgfmluaXQgfmYgPVxuICBsZXQgciA9IHJlZiBpbml0IGluXG4gIGZvciBpID0gMCB0byBsZW5ndGggdCAtIDEgZG9cbiAgICByIDo9IGYgIXIgKHVuc2FmZV9nZXQgdCBpKVxuICBkb25lO1xuICAhclxuOztcblxubGV0IG1pbl9lbHQgdCB+Y29tcGFyZSA9IENvbnRhaW5lci5taW5fZWx0IH5mb2xkIHQgfmNvbXBhcmVcbmxldCBtYXhfZWx0IHQgfmNvbXBhcmUgPSBDb250YWluZXIubWF4X2VsdCB+Zm9sZCB0IH5jb21wYXJlXG5cbigqIFRoaXMgaXMgdGhlIHNhbWUgYXMgdGhlIHBweF9jb21wYXJlIFtjb21wYXJlX2FycmF5XSBidXQgdXNlcyBvdXIgW3Vuc2FmZV9nZXRdIGFuZCBbbGVuZ3RoXS4gKilcbmxldCBjb21wYXJlIGNvbXBhcmVfZWx0IGEgYiA9XG4gIGlmIHBoeXNfZXF1YWwgYSBiXG4gIHRoZW4gMFxuICBlbHNlIChcbiAgICBsZXQgbGVuX2EgPSBsZW5ndGggYSBpblxuICAgIGxldCBsZW5fYiA9IGxlbmd0aCBiIGluXG4gICAgbGV0IHJldCA9IGNvbXBhcmUgbGVuX2EgbGVuX2IgaW5cbiAgICBpZiByZXQgPD4gMFxuICAgIHRoZW4gcmV0XG4gICAgZWxzZSAoXG4gICAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICAgIGlmIGkgPSBsZW5fYVxuICAgICAgICB0aGVuIDBcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgbGV0IGwgPSB1bnNhZmVfZ2V0IGEgaVxuICAgICAgICAgIGFuZCByID0gdW5zYWZlX2dldCBiIGkgaW5cbiAgICAgICAgICBsZXQgcmVzID0gY29tcGFyZV9lbHQgbCByIGluXG4gICAgICAgICAgaWYgcmVzIDw+IDAgdGhlbiByZXMgZWxzZSBsb29wIChpICsgMSkpXG4gICAgICBpblxuICAgICAgbG9vcCAwKSlcbjs7XG4iLCJvcGVuISBJbXBvcnRcblxuKCoqIFsnYSBDaGVhcF9vcHRpb24udF0gaXMgbGlrZSBbJ2Egb3B0aW9uXSwgYnV0IGl0IGRvZXNuJ3QgYm94IFtzb21lIF9dIHZhbHVlcy5cblxuICAgIFRoZXJlIGFyZSBzZXZlcmFsIHRoaW5ncyB0aGF0IGFyZSB1bnNhZmUgYWJvdXQgaXQ6XG5cbiAgICAtIFtmbG9hdCB0IGFycmF5XSAob3IgYW55IGFycmF5LWJhY2tlZCBjb250YWluZXIpIGlzIG5vdCBtZW1vcnktc2FmZVxuICAgICAgYmVjYXVzZSBmbG9hdCBhcnJheSBvcHRpbWl6YXRpb24gaXMgaW5jb21wYXRpYmxlIHdpdGggdW5ib3hlZCBvcHRpb25cbiAgICAgIG9wdGltaXphdGlvbi4gWW91IGhhdmUgdG8gdXNlIFtVbmlmb3JtX2FycmF5LnRdIGluc3RlYWQgb2YgW2FycmF5XS5cblxuICAgIC0gTmVzdGVkIG9wdGlvbnMgKFsnYSB0IHRdKSBkb24ndCB3b3JrLiBUaGV5IGFyZSBiZWxpZXZlZCB0byBiZVxuICAgICAgbWVtb3J5LXNhZmUsIGJ1dCBub3QgcGFyYW1ldHJpYy5cblxuICAgIC0gQSByZWNvcmQgd2l0aCBbZmxvYXQgdF1zIGluIGl0IHNob3VsZCBiZSBzYWZlLCBidXQgaXQncyBvbmx5IFt0XSBiZWluZ1xuICAgICAgYWJzdHJhY3QgdGhhdCBnaXZlcyB5b3Ugc2FmZXR5LiBJZiB0aGUgY29tcGlsZXIgd2FzIHNtYXJ0IGVub3VnaCB0byBwZWVrXG4gICAgICB0aHJvdWdoIHRoZSBtb2R1bGUgc2lnbmF0dXJlIHRoZW4gaXQgY291bGQgZGVjaWRlIHRvIGNvbnN0cnVjdCBhIGZsb2F0XG4gICAgICBhcnJheSBpbnN0ZWFkLiAqKVxubW9kdWxlIENoZWFwX29wdGlvbiA9IHN0cnVjdFxuICAoKiBUaGlzIGlzIHRha2VuIGZyb20gY29yZS4gUmF0aGVyIHRoYW4gZXhwb3NlIGl0IGluIHRoZSBwdWJsaWMgaW50ZXJmYWNlIG9mIGJhc2UsIGp1c3RcbiAgICAga2VlcCBhIGNvcHkgYXJvdW5kIGhlcmUuICopXG4gIGxldCBwaHlzX3NhbWUgKHR5cGUgYSBiKSAoYSA6IGEpIChiIDogYikgPSBwaHlzX2VxdWFsIGEgKENhbWwuT2JqLm1hZ2ljIGIgOiBhKVxuXG4gIG1vZHVsZSBUMCA6IHNpZ1xuICAgIHR5cGUgJ2EgdFxuXG4gICAgdmFsIG5vbmUgOiBfIHRcbiAgICB2YWwgc29tZSA6ICdhIC0+ICdhIHRcbiAgICB2YWwgaXNfbm9uZSA6IF8gdCAtPiBib29sXG4gICAgdmFsIGlzX3NvbWUgOiBfIHQgLT4gYm9vbFxuICAgIHZhbCB2YWx1ZV9leG4gOiAnYSB0IC0+ICdhXG4gICAgdmFsIHZhbHVlX3Vuc2FmZSA6ICdhIHQgLT4gJ2FcbiAgICB2YWwgaXRlcl9zb21lIDogJ2EgdCAtPiBmOignYSAtPiB1bml0KSAtPiB1bml0XG4gIGVuZCA9IHN0cnVjdFxuICAgIHR5cGUgKydhIHRcblxuICAgICgqIEJlaW5nIGEgcG9pbnRlciwgbm8gb25lIG91dHNpZGUgdGhpcyBtb2R1bGUgY2FuIGNvbnN0cnVjdCBhIHZhbHVlIHRoYXQgaXNcbiAgICAgICBbcGh5c19zYW1lXSBhcyB0aGlzIG9uZS5cblxuICAgICAgIEl0IHdvdWxkIGJlIHNpbXBsZXIgdG8gdXNlIHRoaXMgdmFsdWUgYXMgW25vbmVdLCBidXQgd2UgdXNlIGFuIGltbWVkaWF0ZSBpbnN0ZWFkXG4gICAgICAgYmVjYXVzZSBpdCBsZXRzIHVzIGF2b2lkIGNhbWxfbW9kaWZ5IHdoZW4gc2V0dGluZyB0byBbbm9uZV0sIG1ha2luZyBjZXJ0YWluXG4gICAgICAgYmVuY2htYXJrcyBzaWduaWZpY2FudGx5IGZhc3RlciAoZS5nLiAuLi9iZW5jaC9hcnJheV9xdWV1ZS5leGUpLlxuXG4gICAgICAgdGhpcyBjb2RlIGlzIGR1cGxpY2F0ZWQgaW4gTW9wdGlvbiwgYW5kIGlmIHdlIGZpbmQgeWV0IGFub3RoZXIgcGxhY2Ugd2hlcmUgd2Ugd2FudFxuICAgICAgIGl0IHdlIHNob3VsZCByZWNvbnNpZGVyIG1ha2luZyBpdCBzaGFyZWQuICopXG4gICAgbGV0IG5vbmVfc3Vic3RpdHV0ZSA6IF8gdCA9IENhbWwuT2JqLm9iaiAoQ2FtbC5PYmoubmV3X2Jsb2NrIENhbWwuT2JqLmFic3RyYWN0X3RhZyAxKVxuXG4gICAgbGV0IG5vbmUgOiBfIHQgPVxuICAgICAgKCogVGhlIG51bWJlciB3YXMgcHJvZHVjZWQgYnlcbiAgICAgICAgIFs8IC9kZXYvdXJhbmRvbSB0ciAtYyAtZCAnMTIzNDU2Nzg5MGFiY2RlZicgfCBoZWFkIC1jIDE2XS5cblxuICAgICAgICAgVGhlIGlkZWEgaXMgdGhhdCBhIHJhbmRvbSBudW1iZXIgd2lsbCBoYXZlIGxvd2VyIHByb2JhYmlsaXR5IHRvIGNvbGxpZGUgd2l0aFxuICAgICAgICAgYW55dGhpbmcgdGhhbiBhbnkgbnVtYmVyIHdlIGNhbiBjaG9vc2Ugb3Vyc2VsdmVzLlxuXG4gICAgICAgICBXZSBhcmUgdXNpbmcgYSBwb2x5bW9ycGhpYyB2YXJpYW50IGluc3RlYWQgb2YgYW4gaW50ZWdlciBjb25zdGFudCBiZWNhdXNlIHRoZXJlXG4gICAgICAgICBpcyBhIGNvbXBpbGVyIGJ1ZyB3aGVyZSBpdCB3cm9uZ2x5IGFzc3VtZXMgdGhhdCB0aGUgcmVzdWx0IG9mIFtpZiBfIHRoZW4gYyBlbHNlXG4gICAgICAgICB5XSBpcyBub3QgYSBwb2ludGVyIGlmIFtjXSBpcyBhbiBpbnRlZ2VyIGNvbXBpbGUtdGltZSBjb25zdGFudC4gIFRoaXMgaXMgYmVpbmdcbiAgICAgICAgIGZpeGVkIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9vY2FtbC9vY2FtbC9wdWxsLzU1NS4gIFRoZSBcIm1lbW9yeSBjb3JydXB0aW9uXCIgdGVzdFxuICAgICAgICAgYmVsb3cgZGVtb25zdHJhdGVzIHRoZSBpc3N1ZS4gICopXG4gICAgICBDYW1sLk9iai5tYWdpYyBgeDZlOGVlMzQ3OGUxZDc0NDlcbiAgICA7O1xuXG4gICAgbGV0IGlzX25vbmUgeCA9IHBoeXNfZXF1YWwgeCBub25lXG4gICAgbGV0IGlzX3NvbWUgeCA9IG5vdCAocGh5c19lcXVhbCB4IG5vbmUpXG5cbiAgICBsZXQgc29tZSAodHlwZSBhKSAoeCA6IGEpIDogYSB0ID1cbiAgICAgIGlmIHBoeXNfc2FtZSB4IG5vbmUgdGhlbiBub25lX3N1YnN0aXR1dGUgZWxzZSBDYW1sLk9iai5tYWdpYyB4XG4gICAgOztcblxuICAgIGxldCB2YWx1ZV91bnNhZmUgKHR5cGUgYSkgKHggOiBhIHQpIDogYSA9XG4gICAgICBpZiBwaHlzX2VxdWFsIHggbm9uZV9zdWJzdGl0dXRlIHRoZW4gQ2FtbC5PYmoubWFnaWMgbm9uZSBlbHNlIENhbWwuT2JqLm1hZ2ljIHhcbiAgICA7O1xuXG4gICAgbGV0IHZhbHVlX2V4biB4ID1cbiAgICAgIGlmIGlzX3NvbWUgeFxuICAgICAgdGhlbiB2YWx1ZV91bnNhZmUgeFxuICAgICAgZWxzZSBmYWlsd2l0aCBcIk9wdGlvbl9hcnJheS5nZXRfc29tZV9leG46IHRoZSBlbGVtZW50IGlzIFtOb25lXVwiXG4gICAgOztcblxuICAgIGxldCBpdGVyX3NvbWUgdCB+ZiA9IGlmIGlzX3NvbWUgdCB0aGVuIGYgKHZhbHVlX3Vuc2FmZSB0KVxuICBlbmRcblxuICBtb2R1bGUgVDEgPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIFQwXG5cbiAgICBsZXQgb2Zfb3B0aW9uID0gZnVuY3Rpb25cbiAgICAgIHwgTm9uZSAtPiBub25lXG4gICAgICB8IFNvbWUgeCAtPiBzb21lIHhcbiAgICA7O1xuXG4gICAgbGV0W0BpbmxpbmVdIHRvX29wdGlvbiB4ID0gaWYgaXNfc29tZSB4IHRoZW4gU29tZSAodmFsdWVfdW5zYWZlIHgpIGVsc2UgTm9uZVxuICAgIGxldCB0b19zZXhwYWJsZSA9IHRvX29wdGlvblxuICAgIGxldCBvZl9zZXhwYWJsZSA9IG9mX29wdGlvblxuXG4gICAgbGV0IHRfc2V4cF9ncmFtbWFyICh0eXBlIGEpIChncmFtbWFyIDogYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudClcbiAgICAgIDogYSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgICA9XG4gICAgICBTZXhwbGliMC5TZXhwX2dyYW1tYXIuY29lcmNlIChPcHRpb24udF9zZXhwX2dyYW1tYXIgZ3JhbW1hcilcbiAgICA7O1xuICBlbmRcblxuICBpbmNsdWRlIFQxXG4gIGluY2x1ZGUgU2V4cGFibGUuT2Zfc2V4cGFibGUxIChPcHRpb24pIChUMSlcbmVuZFxuXG50eXBlICdhIHQgPSAnYSBDaGVhcF9vcHRpb24udCBVbmlmb3JtX2FycmF5LnQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHAsIHNleHBfZ3JhbW1hcl1cblxubGV0IHRfb2Zfc2V4cCA6ICdhLiAoU2V4cGxpYjAuU2V4cC50IC0+ICdhKSAtPiBTZXhwbGliMC5TZXhwLnQgLT4gJ2EgdCA9XG4gIGZ1biBfb2ZfYV9fMDAxXyB4X18wMDNfIC0+XG4gIFVuaWZvcm1fYXJyYXkudF9vZl9zZXhwIChDaGVhcF9vcHRpb24udF9vZl9zZXhwIF9vZl9hX18wMDFfKSB4X18wMDNfXG47O1xuXG5sZXQgc2V4cF9vZl90IDogJ2EuICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICdhIHQgLT4gU2V4cGxpYjAuU2V4cC50ID1cbiAgZnVuIF9vZl9hX18wMDRfIHhfXzAwNV8gLT5cbiAgVW5pZm9ybV9hcnJheS5zZXhwX29mX3QgKENoZWFwX29wdGlvbi5zZXhwX29mX3QgX29mX2FfXzAwNF8pIHhfXzAwNV9cbjs7XG5cbmxldCAodF9zZXhwX2dyYW1tYXIgOiAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCAtPiAnYSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9XG4gIGZ1biBfJ2Ffc2V4cF9ncmFtbWFyIC0+XG4gIFVuaWZvcm1fYXJyYXkudF9zZXhwX2dyYW1tYXIgKENoZWFwX29wdGlvbi50X3NleHBfZ3JhbW1hciBfJ2Ffc2V4cF9ncmFtbWFyKVxuOztcblxuW0BAQGVuZF1cblxubGV0IGVtcHR5ID0gVW5pZm9ybV9hcnJheS5lbXB0eVxubGV0IGNyZWF0ZSB+bGVuID0gVW5pZm9ybV9hcnJheS5jcmVhdGUgfmxlbiBDaGVhcF9vcHRpb24ubm9uZVxubGV0IGluaXQgbiB+ZiA9IFVuaWZvcm1fYXJyYXkuaW5pdCBuIH5mOihmdW4gaSAtPiBDaGVhcF9vcHRpb24ub2Zfb3B0aW9uIChmIGkpKVxubGV0IGluaXRfc29tZSBuIH5mID0gVW5pZm9ybV9hcnJheS5pbml0IG4gfmY6KGZ1biBpIC0+IENoZWFwX29wdGlvbi5zb21lIChmIGkpKVxubGV0IGxlbmd0aCA9IFVuaWZvcm1fYXJyYXkubGVuZ3RoXG5sZXRbQGlubGluZV0gZ2V0IHQgaSA9IENoZWFwX29wdGlvbi50b19vcHRpb24gKFVuaWZvcm1fYXJyYXkuZ2V0IHQgaSlcbmxldCBnZXRfc29tZV9leG4gdCBpID0gQ2hlYXBfb3B0aW9uLnZhbHVlX2V4biAoVW5pZm9ybV9hcnJheS5nZXQgdCBpKVxubGV0IGlzX25vbmUgdCBpID0gQ2hlYXBfb3B0aW9uLmlzX25vbmUgKFVuaWZvcm1fYXJyYXkuZ2V0IHQgaSlcbmxldCBpc19zb21lIHQgaSA9IENoZWFwX29wdGlvbi5pc19zb21lIChVbmlmb3JtX2FycmF5LmdldCB0IGkpXG5sZXQgc2V0IHQgaSB4ID0gVW5pZm9ybV9hcnJheS5zZXQgdCBpIChDaGVhcF9vcHRpb24ub2Zfb3B0aW9uIHgpXG5sZXQgc2V0X3NvbWUgdCBpIHggPSBVbmlmb3JtX2FycmF5LnNldCB0IGkgKENoZWFwX29wdGlvbi5zb21lIHgpXG5sZXQgc2V0X25vbmUgdCBpID0gVW5pZm9ybV9hcnJheS5zZXQgdCBpIENoZWFwX29wdGlvbi5ub25lXG5sZXQgc3dhcCB0IGkgaiA9IFVuaWZvcm1fYXJyYXkuc3dhcCB0IGkgalxubGV0IHVuc2FmZV9nZXQgdCBpID0gQ2hlYXBfb3B0aW9uLnRvX29wdGlvbiAoVW5pZm9ybV9hcnJheS51bnNhZmVfZ2V0IHQgaSlcbmxldCB1bnNhZmVfZ2V0X3NvbWVfZXhuIHQgaSA9IENoZWFwX29wdGlvbi52YWx1ZV9leG4gKFVuaWZvcm1fYXJyYXkudW5zYWZlX2dldCB0IGkpXG5cbmxldCB1bnNhZmVfZ2V0X3NvbWVfYXNzdW1pbmdfc29tZSB0IGkgPVxuICBDaGVhcF9vcHRpb24udmFsdWVfdW5zYWZlIChVbmlmb3JtX2FycmF5LnVuc2FmZV9nZXQgdCBpKVxuOztcblxubGV0IHVuc2FmZV9pc19zb21lIHQgaSA9IENoZWFwX29wdGlvbi5pc19zb21lIChVbmlmb3JtX2FycmF5LnVuc2FmZV9nZXQgdCBpKVxubGV0IHVuc2FmZV9zZXQgdCBpIHggPSBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCBpIChDaGVhcF9vcHRpb24ub2Zfb3B0aW9uIHgpXG5sZXQgdW5zYWZlX3NldF9zb21lIHQgaSB4ID0gVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgaSAoQ2hlYXBfb3B0aW9uLnNvbWUgeClcbmxldCB1bnNhZmVfc2V0X25vbmUgdCBpID0gVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgaSBDaGVhcF9vcHRpb24ubm9uZVxuXG5sZXQgY2xlYXIgdCA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggdCAtIDEgZG9cbiAgICB1bnNhZmVfc2V0X25vbmUgdCBpXG4gIGRvbmVcbjs7XG5cbmxldCBpdGVyaSBpbnB1dCB+ZiA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggaW5wdXQgLSAxIGRvXG4gICAgZiBpICh1bnNhZmVfZ2V0IGlucHV0IGkpXG4gIGRvbmVcbjs7XG5cbmxldCBpdGVyIGlucHV0IH5mID0gaXRlcmkgaW5wdXQgfmY6KGZ1biAoXyA6IGludCkgeCAtPiBmIHgpXG5cbmxldCBmb2xkaSBpbnB1dCB+aW5pdCB+ZiA9XG4gIGxldCBhY2MgPSByZWYgaW5pdCBpblxuICBpdGVyaSBpbnB1dCB+ZjooZnVuIGkgZWxlbSAtPiBhY2MgOj0gZiBpICFhY2MgZWxlbSk7XG4gICFhY2Ncbjs7XG5cbmxldCBmb2xkIGlucHV0IH5pbml0IH5mID0gZm9sZGkgaW5wdXQgfmluaXQgfmY6KGZ1biAoXyA6IGludCkgYWNjIHggLT4gZiBhY2MgeClcblxuaW5jbHVkZSBJbmRleGVkX2NvbnRhaW5lci5NYWtlX2dlbiAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcbiAgICB0eXBlICdhIGVsdCA9ICdhIG9wdGlvblxuXG4gICAgbGV0IGZvbGQgPSBmb2xkXG4gICAgbGV0IGZvbGRpID0gYEN1c3RvbSBmb2xkaVxuICAgIGxldCBpdGVyID0gYEN1c3RvbSBpdGVyXG4gICAgbGV0IGl0ZXJpID0gYEN1c3RvbSBpdGVyaVxuICAgIGxldCBsZW5ndGggPSBgQ3VzdG9tIGxlbmd0aFxuICBlbmQpXG5cbmxldCBtYXBpIGlucHV0IH5mID1cbiAgbGV0IG91dHB1dCA9IGNyZWF0ZSB+bGVuOihsZW5ndGggaW5wdXQpIGluXG4gIGl0ZXJpIGlucHV0IH5mOihmdW4gaSBlbGVtIC0+IHVuc2FmZV9zZXQgb3V0cHV0IGkgKGYgaSBlbGVtKSk7XG4gIG91dHB1dFxuOztcblxubGV0IG1hcCBpbnB1dCB+ZiA9IG1hcGkgaW5wdXQgfmY6KGZ1biAoXyA6IGludCkgZWxlbSAtPiBmIGVsZW0pXG5cbmxldCBtYXBfc29tZSBpbnB1dCB+ZiA9XG4gIGxldCBsZW4gPSBsZW5ndGggaW5wdXQgaW5cbiAgbGV0IG91dHB1dCA9IGNyZWF0ZSB+bGVuIGluXG4gIGxldCAoKSA9XG4gICAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICAgIGxldCBvcHQgPSBVbmlmb3JtX2FycmF5LnVuc2FmZV9nZXQgaW5wdXQgaSBpblxuICAgICAgQ2hlYXBfb3B0aW9uLml0ZXJfc29tZSBvcHQgfmY6KGZ1biB4IC0+IHVuc2FmZV9zZXRfc29tZSBvdXRwdXQgaSAoZiB4KSlcbiAgICBkb25lXG4gIGluXG4gIG91dHB1dFxuOztcblxubGV0IG9mX2FycmF5IGFycmF5ID0gaW5pdCAoQXJyYXkubGVuZ3RoIGFycmF5KSB+ZjooZnVuIGkgLT4gQXJyYXkudW5zYWZlX2dldCBhcnJheSBpKVxuXG5sZXQgb2ZfYXJyYXlfc29tZSBhcnJheSA9XG4gIGluaXRfc29tZSAoQXJyYXkubGVuZ3RoIGFycmF5KSB+ZjooZnVuIGkgLT4gQXJyYXkudW5zYWZlX2dldCBhcnJheSBpKVxuOztcblxubGV0IHRvX2FycmF5IHQgPSBBcnJheS5pbml0IChsZW5ndGggdCkgfmY6KGZ1biBpIC0+IHVuc2FmZV9nZXQgdCBpKVxuXG5pbmNsdWRlIEJsaXQuTWFrZTFfZ2VuZXJpYyAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICAgIGxldCBsZW5ndGggPSBsZW5ndGhcbiAgICBsZXQgY3JlYXRlX2xpa2UgfmxlbiBfID0gY3JlYXRlIH5sZW5cbiAgICBsZXQgdW5zYWZlX2JsaXQgPSBVbmlmb3JtX2FycmF5LnVuc2FmZV9ibGl0XG4gIGVuZClcblxubGV0IGNvcHkgPSBVbmlmb3JtX2FycmF5LmNvcHlcblxubW9kdWxlIEZvcl90ZXN0aW5nID0gc3RydWN0XG4gIG1vZHVsZSBVbnNhZmVfY2hlYXBfb3B0aW9uID0gQ2hlYXBfb3B0aW9uXG5lbmRcbiIsIm9wZW4hIEltcG9ydFxuXG4oKiBPcGVuIHJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBhZnRlciBpbmNsdWRpbmcgZnVuY3RvciBpbnN0YW50aWF0aW9ucyBzbyB0aGV5IGRvIG5vdFxuICAgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpcyBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uXG4gICBmdW5jdGlvbnMgYXJlIGF2YWlsYWJsZSB3aXRoaW4gdGhpcyBtb2R1bGUuICopXG5vcGVuISBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxubGV0IGNlaWwgPSBDYW1sLmNlaWxcbmxldCBmbG9vciA9IENhbWwuZmxvb3JcbmxldCBtb2RfZmxvYXQgPSBDYW1sLm1vZF9mbG9hdFxubGV0IG1vZGYgPSBDYW1sLm1vZGZcbmxldCBmbG9hdF9vZl9zdHJpbmcgPSBDYW1sLmZsb2F0X29mX3N0cmluZ1xubGV0IG5hbiA9IENhbWwubmFuXG5sZXQgaW5maW5pdHkgPSBDYW1sLmluZmluaXR5XG5sZXQgbmVnX2luZmluaXR5ID0gQ2FtbC5uZWdfaW5maW5pdHlcbmxldCBtYXhfZmluaXRlX3ZhbHVlID0gQ2FtbC5tYXhfZmxvYXRcbmxldCBlcHNpbG9uX2Zsb2F0ID0gQ2FtbC5lcHNpbG9uX2Zsb2F0XG5sZXQgY2xhc3NpZnlfZmxvYXQgPSBDYW1sLmNsYXNzaWZ5X2Zsb2F0XG5sZXQgYWJzX2Zsb2F0ID0gQ2FtbC5hYnNfZmxvYXRcbmxldCBpc19pbnRlZ2VyID0gQ2FtbC5GbG9hdC5pc19pbnRlZ2VyXG5sZXQgKCAqKiApID0gQ2FtbC4oICoqIClcblxubGV0ICggJS4gKSBhIGIgPVxuICAoKiBSYWlzZSBpbiBjYXNlIG9mIGEgbmVnYXRpdmUgbW9kdWx1cywgYXMgZG9lcyBJbnQuKCAlICkuICopXG4gIGlmIGIgPCAwLlxuICB0aGVuIFByaW50Zi5pbnZhbGlkX2FyZ2YgXCIlZiAlJSAlZiBpbiBmbG9hdDAubWw6IG1vZHVsdXMgc2hvdWxkIGJlIHBvc2l0aXZlXCIgYSBiICgpO1xuICBsZXQgbSA9IENhbWwubW9kX2Zsb2F0IGEgYiBpblxuICAoKiBQcm9kdWNlIGEgbm9uLW5lZ2F0aXZlIHJlc3VsdCBpbiBhbmFsb2d5IHdpdGggSW50LiggJSApLiAqKVxuICBpZiBtIDwgMC4gdGhlbiBtICsuIGIgZWxzZSBtXG47O1xuXG4oKiBUaGUgYml0cyBvZiBJTlJJQSdzIFtQZXJ2YXNpdmVzXSB0aGF0IHdlIGp1c3Qgd2FudCB0byBleHBvc2UgaW4gW0Zsb2F0XS4gTW9zdCBhcmVcbiAgIGFscmVhZHkgZGVwcmVjYXRlZCBpbiBbUGVydmFzaXZlc10sIGFuZCBldmVudHVhbGx5IGFsbCBvZiB0aGVtIHNob3VsZCBiZS4gKilcbmluY2x1ZGUgKFxuICBDYW1sIDpcbiAgc2lnXG4gICAgZXh0ZXJuYWwgZnJleHAgOiBmbG9hdCAtPiBmbG9hdCAqIGludCA9IFwiY2FtbF9mcmV4cF9mbG9hdFwiXG5cbiAgICBleHRlcm5hbCBsZGV4cFxuICAgICAgOiAgKGZsb2F0W0B1bmJveGVkXSlcbiAgICAgIC0+IChpbnRbQHVudGFnZ2VkXSlcbiAgICAgIC0+IChmbG9hdFtAdW5ib3hlZF0pXG4gICAgICA9IFwiY2FtbF9sZGV4cF9mbG9hdFwiIFwiY2FtbF9sZGV4cF9mbG9hdF91bmJveGVkXCJcbiAgICBbQEBub2FsbG9jXVxuXG4gICAgZXh0ZXJuYWwgbG9nMTAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2cxMF9mbG9hdFwiIFwibG9nMTBcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuXG4gICAgZXh0ZXJuYWwgZXhwbTEgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9leHBtMV9mbG9hdFwiIFwiY2FtbF9leHBtMVwiXG4gICAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxuICAgIGV4dGVybmFsIGxvZzFwIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfbG9nMXBfZmxvYXRcIiBcImNhbWxfbG9nMXBcIlxuICAgIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5cbiAgICBleHRlcm5hbCBjb3B5c2lnbiA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2NvcHlzaWduX2Zsb2F0XCIgXCJjYW1sX2NvcHlzaWduXCJcbiAgICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuXG4gICAgZXh0ZXJuYWwgY29zIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY29zX2Zsb2F0XCIgXCJjb3NcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuICAgIGV4dGVybmFsIHNpbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Npbl9mbG9hdFwiIFwic2luXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbiAgICBleHRlcm5hbCB0YW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF90YW5fZmxvYXRcIiBcInRhblwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG4gICAgZXh0ZXJuYWwgYWNvcyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Fjb3NfZmxvYXRcIiBcImFjb3NcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuICAgIGV4dGVybmFsIGFzaW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hc2luX2Zsb2F0XCIgXCJhc2luXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbiAgICBleHRlcm5hbCBhdGFuIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXRhbl9mbG9hdFwiIFwiYXRhblwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5cbiAgICBleHRlcm5hbCBhdGFuMiA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2F0YW4yX2Zsb2F0XCIgXCJhdGFuMlwiXG4gICAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxuICAgIGV4dGVybmFsIGh5cG90IDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfaHlwb3RfZmxvYXRcIiBcImNhbWxfaHlwb3RcIlxuICAgIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5cbiAgICBleHRlcm5hbCBjb3NoIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY29zaF9mbG9hdFwiIFwiY29zaFwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG4gICAgZXh0ZXJuYWwgc2luaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3NpbmhfZmxvYXRcIiBcInNpbmhcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuICAgIGV4dGVybmFsIHRhbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF90YW5oX2Zsb2F0XCIgXCJ0YW5oXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbiAgICBleHRlcm5hbCBzcXJ0IDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfc3FydF9mbG9hdFwiIFwic3FydFwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG4gICAgZXh0ZXJuYWwgZXhwIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZXhwX2Zsb2F0XCIgXCJleHBcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuICAgIGV4dGVybmFsIGxvZyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZ19mbG9hdFwiIFwibG9nXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbiAgZW5kKVxuXG4oKiBXZSBuZWVkIHRoaXMgaW5kaXJlY3Rpb24gYmVjYXVzZSB0aGVzZSBhcmUgZXhwb3NlZCBhcyBcInZhbFwiIGluc3RlYWQgb2YgXCJleHRlcm5hbFwiICopXG5sZXQgZnJleHAgPSBmcmV4cFxubGV0IGxkZXhwID0gbGRleHBcbmxldCBpc19uYW4geCA9ICh4IDogZmxvYXQpIDw+IHhcblxuKCogQW4gb3JkZXItcHJlc2VydmluZyBiaWplY3Rpb24gYmV0d2VlbiBhbGwgZmxvYXRzIGV4Y2VwdCBmb3IgTmFOcywgYW5kIDk5Ljk1JSBvZlxuICAgaW50NjRzLlxuXG4gICBOb3RlIHdlIGRvbid0IGRpc3Rpbmd1aXNoIDAuIGFuZCAtMC4gYXMgc2VwYXJhdGUgdmFsdWVzIGhlcmUsIHRoZXkgYm90aCBtYXAgdG8gMEwsIHdoaWNoXG4gICBtYXBzIGJhY2sgdG8gMC5cblxuICAgVGhpcyBzaG91bGQgd29yayBib3RoIG9uIGxpdHRsZS1lbmRpYW4gYW5kIGhpZ2gtZW5kaWFuIENQVXMuICBXaWtpcGVkaWEgc2F5czogXCJvblxuICAgbW9kZXJuIHN0YW5kYXJkIGNvbXB1dGVycyAoaS5lLiwgaW1wbGVtZW50aW5nIElFRUUgNzU0KSwgb25lIG1heSBpbiBwcmFjdGljZSBzYWZlbHlcbiAgIGFzc3VtZSB0aGF0IHRoZSBlbmRpYW5uZXNzIGlzIHRoZSBzYW1lIGZvciBmbG9hdGluZyBwb2ludCBudW1iZXJzIGFzIGZvciBpbnRlZ2Vyc1wiXG4gICAoaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FbmRpYW5uZXNzI0Zsb2F0aW5nLXBvaW50X2FuZF9lbmRpYW5uZXNzKS5cbiopXG5sZXQgdG9faW50NjRfcHJlc2VydmVfb3JkZXIgdCA9XG4gIGlmIGlzX25hbiB0XG4gIHRoZW4gTm9uZVxuICBlbHNlIGlmIHQgPSAwLlxuICB0aGVuICgqIGFsc28gaW5jbHVkZXMgLTAuICopXG4gICAgU29tZSAwTFxuICBlbHNlIGlmIHQgPiAwLlxuICB0aGVuIFNvbWUgKENhbWwuSW50NjQuYml0c19vZl9mbG9hdCB0KVxuICBlbHNlIFNvbWUgKENhbWwuSW50NjQubmVnIChDYW1sLkludDY0LmJpdHNfb2ZfZmxvYXQgKC0udCkpKVxuOztcblxubGV0IHRvX2ludDY0X3ByZXNlcnZlX29yZGVyX2V4biB4ID0gT3B0aW9uLnZhbHVlX2V4biAodG9faW50NjRfcHJlc2VydmVfb3JkZXIgeClcblxubGV0IG9mX2ludDY0X3ByZXNlcnZlX29yZGVyIHggPVxuICBpZiBJbnQ2NF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA+PSApIHggMExcbiAgdGhlbiBDYW1sLkludDY0LmZsb2F0X29mX2JpdHMgeFxuICBlbHNlIH4tLihDYW1sLkludDY0LmZsb2F0X29mX2JpdHMgKENhbWwuSW50NjQubmVnIHgpKVxuOztcblxubGV0IG9uZV91bHAgZGlyIHQgPVxuICBtYXRjaCB0b19pbnQ2NF9wcmVzZXJ2ZV9vcmRlciB0IHdpdGhcbiAgfCBOb25lIC0+IENhbWwubmFuXG4gIHwgU29tZSB4IC0+XG4gICAgb2ZfaW50NjRfcHJlc2VydmVfb3JkZXJcbiAgICAgIChDYW1sLkludDY0LmFkZFxuICAgICAgICAgeFxuICAgICAgICAgKG1hdGNoIGRpciB3aXRoXG4gICAgICAgICAgfCBgVXAgLT4gMUxcbiAgICAgICAgICB8IGBEb3duIC0+IC0xTCkpXG47O1xuXG4oKiBbdXBwZXJfYm91bmRfZm9yX2ludF0gYW5kIFtsb3dlcl9ib3VuZF9mb3JfaW50XSBhcmUgZm9yIGNhbGN1bGF0aW5nIHRoZSBtYXgvbWluIGZsb2F0XG4gICB0aGF0IGZpdHMgaW4gYSBnaXZlbi1zaXplIGludGVnZXIgd2hlbiByb3VuZGVkIHRvd2FyZHMgMCAodXNpbmcgW2ludF9vZl9mbG9hdF0pLlxuXG4gICBtYXhfaW50L21pbl9pbnQgZGVwZW5kIG9uIFtudW1fYml0c10sIGUuZy4gKy8tIDJeMzAsICsvLSAyXjYyIGlmIDMxLWJpdCwgNjMtYml0XG4gICAocmVzcGVjdGl2ZWx5KSB3aGlsZSBmbG9hdCBpcyBJRUVFIHN0YW5kYXJkIGZvciBkb3VibGUgKDUyIHNpZ25pZmljYW50IGJpdHMpLlxuXG4gICBJbiBhbGwgY2FzZXMsIHdlIHdhbnQgdG8gZ3VhcmFudGVlIHRoYXRcbiAgIFtsb3dlcl9ib3VuZF9mb3JfaW50IDw9IHggPD0gdXBwZXJfYm91bmRfZm9yX2ludF1cbiAgIGlmZiBbaW50X29mX2Zsb2F0IHhdIGZpdHMgaW4gYW4gaW50IHdpdGggW251bV9iaXRzXSBiaXRzLlxuXG4gICBbMiAqKiAobnVtX2JpdHMgLSAxKV0gaXMgdGhlIGZpcnN0IGZsb2F0IGdyZWF0ZXIgdGhhdCBtYXhfaW50LCB3ZSB1c2UgdGhlIHByZWNlZGluZ1xuICAgZmxvYXQgYXMgdXBwZXIgYm91bmQuXG5cbiAgIFstICgyICoqIChudW1fYml0cyAtIDEpKV0gaXMgZXF1YWwgdG8gbWluX2ludC5cbiAgIEZvciBsb3dlciBib3VuZCB3ZSBsb29rIGZvciB0aGUgc21hbGxlc3QgZmxvYXQgW2ZdIHNhdGlzZnlpbmcgW2YgPiBtaW5faW50IC0gMV0gc28gdGhhdFxuICAgW2ZdIHJvdW5kcyB0b3dhcmQgemVybyB0byBbbWluX2ludF1cblxuICAgU28gaW4gcGFydGljdWxhciB3ZSB3aWxsIGhhdmU6XG4gICBbbG93ZXJfYm91bmRfZm9yX2ludCB4IDw9IC0gKDIgKiogKDEteCkpXVxuICAgW3VwcGVyX2JvdW5kX2Zvcl9pbnQgeCAgPCAgICAyICoqICgxLXgpIF1cbiopXG5sZXQgdXBwZXJfYm91bmRfZm9yX2ludCBudW1fYml0cyA9XG4gIGxldCBleHAgPSBDYW1sLmZsb2F0X29mX2ludCAobnVtX2JpdHMgLSAxKSBpblxuICBvbmVfdWxwIGBEb3duICgyLiAqKiBleHApXG47O1xuXG5sZXQgaXNfeF9taW51c19vbmVfZXhhY3QgeCA9XG4gICgqIFt4ID0geCAtLiAxLl0gZG9lcyBub3Qgd29yayB3aXRoIHg4NyBmbG9hdGluZyBwb2ludCBhcml0aG1ldGljIGJhY2tlbmQgKHdoaWNoIGlzIHVzZWRcbiAgICAgb24gMzItYml0IG9jYW1sKSBiZWNhdXNlIG9mIDgwLWJpdCByZWdpc3RlciBwcmVjaXNpb24gb2YgaW50ZXJtZWRpYXRlIGNvbXB1dGF0aW9ucy5cblxuICAgICBBbiBhbHRlcm5hdGl2ZSB3YXkgb2YgY29tcHV0aW5nIHRoaXM6IFt4IC0uIG9uZV91bHAgYERvd24geCA8PSAxLl0gaXMgYWxzbyBwcm9uZSB0b1xuICAgICB0aGUgc2FtZSBwcmVjaXNpb24gaXNzdWVzOiB5b3UgbmVlZCB0byBtYWtlIHN1cmUgW3hdIGlzIDY0LWJpdC5cbiAgKilcbiAgbGV0IG9wZW4gSW50NjRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGluXG4gIG5vdCAoQ2FtbC5JbnQ2NC5iaXRzX29mX2Zsb2F0IHggPSBDYW1sLkludDY0LmJpdHNfb2ZfZmxvYXQgKHggLS4gMS4pKVxuOztcblxubGV0IGxvd2VyX2JvdW5kX2Zvcl9pbnQgbnVtX2JpdHMgPVxuICBsZXQgZXhwID0gQ2FtbC5mbG9hdF9vZl9pbnQgKG51bV9iaXRzIC0gMSkgaW5cbiAgbGV0IG1pbl9pbnRfYXNfZmxvYXQgPSB+LS4oMi4gKiogZXhwKSBpblxuICBsZXQgb3BlbiBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGluXG4gIGlmIG51bV9iaXRzIC0gMSA8IDUzICgqIDUzID0gI2JpdHMgaW4gdGhlIGZsb2F0J3MgbWFudGlzc2Egd2l0aCBzaWduIGluY2x1ZGVkICopXG4gIHRoZW4gKFxuICAgICgqIFRoZSBzbWFsbGVzdCBmbG9hdCB0aGF0IHJvdW5kcyB0b3dhcmRzIHplcm8gdG8gW21pbl9pbnRdIGlzXG4gICAgICAgW21pbl9pbnQgLSAxICsgZXBzaWxvbl0gKilcbiAgICBhc3NlcnQgKGlzX3hfbWludXNfb25lX2V4YWN0IG1pbl9pbnRfYXNfZmxvYXQpO1xuICAgIG9uZV91bHAgYFVwIChtaW5faW50X2FzX2Zsb2F0IC0uIDEuKSlcbiAgZWxzZSAoXG4gICAgKCogW21pbl9pbnRfYXNfZmxvYXRdIGlzIGFscmVhZHkgdGhlIHNtYWxsZXN0IGZsb2F0IFtmXSBzYXRpc2Z5aW5nIFtmID4gbWluX2ludCAtIDFdLiAqKVxuICAgIGFzc2VydCAobm90IChpc194X21pbnVzX29uZV9leGFjdCBtaW5faW50X2FzX2Zsb2F0KSk7XG4gICAgbWluX2ludF9hc19mbG9hdClcbjs7XG5cbigqIEZsb2F0IGNsYW1waW5nIGlzIHN0cnVjdHVyZWQgc2xpZ2h0bHkgZGlmZmVyZW50bHkgdGhhbiBjbGFtcGluZyBmb3Igb3RoZXIgdHlwZXMsIHNvXG4gICB0aGF0IHdlIGdldCB0aGUgYmVoYXZpb3Igb2YgW2NsYW1wX3VuY2hlY2tlZCBuYW4gfm1pbiB+bWF4ID0gbmFuXSAoZm9yIGFueSBbbWluXSBhbmRcbiAgIFttYXhdKSBmb3IgZnJlZS5cbiopXG5sZXQgY2xhbXBfdW5jaGVja2VkICh0IDogZmxvYXQpIH5taW4gfm1heCA9XG4gIGlmIHQgPCBtaW4gdGhlbiBtaW4gZWxzZSBpZiBtYXggPCB0IHRoZW4gbWF4IGVsc2UgdFxuOztcblxubGV0IGJveCA9XG4gICgqIFByZXZlbnQgcG90ZW50aWFsIGNvbnN0YW50IGZvbGRpbmcgb2YgWysuIDAuXSBpbiB0aGUgbmVhciBvY2FtbG9wdCBmdXR1cmUuICopXG4gIGxldCB4ID0gU3lzMC5vcGFxdWVfaWRlbnRpdHkgMC4gaW5cbiAgZnVuIGYgLT4gZiArLiB4XG47O1xuXG4oKiBJbmNsdWRlIHR5cGUtc3BlY2lmaWMgW1JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZV0gYXQgdGhlIGVuZCwgYWZ0ZXJcbiAgIGluY2x1ZGluZyBmdW5jdG9yIGFwcGxpY2F0aW9uIHRoYXQgY291bGQgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpc1xuICAgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbnMgYXJlIGV4cG9ydGVkIGJ5XG4gICB0aGlzIG1vZHVsZS4gKilcbmluY2x1ZGUgRmxvYXRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG4iLCJvcGVuISBJbXBvcnQwLkludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcbm1vZHVsZSBCeXRlcyA9IEJ5dGVzMFxubW9kdWxlIFN0cmluZyA9IFN0cmluZzBcblxuKCogQ29uc3RydWN0IGEgYnl0ZSBzdHJpbmcgb2YgbGVuZ3RoIDI1NiwgbWFwcGluZyBldmVyeSBpbnB1dCBjaGFyYWN0ZXIgY29kZSB0b1xuICAgaXRzIGNvcnJlc3BvbmRpbmcgb3V0cHV0IGNoYXJhY3Rlci5cblxuICAgQmVuY2htYXJrcyBpbmRpY2F0ZSB0aGF0IHRoaXMgaXMgZmFzdGVyIHRoYW4gdGhlIGxhbWJkYSAoaW5jbHVkaW5nIGNvc3Qgb2ZcbiAgIHRoaXMgZnVuY3Rpb24pLCBldmVuIGlmIHRhcmdldC9yZXBsYWNlbWVudCBhcmUganVzdCAyIGNoYXJhY3RlcnMgZWFjaC5cblxuICAgUmV0dXJuIE5vbmUgaWYgdGhlIHRyYW5zbGF0aW9uIG1hcCBpcyBlcXVpdmFsZW50IHRvIGp1c3QgdGhlIGlkZW50aXR5LiAqKVxubGV0IHRyX2NyZWF0ZV9tYXAgfnRhcmdldCB+cmVwbGFjZW1lbnQgPVxuICBsZXQgdHJfbWFwID0gQnl0ZXMuY3JlYXRlIDI1NiBpblxuICBmb3IgaSA9IDAgdG8gMjU1IGRvXG4gICAgQnl0ZXMudW5zYWZlX3NldCB0cl9tYXAgaSAoQ2hhci5vZl9pbnRfZXhuIGkpXG4gIGRvbmU7XG4gIGZvciBpID0gMCB0byBtaW4gKFN0cmluZy5sZW5ndGggdGFyZ2V0KSAoU3RyaW5nLmxlbmd0aCByZXBsYWNlbWVudCkgLSAxIGRvXG4gICAgbGV0IGluZGV4ID0gQ2hhci50b19pbnQgKFN0cmluZy51bnNhZmVfZ2V0IHRhcmdldCBpKSBpblxuICAgIEJ5dGVzLnVuc2FmZV9zZXQgdHJfbWFwIGluZGV4IChTdHJpbmcudW5zYWZlX2dldCByZXBsYWNlbWVudCBpKVxuICBkb25lO1xuICBsZXQgbGFzdF9yZXBsYWNlbWVudCA9IFN0cmluZy51bnNhZmVfZ2V0IHJlcGxhY2VtZW50IChTdHJpbmcubGVuZ3RoIHJlcGxhY2VtZW50IC0gMSkgaW5cbiAgZm9yXG4gICAgaSA9IG1pbiAoU3RyaW5nLmxlbmd0aCB0YXJnZXQpIChTdHJpbmcubGVuZ3RoIHJlcGxhY2VtZW50KSB0byBTdHJpbmcubGVuZ3RoIHRhcmdldCAtIDFcbiAgZG9cbiAgICBsZXQgaW5kZXggPSBDaGFyLnRvX2ludCAoU3RyaW5nLnVuc2FmZV9nZXQgdGFyZ2V0IGkpIGluXG4gICAgQnl0ZXMudW5zYWZlX3NldCB0cl9tYXAgaW5kZXggbGFzdF9yZXBsYWNlbWVudFxuICBkb25lO1xuICBsZXQgcmVjIGhhdmVfYW55X2RpZmZlcmVudCB0cl9tYXAgaSA9XG4gICAgaWYgaSA9IDI1NlxuICAgIHRoZW4gZmFsc2VcbiAgICBlbHNlIGlmIENoYXIuKCA8PiApIChCeXRlczAudW5zYWZlX2dldCB0cl9tYXAgaSkgKENoYXIub2ZfaW50X2V4biBpKVxuICAgIHRoZW4gdHJ1ZVxuICAgIGVsc2UgaGF2ZV9hbnlfZGlmZmVyZW50IHRyX21hcCAoaSArIDEpXG4gIGluXG4gICgqIHF1aWNrIGNoZWNrIG9uIHRoZSBmaXJzdCB0YXJnZXQgY2hhcmFjdGVyIHdoaWNoIHdpbGwgOTklIGJlIHRydWUgKilcbiAgbGV0IGZpcnN0X3RhcmdldCA9IHRhcmdldC5bMF0gaW5cbiAgaWYgQ2hhci4oIDw+ICkgKEJ5dGVzMC51bnNhZmVfZ2V0IHRyX21hcCAoQ2hhci50b19pbnQgZmlyc3RfdGFyZ2V0KSkgZmlyc3RfdGFyZ2V0XG4gIHx8IGhhdmVfYW55X2RpZmZlcmVudCB0cl9tYXAgMFxuICB0aGVuIFNvbWUgKEJ5dGVzMC51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOnRyX21hcClcbiAgZWxzZSBOb25lXG47O1xuIiwib3BlbiEgSW1wb3J0XG5cbnR5cGUgJ2EgdCA9ICdhXG5cbmxldCBzdGFnZSA9IEZuLmlkXG5sZXQgdW5zdGFnZSA9IEZuLmlkXG4iLCJvcGVuISBJbXBvcnRcbm1vZHVsZSBJbnQgPSBJbnQwXG5tb2R1bGUgU3lzID0gU3lzMFxuXG5sZXQgY29udmVydF9mYWlsdXJlIHggYSBiIHRvX3N0cmluZyA9XG4gIFByaW50Zi5mYWlsd2l0aGZcbiAgICBcImNvbnZlcnNpb24gZnJvbSAlcyB0byAlcyBmYWlsZWQ6ICVzIGlzIG91dCBvZiByYW5nZVwiXG4gICAgYVxuICAgIGJcbiAgICAodG9fc3RyaW5nIHgpXG4gICAgKClcbltAQGNvbGRdIFtAQGlubGluZSBuZXZlcl0gW0BAbG9jYWwgbmV2ZXJdIFtAQHNwZWNpYWxpc2UgbmV2ZXJdXG47O1xuXG5sZXQgbnVtX2JpdHNfaW50ID0gU3lzLmludF9zaXplX2luX2JpdHNcbmxldCBudW1fYml0c19pbnQzMiA9IDMyXG5sZXQgbnVtX2JpdHNfaW50NjQgPSA2NFxubGV0IG51bV9iaXRzX25hdGl2ZWludCA9IFdvcmRfc2l6ZS5udW1fYml0cyBXb3JkX3NpemUud29yZF9zaXplXG5sZXQgKCkgPSBhc3NlcnQgKG51bV9iaXRzX2ludCA9IDYzIHx8IG51bV9iaXRzX2ludCA9IDMxIHx8IG51bV9iaXRzX2ludCA9IDMyKVxubGV0IG1pbl9pbnQzMiA9IENhbWwuSW50MzIubWluX2ludFxubGV0IG1heF9pbnQzMiA9IENhbWwuSW50MzIubWF4X2ludFxubGV0IG1pbl9pbnQ2NCA9IENhbWwuSW50NjQubWluX2ludFxubGV0IG1heF9pbnQ2NCA9IENhbWwuSW50NjQubWF4X2ludFxubGV0IG1pbl9uYXRpdmVpbnQgPSBDYW1sLk5hdGl2ZWludC5taW5faW50XG5sZXQgbWF4X25hdGl2ZWludCA9IENhbWwuTmF0aXZlaW50Lm1heF9pbnRcbmxldCBpbnRfdG9fc3RyaW5nID0gQ2FtbC5zdHJpbmdfb2ZfaW50XG5sZXQgaW50MzJfdG9fc3RyaW5nID0gQ2FtbC5JbnQzMi50b19zdHJpbmdcbmxldCBpbnQ2NF90b19zdHJpbmcgPSBDYW1sLkludDY0LnRvX3N0cmluZ1xubGV0IG5hdGl2ZWludF90b19zdHJpbmcgPSBDYW1sLk5hdGl2ZWludC50b19zdHJpbmdcblxuKCogaW50IDwtPiBpbnQzMiAqKVxuXG5sZXQgaW50X3RvX2ludDMyX2ZhaWx1cmUgeCA9IGNvbnZlcnRfZmFpbHVyZSB4IFwiaW50XCIgXCJpbnQzMlwiIGludF90b19zdHJpbmdcbmxldCBpbnQzMl90b19pbnRfZmFpbHVyZSB4ID0gY29udmVydF9mYWlsdXJlIHggXCJpbnQzMlwiIFwiaW50XCIgaW50MzJfdG9fc3RyaW5nXG5sZXQgaW50MzJfdG9faW50X3RydW5jID0gQ2FtbC5JbnQzMi50b19pbnRcbmxldCBpbnRfdG9faW50MzJfdHJ1bmMgPSBDYW1sLkludDMyLm9mX2ludFxuXG5sZXQgaW50X2lzX3JlcHJlc2VudGFibGVfYXNfaW50MzIgPVxuICBpZiBudW1fYml0c19pbnQgPD0gbnVtX2JpdHNfaW50MzJcbiAgdGhlbiBmdW4gXyAtPiB0cnVlXG4gIGVsc2UgKFxuICAgIGxldCBtaW4gPSBpbnQzMl90b19pbnRfdHJ1bmMgbWluX2ludDMyIGluXG4gICAgbGV0IG1heCA9IGludDMyX3RvX2ludF90cnVuYyBtYXhfaW50MzIgaW5cbiAgICBmdW4geCAtPiBjb21wYXJlX2ludCBtaW4geCA8PSAwICYmIGNvbXBhcmVfaW50IHggbWF4IDw9IDApXG47O1xuXG5sZXQgaW50MzJfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQgPVxuICBpZiBudW1fYml0c19pbnQzMiA8PSBudW1fYml0c19pbnRcbiAgdGhlbiBmdW4gXyAtPiB0cnVlXG4gIGVsc2UgKFxuICAgIGxldCBtaW4gPSBpbnRfdG9faW50MzJfdHJ1bmMgSW50Lm1pbl92YWx1ZSBpblxuICAgIGxldCBtYXggPSBpbnRfdG9faW50MzJfdHJ1bmMgSW50Lm1heF92YWx1ZSBpblxuICAgIGZ1biB4IC0+IGNvbXBhcmVfaW50MzIgbWluIHggPD0gMCAmJiBjb21wYXJlX2ludDMyIHggbWF4IDw9IDApXG47O1xuXG5sZXQgaW50X3RvX2ludDMyIHggPVxuICBpZiBpbnRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQzMiB4IHRoZW4gU29tZSAoaW50X3RvX2ludDMyX3RydW5jIHgpIGVsc2UgTm9uZVxuOztcblxubGV0IGludDMyX3RvX2ludCB4ID1cbiAgaWYgaW50MzJfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQgeCB0aGVuIFNvbWUgKGludDMyX3RvX2ludF90cnVuYyB4KSBlbHNlIE5vbmVcbjs7XG5cbmxldCBpbnRfdG9faW50MzJfZXhuIHggPVxuICBpZiBpbnRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQzMiB4IHRoZW4gaW50X3RvX2ludDMyX3RydW5jIHggZWxzZSBpbnRfdG9faW50MzJfZmFpbHVyZSB4XG47O1xuXG5sZXQgaW50MzJfdG9faW50X2V4biB4ID1cbiAgaWYgaW50MzJfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQgeCB0aGVuIGludDMyX3RvX2ludF90cnVuYyB4IGVsc2UgaW50MzJfdG9faW50X2ZhaWx1cmUgeFxuOztcblxuKCogaW50IDwtPiBpbnQ2NCAqKVxuXG5sZXQgaW50NjRfdG9faW50X2ZhaWx1cmUgeCA9IGNvbnZlcnRfZmFpbHVyZSB4IFwiaW50NjRcIiBcImludFwiIGludDY0X3RvX3N0cmluZ1xubGV0ICgpID0gYXNzZXJ0IChudW1fYml0c19pbnQgPCBudW1fYml0c19pbnQ2NClcbmxldCBpbnRfdG9faW50NjQgPSBDYW1sLkludDY0Lm9mX2ludFxubGV0IGludDY0X3RvX2ludF90cnVuYyA9IENhbWwuSW50NjQudG9faW50XG5cbmxldCBpbnQ2NF9pc19yZXByZXNlbnRhYmxlX2FzX2ludCA9XG4gIGxldCBtaW4gPSBpbnRfdG9faW50NjQgSW50Lm1pbl92YWx1ZSBpblxuICBsZXQgbWF4ID0gaW50X3RvX2ludDY0IEludC5tYXhfdmFsdWUgaW5cbiAgZnVuIHggLT4gY29tcGFyZV9pbnQ2NCBtaW4geCA8PSAwICYmIGNvbXBhcmVfaW50NjQgeCBtYXggPD0gMFxuOztcblxubGV0IGludDY0X3RvX2ludCB4ID1cbiAgaWYgaW50NjRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQgeCB0aGVuIFNvbWUgKGludDY0X3RvX2ludF90cnVuYyB4KSBlbHNlIE5vbmVcbjs7XG5cbmxldCBpbnQ2NF90b19pbnRfZXhuIHggPVxuICBpZiBpbnQ2NF9pc19yZXByZXNlbnRhYmxlX2FzX2ludCB4IHRoZW4gaW50NjRfdG9faW50X3RydW5jIHggZWxzZSBpbnQ2NF90b19pbnRfZmFpbHVyZSB4XG47O1xuXG4oKiBpbnQgPC0+IG5hdGl2ZWludCAqKVxuXG5sZXQgbmF0aXZlaW50X3RvX2ludF9mYWlsdXJlIHggPSBjb252ZXJ0X2ZhaWx1cmUgeCBcIm5hdGl2ZWludFwiIFwiaW50XCIgbmF0aXZlaW50X3RvX3N0cmluZ1xubGV0ICgpID0gYXNzZXJ0IChudW1fYml0c19pbnQgPD0gbnVtX2JpdHNfbmF0aXZlaW50KVxubGV0IGludF90b19uYXRpdmVpbnQgPSBDYW1sLk5hdGl2ZWludC5vZl9pbnRcbmxldCBuYXRpdmVpbnRfdG9faW50X3RydW5jID0gQ2FtbC5OYXRpdmVpbnQudG9faW50XG5cbmxldCBuYXRpdmVpbnRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQgPVxuICBpZiBudW1fYml0c19uYXRpdmVpbnQgPD0gbnVtX2JpdHNfaW50XG4gIHRoZW4gZnVuIF8gLT4gdHJ1ZVxuICBlbHNlIChcbiAgICBsZXQgbWluID0gaW50X3RvX25hdGl2ZWludCBJbnQubWluX3ZhbHVlIGluXG4gICAgbGV0IG1heCA9IGludF90b19uYXRpdmVpbnQgSW50Lm1heF92YWx1ZSBpblxuICAgIGZ1biB4IC0+IGNvbXBhcmVfbmF0aXZlaW50IG1pbiB4IDw9IDAgJiYgY29tcGFyZV9uYXRpdmVpbnQgeCBtYXggPD0gMClcbjs7XG5cbmxldCBuYXRpdmVpbnRfdG9faW50IHggPVxuICBpZiBuYXRpdmVpbnRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQgeCB0aGVuIFNvbWUgKG5hdGl2ZWludF90b19pbnRfdHJ1bmMgeCkgZWxzZSBOb25lXG47O1xuXG5sZXQgbmF0aXZlaW50X3RvX2ludF9leG4geCA9XG4gIGlmIG5hdGl2ZWludF9pc19yZXByZXNlbnRhYmxlX2FzX2ludCB4XG4gIHRoZW4gbmF0aXZlaW50X3RvX2ludF90cnVuYyB4XG4gIGVsc2UgbmF0aXZlaW50X3RvX2ludF9mYWlsdXJlIHhcbjs7XG5cbigqIGludDMyIDwtPiBpbnQ2NCAqKVxuXG5sZXQgaW50NjRfdG9faW50MzJfZmFpbHVyZSB4ID0gY29udmVydF9mYWlsdXJlIHggXCJpbnQ2NFwiIFwiaW50MzJcIiBpbnQ2NF90b19zdHJpbmdcbmxldCAoKSA9IGFzc2VydCAobnVtX2JpdHNfaW50MzIgPCBudW1fYml0c19pbnQ2NClcbmxldCBpbnQzMl90b19pbnQ2NCA9IENhbWwuSW50NjQub2ZfaW50MzJcbmxldCBpbnQ2NF90b19pbnQzMl90cnVuYyA9IENhbWwuSW50NjQudG9faW50MzJcblxubGV0IGludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfaW50MzIgPVxuICBsZXQgbWluID0gaW50MzJfdG9faW50NjQgbWluX2ludDMyIGluXG4gIGxldCBtYXggPSBpbnQzMl90b19pbnQ2NCBtYXhfaW50MzIgaW5cbiAgZnVuIHggLT4gY29tcGFyZV9pbnQ2NCBtaW4geCA8PSAwICYmIGNvbXBhcmVfaW50NjQgeCBtYXggPD0gMFxuOztcblxubGV0IGludDY0X3RvX2ludDMyIHggPVxuICBpZiBpbnQ2NF9pc19yZXByZXNlbnRhYmxlX2FzX2ludDMyIHggdGhlbiBTb21lIChpbnQ2NF90b19pbnQzMl90cnVuYyB4KSBlbHNlIE5vbmVcbjs7XG5cbmxldCBpbnQ2NF90b19pbnQzMl9leG4geCA9XG4gIGlmIGludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfaW50MzIgeFxuICB0aGVuIGludDY0X3RvX2ludDMyX3RydW5jIHhcbiAgZWxzZSBpbnQ2NF90b19pbnQzMl9mYWlsdXJlIHhcbjs7XG5cbigqIGludDMyIDwtPiBuYXRpdmVpbnQgKilcblxubGV0IG5hdGl2ZWludF90b19pbnQzMl9mYWlsdXJlIHggPVxuICBjb252ZXJ0X2ZhaWx1cmUgeCBcIm5hdGl2ZWludFwiIFwiaW50MzJcIiBuYXRpdmVpbnRfdG9fc3RyaW5nXG47O1xuXG5sZXQgKCkgPSBhc3NlcnQgKG51bV9iaXRzX2ludDMyIDw9IG51bV9iaXRzX25hdGl2ZWludClcbmxldCBpbnQzMl90b19uYXRpdmVpbnQgPSBDYW1sLk5hdGl2ZWludC5vZl9pbnQzMlxubGV0IG5hdGl2ZWludF90b19pbnQzMl90cnVuYyA9IENhbWwuTmF0aXZlaW50LnRvX2ludDMyXG5cbmxldCBuYXRpdmVpbnRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQzMiA9XG4gIGlmIG51bV9iaXRzX25hdGl2ZWludCA8PSBudW1fYml0c19pbnQzMlxuICB0aGVuIGZ1biBfIC0+IHRydWVcbiAgZWxzZSAoXG4gICAgbGV0IG1pbiA9IGludDMyX3RvX25hdGl2ZWludCBtaW5faW50MzIgaW5cbiAgICBsZXQgbWF4ID0gaW50MzJfdG9fbmF0aXZlaW50IG1heF9pbnQzMiBpblxuICAgIGZ1biB4IC0+IGNvbXBhcmVfbmF0aXZlaW50IG1pbiB4IDw9IDAgJiYgY29tcGFyZV9uYXRpdmVpbnQgeCBtYXggPD0gMClcbjs7XG5cbmxldCBuYXRpdmVpbnRfdG9faW50MzIgeCA9XG4gIGlmIG5hdGl2ZWludF9pc19yZXByZXNlbnRhYmxlX2FzX2ludDMyIHhcbiAgdGhlbiBTb21lIChuYXRpdmVpbnRfdG9faW50MzJfdHJ1bmMgeClcbiAgZWxzZSBOb25lXG47O1xuXG5sZXQgbmF0aXZlaW50X3RvX2ludDMyX2V4biB4ID1cbiAgaWYgbmF0aXZlaW50X2lzX3JlcHJlc2VudGFibGVfYXNfaW50MzIgeFxuICB0aGVuIG5hdGl2ZWludF90b19pbnQzMl90cnVuYyB4XG4gIGVsc2UgbmF0aXZlaW50X3RvX2ludDMyX2ZhaWx1cmUgeFxuOztcblxuKCogaW50NjQgPC0+IG5hdGl2ZWludCAqKVxuXG5sZXQgaW50NjRfdG9fbmF0aXZlaW50X2ZhaWx1cmUgeCA9IGNvbnZlcnRfZmFpbHVyZSB4IFwiaW50NjRcIiBcIm5hdGl2ZWludFwiIGludDY0X3RvX3N0cmluZ1xubGV0ICgpID0gYXNzZXJ0IChudW1fYml0c19pbnQ2NCA+PSBudW1fYml0c19uYXRpdmVpbnQpXG5sZXQgaW50NjRfdG9fbmF0aXZlaW50X3RydW5jID0gQ2FtbC5JbnQ2NC50b19uYXRpdmVpbnRcbmxldCBuYXRpdmVpbnRfdG9faW50NjQgPSBDYW1sLkludDY0Lm9mX25hdGl2ZWludFxuXG5sZXQgaW50NjRfaXNfcmVwcmVzZW50YWJsZV9hc19uYXRpdmVpbnQgPVxuICBpZiBudW1fYml0c19pbnQ2NCA8PSBudW1fYml0c19uYXRpdmVpbnRcbiAgdGhlbiBmdW4gXyAtPiB0cnVlXG4gIGVsc2UgKFxuICAgIGxldCBtaW4gPSBuYXRpdmVpbnRfdG9faW50NjQgbWluX25hdGl2ZWludCBpblxuICAgIGxldCBtYXggPSBuYXRpdmVpbnRfdG9faW50NjQgbWF4X25hdGl2ZWludCBpblxuICAgIGZ1biB4IC0+IGNvbXBhcmVfaW50NjQgbWluIHggPD0gMCAmJiBjb21wYXJlX2ludDY0IHggbWF4IDw9IDApXG47O1xuXG5sZXQgaW50NjRfdG9fbmF0aXZlaW50IHggPVxuICBpZiBpbnQ2NF9pc19yZXByZXNlbnRhYmxlX2FzX25hdGl2ZWludCB4XG4gIHRoZW4gU29tZSAoaW50NjRfdG9fbmF0aXZlaW50X3RydW5jIHgpXG4gIGVsc2UgTm9uZVxuOztcblxubGV0IGludDY0X3RvX25hdGl2ZWludF9leG4geCA9XG4gIGlmIGludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfbmF0aXZlaW50IHhcbiAgdGhlbiBpbnQ2NF90b19uYXRpdmVpbnRfdHJ1bmMgeFxuICBlbHNlIGludDY0X3RvX25hdGl2ZWludF9mYWlsdXJlIHhcbjs7XG5cbigqIGludDY0IDwtPiBpbnQ2MyAqKVxuXG5sZXQgaW50NjRfdG9faW50NjNfZmFpbHVyZSB4ID0gY29udmVydF9mYWlsdXJlIHggXCJpbnQ2NFwiIFwiaW50NjNcIiBpbnQ2NF90b19zdHJpbmdcblxubGV0IGludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfaW50NjMgPVxuICBsZXQgbWluID0gQ2FtbC5JbnQ2NC5zaGlmdF9yaWdodCBtaW5faW50NjQgMSBpblxuICBsZXQgbWF4ID0gQ2FtbC5JbnQ2NC5zaGlmdF9yaWdodCBtYXhfaW50NjQgMSBpblxuICBmdW4geCAtPiBjb21wYXJlX2ludDY0IG1pbiB4IDw9IDAgJiYgY29tcGFyZV9pbnQ2NCB4IG1heCA8PSAwXG47O1xuXG5sZXQgaW50NjRfZml0X29uX2ludDYzX2V4biB4ID1cbiAgaWYgaW50NjRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQ2MyB4IHRoZW4gKCkgZWxzZSBpbnQ2NF90b19pbnQ2M19mYWlsdXJlIHhcbjs7XG5cbigqIHN0cmluZyBjb252ZXJzaW9ucyAqKVxuXG5sZXQgaW5zZXJ0X2RlbGltaXRlcl9ldmVyeSBpbnB1dCB+ZGVsaW1pdGVyIH5jaGFyc19wZXJfZGVsaW1pdGVyID1cbiAgbGV0IGlucHV0X2xlbmd0aCA9IFN0cmluZy5sZW5ndGggaW5wdXQgaW5cbiAgaWYgaW5wdXRfbGVuZ3RoIDw9IGNoYXJzX3Blcl9kZWxpbWl0ZXJcbiAgdGhlbiBpbnB1dFxuICBlbHNlIChcbiAgICBsZXQgaGFzX3NpZ24gPVxuICAgICAgbWF0Y2ggaW5wdXQuWzBdIHdpdGhcbiAgICAgIHwgJysnIHwgJy0nIC0+IHRydWVcbiAgICAgIHwgXyAtPiBmYWxzZVxuICAgIGluXG4gICAgbGV0IG51bV9kaWdpdHMgPSBpZiBoYXNfc2lnbiB0aGVuIGlucHV0X2xlbmd0aCAtIDEgZWxzZSBpbnB1dF9sZW5ndGggaW5cbiAgICBsZXQgbnVtX2RlbGltaXRlcnMgPSAobnVtX2RpZ2l0cyAtIDEpIC8gY2hhcnNfcGVyX2RlbGltaXRlciBpblxuICAgIGxldCBvdXRwdXRfbGVuZ3RoID0gaW5wdXRfbGVuZ3RoICsgbnVtX2RlbGltaXRlcnMgaW5cbiAgICBsZXQgb3V0cHV0ID0gQnl0ZXMuY3JlYXRlIG91dHB1dF9sZW5ndGggaW5cbiAgICBsZXQgaW5wdXRfcG9zID0gcmVmIChpbnB1dF9sZW5ndGggLSAxKSBpblxuICAgIGxldCBvdXRwdXRfcG9zID0gcmVmIChvdXRwdXRfbGVuZ3RoIC0gMSkgaW5cbiAgICBsZXQgbnVtX2NoYXJzX3VudGlsX2RlbGltaXRlciA9IHJlZiBjaGFyc19wZXJfZGVsaW1pdGVyIGluXG4gICAgbGV0IGZpcnN0X2RpZ2l0X3BvcyA9IGlmIGhhc19zaWduIHRoZW4gMSBlbHNlIDAgaW5cbiAgICB3aGlsZSAhaW5wdXRfcG9zID49IGZpcnN0X2RpZ2l0X3BvcyBkb1xuICAgICAgaWYgIW51bV9jaGFyc191bnRpbF9kZWxpbWl0ZXIgPSAwXG4gICAgICB0aGVuIChcbiAgICAgICAgQnl0ZXMuc2V0IG91dHB1dCAhb3V0cHV0X3BvcyBkZWxpbWl0ZXI7XG4gICAgICAgIGRlY3Igb3V0cHV0X3BvcztcbiAgICAgICAgbnVtX2NoYXJzX3VudGlsX2RlbGltaXRlciA6PSBjaGFyc19wZXJfZGVsaW1pdGVyKTtcbiAgICAgIEJ5dGVzLnNldCBvdXRwdXQgIW91dHB1dF9wb3MgaW5wdXQuWyFpbnB1dF9wb3NdO1xuICAgICAgZGVjciBpbnB1dF9wb3M7XG4gICAgICBkZWNyIG91dHB1dF9wb3M7XG4gICAgICBkZWNyIG51bV9jaGFyc191bnRpbF9kZWxpbWl0ZXJcbiAgICBkb25lO1xuICAgIGlmIGhhc19zaWduIHRoZW4gQnl0ZXMuc2V0IG91dHB1dCAwIGlucHV0LlswXTtcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOm91dHB1dClcbjs7XG5cbmxldCBpbnNlcnRfZGVsaW1pdGVyIGlucHV0IH5kZWxpbWl0ZXIgPVxuICBpbnNlcnRfZGVsaW1pdGVyX2V2ZXJ5IGlucHV0IH5kZWxpbWl0ZXIgfmNoYXJzX3Blcl9kZWxpbWl0ZXI6M1xuOztcblxubGV0IGluc2VydF91bmRlcnNjb3JlcyBpbnB1dCA9IGluc2VydF9kZWxpbWl0ZXIgaW5wdXQgfmRlbGltaXRlcjonXydcbmxldCBzZXhwX29mX2ludF9zdHlsZSA9IFNleHAub2ZfaW50X3N0eWxlXG5cbm1vZHVsZSBNYWtlIChJIDogc2lnXG4gICAgdHlwZSB0XG5cbiAgICB2YWwgdG9fc3RyaW5nIDogdCAtPiBzdHJpbmdcbiAgZW5kKSA9XG5zdHJ1Y3RcbiAgb3BlbiBJXG5cbiAgbGV0IGNoYXJzX3Blcl9kZWxpbWl0ZXIgPSAzXG5cbiAgbGV0IHRvX3N0cmluZ19odW0gPyhkZWxpbWl0ZXIgPSAnXycpIHQgPVxuICAgIGluc2VydF9kZWxpbWl0ZXJfZXZlcnkgKHRvX3N0cmluZyB0KSB+ZGVsaW1pdGVyIH5jaGFyc19wZXJfZGVsaW1pdGVyXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCB0ID1cbiAgICBsZXQgcyA9IHRvX3N0cmluZyB0IGluXG4gICAgU2V4cC5BdG9tXG4gICAgICAobWF0Y2ggIXNleHBfb2ZfaW50X3N0eWxlIHdpdGhcbiAgICAgICB8IGBVbmRlcnNjb3JlcyAtPiBpbnNlcnRfZGVsaW1pdGVyX2V2ZXJ5IHMgfmNoYXJzX3Blcl9kZWxpbWl0ZXIgfmRlbGltaXRlcjonXydcbiAgICAgICB8IGBOb191bmRlcnNjb3JlcyAtPiBzKVxuICA7O1xuZW5kXG5cbm1vZHVsZSBNYWtlX2hleCAoSSA6IHNpZ1xuICAgIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgaGFzaF1cblxuICAgIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkNvbXBhcmFibGUuUyB3aXRoIHR5cGUgdCA6PSB0XG4gICAgaW5jbHVkZSBQcHhfaGFzaF9saWIuSGFzaGFibGUuUyB3aXRoIHR5cGUgdCA6PSB0XG5cbiAgICBbQEBAZW5kXVxuXG4gICAgdmFsIHRvX3N0cmluZyA6IHQgLT4gc3RyaW5nXG4gICAgdmFsIG9mX3N0cmluZyA6IHN0cmluZyAtPiB0XG4gICAgdmFsIHplcm8gOiB0XG4gICAgdmFsICggPCApIDogdCAtPiB0IC0+IGJvb2xcbiAgICB2YWwgbmVnIDogdCAtPiB0XG4gICAgdmFsIG1vZHVsZV9uYW1lIDogc3RyaW5nXG4gIGVuZCkgPVxuc3RydWN0XG4gIG1vZHVsZSBUX2hleCA9IHN0cnVjdFxuICAgIHR5cGUgdCA9IEkudCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgaGFzaF1cblxuICAgIGxldCBjb21wYXJlID0gKEkuY29tcGFyZSA6IHQgLT4gdCAtPiBpbnQpXG5cbiAgICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgICBJLmhhc2hfZm9sZF90XG5cbiAgICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgICBsZXQgZnVuYyA9IEkuaGFzaCBpblxuICAgICAgZnVuIHggLT4gZnVuYyB4XG4gICAgOztcblxuICAgIFtAQEBlbmRdXG5cbiAgICBsZXQgY2hhcnNfcGVyX2RlbGltaXRlciA9IDRcblxuICAgIGxldCB0b19zdHJpbmcnID9kZWxpbWl0ZXIgdCA9XG4gICAgICBsZXQgbWFrZV9zdWZmaXggPVxuICAgICAgICBtYXRjaCBkZWxpbWl0ZXIgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gSS50b19zdHJpbmdcbiAgICAgICAgfCBTb21lIGRlbGltaXRlciAtPlxuICAgICAgICAgIGZ1biB0IC0+IGluc2VydF9kZWxpbWl0ZXJfZXZlcnkgKEkudG9fc3RyaW5nIHQpIH5kZWxpbWl0ZXIgfmNoYXJzX3Blcl9kZWxpbWl0ZXJcbiAgICAgIGluXG4gICAgICBpZiBJLiggPCApIHQgSS56ZXJvIHRoZW4gXCItMHhcIiBeIG1ha2Vfc3VmZml4IChJLm5lZyB0KSBlbHNlIFwiMHhcIiBeIG1ha2Vfc3VmZml4IHRcbiAgICA7O1xuXG4gICAgbGV0IHRvX3N0cmluZyB0ID0gdG9fc3RyaW5nJyB0ID9kZWxpbWl0ZXI6Tm9uZVxuICAgIGxldCB0b19zdHJpbmdfaHVtID8oZGVsaW1pdGVyID0gJ18nKSB0ID0gdG9fc3RyaW5nJyB0IH5kZWxpbWl0ZXJcblxuICAgIGxldCBpbnZhbGlkIHN0ciA9XG4gICAgICBQcmludGYuZmFpbHdpdGhmIFwiJXMub2Zfc3RyaW5nOiBpbnZhbGlkIGlucHV0ICVTXCIgSS5tb2R1bGVfbmFtZSBzdHIgKClcbiAgICA7O1xuXG4gICAgbGV0IG9mX3N0cmluZ193aXRoX2RlbGltaXRlciBzdHIgPVxuICAgICAgSS5vZl9zdHJpbmcgKFN0cmluZy5maWx0ZXIgc3RyIH5mOihmdW4gYyAtPiBDaGFyLiggPD4gKSBjICdfJykpXG4gICAgOztcblxuICAgIGxldCBvZl9zdHJpbmcgc3RyID1cbiAgICAgIGxldCBtb2R1bGUgTCA9IEhleF9sZXhlciBpblxuICAgICAgbGV0IGxleCA9IENhbWwuTGV4aW5nLmZyb21fc3RyaW5nIHN0ciBpblxuICAgICAgbGV0IHJlc3VsdCA9IE9wdGlvbi50cnlfd2l0aCAoZnVuICgpIC0+IEwucGFyc2VfaGV4IGxleCkgaW5cbiAgICAgIGlmIGxleC5sZXhfY3Vycl9wb3MgPSBsZXgubGV4X2J1ZmZlcl9sZW5cbiAgICAgIHRoZW4gKFxuICAgICAgICBtYXRjaCByZXN1bHQgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gaW52YWxpZCBzdHJcbiAgICAgICAgfCBTb21lIChOZWcgYm9keSkgLT4gSS5uZWcgKG9mX3N0cmluZ193aXRoX2RlbGltaXRlciBib2R5KVxuICAgICAgICB8IFNvbWUgKFBvcyBib2R5KSAtPiBvZl9zdHJpbmdfd2l0aF9kZWxpbWl0ZXIgYm9keSlcbiAgICAgIGVsc2UgaW52YWxpZCBzdHJcbiAgICA7O1xuXG4gICAgbGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID1cbiAgICAgIFNleHBsaWIwLlNleHBfZ3JhbW1hci5jb2VyY2UgU3RyaW5nLnRfc2V4cF9ncmFtbWFyXG4gICAgOztcbiAgZW5kXG5cbiAgbW9kdWxlIEhleCA9IHN0cnVjdFxuICAgIGluY2x1ZGUgVF9oZXhcbiAgICBpbmNsdWRlIFNleHBhYmxlLk9mX3N0cmluZ2FibGUgKFRfaGV4KVxuICBlbmRcbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5cbmxldCBpbnZhbGlkX2FyZ2YgPSBQcmludGYuaW52YWxpZF9hcmdmXG5sZXQgbmVnYXRpdmVfZXhwb25lbnQgKCkgPSBQcmludGYuaW52YWxpZF9hcmdmIFwiZXhwb25lbnQgY2FuIG5vdCBiZSBuZWdhdGl2ZVwiICgpXG5sZXQgb3ZlcmZsb3cgKCkgPSBQcmludGYuaW52YWxpZF9hcmdmIFwiaW50ZWdlciBvdmVyZmxvdyBpbiBwb3dcIiAoKVxuXG4oKiBUbyBpbXBsZW1lbnQgW2ludDY0X3Bvd10sIHdlIHVzZSBDIGNvZGUgcmF0aGVyIHRoYW4gT0NhbWwgdG8gZWxpbWluYXRlIGFsbG9jYXRpb24uICopXG5leHRlcm5hbCBpbnRfbWF0aF9pbnRfcG93IDogaW50IC0+IGludCAtPiBpbnQgPSBcIkJhc2VfaW50X21hdGhfaW50X3Bvd19zdHViXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIGludF9tYXRoX2ludDY0X3BvdyA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCJCYXNlX2ludF9tYXRoX2ludDY0X3Bvd19zdHViXCJcblxubGV0IGludF9wb3cgYmFzZSBleHBvbmVudCA9XG4gIGlmIGV4cG9uZW50IDwgMCB0aGVuIG5lZ2F0aXZlX2V4cG9uZW50ICgpO1xuICBpZiBhYnMgYmFzZSA+IDFcbiAgJiYgKGV4cG9uZW50ID4gNjNcbiAgICAgIHx8IGFicyBiYXNlID4gUG93X292ZXJmbG93X2JvdW5kcy5pbnRfcG9zaXRpdmVfb3ZlcmZsb3dfYm91bmRzLihleHBvbmVudCkpXG4gIHRoZW4gb3ZlcmZsb3cgKCk7XG4gIGludF9tYXRoX2ludF9wb3cgYmFzZSBleHBvbmVudFxuOztcblxubW9kdWxlIEludDY0X3dpdGhfY29tcGFyaXNvbnMgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBDYW1sLkludDY0XG5cbiAgZXh0ZXJuYWwgKCA8ICkgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBib29sID0gXCIlbGVzc3RoYW5cIlxuICBleHRlcm5hbCAoID4gKSA6IGludDY0IC0+IGludDY0IC0+IGJvb2wgPSBcIiVncmVhdGVydGhhblwiXG4gIGV4dGVybmFsICggPj0gKSA6IGludDY0IC0+IGludDY0IC0+IGJvb2wgPSBcIiVncmVhdGVyZXF1YWxcIlxuZW5kXG5cbigqIHdlIGRvbid0IGRvIFthYnNdIGluIGludDY0IGNhc2UgdG8gYXZvaWQgYWxsb2NhdGlvbiAqKVxubGV0IGludDY0X3BvdyBiYXNlIGV4cG9uZW50ID1cbiAgbGV0IG9wZW4gSW50NjRfd2l0aF9jb21wYXJpc29ucyBpblxuICBpZiBleHBvbmVudCA8IDBMIHRoZW4gbmVnYXRpdmVfZXhwb25lbnQgKCk7XG4gIGlmIChiYXNlID4gMUwgfHwgYmFzZSA8IC0xTClcbiAgJiYgKGV4cG9uZW50ID4gNjNMXG4gICAgICB8fCAoYmFzZSA+PSAwTFxuICAgICAgICAgICYmIGJhc2UgPiBQb3dfb3ZlcmZsb3dfYm91bmRzLmludDY0X3Bvc2l0aXZlX292ZXJmbG93X2JvdW5kcy4odG9faW50IGV4cG9uZW50KVxuICAgICAgICAgKVxuICAgICAgfHwgKGJhc2UgPCAwTFxuICAgICAgICAgICYmIGJhc2UgPCBQb3dfb3ZlcmZsb3dfYm91bmRzLmludDY0X25lZ2F0aXZlX292ZXJmbG93X2JvdW5kcy4odG9faW50IGV4cG9uZW50KVxuICAgICAgICAgKSlcbiAgdGhlbiBvdmVyZmxvdyAoKTtcbiAgaW50X21hdGhfaW50NjRfcG93IGJhc2UgZXhwb25lbnRcbjs7XG5cbmxldCBpbnQ2M19wb3dfb25faW50NjQgYmFzZSBleHBvbmVudCA9XG4gIGxldCBvcGVuIEludDY0X3dpdGhfY29tcGFyaXNvbnMgaW5cbiAgaWYgZXhwb25lbnQgPCAwTCB0aGVuIG5lZ2F0aXZlX2V4cG9uZW50ICgpO1xuICBpZiBhYnMgYmFzZSA+IDFMXG4gICYmIChleHBvbmVudCA+IDYzTFxuICAgICAgfHwgYWJzIGJhc2VcbiAgICAgICAgID4gUG93X292ZXJmbG93X2JvdW5kcy5pbnQ2M19vbl9pbnQ2NF9wb3NpdGl2ZV9vdmVyZmxvd19ib3VuZHMuKHRvX2ludCBleHBvbmVudClcbiAgICAgKVxuICB0aGVuIG92ZXJmbG93ICgpO1xuICBpbnRfbWF0aF9pbnQ2NF9wb3cgYmFzZSBleHBvbmVudFxuOztcblxubW9kdWxlIHR5cGUgTWFrZV9hcmcgPSBzaWdcbiAgdHlwZSB0XG5cbiAgaW5jbHVkZSBGbG9hdGFibGUuUyB3aXRoIHR5cGUgdCA6PSB0XG4gIGluY2x1ZGUgU3RyaW5nYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcblxuICB2YWwgKCArICkgOiB0IC0+IHQgLT4gdFxuICB2YWwgKCAtICkgOiB0IC0+IHQgLT4gdFxuICB2YWwgKCAqICkgOiB0IC0+IHQgLT4gdFxuICB2YWwgKCAvICkgOiB0IC0+IHQgLT4gdFxuICB2YWwgKCB+LSApIDogdCAtPiB0XG5cbiAgaW5jbHVkZSBDb21wYXJpc29ucy5JbmZpeCB3aXRoIHR5cGUgdCA6PSB0XG5cbiAgdmFsIGFicyA6IHQgLT4gdFxuICB2YWwgbmVnIDogdCAtPiB0XG4gIHZhbCB6ZXJvIDogdFxuICB2YWwgb2ZfaW50X2V4biA6IGludCAtPiB0XG4gIHZhbCByZW0gOiB0IC0+IHQgLT4gdFxuZW5kXG5cbm1vZHVsZSBNYWtlIChYIDogTWFrZV9hcmcpID0gc3RydWN0XG4gIG9wZW4gWFxuXG4gIGxldCAoICUgKSB4IHkgPVxuICAgIGlmIHkgPD0gemVyb1xuICAgIHRoZW5cbiAgICAgIGludmFsaWRfYXJnZlxuICAgICAgICBcIiVzICUlICVzIGluIGNvcmVfaW50Lm1sOiBtb2R1bHVzIHNob3VsZCBiZSBwb3NpdGl2ZVwiXG4gICAgICAgICh0b19zdHJpbmcgeClcbiAgICAgICAgKHRvX3N0cmluZyB5KVxuICAgICAgICAoKTtcbiAgICBsZXQgcnZhbCA9IFgucmVtIHggeSBpblxuICAgIGlmIHJ2YWwgPCB6ZXJvIHRoZW4gcnZhbCArIHkgZWxzZSBydmFsXG4gIDs7XG5cbiAgbGV0IG9uZSA9IG9mX2ludF9leG4gMVxuXG4gIGxldCAoIC8lICkgeCB5ID1cbiAgICBpZiB5IDw9IHplcm9cbiAgICB0aGVuXG4gICAgICBpbnZhbGlkX2FyZ2ZcbiAgICAgICAgXCIlcyAvJSUgJXMgaW4gY29yZV9pbnQubWw6IGRpdmlzb3Igc2hvdWxkIGJlIHBvc2l0aXZlXCJcbiAgICAgICAgKHRvX3N0cmluZyB4KVxuICAgICAgICAodG9fc3RyaW5nIHkpXG4gICAgICAgICgpO1xuICAgIGlmIHggPCB6ZXJvIHRoZW4gKCh4ICsgb25lKSAvIHkpIC0gb25lIGVsc2UgeCAvIHlcbiAgOztcblxuICAoKiogZmxvYXQgZGl2aXNpb24gb2YgaW50ZWdlcnMgKilcbiAgbGV0ICggLy8gKSB4IHkgPSB0b19mbG9hdCB4IC8uIHRvX2Zsb2F0IHlcblxuICBsZXQgcm91bmRfZG93biBpIH50b19tdWx0aXBsZV9vZjptb2R1bHVzID0gaSAtIChpICUgbW9kdWx1cylcblxuICBsZXQgcm91bmRfdXAgaSB+dG9fbXVsdGlwbGVfb2Y6bW9kdWx1cyA9XG4gICAgbGV0IHJlbWFpbmRlciA9IGkgJSBtb2R1bHVzIGluXG4gICAgaWYgcmVtYWluZGVyID0gemVybyB0aGVuIGkgZWxzZSBpICsgbW9kdWx1cyAtIHJlbWFpbmRlclxuICA7O1xuXG4gIGxldCByb3VuZF90b3dhcmRzX3plcm8gaSB+dG9fbXVsdGlwbGVfb2YgPVxuICAgIGlmIGkgPSB6ZXJvXG4gICAgdGhlbiB6ZXJvXG4gICAgZWxzZSBpZiBpID4gemVyb1xuICAgIHRoZW4gcm91bmRfZG93biBpIH50b19tdWx0aXBsZV9vZlxuICAgIGVsc2Ugcm91bmRfdXAgaSB+dG9fbXVsdGlwbGVfb2ZcbiAgOztcblxuICBsZXQgcm91bmRfbmVhcmVzdCBpIH50b19tdWx0aXBsZV9vZjptb2R1bHVzID1cbiAgICBsZXQgcmVtYWluZGVyID0gaSAlIG1vZHVsdXMgaW5cbiAgICBsZXQgbW9kdWx1c19taW51c19yZW1haW5kZXIgPSBtb2R1bHVzIC0gcmVtYWluZGVyIGluXG4gICAgaWYgbW9kdWx1c19taW51c19yZW1haW5kZXIgPD0gcmVtYWluZGVyXG4gICAgdGhlbiBpICsgbW9kdWx1c19taW51c19yZW1haW5kZXJcbiAgICBlbHNlIGkgLSByZW1haW5kZXJcbiAgOztcblxuICBsZXQgcm91bmQgPyhkaXIgPSBgTmVhcmVzdCkgaSB+dG9fbXVsdGlwbGVfb2YgPVxuICAgIG1hdGNoIGRpciB3aXRoXG4gICAgfCBgTmVhcmVzdCAtPiByb3VuZF9uZWFyZXN0IGkgfnRvX211bHRpcGxlX29mXG4gICAgfCBgRG93biAtPiByb3VuZF9kb3duIGkgfnRvX211bHRpcGxlX29mXG4gICAgfCBgVXAgLT4gcm91bmRfdXAgaSB+dG9fbXVsdGlwbGVfb2ZcbiAgICB8IGBaZXJvIC0+IHJvdW5kX3Rvd2FyZHNfemVybyBpIH50b19tdWx0aXBsZV9vZlxuICA7O1xuZW5kXG5cbm1vZHVsZSBQcml2YXRlID0gc3RydWN0XG4gIGxldCBpbnRfcG93ID0gaW50X3Bvd1xuICBsZXQgaW50NjRfcG93ID0gaW50NjRfcG93XG4gIGxldCBpbnQ2M19wb3dfb25faW50NjQgPSBpbnQ2M19wb3dfb25faW50NjRcblxuICBtb2R1bGUgUG93X292ZXJmbG93X2JvdW5kcyA9IFBvd19vdmVyZmxvd19ib3VuZHNcbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIFNpZ24wXG5pbmNsdWRlIElkZW50aWZpYWJsZS5NYWtlIChTaWduMClcblxuKCogT3BlbiBbUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXSBhZnRlciBpbmNsdWRpbmcgZnVuY3RvciBhcHBsaWNhdGlvbnMgc29cbiAgIHRoZXkgZG8gbm90IHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXMgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9uc1xuICAgb2YgdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25zIGFyZSBhdmFpbGFibGUgd2l0aGluIHRoaXMgbW9kdWxlLiAqKVxub3BlbiEgUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbmxldCB0b19mbG9hdCA9IGZ1bmN0aW9uXG4gIHwgTmVnIC0+IC0xLlxuICB8IFplcm8gLT4gMC5cbiAgfCBQb3MgLT4gMS5cbjs7XG5cbmxldCBmbGlwID0gZnVuY3Rpb25cbiAgfCBOZWcgLT4gUG9zXG4gIHwgWmVybyAtPiBaZXJvXG4gIHwgUG9zIC0+IE5lZ1xuOztcblxubGV0ICggKiApIHQgdCcgPSBvZl9pbnQgKHRvX2ludCB0ICogdG9faW50IHQnKVxuXG4oKiBJbmNsdWRlIHR5cGUtc3BlY2lmaWMgW1JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBhdCB0aGUgZW5kLCBhZnRlciBhbnlcbiAgIGZ1bmN0b3IgYXBwbGljYXRpb25zIHRoYXQgY291bGQgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpcyBoZXJlIHNvXG4gICB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbnMgYXJlIGV4cG9ydGVkIGJ5IHRoaXNcbiAgIG1vZHVsZS4gKilcbmluY2x1ZGUgUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG4iLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgU3RhY2tfaW50ZlxuXG5sZXQgcmFpc2VfcyA9IEVycm9yLnJhaXNlX3NcblxuKCogVGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBzaW1pbGFyIHRvIFtEZXF1ZV0gaW4gdGhhdCBpdCB1c2VzIGFuIGFycmF5IG9mIFsnYV0gYW5kXG4gICBhIG11dGFibGUgW2ludF0gdG8gaW5kaWNhdGUgd2hhdCBpbiB0aGUgYXJyYXkgaXMgdXNlZC4gIFdlIGNob29zZSB0byBpbXBsZW1lbnQgW1N0YWNrXVxuICAgZGlyZWN0bHkgcmF0aGVyIHRoYW4gb24gdG9wIG9mIFtEZXF1ZV0gZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuICBFLmcuIGEgc2ltcGxlXG4gICBtaWNyb2JlbmNobWFyayBzaG93cyB0aGF0IHB1c2gvcG9wIGlzIGFib3V0IDIwJSBmYXN0ZXIuICopXG50eXBlICdhIHQgPVxuICB7IG11dGFibGUgbGVuZ3RoIDogaW50XG4gIDsgbXV0YWJsZSBlbHRzIDogJ2EgT3B0aW9uX2FycmF5LnRcbiAgfVxuW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbmxldCBzZXhwX29mX3QgOiAnYS4gKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgdCAtPiBTZXhwbGliMC5TZXhwLnQgPVxuICBmdW4gX29mX2FfXzAwMV8geyBsZW5ndGggPSBsZW5ndGhfXzAwM187IGVsdHMgPSBlbHRzX18wMDVfIH0gLT5cbiAgbGV0IGJuZHNfXzAwMl8gPSBbXSBpblxuICBsZXQgYm5kc19fMDAyXyA9XG4gICAgbGV0IGFyZ19fMDA2XyA9IE9wdGlvbl9hcnJheS5zZXhwX29mX3QgX29mX2FfXzAwMV8gZWx0c19fMDA1XyBpblxuICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcImVsdHNcIjsgYXJnX18wMDZfIF0gOjogYm5kc19fMDAyX1xuICBpblxuICBsZXQgYm5kc19fMDAyXyA9XG4gICAgbGV0IGFyZ19fMDA0XyA9IHNleHBfb2ZfaW50IGxlbmd0aF9fMDAzXyBpblxuICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcImxlbmd0aFwiOyBhcmdfXzAwNF8gXSA6OiBibmRzX18wMDJfXG4gIGluXG4gIFNleHBsaWIwLlNleHAuTGlzdCBibmRzX18wMDJfXG47O1xuXG5bQEBAZW5kXVxuXG5sZXQgc2V4cF9vZl90X2ludGVybmFsID0gc2V4cF9vZl90XG5sZXQgc2V4cF9vZl90ID0gYFJlYm91bmRfbGF0ZXJcbmxldCBfID0gc2V4cF9vZl90XG5sZXQgY2FwYWNpdHkgdCA9IE9wdGlvbl9hcnJheS5sZW5ndGggdC5lbHRzXG5cbmxldCBpbnZhcmlhbnQgaW52YXJpYW50X2EgKHsgbGVuZ3RoOyBlbHRzIH0gYXMgdCkgOiB1bml0ID1cbiAgdHJ5XG4gICAgYXNzZXJ0ICgwIDw9IGxlbmd0aCAmJiBsZW5ndGggPD0gT3B0aW9uX2FycmF5Lmxlbmd0aCBlbHRzKTtcbiAgICBmb3IgaSA9IDAgdG8gbGVuZ3RoIC0gMSBkb1xuICAgICAgaW52YXJpYW50X2EgKE9wdGlvbl9hcnJheS5nZXRfc29tZV9leG4gZWx0cyBpKVxuICAgIGRvbmU7XG4gICAgKCogV2UgbWFpbnRhaW4gdGhlIGludmFyaWFudCB0aGF0IHVudXNlZCBlbGVtZW50cyBhcmUgdW5zZXQgdG8gYXZvaWQgYSBzcGFjZVxuICAgICAgIGxlYWsuICopXG4gICAgZm9yIGkgPSBsZW5ndGggdG8gT3B0aW9uX2FycmF5Lmxlbmd0aCBlbHRzIC0gMSBkb1xuICAgICAgYXNzZXJ0IChub3QgKE9wdGlvbl9hcnJheS5pc19zb21lIGVsdHMgaSkpXG4gICAgZG9uZVxuICB3aXRoXG4gIHwgZXhuIC0+XG4gICAgcmFpc2Vfc1xuICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgXCJTdGFjay5pbnZhcmlhbnQgZmFpbGVkXCJcbiAgICAgICAgIFsgXCJleG5cIiwgZXhuIHw+IEV4bi5zZXhwX29mX3Q7IFwic3RhY2tcIiwgdCB8PiBzZXhwX29mX3RfaW50ZXJuYWwgc2V4cF9vZl9vcGFxdWUgXSlcbjs7XG5cbmxldCBjcmVhdGUgKHR5cGUgYSkgKCkgOiBhIHQgPSB7IGxlbmd0aCA9IDA7IGVsdHMgPSBPcHRpb25fYXJyYXkuZW1wdHkgfVxubGV0IGxlbmd0aCB0ID0gdC5sZW5ndGhcbmxldCBpc19lbXB0eSB0ID0gbGVuZ3RoIHQgPSAwXG5cbigqIFRoZSBvcmRlciBpbiB3aGljaCBlbGVtZW50cyBhcmUgdmlzaXRlZCBoYXMgYmVlbiBjaG9zZW4gc28gYXMgdG8gYmUgYmFja3dhcmRzXG4gICBjb21wYXRpYmxlIHdpdGggW0NhbWwuU3RhY2tdICopXG5sZXQgZm9sZCB0IH5pbml0IH5mID1cbiAgbGV0IHIgPSByZWYgaW5pdCBpblxuICBmb3IgaSA9IHQubGVuZ3RoIC0gMSBkb3dudG8gMCBkb1xuICAgIHIgOj0gZiAhciAoT3B0aW9uX2FycmF5LmdldF9zb21lX2V4biB0LmVsdHMgaSlcbiAgZG9uZTtcbiAgIXJcbjs7XG5cbmxldCBpdGVyIHQgfmYgPVxuICBmb3IgaSA9IHQubGVuZ3RoIC0gMSBkb3dudG8gMCBkb1xuICAgIGYgKE9wdGlvbl9hcnJheS5nZXRfc29tZV9leG4gdC5lbHRzIGkpXG4gIGRvbmVcbjs7XG5cbm1vZHVsZSBDID0gQ29udGFpbmVyLk1ha2UgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgICBsZXQgZm9sZCA9IGZvbGRcbiAgICBsZXQgaXRlciA9IGBDdXN0b20gaXRlclxuICAgIGxldCBsZW5ndGggPSBgQ3VzdG9tIGxlbmd0aFxuICBlbmQpXG5cbmxldCBtZW0gPSBDLm1lbVxubGV0IGV4aXN0cyA9IEMuZXhpc3RzXG5sZXQgZm9yX2FsbCA9IEMuZm9yX2FsbFxubGV0IGNvdW50ID0gQy5jb3VudFxubGV0IHN1bSA9IEMuc3VtXG5sZXQgZmluZCA9IEMuZmluZFxubGV0IGZpbmRfbWFwID0gQy5maW5kX21hcFxubGV0IHRvX2xpc3QgPSBDLnRvX2xpc3RcbmxldCB0b19hcnJheSA9IEMudG9fYXJyYXlcbmxldCBtaW5fZWx0ID0gQy5taW5fZWx0XG5sZXQgbWF4X2VsdCA9IEMubWF4X2VsdFxubGV0IGZvbGRfcmVzdWx0ID0gQy5mb2xkX3Jlc3VsdFxubGV0IGZvbGRfdW50aWwgPSBDLmZvbGRfdW50aWxcblxubGV0IG9mX2xpc3QgKHR5cGUgYSkgKGwgOiBhIGxpc3QpID1cbiAgaWYgTGlzdC5pc19lbXB0eSBsXG4gIHRoZW4gY3JlYXRlICgpXG4gIGVsc2UgKFxuICAgIGxldCBsZW5ndGggPSBMaXN0Lmxlbmd0aCBsIGluXG4gICAgbGV0IGVsdHMgPSBPcHRpb25fYXJyYXkuY3JlYXRlIH5sZW46KDIgKiBsZW5ndGgpIGluXG4gICAgbGV0IHIgPSByZWYgbCBpblxuICAgIGZvciBpID0gbGVuZ3RoIC0gMSBkb3dudG8gMCBkb1xuICAgICAgbWF0Y2ggIXIgd2l0aFxuICAgICAgfCBbXSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgIHwgYSA6OiBsIC0+XG4gICAgICAgIE9wdGlvbl9hcnJheS5zZXRfc29tZSBlbHRzIGkgYTtcbiAgICAgICAgciA6PSBsXG4gICAgZG9uZTtcbiAgICB7IGxlbmd0aDsgZWx0cyB9KVxuOztcblxubGV0IHNleHBfb2ZfdCBzZXhwX29mX2EgdCA9IExpc3Quc2V4cF9vZl90IHNleHBfb2ZfYSAodG9fbGlzdCB0KVxubGV0IHRfb2Zfc2V4cCBhX29mX3NleHAgc2V4cCA9IG9mX2xpc3QgKExpc3QudF9vZl9zZXhwIGFfb2Zfc2V4cCBzZXhwKVxuXG5sZXQgdF9zZXhwX2dyYW1tYXIgKHR5cGUgYSkgKGdyYW1tYXIgOiBhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50KVxuICA6IGEgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICA9XG4gIFNleHBsaWIwLlNleHBfZ3JhbW1hci5jb2VyY2UgKExpc3QudF9zZXhwX2dyYW1tYXIgZ3JhbW1hcilcbjs7XG5cbmxldCByZXNpemUgdCBzaXplID1cbiAgbGV0IGFyciA9IE9wdGlvbl9hcnJheS5jcmVhdGUgfmxlbjpzaXplIGluXG4gIE9wdGlvbl9hcnJheS5ibGl0IH5zcmM6dC5lbHRzIH5kc3Q6YXJyIH5zcmNfcG9zOjAgfmRzdF9wb3M6MCB+bGVuOnQubGVuZ3RoO1xuICB0LmVsdHMgPC0gYXJyXG47O1xuXG5sZXQgc2V0X2NhcGFjaXR5IHQgbmV3X2NhcGFjaXR5ID1cbiAgbGV0IG5ld19jYXBhY2l0eSA9IG1heCBuZXdfY2FwYWNpdHkgKGxlbmd0aCB0KSBpblxuICBpZiBuZXdfY2FwYWNpdHkgPD4gY2FwYWNpdHkgdCB0aGVuIHJlc2l6ZSB0IG5ld19jYXBhY2l0eVxuOztcblxubGV0IHB1c2ggdCBhID1cbiAgaWYgdC5sZW5ndGggPSBPcHRpb25fYXJyYXkubGVuZ3RoIHQuZWx0cyB0aGVuIHJlc2l6ZSB0ICgyICogKHQubGVuZ3RoICsgMSkpO1xuICBPcHRpb25fYXJyYXkuc2V0X3NvbWUgdC5lbHRzIHQubGVuZ3RoIGE7XG4gIHQubGVuZ3RoIDwtIHQubGVuZ3RoICsgMVxuOztcblxubGV0IHBvcF9ub25lbXB0eSB0ID1cbiAgbGV0IGkgPSB0Lmxlbmd0aCAtIDEgaW5cbiAgbGV0IHJlc3VsdCA9IE9wdGlvbl9hcnJheS5nZXRfc29tZV9leG4gdC5lbHRzIGkgaW5cbiAgT3B0aW9uX2FycmF5LnNldF9ub25lIHQuZWx0cyBpO1xuICB0Lmxlbmd0aCA8LSBpO1xuICByZXN1bHRcbjs7XG5cbmxldCBwb3BfZXJyb3IgPSBFcnJvci5vZl9zdHJpbmcgXCJTdGFjay5wb3Agb2YgZW1wdHkgc3RhY2tcIlxubGV0IHBvcCB0ID0gaWYgaXNfZW1wdHkgdCB0aGVuIE5vbmUgZWxzZSBTb21lIChwb3Bfbm9uZW1wdHkgdClcbmxldCBwb3BfZXhuIHQgPSBpZiBpc19lbXB0eSB0IHRoZW4gRXJyb3IucmFpc2UgcG9wX2Vycm9yIGVsc2UgcG9wX25vbmVtcHR5IHRcbmxldCB0b3Bfbm9uZW1wdHkgdCA9IE9wdGlvbl9hcnJheS5nZXRfc29tZV9leG4gdC5lbHRzICh0Lmxlbmd0aCAtIDEpXG5sZXQgdG9wX2Vycm9yID0gRXJyb3Iub2Zfc3RyaW5nIFwiU3RhY2sudG9wIG9mIGVtcHR5IHN0YWNrXCJcbmxldCB0b3AgdCA9IGlmIGlzX2VtcHR5IHQgdGhlbiBOb25lIGVsc2UgU29tZSAodG9wX25vbmVtcHR5IHQpXG5sZXQgdG9wX2V4biB0ID0gaWYgaXNfZW1wdHkgdCB0aGVuIEVycm9yLnJhaXNlIHRvcF9lcnJvciBlbHNlIHRvcF9ub25lbXB0eSB0XG5sZXQgY29weSB7IGxlbmd0aDsgZWx0cyB9ID0geyBsZW5ndGg7IGVsdHMgPSBPcHRpb25fYXJyYXkuY29weSBlbHRzIH1cblxubGV0IGNsZWFyIHQgPVxuICBpZiB0Lmxlbmd0aCA+IDBcbiAgdGhlbiAoXG4gICAgZm9yIGkgPSAwIHRvIHQubGVuZ3RoIC0gMSBkb1xuICAgICAgT3B0aW9uX2FycmF5LnNldF9ub25lIHQuZWx0cyBpXG4gICAgZG9uZTtcbiAgICB0Lmxlbmd0aCA8LSAwKVxuOztcblxubGV0IHVudGlsX2VtcHR5IHQgZiA9XG4gIGxldCByZWMgbG9vcCAoKSA9XG4gICAgaWYgdC5sZW5ndGggPiAwXG4gICAgdGhlbiAoXG4gICAgICBmIChwb3Bfbm9uZW1wdHkgdCk7XG4gICAgICBsb29wICgpKVxuICBpblxuICBsb29wICgpXG47O1xuXG5sZXQgc2luZ2xldG9uIHggPVxuICBsZXQgdCA9IGNyZWF0ZSAoKSBpblxuICBwdXNoIHQgeDtcbiAgdFxuOztcbiIsIm9wZW4hIEltcG9ydFxuXG4oKiBUaGlzIGlzIGxpZnRlZCBvdXQgb2YgW01dIGJlY2F1c2UgW1NvdXJjZV9jb2RlX3Bvc2l0aW9uMF0gZXhwb3J0cyBbU3RyaW5nMF1cbiAgIGFzIFtTdHJpbmddLCB3aGljaCBkb2VzIG5vdCBleHBvcnQgYSBoYXNoIGZ1bmN0aW9uLiAqKVxubGV0IGhhc2hfb3ZlcnJpZGUgeyBDYW1sLkxleGluZy5wb3NfZm5hbWU7IHBvc19sbnVtOyBwb3NfYm9sOyBwb3NfY251bSB9ID1cbiAgU3RyaW5nLmhhc2ggcG9zX2ZuYW1lXG4gIGx4b3IgSW50Lmhhc2ggcG9zX2xudW1cbiAgbHhvciBJbnQuaGFzaCBwb3NfYm9sXG4gIGx4b3IgSW50Lmhhc2ggcG9zX2NudW1cbjs7XG5cbm1vZHVsZSBNID0gc3RydWN0XG4gIGluY2x1ZGUgU291cmNlX2NvZGVfcG9zaXRpb24wXG5cbiAgbGV0IGhhc2ggPSBoYXNoX292ZXJyaWRlXG5lbmRcblxuaW5jbHVkZSBNXG5pbmNsdWRlIENvbXBhcmFibGUuTWFrZV91c2luZ19jb21wYXJhdG9yIChNKVxuXG5sZXQgb2ZfcG9zIChwb3NfZm5hbWUsIHBvc19sbnVtLCBwb3NfY251bSwgXykgPVxuICB7IHBvc19mbmFtZTsgcG9zX2xudW07IHBvc19jbnVtOyBwb3NfYm9sID0gMCB9XG47O1xuIiwib3BlbiEgSW1wb3J0XG5vcGVuISBUXG5cbm1vZHVsZSB0eXBlIEVsdF9wbGFpbiA9IHNpZ1xuICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIHNleHBfb2ZdXG5cbiAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcblxuICB2YWwgc2V4cF9vZl90IDogdCAtPiBTZXhwbGliMC5TZXhwLnRcblxuICBbQEBAZW5kXVxuZW5kXG5cbm1vZHVsZSBXaXRob3V0X2NvbXBhcmF0b3IgPSBNYXBfaW50Zi5XaXRob3V0X2NvbXBhcmF0b3Jcbm1vZHVsZSBXaXRoX2NvbXBhcmF0b3IgPSBNYXBfaW50Zi5XaXRoX2NvbXBhcmF0b3Jcbm1vZHVsZSBXaXRoX2ZpcnN0X2NsYXNzX21vZHVsZSA9IE1hcF9pbnRmLldpdGhfZmlyc3RfY2xhc3NfbW9kdWxlXG5tb2R1bGUgTWVyZ2VfdG9fc2VxdWVuY2VfZWxlbWVudCA9IFNlcXVlbmNlLk1lcmdlX3dpdGhfZHVwbGljYXRlc19lbGVtZW50XG5cbm1vZHVsZSB0eXBlIEFjY2Vzc29yc19nZW5lcmljID0gc2lnXG4gIGluY2x1ZGUgQ29udGFpbmVyLkdlbmVyaWNfcGhhbnRvbVxuXG4gIHR5cGUgKCdhLCAnY21wKSB0cmVlXG5cbiAgKCoqIFRoZSBbb3B0aW9uc10gdHlwZSBpcyB1c2VkIHRvIG1ha2UgW0FjY2Vzc29yc19nZW5lcmljXSBmbGV4aWJsZSBhcyB0byB3aGV0aGVyIGFcbiAgICAgIGNvbXBhcmF0b3IgaXMgcmVxdWlyZWQgdG8gYmUgcGFzc2VkIHRvIGNlcnRhaW4gZnVuY3Rpb25zLiAqKVxuICB0eXBlICgnYSwgJ2NtcCwgJ3opIG9wdGlvbnNcblxuICB0eXBlICdjbXAgY21wXG5cbiAgdmFsIGludmFyaWFudHMgOiAoJ2EsICdjbXAsICgnYSwgJ2NtcCkgdCAtPiBib29sKSBvcHRpb25zXG5cbiAgKCoqIG92ZXJyaWRlIFtDb250YWluZXJdJ3MgW21lbV0gKilcbiAgdmFsIG1lbSA6ICgnYSwgJ2NtcCwgKCdhLCAnY21wKSB0IC0+ICdhIGVsdCAtPiBib29sKSBvcHRpb25zXG5cbiAgdmFsIGFkZCA6ICgnYSwgJ2NtcCwgKCdhLCAnY21wKSB0IC0+ICdhIGVsdCAtPiAoJ2EsICdjbXApIHQpIG9wdGlvbnNcbiAgdmFsIHJlbW92ZSA6ICgnYSwgJ2NtcCwgKCdhLCAnY21wKSB0IC0+ICdhIGVsdCAtPiAoJ2EsICdjbXApIHQpIG9wdGlvbnNcbiAgdmFsIHVuaW9uIDogKCdhLCAnY21wLCAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdCkgb3B0aW9uc1xuICB2YWwgaW50ZXIgOiAoJ2EsICdjbXAsICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0KSBvcHRpb25zXG4gIHZhbCBkaWZmIDogKCdhLCAnY21wLCAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdCkgb3B0aW9uc1xuXG4gIHZhbCBzeW1tZXRyaWNfZGlmZlxuICAgIDogKCAnYVxuICAgICAgLCAnY21wXG4gICAgICAsICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQgLT4gKCdhIGVsdCwgJ2EgZWx0KSBFaXRoZXIudCBTZXF1ZW5jZS50IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBjb21wYXJlX2RpcmVjdCA6ICgnYSwgJ2NtcCwgKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdCAtPiBpbnQpIG9wdGlvbnNcbiAgdmFsIGVxdWFsIDogKCdhLCAnY21wLCAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+IGJvb2wpIG9wdGlvbnNcbiAgdmFsIGlzX3N1YnNldCA6ICgnYSwgJ2NtcCwgKCdhLCAnY21wKSB0IC0+IG9mXzooJ2EsICdjbXApIHQgLT4gYm9vbCkgb3B0aW9uc1xuICB2YWwgYXJlX2Rpc2pvaW50IDogKCdhLCAnY21wLCAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+IGJvb2wpIG9wdGlvbnNcblxuICB0eXBlICgnYSwgJ2NtcCkgbmFtZWRcblxuICBtb2R1bGUgTmFtZWQgOiBzaWdcbiAgICB2YWwgaXNfc3Vic2V0XG4gICAgICA6ICgnYSwgJ2NtcCwgKCdhLCAnY21wKSBuYW1lZCAtPiBvZl86KCdhLCAnY21wKSBuYW1lZCAtPiB1bml0IE9yX2Vycm9yLnQpIG9wdGlvbnNcblxuICAgIHZhbCBlcXVhbFxuICAgICAgOiAoJ2EsICdjbXAsICgnYSwgJ2NtcCkgbmFtZWQgLT4gKCdhLCAnY21wKSBuYW1lZCAtPiB1bml0IE9yX2Vycm9yLnQpIG9wdGlvbnNcbiAgZW5kXG5cbiAgdmFsIGZvbGRfdW50aWxcbiAgICA6ICAoJ2EsIF8pIHRcbiAgICAtPiBpbml0OidiXG4gICAgLT4gZjooJ2IgLT4gJ2EgZWx0IC0+ICgnYiwgJ2ZpbmFsKSBDb250YWluZXIuQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IGZpbmlzaDooJ2IgLT4gJ2ZpbmFsKVxuICAgIC0+ICdmaW5hbFxuXG4gIHZhbCBmb2xkX3JpZ2h0IDogKCdhLCBfKSB0IC0+IGluaXQ6J2IgLT4gZjooJ2EgZWx0IC0+ICdiIC0+ICdiKSAtPiAnYlxuXG4gIHZhbCBpdGVyMlxuICAgIDogKCAnYVxuICAgICAgLCAnY21wXG4gICAgICAsICgnYSwgJ2NtcCkgdFxuICAgICAgLT4gKCdhLCAnY21wKSB0XG4gICAgICAtPiBmOihbIGBMZWZ0IG9mICdhIGVsdCB8IGBSaWdodCBvZiAnYSBlbHQgfCBgQm90aCBvZiAnYSBlbHQgKiAnYSBlbHQgXSAtPiB1bml0KVxuICAgICAgLT4gdW5pdCApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgZmlsdGVyIDogKCdhLCAnY21wLCAoJ2EsICdjbXApIHQgLT4gZjooJ2EgZWx0IC0+IGJvb2wpIC0+ICgnYSwgJ2NtcCkgdCkgb3B0aW9uc1xuXG4gIHZhbCBwYXJ0aXRpb25fdGZcbiAgICA6ICggJ2FcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2EsICdjbXApIHQgLT4gZjooJ2EgZWx0IC0+IGJvb2wpIC0+ICgnYSwgJ2NtcCkgdCAqICgnYSwgJ2NtcCkgdCApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgZWxlbWVudHMgOiAoJ2EsIF8pIHQgLT4gJ2EgZWx0IGxpc3RcbiAgdmFsIG1pbl9lbHQgOiAoJ2EsIF8pIHQgLT4gJ2EgZWx0IG9wdGlvblxuICB2YWwgbWluX2VsdF9leG4gOiAoJ2EsIF8pIHQgLT4gJ2EgZWx0XG4gIHZhbCBtYXhfZWx0IDogKCdhLCBfKSB0IC0+ICdhIGVsdCBvcHRpb25cbiAgdmFsIG1heF9lbHRfZXhuIDogKCdhLCBfKSB0IC0+ICdhIGVsdFxuICB2YWwgY2hvb3NlIDogKCdhLCBfKSB0IC0+ICdhIGVsdCBvcHRpb25cbiAgdmFsIGNob29zZV9leG4gOiAoJ2EsIF8pIHQgLT4gJ2EgZWx0XG5cbiAgdmFsIHNwbGl0XG4gICAgOiAoICdhXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdhLCAnY21wKSB0IC0+ICdhIGVsdCAtPiAoJ2EsICdjbXApIHQgKiAnYSBlbHQgb3B0aW9uICogKCdhLCAnY21wKSB0IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBncm91cF9ieVxuICAgIDogKCAnYVxuICAgICAgLCAnY21wXG4gICAgICAsICgnYSwgJ2NtcCkgdCAtPiBlcXVpdjooJ2EgZWx0IC0+ICdhIGVsdCAtPiBib29sKSAtPiAoJ2EsICdjbXApIHQgbGlzdCApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgZmluZF9leG4gOiAoJ2EsIF8pIHQgLT4gZjooJ2EgZWx0IC0+IGJvb2wpIC0+ICdhIGVsdFxuICB2YWwgbnRoIDogKCdhLCBfKSB0IC0+IGludCAtPiAnYSBlbHQgb3B0aW9uXG4gIHZhbCByZW1vdmVfaW5kZXggOiAoJ2EsICdjbXAsICgnYSwgJ2NtcCkgdCAtPiBpbnQgLT4gKCdhLCAnY21wKSB0KSBvcHRpb25zXG4gIHZhbCB0b190cmVlIDogKCdhLCAnY21wKSB0IC0+ICgnYSBlbHQsICdjbXApIHRyZWVcblxuICB2YWwgdG9fc2VxdWVuY2VcbiAgICA6ICggJ2FcbiAgICAgICwgJ2NtcFxuICAgICAgLCA/b3JkZXI6WyBgSW5jcmVhc2luZyB8IGBEZWNyZWFzaW5nIF1cbiAgICAgIC0+ID9ncmVhdGVyX29yX2VxdWFsX3RvOidhIGVsdFxuICAgICAgLT4gP2xlc3Nfb3JfZXF1YWxfdG86J2EgZWx0XG4gICAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAgIC0+ICdhIGVsdCBTZXF1ZW5jZS50IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBiaW5hcnlfc2VhcmNoXG4gICAgOiAoICdhXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdhLCAnY21wKSB0XG4gICAgICAtPiBjb21wYXJlOignYSBlbHQgLT4gJ2tleSAtPiBpbnQpXG4gICAgICAtPiBCaW5hcnlfc2VhcmNoYWJsZS5XaGljaF90YXJnZXRfYnlfa2V5LnRcbiAgICAgIC0+ICdrZXlcbiAgICAgIC0+ICdhIGVsdCBvcHRpb24gKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkXG4gICAgOiAoICdhXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdhLCAnY21wKSB0XG4gICAgICAtPiBzZWdtZW50X29mOignYSBlbHQgLT4gWyBgTGVmdCB8IGBSaWdodCBdKVxuICAgICAgLT4gQmluYXJ5X3NlYXJjaGFibGUuV2hpY2hfdGFyZ2V0X2J5X3NlZ21lbnQudFxuICAgICAgLT4gJ2EgZWx0IG9wdGlvbiApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgbWVyZ2VfdG9fc2VxdWVuY2VcbiAgICA6ICggJ2FcbiAgICAgICwgJ2NtcFxuICAgICAgLCA/b3JkZXI6WyBgSW5jcmVhc2luZyB8IGBEZWNyZWFzaW5nIF1cbiAgICAgIC0+ID9ncmVhdGVyX29yX2VxdWFsX3RvOidhIGVsdFxuICAgICAgLT4gP2xlc3Nfb3JfZXF1YWxfdG86J2EgZWx0XG4gICAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgICAgLT4gKCdhIGVsdCwgJ2EgZWx0KSBNZXJnZV90b19zZXF1ZW5jZV9lbGVtZW50LnQgU2VxdWVuY2UudCApXG4gICAgICAgIG9wdGlvbnNcbmVuZFxuXG5tb2R1bGUgdHlwZSBBY2Nlc3NvcnMwID0gc2lnXG4gIGluY2x1ZGUgQ29udGFpbmVyLlMwXG5cbiAgdHlwZSB0cmVlXG4gIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgdmFsIGludmFyaWFudHMgOiB0IC0+IGJvb2xcbiAgdmFsIG1lbSA6IHQgLT4gZWx0IC0+IGJvb2xcbiAgdmFsIGFkZCA6IHQgLT4gZWx0IC0+IHRcbiAgdmFsIHJlbW92ZSA6IHQgLT4gZWx0IC0+IHRcbiAgdmFsIHVuaW9uIDogdCAtPiB0IC0+IHRcbiAgdmFsIGludGVyIDogdCAtPiB0IC0+IHRcbiAgdmFsIGRpZmYgOiB0IC0+IHQgLT4gdFxuICB2YWwgc3ltbWV0cmljX2RpZmYgOiB0IC0+IHQgLT4gKGVsdCwgZWx0KSBFaXRoZXIudCBTZXF1ZW5jZS50XG4gIHZhbCBjb21wYXJlX2RpcmVjdCA6IHQgLT4gdCAtPiBpbnRcbiAgdmFsIGVxdWFsIDogdCAtPiB0IC0+IGJvb2xcbiAgdmFsIGlzX3N1YnNldCA6IHQgLT4gb2ZfOnQgLT4gYm9vbFxuICB2YWwgYXJlX2Rpc2pvaW50IDogdCAtPiB0IC0+IGJvb2xcblxuICB0eXBlIG5hbWVkXG5cbiAgbW9kdWxlIE5hbWVkIDogc2lnXG4gICAgdmFsIGlzX3N1YnNldCA6IG5hbWVkIC0+IG9mXzpuYW1lZCAtPiB1bml0IE9yX2Vycm9yLnRcbiAgICB2YWwgZXF1YWwgOiBuYW1lZCAtPiBuYW1lZCAtPiB1bml0IE9yX2Vycm9yLnRcbiAgZW5kXG5cbiAgdmFsIGZvbGRfdW50aWxcbiAgICA6ICB0XG4gICAgLT4gaW5pdDonYlxuICAgIC0+IGY6KCdiIC0+IGVsdCAtPiAoJ2IsICdmaW5hbCkgQ29udGFpbmVyLkNvbnRpbnVlX29yX3N0b3AudClcbiAgICAtPiBmaW5pc2g6KCdiIC0+ICdmaW5hbClcbiAgICAtPiAnZmluYWxcblxuICB2YWwgZm9sZF9yaWdodCA6IHQgLT4gaW5pdDonYiAtPiBmOihlbHQgLT4gJ2IgLT4gJ2IpIC0+ICdiXG5cbiAgdmFsIGl0ZXIyXG4gICAgOiAgdFxuICAgIC0+IHRcbiAgICAtPiBmOihbIGBMZWZ0IG9mIGVsdCB8IGBSaWdodCBvZiBlbHQgfCBgQm90aCBvZiBlbHQgKiBlbHQgXSAtPiB1bml0KVxuICAgIC0+IHVuaXRcblxuICB2YWwgZmlsdGVyIDogdCAtPiBmOihlbHQgLT4gYm9vbCkgLT4gdFxuICB2YWwgcGFydGl0aW9uX3RmIDogdCAtPiBmOihlbHQgLT4gYm9vbCkgLT4gdCAqIHRcbiAgdmFsIGVsZW1lbnRzIDogdCAtPiBlbHQgbGlzdFxuICB2YWwgbWluX2VsdCA6IHQgLT4gZWx0IG9wdGlvblxuICB2YWwgbWluX2VsdF9leG4gOiB0IC0+IGVsdFxuICB2YWwgbWF4X2VsdCA6IHQgLT4gZWx0IG9wdGlvblxuICB2YWwgbWF4X2VsdF9leG4gOiB0IC0+IGVsdFxuICB2YWwgY2hvb3NlIDogdCAtPiBlbHQgb3B0aW9uXG4gIHZhbCBjaG9vc2VfZXhuIDogdCAtPiBlbHRcbiAgdmFsIHNwbGl0IDogdCAtPiBlbHQgLT4gdCAqIGVsdCBvcHRpb24gKiB0XG4gIHZhbCBncm91cF9ieSA6IHQgLT4gZXF1aXY6KGVsdCAtPiBlbHQgLT4gYm9vbCkgLT4gdCBsaXN0XG4gIHZhbCBmaW5kX2V4biA6IHQgLT4gZjooZWx0IC0+IGJvb2wpIC0+IGVsdFxuICB2YWwgbnRoIDogdCAtPiBpbnQgLT4gZWx0IG9wdGlvblxuICB2YWwgcmVtb3ZlX2luZGV4IDogdCAtPiBpbnQgLT4gdFxuICB2YWwgdG9fdHJlZSA6IHQgLT4gdHJlZVxuXG4gIHZhbCB0b19zZXF1ZW5jZVxuICAgIDogID9vcmRlcjpbIGBJbmNyZWFzaW5nIHwgYERlY3JlYXNpbmcgXVxuICAgIC0+ID9ncmVhdGVyX29yX2VxdWFsX3RvOmVsdFxuICAgIC0+ID9sZXNzX29yX2VxdWFsX3RvOmVsdFxuICAgIC0+IHRcbiAgICAtPiBlbHQgU2VxdWVuY2UudFxuXG4gIHZhbCBiaW5hcnlfc2VhcmNoXG4gICAgOiAgdFxuICAgIC0+IGNvbXBhcmU6KGVsdCAtPiAna2V5IC0+IGludClcbiAgICAtPiBCaW5hcnlfc2VhcmNoYWJsZS5XaGljaF90YXJnZXRfYnlfa2V5LnRcbiAgICAtPiAna2V5XG4gICAgLT4gZWx0IG9wdGlvblxuXG4gIHZhbCBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZFxuICAgIDogIHRcbiAgICAtPiBzZWdtZW50X29mOihlbHQgLT4gWyBgTGVmdCB8IGBSaWdodCBdKVxuICAgIC0+IEJpbmFyeV9zZWFyY2hhYmxlLldoaWNoX3RhcmdldF9ieV9zZWdtZW50LnRcbiAgICAtPiBlbHQgb3B0aW9uXG5cbiAgdmFsIG1lcmdlX3RvX3NlcXVlbmNlXG4gICAgOiAgP29yZGVyOlsgYEluY3JlYXNpbmcgfCBgRGVjcmVhc2luZyBdXG4gICAgLT4gP2dyZWF0ZXJfb3JfZXF1YWxfdG86ZWx0XG4gICAgLT4gP2xlc3Nfb3JfZXF1YWxfdG86ZWx0XG4gICAgLT4gdFxuICAgIC0+IHRcbiAgICAtPiAoZWx0LCBlbHQpIE1lcmdlX3RvX3NlcXVlbmNlX2VsZW1lbnQudCBTZXF1ZW5jZS50XG5lbmRcblxubW9kdWxlIHR5cGUgQWNjZXNzb3JzMSA9IHNpZ1xuICBpbmNsdWRlIENvbnRhaW5lci5TMVxuXG4gIHR5cGUgJ2EgdHJlZVxuICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIHZhbCBpbnZhcmlhbnRzIDogXyB0IC0+IGJvb2xcbiAgdmFsIG1lbSA6ICdhIHQgLT4gJ2EgLT4gYm9vbFxuICB2YWwgYWRkIDogJ2EgdCAtPiAnYSAtPiAnYSB0XG4gIHZhbCByZW1vdmUgOiAnYSB0IC0+ICdhIC0+ICdhIHRcbiAgdmFsIHVuaW9uIDogJ2EgdCAtPiAnYSB0IC0+ICdhIHRcbiAgdmFsIGludGVyIDogJ2EgdCAtPiAnYSB0IC0+ICdhIHRcbiAgdmFsIGRpZmYgOiAnYSB0IC0+ICdhIHQgLT4gJ2EgdFxuICB2YWwgc3ltbWV0cmljX2RpZmYgOiAnYSB0IC0+ICdhIHQgLT4gKCdhLCAnYSkgRWl0aGVyLnQgU2VxdWVuY2UudFxuICB2YWwgY29tcGFyZV9kaXJlY3QgOiAnYSB0IC0+ICdhIHQgLT4gaW50XG4gIHZhbCBlcXVhbCA6ICdhIHQgLT4gJ2EgdCAtPiBib29sXG4gIHZhbCBpc19zdWJzZXQgOiAnYSB0IC0+IG9mXzonYSB0IC0+IGJvb2xcbiAgdmFsIGFyZV9kaXNqb2ludCA6ICdhIHQgLT4gJ2EgdCAtPiBib29sXG5cbiAgdHlwZSAnYSBuYW1lZFxuXG4gIG1vZHVsZSBOYW1lZCA6IHNpZ1xuICAgIHZhbCBpc19zdWJzZXQgOiAnYSBuYW1lZCAtPiBvZl86J2EgbmFtZWQgLT4gdW5pdCBPcl9lcnJvci50XG4gICAgdmFsIGVxdWFsIDogJ2EgbmFtZWQgLT4gJ2EgbmFtZWQgLT4gdW5pdCBPcl9lcnJvci50XG4gIGVuZFxuXG4gIHZhbCBmb2xkX3VudGlsXG4gICAgOiAgJ2EgdFxuICAgIC0+IGluaXQ6J2JcbiAgICAtPiBmOignYiAtPiAnYSAtPiAoJ2IsICdmaW5hbCkgQ29udGFpbmVyLkNvbnRpbnVlX29yX3N0b3AudClcbiAgICAtPiBmaW5pc2g6KCdiIC0+ICdmaW5hbClcbiAgICAtPiAnZmluYWxcblxuICB2YWwgZm9sZF9yaWdodCA6ICdhIHQgLT4gaW5pdDonYiAtPiBmOignYSAtPiAnYiAtPiAnYikgLT4gJ2JcblxuICB2YWwgaXRlcjJcbiAgICA6ICAnYSB0XG4gICAgLT4gJ2EgdFxuICAgIC0+IGY6KFsgYExlZnQgb2YgJ2EgfCBgUmlnaHQgb2YgJ2EgfCBgQm90aCBvZiAnYSAqICdhIF0gLT4gdW5pdClcbiAgICAtPiB1bml0XG5cbiAgdmFsIGZpbHRlciA6ICdhIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gJ2EgdFxuICB2YWwgcGFydGl0aW9uX3RmIDogJ2EgdCAtPiBmOignYSAtPiBib29sKSAtPiAnYSB0ICogJ2EgdFxuICB2YWwgZWxlbWVudHMgOiAnYSB0IC0+ICdhIGxpc3RcbiAgdmFsIG1pbl9lbHQgOiAnYSB0IC0+ICdhIG9wdGlvblxuICB2YWwgbWluX2VsdF9leG4gOiAnYSB0IC0+ICdhXG4gIHZhbCBtYXhfZWx0IDogJ2EgdCAtPiAnYSBvcHRpb25cbiAgdmFsIG1heF9lbHRfZXhuIDogJ2EgdCAtPiAnYVxuICB2YWwgY2hvb3NlIDogJ2EgdCAtPiAnYSBvcHRpb25cbiAgdmFsIGNob29zZV9leG4gOiAnYSB0IC0+ICdhXG4gIHZhbCBzcGxpdCA6ICdhIHQgLT4gJ2EgLT4gJ2EgdCAqICdhIG9wdGlvbiAqICdhIHRcbiAgdmFsIGdyb3VwX2J5IDogJ2EgdCAtPiBlcXVpdjooJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCBsaXN0XG4gIHZhbCBmaW5kX2V4biA6ICdhIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gJ2FcbiAgdmFsIG50aCA6ICdhIHQgLT4gaW50IC0+ICdhIG9wdGlvblxuICB2YWwgcmVtb3ZlX2luZGV4IDogJ2EgdCAtPiBpbnQgLT4gJ2EgdFxuICB2YWwgdG9fdHJlZSA6ICdhIHQgLT4gJ2EgdHJlZVxuXG4gIHZhbCB0b19zZXF1ZW5jZVxuICAgIDogID9vcmRlcjpbIGBJbmNyZWFzaW5nIHwgYERlY3JlYXNpbmcgXVxuICAgIC0+ID9ncmVhdGVyX29yX2VxdWFsX3RvOidhXG4gICAgLT4gP2xlc3Nfb3JfZXF1YWxfdG86J2FcbiAgICAtPiAnYSB0XG4gICAgLT4gJ2EgU2VxdWVuY2UudFxuXG4gIHZhbCBiaW5hcnlfc2VhcmNoXG4gICAgOiAgJ2EgdFxuICAgIC0+IGNvbXBhcmU6KCdhIC0+ICdrZXkgLT4gaW50KVxuICAgIC0+IEJpbmFyeV9zZWFyY2hhYmxlLldoaWNoX3RhcmdldF9ieV9rZXkudFxuICAgIC0+ICdrZXlcbiAgICAtPiAnYSBvcHRpb25cblxuICB2YWwgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWRcbiAgICA6ICAnYSB0XG4gICAgLT4gc2VnbWVudF9vZjooJ2EgLT4gWyBgTGVmdCB8IGBSaWdodCBdKVxuICAgIC0+IEJpbmFyeV9zZWFyY2hhYmxlLldoaWNoX3RhcmdldF9ieV9zZWdtZW50LnRcbiAgICAtPiAnYSBvcHRpb25cblxuICB2YWwgbWVyZ2VfdG9fc2VxdWVuY2VcbiAgICA6ICA/b3JkZXI6WyBgSW5jcmVhc2luZyB8IGBEZWNyZWFzaW5nIF1cbiAgICAtPiA/Z3JlYXRlcl9vcl9lcXVhbF90bzonYVxuICAgIC0+ID9sZXNzX29yX2VxdWFsX3RvOidhXG4gICAgLT4gJ2EgdFxuICAgIC0+ICdhIHRcbiAgICAtPiAoJ2EsICdhKSBNZXJnZV90b19zZXF1ZW5jZV9lbGVtZW50LnQgU2VxdWVuY2UudFxuZW5kXG5cbm1vZHVsZSB0eXBlIEFjY2Vzc29yczIgPSBzaWdcbiAgaW5jbHVkZSBDb250YWluZXIuUzFfcGhhbnRvbV9pbnZhcmlhbnRcblxuICB0eXBlICgnYSwgJ2NtcCkgdHJlZVxuXG4gIHZhbCBpbnZhcmlhbnRzIDogKF8sIF8pIHQgLT4gYm9vbFxuICB2YWwgbWVtIDogKCdhLCBfKSB0IC0+ICdhIC0+IGJvb2xcbiAgdmFsIGFkZCA6ICgnYSwgJ2NtcCkgdCAtPiAnYSAtPiAoJ2EsICdjbXApIHRcbiAgdmFsIHJlbW92ZSA6ICgnYSwgJ2NtcCkgdCAtPiAnYSAtPiAoJ2EsICdjbXApIHRcbiAgdmFsIHVuaW9uIDogKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHRcbiAgdmFsIGludGVyIDogKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHRcbiAgdmFsIGRpZmYgOiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdFxuICB2YWwgc3ltbWV0cmljX2RpZmYgOiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2EpIEVpdGhlci50IFNlcXVlbmNlLnRcbiAgdmFsIGNvbXBhcmVfZGlyZWN0IDogKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdCAtPiBpbnRcbiAgdmFsIGVxdWFsIDogKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdCAtPiBib29sXG4gIHZhbCBpc19zdWJzZXQgOiAoJ2EsICdjbXApIHQgLT4gb2ZfOignYSwgJ2NtcCkgdCAtPiBib29sXG4gIHZhbCBhcmVfZGlzam9pbnQgOiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+IGJvb2xcblxuICB0eXBlICgnYSwgJ2NtcCkgbmFtZWRcblxuICBtb2R1bGUgTmFtZWQgOiBzaWdcbiAgICB2YWwgaXNfc3Vic2V0IDogKCdhLCAnY21wKSBuYW1lZCAtPiBvZl86KCdhLCAnY21wKSBuYW1lZCAtPiB1bml0IE9yX2Vycm9yLnRcbiAgICB2YWwgZXF1YWwgOiAoJ2EsICdjbXApIG5hbWVkIC0+ICgnYSwgJ2NtcCkgbmFtZWQgLT4gdW5pdCBPcl9lcnJvci50XG4gIGVuZFxuXG4gIHZhbCBmb2xkX3VudGlsXG4gICAgOiAgKCdhLCBfKSB0XG4gICAgLT4gaW5pdDonYlxuICAgIC0+IGY6KCdiIC0+ICdhIC0+ICgnYiwgJ2ZpbmFsKSBDb250YWluZXIuQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IGZpbmlzaDooJ2IgLT4gJ2ZpbmFsKVxuICAgIC0+ICdmaW5hbFxuXG4gIHZhbCBmb2xkX3JpZ2h0IDogKCdhLCBfKSB0IC0+IGluaXQ6J2IgLT4gZjooJ2EgLT4gJ2IgLT4gJ2IpIC0+ICdiXG5cbiAgdmFsIGl0ZXIyXG4gICAgOiAgKCdhLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gZjooWyBgTGVmdCBvZiAnYSB8IGBSaWdodCBvZiAnYSB8IGBCb3RoIG9mICdhICogJ2EgXSAtPiB1bml0KVxuICAgIC0+IHVuaXRcblxuICB2YWwgZmlsdGVyIDogKCdhLCAnY21wKSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+ICgnYSwgJ2NtcCkgdFxuICB2YWwgcGFydGl0aW9uX3RmIDogKCdhLCAnY21wKSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+ICgnYSwgJ2NtcCkgdCAqICgnYSwgJ2NtcCkgdFxuICB2YWwgZWxlbWVudHMgOiAoJ2EsIF8pIHQgLT4gJ2EgbGlzdFxuICB2YWwgbWluX2VsdCA6ICgnYSwgXykgdCAtPiAnYSBvcHRpb25cbiAgdmFsIG1pbl9lbHRfZXhuIDogKCdhLCBfKSB0IC0+ICdhXG4gIHZhbCBtYXhfZWx0IDogKCdhLCBfKSB0IC0+ICdhIG9wdGlvblxuICB2YWwgbWF4X2VsdF9leG4gOiAoJ2EsIF8pIHQgLT4gJ2FcbiAgdmFsIGNob29zZSA6ICgnYSwgXykgdCAtPiAnYSBvcHRpb25cbiAgdmFsIGNob29zZV9leG4gOiAoJ2EsIF8pIHQgLT4gJ2FcbiAgdmFsIHNwbGl0IDogKCdhLCAnY21wKSB0IC0+ICdhIC0+ICgnYSwgJ2NtcCkgdCAqICdhIG9wdGlvbiAqICgnYSwgJ2NtcCkgdFxuICB2YWwgZ3JvdXBfYnkgOiAoJ2EsICdjbXApIHQgLT4gZXF1aXY6KCdhIC0+ICdhIC0+IGJvb2wpIC0+ICgnYSwgJ2NtcCkgdCBsaXN0XG4gIHZhbCBmaW5kX2V4biA6ICgnYSwgXykgdCAtPiBmOignYSAtPiBib29sKSAtPiAnYVxuICB2YWwgbnRoIDogKCdhLCBfKSB0IC0+IGludCAtPiAnYSBvcHRpb25cbiAgdmFsIHJlbW92ZV9pbmRleCA6ICgnYSwgJ2NtcCkgdCAtPiBpbnQgLT4gKCdhLCAnY21wKSB0XG4gIHZhbCB0b190cmVlIDogKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdHJlZVxuXG4gIHZhbCB0b19zZXF1ZW5jZVxuICAgIDogID9vcmRlcjpbIGBJbmNyZWFzaW5nIHwgYERlY3JlYXNpbmcgXVxuICAgIC0+ID9ncmVhdGVyX29yX2VxdWFsX3RvOidhXG4gICAgLT4gP2xlc3Nfb3JfZXF1YWxfdG86J2FcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiAnYSBTZXF1ZW5jZS50XG5cbiAgdmFsIGJpbmFyeV9zZWFyY2hcbiAgICA6ICAoJ2EsICdjbXApIHRcbiAgICAtPiBjb21wYXJlOignYSAtPiAna2V5IC0+IGludClcbiAgICAtPiBCaW5hcnlfc2VhcmNoYWJsZS5XaGljaF90YXJnZXRfYnlfa2V5LnRcbiAgICAtPiAna2V5XG4gICAgLT4gJ2Egb3B0aW9uXG5cbiAgdmFsIGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkXG4gICAgOiAgKCdhLCAnY21wKSB0XG4gICAgLT4gc2VnbWVudF9vZjooJ2EgLT4gWyBgTGVmdCB8IGBSaWdodCBdKVxuICAgIC0+IEJpbmFyeV9zZWFyY2hhYmxlLldoaWNoX3RhcmdldF9ieV9zZWdtZW50LnRcbiAgICAtPiAnYSBvcHRpb25cblxuICB2YWwgbWVyZ2VfdG9fc2VxdWVuY2VcbiAgICA6ICA/b3JkZXI6WyBgSW5jcmVhc2luZyB8IGBEZWNyZWFzaW5nIF1cbiAgICAtPiA/Z3JlYXRlcl9vcl9lcXVhbF90bzonYVxuICAgIC0+ID9sZXNzX29yX2VxdWFsX3RvOidhXG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnYSkgTWVyZ2VfdG9fc2VxdWVuY2VfZWxlbWVudC50IFNlcXVlbmNlLnRcbmVuZFxuXG5tb2R1bGUgdHlwZSBBY2Nlc3NvcnMyX3dpdGhfY29tcGFyYXRvciA9IHNpZ1xuICBpbmNsdWRlIENvbnRhaW5lci5TMV9waGFudG9tX2ludmFyaWFudFxuXG4gIHR5cGUgKCdhLCAnY21wKSB0cmVlXG5cbiAgdmFsIGludmFyaWFudHMgOiBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50IC0+ICgnYSwgJ2NtcCkgdCAtPiBib29sXG4gIHZhbCBtZW0gOiBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50IC0+ICgnYSwgJ2NtcCkgdCAtPiAnYSAtPiBib29sXG4gIHZhbCBhZGQgOiBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50IC0+ICgnYSwgJ2NtcCkgdCAtPiAnYSAtPiAoJ2EsICdjbXApIHRcbiAgdmFsIHJlbW92ZSA6IGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnQgLT4gKCdhLCAnY21wKSB0IC0+ICdhIC0+ICgnYSwgJ2NtcCkgdFxuXG4gIHZhbCB1bmlvblxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiAoJ2EsICdjbXApIHRcblxuICB2YWwgaW50ZXJcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnY21wKSB0XG5cbiAgdmFsIGRpZmZcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnY21wKSB0XG5cbiAgdmFsIHN5bW1ldHJpY19kaWZmXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+ICgnYSwgJ2EpIEVpdGhlci50IFNlcXVlbmNlLnRcblxuICB2YWwgY29tcGFyZV9kaXJlY3RcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gaW50XG5cbiAgdmFsIGVxdWFsIDogY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudCAtPiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+IGJvb2xcblxuICB2YWwgaXNfc3Vic2V0XG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+IG9mXzooJ2EsICdjbXApIHRcbiAgICAtPiBib29sXG5cbiAgdmFsIGFyZV9kaXNqb2ludFxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiBib29sXG5cbiAgdHlwZSAoJ2EsICdjbXApIG5hbWVkXG5cbiAgbW9kdWxlIE5hbWVkIDogc2lnXG4gICAgdmFsIGlzX3N1YnNldFxuICAgICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgICAgLT4gKCdhLCAnY21wKSBuYW1lZFxuICAgICAgLT4gb2ZfOignYSwgJ2NtcCkgbmFtZWRcbiAgICAgIC0+IHVuaXQgT3JfZXJyb3IudFxuXG4gICAgdmFsIGVxdWFsXG4gICAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgICAtPiAoJ2EsICdjbXApIG5hbWVkXG4gICAgICAtPiAoJ2EsICdjbXApIG5hbWVkXG4gICAgICAtPiB1bml0IE9yX2Vycm9yLnRcbiAgZW5kXG5cbiAgdmFsIGZvbGRfdW50aWxcbiAgICA6ICAoJ2EsIF8pIHRcbiAgICAtPiBpbml0OidhY2N1bVxuICAgIC0+IGY6KCdhY2N1bSAtPiAnYSAtPiAoJ2FjY3VtLCAnZmluYWwpIENvbnRhaW5lci5Db250aW51ZV9vcl9zdG9wLnQpXG4gICAgLT4gZmluaXNoOignYWNjdW0gLT4gJ2ZpbmFsKVxuICAgIC0+ICdmaW5hbFxuXG4gIHZhbCBmb2xkX3JpZ2h0IDogKCdhLCBfKSB0IC0+IGluaXQ6J2FjY3VtIC0+IGY6KCdhIC0+ICdhY2N1bSAtPiAnYWNjdW0pIC0+ICdhY2N1bVxuXG4gIHZhbCBpdGVyMlxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiBmOihbIGBMZWZ0IG9mICdhIHwgYFJpZ2h0IG9mICdhIHwgYEJvdGggb2YgJ2EgKiAnYSBdIC0+IHVuaXQpXG4gICAgLT4gdW5pdFxuXG4gIHZhbCBmaWx0ZXJcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gZjooJ2EgLT4gYm9vbClcbiAgICAtPiAoJ2EsICdjbXApIHRcblxuICB2YWwgcGFydGl0aW9uX3RmXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+IGY6KCdhIC0+IGJvb2wpXG4gICAgLT4gKCdhLCAnY21wKSB0ICogKCdhLCAnY21wKSB0XG5cbiAgdmFsIGVsZW1lbnRzIDogKCdhLCBfKSB0IC0+ICdhIGxpc3RcbiAgdmFsIG1pbl9lbHQgOiAoJ2EsIF8pIHQgLT4gJ2Egb3B0aW9uXG4gIHZhbCBtaW5fZWx0X2V4biA6ICgnYSwgXykgdCAtPiAnYVxuICB2YWwgbWF4X2VsdCA6ICgnYSwgXykgdCAtPiAnYSBvcHRpb25cbiAgdmFsIG1heF9lbHRfZXhuIDogKCdhLCBfKSB0IC0+ICdhXG4gIHZhbCBjaG9vc2UgOiAoJ2EsIF8pIHQgLT4gJ2Egb3B0aW9uXG4gIHZhbCBjaG9vc2VfZXhuIDogKCdhLCBfKSB0IC0+ICdhXG5cbiAgdmFsIHNwbGl0XG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+ICdhXG4gICAgLT4gKCdhLCAnY21wKSB0ICogJ2Egb3B0aW9uICogKCdhLCAnY21wKSB0XG5cbiAgdmFsIGdyb3VwX2J5XG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+IGVxdWl2OignYSAtPiAnYSAtPiBib29sKVxuICAgIC0+ICgnYSwgJ2NtcCkgdCBsaXN0XG5cbiAgdmFsIGZpbmRfZXhuIDogKCdhLCBfKSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+ICdhXG4gIHZhbCBudGggOiAoJ2EsIF8pIHQgLT4gaW50IC0+ICdhIG9wdGlvblxuXG4gIHZhbCByZW1vdmVfaW5kZXhcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gaW50XG4gICAgLT4gKCdhLCAnY21wKSB0XG5cbiAgdmFsIHRvX3RyZWUgOiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0cmVlXG5cbiAgdmFsIHRvX3NlcXVlbmNlXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ID9vcmRlcjpbIGBJbmNyZWFzaW5nIHwgYERlY3JlYXNpbmcgXVxuICAgIC0+ID9ncmVhdGVyX29yX2VxdWFsX3RvOidhXG4gICAgLT4gP2xlc3Nfb3JfZXF1YWxfdG86J2FcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiAnYSBTZXF1ZW5jZS50XG5cbiAgdmFsIGJpbmFyeV9zZWFyY2hcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gY29tcGFyZTooJ2EgLT4gJ2tleSAtPiBpbnQpXG4gICAgLT4gQmluYXJ5X3NlYXJjaGFibGUuV2hpY2hfdGFyZ2V0X2J5X2tleS50XG4gICAgLT4gJ2tleVxuICAgIC0+ICdhIG9wdGlvblxuXG4gIHZhbCBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZFxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiBzZWdtZW50X29mOignYSAtPiBbIGBMZWZ0IHwgYFJpZ2h0IF0pXG4gICAgLT4gQmluYXJ5X3NlYXJjaGFibGUuV2hpY2hfdGFyZ2V0X2J5X3NlZ21lbnQudFxuICAgIC0+ICdhIG9wdGlvblxuXG4gIHZhbCBtZXJnZV90b19zZXF1ZW5jZVxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiA/b3JkZXI6WyBgSW5jcmVhc2luZyB8IGBEZWNyZWFzaW5nIF1cbiAgICAtPiA/Z3JlYXRlcl9vcl9lcXVhbF90bzonYVxuICAgIC0+ID9sZXNzX29yX2VxdWFsX3RvOidhXG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnYSkgTWVyZ2VfdG9fc2VxdWVuY2VfZWxlbWVudC50IFNlcXVlbmNlLnRcbmVuZFxuXG4oKiogQ29uc2lzdGVuY3kgY2hlY2tzIChzYW1lIGFzIGluIFtDb250YWluZXJdKS4gKilcbm1vZHVsZSBDaGVja19hY2Nlc3NvcnNcbiAgICAoVCA6IFQyKVxuICAgIChUcmVlIDogVDIpXG4gICAgKEVsdCA6IFQxKVxuICAgIChOYW1lZCA6IFQyKVxuICAgIChDbXAgOiBUMSlcbiAgICAoT3B0aW9ucyA6IFQzKVxuICAgIChfIDogQWNjZXNzb3JzX2dlbmVyaWNcbiAgICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSBvcHRpb25zIDo9ICgnYSwgJ2IsICdjKSBPcHRpb25zLnRcbiAgICAgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgVC50XG4gICAgIHdpdGggdHlwZSAoJ2EsICdiKSB0cmVlIDo9ICgnYSwgJ2IpIFRyZWUudFxuICAgICB3aXRoIHR5cGUgJ2EgZWx0IDo9ICdhIEVsdC50XG4gICAgIHdpdGggdHlwZSAnY21wIGNtcCA6PSAnY21wIENtcC50XG4gICAgIHdpdGggdHlwZSAoJ2EsICdiKSBuYW1lZCA6PSAoJ2EsICdiKSBOYW1lZC50KSA9XG5zdHJ1Y3QgZW5kXG5cbm1vZHVsZSBDaGVja19hY2Nlc3NvcnMwIChNIDogQWNjZXNzb3JzMCkgPVxuICBDaGVja19hY2Nlc3NvcnNcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IpIHQgPSBNLnRcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiKSB0ID0gTS50cmVlXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9IE0uZWx0XG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYikgdCA9IE0ubmFtZWRcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gTS5jb21wYXJhdG9yX3dpdG5lc3NcbiAgICBlbmQpXG4gICAgKFdpdGhvdXRfY29tcGFyYXRvcilcbiAgICAoTSlcblxubW9kdWxlIENoZWNrX2FjY2Vzc29yczEgKE0gOiBBY2Nlc3NvcnMxKSA9XG4gIENoZWNrX2FjY2Vzc29yc1xuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYikgdCA9ICdhIE0udFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IpIHQgPSAnYSBNLnRyZWVcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gJ2FcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiKSB0ID0gJ2EgTS5uYW1lZFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSBNLmNvbXBhcmF0b3Jfd2l0bmVzc1xuICAgIGVuZClcbiAgICAoV2l0aG91dF9jb21wYXJhdG9yKVxuICAgIChNKVxuXG5tb2R1bGUgQ2hlY2tfYWNjZXNzb3JzMiAoTSA6IEFjY2Vzc29yczIpID1cbiAgQ2hlY2tfYWNjZXNzb3JzXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiKSB0ID0gKCdhLCAnYikgTS50XG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYikgdCA9ICgnYSwgJ2IpIE0udHJlZVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IpIHQgPSAoJ2EsICdiKSBNLm5hbWVkXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9ICdhXG4gICAgZW5kKVxuICAgIChXaXRob3V0X2NvbXBhcmF0b3IpXG4gICAgKE0pXG5cbm1vZHVsZSBDaGVja19hY2Nlc3NvcnMyX3dpdGhfY29tcGFyYXRvciAoTSA6IEFjY2Vzc29yczJfd2l0aF9jb21wYXJhdG9yKSA9XG4gIENoZWNrX2FjY2Vzc29yc1xuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYikgdCA9ICgnYSwgJ2IpIE0udFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IpIHQgPSAoJ2EsICdiKSBNLnRyZWVcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gJ2FcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiKSB0ID0gKCdhLCAnYikgTS5uYW1lZFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYVxuICAgIGVuZClcbiAgICAoV2l0aF9jb21wYXJhdG9yKVxuICAgIChNKVxuXG5tb2R1bGUgdHlwZSBDcmVhdG9yc19nZW5lcmljID0gc2lnXG4gIHR5cGUgKCdhLCAnY21wKSB0XG4gIHR5cGUgKCdhLCAnY21wKSBzZXRcbiAgdHlwZSAoJ2EsICdjbXApIHRyZWVcbiAgdHlwZSAnYSBlbHRcbiAgdHlwZSAoJ2EsICdjbXAsICd6KSBvcHRpb25zXG4gIHR5cGUgJ2NtcCBjbXBcblxuICB2YWwgZW1wdHkgOiAoJ2EsICdjbXAsICgnYSwgJ2NtcCkgdCkgb3B0aW9uc1xuICB2YWwgc2luZ2xldG9uIDogKCdhLCAnY21wLCAnYSBlbHQgLT4gKCdhLCAnY21wKSB0KSBvcHRpb25zXG4gIHZhbCB1bmlvbl9saXN0IDogKCdhLCAnY21wLCAoJ2EsICdjbXApIHQgbGlzdCAtPiAoJ2EsICdjbXApIHQpIG9wdGlvbnNcbiAgdmFsIG9mX2xpc3QgOiAoJ2EsICdjbXAsICdhIGVsdCBsaXN0IC0+ICgnYSwgJ2NtcCkgdCkgb3B0aW9uc1xuICB2YWwgb2Zfc2VxdWVuY2UgOiAoJ2EsICdjbXAsICdhIGVsdCBTZXF1ZW5jZS50IC0+ICgnYSwgJ2NtcCkgdCkgb3B0aW9uc1xuICB2YWwgb2ZfYXJyYXkgOiAoJ2EsICdjbXAsICdhIGVsdCBhcnJheSAtPiAoJ2EsICdjbXApIHQpIG9wdGlvbnNcbiAgdmFsIG9mX3NvcnRlZF9hcnJheSA6ICgnYSwgJ2NtcCwgJ2EgZWx0IGFycmF5IC0+ICgnYSwgJ2NtcCkgdCBPcl9lcnJvci50KSBvcHRpb25zXG4gIHZhbCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIDogKCdhLCAnY21wLCAnYSBlbHQgYXJyYXkgLT4gKCdhLCAnY21wKSB0KSBvcHRpb25zXG5cbiAgdmFsIG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkXG4gICAgOiAoJ2EsICdjbXAsIGxlbjppbnQgLT4gZjooaW50IC0+ICdhIGVsdCkgLT4gKCdhLCAnY21wKSB0KSBvcHRpb25zXG5cbiAgdmFsIHN0YWJsZV9kZWR1cF9saXN0IDogKCdhLCBfLCAnYSBlbHQgbGlzdCAtPiAnYSBlbHQgbGlzdCkgb3B0aW9uc1xuXG4gICgqKiBUaGUgdHlwZXMgb2YgW21hcF0gYW5kIFtmaWx0ZXJfbWFwXSBhcmUgc3VidGxlLiAgVGhlIGlucHV0IHNldCwgWygnYSwgXykgc2V0XSxcbiAgICAgIHJlZmxlY3RzIHRoZSBmYWN0IHRoYXQgdGhlc2UgZnVuY3Rpb25zIHRha2UgYSBzZXQgb2YgKmFueSogdHlwZSwgd2l0aCBhbnlcbiAgICAgIGNvbXBhcmF0b3IsIHdoaWxlIHRoZSBvdXRwdXQgc2V0LCBbKCdiLCAnY21wKSB0XSwgcmVmbGVjdHMgdGhhdCB0aGUgb3V0cHV0IHNldCBoYXNcbiAgICAgIHRoZSBwYXJ0aWN1bGFyIFsnY21wXSBvZiB0aGUgY3JlYXRpb24gZnVuY3Rpb24uICBUaGUgY29tcGFyYXRvciBjYW4gY29tZSBpbiBvbmUgb2ZcbiAgICAgIHRocmVlIHdheXMsIGRlcGVuZGluZyBvbiB3aGljaCBzZXQgbW9kdWxlIGlzIHVzZWRcblxuICAgICAgLSBbU2V0Lm1hcF0gLS0gY29tcGFyYXRvciBjb21lcyBhcyBhbiBhcmd1bWVudFxuICAgICAgLSBbU2V0LlBvbHkubWFwXSAtLSBjb21wYXJhdG9yIGlzIHBvbHltb3JwaGljIGNvbXBhcmlzb25cbiAgICAgIC0gW0Zvby5TZXQubWFwXSAtLSBjb21wYXJhdG9yIGlzIFtGb28uY29tcGFyYXRvcl0gKilcbiAgdmFsIG1hcCA6ICgnYiwgJ2NtcCwgKCdhLCBfKSBzZXQgLT4gZjooJ2EgLT4gJ2IgZWx0KSAtPiAoJ2IsICdjbXApIHQpIG9wdGlvbnNcblxuICB2YWwgZmlsdGVyX21hcFxuICAgIDogKCdiLCAnY21wLCAoJ2EsIF8pIHNldCAtPiBmOignYSAtPiAnYiBlbHQgb3B0aW9uKSAtPiAoJ2IsICdjbXApIHQpIG9wdGlvbnNcblxuICB2YWwgb2ZfdHJlZSA6ICgnYSwgJ2NtcCwgKCdhIGVsdCwgJ2NtcCkgdHJlZSAtPiAoJ2EsICdjbXApIHQpIG9wdGlvbnNcbmVuZFxuXG5tb2R1bGUgdHlwZSBDcmVhdG9yczAgPSBzaWdcbiAgdHlwZSAoJ2EsICdjbXApIHNldFxuICB0eXBlIHRcbiAgdHlwZSB0cmVlXG4gIHR5cGUgZWx0XG4gIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgdmFsIGVtcHR5IDogdFxuICB2YWwgc2luZ2xldG9uIDogZWx0IC0+IHRcbiAgdmFsIHVuaW9uX2xpc3QgOiB0IGxpc3QgLT4gdFxuICB2YWwgb2ZfbGlzdCA6IGVsdCBsaXN0IC0+IHRcbiAgdmFsIG9mX3NlcXVlbmNlIDogZWx0IFNlcXVlbmNlLnQgLT4gdFxuICB2YWwgb2ZfYXJyYXkgOiBlbHQgYXJyYXkgLT4gdFxuICB2YWwgb2Zfc29ydGVkX2FycmF5IDogZWx0IGFycmF5IC0+IHQgT3JfZXJyb3IudFxuICB2YWwgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCA6IGVsdCBhcnJheSAtPiB0XG4gIHZhbCBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCA6IGxlbjppbnQgLT4gZjooaW50IC0+IGVsdCkgLT4gdFxuICB2YWwgc3RhYmxlX2RlZHVwX2xpc3QgOiBlbHQgbGlzdCAtPiBlbHQgbGlzdFxuICB2YWwgbWFwIDogKCdhLCBfKSBzZXQgLT4gZjooJ2EgLT4gZWx0KSAtPiB0XG4gIHZhbCBmaWx0ZXJfbWFwIDogKCdhLCBfKSBzZXQgLT4gZjooJ2EgLT4gZWx0IG9wdGlvbikgLT4gdFxuICB2YWwgb2ZfdHJlZSA6IHRyZWUgLT4gdFxuZW5kXG5cbm1vZHVsZSB0eXBlIENyZWF0b3JzMSA9IHNpZ1xuICB0eXBlICgnYSwgJ2NtcCkgc2V0XG4gIHR5cGUgJ2EgdFxuICB0eXBlICdhIHRyZWVcbiAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3NcblxuICB2YWwgZW1wdHkgOiAnYSB0XG4gIHZhbCBzaW5nbGV0b24gOiAnYSAtPiAnYSB0XG4gIHZhbCB1bmlvbl9saXN0IDogJ2EgdCBsaXN0IC0+ICdhIHRcbiAgdmFsIG9mX2xpc3QgOiAnYSBsaXN0IC0+ICdhIHRcbiAgdmFsIG9mX3NlcXVlbmNlIDogJ2EgU2VxdWVuY2UudCAtPiAnYSB0XG4gIHZhbCBvZl9hcnJheSA6ICdhIGFycmF5IC0+ICdhIHRcbiAgdmFsIG9mX3NvcnRlZF9hcnJheSA6ICdhIGFycmF5IC0+ICdhIHQgT3JfZXJyb3IudFxuICB2YWwgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCA6ICdhIGFycmF5IC0+ICdhIHRcbiAgdmFsIG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIDogbGVuOmludCAtPiBmOihpbnQgLT4gJ2EpIC0+ICdhIHRcbiAgdmFsIHN0YWJsZV9kZWR1cF9saXN0IDogJ2EgbGlzdCAtPiAnYSBsaXN0XG4gIHZhbCBtYXAgOiAoJ2EsIF8pIHNldCAtPiBmOignYSAtPiAnYikgLT4gJ2IgdFxuICB2YWwgZmlsdGVyX21hcCA6ICgnYSwgXykgc2V0IC0+IGY6KCdhIC0+ICdiIG9wdGlvbikgLT4gJ2IgdFxuICB2YWwgb2ZfdHJlZSA6ICdhIHRyZWUgLT4gJ2EgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIENyZWF0b3JzMiA9IHNpZ1xuICB0eXBlICgnYSwgJ2NtcCkgc2V0XG4gIHR5cGUgKCdhLCAnY21wKSB0XG4gIHR5cGUgKCdhLCAnY21wKSB0cmVlXG5cbiAgdmFsIGVtcHR5IDogKCdhLCAnY21wKSB0XG4gIHZhbCBzaW5nbGV0b24gOiAnYSAtPiAoJ2EsICdjbXApIHRcbiAgdmFsIHVuaW9uX2xpc3QgOiAoJ2EsICdjbXApIHQgbGlzdCAtPiAoJ2EsICdjbXApIHRcbiAgdmFsIG9mX2xpc3QgOiAnYSBsaXN0IC0+ICgnYSwgJ2NtcCkgdFxuICB2YWwgb2Zfc2VxdWVuY2UgOiAnYSBTZXF1ZW5jZS50IC0+ICgnYSwgJ2NtcCkgdFxuICB2YWwgb2ZfYXJyYXkgOiAnYSBhcnJheSAtPiAoJ2EsICdjbXApIHRcbiAgdmFsIG9mX3NvcnRlZF9hcnJheSA6ICdhIGFycmF5IC0+ICgnYSwgJ2NtcCkgdCBPcl9lcnJvci50XG4gIHZhbCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIDogJ2EgYXJyYXkgLT4gKCdhLCAnY21wKSB0XG4gIHZhbCBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCA6IGxlbjppbnQgLT4gZjooaW50IC0+ICdhKSAtPiAoJ2EsICdjbXApIHRcbiAgdmFsIHN0YWJsZV9kZWR1cF9saXN0IDogJ2EgbGlzdCAtPiAnYSBsaXN0XG4gIHZhbCBtYXAgOiAoJ2EsIF8pIHNldCAtPiBmOignYSAtPiAnYikgLT4gKCdiLCAnY21wKSB0XG4gIHZhbCBmaWx0ZXJfbWFwIDogKCdhLCBfKSBzZXQgLT4gZjooJ2EgLT4gJ2Igb3B0aW9uKSAtPiAoJ2IsICdjbXApIHRcbiAgdmFsIG9mX3RyZWUgOiAoJ2EsICdjbXApIHRyZWUgLT4gKCdhLCAnY21wKSB0XG5lbmRcblxubW9kdWxlIHR5cGUgQ3JlYXRvcnMyX3dpdGhfY29tcGFyYXRvciA9IHNpZ1xuICB0eXBlICgnYSwgJ2NtcCkgc2V0XG4gIHR5cGUgKCdhLCAnY21wKSB0XG4gIHR5cGUgKCdhLCAnY21wKSB0cmVlXG5cbiAgdmFsIGVtcHR5IDogY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudCAtPiAoJ2EsICdjbXApIHRcbiAgdmFsIHNpbmdsZXRvbiA6IGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnQgLT4gJ2EgLT4gKCdhLCAnY21wKSB0XG4gIHZhbCB1bmlvbl9saXN0IDogY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudCAtPiAoJ2EsICdjbXApIHQgbGlzdCAtPiAoJ2EsICdjbXApIHRcbiAgdmFsIG9mX2xpc3QgOiBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50IC0+ICdhIGxpc3QgLT4gKCdhLCAnY21wKSB0XG4gIHZhbCBvZl9zZXF1ZW5jZSA6IGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnQgLT4gJ2EgU2VxdWVuY2UudCAtPiAoJ2EsICdjbXApIHRcbiAgdmFsIG9mX2FycmF5IDogY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudCAtPiAnYSBhcnJheSAtPiAoJ2EsICdjbXApIHRcblxuICB2YWwgb2Zfc29ydGVkX2FycmF5XG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICdhIGFycmF5XG4gICAgLT4gKCdhLCAnY21wKSB0IE9yX2Vycm9yLnRcblxuICB2YWwgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZFxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAnYSBhcnJheVxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuXG4gIHZhbCBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZFxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiBsZW46aW50XG4gICAgLT4gZjooaW50IC0+ICdhKVxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuXG4gIHZhbCBzdGFibGVfZGVkdXBfbGlzdCA6IGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnQgLT4gJ2EgbGlzdCAtPiAnYSBsaXN0XG5cbiAgdmFsIG1hcFxuICAgIDogIGNvbXBhcmF0b3I6KCdiLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsIF8pIHNldFxuICAgIC0+IGY6KCdhIC0+ICdiKVxuICAgIC0+ICgnYiwgJ2NtcCkgdFxuXG4gIHZhbCBmaWx0ZXJfbWFwXG4gICAgOiAgY29tcGFyYXRvcjooJ2IsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgXykgc2V0XG4gICAgLT4gZjooJ2EgLT4gJ2Igb3B0aW9uKVxuICAgIC0+ICgnYiwgJ2NtcCkgdFxuXG4gIHZhbCBvZl90cmVlIDogY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudCAtPiAoJ2EsICdjbXApIHRyZWUgLT4gKCdhLCAnY21wKSB0XG5lbmRcblxubW9kdWxlIENoZWNrX2NyZWF0b3JzXG4gICAgKFQgOiBUMilcbiAgICAoVHJlZSA6IFQyKVxuICAgIChFbHQgOiBUMSlcbiAgICAoQ21wIDogVDEpXG4gICAgKE9wdGlvbnMgOiBUMylcbiAgICAoXyA6IENyZWF0b3JzX2dlbmVyaWNcbiAgICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSBvcHRpb25zIDo9ICgnYSwgJ2IsICdjKSBPcHRpb25zLnRcbiAgICAgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgVC50XG4gICAgIHdpdGggdHlwZSAoJ2EsICdiKSB0cmVlIDo9ICgnYSwgJ2IpIFRyZWUudFxuICAgICB3aXRoIHR5cGUgJ2EgZWx0IDo9ICdhIEVsdC50XG4gICAgIHdpdGggdHlwZSAnY21wIGNtcCA6PSAnY21wIENtcC50KSA9XG5zdHJ1Y3QgZW5kXG5cbm1vZHVsZSBDaGVja19jcmVhdG9yczAgKE0gOiBDcmVhdG9yczApID1cbiAgQ2hlY2tfY3JlYXRvcnNcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IpIHQgPSBNLnRcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiKSB0ID0gTS50cmVlXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9IE0uZWx0XG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2NtcCB0ID0gTS5jb21wYXJhdG9yX3dpdG5lc3NcbiAgICBlbmQpXG4gICAgKFdpdGhvdXRfY29tcGFyYXRvcilcbiAgICAoTSlcblxubW9kdWxlIENoZWNrX2NyZWF0b3JzMSAoTSA6IENyZWF0b3JzMSkgPVxuICBDaGVja19jcmVhdG9yc1xuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYikgdCA9ICdhIE0udFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IpIHQgPSAnYSBNLnRyZWVcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gJ2FcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnY21wIHQgPSBNLmNvbXBhcmF0b3Jfd2l0bmVzc1xuICAgIGVuZClcbiAgICAoV2l0aG91dF9jb21wYXJhdG9yKVxuICAgIChNKVxuXG5tb2R1bGUgQ2hlY2tfY3JlYXRvcnMyIChNIDogQ3JlYXRvcnMyKSA9XG4gIENoZWNrX2NyZWF0b3JzXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiKSB0ID0gKCdhLCAnYikgTS50XG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYikgdCA9ICgnYSwgJ2IpIE0udHJlZVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdjbXAgdCA9ICdjbXBcbiAgICBlbmQpXG4gICAgKFdpdGhvdXRfY29tcGFyYXRvcilcbiAgICAoTSlcblxubW9kdWxlIENoZWNrX2NyZWF0b3JzMl93aXRoX2NvbXBhcmF0b3IgKE0gOiBDcmVhdG9yczJfd2l0aF9jb21wYXJhdG9yKSA9XG4gIENoZWNrX2NyZWF0b3JzXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiKSB0ID0gKCdhLCAnYikgTS50XG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYikgdCA9ICgnYSwgJ2IpIE0udHJlZVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdjbXAgdCA9ICdjbXBcbiAgICBlbmQpXG4gICAgKFdpdGhfY29tcGFyYXRvcilcbiAgICAoTSlcblxubW9kdWxlIHR5cGUgQ3JlYXRvcnNfYW5kX2FjY2Vzc29yc19nZW5lcmljID0gc2lnXG4gIGluY2x1ZGUgQWNjZXNzb3JzX2dlbmVyaWNcblxuICBpbmNsdWRlXG4gICAgQ3JlYXRvcnNfZ2VuZXJpY1xuICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgb3B0aW9ucyA6PSAoJ2EsICdiLCAnYykgb3B0aW9uc1xuICAgIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHRcbiAgICB3aXRoIHR5cGUgKCdhLCAnYikgdHJlZSA6PSAoJ2EsICdiKSB0cmVlXG4gICAgd2l0aCB0eXBlICdhIGVsdCA6PSAnYSBlbHRcbiAgICB3aXRoIHR5cGUgJ2NtcCBjbXAgOj0gJ2NtcCBjbXBcbmVuZFxuXG5tb2R1bGUgdHlwZSBDcmVhdG9yc19hbmRfYWNjZXNzb3JzMCA9IHNpZ1xuICBpbmNsdWRlIEFjY2Vzc29yczBcblxuICBpbmNsdWRlXG4gICAgQ3JlYXRvcnMwXG4gICAgd2l0aCB0eXBlIHQgOj0gdFxuICAgIHdpdGggdHlwZSB0cmVlIDo9IHRyZWVcbiAgICB3aXRoIHR5cGUgZWx0IDo9IGVsdFxuICAgIHdpdGggdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgOj0gY29tcGFyYXRvcl93aXRuZXNzXG5lbmRcblxubW9kdWxlIHR5cGUgQ3JlYXRvcnNfYW5kX2FjY2Vzc29yczEgPSBzaWdcbiAgaW5jbHVkZSBBY2Nlc3NvcnMxXG5cbiAgaW5jbHVkZVxuICAgIENyZWF0b3JzMVxuICAgIHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcbiAgICB3aXRoIHR5cGUgJ2EgdHJlZSA6PSAnYSB0cmVlXG4gICAgd2l0aCB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA6PSBjb21wYXJhdG9yX3dpdG5lc3NcbmVuZFxuXG5tb2R1bGUgdHlwZSBDcmVhdG9yc19hbmRfYWNjZXNzb3JzMiA9IHNpZ1xuICBpbmNsdWRlIEFjY2Vzc29yczJcblxuICBpbmNsdWRlXG4gICAgQ3JlYXRvcnMyIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHQgd2l0aCB0eXBlICgnYSwgJ2IpIHRyZWUgOj0gKCdhLCAnYikgdHJlZVxuZW5kXG5cbm1vZHVsZSB0eXBlIENyZWF0b3JzX2FuZF9hY2Nlc3NvcnMyX3dpdGhfY29tcGFyYXRvciA9IHNpZ1xuICBpbmNsdWRlIEFjY2Vzc29yczJfd2l0aF9jb21wYXJhdG9yXG5cbiAgaW5jbHVkZVxuICAgIENyZWF0b3JzMl93aXRoX2NvbXBhcmF0b3JcbiAgICB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0XG4gICAgd2l0aCB0eXBlICgnYSwgJ2IpIHRyZWUgOj0gKCdhLCAnYikgdHJlZVxuZW5kXG5cbm1vZHVsZSB0eXBlIFNfcG9seSA9IENyZWF0b3JzX2FuZF9hY2Nlc3NvcnMxXG5cbm1vZHVsZSB0eXBlIEZvcl9kZXJpdmluZyA9IHNpZ1xuICB0eXBlICgnYSwgJ2IpIHRcblxuICBtb2R1bGUgdHlwZSBTZXhwX29mX20gPSBzaWdcbiAgICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgICB2YWwgc2V4cF9vZl90IDogdCAtPiBTZXhwbGliMC5TZXhwLnRcblxuICAgIFtAQEBlbmRdXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIE1fb2Zfc2V4cCA9IHNpZ1xuICAgIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgb2Zfc2V4cF1cblxuICAgIHZhbCB0X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdFxuXG4gICAgW0BAQGVuZF1cblxuICAgIGluY2x1ZGUgQ29tcGFyYXRvci5TIHdpdGggdHlwZSB0IDo9IHRcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgTV9zZXhwX2dyYW1tYXIgPSBzaWdcbiAgICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfZ3JhbW1hcl1cblxuICAgIHZhbCB0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcblxuICAgIFtAQEBlbmRdXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIENvbXBhcmVfbSA9IHNpZyBlbmRcbiAgbW9kdWxlIHR5cGUgRXF1YWxfbSA9IHNpZyBlbmRcbiAgbW9kdWxlIHR5cGUgSGFzaF9mb2xkX20gPSBIYXNoZXIuU1xuXG4gIHZhbCBzZXhwX29mX21fX3QgOiAobW9kdWxlIFNleHBfb2ZfbSB3aXRoIHR5cGUgdCA9ICdlbHQpIC0+ICgnZWx0LCAnY21wKSB0IC0+IFNleHAudFxuXG4gIHZhbCBtX190X29mX3NleHBcbiAgICA6ICAobW9kdWxlIE1fb2Zfc2V4cCB3aXRoIHR5cGUgdCA9ICdlbHQgYW5kIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gJ2NtcClcbiAgICAtPiBTZXhwLnRcbiAgICAtPiAoJ2VsdCwgJ2NtcCkgdFxuXG4gIHZhbCBtX190X3NleHBfZ3JhbW1hclxuICAgIDogIChtb2R1bGUgTV9zZXhwX2dyYW1tYXIgd2l0aCB0eXBlIHQgPSAnZWx0KVxuICAgIC0+ICgnZWx0LCAnY21wKSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG5cbiAgdmFsIGNvbXBhcmVfbV9fdCA6IChtb2R1bGUgQ29tcGFyZV9tKSAtPiAoJ2VsdCwgJ2NtcCkgdCAtPiAoJ2VsdCwgJ2NtcCkgdCAtPiBpbnRcbiAgdmFsIGVxdWFsX21fX3QgOiAobW9kdWxlIEVxdWFsX20pIC0+ICgnZWx0LCAnY21wKSB0IC0+ICgnZWx0LCAnY21wKSB0IC0+IGJvb2xcblxuICB2YWwgaGFzaF9mb2xkX21fX3RcbiAgICA6ICAobW9kdWxlIEhhc2hfZm9sZF9tIHdpdGggdHlwZSB0ID0gJ2VsdClcbiAgICAtPiBIYXNoLnN0YXRlXG4gICAgLT4gKCdlbHQsIF8pIHRcbiAgICAtPiBIYXNoLnN0YXRlXG5cbiAgdmFsIGhhc2hfbV9fdCA6IChtb2R1bGUgSGFzaF9mb2xkX20gd2l0aCB0eXBlIHQgPSAnZWx0KSAtPiAoJ2VsdCwgXykgdCAtPiBpbnRcbmVuZFxuXG5tb2R1bGUgdHlwZSBTZXQgPSBzaWdcbiAgKCoqIFNldHMgYmFzZWQgb24geyFDb21wYXJhdG9yLlN9LlxuXG4gICAgICBDcmVhdG9ycyByZXF1aXJlIGEgY29tcGFyYXRvciBhcmd1bWVudCB0byBiZSBwYXNzZWQgaW4sIHdoZXJlYXMgYWNjZXNzb3JzIHVzZSB0aGVcbiAgICAgIGNvbXBhcmF0b3IgcHJvdmlkZWQgYnkgdGhlIGlucHV0IHNldC4gKilcblxuICAoKiogVGhlIHR5cGUgb2YgYSBzZXQuICBUaGUgZmlyc3QgdHlwZSBwYXJhbWV0ZXIgaWRlbnRpZmllcyB0aGUgdHlwZSBvZiB0aGUgZWxlbWVudCwgYW5kXG4gICAgICB0aGUgc2Vjb25kIGlkZW50aWZpZXMgdGhlIGNvbXBhcmF0b3IsIHdoaWNoIGRldGVybWluZXMgdGhlIGNvbXBhcmlzb24gZnVuY3Rpb24gdGhhdFxuICAgICAgaXMgdXNlZCBmb3Igb3JkZXJpbmcgZWxlbWVudHMgaW4gdGhpcyBzZXQuICBNYW55IG9wZXJhdGlvbnMgKGUuZy4sIHshdW5pb259KSxcbiAgICAgIHJlcXVpcmUgdGhhdCB0aGV5IGJlIHBhc3NlZCBzZXRzIHdpdGggdGhlIHNhbWUgZWxlbWVudCB0eXBlIGFuZCB0aGUgc2FtZSBjb21wYXJhdG9yXG4gICAgICB0eXBlLiAqKVxuICB0eXBlICgnZWx0LCAnY21wKSB0IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlXVxuXG4gIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkNvbXBhcmFibGUuUzIgd2l0aCB0eXBlICgnZWx0LCAnY21wKSB0IDo9ICgnZWx0LCAnY21wKSB0XG5cbiAgW0BAQGVuZF1cblxuICB0eXBlICgnaywgJ2NtcCkgY29tcGFyYXRvciA9ICgnaywgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICBbQEBkZXByZWNhdGVkIFwiW3NpbmNlIDIwMjEtMTJdIHVzZSBbQ29tcGFyYXRvci5Nb2R1bGUudF0gaW5zdGVhZFwiXVxuXG4gICgqKiBUZXN0cyBpbnRlcm5hbCBpbnZhcmlhbnRzIG9mIHRoZSBzZXQgZGF0YSBzdHJ1Y3R1cmUuICBSZXR1cm5zIHRydWUgb24gc3VjY2Vzcy4gKilcbiAgdmFsIGludmFyaWFudHMgOiAoXywgXykgdCAtPiBib29sXG5cbiAgKCoqIFJldHVybnMgYSBmaXJzdC1jbGFzcyBtb2R1bGUgdGhhdCBjYW4gYmUgdXNlZCB0byBidWlsZCBvdGhlciBtYXAvc2V0L2V0Y1xuICAgICAgd2l0aCB0aGUgc2FtZSBub3Rpb24gb2YgY29tcGFyaXNvbi4gKilcbiAgdmFsIGNvbXBhcmF0b3JfcyA6ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcblxuICB2YWwgY29tcGFyYXRvciA6ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIENvbXBhcmF0b3IudFxuXG4gICgqKiBDcmVhdGVzIGFuIGVtcHR5IHNldCBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgY29tcGFyYXRvci4gKilcbiAgdmFsIGVtcHR5IDogKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50IC0+ICgnYSwgJ2NtcCkgdFxuXG4gICgqKiBDcmVhdGVzIGEgc2V0IGJhc2VkIG9uIHRoZSBwcm92aWRlZCBjb21wYXJhdG9yIHRoYXQgY29udGFpbnMgb25seSB0aGUgcHJvdmlkZWRcbiAgICAgIGVsZW1lbnQuICopXG4gIHZhbCBzaW5nbGV0b24gOiAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnQgLT4gJ2EgLT4gKCdhLCAnY21wKSB0XG5cbiAgKCoqIFJldHVybnMgdGhlIGNhcmRpbmFsaXR5IG9mIHRoZSBzZXQuIFtPKDEpXS4gKilcbiAgdmFsIGxlbmd0aCA6IChfLCBfKSB0IC0+IGludFxuXG4gICgqKiBbaXNfZW1wdHkgdF0gaXMgW3RydWVdIGlmZiBbdF0gaXMgZW1wdHkuICBbTygxKV0uICopXG4gIHZhbCBpc19lbXB0eSA6IChfLCBfKSB0IC0+IGJvb2xcblxuICAoKiogW21lbSB0IGFdIHJldHVybnMgW3RydWVdIGlmZiBbYV0gaXMgaW4gW3RdLiAgW08obG9nIG4pXS4gKilcbiAgdmFsIG1lbSA6ICgnYSwgXykgdCAtPiAnYSAtPiBib29sXG5cbiAgKCoqIFthZGQgdCBhXSByZXR1cm5zIGEgbmV3IHNldCB3aXRoIFthXSBhZGRlZCB0byBbdF0sIG9yIHJldHVybnMgW3RdIGlmIFttZW0gdCBhXS5cbiAgICAgIFtPKGxvZyBuKV0uICopXG4gIHZhbCBhZGQgOiAoJ2EsICdjbXApIHQgLT4gJ2EgLT4gKCdhLCAnY21wKSB0XG5cbiAgKCoqIFtyZW1vdmUgdCBhXSByZXR1cm5zIGEgbmV3IHNldCB3aXRoIFthXSByZW1vdmVkIGZyb20gW3RdIGlmIFttZW0gdCBhXSwgb3IgcmV0dXJucyBbdF1cbiAgICAgIG90aGVyd2lzZS4gIFtPKGxvZyBuKV0uICopXG4gIHZhbCByZW1vdmUgOiAoJ2EsICdjbXApIHQgLT4gJ2EgLT4gKCdhLCAnY21wKSB0XG5cbiAgKCoqIFt1bmlvbiB0MSB0Ml0gcmV0dXJucyB0aGUgdW5pb24gb2YgdGhlIHR3byBzZXRzLiAgW08obGVuZ3RoIHQxICsgbGVuZ3RoIHQyKV0uICopXG4gIHZhbCB1bmlvbiA6ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0XG5cbiAgKCoqIFt1bmlvbiBjIGxpc3RdIHJldHVybnMgdGhlIHVuaW9uIG9mIGFsbCB0aGUgc2V0cyBpbiBbbGlzdF0uICBUaGVcbiAgICAgIFtjb21wYXJhdG9yXSBhcmd1bWVudCBpcyByZXF1aXJlZCBmb3IgdGhlIGNhc2Ugd2hlcmUgW2xpc3RdIGlzIGVtcHR5LlxuICAgICAgW08obWF4KExpc3QubGVuZ3RoIGxpc3QsIG4gbG9nIG4pKV0sIHdoZXJlIFtuXSBpcyB0aGUgc3VtIG9mIHNpemVzIG9mIHRoZSBpbnB1dCBzZXRzLiAqKVxuICB2YWwgdW5pb25fbGlzdCA6ICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudCAtPiAoJ2EsICdjbXApIHQgbGlzdCAtPiAoJ2EsICdjbXApIHRcblxuICAoKiogW2ludGVyIHQxIHQyXSBjb21wdXRlcyB0aGUgaW50ZXJzZWN0aW9uIG9mIHNldHMgW3QxXSBhbmQgW3QyXS4gIFtPKGxlbmd0aCB0MSArXG4gICAgICBsZW5ndGggdDIpXS4gKilcbiAgdmFsIGludGVyIDogKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHRcblxuICAoKiogW2RpZmYgdDEgdDJdIGNvbXB1dGVzIHRoZSBzZXQgZGlmZmVyZW5jZSBbdDEgLSB0Ml0sIGkuZS4sIHRoZSBzZXQgY29udGFpbmluZyBhbGxcbiAgICAgIGVsZW1lbnRzIGluIFt0MV0gdGhhdCBhcmUgbm90IGluIFt0Ml0uICBbTyhsZW5ndGggdDEgKyBsZW5ndGggdDIpXS4gKilcbiAgdmFsIGRpZmYgOiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdFxuXG4gICgqKiBbc3ltbWV0cmljX2RpZmYgdDEgdDJdIHJldHVybnMgYSBzZXF1ZW5jZSBvZiBjaGFuZ2VzIGJldHdlZW4gW3QxXSBhbmQgW3QyXS4gSXQgaXNcbiAgICAgIGludGVuZGVkIHRvIGJlIGVmZmljaWVudCBpbiB0aGUgY2FzZSB3aGVyZSBbdDFdIGFuZCBbdDJdIHNoYXJlIGEgbGFyZ2UgYW1vdW50IG9mXG4gICAgICBzdHJ1Y3R1cmUuICopXG4gIHZhbCBzeW1tZXRyaWNfZGlmZiA6ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnYSkgRWl0aGVyLnQgU2VxdWVuY2UudFxuXG4gICgqKiBbY29tcGFyZV9kaXJlY3QgdDEgdDJdIGNvbXBhcmVzIHRoZSBzZXRzIFt0MV0gYW5kIFt0Ml0uICBJdCByZXR1cm5zIHRoZSBzYW1lIHJlc3VsdFxuICAgICAgYXMgW2NvbXBhcmVdLCBidXQgdW5saWtlIGNvbXBhcmUsIGRvZXNuJ3QgcmVxdWlyZSBhcmd1bWVudHMgdG8gYmUgcGFzc2VkIGluIGZvciB0aGVcbiAgICAgIHR5cGUgcGFyYW1ldGVycyBvZiB0aGUgc2V0LiAgW08obGVuZ3RoIHQxICsgbGVuZ3RoIHQyKV0uICopXG4gIHZhbCBjb21wYXJlX2RpcmVjdCA6ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQgLT4gaW50XG5cbiAgKCoqIEhhc2ggZnVuY3Rpb246IGEgYnVpbGRpbmcgYmxvY2sgdG8gdXNlIHdoZW4gaGFzaGluZyBkYXRhIHN0cnVjdHVyZXMgY29udGFpbmluZyBzZXRzIGluXG4gICAgICB0aGVtLiBbaGFzaF9mb2xkX2RpcmVjdCBoYXNoX2ZvbGRfa2V5XSBpcyBjb21wYXRpYmxlIHdpdGggW2NvbXBhcmVfZGlyZWN0XSBpZmZcbiAgICAgIFtoYXNoX2ZvbGRfa2V5XSBpcyBjb21wYXRpYmxlIHdpdGggWyhjb21wYXJhdG9yIHMpLmNvbXBhcmVdIG9mIHRoZSBzZXQgW3NdIGJlaW5nXG4gICAgICBoYXNoZWQuICopXG4gIHZhbCBoYXNoX2ZvbGRfZGlyZWN0IDogJ2EgSGFzaC5mb2xkZXIgLT4gKCdhLCAnY21wKSB0IEhhc2guZm9sZGVyXG5cbiAgKCoqIFtlcXVhbCB0MSB0Ml0gcmV0dXJucyBbdHJ1ZV0gaWZmIHRoZSB0d28gc2V0cyBoYXZlIHRoZSBzYW1lIGVsZW1lbnRzLiAgW08obGVuZ3RoIHQxICtcbiAgICAgIGxlbmd0aCB0MildICopXG4gIHZhbCBlcXVhbCA6ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQgLT4gYm9vbFxuXG4gICgqKiBbZXhpc3RzIHQgfmZdIHJldHVybnMgW3RydWVdIGlmZiB0aGVyZSBleGlzdHMgYW4gW2FdIGluIFt0XSBmb3Igd2hpY2ggW2YgYV0uICBbTyhuKV0sXG4gICAgICBidXQgcmV0dXJucyBhcyBzb29uIGFzIGl0IGZpbmRzIGFuIFthXSBmb3Igd2hpY2ggW2YgYV0uICopXG4gIHZhbCBleGlzdHMgOiAoJ2EsIF8pIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gYm9vbFxuXG4gICgqKiBbZm9yX2FsbCB0IH5mXSByZXR1cm5zIFt0cnVlXSBpZmYgZm9yIGFsbCBbYV0gaW4gW3RdLCBbZiBhXS4gIFtPKG4pXSwgYnV0IHJldHVybnMgYXNcbiAgICAgIHNvb24gYXMgaXQgZmluZHMgYW4gW2FdIGZvciB3aGljaCBbbm90IChmIGEpXS4gKilcbiAgdmFsIGZvcl9hbGwgOiAoJ2EsIF8pIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gYm9vbFxuXG4gICgqKiBbY291bnQgdF0gcmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIG9mIFt0XSBmb3Igd2hpY2ggW2ZdIHJldHVybnMgW3RydWVdLlxuICAgICAgW08obildLiAqKVxuICB2YWwgY291bnQgOiAoJ2EsIF8pIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gaW50XG5cbiAgKCoqIFtzdW0gdF0gcmV0dXJucyB0aGUgc3VtIG9mIFtmIHRdIGZvciBlYWNoIFt0XSBpbiB0aGUgc2V0LlxuICAgICAgW08obildLiAqKVxuICB2YWwgc3VtXG4gICAgOiAgKG1vZHVsZSBDb250YWluZXIuU3VtbWFibGUgd2l0aCB0eXBlIHQgPSAnc3VtKVxuICAgIC0+ICgnYSwgXykgdFxuICAgIC0+IGY6KCdhIC0+ICdzdW0pXG4gICAgLT4gJ3N1bVxuXG4gICgqKiBbZmluZCB0IGZdIHJldHVybnMgYW4gZWxlbWVudCBvZiBbdF0gZm9yIHdoaWNoIFtmXSByZXR1cm5zIHRydWUsIHdpdGggbm8gZ3VhcmFudGVlIGFzXG4gICAgICB0byB3aGljaCBlbGVtZW50IGlzIHJldHVybmVkLiAgW08obildLCBidXQgcmV0dXJucyBhcyBzb29uIGFzIGEgc3VpdGFibGUgZWxlbWVudCBpc1xuICAgICAgZm91bmQuICopXG4gIHZhbCBmaW5kIDogKCdhLCBfKSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+ICdhIG9wdGlvblxuXG4gICgqKiBbZmluZF9tYXAgdCBmXSByZXR1cm5zIFtiXSBmb3Igc29tZSBbYV0gaW4gW3RdIGZvciB3aGljaCBbZiBhID0gU29tZSBiXS4gIElmIG5vIHN1Y2hcbiAgICAgIFthXSBleGlzdHMsIHRoZW4gW2ZpbmRdIHJldHVybnMgW05vbmVdLiAgW08obildLCBidXQgcmV0dXJucyBhcyBzb29uIGFzIGEgc3VpdGFibGVcbiAgICAgIGVsZW1lbnQgaXMgZm91bmQuICopXG4gIHZhbCBmaW5kX21hcCA6ICgnYSwgXykgdCAtPiBmOignYSAtPiAnYiBvcHRpb24pIC0+ICdiIG9wdGlvblxuXG4gICgqKiBMaWtlIFtmaW5kXSwgYnV0IHRocm93cyBhbiBleGNlcHRpb24gb24gZmFpbHVyZS4gKilcbiAgdmFsIGZpbmRfZXhuIDogKCdhLCBfKSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+ICdhXG5cbiAgKCoqIFtudGggdCBpXSByZXR1cm5zIHRoZSBbaV10aCBzbWFsbGVzdCBlbGVtZW50IG9mIFt0XSwgaW4gW08obG9nIG4pXSB0aW1lLiAgVGhlXG4gICAgICBzbWFsbGVzdCBlbGVtZW50IGhhcyBbaSA9IDBdLiAgUmV0dXJucyBbTm9uZV0gaWYgW2kgPCAwXSBvciBbaSA+PSBsZW5ndGggdF0uICopXG4gIHZhbCBudGggOiAoJ2EsIF8pIHQgLT4gaW50IC0+ICdhIG9wdGlvblxuXG4gICgqKiBbcmVtb3ZlX2luZGV4IHQgaV0gcmV0dXJucyBhIHZlcnNpb24gb2YgW3RdIHdpdGggdGhlIFtpXXRoIHNtYWxsZXN0IGVsZW1lbnQgcmVtb3ZlZCxcbiAgICAgIGluIFtPKGxvZyBuKV0gdGltZS4gIFRoZSBzbWFsbGVzdCBlbGVtZW50IGhhcyBbaSA9IDBdLiAgUmV0dXJucyBbdF0gaWYgW2kgPCAwXSBvclxuICAgICAgW2kgPj0gbGVuZ3RoIHRdLiAqKVxuICB2YWwgcmVtb3ZlX2luZGV4IDogKCdhLCAnY21wKSB0IC0+IGludCAtPiAoJ2EsICdjbXApIHRcblxuICAoKiogW2lzX3N1YnNldCB0MSB+b2ZfOnQyXSByZXR1cm5zIHRydWUgaWZmIFt0MV0gaXMgYSBzdWJzZXQgb2YgW3QyXS4gKilcbiAgdmFsIGlzX3N1YnNldCA6ICgnYSwgJ2NtcCkgdCAtPiBvZl86KCdhLCAnY21wKSB0IC0+IGJvb2xcblxuICAoKiogW2FyZV9kaXNqb2ludCB0MSB0Ml0gcmV0dXJucyBbdHJ1ZV0gaWZmIFtpc19lbXB0eSAoaW50ZXIgdDEgdDIpXSwgYnV0IGlzIG1vcmVcbiAgICAgIGVmZmljaWVudC4gKilcbiAgdmFsIGFyZV9kaXNqb2ludCA6ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQgLT4gYm9vbFxuXG4gICgqKiBbTmFtZWRdIGFsbG93cyB0aGUgdmFsaWRhdGlvbiBvZiBzdWJzZXQgYW5kIGVxdWFsaXR5IHJlbGF0aW9uc2hpcHMgYmV0d2VlbiBzZXRzLiAgQVxuICAgICAgW05hbWVkLnRdIGlzIGEgcmVjb3JkIG9mIGEgc2V0IGFuZCBhIG5hbWUsIHdoZXJlIHRoZSBuYW1lIGlzIHVzZWQgaW4gZXJyb3IgbWVzc2FnZXMsXG4gICAgICBhbmQgW05hbWVkLmlzX3N1YnNldF0gYW5kIFtOYW1lZC5lcXVhbF0gdmFsaWRhdGUgc3Vic2V0IGFuZCBlcXVhbGl0eSByZWxhdGlvbnNoaXBzXG4gICAgICByZXNwZWN0aXZlbHkuXG5cbiAgICAgIFRoZSBlcnJvciBtZXNzYWdlIGZvciwgZS5nLixcbiAgICAgIHtbXG4gICAgICAgIE5hbWVkLmlzX3N1YnNldCB7IHNldCA9IHNldDE7IG5hbWUgPSBcInNldDFcIiB9IH5vZl86e3NldCA9IHNldDI7IG5hbWUgPSBcInNldDJcIiB9XG4gICAgICBdfVxuXG4gICAgICBsb29rcyBsaWtlXG4gICAgICB7dlxuICAgICAgICAoXCJzZXQxIGlzIG5vdCBhIHN1YnNldCBvZiBzZXQyXCIgKGludmFsaWRfZWxlbWVudHMgKC4uLmVsZW1lbnRzIG9mIHNldDEgLSBzZXQyLi4uKSkpXG4gICAgIHZ9XG5cbiAgICAgIHNvIFtuYW1lXSBzaG91bGQgYmUgYSBub3VuIHBocmFzZSB0aGF0IGRvZXNuJ3Qgc291bmQgYXdrd2FyZCBpbiB0aGUgYWJvdmUgZXJyb3JcbiAgICAgIG1lc3NhZ2UuICBFdmVuIHRob3VnaCBpdCBhZGRzIHZlcmJvc2l0eSwgY2hvb3NpbmcgW25hbWVdcyB0aGF0IHN0YXJ0IHdpdGggdGhlIHBocmFzZVxuICAgICAgXCJ0aGUgc2V0IG9mXCIgb2Z0ZW4gbWFrZXMgdGhlIGVycm9yIG1lc3NhZ2Ugc291bmQgbW9yZSBuYXR1cmFsLlxuICAqKVxuICBtb2R1bGUgTmFtZWQgOiBzaWdcbiAgICB0eXBlIG5vbnJlYyAoJ2EsICdjbXApIHQgPVxuICAgICAgeyBzZXQgOiAoJ2EsICdjbXApIHRcbiAgICAgIDsgbmFtZSA6IHN0cmluZ1xuICAgICAgfVxuXG4gICAgKCoqIFtpc19zdWJzZXQgdDEgfm9mXzp0Ml0gcmV0dXJucyBbT2sgKCldIGlmIFt0MV0gaXMgYSBzdWJzZXQgb2YgW3QyXSBhbmQgYVxuICAgICAgICBodW1hbi1yZWFkYWJsZSBlcnJvciBvdGhlcndpc2UuICAqKVxuICAgIHZhbCBpc19zdWJzZXQgOiAoJ2EsICdjbXApIHQgLT4gb2ZfOignYSwgJ2NtcCkgdCAtPiB1bml0IE9yX2Vycm9yLnRcblxuICAgICgqKiBbZXF1YWwgdDEgdDJdIHJldHVybnMgW09rICgpXSBpZiBbdDFdIGlzIGVxdWFsIHRvIFt0Ml0gYW5kIGEgaHVtYW4tcmVhZGFibGVcbiAgICAgICAgZXJyb3Igb3RoZXJ3aXNlLiAgKilcbiAgICB2YWwgZXF1YWwgOiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+IHVuaXQgT3JfZXJyb3IudFxuICBlbmRcblxuICAoKiogVGhlIGxpc3Qgb3IgYXJyYXkgZ2l2ZW4gdG8gW29mX2xpc3RdIGFuZCBbb2ZfYXJyYXldIG5lZWQgbm90IGJlIHNvcnRlZC4gKilcbiAgdmFsIG9mX2xpc3QgOiAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnQgLT4gJ2EgbGlzdCAtPiAoJ2EsICdjbXApIHRcblxuICB2YWwgb2Zfc2VxdWVuY2UgOiAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnQgLT4gJ2EgU2VxdWVuY2UudCAtPiAoJ2EsICdjbXApIHRcbiAgdmFsIG9mX2FycmF5IDogKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50IC0+ICdhIGFycmF5IC0+ICgnYSwgJ2NtcCkgdFxuXG4gICgqKiBbdG9fbGlzdF0gYW5kIFt0b19hcnJheV0gcHJvZHVjZSBzZXF1ZW5jZXMgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlciBhY2NvcmRpbmcgdG8gdGhlXG4gICAgICBjb21wYXJhdG9yLiAqKVxuICB2YWwgdG9fbGlzdCA6ICgnYSwgXykgdCAtPiAnYSBsaXN0XG5cbiAgdmFsIHRvX2FycmF5IDogKCdhLCBfKSB0IC0+ICdhIGFycmF5XG5cbiAgKCoqIENyZWF0ZSBzZXQgZnJvbSBzb3J0ZWQgYXJyYXkuICBUaGUgaW5wdXQgbXVzdCBiZSBzb3J0ZWQgKGVpdGhlciBpbiBhc2NlbmRpbmcgb3JcbiAgICAgIGRlc2NlbmRpbmcgb3JkZXIgYXMgZ2l2ZW4gYnkgdGhlIGNvbXBhcmF0b3IpIGFuZCBjb250YWluIG5vIGR1cGxpY2F0ZXMsIG90aGVyd2lzZSB0aGVcbiAgICAgIHJlc3VsdCBpcyBhbiBlcnJvci4gIFRoZSBjb21wbGV4aXR5IG9mIHRoaXMgZnVuY3Rpb24gaXMgW08obildLiAqKVxuICB2YWwgb2Zfc29ydGVkX2FycmF5XG4gICAgOiAgKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gJ2EgYXJyYXlcbiAgICAtPiAoJ2EsICdjbXApIHQgT3JfZXJyb3IudFxuXG4gICgqKiBTaW1pbGFyIHRvIFtvZl9zb3J0ZWRfYXJyYXldLCBidXQgd2l0aG91dCBjaGVja2luZyB0aGUgaW5wdXQgYXJyYXkuICopXG4gIHZhbCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkXG4gICAgOiAgKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gJ2EgYXJyYXlcbiAgICAtPiAoJ2EsICdjbXApIHRcblxuICAoKiogW29mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIGMgfmxlbiB+Zl0gYmVoYXZlcyBsaWtlIFtvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIGNcbiAgICAgIChBcnJheS5pbml0IGxlbiB+ZildLCB3aXRoIHRoZSBhZGRpdGlvbmFsIHJlc3RyaWN0aW9uIHRoYXQgYSBkZWNyZWFzaW5nIG9yZGVyIGlzIG5vdFxuICAgICAgc3VwcG9ydGVkLiAgVGhlIGFkdmFudGFnZSBpcyBub3QgcmVxdWlyaW5nIHlvdSB0byBhbGxvY2F0ZSBhbiBpbnRlcm1lZGlhdGUgYXJyYXkuICBbZl1cbiAgICAgIHdpbGwgYmUgY2FsbGVkIHdpdGggMCwgMSwgLi4uIFtsZW4gLSAxXSwgaW4gb3JkZXIuICopXG4gIHZhbCBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZFxuICAgIDogICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+IGxlbjppbnRcbiAgICAtPiBmOihpbnQgLT4gJ2EpXG4gICAgLT4gKCdhLCAnY21wKSB0XG5cbiAgKCoqIFtzdGFibGVfZGVkdXBfbGlzdF0gaXMgaGVyZSByYXRoZXIgdGhhbiBpbiB0aGUgW0xpc3RdIG1vZHVsZSBiZWNhdXNlIHRoZVxuICAgICAgaW1wbGVtZW50YXRpb24gcmVsaWVzIGNydWNpYWxseSBvbiBzZXRzLCBhbmQgYmVjYXVzZSBkb2luZyBzbyBhbGxvd3Mgb25lIHRvIGF2b2lkIHVzZXNcbiAgICAgIG9mIHBvbHltb3JwaGljIGNvbXBhcmlzb24gYnkgaW5zdGFudGlhdGluZyB0aGUgZnVuY3RvciBhdCBhIGRpZmZlcmVudCBpbXBsZW1lbnRhdGlvblxuICAgICAgb2YgW0NvbXBhcmF0b3JdIGFuZCB1c2luZyB0aGUgcmVzdWx0aW5nIFtzdGFibGVfZGVkdXBfbGlzdF0uICopXG4gIHZhbCBzdGFibGVfZGVkdXBfbGlzdCA6ICgnYSwgXykgQ29tcGFyYXRvci5Nb2R1bGUudCAtPiAnYSBsaXN0IC0+ICdhIGxpc3RcblxuICAoKiogW21hcCBjIHQgfmZdIHJldHVybnMgYSBuZXcgc2V0IGNyZWF0ZWQgYnkgYXBwbHlpbmcgW2ZdIHRvIGV2ZXJ5IGVsZW1lbnQgaW5cbiAgICAgIFt0XS4gIFRoZSByZXR1cm5lZCBzZXQgaXMgYmFzZWQgb24gdGhlIHByb3ZpZGVkIFtjb21wYXJhdG9yXS4gIFtPKG4gbG9nIG4pXS4gKilcbiAgdmFsIG1hcCA6ICgnYiwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudCAtPiAoJ2EsIF8pIHQgLT4gZjooJ2EgLT4gJ2IpIC0+ICgnYiwgJ2NtcCkgdFxuXG4gICgqKiBMaWtlIHshbWFwfSwgZXhjZXB0IGVsZW1lbnRzIGZvciB3aGljaCBbZl0gcmV0dXJucyBbTm9uZV0gd2lsbCBiZSBkcm9wcGVkLiAgKilcbiAgdmFsIGZpbHRlcl9tYXBcbiAgICA6ICAoJ2IsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2EsIF8pIHRcbiAgICAtPiBmOignYSAtPiAnYiBvcHRpb24pXG4gICAgLT4gKCdiLCAnY21wKSB0XG5cbiAgKCoqIFtmaWx0ZXIgdCB+Zl0gcmV0dXJucyB0aGUgc3Vic2V0IG9mIFt0XSBmb3Igd2hpY2ggW2ZdIGV2YWx1YXRlcyB0byB0cnVlLiAgW08obiBsb2dcbiAgICAgIG4pXS4gKilcbiAgdmFsIGZpbHRlciA6ICgnYSwgJ2NtcCkgdCAtPiBmOignYSAtPiBib29sKSAtPiAoJ2EsICdjbXApIHRcblxuICAoKiogW2ZvbGQgdCB+aW5pdCB+Zl0gZm9sZHMgb3ZlciB0aGUgZWxlbWVudHMgb2YgdGhlIHNldCBmcm9tIHNtYWxsZXN0IHRvIGxhcmdlc3QuICopXG4gIHZhbCBmb2xkIDogKCdhLCBfKSB0IC0+IGluaXQ6J2FjY3VtIC0+IGY6KCdhY2N1bSAtPiAnYSAtPiAnYWNjdW0pIC0+ICdhY2N1bVxuXG4gICgqKiBbZm9sZF9yZXN1bHQgfmluaXQgfmZdIGZvbGRzIG92ZXIgdGhlIGVsZW1lbnRzIG9mIHRoZSBzZXQgZnJvbSBzbWFsbGVzdCB0b1xuICAgICAgbGFyZ2VzdCwgc2hvcnQgY2lyY3VpdGluZyB0aGUgZm9sZCBpZiBbZiBhY2N1bSB4XSBpcyBhbiBbRXJyb3IgX10gKilcbiAgdmFsIGZvbGRfcmVzdWx0XG4gICAgOiAgKCdhLCBfKSB0XG4gICAgLT4gaW5pdDonYWNjdW1cbiAgICAtPiBmOignYWNjdW0gLT4gJ2EgLT4gKCdhY2N1bSwgJ2UpIFJlc3VsdC50KVxuICAgIC0+ICgnYWNjdW0sICdlKSBSZXN1bHQudFxuXG4gICgqKiBbZm9sZF91bnRpbCB0IH5pbml0IH5mXSBpcyBhIHNob3J0LWNpcmN1aXRpbmcgdmVyc2lvbiBvZiBbZm9sZF0uIElmIFtmXVxuICAgICAgcmV0dXJucyBbU3RvcCBfXSB0aGUgY29tcHV0YXRpb24gY2Vhc2VzIGFuZCByZXN1bHRzIGluIHRoYXQgdmFsdWUuIElmIFtmXSByZXR1cm5zXG4gICAgICBbQ29udGludWUgX10sIHRoZSBmb2xkIHdpbGwgcHJvY2VlZC4gKilcbiAgdmFsIGZvbGRfdW50aWxcbiAgICA6ICAoJ2EsIF8pIHRcbiAgICAtPiBpbml0OidhY2N1bVxuICAgIC0+IGY6KCdhY2N1bSAtPiAnYSAtPiAoJ2FjY3VtLCAnZmluYWwpIENvbnRhaW5lci5Db250aW51ZV9vcl9zdG9wLnQpXG4gICAgLT4gZmluaXNoOignYWNjdW0gLT4gJ2ZpbmFsKVxuICAgIC0+ICdmaW5hbFxuXG5cbiAgKCoqIExpa2UgeyFmb2xkfSwgZXhjZXB0IHRoYXQgaXQgZ29lcyBmcm9tIHRoZSBsYXJnZXN0IHRvIHRoZSBzbWFsbGVzdCBlbGVtZW50LiAqKVxuICB2YWwgZm9sZF9yaWdodCA6ICgnYSwgXykgdCAtPiBpbml0OidhY2N1bSAtPiBmOignYSAtPiAnYWNjdW0gLT4gJ2FjY3VtKSAtPiAnYWNjdW1cblxuICAoKiogW2l0ZXIgdCB+Zl0gY2FsbHMgW2ZdIG9uIGV2ZXJ5IGVsZW1lbnQgb2YgW3RdLCBnb2luZyBpbiBvcmRlciBmcm9tIHRoZSBzbWFsbGVzdCB0b1xuICAgICAgbGFyZ2VzdC4gICopXG4gIHZhbCBpdGVyIDogKCdhLCBfKSB0IC0+IGY6KCdhIC0+IHVuaXQpIC0+IHVuaXRcblxuICAoKiogSXRlcmF0ZSB0d28gc2V0cyBzaWRlIGJ5IHNpZGUuICBDb21wbGV4aXR5IGlzIFtPKG0rbildIHdoZXJlIFttXSBhbmQgW25dIGFyZSB0aGUgc2l6ZXNcbiAgICAgIG9mIHRoZSB0d28gaW5wdXQgc2V0cy4gIEFzIGFuIGV4YW1wbGUsIHdpdGggdGhlIGlucHV0cyBbMDsgMV0gYW5kIFsxOyAyXSwgW2ZdIHdpbGwgYmVcbiAgICAgIGNhbGxlZCB3aXRoIFtgTGVmdCAwXTsgW2BCb3RoICgxLCAxKV07IGFuZCBbYFJpZ2h0IDJdLiAqKVxuICB2YWwgaXRlcjJcbiAgICA6ICAoJ2EsICdjbXApIHRcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiBmOihbIGBMZWZ0IG9mICdhIHwgYFJpZ2h0IG9mICdhIHwgYEJvdGggb2YgJ2EgKiAnYSBdIC0+IHVuaXQpXG4gICAgLT4gdW5pdFxuXG4gICgqKiBpZiBbYSwgYiA9IHBhcnRpdGlvbl90ZiBzZXQgfmZdIHRoZW4gW2FdIGlzIHRoZSBlbGVtZW50cyBvbiB3aGljaCBbZl0gcHJvZHVjZWQgW3RydWVdLFxuICAgICAgYW5kIFtiXSBpcyB0aGUgZWxlbWVudHMgb24gd2hpY2ggW2ZdIHByb2R1Y2VzIFtmYWxzZV0uICopXG4gIHZhbCBwYXJ0aXRpb25fdGYgOiAoJ2EsICdjbXApIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gKCdhLCAnY21wKSB0ICogKCdhLCAnY21wKSB0XG5cbiAgKCoqIFNhbWUgYXMgeyF0b19saXN0fS4gKilcbiAgdmFsIGVsZW1lbnRzIDogKCdhLCBfKSB0IC0+ICdhIGxpc3RcblxuICAoKiogUmV0dXJucyB0aGUgc21hbGxlc3QgZWxlbWVudCBvZiB0aGUgc2V0LiAgW08obG9nIG4pXS4gKilcbiAgdmFsIG1pbl9lbHQgOiAoJ2EsIF8pIHQgLT4gJ2Egb3B0aW9uXG5cbiAgKCoqIExpa2UgeyFtaW5fZWx0fSwgYnV0IHRocm93cyBhbiBleGNlcHRpb24gd2hlbiBnaXZlbiBhbiBlbXB0eSBzZXQuICopXG4gIHZhbCBtaW5fZWx0X2V4biA6ICgnYSwgXykgdCAtPiAnYVxuXG4gICgqKiBSZXR1cm5zIHRoZSBsYXJnZXN0IGVsZW1lbnQgb2YgdGhlIHNldC4gIFtPKGxvZyBuKV0uICAqKVxuICB2YWwgbWF4X2VsdCA6ICgnYSwgXykgdCAtPiAnYSBvcHRpb25cblxuICAoKiogTGlrZSB7IW1heF9lbHR9LCBidXQgdGhyb3dzIGFuIGV4Y2VwdGlvbiB3aGVuIGdpdmVuIGFuIGVtcHR5IHNldC4gKilcbiAgdmFsIG1heF9lbHRfZXhuIDogKCdhLCBfKSB0IC0+ICdhXG5cbiAgKCoqIHJldHVybnMgYW4gYXJiaXRyYXJ5IGVsZW1lbnQsIG9yIFtOb25lXSBpZiB0aGUgc2V0IGlzIGVtcHR5LiAqKVxuICB2YWwgY2hvb3NlIDogKCdhLCBfKSB0IC0+ICdhIG9wdGlvblxuXG4gICgqKiBMaWtlIHshY2hvb3NlfSwgYnV0IHRocm93cyBhbiBleGNlcHRpb24gb24gYW4gZW1wdHkgc2V0LiAqKVxuICB2YWwgY2hvb3NlX2V4biA6ICgnYSwgXykgdCAtPiAnYVxuXG4gICgqKiBbc3BsaXQgdCB4XSBwcm9kdWNlcyBhIHRyaXBsZSBbKHQxLCBtYXliZV94LCB0MildIHdoZXJlIFt0MV0gaXMgdGhlIHNldCBvZiBlbGVtZW50c1xuICAgICAgc3RyaWN0bHkgbGVzcyB0aGFuIFt4XSwgW21heWJlX3hdIGlzIHRoZSBtZW1iZXIgKGlmIGFueSkgb2YgW3RdIHdoaWNoIGNvbXBhcmVzIGVxdWFsXG4gICAgICB0byBbeF0sIGFuZCBbdDJdIGlzIHRoZSBzZXQgb2YgZWxlbWVudHMgc3RyaWN0bHkgbGFyZ2VyIHRoYW4gW3hdLiAqKVxuICB2YWwgc3BsaXQgOiAoJ2EsICdjbXApIHQgLT4gJ2EgLT4gKCdhLCAnY21wKSB0ICogJ2Egb3B0aW9uICogKCdhLCAnY21wKSB0XG5cbiAgKCoqIGlmIFtlcXVpdl0gaXMgYW4gZXF1aXZhbGVuY2UgcHJlZGljYXRlLCB0aGVuIFtncm91cF9ieSBzZXQgfmVxdWl2XSBwcm9kdWNlcyBhIGxpc3RcbiAgICAgIG9mIGVxdWl2YWxlbmNlIGNsYXNzZXMgKGkuZS4sIGEgc2V0LXRoZW9yZXRpYyBxdW90aWVudCkuICBFLmcuLFxuXG4gICAgICB7W1xuICAgICAgICBsZXQgY2hhcnMgPSBTZXQub2ZfbGlzdCBbJ0EnOyAnYSc7ICdiJzsgJ2MnXSBpblxuICAgICAgICBsZXQgZXF1aXYgYyBjJyA9IENoYXIuZXF1YWwgKENoYXIudXBwZXJjYXNlIGMpIChDaGFyLnVwcGVyY2FzZSBjJykgaW5cbiAgICAgICAgZ3JvdXBfYnkgY2hhcnMgfmVxdWl2XG4gICAgICBdfVxuXG4gICAgICBwcm9kdWNlczpcblxuICAgICAge1tcbiAgICAgICAgW1NldC5vZl9saXN0IFsnQSc7J2EnXTsgU2V0LnNpbmdsZXRvbiAnYic7IFNldC5zaW5nbGV0b24gJ2MnXVxuICAgICAgXX1cblxuICAgICAgW2dyb3VwX2J5XSBydW5zIGluIE8obl4yKSB0aW1lLCBzbyBpZiB5b3UgaGF2ZSBhIGNvbXBhcmlzb24gZnVuY3Rpb24sIGl0J3MgdXN1YWxseVxuICAgICAgbXVjaCBmYXN0ZXIgdG8gdXNlIFtTZXQub2ZfbGlzdF0uICopXG4gIHZhbCBncm91cF9ieSA6ICgnYSwgJ2NtcCkgdCAtPiBlcXVpdjooJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gKCdhLCAnY21wKSB0IGxpc3RcblxuICAoKiogW3RvX3NlcXVlbmNlIHRdIGNvbnZlcnRzIHRoZSBzZXQgW3RdIHRvIGEgc2VxdWVuY2Ugb2YgdGhlIGVsZW1lbnRzIGJldHdlZW5cbiAgICAgIFtncmVhdGVyX29yX2VxdWFsX3RvXSBhbmQgW2xlc3Nfb3JfZXF1YWxfdG9dIGluY2x1c2l2ZSBpbiB0aGUgb3JkZXIgaW5kaWNhdGVkIGJ5XG4gICAgICBbb3JkZXJdLiAgSWYgW2dyZWF0ZXJfb3JfZXF1YWxfdG8gPiBsZXNzX29yX2VxdWFsX3RvXSB0aGUgc2VxdWVuY2UgaXMgZW1wdHkuICBDb3N0IGlzXG4gICAgICBPKGxvZyBuKSB1cCBmcm9udCBhbmQgYW1vcnRpemVkIE8oMSkgZm9yIGVhY2ggZWxlbWVudCBwcm9kdWNlZC4gKilcbiAgdmFsIHRvX3NlcXVlbmNlXG4gICAgOiAgP29yZGVyOlsgYEluY3JlYXNpbmcgKCoqIGRlZmF1bHQgKikgfCBgRGVjcmVhc2luZyBdXG4gICAgLT4gP2dyZWF0ZXJfb3JfZXF1YWxfdG86J2FcbiAgICAtPiA/bGVzc19vcl9lcXVhbF90bzonYVxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+ICdhIFNlcXVlbmNlLnRcblxuICAoKiogW2JpbmFyeV9zZWFyY2ggdCB+Y29tcGFyZSB3aGljaCBlbHRdIHJldHVybnMgdGhlIGVsZW1lbnQgaW4gW3RdIHNwZWNpZmllZCBieVxuICAgICAgW2NvbXBhcmVdIGFuZCBbd2hpY2hdLCBpZiBvbmUgZXhpc3RzLlxuXG4gICAgICBbdF0gbXVzdCBiZSBzb3J0ZWQgaW4gaW5jcmVhc2luZyBvcmRlciBhY2NvcmRpbmcgdG8gW2NvbXBhcmVdLCB3aGVyZSBbY29tcGFyZV0gYW5kXG4gICAgICBbZWx0XSBkaXZpZGUgW3RdIGludG8gdGhyZWUgKHBvc3NpYmx5IGVtcHR5KSBzZWdtZW50czpcblxuICAgICAge3ZcbiAgICAgICAgfCAgPCBlbHQgIHwgID0gZWx0ICB8ICA+IGVsdCAgfFxuICAgICAgdn1cblxuICAgICAgW2JpbmFyeV9zZWFyY2hdIHJldHVybnMgYW4gZWxlbWVudCBvbiB0aGUgYm91bmRhcnkgb2Ygc2VnbWVudHMgYXMgc3BlY2lmaWVkIGJ5XG4gICAgICBbd2hpY2hdLiAgU2VlIHRoZSBkaWFncmFtIGJlbG93IG5leHQgdG8gdGhlIFt3aGljaF0gdmFyaWFudHMuXG5cbiAgICAgIFtiaW5hcnlfc2VhcmNoXSBkb2VzIG5vdCBjaGVjayB0aGF0IFtjb21wYXJlXSBvcmRlcnMgW3RdLCBhbmQgYmVoYXZpb3IgaXNcbiAgICAgIHVuc3BlY2lmaWVkIGlmIFtjb21wYXJlXSBkb2Vzbid0IG9yZGVyIFt0XS4gIEJlaGF2aW9yIGlzIGFsc28gdW5zcGVjaWZpZWQgaWZcbiAgICAgIFtjb21wYXJlXSBtdXRhdGVzIFt0XS4gKilcbiAgdmFsIGJpbmFyeV9zZWFyY2hcbiAgICA6ICAoJ2EsICdjbXApIHRcbiAgICAtPiBjb21wYXJlOignYSAtPiAna2V5IC0+IGludClcbiAgICAtPiBbIGBMYXN0X3N0cmljdGx5X2xlc3NfdGhhbiAoKiogICAgICAgIHt2IHwgPCBlbHQgWCB8ICAgICAgICAgICAgICAgICAgICAgICB2fSAqKVxuICAgICAgIHwgYExhc3RfbGVzc190aGFuX29yX2VxdWFsX3RvICgqKiAgICAge3YgfCAgICAgIDw9IGVsdCAgICAgICBYIHwgICAgICAgICAgIHZ9ICopXG4gICAgICAgfCBgTGFzdF9lcXVhbF90byAoKiogICAgICAgICAgICAgICAgICB7diAgICAgICAgICAgfCAgID0gZWx0IFggfCAgICAgICAgICAgdn0gKilcbiAgICAgICB8IGBGaXJzdF9lcXVhbF90byAoKiogICAgICAgICAgICAgICAgIHt2ICAgICAgICAgICB8IFggPSBlbHQgICB8ICAgICAgICAgICB2fSAqKVxuICAgICAgIHwgYEZpcnN0X2dyZWF0ZXJfdGhhbl9vcl9lcXVhbF90byAoKioge3YgICAgICAgICAgIHwgWCAgICAgICA+PSBlbHQgICAgICB8IHZ9ICopXG4gICAgICAgfCBgRmlyc3Rfc3RyaWN0bHlfZ3JlYXRlcl90aGFuICgqKiAgICB7diAgICAgICAgICAgICAgICAgICAgICAgfCBYID4gZWx0IHwgdn0gKilcbiAgICAgICBdXG4gICAgLT4gJ2tleVxuICAgIC0+ICdhIG9wdGlvblxuXG4gICgqKiBbYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQgdCB+c2VnbWVudF9vZiB3aGljaF0gdGFrZXMgYSBbc2VnbWVudF9vZl0gZnVuY3Rpb24gdGhhdFxuICAgICAgZGl2aWRlcyBbdF0gaW50byB0d28gKHBvc3NpYmx5IGVtcHR5KSBzZWdtZW50czpcblxuICAgICAge3ZcbiAgICAgICAgfCBzZWdtZW50X29mIGVsdCA9IGBMZWZ0IHwgc2VnbWVudF9vZiBlbHQgPSBgUmlnaHQgfFxuICAgICAgdn1cblxuICAgICAgW2JpbmFyeV9zZWFyY2hfc2VnbWVudGVkXSByZXR1cm5zIHRoZSBlbGVtZW50IG9uIHRoZSBib3VuZGFyeSBvZiB0aGUgc2VnbWVudHMgYXNcbiAgICAgIHNwZWNpZmllZCBieSBbd2hpY2hdOiBbYExhc3Rfb25fbGVmdF0geWllbGRzIHRoZSBsYXN0IGVsZW1lbnQgb2YgdGhlIGxlZnQgc2VnbWVudCxcbiAgICAgIHdoaWxlIFtgRmlyc3Rfb25fcmlnaHRdIHlpZWxkcyB0aGUgZmlyc3QgZWxlbWVudCBvZiB0aGUgcmlnaHQgc2VnbWVudC4gIEl0IHJldHVybnNcbiAgICAgIFtOb25lXSBpZiB0aGUgc2VnbWVudCBpcyBlbXB0eS5cblxuICAgICAgW2JpbmFyeV9zZWFyY2hfc2VnbWVudGVkXSBkb2VzIG5vdCBjaGVjayB0aGF0IFtzZWdtZW50X29mXSBzZWdtZW50cyBbdF0gYXMgaW4gdGhlXG4gICAgICBkaWFncmFtLCBhbmQgYmVoYXZpb3IgaXMgdW5zcGVjaWZpZWQgaWYgW3NlZ21lbnRfb2ZdIGRvZXNuJ3Qgc2VnbWVudCBbdF0uICBCZWhhdmlvclxuICAgICAgaXMgYWxzbyB1bnNwZWNpZmllZCBpZiBbc2VnbWVudF9vZl0gbXV0YXRlcyBbdF0uICopXG4gIHZhbCBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZFxuICAgIDogICgnYSwgJ2NtcCkgdFxuICAgIC0+IHNlZ21lbnRfb2Y6KCdhIC0+IFsgYExlZnQgfCBgUmlnaHQgXSlcbiAgICAtPiBbIGBMYXN0X29uX2xlZnQgfCBgRmlyc3Rfb25fcmlnaHQgXVxuICAgIC0+ICdhIG9wdGlvblxuXG4gICgqKiBQcm9kdWNlcyB0aGUgZWxlbWVudHMgb2YgdGhlIHR3byBzZXRzIGJldHdlZW4gW2dyZWF0ZXJfb3JfZXF1YWxfdG9dIGFuZFxuICAgICAgW2xlc3Nfb3JfZXF1YWxfdG9dIGluIFtvcmRlcl0sIG5vdGluZyB3aGV0aGVyIGVhY2ggZWxlbWVudCBhcHBlYXJzIGluIHRoZSBsZWZ0IHNldCxcbiAgICAgIHRoZSByaWdodCBzZXQsIG9yIGJvdGguICBJbiB0aGUgYm90aCBjYXNlLCBib3RoIGVsZW1lbnRzIGFyZSByZXR1cm5lZCwgaW4gY2FzZSB0aGVcbiAgICAgIGNhbGxlciBjYW4gZGlzdGluZ3Vpc2ggYmV0d2VlbiBlbGVtZW50cyB0aGF0IGFyZSBlcXVhbCB0byB0aGUgc2V0cycgY29tcGFyYXRvci4gIFJ1bnNcbiAgICAgIGluIE8obGVuZ3RoIHQgKyBsZW5ndGggdCcpLiAqKVxuICBtb2R1bGUgTWVyZ2VfdG9fc2VxdWVuY2VfZWxlbWVudCA6IHNpZ1xuICAgIHR5cGUgKCdhLCAnYikgdCA9ICgnYSwgJ2IpIFNlcXVlbmNlLk1lcmdlX3dpdGhfZHVwbGljYXRlc19lbGVtZW50LnQgPVxuICAgICAgfCBMZWZ0IG9mICdhXG4gICAgICB8IFJpZ2h0IG9mICdiXG4gICAgICB8IEJvdGggb2YgJ2EgKiAnYlxuICAgIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBzZXhwXVxuXG4gICAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TMiB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0XG4gICAgaW5jbHVkZSBTZXhwbGliMC5TZXhwYWJsZS5TMiB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0XG5cbiAgICBbQEBAZW5kXVxuICBlbmRcblxuICB2YWwgbWVyZ2VfdG9fc2VxdWVuY2VcbiAgICA6ICA/b3JkZXI6WyBgSW5jcmVhc2luZyAoKiogZGVmYXVsdCAqKSB8IGBEZWNyZWFzaW5nIF1cbiAgICAtPiA/Z3JlYXRlcl9vcl9lcXVhbF90bzonYVxuICAgIC0+ID9sZXNzX29yX2VxdWFsX3RvOidhXG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnYSkgTWVyZ2VfdG9fc2VxdWVuY2VfZWxlbWVudC50IFNlcXVlbmNlLnRcblxuICAoKiogW01dIGlzIG1lYW50IHRvIGJlIHVzZWQgaW4gY29tYmluYXRpb24gd2l0aCBPQ2FtbCBhcHBsaWNhdGl2ZSBmdW5jdG9yIHR5cGVzOlxuXG4gICAgICB7W1xuICAgICAgICB0eXBlIHN0cmluZ19zZXQgPSBTZXQuTShTdHJpbmcpLnRcbiAgICAgIF19XG5cbiAgICAgIHdoaWNoIHN0YW5kcyBmb3I6XG5cbiAgICAgIHtbXG4gICAgICAgIHR5cGUgc3RyaW5nX3NldCA9IChTdHJpbmcudCwgU3RyaW5nLmNvbXBhcmF0b3Jfd2l0bmVzcykgU2V0LnRcbiAgICAgIF19XG5cbiAgICAgIFRoZSBwb2ludCBpcyB0aGF0IFtTZXQuTShTdHJpbmcpLnRdIHN1cHBvcnRzIGRlcml2aW5nLCB3aGVyZWFzIHRoZSBzZWNvbmQgc3ludGF4XG4gICAgICBkb2Vzbid0IChiZWNhdXNlIHRoZXJlIGlzIG5vIHN1Y2ggdGhpbmcgYXMsIHNheSwgU3RyaW5nLnNleHBfb2ZfY29tcGFyYXRvcl93aXRuZXNzLFxuICAgICAgaW5zdGVhZCB5b3Ugd291bGQgd2FudCB0byBwYXNzIHRoZSBjb21wYXJhdG9yIGRpcmVjdGx5KS4gKilcbiAgbW9kdWxlIE0gKEVsdCA6IHNpZ1xuICAgICAgdHlwZSB0XG4gICAgICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzc1xuICAgIGVuZCkgOiBzaWdcbiAgICB0eXBlIG5vbnJlYyB0ID0gKEVsdC50LCBFbHQuY29tcGFyYXRvcl93aXRuZXNzKSB0XG4gIGVuZFxuXG4gIGluY2x1ZGUgRm9yX2Rlcml2aW5nIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHRcblxuICAoKiogQSBwb2x5bW9ycGhpYyBTZXQuICopXG4gIG1vZHVsZSBQb2x5IDogU19wb2x5IHdpdGggdHlwZSAnZWx0IHQgPSAoJ2VsdCwgQ29tcGFyYXRvci5Qb2x5LmNvbXBhcmF0b3Jfd2l0bmVzcykgdFxuXG4gICgqKiBVc2luZyBjb21wYXJhdG9yIGlzIGEgc2ltaWxhciBpbnRlcmZhY2UgYXMgdGhlIHRvcGxldmVsIG9mIFtTZXRdLCBleGNlcHQgdGhlIGZ1bmN0aW9uc1xuICAgICAgdGFrZSBhIFt+Y29tcGFyYXRvcjooJ2VsdCwgJ2NtcCkgQ29tcGFyYXRvci50XSB3aGVyZSB0aGUgZnVuY3Rpb25zIGF0IHRoZSB0b3BsZXZlbCBvZlxuICAgICAgW1NldF0gdGFrZXMgYSBbKCdlbHQsICdjbXApIGNvbXBhcmF0b3JdLiAqKVxuICBtb2R1bGUgVXNpbmdfY29tcGFyYXRvciA6IHNpZ1xuICAgIHR5cGUgbm9ucmVjICgnZWx0LCAnY21wKSB0ID0gKCdlbHQsICdjbXApIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgICB2YWwgc2V4cF9vZl90XG4gICAgICA6ICAoJ2VsdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAtPiAoJ2NtcCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAtPiAoJ2VsdCwgJ2NtcCkgdFxuICAgICAgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgICBbQEBAZW5kXVxuXG4gICAgdmFsIHRfb2Zfc2V4cF9kaXJlY3RcbiAgICAgIDogIGNvbXBhcmF0b3I6KCdlbHQsICdjbXApIENvbXBhcmF0b3IudFxuICAgICAgLT4gKFNleHAudCAtPiAnZWx0KVxuICAgICAgLT4gU2V4cC50XG4gICAgICAtPiAoJ2VsdCwgJ2NtcCkgdFxuXG4gICAgbW9kdWxlIFRyZWUgOiBzaWdcbiAgICAgICgqKiBBIFtUcmVlLnRdIGNvbnRhaW5zIGp1c3QgdGhlIHRyZWUgZGF0YSBzdHJ1Y3R1cmUgdGhhdCBhIHNldCBpcyBiYXNlZCBvbiwgd2l0aG91dFxuICAgICAgICAgIGluY2x1ZGluZyB0aGUgY29tcGFyYXRvci4gIEFjY29yZGluZ2x5LCBhbnkgb3BlcmF0aW9uIG9uIGEgW1RyZWUudF0gbXVzdCBhbHNvIHRha2VcbiAgICAgICAgICBhcyBhbiBhcmd1bWVudCB0aGUgY29ycmVzcG9uZGluZyBjb21wYXJhdG9yLiAqKVxuICAgICAgdHlwZSAoJ2EsICdjbXApIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgICAgIHZhbCBzZXhwX29mX3RcbiAgICAgICAgOiAgKCdhIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgICAgLT4gKCdjbXAgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAgICAgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgICAgIFtAQEBlbmRdXG5cbiAgICAgIHZhbCB0X29mX3NleHBfZGlyZWN0XG4gICAgICAgIDogIGNvbXBhcmF0b3I6KCdlbHQsICdjbXApIENvbXBhcmF0b3IudFxuICAgICAgICAtPiAoU2V4cC50IC0+ICdlbHQpXG4gICAgICAgIC0+IFNleHAudFxuICAgICAgICAtPiAoJ2VsdCwgJ2NtcCkgdFxuXG4gICAgICBtb2R1bGUgTmFtZWQgOiBzaWdcbiAgICAgICAgdHlwZSBub25yZWMgKCdhLCAnY21wKSB0ID1cbiAgICAgICAgICB7IHRyZWUgOiAoJ2EsICdjbXApIHRcbiAgICAgICAgICA7IG5hbWUgOiBzdHJpbmdcbiAgICAgICAgICB9XG5cbiAgICAgICAgdmFsIGlzX3N1YnNldFxuICAgICAgICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAgICAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAgICAgICAtPiBvZl86KCdhLCAnY21wKSB0XG4gICAgICAgICAgLT4gdW5pdCBPcl9lcnJvci50XG5cbiAgICAgICAgdmFsIGVxdWFsXG4gICAgICAgICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgICAgICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgICAgICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgICAgICAgIC0+IHVuaXQgT3JfZXJyb3IudFxuICAgICAgZW5kXG5cbiAgICAgIGluY2x1ZGVcbiAgICAgICAgQ3JlYXRvcnNfYW5kX2FjY2Vzc29yczJfd2l0aF9jb21wYXJhdG9yXG4gICAgICAgIHdpdGggdHlwZSAoJ2EsICdiKSBzZXQgOj0gKCdhLCAnYikgdFxuICAgICAgICB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0XG4gICAgICAgIHdpdGggdHlwZSAoJ2EsICdiKSB0cmVlIDo9ICgnYSwgJ2IpIHRcbiAgICAgICAgd2l0aCB0eXBlICgnYSwgJ2IpIG5hbWVkIDo9ICgnYSwgJ2IpIE5hbWVkLnRcbiAgICAgICAgd2l0aCBtb2R1bGUgTmFtZWQgOj0gTmFtZWRcblxuICAgICAgdmFsIGVtcHR5X3dpdGhvdXRfdmFsdWVfcmVzdHJpY3Rpb24gOiAoXywgXykgdFxuICAgIGVuZFxuXG4gICAgaW5jbHVkZVxuICAgICAgQWNjZXNzb3JzMlxuICAgICAgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdFxuICAgICAgd2l0aCB0eXBlICgnYSwgJ2IpIHRyZWUgOj0gKCdhLCAnYikgVHJlZS50XG4gICAgICB3aXRoIHR5cGUgKCdhLCAnYikgbmFtZWQgOj0gKCdhLCAnYikgTmFtZWQudFxuXG4gICAgaW5jbHVkZVxuICAgICAgQ3JlYXRvcnMyX3dpdGhfY29tcGFyYXRvclxuICAgICAgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdFxuICAgICAgd2l0aCB0eXBlICgnYSwgJ2IpIHRyZWUgOj0gKCdhLCAnYikgVHJlZS50XG4gICAgICB3aXRoIHR5cGUgKCdhLCAnYikgc2V0IDo9ICgnYSwgJ2IpIHRcblxuICAgIHZhbCBjb21wYXJhdG9yIDogKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgdmFsIGhhc2hfZm9sZF9kaXJlY3QgOiAnZWx0IEhhc2guZm9sZGVyIC0+ICgnZWx0LCAnY21wKSB0IEhhc2guZm9sZGVyXG5cbiAgICBtb2R1bGUgRW1wdHlfd2l0aG91dF92YWx1ZV9yZXN0cmljdGlvbiAoRWx0IDogQ29tcGFyYXRvci5TMSkgOiBzaWdcbiAgICAgIHZhbCBlbXB0eSA6ICgnYSBFbHQudCwgRWx0LmNvbXBhcmF0b3Jfd2l0bmVzcykgdFxuICAgIGVuZFxuICBlbmRcblxuICAoKiogezIgTW9kdWxlcyBhbmQgbW9kdWxlIHR5cGVzIGZvciBleHRlbmRpbmcgW1NldF19XG5cbiAgICAgIEZvciB1c2UgaW4gZXh0ZW5zaW9ucyBvZiBCYXNlLCBsaWtlIFtDb3JlXS4gKilcblxuICBtb2R1bGUgV2l0aF9jb21wYXJhdG9yID0gV2l0aF9jb21wYXJhdG9yXG4gIG1vZHVsZSBXaXRoX2ZpcnN0X2NsYXNzX21vZHVsZSA9IFdpdGhfZmlyc3RfY2xhc3NfbW9kdWxlXG4gIG1vZHVsZSBXaXRob3V0X2NvbXBhcmF0b3IgPSBXaXRob3V0X2NvbXBhcmF0b3JcblxuICBtb2R1bGUgdHlwZSBGb3JfZGVyaXZpbmcgPSBGb3JfZGVyaXZpbmdcbiAgbW9kdWxlIHR5cGUgU19wb2x5ID0gU19wb2x5XG4gIG1vZHVsZSB0eXBlIEFjY2Vzc29yczAgPSBBY2Nlc3NvcnMwXG4gIG1vZHVsZSB0eXBlIEFjY2Vzc29yczEgPSBBY2Nlc3NvcnMxXG4gIG1vZHVsZSB0eXBlIEFjY2Vzc29yczIgPSBBY2Nlc3NvcnMyXG4gIG1vZHVsZSB0eXBlIEFjY2Vzc29yczJfd2l0aF9jb21wYXJhdG9yID0gQWNjZXNzb3JzMl93aXRoX2NvbXBhcmF0b3JcbiAgbW9kdWxlIHR5cGUgQWNjZXNzb3JzX2dlbmVyaWMgPSBBY2Nlc3NvcnNfZ2VuZXJpY1xuICBtb2R1bGUgdHlwZSBDcmVhdG9yczAgPSBDcmVhdG9yczBcbiAgbW9kdWxlIHR5cGUgQ3JlYXRvcnMxID0gQ3JlYXRvcnMxXG4gIG1vZHVsZSB0eXBlIENyZWF0b3JzMiA9IENyZWF0b3JzMlxuICBtb2R1bGUgdHlwZSBDcmVhdG9yczJfd2l0aF9jb21wYXJhdG9yID0gQ3JlYXRvcnMyX3dpdGhfY29tcGFyYXRvclxuICBtb2R1bGUgdHlwZSBDcmVhdG9yc19hbmRfYWNjZXNzb3JzMCA9IENyZWF0b3JzX2FuZF9hY2Nlc3NvcnMwXG4gIG1vZHVsZSB0eXBlIENyZWF0b3JzX2FuZF9hY2Nlc3NvcnMxID0gQ3JlYXRvcnNfYW5kX2FjY2Vzc29yczFcbiAgbW9kdWxlIHR5cGUgQ3JlYXRvcnNfYW5kX2FjY2Vzc29yczIgPSBDcmVhdG9yc19hbmRfYWNjZXNzb3JzMlxuXG4gIG1vZHVsZSB0eXBlIENyZWF0b3JzX2FuZF9hY2Nlc3NvcnMyX3dpdGhfY29tcGFyYXRvciA9XG4gICAgQ3JlYXRvcnNfYW5kX2FjY2Vzc29yczJfd2l0aF9jb21wYXJhdG9yXG5cbiAgbW9kdWxlIHR5cGUgQ3JlYXRvcnNfZ2VuZXJpYyA9IENyZWF0b3JzX2dlbmVyaWNcbiAgbW9kdWxlIHR5cGUgRWx0X3BsYWluID0gRWx0X3BsYWluXG5lbmRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0aXZlIENhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgKilcbigqICBlbiBBdXRvbWF0aXF1ZS4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgICAgKilcbigqICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEFwYWNoZSAyLjAgbGljZW5zZS4gU2VlIC4uL1RISVJELVBBUlRZLnR4dCAgKilcbigqICBmb3IgZGV0YWlscy4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogU2V0cyBvdmVyIG9yZGVyZWQgdHlwZXMgKilcblxub3BlbiEgSW1wb3J0XG5pbmNsdWRlIFNldF9pbnRmXG5cbmxldCB3aXRoX3JldHVybiA9IFdpdGhfcmV0dXJuLndpdGhfcmV0dXJuXG5cblxubW9kdWxlIFRyZWUwID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9XG4gICAgfCBFbXB0eVxuICAgICgqIChMZWFmIHgpIGlzIHRoZSBzYW1lIGFzIChOb2RlIChFbXB0eSwgeCwgRW1wdHksIDEsIDEpKSBidXQgdXNlcyBsZXNzIHNwYWNlLiAqKVxuICAgIHwgTGVhZiBvZiAnYVxuICAgICgqIGZpcnN0IGludCBpcyBoZWlnaHQsIHNlY29uZCBpcyBzdWItdHJlZSBzaXplICopXG4gICAgfCBOb2RlIG9mICdhIHQgKiAnYSAqICdhIHQgKiBpbnQgKiBpbnRcblxuICB0eXBlICdhIHRyZWUgPSAnYSB0XG5cbiAgKCogU2V0cyBhcmUgcmVwcmVzZW50ZWQgYnkgYmFsYW5jZWQgYmluYXJ5IHRyZWVzICh0aGUgaGVpZ2h0cyBvZiB0aGUgY2hpbGRyZW4gZGlmZmVyIGJ5XG4gICAgIGF0IG1vc3QgMi4gKilcbiAgbGV0IGhlaWdodCA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPiAwXG4gICAgfCBMZWFmIF8gLT4gMVxuICAgIHwgTm9kZSAoXywgXywgXywgaCwgXykgLT4gaFxuICA7O1xuXG4gIGxldCBsZW5ndGggPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gMFxuICAgIHwgTGVhZiBfIC0+IDFcbiAgICB8IE5vZGUgKF8sIF8sIF8sIF8sIHMpIC0+IHNcbiAgOztcblxuICBsZXQgaW52YXJpYW50cyA9XG4gICAgbGV0IGluX3JhbmdlIGxvd2VyIHVwcGVyIGNvbXBhcmVfZWx0IHYgPVxuICAgICAgKG1hdGNoIGxvd2VyIHdpdGhcbiAgICAgICB8IE5vbmUgLT4gdHJ1ZVxuICAgICAgIHwgU29tZSBsb3dlciAtPiBjb21wYXJlX2VsdCBsb3dlciB2IDwgMClcbiAgICAgICYmXG4gICAgICBtYXRjaCB1cHBlciB3aXRoXG4gICAgICB8IE5vbmUgLT4gdHJ1ZVxuICAgICAgfCBTb21lIHVwcGVyIC0+IGNvbXBhcmVfZWx0IHYgdXBwZXIgPCAwXG4gICAgaW5cbiAgICBsZXQgcmVjIGxvb3AgbG93ZXIgdXBwZXIgY29tcGFyZV9lbHQgdCA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gdHJ1ZVxuICAgICAgfCBMZWFmIHYgLT4gaW5fcmFuZ2UgbG93ZXIgdXBwZXIgY29tcGFyZV9lbHQgdlxuICAgICAgfCBOb2RlIChsLCB2LCByLCBoLCBuKSAtPlxuICAgICAgICBsZXQgaGwgPSBoZWlnaHQgbFxuICAgICAgICBhbmQgaHIgPSBoZWlnaHQgciBpblxuICAgICAgICBhYnMgKGhsIC0gaHIpIDw9IDJcbiAgICAgICAgJiYgaCA9IG1heCBobCBociArIDFcbiAgICAgICAgJiYgbiA9IGxlbmd0aCBsICsgbGVuZ3RoIHIgKyAxXG4gICAgICAgICYmIGluX3JhbmdlIGxvd2VyIHVwcGVyIGNvbXBhcmVfZWx0IHZcbiAgICAgICAgJiYgbG9vcCBsb3dlciAoU29tZSB2KSBjb21wYXJlX2VsdCBsXG4gICAgICAgICYmIGxvb3AgKFNvbWUgdikgdXBwZXIgY29tcGFyZV9lbHQgclxuICAgIGluXG4gICAgZnVuIHQgfmNvbXBhcmVfZWx0IC0+IGxvb3AgTm9uZSBOb25lIGNvbXBhcmVfZWx0IHRcbiAgOztcblxuICBsZXQgaXNfZW1wdHkgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gdHJ1ZVxuICAgIHwgTGVhZiBfIHwgTm9kZSBfIC0+IGZhbHNlXG4gIDs7XG5cbiAgKCogQ3JlYXRlcyBhIG5ldyBub2RlIHdpdGggbGVmdCBzb24gbCwgdmFsdWUgdiBhbmQgcmlnaHQgc29uIHIuXG4gICAgIFdlIG11c3QgaGF2ZSBhbGwgZWxlbWVudHMgb2YgbCA8IHYgPCBhbGwgZWxlbWVudHMgb2Ygci5cbiAgICAgbCBhbmQgciBtdXN0IGJlIGJhbGFuY2VkIGFuZCB8IGhlaWdodCBsIC0gaGVpZ2h0IHIgfCA8PSAyLlxuICAgICBJbmxpbmUgZXhwYW5zaW9uIG9mIGhlaWdodCBmb3IgYmV0dGVyIHNwZWVkLiAqKVxuXG4gIGxldCBjcmVhdGUgbCB2IHIgPVxuICAgIGxldCBobCA9XG4gICAgICBtYXRjaCBsIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gMFxuICAgICAgfCBMZWFmIF8gLT4gMVxuICAgICAgfCBOb2RlIChfLCBfLCBfLCBoLCBfKSAtPiBoXG4gICAgaW5cbiAgICBsZXQgaHIgPVxuICAgICAgbWF0Y2ggciB3aXRoXG4gICAgICB8IEVtcHR5IC0+IDBcbiAgICAgIHwgTGVhZiBfIC0+IDFcbiAgICAgIHwgTm9kZSAoXywgXywgXywgaCwgXykgLT4gaFxuICAgIGluXG4gICAgbGV0IGggPSBpZiBobCA+PSBociB0aGVuIGhsICsgMSBlbHNlIGhyICsgMSBpblxuICAgIGlmIGggPSAxXG4gICAgdGhlbiBMZWFmIHZcbiAgICBlbHNlIChcbiAgICAgIGxldCBzbCA9XG4gICAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IDBcbiAgICAgICAgfCBMZWFmIF8gLT4gMVxuICAgICAgICB8IE5vZGUgKF8sIF8sIF8sIF8sIHMpIC0+IHNcbiAgICAgIGluXG4gICAgICBsZXQgc3IgPVxuICAgICAgICBtYXRjaCByIHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPiAwXG4gICAgICAgIHwgTGVhZiBfIC0+IDFcbiAgICAgICAgfCBOb2RlIChfLCBfLCBfLCBfLCBzKSAtPiBzXG4gICAgICBpblxuICAgICAgTm9kZSAobCwgdiwgciwgaCwgc2wgKyBzciArIDEpKVxuICA7O1xuXG4gICgqIFdlIG11c3QgY2FsbCBbZl0gd2l0aCBpbmNyZWFzaW5nIGluZGV4ZXMsIGJlY2F1c2UgdGhlIGJpbl9wcm90IHJlYWRlciBpblxuICAgICBDb3JlLlNldCBuZWVkcyBpdC4gKilcbiAgbGV0IG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5sZW4gfmYgPVxuICAgIGxldCByZWMgbG9vcCBuIH5mIGkgPVxuICAgICAgbWF0Y2ggbiB3aXRoXG4gICAgICB8IDAgLT4gRW1wdHlcbiAgICAgIHwgMSAtPlxuICAgICAgICBsZXQgayA9IGYgaSBpblxuICAgICAgICBMZWFmIGtcbiAgICAgIHwgMiAtPlxuICAgICAgICBsZXQga2wgPSBmIGkgaW5cbiAgICAgICAgbGV0IGsgPSBmIChpICsgMSkgaW5cbiAgICAgICAgY3JlYXRlIChMZWFmIGtsKSBrIEVtcHR5XG4gICAgICB8IDMgLT5cbiAgICAgICAgbGV0IGtsID0gZiBpIGluXG4gICAgICAgIGxldCBrID0gZiAoaSArIDEpIGluXG4gICAgICAgIGxldCBrciA9IGYgKGkgKyAyKSBpblxuICAgICAgICBjcmVhdGUgKExlYWYga2wpIGsgKExlYWYga3IpXG4gICAgICB8IG4gLT5cbiAgICAgICAgbGV0IGxlZnRfbGVuZ3RoID0gbiBsc3IgMSBpblxuICAgICAgICBsZXQgcmlnaHRfbGVuZ3RoID0gbiAtIGxlZnRfbGVuZ3RoIC0gMSBpblxuICAgICAgICBsZXQgbGVmdCA9IGxvb3AgbGVmdF9sZW5ndGggfmYgaSBpblxuICAgICAgICBsZXQgayA9IGYgKGkgKyBsZWZ0X2xlbmd0aCkgaW5cbiAgICAgICAgbGV0IHJpZ2h0ID0gbG9vcCByaWdodF9sZW5ndGggfmYgKGkgKyBsZWZ0X2xlbmd0aCArIDEpIGluXG4gICAgICAgIGNyZWF0ZSBsZWZ0IGsgcmlnaHRcbiAgICBpblxuICAgIGxvb3AgbGVuIH5mIDBcbiAgOztcblxuICBsZXQgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCBhcnJheSB+Y29tcGFyZV9lbHQgPVxuICAgIGxldCBhcnJheV9sZW5ndGggPSBBcnJheS5sZW5ndGggYXJyYXkgaW5cbiAgICBsZXQgbmV4dCA9XG4gICAgICAoKiBXZSBkb24ndCBjaGVjayBpZiB0aGUgYXJyYXkgaXMgc29ydGVkIG9yIGtleXMgYXJlIGR1cGxpY2F0ZWQsIGJlY2F1c2UgdGhhdFxuICAgICAgICAgY2hlY2tpbmcgaXMgc2xvd2VyIHRoYW4gdGhlIHdob2xlIFtvZl9zb3J0ZWRfYXJyYXldIGZ1bmN0aW9uICopXG4gICAgICBpZiBhcnJheV9sZW5ndGggPCAyIHx8IGNvbXBhcmVfZWx0IGFycmF5LigwKSBhcnJheS4oMSkgPCAwXG4gICAgICB0aGVuIGZ1biBpIC0+IGFycmF5LihpKVxuICAgICAgZWxzZSBmdW4gaSAtPiBhcnJheS4oYXJyYXlfbGVuZ3RoIC0gMSAtIGkpXG4gICAgaW5cbiAgICBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+bGVuOmFycmF5X2xlbmd0aCB+ZjpuZXh0XG4gIDs7XG5cbiAgbGV0IG9mX3NvcnRlZF9hcnJheSBhcnJheSB+Y29tcGFyZV9lbHQgPVxuICAgIG1hdGNoIGFycmF5IHdpdGhcbiAgICB8IFt8fF0gfCBbfCBfIHxdIC0+IFJlc3VsdC5PayAob2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCBhcnJheSB+Y29tcGFyZV9lbHQpXG4gICAgfCBfIC0+XG4gICAgICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICAgICAgbGV0IGluY3JlYXNpbmcgPVxuICAgICAgICAgIG1hdGNoIGNvbXBhcmVfZWx0IGFycmF5LigwKSBhcnJheS4oMSkgd2l0aFxuICAgICAgICAgIHwgMCAtPiByLnJldHVybiAoT3JfZXJyb3IuZXJyb3Jfc3RyaW5nIFwib2Zfc29ydGVkX2FycmF5OiBkdXBsaWNhdGVkIGVsZW1lbnRzXCIpXG4gICAgICAgICAgfCBpIC0+IGkgPCAwXG4gICAgICAgIGluXG4gICAgICAgIGZvciBpID0gMSB0byBBcnJheS5sZW5ndGggYXJyYXkgLSAyIGRvXG4gICAgICAgICAgbWF0Y2ggY29tcGFyZV9lbHQgYXJyYXkuKGkpIGFycmF5LihpICsgMSkgd2l0aFxuICAgICAgICAgIHwgMCAtPiByLnJldHVybiAoT3JfZXJyb3IuZXJyb3Jfc3RyaW5nIFwib2Zfc29ydGVkX2FycmF5OiBkdXBsaWNhdGVkIGVsZW1lbnRzXCIpXG4gICAgICAgICAgfCBpIC0+XG4gICAgICAgICAgICBpZiBQb2x5LiggPD4gKSAoaSA8IDApIGluY3JlYXNpbmdcbiAgICAgICAgICAgIHRoZW5cbiAgICAgICAgICAgICAgci5yZXR1cm5cbiAgICAgICAgICAgICAgICAoT3JfZXJyb3IuZXJyb3Jfc3RyaW5nIFwib2Zfc29ydGVkX2FycmF5OiBlbGVtZW50cyBhcmUgbm90IG9yZGVyZWRcIilcbiAgICAgICAgZG9uZTtcbiAgICAgICAgUmVzdWx0Lk9rIChvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIGFycmF5IH5jb21wYXJlX2VsdCkpXG4gIDs7XG5cbiAgKCogU2FtZSBhcyBjcmVhdGUsIGJ1dCBwZXJmb3JtcyBvbmUgc3RlcCBvZiByZWJhbGFuY2luZyBpZiBuZWNlc3NhcnkuXG4gICAgIEFzc3VtZXMgbCBhbmQgciBiYWxhbmNlZCBhbmQgfCBoZWlnaHQgbCAtIGhlaWdodCByIHwgPD0gMy5cbiAgICAgSW5saW5lIGV4cGFuc2lvbiBvZiBjcmVhdGUgZm9yIGJldHRlciBzcGVlZCBpbiB0aGUgbW9zdCBmcmVxdWVudCBjYXNlXG4gICAgIHdoZXJlIG5vIHJlYmFsYW5jaW5nIGlzIHJlcXVpcmVkLiAqKVxuXG4gIGxldCBiYWwgbCB2IHIgPVxuICAgIGxldCBobCA9XG4gICAgICBtYXRjaCBsIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gMFxuICAgICAgfCBMZWFmIF8gLT4gMVxuICAgICAgfCBOb2RlIChfLCBfLCBfLCBoLCBfKSAtPiBoXG4gICAgaW5cbiAgICBsZXQgaHIgPVxuICAgICAgbWF0Y2ggciB3aXRoXG4gICAgICB8IEVtcHR5IC0+IDBcbiAgICAgIHwgTGVhZiBfIC0+IDFcbiAgICAgIHwgTm9kZSAoXywgXywgXywgaCwgXykgLT4gaFxuICAgIGluXG4gICAgaWYgaGwgPiBociArIDJcbiAgICB0aGVuIChcbiAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgIHwgTGVhZiBfIC0+IGFzc2VydCBmYWxzZSAoKiBiZWNhdXNlIGgobCk+aChyKSsyIGFuZCBoKGxlYWYpPTEgKilcbiAgICAgIHwgTm9kZSAobGwsIGx2LCBsciwgXywgXykgLT5cbiAgICAgICAgaWYgaGVpZ2h0IGxsID49IGhlaWdodCBsclxuICAgICAgICB0aGVuIGNyZWF0ZSBsbCBsdiAoY3JlYXRlIGxyIHYgcilcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgbWF0Y2ggbHIgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgICAgfCBMZWFmIGxydiAtPlxuICAgICAgICAgICAgYXNzZXJ0IChpc19lbXB0eSBsbCk7XG4gICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsbCBsdiBFbXB0eSkgbHJ2IChjcmVhdGUgRW1wdHkgdiByKVxuICAgICAgICAgIHwgTm9kZSAobHJsLCBscnYsIGxyciwgXywgXykgLT4gY3JlYXRlIChjcmVhdGUgbGwgbHYgbHJsKSBscnYgKGNyZWF0ZSBscnIgdiByKSkpXG4gICAgZWxzZSBpZiBociA+IGhsICsgMlxuICAgIHRoZW4gKFxuICAgICAgbWF0Y2ggciB3aXRoXG4gICAgICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICAgICAgfCBMZWFmIF8gLT4gYXNzZXJ0IGZhbHNlICgqIGJlY2F1c2UgaChyKT5oKGwpKzIgYW5kIGgobGVhZik9MSAqKVxuICAgICAgfCBOb2RlIChybCwgcnYsIHJyLCBfLCBfKSAtPlxuICAgICAgICBpZiBoZWlnaHQgcnIgPj0gaGVpZ2h0IHJsXG4gICAgICAgIHRoZW4gY3JlYXRlIChjcmVhdGUgbCB2IHJsKSBydiByclxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBtYXRjaCBybCB3aXRoXG4gICAgICAgICAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgICB8IExlYWYgcmx2IC0+XG4gICAgICAgICAgICBhc3NlcnQgKGlzX2VtcHR5IHJyKTtcbiAgICAgICAgICAgIGNyZWF0ZSAoY3JlYXRlIGwgdiBFbXB0eSkgcmx2IChjcmVhdGUgRW1wdHkgcnYgcnIpXG4gICAgICAgICAgfCBOb2RlIChybGwsIHJsdiwgcmxyLCBfLCBfKSAtPiBjcmVhdGUgKGNyZWF0ZSBsIHYgcmxsKSBybHYgKGNyZWF0ZSBybHIgcnYgcnIpKSlcbiAgICBlbHNlIChcbiAgICAgIGxldCBoID0gaWYgaGwgPj0gaHIgdGhlbiBobCArIDEgZWxzZSBociArIDEgaW5cbiAgICAgIGxldCBzbCA9XG4gICAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IDBcbiAgICAgICAgfCBMZWFmIF8gLT4gMVxuICAgICAgICB8IE5vZGUgKF8sIF8sIF8sIF8sIHMpIC0+IHNcbiAgICAgIGluXG4gICAgICBsZXQgc3IgPVxuICAgICAgICBtYXRjaCByIHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPiAwXG4gICAgICAgIHwgTGVhZiBfIC0+IDFcbiAgICAgICAgfCBOb2RlIChfLCBfLCBfLCBfLCBzKSAtPiBzXG4gICAgICBpblxuICAgICAgaWYgaCA9IDEgdGhlbiBMZWFmIHYgZWxzZSBOb2RlIChsLCB2LCByLCBoLCBzbCArIHNyICsgMSkpXG4gIDs7XG5cbiAgKCogSW5zZXJ0aW9uIG9mIG9uZSBlbGVtZW50ICopXG5cbiAgZXhjZXB0aW9uIFNhbWVcblxuICBsZXQgYWRkIHQgeCB+Y29tcGFyZV9lbHQgPVxuICAgIGxldCByZWMgYXV4ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gTGVhZiB4XG4gICAgICB8IExlYWYgdiAtPlxuICAgICAgICBsZXQgYyA9IGNvbXBhcmVfZWx0IHggdiBpblxuICAgICAgICBpZiBjID0gMFxuICAgICAgICB0aGVuIHJhaXNlIFNhbWVcbiAgICAgICAgZWxzZSBpZiBjIDwgMFxuICAgICAgICB0aGVuIGNyZWF0ZSAoTGVhZiB4KSB2IEVtcHR5XG4gICAgICAgIGVsc2UgY3JlYXRlIEVtcHR5IHYgKExlYWYgeClcbiAgICAgIHwgTm9kZSAobCwgdiwgciwgXywgXykgLT5cbiAgICAgICAgbGV0IGMgPSBjb21wYXJlX2VsdCB4IHYgaW5cbiAgICAgICAgaWYgYyA9IDAgdGhlbiByYWlzZSBTYW1lIGVsc2UgaWYgYyA8IDAgdGhlbiBiYWwgKGF1eCBsKSB2IHIgZWxzZSBiYWwgbCB2IChhdXggcilcbiAgICBpblxuICAgIHRyeSBhdXggdCB3aXRoXG4gICAgfCBTYW1lIC0+IHRcbiAgOztcblxuICAoKiBTYW1lIGFzIGNyZWF0ZSBhbmQgYmFsLCBidXQgbm8gYXNzdW1wdGlvbnMgYXJlIG1hZGUgb24gdGhlIHJlbGF0aXZlIGhlaWdodHMgb2YgbCBhbmRcbiAgICAgci4gKilcbiAgbGV0IHJlYyBqb2luIGwgdiByIH5jb21wYXJlX2VsdCA9XG4gICAgbWF0Y2ggbCwgciB3aXRoXG4gICAgfCBFbXB0eSwgXyAtPiBhZGQgciB2IH5jb21wYXJlX2VsdFxuICAgIHwgXywgRW1wdHkgLT4gYWRkIGwgdiB+Y29tcGFyZV9lbHRcbiAgICB8IExlYWYgbHYsIF8gLT4gYWRkIChhZGQgciB2IH5jb21wYXJlX2VsdCkgbHYgfmNvbXBhcmVfZWx0XG4gICAgfCBfLCBMZWFmIHJ2IC0+IGFkZCAoYWRkIGwgdiB+Y29tcGFyZV9lbHQpIHJ2IH5jb21wYXJlX2VsdFxuICAgIHwgTm9kZSAobGwsIGx2LCBsciwgbGgsIF8pLCBOb2RlIChybCwgcnYsIHJyLCByaCwgXykgLT5cbiAgICAgIGlmIGxoID4gcmggKyAyXG4gICAgICB0aGVuIGJhbCBsbCBsdiAoam9pbiBsciB2IHIgfmNvbXBhcmVfZWx0KVxuICAgICAgZWxzZSBpZiByaCA+IGxoICsgMlxuICAgICAgdGhlbiBiYWwgKGpvaW4gbCB2IHJsIH5jb21wYXJlX2VsdCkgcnYgcnJcbiAgICAgIGVsc2UgY3JlYXRlIGwgdiByXG4gIDs7XG5cbiAgKCogU21hbGxlc3QgYW5kIGdyZWF0ZXN0IGVsZW1lbnQgb2YgYSBzZXQgKilcbiAgbGV0IHJlYyBtaW5fZWx0ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICB8IExlYWYgdiB8IE5vZGUgKEVtcHR5LCB2LCBfLCBfLCBfKSAtPiBTb21lIHZcbiAgICB8IE5vZGUgKGwsIF8sIF8sIF8sIF8pIC0+IG1pbl9lbHQgbFxuICA7O1xuXG4gIGV4Y2VwdGlvbiBTZXRfbWluX2VsdF9leG5fb2ZfZW1wdHlfc2V0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwXVxuXG4gIGxldCAoKSA9XG4gICAgU2V4cGxpYjAuU2V4cF9jb252LkV4bl9jb252ZXJ0ZXIuYWRkXG4gICAgICBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBTZXRfbWluX2VsdF9leG5fb2ZfZW1wdHlfc2V0XVxuICAgICAgKGZ1bmN0aW9uXG4gICAgICAgIHwgU2V0X21pbl9lbHRfZXhuX29mX2VtcHR5X3NldCAtPlxuICAgICAgICAgIFNleHBsaWIwLlNleHAuQXRvbSBcInNldC5tbC5UcmVlMC5TZXRfbWluX2VsdF9leG5fb2ZfZW1wdHlfc2V0XCJcbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSlcbiAgOztcblxuICBbQEBAZW5kXVxuXG4gIGV4Y2VwdGlvbiBTZXRfbWF4X2VsdF9leG5fb2ZfZW1wdHlfc2V0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwXVxuXG4gIGxldCAoKSA9XG4gICAgU2V4cGxpYjAuU2V4cF9jb252LkV4bl9jb252ZXJ0ZXIuYWRkXG4gICAgICBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBTZXRfbWF4X2VsdF9leG5fb2ZfZW1wdHlfc2V0XVxuICAgICAgKGZ1bmN0aW9uXG4gICAgICAgIHwgU2V0X21heF9lbHRfZXhuX29mX2VtcHR5X3NldCAtPlxuICAgICAgICAgIFNleHBsaWIwLlNleHAuQXRvbSBcInNldC5tbC5UcmVlMC5TZXRfbWF4X2VsdF9leG5fb2ZfZW1wdHlfc2V0XCJcbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSlcbiAgOztcblxuICBbQEBAZW5kXVxuXG4gIGxldCBtaW5fZWx0X2V4biB0ID1cbiAgICBtYXRjaCBtaW5fZWx0IHQgd2l0aFxuICAgIHwgTm9uZSAtPiByYWlzZSBTZXRfbWluX2VsdF9leG5fb2ZfZW1wdHlfc2V0XG4gICAgfCBTb21lIHYgLT4gdlxuICA7O1xuXG4gIGxldCBmb2xkX3VudGlsIHQgfmluaXQgfmYgfmZpbmlzaCA9XG4gICAgbGV0IHJlYyBmb2xkX3VudGlsX2hlbHBlciB+ZiB0IGFjYyA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gQ29udGFpbmVyLkNvbnRpbnVlX29yX3N0b3AuQ29udGludWUgYWNjXG4gICAgICB8IExlYWYgdmFsdWUgLT4gZiBhY2MgdmFsdWVcbiAgICAgIHwgTm9kZSAobGVmdCwgdmFsdWUsIHJpZ2h0LCBfLCBfKSAtPlxuICAgICAgICAobWF0Y2ggZm9sZF91bnRpbF9oZWxwZXIgfmYgbGVmdCBhY2Mgd2l0aFxuICAgICAgICAgfCBTdG9wIF9hIGFzIHggLT4geFxuICAgICAgICAgfCBDb250aW51ZSBhY2MgLT5cbiAgICAgICAgICAgKG1hdGNoIGYgYWNjIHZhbHVlIHdpdGhcbiAgICAgICAgICAgIHwgU3RvcCBfYSBhcyB4IC0+IHhcbiAgICAgICAgICAgIHwgQ29udGludWUgYSAtPiBmb2xkX3VudGlsX2hlbHBlciB+ZiByaWdodCBhKSlcbiAgICBpblxuICAgIG1hdGNoIGZvbGRfdW50aWxfaGVscGVyIH5mIHQgaW5pdCB3aXRoXG4gICAgfCBDb250aW51ZSB4IC0+IGZpbmlzaCB4XG4gICAgfCBTdG9wIHggLT4geFxuICA7O1xuXG4gIGxldCByZWMgbWF4X2VsdCA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPiBOb25lXG4gICAgfCBMZWFmIHYgfCBOb2RlIChfLCB2LCBFbXB0eSwgXywgXykgLT4gU29tZSB2XG4gICAgfCBOb2RlIChfLCBfLCByLCBfLCBfKSAtPiBtYXhfZWx0IHJcbiAgOztcblxuICBsZXQgbWF4X2VsdF9leG4gdCA9XG4gICAgbWF0Y2ggbWF4X2VsdCB0IHdpdGhcbiAgICB8IE5vbmUgLT4gcmFpc2UgU2V0X21heF9lbHRfZXhuX29mX2VtcHR5X3NldFxuICAgIHwgU29tZSB2IC0+IHZcbiAgOztcblxuICAoKiBSZW1vdmUgdGhlIHNtYWxsZXN0IGVsZW1lbnQgb2YgdGhlIGdpdmVuIHNldCAqKVxuXG4gIGxldCByZWMgcmVtb3ZlX21pbl9lbHQgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJTZXQucmVtb3ZlX21pbl9lbHRcIlxuICAgIHwgTGVhZiBfIC0+IEVtcHR5XG4gICAgfCBOb2RlIChFbXB0eSwgXywgciwgXywgXykgLT4gclxuICAgIHwgTm9kZSAobCwgdiwgciwgXywgXykgLT4gYmFsIChyZW1vdmVfbWluX2VsdCBsKSB2IHJcbiAgOztcblxuICAoKiBNZXJnZSB0d28gdHJlZXMgbCBhbmQgciBpbnRvIG9uZS4gIEFsbCBlbGVtZW50cyBvZiBsIG11c3QgcHJlY2VkZSB0aGUgZWxlbWVudHMgb2Ygci5cbiAgICAgQXNzdW1lIHwgaGVpZ2h0IGwgLSBoZWlnaHQgciB8IDw9IDIuICopXG4gIGxldCBtZXJnZSB0MSB0MiA9XG4gICAgbWF0Y2ggdDEsIHQyIHdpdGhcbiAgICB8IEVtcHR5LCB0IC0+IHRcbiAgICB8IHQsIEVtcHR5IC0+IHRcbiAgICB8IF8sIF8gLT4gYmFsIHQxIChtaW5fZWx0X2V4biB0MikgKHJlbW92ZV9taW5fZWx0IHQyKVxuICA7O1xuXG4gICgqIE1lcmdlIHR3byB0cmVlcyBsIGFuZCByIGludG8gb25lLiAgQWxsIGVsZW1lbnRzIG9mIGwgbXVzdCBwcmVjZWRlIHRoZSBlbGVtZW50cyBvZiByLlxuICAgICBObyBhc3N1bXB0aW9uIG9uIHRoZSBoZWlnaHRzIG9mIGwgYW5kIHIuICopXG4gIGxldCBjb25jYXQgdDEgdDIgfmNvbXBhcmVfZWx0ID1cbiAgICBtYXRjaCB0MSwgdDIgd2l0aFxuICAgIHwgRW1wdHksIHQgfCB0LCBFbXB0eSAtPiB0XG4gICAgfCBfLCBfIC0+IGpvaW4gdDEgKG1pbl9lbHRfZXhuIHQyKSAocmVtb3ZlX21pbl9lbHQgdDIpIH5jb21wYXJlX2VsdFxuICA7O1xuXG4gIGxldCBzcGxpdCB0IHggfmNvbXBhcmVfZWx0ID1cbiAgICBsZXQgcmVjIHNwbGl0IHQgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IEVtcHR5IC0+IEVtcHR5LCBOb25lLCBFbXB0eVxuICAgICAgfCBMZWFmIHYgLT5cbiAgICAgICAgbGV0IGMgPSBjb21wYXJlX2VsdCB4IHYgaW5cbiAgICAgICAgaWYgYyA9IDBcbiAgICAgICAgdGhlbiBFbXB0eSwgU29tZSB2LCBFbXB0eVxuICAgICAgICBlbHNlIGlmIGMgPCAwXG4gICAgICAgIHRoZW4gRW1wdHksIE5vbmUsIExlYWYgdlxuICAgICAgICBlbHNlIExlYWYgdiwgTm9uZSwgRW1wdHlcbiAgICAgIHwgTm9kZSAobCwgdiwgciwgXywgXykgLT5cbiAgICAgICAgbGV0IGMgPSBjb21wYXJlX2VsdCB4IHYgaW5cbiAgICAgICAgaWYgYyA9IDBcbiAgICAgICAgdGhlbiBsLCBTb21lIHYsIHJcbiAgICAgICAgZWxzZSBpZiBjIDwgMFxuICAgICAgICB0aGVuIChcbiAgICAgICAgICBsZXQgbGwsIG1heWJlX2VsdCwgcmwgPSBzcGxpdCBsIGluXG4gICAgICAgICAgbGwsIG1heWJlX2VsdCwgam9pbiBybCB2IHIgfmNvbXBhcmVfZWx0KVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBsZXQgbHIsIG1heWJlX2VsdCwgcnIgPSBzcGxpdCByIGluXG4gICAgICAgICAgam9pbiBsIHYgbHIgfmNvbXBhcmVfZWx0LCBtYXliZV9lbHQsIHJyKVxuICAgIGluXG4gICAgc3BsaXQgdFxuICA7O1xuXG4gICgqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBzZXQgb3BlcmF0aW9ucyAqKVxuXG4gIGxldCBlbXB0eSA9IEVtcHR5XG5cbiAgbGV0IHJlYyBtZW0gdCB4IH5jb21wYXJlX2VsdCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBmYWxzZVxuICAgIHwgTGVhZiB2IC0+XG4gICAgICBsZXQgYyA9IGNvbXBhcmVfZWx0IHggdiBpblxuICAgICAgYyA9IDBcbiAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIF8pIC0+XG4gICAgICBsZXQgYyA9IGNvbXBhcmVfZWx0IHggdiBpblxuICAgICAgYyA9IDAgfHwgbWVtIChpZiBjIDwgMCB0aGVuIGwgZWxzZSByKSB4IH5jb21wYXJlX2VsdFxuICA7O1xuXG4gIGxldCBzaW5nbGV0b24geCA9IExlYWYgeFxuXG4gIGxldCByZW1vdmUgdCB4IH5jb21wYXJlX2VsdCA9XG4gICAgbGV0IHJlYyBhdXggdCA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gcmFpc2UgU2FtZVxuICAgICAgfCBMZWFmIHYgLT4gaWYgY29tcGFyZV9lbHQgeCB2ID0gMCB0aGVuIEVtcHR5IGVsc2UgcmFpc2UgU2FtZVxuICAgICAgfCBOb2RlIChsLCB2LCByLCBfLCBfKSAtPlxuICAgICAgICBsZXQgYyA9IGNvbXBhcmVfZWx0IHggdiBpblxuICAgICAgICBpZiBjID0gMCB0aGVuIG1lcmdlIGwgciBlbHNlIGlmIGMgPCAwIHRoZW4gYmFsIChhdXggbCkgdiByIGVsc2UgYmFsIGwgdiAoYXV4IHIpXG4gICAgaW5cbiAgICB0cnkgYXV4IHQgd2l0aFxuICAgIHwgU2FtZSAtPiB0XG4gIDs7XG5cbiAgbGV0IHJlbW92ZV9pbmRleCB0IGkgfmNvbXBhcmVfZWx0Ol8gPVxuICAgIGxldCByZWMgYXV4IHQgaSA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gcmFpc2UgU2FtZVxuICAgICAgfCBMZWFmIF8gLT4gaWYgaSA9IDAgdGhlbiBFbXB0eSBlbHNlIHJhaXNlIFNhbWVcbiAgICAgIHwgTm9kZSAobCwgdiwgciwgXywgXykgLT5cbiAgICAgICAgbGV0IGxfc2l6ZSA9IGxlbmd0aCBsIGluXG4gICAgICAgIGxldCBjID0gUG9seS5jb21wYXJlIGkgbF9zaXplIGluXG4gICAgICAgIGlmIGMgPSAwXG4gICAgICAgIHRoZW4gbWVyZ2UgbCByXG4gICAgICAgIGVsc2UgaWYgYyA8IDBcbiAgICAgICAgdGhlbiBiYWwgKGF1eCBsIGkpIHYgclxuICAgICAgICBlbHNlIGJhbCBsIHYgKGF1eCByIChpIC0gbF9zaXplIC0gMSkpXG4gICAgaW5cbiAgICB0cnkgYXV4IHQgaSB3aXRoXG4gICAgfCBTYW1lIC0+IHRcbiAgOztcblxuICBsZXQgdW5pb24gczEgczIgfmNvbXBhcmVfZWx0ID1cbiAgICBsZXQgcmVjIHVuaW9uIHMxIHMyID1cbiAgICAgIGlmIHBoeXNfZXF1YWwgczEgczJcbiAgICAgIHRoZW4gczFcbiAgICAgIGVsc2UgKFxuICAgICAgICBtYXRjaCBzMSwgczIgd2l0aFxuICAgICAgICB8IEVtcHR5LCB0IHwgdCwgRW1wdHkgLT4gdFxuICAgICAgICB8IExlYWYgdjEsIF8gLT4gdW5pb24gKE5vZGUgKEVtcHR5LCB2MSwgRW1wdHksIDEsIDEpKSBzMlxuICAgICAgICB8IF8sIExlYWYgdjIgLT4gdW5pb24gczEgKE5vZGUgKEVtcHR5LCB2MiwgRW1wdHksIDEsIDEpKVxuICAgICAgICB8IE5vZGUgKGwxLCB2MSwgcjEsIGgxLCBfKSwgTm9kZSAobDIsIHYyLCByMiwgaDIsIF8pIC0+XG4gICAgICAgICAgaWYgaDEgPj0gaDJcbiAgICAgICAgICB0aGVuXG4gICAgICAgICAgICBpZiBoMiA9IDFcbiAgICAgICAgICAgIHRoZW4gYWRkIHMxIHYyIH5jb21wYXJlX2VsdFxuICAgICAgICAgICAgZWxzZSAoXG4gICAgICAgICAgICAgIGxldCBsMiwgXywgcjIgPSBzcGxpdCBzMiB2MSB+Y29tcGFyZV9lbHQgaW5cbiAgICAgICAgICAgICAgam9pbiAodW5pb24gbDEgbDIpIHYxICh1bmlvbiByMSByMikgfmNvbXBhcmVfZWx0KVxuICAgICAgICAgIGVsc2UgaWYgaDEgPSAxXG4gICAgICAgICAgdGhlbiBhZGQgczIgdjEgfmNvbXBhcmVfZWx0XG4gICAgICAgICAgZWxzZSAoXG4gICAgICAgICAgICBsZXQgbDEsIF8sIHIxID0gc3BsaXQgczEgdjIgfmNvbXBhcmVfZWx0IGluXG4gICAgICAgICAgICBqb2luICh1bmlvbiBsMSBsMikgdjIgKHVuaW9uIHIxIHIyKSB+Y29tcGFyZV9lbHQpKVxuICAgIGluXG4gICAgdW5pb24gczEgczJcbiAgOztcblxuICBsZXQgdW5pb25fbGlzdCB+Y29tcGFyYXRvciB+dG9fdHJlZSB4cyA9XG4gICAgbGV0IGNvbXBhcmVfZWx0ID0gY29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgaW5cbiAgICBMaXN0LmZvbGQgeHMgfmluaXQ6ZW1wdHkgfmY6KGZ1biBhYyB4IC0+IHVuaW9uIGFjICh0b190cmVlIHgpIH5jb21wYXJlX2VsdClcbiAgOztcblxuICBsZXQgaW50ZXIgczEgczIgfmNvbXBhcmVfZWx0ID1cbiAgICBsZXQgcmVjIGludGVyIHMxIHMyID1cbiAgICAgIGlmIHBoeXNfZXF1YWwgczEgczJcbiAgICAgIHRoZW4gczFcbiAgICAgIGVsc2UgKFxuICAgICAgICBtYXRjaCBzMSwgczIgd2l0aFxuICAgICAgICB8IEVtcHR5LCBfIHwgXywgRW1wdHkgLT4gRW1wdHlcbiAgICAgICAgfCAoTGVhZiBlbHQgYXMgc2luZ2xldG9uKSwgb3RoZXJfc2V0IHwgb3RoZXJfc2V0LCAoTGVhZiBlbHQgYXMgc2luZ2xldG9uKSAtPlxuICAgICAgICAgIGlmIG1lbSBvdGhlcl9zZXQgZWx0IH5jb21wYXJlX2VsdCB0aGVuIHNpbmdsZXRvbiBlbHNlIEVtcHR5XG4gICAgICAgIHwgTm9kZSAobDEsIHYxLCByMSwgXywgXyksIHQyIC0+XG4gICAgICAgICAgKG1hdGNoIHNwbGl0IHQyIHYxIH5jb21wYXJlX2VsdCB3aXRoXG4gICAgICAgICAgIHwgbDIsIE5vbmUsIHIyIC0+IGNvbmNhdCAoaW50ZXIgbDEgbDIpIChpbnRlciByMSByMikgfmNvbXBhcmVfZWx0XG4gICAgICAgICAgIHwgbDIsIFNvbWUgdjEsIHIyIC0+IGpvaW4gKGludGVyIGwxIGwyKSB2MSAoaW50ZXIgcjEgcjIpIH5jb21wYXJlX2VsdCkpXG4gICAgaW5cbiAgICBpbnRlciBzMSBzMlxuICA7O1xuXG4gIGxldCBkaWZmIHMxIHMyIH5jb21wYXJlX2VsdCA9XG4gICAgbGV0IHJlYyBkaWZmIHMxIHMyID1cbiAgICAgIGlmIHBoeXNfZXF1YWwgczEgczJcbiAgICAgIHRoZW4gRW1wdHlcbiAgICAgIGVsc2UgKFxuICAgICAgICBtYXRjaCBzMSwgczIgd2l0aFxuICAgICAgICB8IEVtcHR5LCBfIC0+IEVtcHR5XG4gICAgICAgIHwgdDEsIEVtcHR5IC0+IHQxXG4gICAgICAgIHwgTGVhZiB2MSwgdDIgLT4gZGlmZiAoTm9kZSAoRW1wdHksIHYxLCBFbXB0eSwgMSwgMSkpIHQyXG4gICAgICAgIHwgTm9kZSAobDEsIHYxLCByMSwgXywgXyksIHQyIC0+XG4gICAgICAgICAgKG1hdGNoIHNwbGl0IHQyIHYxIH5jb21wYXJlX2VsdCB3aXRoXG4gICAgICAgICAgIHwgbDIsIE5vbmUsIHIyIC0+IGpvaW4gKGRpZmYgbDEgbDIpIHYxIChkaWZmIHIxIHIyKSB+Y29tcGFyZV9lbHRcbiAgICAgICAgICAgfCBsMiwgU29tZSBfLCByMiAtPiBjb25jYXQgKGRpZmYgbDEgbDIpIChkaWZmIHIxIHIyKSB+Y29tcGFyZV9lbHQpKVxuICAgIGluXG4gICAgZGlmZiBzMSBzMlxuICA7O1xuXG4gIG1vZHVsZSBFbnVtID0gc3RydWN0XG4gICAgdHlwZSBpbmNyZWFzaW5nXG4gICAgdHlwZSBkZWNyZWFzaW5nXG5cbiAgICB0eXBlICgnYSwgJ2RpcmVjdGlvbikgdCA9XG4gICAgICB8IEVuZFxuICAgICAgfCBNb3JlIG9mICdhICogJ2EgdHJlZSAqICgnYSwgJ2RpcmVjdGlvbikgdFxuXG4gICAgbGV0IHJlYyBjb25zIHMgKGUgOiAoXywgaW5jcmVhc2luZykgdCkgOiAoXywgaW5jcmVhc2luZykgdCA9XG4gICAgICBtYXRjaCBzIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gZVxuICAgICAgfCBMZWFmIHYgLT4gTW9yZSAodiwgRW1wdHksIGUpXG4gICAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIF8pIC0+IGNvbnMgbCAoTW9yZSAodiwgciwgZSkpXG4gICAgOztcblxuICAgIGxldCByZWMgY29uc19yaWdodCBzIChlIDogKF8sIGRlY3JlYXNpbmcpIHQpIDogKF8sIGRlY3JlYXNpbmcpIHQgPVxuICAgICAgbWF0Y2ggcyB3aXRoXG4gICAgICB8IEVtcHR5IC0+IGVcbiAgICAgIHwgTGVhZiB2IC0+IE1vcmUgKHYsIEVtcHR5LCBlKVxuICAgICAgfCBOb2RlIChsLCB2LCByLCBfLCBfKSAtPiBjb25zX3JpZ2h0IHIgKE1vcmUgKHYsIGwsIGUpKVxuICAgIDs7XG5cbiAgICBsZXQgb2Zfc2V0IHMgOiAoXywgaW5jcmVhc2luZykgdCA9IGNvbnMgcyBFbmRcbiAgICBsZXQgb2Zfc2V0X3JpZ2h0IHMgOiAoXywgZGVjcmVhc2luZykgdCA9IGNvbnNfcmlnaHQgcyBFbmRcblxuICAgIGxldCBzdGFydGluZ19hdF9pbmNyZWFzaW5nIHQga2V5IGNvbXBhcmUgOiAoXywgaW5jcmVhc2luZykgdCA9XG4gICAgICBsZXQgcmVjIGxvb3AgdCBlID1cbiAgICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICAgIHwgRW1wdHkgLT4gZVxuICAgICAgICB8IExlYWYgdiAtPiBsb29wIChOb2RlIChFbXB0eSwgdiwgRW1wdHksIDEsIDEpKSBlXG4gICAgICAgIHwgTm9kZSAoXywgdiwgciwgXywgXykgd2hlbiBjb21wYXJlIHYga2V5IDwgMCAtPiBsb29wIHIgZVxuICAgICAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIF8pIC0+IGxvb3AgbCAoTW9yZSAodiwgciwgZSkpXG4gICAgICBpblxuICAgICAgbG9vcCB0IEVuZFxuICAgIDs7XG5cbiAgICBsZXQgc3RhcnRpbmdfYXRfZGVjcmVhc2luZyB0IGtleSBjb21wYXJlIDogKF8sIGRlY3JlYXNpbmcpIHQgPVxuICAgICAgbGV0IHJlYyBsb29wIHQgZSA9XG4gICAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IGVcbiAgICAgICAgfCBMZWFmIHYgLT4gbG9vcCAoTm9kZSAoRW1wdHksIHYsIEVtcHR5LCAxLCAxKSkgZVxuICAgICAgICB8IE5vZGUgKGwsIHYsIF8sIF8sIF8pIHdoZW4gY29tcGFyZSB2IGtleSA+IDAgLT4gbG9vcCBsIGVcbiAgICAgICAgfCBOb2RlIChsLCB2LCByLCBfLCBfKSAtPiBsb29wIHIgKE1vcmUgKHYsIGwsIGUpKVxuICAgICAgaW5cbiAgICAgIGxvb3AgdCBFbmRcbiAgICA7O1xuXG4gICAgbGV0IGNvbXBhcmUgY29tcGFyZV9lbHQgZTEgZTIgPVxuICAgICAgbGV0IHJlYyBsb29wIGUxIGUyID1cbiAgICAgICAgbWF0Y2ggZTEsIGUyIHdpdGhcbiAgICAgICAgfCBFbmQsIEVuZCAtPiAwXG4gICAgICAgIHwgRW5kLCBfIC0+IC0xXG4gICAgICAgIHwgXywgRW5kIC0+IDFcbiAgICAgICAgfCBNb3JlICh2MSwgcjEsIGUxKSwgTW9yZSAodjIsIHIyLCBlMikgLT5cbiAgICAgICAgICBsZXQgYyA9IGNvbXBhcmVfZWx0IHYxIHYyIGluXG4gICAgICAgICAgaWYgYyA8PiAwXG4gICAgICAgICAgdGhlbiBjXG4gICAgICAgICAgZWxzZSBpZiBwaHlzX2VxdWFsIHIxIHIyXG4gICAgICAgICAgdGhlbiBsb29wIGUxIGUyXG4gICAgICAgICAgZWxzZSBsb29wIChjb25zIHIxIGUxKSAoY29ucyByMiBlMilcbiAgICAgIGluXG4gICAgICBsb29wIGUxIGUyXG4gICAgOztcblxuICAgIGxldCByZWMgaXRlciB+ZiA9IGZ1bmN0aW9uXG4gICAgICB8IEVuZCAtPiAoKVxuICAgICAgfCBNb3JlIChhLCB0cmVlLCBlbnVtKSAtPlxuICAgICAgICBmIGE7XG4gICAgICAgIGl0ZXIgKGNvbnMgdHJlZSBlbnVtKSB+ZlxuICAgIDs7XG5cbiAgICBsZXQgaXRlcjIgY29tcGFyZV9lbHQgdDEgdDIgfmYgPVxuICAgICAgbGV0IHJlYyBsb29wIHQxIHQyID1cbiAgICAgICAgbWF0Y2ggdDEsIHQyIHdpdGhcbiAgICAgICAgfCBFbmQsIEVuZCAtPiAoKVxuICAgICAgICB8IEVuZCwgXyAtPiBpdGVyIHQyIH5mOihmdW4gYSAtPiBmIChgUmlnaHQgYSkpXG4gICAgICAgIHwgXywgRW5kIC0+IGl0ZXIgdDEgfmY6KGZ1biBhIC0+IGYgKGBMZWZ0IGEpKVxuICAgICAgICB8IE1vcmUgKGExLCB0cmVlMSwgZW51bTEpLCBNb3JlIChhMiwgdHJlZTIsIGVudW0yKSAtPlxuICAgICAgICAgIGxldCBjb21wYXJlX3Jlc3VsdCA9IGNvbXBhcmVfZWx0IGExIGEyIGluXG4gICAgICAgICAgaWYgY29tcGFyZV9yZXN1bHQgPSAwXG4gICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICBmIChgQm90aCAoYTEsIGEyKSk7XG4gICAgICAgICAgICBsb29wIChjb25zIHRyZWUxIGVudW0xKSAoY29ucyB0cmVlMiBlbnVtMikpXG4gICAgICAgICAgZWxzZSBpZiBjb21wYXJlX3Jlc3VsdCA8IDBcbiAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgIGYgKGBMZWZ0IGExKTtcbiAgICAgICAgICAgIGxvb3AgKGNvbnMgdHJlZTEgZW51bTEpIHQyKVxuICAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICAgZiAoYFJpZ2h0IGEyKTtcbiAgICAgICAgICAgIGxvb3AgdDEgKGNvbnMgdHJlZTIgZW51bTIpKVxuICAgICAgaW5cbiAgICAgIGxvb3AgdDEgdDJcbiAgICA7O1xuXG4gICAgbGV0IHN5bW1ldHJpY19kaWZmIHQxIHQyIH5jb21wYXJlX2VsdCA9XG4gICAgICBsZXQgc3RlcCBzdGF0ZSA6ICgoXywgXykgRWl0aGVyLnQsIF8pIFNlcXVlbmNlLlN0ZXAudCA9XG4gICAgICAgIG1hdGNoIHN0YXRlIHdpdGhcbiAgICAgICAgfCBFbmQsIEVuZCAtPiBEb25lXG4gICAgICAgIHwgRW5kLCBNb3JlIChlbHQsIHRyZWUsIGVudW0pIC0+IFlpZWxkIChTZWNvbmQgZWx0LCAoRW5kLCBjb25zIHRyZWUgZW51bSkpXG4gICAgICAgIHwgTW9yZSAoZWx0LCB0cmVlLCBlbnVtKSwgRW5kIC0+IFlpZWxkIChGaXJzdCBlbHQsIChjb25zIHRyZWUgZW51bSwgRW5kKSlcbiAgICAgICAgfCAoTW9yZSAoYTEsIHRyZWUxLCBlbnVtMSkgYXMgbGVmdCksIChNb3JlIChhMiwgdHJlZTIsIGVudW0yKSBhcyByaWdodCkgLT5cbiAgICAgICAgICBsZXQgY29tcGFyZV9yZXN1bHQgPSBjb21wYXJlX2VsdCBhMSBhMiBpblxuICAgICAgICAgIGlmIGNvbXBhcmVfcmVzdWx0ID0gMFxuICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgbGV0IG5leHRfc3RhdGUgPVxuICAgICAgICAgICAgICBpZiBwaHlzX2VxdWFsIHRyZWUxIHRyZWUyXG4gICAgICAgICAgICAgIHRoZW4gZW51bTEsIGVudW0yXG4gICAgICAgICAgICAgIGVsc2UgY29ucyB0cmVlMSBlbnVtMSwgY29ucyB0cmVlMiBlbnVtMlxuICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIFNraXAgbmV4dF9zdGF0ZSlcbiAgICAgICAgICBlbHNlIGlmIGNvbXBhcmVfcmVzdWx0IDwgMFxuICAgICAgICAgIHRoZW4gWWllbGQgKEZpcnN0IGExLCAoY29ucyB0cmVlMSBlbnVtMSwgcmlnaHQpKVxuICAgICAgICAgIGVsc2UgWWllbGQgKFNlY29uZCBhMiwgKGxlZnQsIGNvbnMgdHJlZTIgZW51bTIpKVxuICAgICAgaW5cbiAgICAgIFNlcXVlbmNlLnVuZm9sZF9zdGVwIH5pbml0OihvZl9zZXQgdDEsIG9mX3NldCB0MikgfmY6c3RlcFxuICAgIDs7XG4gIGVuZFxuXG4gIGxldCB0b19zZXF1ZW5jZV9pbmNyZWFzaW5nIGNvbXBhcmF0b3IgfmZyb21fZWx0IHQgPVxuICAgIGxldCBuZXh0IGVudW0gPVxuICAgICAgbWF0Y2ggZW51bSB3aXRoXG4gICAgICB8IEVudW0uRW5kIC0+IFNlcXVlbmNlLlN0ZXAuRG9uZVxuICAgICAgfCBFbnVtLk1vcmUgKGssIHQsIGUpIC0+IFNlcXVlbmNlLlN0ZXAuWWllbGQgKGssIEVudW0uY29ucyB0IGUpXG4gICAgaW5cbiAgICBsZXQgaW5pdCA9XG4gICAgICBtYXRjaCBmcm9tX2VsdCB3aXRoXG4gICAgICB8IE5vbmUgLT4gRW51bS5vZl9zZXQgdFxuICAgICAgfCBTb21lIGtleSAtPiBFbnVtLnN0YXJ0aW5nX2F0X2luY3JlYXNpbmcgdCBrZXkgY29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICBpblxuICAgIFNlcXVlbmNlLnVuZm9sZF9zdGVwIH5pbml0IH5mOm5leHRcbiAgOztcblxuICBsZXQgdG9fc2VxdWVuY2VfZGVjcmVhc2luZyBjb21wYXJhdG9yIH5mcm9tX2VsdCB0ID1cbiAgICBsZXQgbmV4dCBlbnVtID1cbiAgICAgIG1hdGNoIGVudW0gd2l0aFxuICAgICAgfCBFbnVtLkVuZCAtPiBTZXF1ZW5jZS5TdGVwLkRvbmVcbiAgICAgIHwgRW51bS5Nb3JlIChrLCB0LCBlKSAtPiBTZXF1ZW5jZS5TdGVwLllpZWxkIChrLCBFbnVtLmNvbnNfcmlnaHQgdCBlKVxuICAgIGluXG4gICAgbGV0IGluaXQgPVxuICAgICAgbWF0Y2ggZnJvbV9lbHQgd2l0aFxuICAgICAgfCBOb25lIC0+IEVudW0ub2Zfc2V0X3JpZ2h0IHRcbiAgICAgIHwgU29tZSBrZXkgLT4gRW51bS5zdGFydGluZ19hdF9kZWNyZWFzaW5nIHQga2V5IGNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgaW5cbiAgICBTZXF1ZW5jZS51bmZvbGRfc3RlcCB+aW5pdCB+ZjpuZXh0XG4gIDs7XG5cbiAgbGV0IHRvX3NlcXVlbmNlXG4gICAgICAgIGNvbXBhcmF0b3JcbiAgICAgICAgPyhvcmRlciA9IGBJbmNyZWFzaW5nKVxuICAgICAgICA/Z3JlYXRlcl9vcl9lcXVhbF90b1xuICAgICAgICA/bGVzc19vcl9lcXVhbF90b1xuICAgICAgICB0XG4gICAgPVxuICAgIGxldCBpbmNsdXNpdmVfYm91bmQgc2lkZSB0IGJvdW5kID1cbiAgICAgIGxldCBjb21wYXJlX2VsdCA9IGNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIGluXG4gICAgICBsZXQgbCwgbWF5YmUsIHIgPSBzcGxpdCB0IGJvdW5kIH5jb21wYXJlX2VsdCBpblxuICAgICAgbGV0IHQgPSBzaWRlIChsLCByKSBpblxuICAgICAgbWF0Y2ggbWF5YmUgd2l0aFxuICAgICAgfCBOb25lIC0+IHRcbiAgICAgIHwgU29tZSBlbHQgLT4gYWRkIHQgZWx0IH5jb21wYXJlX2VsdFxuICAgIGluXG4gICAgbWF0Y2ggb3JkZXIgd2l0aFxuICAgIHwgYEluY3JlYXNpbmcgLT5cbiAgICAgIGxldCB0ID0gT3B0aW9uLmZvbGQgbGVzc19vcl9lcXVhbF90byB+aW5pdDp0IH5mOihpbmNsdXNpdmVfYm91bmQgZnN0KSBpblxuICAgICAgdG9fc2VxdWVuY2VfaW5jcmVhc2luZyBjb21wYXJhdG9yIH5mcm9tX2VsdDpncmVhdGVyX29yX2VxdWFsX3RvIHRcbiAgICB8IGBEZWNyZWFzaW5nIC0+XG4gICAgICBsZXQgdCA9IE9wdGlvbi5mb2xkIGdyZWF0ZXJfb3JfZXF1YWxfdG8gfmluaXQ6dCB+ZjooaW5jbHVzaXZlX2JvdW5kIHNuZCkgaW5cbiAgICAgIHRvX3NlcXVlbmNlX2RlY3JlYXNpbmcgY29tcGFyYXRvciB+ZnJvbV9lbHQ6bGVzc19vcl9lcXVhbF90byB0XG4gIDs7XG5cblxuICBsZXQgcmVjIGZpbmRfZmlyc3Rfc2F0aXNmeWluZyB0IH5mID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICB8IExlYWYgdiAtPiBpZiBmIHYgdGhlbiBTb21lIHYgZWxzZSBOb25lXG4gICAgfCBOb2RlIChsLCB2LCByLCBfLCBfKSAtPlxuICAgICAgaWYgZiB2XG4gICAgICB0aGVuIChcbiAgICAgICAgbWF0Y2ggZmluZF9maXJzdF9zYXRpc2Z5aW5nIGwgfmYgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gU29tZSB2XG4gICAgICAgIHwgU29tZSBfIGFzIHggLT4geClcbiAgICAgIGVsc2UgZmluZF9maXJzdF9zYXRpc2Z5aW5nIHIgfmZcbiAgOztcblxuICBsZXQgcmVjIGZpbmRfbGFzdF9zYXRpc2Z5aW5nIHQgfmYgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgIHwgTGVhZiB2IC0+IGlmIGYgdiB0aGVuIFNvbWUgdiBlbHNlIE5vbmVcbiAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIF8pIC0+XG4gICAgICBpZiBmIHZcbiAgICAgIHRoZW4gKFxuICAgICAgICBtYXRjaCBmaW5kX2xhc3Rfc2F0aXNmeWluZyByIH5mIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IFNvbWUgdlxuICAgICAgICB8IFNvbWUgXyBhcyB4IC0+IHgpXG4gICAgICBlbHNlIGZpbmRfbGFzdF9zYXRpc2Z5aW5nIGwgfmZcbiAgOztcblxuICBsZXQgYmluYXJ5X3NlYXJjaCB0IH5jb21wYXJlIGhvdyB2ID1cbiAgICBtYXRjaCBob3cgd2l0aFxuICAgIHwgYExhc3Rfc3RyaWN0bHlfbGVzc190aGFuIC0+IGZpbmRfbGFzdF9zYXRpc2Z5aW5nIHQgfmY6KGZ1biB4IC0+IGNvbXBhcmUgeCB2IDwgMClcbiAgICB8IGBMYXN0X2xlc3NfdGhhbl9vcl9lcXVhbF90byAtPiBmaW5kX2xhc3Rfc2F0aXNmeWluZyB0IH5mOihmdW4geCAtPiBjb21wYXJlIHggdiA8PSAwKVxuICAgIHwgYEZpcnN0X2VxdWFsX3RvIC0+XG4gICAgICAobWF0Y2ggZmluZF9maXJzdF9zYXRpc2Z5aW5nIHQgfmY6KGZ1biB4IC0+IGNvbXBhcmUgeCB2ID49IDApIHdpdGhcbiAgICAgICB8IFNvbWUgeCBhcyBlbHQgd2hlbiBjb21wYXJlIHggdiA9IDAgLT4gZWx0XG4gICAgICAgfCBOb25lIHwgU29tZSBfIC0+IE5vbmUpXG4gICAgfCBgTGFzdF9lcXVhbF90byAtPlxuICAgICAgKG1hdGNoIGZpbmRfbGFzdF9zYXRpc2Z5aW5nIHQgfmY6KGZ1biB4IC0+IGNvbXBhcmUgeCB2IDw9IDApIHdpdGhcbiAgICAgICB8IFNvbWUgeCBhcyBlbHQgd2hlbiBjb21wYXJlIHggdiA9IDAgLT4gZWx0XG4gICAgICAgfCBOb25lIHwgU29tZSBfIC0+IE5vbmUpXG4gICAgfCBgRmlyc3RfZ3JlYXRlcl90aGFuX29yX2VxdWFsX3RvIC0+XG4gICAgICBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgdCB+ZjooZnVuIHggLT4gY29tcGFyZSB4IHYgPj0gMClcbiAgICB8IGBGaXJzdF9zdHJpY3RseV9ncmVhdGVyX3RoYW4gLT5cbiAgICAgIGZpbmRfZmlyc3Rfc2F0aXNmeWluZyB0IH5mOihmdW4geCAtPiBjb21wYXJlIHggdiA+IDApXG4gIDs7XG5cbiAgbGV0IGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkIHQgfnNlZ21lbnRfb2YgaG93ID1cbiAgICBsZXQgaXNfbGVmdCB4ID1cbiAgICAgIG1hdGNoIHNlZ21lbnRfb2YgeCB3aXRoXG4gICAgICB8IGBMZWZ0IC0+IHRydWVcbiAgICAgIHwgYFJpZ2h0IC0+IGZhbHNlXG4gICAgaW5cbiAgICBsZXQgaXNfcmlnaHQgeCA9IG5vdCAoaXNfbGVmdCB4KSBpblxuICAgIG1hdGNoIGhvdyB3aXRoXG4gICAgfCBgTGFzdF9vbl9sZWZ0IC0+IGZpbmRfbGFzdF9zYXRpc2Z5aW5nIHQgfmY6aXNfbGVmdFxuICAgIHwgYEZpcnN0X29uX3JpZ2h0IC0+IGZpbmRfZmlyc3Rfc2F0aXNmeWluZyB0IH5mOmlzX3JpZ2h0XG4gIDs7XG5cbiAgbGV0IG1lcmdlX3RvX3NlcXVlbmNlXG4gICAgICAgIGNvbXBhcmF0b3JcbiAgICAgICAgPyhvcmRlciA9IGBJbmNyZWFzaW5nKVxuICAgICAgICA/Z3JlYXRlcl9vcl9lcXVhbF90b1xuICAgICAgICA/bGVzc19vcl9lcXVhbF90b1xuICAgICAgICB0XG4gICAgICAgIHQnXG4gICAgPVxuICAgIFNlcXVlbmNlLm1lcmdlX3dpdGhfZHVwbGljYXRlc1xuICAgICAgKHRvX3NlcXVlbmNlIGNvbXBhcmF0b3Igfm9yZGVyID9ncmVhdGVyX29yX2VxdWFsX3RvID9sZXNzX29yX2VxdWFsX3RvIHQpXG4gICAgICAodG9fc2VxdWVuY2UgY29tcGFyYXRvciB+b3JkZXIgP2dyZWF0ZXJfb3JfZXF1YWxfdG8gP2xlc3Nfb3JfZXF1YWxfdG8gdCcpXG4gICAgICB+Y29tcGFyZTpcbiAgICAgICAgKG1hdGNoIG9yZGVyIHdpdGhcbiAgICAgICAgIHwgYEluY3JlYXNpbmcgLT4gY29tcGFyYXRvci5jb21wYXJlXG4gICAgICAgICB8IGBEZWNyZWFzaW5nIC0+IEZuLmZsaXAgY29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBjb21wYXJlIGNvbXBhcmVfZWx0IHMxIHMyID1cbiAgICBFbnVtLmNvbXBhcmUgY29tcGFyZV9lbHQgKEVudW0ub2Zfc2V0IHMxKSAoRW51bS5vZl9zZXQgczIpXG4gIDs7XG5cbiAgbGV0IGl0ZXIyIHMxIHMyIH5jb21wYXJlX2VsdCA9IEVudW0uaXRlcjIgY29tcGFyZV9lbHQgKEVudW0ub2Zfc2V0IHMxKSAoRW51bS5vZl9zZXQgczIpXG4gIGxldCBlcXVhbCBzMSBzMiB+Y29tcGFyZV9lbHQgPSBjb21wYXJlIGNvbXBhcmVfZWx0IHMxIHMyID0gMFxuXG4gIGxldCBpc19zdWJzZXQgczEgfm9mXzpzMiB+Y29tcGFyZV9lbHQgPVxuICAgIGxldCByZWMgaXNfc3Vic2V0IHMxIH5vZl86czIgPVxuICAgICAgbWF0Y2ggczEsIHMyIHdpdGhcbiAgICAgIHwgRW1wdHksIF8gLT4gdHJ1ZVxuICAgICAgfCBfLCBFbXB0eSAtPiBmYWxzZVxuICAgICAgfCBMZWFmIHYxLCB0MiAtPiBtZW0gdDIgdjEgfmNvbXBhcmVfZWx0XG4gICAgICB8IE5vZGUgKGwxLCB2MSwgcjEsIF8sIF8pLCBMZWFmIHYyIC0+XG4gICAgICAgIChtYXRjaCBsMSwgcjEgd2l0aFxuICAgICAgICAgfCBFbXB0eSwgRW1wdHkgLT5cbiAgICAgICAgICAgKCogVGhpcyBjYXNlIHNob3VsZG4ndCBvY2N1ciBpbiBwcmFjdGljZSBiZWNhdXNlIHdlIHNob3VsZCBoYXZlIGNvbnN0cnVjdGVkXG4gICAgICAgICAgICAgIGEgTGVhZiByYXRoZXIgdGhhbiBhIE5vZGUgd2l0aCB0d28gRW1wdHkgc3VidHJlZXMgKilcbiAgICAgICAgICAgY29tcGFyZV9lbHQgdjEgdjIgPSAwXG4gICAgICAgICB8IF8sIF8gLT4gZmFsc2UpXG4gICAgICB8IE5vZGUgKGwxLCB2MSwgcjEsIF8sIF8pLCAoTm9kZSAobDIsIHYyLCByMiwgXywgXykgYXMgdDIpIC0+XG4gICAgICAgIGxldCBjID0gY29tcGFyZV9lbHQgdjEgdjIgaW5cbiAgICAgICAgaWYgYyA9IDBcbiAgICAgICAgdGhlblxuICAgICAgICAgIHBoeXNfZXF1YWwgczEgczIgfHwgKGlzX3N1YnNldCBsMSB+b2ZfOmwyICYmIGlzX3N1YnNldCByMSB+b2ZfOnIyKVxuICAgICAgICAgICgqIE5vdGUgdGhhdCBoZWlnaHQgYW5kIHNpemUgZG9uJ3QgbWF0dGVyIGhlcmUuICopXG4gICAgICAgIGVsc2UgaWYgYyA8IDBcbiAgICAgICAgdGhlbiBpc19zdWJzZXQgKE5vZGUgKGwxLCB2MSwgRW1wdHksIDAsIDApKSB+b2ZfOmwyICYmIGlzX3N1YnNldCByMSB+b2ZfOnQyXG4gICAgICAgIGVsc2UgaXNfc3Vic2V0IChOb2RlIChFbXB0eSwgdjEsIHIxLCAwLCAwKSkgfm9mXzpyMiAmJiBpc19zdWJzZXQgbDEgfm9mXzp0MlxuICAgIGluXG4gICAgaXNfc3Vic2V0IHMxIH5vZl86czJcbiAgOztcblxuICBsZXQgcmVjIGFyZV9kaXNqb2ludCBzMSBzMiB+Y29tcGFyZV9lbHQgPVxuICAgIG1hdGNoIHMxLCBzMiB3aXRoXG4gICAgfCBFbXB0eSwgXyB8IF8sIEVtcHR5IC0+IHRydWVcbiAgICB8IExlYWYgZWx0LCBvdGhlcl9zZXQgfCBvdGhlcl9zZXQsIExlYWYgZWx0IC0+IG5vdCAobWVtIG90aGVyX3NldCBlbHQgfmNvbXBhcmVfZWx0KVxuICAgIHwgTm9kZSAobDEsIHYxLCByMSwgXywgXyksIHQyIC0+XG4gICAgICBpZiBwaHlzX2VxdWFsIHMxIHMyXG4gICAgICB0aGVuIGZhbHNlXG4gICAgICBlbHNlIChcbiAgICAgICAgbWF0Y2ggc3BsaXQgdDIgdjEgfmNvbXBhcmVfZWx0IHdpdGhcbiAgICAgICAgfCBsMiwgTm9uZSwgcjIgLT5cbiAgICAgICAgICBhcmVfZGlzam9pbnQgbDEgbDIgfmNvbXBhcmVfZWx0ICYmIGFyZV9kaXNqb2ludCByMSByMiB+Y29tcGFyZV9lbHRcbiAgICAgICAgfCBfLCBTb21lIF8sIF8gLT4gZmFsc2UpXG4gIDs7XG5cbiAgbGV0IGl0ZXIgdCB+ZiA9XG4gICAgbGV0IHJlYyBpdGVyID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gKClcbiAgICAgIHwgTGVhZiB2IC0+IGYgdlxuICAgICAgfCBOb2RlIChsLCB2LCByLCBfLCBfKSAtPlxuICAgICAgICBpdGVyIGw7XG4gICAgICAgIGYgdjtcbiAgICAgICAgaXRlciByXG4gICAgaW5cbiAgICBpdGVyIHRcbiAgOztcblxuICBsZXQgc3ltbWV0cmljX2RpZmYgPSBFbnVtLnN5bW1ldHJpY19kaWZmXG5cbiAgbGV0IHJlYyBmb2xkIHMgfmluaXQ6YWNjdSB+ZiA9XG4gICAgbWF0Y2ggcyB3aXRoXG4gICAgfCBFbXB0eSAtPiBhY2N1XG4gICAgfCBMZWFmIHYgLT4gZiBhY2N1IHZcbiAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIF8pIC0+IGZvbGQgfmYgciB+aW5pdDooZiAoZm9sZCB+ZiBsIH5pbml0OmFjY3UpIHYpXG4gIDs7XG5cbiAgbGV0IGhhc2hfZm9sZF90X2lnbm9yaW5nX3N0cnVjdHVyZSBoYXNoX2ZvbGRfZWxlbSBzdGF0ZSB0ID1cbiAgICBmb2xkIHQgfmluaXQ6KGhhc2hfZm9sZF9pbnQgc3RhdGUgKGxlbmd0aCB0KSkgfmY6aGFzaF9mb2xkX2VsZW1cbiAgOztcblxuICBsZXQgY291bnQgdCB+ZiA9IENvbnRhaW5lci5jb3VudCB+Zm9sZCB0IH5mXG4gIGxldCBzdW0gbSB0IH5mID0gQ29udGFpbmVyLnN1bSB+Zm9sZCBtIHQgfmZcblxuICBsZXQgcmVjIGZvbGRfcmlnaHQgcyB+aW5pdDphY2N1IH5mID1cbiAgICBtYXRjaCBzIHdpdGhcbiAgICB8IEVtcHR5IC0+IGFjY3VcbiAgICB8IExlYWYgdiAtPiBmIHYgYWNjdVxuICAgIHwgTm9kZSAobCwgdiwgciwgXywgXykgLT4gZm9sZF9yaWdodCB+ZiBsIH5pbml0OihmIHYgKGZvbGRfcmlnaHQgfmYgciB+aW5pdDphY2N1KSlcbiAgOztcblxuICBsZXQgcmVjIGZvcl9hbGwgdCB+ZjpwID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IHRydWVcbiAgICB8IExlYWYgdiAtPiBwIHZcbiAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIF8pIC0+IHAgdiAmJiBmb3JfYWxsIH5mOnAgbCAmJiBmb3JfYWxsIH5mOnAgclxuICA7O1xuXG4gIGxldCByZWMgZXhpc3RzIHQgfmY6cCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBmYWxzZVxuICAgIHwgTGVhZiB2IC0+IHAgdlxuICAgIHwgTm9kZSAobCwgdiwgciwgXywgXykgLT4gcCB2IHx8IGV4aXN0cyB+ZjpwIGwgfHwgZXhpc3RzIH5mOnAgclxuICA7O1xuXG4gIGxldCBmaWx0ZXIgcyB+ZjpwIH5jb21wYXJlX2VsdCA9XG4gICAgbGV0IHJlYyBmaWx0IGFjY3UgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBhY2N1XG4gICAgICB8IExlYWYgdiAtPiBpZiBwIHYgdGhlbiBhZGQgYWNjdSB2IH5jb21wYXJlX2VsdCBlbHNlIGFjY3VcbiAgICAgIHwgTm9kZSAobCwgdiwgciwgXywgXykgLT5cbiAgICAgICAgZmlsdCAoZmlsdCAoaWYgcCB2IHRoZW4gYWRkIGFjY3UgdiB+Y29tcGFyZV9lbHQgZWxzZSBhY2N1KSBsKSByXG4gICAgaW5cbiAgICBmaWx0IEVtcHR5IHNcbiAgOztcblxuICBsZXQgZmlsdGVyX21hcCBzIH5mOnAgfmNvbXBhcmVfZWx0ID1cbiAgICBsZXQgcmVjIGZpbHQgYWNjdSA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IGFjY3VcbiAgICAgIHwgTGVhZiB2IC0+XG4gICAgICAgIChtYXRjaCBwIHYgd2l0aFxuICAgICAgICAgfCBOb25lIC0+IGFjY3VcbiAgICAgICAgIHwgU29tZSB2IC0+IGFkZCBhY2N1IHYgfmNvbXBhcmVfZWx0KVxuICAgICAgfCBOb2RlIChsLCB2LCByLCBfLCBfKSAtPlxuICAgICAgICBmaWx0XG4gICAgICAgICAgKGZpbHRcbiAgICAgICAgICAgICAobWF0Y2ggcCB2IHdpdGhcbiAgICAgICAgICAgICAgfCBOb25lIC0+IGFjY3VcbiAgICAgICAgICAgICAgfCBTb21lIHYgLT4gYWRkIGFjY3UgdiB+Y29tcGFyZV9lbHQpXG4gICAgICAgICAgICAgbClcbiAgICAgICAgICByXG4gICAgaW5cbiAgICBmaWx0IEVtcHR5IHNcbiAgOztcblxuICBsZXQgcGFydGl0aW9uX3RmIHMgfmY6cCB+Y29tcGFyZV9lbHQgPVxuICAgIGxldCByZWMgcGFydCAoKHQsIGYpIGFzIGFjY3UpID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gYWNjdVxuICAgICAgfCBMZWFmIHYgLT4gaWYgcCB2IHRoZW4gYWRkIHQgdiB+Y29tcGFyZV9lbHQsIGYgZWxzZSB0LCBhZGQgZiB2IH5jb21wYXJlX2VsdFxuICAgICAgfCBOb2RlIChsLCB2LCByLCBfLCBfKSAtPlxuICAgICAgICBwYXJ0IChwYXJ0IChpZiBwIHYgdGhlbiBhZGQgdCB2IH5jb21wYXJlX2VsdCwgZiBlbHNlIHQsIGFkZCBmIHYgfmNvbXBhcmVfZWx0KSBsKSByXG4gICAgaW5cbiAgICBwYXJ0IChFbXB0eSwgRW1wdHkpIHNcbiAgOztcblxuICBsZXQgcmVjIGVsZW1lbnRzX2F1eCBhY2N1ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+IGFjY3VcbiAgICB8IExlYWYgdiAtPiB2IDo6IGFjY3VcbiAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIF8pIC0+IGVsZW1lbnRzX2F1eCAodiA6OiBlbGVtZW50c19hdXggYWNjdSByKSBsXG4gIDs7XG5cbiAgbGV0IGVsZW1lbnRzIHMgPSBlbGVtZW50c19hdXggW10gc1xuXG4gIGxldCBjaG9vc2UgdCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBOb25lXG4gICAgfCBMZWFmIHYgLT4gU29tZSB2XG4gICAgfCBOb2RlIChfLCB2LCBfLCBfLCBfKSAtPiBTb21lIHZcbiAgOztcblxuICBsZXQgY2hvb3NlX2V4biA9XG4gICAgbGV0IG5vdF9mb3VuZCA9IE5vdF9mb3VuZF9zIChBdG9tIFwiU2V0LmNob29zZV9leG46IGVtcHR5IHNldFwiKSBpblxuICAgIGxldCBjaG9vc2VfZXhuIHQgPVxuICAgICAgbWF0Y2ggY2hvb3NlIHQgd2l0aFxuICAgICAgfCBOb25lIC0+IHJhaXNlIG5vdF9mb3VuZFxuICAgICAgfCBTb21lIHYgLT4gdlxuICAgIGluXG4gICAgKCogbmFtZWQgdG8gcHJlc2VydmUgc3ltYm9sIGluIGNvbXBpbGVkIGJpbmFyeSAqKVxuICAgIGNob29zZV9leG5cbiAgOztcblxuICBsZXQgb2ZfbGlzdCBsc3QgfmNvbXBhcmVfZWx0ID1cbiAgICBMaXN0LmZvbGQgbHN0IH5pbml0OmVtcHR5IH5mOihmdW4gdCB4IC0+IGFkZCB0IHggfmNvbXBhcmVfZWx0KVxuICA7O1xuXG4gIGxldCBvZl9zZXF1ZW5jZSBzZXF1ZW5jZSB+Y29tcGFyZV9lbHQgPVxuICAgIFNlcXVlbmNlLmZvbGQgc2VxdWVuY2UgfmluaXQ6ZW1wdHkgfmY6KGZ1biB0IHggLT4gYWRkIHQgeCB+Y29tcGFyZV9lbHQpXG4gIDs7XG5cbiAgbGV0IHRvX2xpc3QgcyA9IGVsZW1lbnRzIHNcblxuICBsZXQgb2ZfYXJyYXkgYSB+Y29tcGFyZV9lbHQgPVxuICAgIEFycmF5LmZvbGQgYSB+aW5pdDplbXB0eSB+ZjooZnVuIHQgeCAtPiBhZGQgdCB4IH5jb21wYXJlX2VsdClcbiAgOztcblxuICAoKiBmYXN0ZXIgYnV0IGVxdWl2YWxlbnQgdG8gW0FycmF5Lm9mX2xpc3QgKHRvX2xpc3QgdCldICopXG4gIGxldCB0b19hcnJheSA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPiBbfHxdXG4gICAgfCBMZWFmIHYgLT4gW3wgdiB8XVxuICAgIHwgTm9kZSAobCwgdiwgciwgXywgcykgLT5cbiAgICAgIGxldCByZXMgPSBBcnJheS5jcmVhdGUgfmxlbjpzIHYgaW5cbiAgICAgIGxldCBwb3NfcmVmID0gcmVmIDAgaW5cbiAgICAgIGxldCByZWMgbG9vcCA9IGZ1bmN0aW9uXG4gICAgICAgICgqIEludmFyaWFudDogb24gZW50cnkgYW5kIG9uIGV4aXQgdG8gW2xvb3BdLCAhcG9zX3JlZiBpcyB0aGUgbmV4dFxuICAgICAgICAgICBhdmFpbGFibGUgY2VsbCBpbiB0aGUgYXJyYXkuICopXG4gICAgICAgIHwgRW1wdHkgLT4gKClcbiAgICAgICAgfCBMZWFmIHYgLT5cbiAgICAgICAgICByZXMuKCFwb3NfcmVmKSA8LSB2O1xuICAgICAgICAgIGluY3IgcG9zX3JlZlxuICAgICAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIF8pIC0+XG4gICAgICAgICAgbG9vcCBsO1xuICAgICAgICAgIHJlcy4oIXBvc19yZWYpIDwtIHY7XG4gICAgICAgICAgaW5jciBwb3NfcmVmO1xuICAgICAgICAgIGxvb3AgclxuICAgICAgaW5cbiAgICAgIGxvb3AgbDtcbiAgICAgICgqIHJlcy4oIXBvc19yZWYpIGlzIGFscmVhZHkgaW5pdGlhbGl6ZWQgKGJ5IEFycmF5LmNyZWF0ZSB+bGVuOmFib3ZlKS4gKilcbiAgICAgIGluY3IgcG9zX3JlZjtcbiAgICAgIGxvb3AgcjtcbiAgICAgIHJlc1xuICA7O1xuXG4gIGxldCBtYXAgdCB+ZiB+Y29tcGFyZV9lbHQgPSBmb2xkIHQgfmluaXQ6ZW1wdHkgfmY6KGZ1biB0IHggLT4gYWRkIHQgKGYgeCkgfmNvbXBhcmVfZWx0KVxuXG4gIGxldCBncm91cF9ieSBzZXQgfmVxdWl2IH5jb21wYXJlX2VsdCA9XG4gICAgbGV0IHJlYyBsb29wIHNldCBlcXVpdl9jbGFzc2VzID1cbiAgICAgIGlmIGlzX2VtcHR5IHNldFxuICAgICAgdGhlbiBlcXVpdl9jbGFzc2VzXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IHggPSBjaG9vc2VfZXhuIHNldCBpblxuICAgICAgICBsZXQgZXF1aXZfeCwgbm90X2VxdWl2X3ggPVxuICAgICAgICAgIHBhcnRpdGlvbl90ZiBzZXQgfmY6KGZ1biBlbHQgLT4gcGh5c19lcXVhbCB4IGVsdCB8fCBlcXVpdiB4IGVsdCkgfmNvbXBhcmVfZWx0XG4gICAgICAgIGluXG4gICAgICAgIGxvb3Agbm90X2VxdWl2X3ggKGVxdWl2X3ggOjogZXF1aXZfY2xhc3NlcykpXG4gICAgaW5cbiAgICBsb29wIHNldCBbXVxuICA7O1xuXG4gIGxldCByZWMgZmluZCB0IH5mID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICB8IExlYWYgdiAtPiBpZiBmIHYgdGhlbiBTb21lIHYgZWxzZSBOb25lXG4gICAgfCBOb2RlIChsLCB2LCByLCBfLCBfKSAtPlxuICAgICAgaWYgZiB2XG4gICAgICB0aGVuIFNvbWUgdlxuICAgICAgZWxzZSAoXG4gICAgICAgIG1hdGNoIGZpbmQgbCB+ZiB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBmaW5kIHIgfmZcbiAgICAgICAgfCBTb21lIF8gYXMgciAtPiByKVxuICA7O1xuXG4gIGxldCByZWMgZmluZF9tYXAgdCB+ZiA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBOb25lXG4gICAgfCBMZWFmIHYgLT4gZiB2XG4gICAgfCBOb2RlIChsLCB2LCByLCBfLCBfKSAtPlxuICAgICAgKG1hdGNoIGYgdiB3aXRoXG4gICAgICAgfCBTb21lIF8gYXMgciAtPiByXG4gICAgICAgfCBOb25lIC0+XG4gICAgICAgICAobWF0Y2ggZmluZF9tYXAgbCB+ZiB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IGZpbmRfbWFwIHIgfmZcbiAgICAgICAgICB8IFNvbWUgXyBhcyByIC0+IHIpKVxuICA7O1xuXG4gIGxldCBmaW5kX2V4biB0IH5mID1cbiAgICBtYXRjaCBmaW5kIHQgfmYgd2l0aFxuICAgIHwgTm9uZSAtPiBmYWlsd2l0aCBcIlNldC5maW5kX2V4biBmYWlsZWQgdG8gZmluZCBhIG1hdGNoaW5nIGVsZW1lbnRcIlxuICAgIHwgU29tZSBlIC0+IGVcbiAgOztcblxuICBsZXQgcmVjIG50aCB0IGkgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgIHwgTGVhZiB2IC0+IGlmIGkgPSAwIHRoZW4gU29tZSB2IGVsc2UgTm9uZVxuICAgIHwgTm9kZSAobCwgdiwgciwgXywgcykgLT5cbiAgICAgIGlmIGkgPj0gc1xuICAgICAgdGhlbiBOb25lXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IGxfc2l6ZSA9IGxlbmd0aCBsIGluXG4gICAgICAgIGxldCBjID0gUG9seS5jb21wYXJlIGkgbF9zaXplIGluXG4gICAgICAgIGlmIGMgPCAwIHRoZW4gbnRoIGwgaSBlbHNlIGlmIGMgPSAwIHRoZW4gU29tZSB2IGVsc2UgbnRoIHIgKGkgLSBsX3NpemUgLSAxKSlcbiAgOztcblxuICBsZXQgc3RhYmxlX2RlZHVwX2xpc3QgeHMgfmNvbXBhcmVfZWx0ID1cbiAgICBsZXQgcmVjIGxvb3AgeHMgbGVmdG92ZXJzIGFscmVhZHlfc2VlbiA9XG4gICAgICBtYXRjaCB4cyB3aXRoXG4gICAgICB8IFtdIC0+IExpc3QucmV2IGxlZnRvdmVyc1xuICAgICAgfCBoZCA6OiB0bCAtPlxuICAgICAgICBpZiBtZW0gYWxyZWFkeV9zZWVuIGhkIH5jb21wYXJlX2VsdFxuICAgICAgICB0aGVuIGxvb3AgdGwgbGVmdG92ZXJzIGFscmVhZHlfc2VlblxuICAgICAgICBlbHNlIGxvb3AgdGwgKGhkIDo6IGxlZnRvdmVycykgKGFkZCBhbHJlYWR5X3NlZW4gaGQgfmNvbXBhcmVfZWx0KVxuICAgIGluXG4gICAgbG9vcCB4cyBbXSBlbXB0eVxuICA7O1xuXG4gIGxldCB0X29mX3NleHBfZGlyZWN0IGFfb2Zfc2V4cCBzZXhwIH5jb21wYXJlX2VsdCA9XG4gICAgbWF0Y2ggc2V4cCB3aXRoXG4gICAgfCBTZXhwLkxpc3QgbHN0IC0+XG4gICAgICBsZXQgZWx0X2xzdCA9IExpc3QubWFwIGxzdCB+ZjphX29mX3NleHAgaW5cbiAgICAgIGxldCBzZXQgPSBvZl9saXN0IGVsdF9sc3QgfmNvbXBhcmVfZWx0IGluXG4gICAgICBpZiBsZW5ndGggc2V0ID0gTGlzdC5sZW5ndGggbHN0XG4gICAgICB0aGVuIHNldFxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBzZXQgPSByZWYgZW1wdHkgaW5cbiAgICAgICAgTGlzdC5pdGVyMl9leG4gbHN0IGVsdF9sc3QgfmY6KGZ1biBlbF9zZXhwIGVsIC0+XG4gICAgICAgICAgaWYgbWVtICFzZXQgZWwgfmNvbXBhcmVfZWx0XG4gICAgICAgICAgdGhlbiBvZl9zZXhwX2Vycm9yIFwiU2V0LnRfb2Zfc2V4cDogZHVwbGljYXRlIGVsZW1lbnQgaW4gc2V0XCIgZWxfc2V4cFxuICAgICAgICAgIGVsc2Ugc2V0IDo9IGFkZCAhc2V0IGVsIH5jb21wYXJlX2VsdCk7XG4gICAgICAgIGFzc2VydCBmYWxzZSlcbiAgICB8IHNleHAgLT4gb2Zfc2V4cF9lcnJvciBcIlNldC50X29mX3NleHA6IGxpc3QgbmVlZGVkXCIgc2V4cFxuICA7O1xuXG4gIGxldCBzZXhwX29mX3Qgc2V4cF9vZl9hIHQgPVxuICAgIFNleHAuTGlzdCAoZm9sZF9yaWdodCB0IH5pbml0OltdIH5mOihmdW4gZWwgYWNjIC0+IHNleHBfb2ZfYSBlbCA6OiBhY2MpKVxuICA7O1xuXG4gIG1vZHVsZSBOYW1lZCA9IHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjICgnYSwgJ2NtcCkgdCA9XG4gICAgICB7IHRyZWUgOiAnYSB0XG4gICAgICA7IG5hbWUgOiBzdHJpbmdcbiAgICAgIH1cblxuICAgIGxldCBpc19zdWJzZXQgKHN1YnNldCA6IF8gdCkgfm9mXzooc3VwZXJzZXQgOiBfIHQpIH5zZXhwX29mX2VsdCB+Y29tcGFyZV9lbHQgPVxuICAgICAgbGV0IGludmFsaWRfZWxlbWVudHMgPSBkaWZmIHN1YnNldC50cmVlIHN1cGVyc2V0LnRyZWUgfmNvbXBhcmVfZWx0IGluXG4gICAgICBpZiBpc19lbXB0eSBpbnZhbGlkX2VsZW1lbnRzXG4gICAgICB0aGVuIE9rICgpXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IGludmFsaWRfZWxlbWVudHNfc2V4cCA9IHNleHBfb2ZfdCBzZXhwX29mX2VsdCBpbnZhbGlkX2VsZW1lbnRzIGluXG4gICAgICAgIE9yX2Vycm9yLmVycm9yX3NcbiAgICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgICAgKHN1YnNldC5uYW1lIF4gXCIgaXMgbm90IGEgc3Vic2V0IG9mIFwiIF4gc3VwZXJzZXQubmFtZSlcbiAgICAgICAgICAgICBbIFwiaW52YWxpZF9lbGVtZW50c1wiLCBpbnZhbGlkX2VsZW1lbnRzX3NleHAgXSkpXG4gICAgOztcblxuICAgIGxldCBlcXVhbCBzMSBzMiB+c2V4cF9vZl9lbHQgfmNvbXBhcmVfZWx0ID1cbiAgICAgIE9yX2Vycm9yLmNvbWJpbmVfZXJyb3JzX3VuaXRcbiAgICAgICAgWyBpc19zdWJzZXQgczEgfm9mXzpzMiB+c2V4cF9vZl9lbHQgfmNvbXBhcmVfZWx0XG4gICAgICAgIDsgaXNfc3Vic2V0IHMyIH5vZl86czEgfnNleHBfb2ZfZWx0IH5jb21wYXJlX2VsdFxuICAgICAgICBdXG4gICAgOztcbiAgZW5kXG5lbmRcblxudHlwZSAoJ2EsICdjb21wYXJhdG9yKSB0ID1cbiAgeyAoKiBbY29tcGFyYXRvcl0gaXMgdGhlIGZpcnN0IGZpZWxkIHNvIHRoYXQgcG9seW1vcnBoaWMgZXF1YWxpdHkgZmFpbHMgb24gYSBtYXAgZHVlXG4gICAgICAgdG8gdGhlIGZ1bmN0aW9uYWwgdmFsdWUgaW4gdGhlIGNvbXBhcmF0b3IuXG4gICAgICAgTm90ZSB0aGF0IHRoaXMgZG9lcyBub3QgYWZmZWN0IHBvbHltb3JwaGljIFtjb21wYXJlXTogdGhhdCBzdGlsbCBwcm9kdWNlc1xuICAgICAgIG5vbnNlbnNlLiAqKVxuICAgIGNvbXBhcmF0b3IgOiAoJ2EsICdjb21wYXJhdG9yKSBDb21wYXJhdG9yLnRcbiAgOyB0cmVlIDogJ2EgVHJlZTAudFxuICB9XG5cbnR5cGUgKCdhLCAnY29tcGFyYXRvcikgdHJlZSA9ICdhIFRyZWUwLnRcblxubGV0IGxpa2UgeyB0cmVlID0gXzsgY29tcGFyYXRvciB9IHRyZWUgPSB7IHRyZWU7IGNvbXBhcmF0b3IgfVxubGV0IGNvbXBhcmVfZWx0IHQgPSB0LmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG5cbm1vZHVsZSBBY2Nlc3NvcnMgPSBzdHJ1Y3RcbiAgbGV0IGNvbXBhcmF0b3IgdCA9IHQuY29tcGFyYXRvclxuICBsZXQgaW52YXJpYW50cyB0ID0gVHJlZTAuaW52YXJpYW50cyB0LnRyZWUgfmNvbXBhcmVfZWx0Oihjb21wYXJlX2VsdCB0KVxuICBsZXQgbGVuZ3RoIHQgPSBUcmVlMC5sZW5ndGggdC50cmVlXG4gIGxldCBpc19lbXB0eSB0ID0gVHJlZTAuaXNfZW1wdHkgdC50cmVlXG4gIGxldCBlbGVtZW50cyB0ID0gVHJlZTAuZWxlbWVudHMgdC50cmVlXG4gIGxldCBtaW5fZWx0IHQgPSBUcmVlMC5taW5fZWx0IHQudHJlZVxuICBsZXQgbWluX2VsdF9leG4gdCA9IFRyZWUwLm1pbl9lbHRfZXhuIHQudHJlZVxuICBsZXQgbWF4X2VsdCB0ID0gVHJlZTAubWF4X2VsdCB0LnRyZWVcbiAgbGV0IG1heF9lbHRfZXhuIHQgPSBUcmVlMC5tYXhfZWx0X2V4biB0LnRyZWVcbiAgbGV0IGNob29zZSB0ID0gVHJlZTAuY2hvb3NlIHQudHJlZVxuICBsZXQgY2hvb3NlX2V4biB0ID0gVHJlZTAuY2hvb3NlX2V4biB0LnRyZWVcbiAgbGV0IHRvX2xpc3QgdCA9IFRyZWUwLnRvX2xpc3QgdC50cmVlXG4gIGxldCB0b19hcnJheSB0ID0gVHJlZTAudG9fYXJyYXkgdC50cmVlXG4gIGxldCBmb2xkIHQgfmluaXQgfmYgPSBUcmVlMC5mb2xkIHQudHJlZSB+aW5pdCB+ZlxuICBsZXQgZm9sZF91bnRpbCB0IH5pbml0IH5mID0gVHJlZTAuZm9sZF91bnRpbCB0LnRyZWUgfmluaXQgfmZcbiAgbGV0IGZvbGRfcmlnaHQgdCB+aW5pdCB+ZiA9IFRyZWUwLmZvbGRfcmlnaHQgdC50cmVlIH5pbml0IH5mXG4gIGxldCBmb2xkX3Jlc3VsdCB0IH5pbml0IH5mID0gQ29udGFpbmVyLmZvbGRfcmVzdWx0IH5mb2xkIH5pbml0IH5mIHRcbiAgbGV0IGl0ZXIgdCB+ZiA9IFRyZWUwLml0ZXIgdC50cmVlIH5mXG4gIGxldCBpdGVyMiBhIGIgfmYgPSBUcmVlMC5pdGVyMiBhLnRyZWUgYi50cmVlIH5mIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgYSlcbiAgbGV0IGV4aXN0cyB0IH5mID0gVHJlZTAuZXhpc3RzIHQudHJlZSB+ZlxuICBsZXQgZm9yX2FsbCB0IH5mID0gVHJlZTAuZm9yX2FsbCB0LnRyZWUgfmZcbiAgbGV0IGNvdW50IHQgfmYgPSBUcmVlMC5jb3VudCB0LnRyZWUgfmZcbiAgbGV0IHN1bSBtIHQgfmYgPSBUcmVlMC5zdW0gbSB0LnRyZWUgfmZcbiAgbGV0IGZpbmQgdCB+ZiA9IFRyZWUwLmZpbmQgdC50cmVlIH5mXG4gIGxldCBmaW5kX2V4biB0IH5mID0gVHJlZTAuZmluZF9leG4gdC50cmVlIH5mXG4gIGxldCBmaW5kX21hcCB0IH5mID0gVHJlZTAuZmluZF9tYXAgdC50cmVlIH5mXG4gIGxldCBtZW0gdCBhID0gVHJlZTAubWVtIHQudHJlZSBhIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgdClcbiAgbGV0IGZpbHRlciB0IH5mID0gbGlrZSB0IChUcmVlMC5maWx0ZXIgdC50cmVlIH5mIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgdCkpXG4gIGxldCBhZGQgdCBhID0gbGlrZSB0IChUcmVlMC5hZGQgdC50cmVlIGEgfmNvbXBhcmVfZWx0Oihjb21wYXJlX2VsdCB0KSlcbiAgbGV0IHJlbW92ZSB0IGEgPSBsaWtlIHQgKFRyZWUwLnJlbW92ZSB0LnRyZWUgYSB+Y29tcGFyZV9lbHQ6KGNvbXBhcmVfZWx0IHQpKVxuICBsZXQgdW5pb24gdDEgdDIgPSBsaWtlIHQxIChUcmVlMC51bmlvbiB0MS50cmVlIHQyLnRyZWUgfmNvbXBhcmVfZWx0Oihjb21wYXJlX2VsdCB0MSkpXG4gIGxldCBpbnRlciB0MSB0MiA9IGxpa2UgdDEgKFRyZWUwLmludGVyIHQxLnRyZWUgdDIudHJlZSB+Y29tcGFyZV9lbHQ6KGNvbXBhcmVfZWx0IHQxKSlcbiAgbGV0IGRpZmYgdDEgdDIgPSBsaWtlIHQxIChUcmVlMC5kaWZmIHQxLnRyZWUgdDIudHJlZSB+Y29tcGFyZV9lbHQ6KGNvbXBhcmVfZWx0IHQxKSlcblxuICBsZXQgc3ltbWV0cmljX2RpZmYgdDEgdDIgPVxuICAgIFRyZWUwLnN5bW1ldHJpY19kaWZmIHQxLnRyZWUgdDIudHJlZSB+Y29tcGFyZV9lbHQ6KGNvbXBhcmVfZWx0IHQxKVxuICA7O1xuXG4gIGxldCBjb21wYXJlX2RpcmVjdCB0MSB0MiA9IFRyZWUwLmNvbXBhcmUgKGNvbXBhcmVfZWx0IHQxKSB0MS50cmVlIHQyLnRyZWVcbiAgbGV0IGVxdWFsIHQxIHQyID0gVHJlZTAuZXF1YWwgdDEudHJlZSB0Mi50cmVlIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgdDEpXG4gIGxldCBpc19zdWJzZXQgdCB+b2ZfID0gVHJlZTAuaXNfc3Vic2V0IHQudHJlZSB+b2ZfOm9mXy50cmVlIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgdClcblxuICBsZXQgYXJlX2Rpc2pvaW50IHQxIHQyID1cbiAgICBUcmVlMC5hcmVfZGlzam9pbnQgdDEudHJlZSB0Mi50cmVlIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgdDEpXG4gIDs7XG5cbiAgbW9kdWxlIE5hbWVkID0gc3RydWN0XG4gICAgdHlwZSBub25yZWMgKCdhLCAnY21wKSB0ID1cbiAgICAgIHsgc2V0IDogKCdhLCAnY21wKSB0XG4gICAgICA7IG5hbWUgOiBzdHJpbmdcbiAgICAgIH1cblxuICAgIGxldCB0b19uYW1lZF90cmVlIHsgc2V0OyBuYW1lIH0gPSB7IFRyZWUwLk5hbWVkLnRyZWUgPSBzZXQudHJlZTsgbmFtZSB9XG5cbiAgICBsZXQgaXNfc3Vic2V0IChzdWJzZXQgOiAoXywgXykgdCkgfm9mXzooc3VwZXJzZXQgOiAoXywgXykgdCkgPVxuICAgICAgVHJlZTAuTmFtZWQuaXNfc3Vic2V0XG4gICAgICAgICh0b19uYW1lZF90cmVlIHN1YnNldClcbiAgICAgICAgfm9mXzoodG9fbmFtZWRfdHJlZSBzdXBlcnNldClcbiAgICAgICAgfmNvbXBhcmVfZWx0Oihjb21wYXJlX2VsdCBzdWJzZXQuc2V0KVxuICAgICAgICB+c2V4cF9vZl9lbHQ6c3Vic2V0LnNldC5jb21wYXJhdG9yLnNleHBfb2ZfdFxuICAgIDs7XG5cbiAgICBsZXQgZXF1YWwgdDEgdDIgPVxuICAgICAgT3JfZXJyb3IuY29tYmluZV9lcnJvcnNfdW5pdCBbIGlzX3N1YnNldCB0MSB+b2ZfOnQyOyBpc19zdWJzZXQgdDIgfm9mXzp0MSBdXG4gICAgOztcbiAgZW5kXG5cbiAgbGV0IHBhcnRpdGlvbl90ZiB0IH5mID1cbiAgICBsZXQgdHJlZV90LCB0cmVlX2YgPSBUcmVlMC5wYXJ0aXRpb25fdGYgdC50cmVlIH5mIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgdCkgaW5cbiAgICBsaWtlIHQgdHJlZV90LCBsaWtlIHQgdHJlZV9mXG4gIDs7XG5cbiAgbGV0IHNwbGl0IHQgYSA9XG4gICAgbGV0IHRyZWUxLCBiLCB0cmVlMiA9IFRyZWUwLnNwbGl0IHQudHJlZSBhIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgdCkgaW5cbiAgICBsaWtlIHQgdHJlZTEsIGIsIGxpa2UgdCB0cmVlMlxuICA7O1xuXG4gIGxldCBncm91cF9ieSB0IH5lcXVpdiA9XG4gICAgTGlzdC5tYXAgKFRyZWUwLmdyb3VwX2J5IHQudHJlZSB+ZXF1aXYgfmNvbXBhcmVfZWx0Oihjb21wYXJlX2VsdCB0KSkgfmY6KGxpa2UgdClcbiAgOztcblxuICBsZXQgbnRoIHQgaSA9IFRyZWUwLm50aCB0LnRyZWUgaVxuICBsZXQgcmVtb3ZlX2luZGV4IHQgaSA9IGxpa2UgdCAoVHJlZTAucmVtb3ZlX2luZGV4IHQudHJlZSBpIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgdCkpXG4gIGxldCBzZXhwX29mX3Qgc2V4cF9vZl9hIF8gdCA9IFRyZWUwLnNleHBfb2ZfdCBzZXhwX29mX2EgdC50cmVlXG5cbiAgbGV0IHRvX3NlcXVlbmNlID9vcmRlciA/Z3JlYXRlcl9vcl9lcXVhbF90byA/bGVzc19vcl9lcXVhbF90byB0ID1cbiAgICBUcmVlMC50b19zZXF1ZW5jZSB0LmNvbXBhcmF0b3IgP29yZGVyID9ncmVhdGVyX29yX2VxdWFsX3RvID9sZXNzX29yX2VxdWFsX3RvIHQudHJlZVxuICA7O1xuXG4gIGxldCBiaW5hcnlfc2VhcmNoIHQgfmNvbXBhcmUgaG93IHYgPSBUcmVlMC5iaW5hcnlfc2VhcmNoIHQudHJlZSB+Y29tcGFyZSBob3cgdlxuXG4gIGxldCBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCB0IH5zZWdtZW50X29mIGhvdyA9XG4gICAgVHJlZTAuYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQgdC50cmVlIH5zZWdtZW50X29mIGhvd1xuICA7O1xuXG4gIGxldCBtZXJnZV90b19zZXF1ZW5jZSA/b3JkZXIgP2dyZWF0ZXJfb3JfZXF1YWxfdG8gP2xlc3Nfb3JfZXF1YWxfdG8gdCB0JyA9XG4gICAgVHJlZTAubWVyZ2VfdG9fc2VxdWVuY2VcbiAgICAgIHQuY29tcGFyYXRvclxuICAgICAgP29yZGVyXG4gICAgICA/Z3JlYXRlcl9vcl9lcXVhbF90b1xuICAgICAgP2xlc3Nfb3JfZXF1YWxfdG9cbiAgICAgIHQudHJlZVxuICAgICAgdCcudHJlZVxuICA7O1xuXG4gIGxldCBoYXNoX2ZvbGRfZGlyZWN0IGhhc2hfZm9sZF9rZXkgc3RhdGUgdCA9XG4gICAgVHJlZTAuaGFzaF9mb2xkX3RfaWdub3Jpbmdfc3RydWN0dXJlIGhhc2hfZm9sZF9rZXkgc3RhdGUgdC50cmVlXG4gIDs7XG5lbmRcblxuaW5jbHVkZSBBY2Nlc3NvcnNcblxubGV0IGNvbXBhcmUgXyBfIHQxIHQyID0gY29tcGFyZV9kaXJlY3QgdDEgdDJcblxubW9kdWxlIFRyZWUgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2EsICdjb21wYXJhdG9yKSB0ID0gKCdhLCAnY29tcGFyYXRvcikgdHJlZVxuXG4gIGxldCBjZSBjb21wYXJhdG9yID0gY29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcblxuICBsZXQgdF9vZl9zZXhwX2RpcmVjdCB+Y29tcGFyYXRvciBhX29mX3NleHAgc2V4cCA9XG4gICAgVHJlZTAudF9vZl9zZXhwX2RpcmVjdCB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpIGFfb2Zfc2V4cCBzZXhwXG4gIDs7XG5cbiAgbGV0IGVtcHR5X3dpdGhvdXRfdmFsdWVfcmVzdHJpY3Rpb24gPSBUcmVlMC5lbXB0eVxuICBsZXQgZW1wdHkgfmNvbXBhcmF0b3I6XyA9IGVtcHR5X3dpdGhvdXRfdmFsdWVfcmVzdHJpY3Rpb25cbiAgbGV0IHNpbmdsZXRvbiB+Y29tcGFyYXRvcjpfIGUgPSBUcmVlMC5zaW5nbGV0b24gZVxuICBsZXQgbGVuZ3RoIHQgPSBUcmVlMC5sZW5ndGggdFxuICBsZXQgaW52YXJpYW50cyB+Y29tcGFyYXRvciB0ID0gVHJlZTAuaW52YXJpYW50cyB0IH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IGlzX2VtcHR5IHQgPSBUcmVlMC5pc19lbXB0eSB0XG4gIGxldCBlbGVtZW50cyB0ID0gVHJlZTAuZWxlbWVudHMgdFxuICBsZXQgbWluX2VsdCB0ID0gVHJlZTAubWluX2VsdCB0XG4gIGxldCBtaW5fZWx0X2V4biB0ID0gVHJlZTAubWluX2VsdF9leG4gdFxuICBsZXQgbWF4X2VsdCB0ID0gVHJlZTAubWF4X2VsdCB0XG4gIGxldCBtYXhfZWx0X2V4biB0ID0gVHJlZTAubWF4X2VsdF9leG4gdFxuICBsZXQgY2hvb3NlIHQgPSBUcmVlMC5jaG9vc2UgdFxuICBsZXQgY2hvb3NlX2V4biB0ID0gVHJlZTAuY2hvb3NlX2V4biB0XG4gIGxldCB0b19saXN0IHQgPSBUcmVlMC50b19saXN0IHRcbiAgbGV0IHRvX2FycmF5IHQgPSBUcmVlMC50b19hcnJheSB0XG4gIGxldCBpdGVyIHQgfmYgPSBUcmVlMC5pdGVyIHQgfmZcbiAgbGV0IGV4aXN0cyB0IH5mID0gVHJlZTAuZXhpc3RzIHQgfmZcbiAgbGV0IGZvcl9hbGwgdCB+ZiA9IFRyZWUwLmZvcl9hbGwgdCB+ZlxuICBsZXQgY291bnQgdCB+ZiA9IFRyZWUwLmNvdW50IHQgfmZcbiAgbGV0IHN1bSBtIHQgfmYgPSBUcmVlMC5zdW0gbSB0IH5mXG4gIGxldCBmaW5kIHQgfmYgPSBUcmVlMC5maW5kIHQgfmZcbiAgbGV0IGZpbmRfZXhuIHQgfmYgPSBUcmVlMC5maW5kX2V4biB0IH5mXG4gIGxldCBmaW5kX21hcCB0IH5mID0gVHJlZTAuZmluZF9tYXAgdCB+ZlxuICBsZXQgZm9sZCB0IH5pbml0IH5mID0gVHJlZTAuZm9sZCB0IH5pbml0IH5mXG4gIGxldCBmb2xkX3VudGlsIHQgfmluaXQgfmYgPSBUcmVlMC5mb2xkX3VudGlsIHQgfmluaXQgfmZcbiAgbGV0IGZvbGRfcmlnaHQgdCB+aW5pdCB+ZiA9IFRyZWUwLmZvbGRfcmlnaHQgdCB+aW5pdCB+ZlxuICBsZXQgbWFwIH5jb21wYXJhdG9yIHQgfmYgPSBUcmVlMC5tYXAgdCB+ZiB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIGxldCBmaWx0ZXIgfmNvbXBhcmF0b3IgdCB+ZiA9IFRyZWUwLmZpbHRlciB0IH5mIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IGZpbHRlcl9tYXAgfmNvbXBhcmF0b3IgdCB+ZiA9IFRyZWUwLmZpbHRlcl9tYXAgdCB+ZiB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIGxldCBwYXJ0aXRpb25fdGYgfmNvbXBhcmF0b3IgdCB+ZiA9IFRyZWUwLnBhcnRpdGlvbl90ZiB0IH5mIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IGl0ZXIyIH5jb21wYXJhdG9yIGEgYiB+ZiA9IFRyZWUwLml0ZXIyIGEgYiB+ZiB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIGxldCBtZW0gfmNvbXBhcmF0b3IgdCBhID0gVHJlZTAubWVtIHQgYSB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIGxldCBhZGQgfmNvbXBhcmF0b3IgdCBhID0gVHJlZTAuYWRkIHQgYSB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIGxldCByZW1vdmUgfmNvbXBhcmF0b3IgdCBhID0gVHJlZTAucmVtb3ZlIHQgYSB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIGxldCB1bmlvbiB+Y29tcGFyYXRvciB0MSB0MiA9IFRyZWUwLnVuaW9uIHQxIHQyIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IGludGVyIH5jb21wYXJhdG9yIHQxIHQyID0gVHJlZTAuaW50ZXIgdDEgdDIgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICBsZXQgZGlmZiB+Y29tcGFyYXRvciB0MSB0MiA9IFRyZWUwLmRpZmYgdDEgdDIgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuXG4gIGxldCBzeW1tZXRyaWNfZGlmZiB+Y29tcGFyYXRvciB0MSB0MiA9XG4gICAgVHJlZTAuc3ltbWV0cmljX2RpZmYgdDEgdDIgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICA7O1xuXG4gIGxldCBjb21wYXJlX2RpcmVjdCB+Y29tcGFyYXRvciB0MSB0MiA9IFRyZWUwLmNvbXBhcmUgKGNlIGNvbXBhcmF0b3IpIHQxIHQyXG4gIGxldCBlcXVhbCB+Y29tcGFyYXRvciB0MSB0MiA9IFRyZWUwLmVxdWFsIHQxIHQyIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IGlzX3N1YnNldCB+Y29tcGFyYXRvciB0IH5vZl8gPSBUcmVlMC5pc19zdWJzZXQgdCB+b2ZfIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcblxuICBsZXQgYXJlX2Rpc2pvaW50IH5jb21wYXJhdG9yIHQxIHQyID1cbiAgICBUcmVlMC5hcmVfZGlzam9pbnQgdDEgdDIgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICA7O1xuXG4gIGxldCBvZl9saXN0IH5jb21wYXJhdG9yIGwgPSBUcmVlMC5vZl9saXN0IGwgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICBsZXQgb2Zfc2VxdWVuY2UgfmNvbXBhcmF0b3IgcyA9IFRyZWUwLm9mX3NlcXVlbmNlIHMgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICBsZXQgb2ZfYXJyYXkgfmNvbXBhcmF0b3IgYSA9IFRyZWUwLm9mX2FycmF5IGEgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuXG4gIGxldCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIH5jb21wYXJhdG9yIGEgPVxuICAgIFRyZWUwLm9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgYSB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIDs7XG5cbiAgbGV0IG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5jb21wYXJhdG9yOl8gfmxlbiB+ZiA9XG4gICAgVHJlZTAub2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmxlbiB+ZlxuICA7O1xuXG4gIGxldCBvZl9zb3J0ZWRfYXJyYXkgfmNvbXBhcmF0b3IgYSA9IFRyZWUwLm9mX3NvcnRlZF9hcnJheSBhIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IHVuaW9uX2xpc3QgfmNvbXBhcmF0b3IgbCA9IFRyZWUwLnVuaW9uX2xpc3QgbCB+dG9fdHJlZTpGbi5pZCB+Y29tcGFyYXRvclxuXG4gIGxldCBzdGFibGVfZGVkdXBfbGlzdCB+Y29tcGFyYXRvciB4cyA9XG4gICAgVHJlZTAuc3RhYmxlX2RlZHVwX2xpc3QgeHMgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICA7O1xuXG4gIGxldCBncm91cF9ieSB+Y29tcGFyYXRvciB0IH5lcXVpdiA9IFRyZWUwLmdyb3VwX2J5IHQgfmVxdWl2IH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IHNwbGl0IH5jb21wYXJhdG9yIHQgYSA9IFRyZWUwLnNwbGl0IHQgYSB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIGxldCBudGggdCBpID0gVHJlZTAubnRoIHQgaVxuICBsZXQgcmVtb3ZlX2luZGV4IH5jb21wYXJhdG9yIHQgaSA9IFRyZWUwLnJlbW92ZV9pbmRleCB0IGkgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICBsZXQgc2V4cF9vZl90IHNleHBfb2ZfYSBfIHQgPSBUcmVlMC5zZXhwX29mX3Qgc2V4cF9vZl9hIHRcbiAgbGV0IHRvX3RyZWUgdCA9IHRcbiAgbGV0IG9mX3RyZWUgfmNvbXBhcmF0b3I6XyB0ID0gdFxuXG4gIGxldCB0b19zZXF1ZW5jZSB+Y29tcGFyYXRvciA/b3JkZXIgP2dyZWF0ZXJfb3JfZXF1YWxfdG8gP2xlc3Nfb3JfZXF1YWxfdG8gdCA9XG4gICAgVHJlZTAudG9fc2VxdWVuY2UgY29tcGFyYXRvciA/b3JkZXIgP2dyZWF0ZXJfb3JfZXF1YWxfdG8gP2xlc3Nfb3JfZXF1YWxfdG8gdFxuICA7O1xuXG4gIGxldCBiaW5hcnlfc2VhcmNoIH5jb21wYXJhdG9yOl8gdCB+Y29tcGFyZSBob3cgdiA9IFRyZWUwLmJpbmFyeV9zZWFyY2ggdCB+Y29tcGFyZSBob3cgdlxuXG4gIGxldCBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCB+Y29tcGFyYXRvcjpfIHQgfnNlZ21lbnRfb2YgaG93ID1cbiAgICBUcmVlMC5iaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCB0IH5zZWdtZW50X29mIGhvd1xuICA7O1xuXG4gIGxldCBtZXJnZV90b19zZXF1ZW5jZSB+Y29tcGFyYXRvciA/b3JkZXIgP2dyZWF0ZXJfb3JfZXF1YWxfdG8gP2xlc3Nfb3JfZXF1YWxfdG8gdCB0JyA9XG4gICAgVHJlZTAubWVyZ2VfdG9fc2VxdWVuY2UgY29tcGFyYXRvciA/b3JkZXIgP2dyZWF0ZXJfb3JfZXF1YWxfdG8gP2xlc3Nfb3JfZXF1YWxfdG8gdCB0J1xuICA7O1xuXG4gIGxldCBmb2xkX3Jlc3VsdCB0IH5pbml0IH5mID0gQ29udGFpbmVyLmZvbGRfcmVzdWx0IH5mb2xkIH5pbml0IH5mIHRcblxuICBtb2R1bGUgTmFtZWQgPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIFRyZWUwLk5hbWVkXG5cbiAgICBsZXQgaXNfc3Vic2V0IH5jb21wYXJhdG9yIHQxIH5vZl86dDIgPVxuICAgICAgVHJlZTAuTmFtZWQuaXNfc3Vic2V0XG4gICAgICAgIHQxXG4gICAgICAgIH5vZl86dDJcbiAgICAgICAgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICAgICAgICB+c2V4cF9vZl9lbHQ6Y29tcGFyYXRvci5Db21wYXJhdG9yLnNleHBfb2ZfdFxuICAgIDs7XG5cbiAgICBsZXQgZXF1YWwgfmNvbXBhcmF0b3IgdDEgdDIgPVxuICAgICAgVHJlZTAuTmFtZWQuZXF1YWxcbiAgICAgICAgdDFcbiAgICAgICAgdDJcbiAgICAgICAgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICAgICAgICB+c2V4cF9vZl9lbHQ6Y29tcGFyYXRvci5Db21wYXJhdG9yLnNleHBfb2ZfdFxuICAgIDs7XG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBVc2luZ19jb21wYXJhdG9yID0gc3RydWN0XG4gIHR5cGUgbm9ucmVjICgnZWx0LCAnY21wKSB0ID0gKCdlbHQsICdjbXApIHRcblxuICBpbmNsdWRlIEFjY2Vzc29yc1xuXG4gIGxldCB0b190cmVlIHQgPSB0LnRyZWVcbiAgbGV0IG9mX3RyZWUgfmNvbXBhcmF0b3IgdHJlZSA9IHsgY29tcGFyYXRvcjsgdHJlZSB9XG5cbiAgbGV0IHRfb2Zfc2V4cF9kaXJlY3QgfmNvbXBhcmF0b3IgYV9vZl9zZXhwIHNleHAgPVxuICAgIG9mX3RyZWVcbiAgICAgIH5jb21wYXJhdG9yXG4gICAgICAoVHJlZTAudF9vZl9zZXhwX2RpcmVjdCB+Y29tcGFyZV9lbHQ6Y29tcGFyYXRvci5jb21wYXJlIGFfb2Zfc2V4cCBzZXhwKVxuICA7O1xuXG4gIGxldCBlbXB0eSB+Y29tcGFyYXRvciA9IHsgY29tcGFyYXRvcjsgdHJlZSA9IFRyZWUwLmVtcHR5IH1cblxuICBtb2R1bGUgRW1wdHlfd2l0aG91dF92YWx1ZV9yZXN0cmljdGlvbiAoRWx0IDogQ29tcGFyYXRvci5TMSkgPSBzdHJ1Y3RcbiAgICBsZXQgZW1wdHkgPSB7IGNvbXBhcmF0b3IgPSBFbHQuY29tcGFyYXRvcjsgdHJlZSA9IFRyZWUwLmVtcHR5IH1cbiAgZW5kXG5cbiAgbGV0IHNpbmdsZXRvbiB+Y29tcGFyYXRvciBlID0geyBjb21wYXJhdG9yOyB0cmVlID0gVHJlZTAuc2luZ2xldG9uIGUgfVxuXG4gIGxldCB1bmlvbl9saXN0IH5jb21wYXJhdG9yIGwgPVxuICAgIG9mX3RyZWUgfmNvbXBhcmF0b3IgKFRyZWUwLnVuaW9uX2xpc3QgfmNvbXBhcmF0b3IgfnRvX3RyZWUgbClcbiAgOztcblxuICBsZXQgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCB+Y29tcGFyYXRvciBhcnJheSA9XG4gICAgbGV0IHRyZWUgPVxuICAgICAgVHJlZTAub2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCBhcnJheSB+Y29tcGFyZV9lbHQ6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICBpblxuICAgIHsgY29tcGFyYXRvcjsgdHJlZSB9XG4gIDs7XG5cbiAgbGV0IG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5jb21wYXJhdG9yIH5sZW4gfmYgPVxuICAgIG9mX3RyZWUgfmNvbXBhcmF0b3IgKFRyZWUwLm9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5sZW4gfmYpXG4gIDs7XG5cbiAgbGV0IG9mX3NvcnRlZF9hcnJheSB+Y29tcGFyYXRvciBhcnJheSA9XG4gICAgT3JfZXJyb3IuTW9uYWRfaW5maXguKFxuICAgICAgVHJlZTAub2Zfc29ydGVkX2FycmF5IGFycmF5IH5jb21wYXJlX2VsdDpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICAgICAgPj58IGZ1biB0cmVlIC0+IHsgY29tcGFyYXRvcjsgdHJlZSB9KVxuICA7O1xuXG4gIGxldCBvZl9saXN0IH5jb21wYXJhdG9yIGwgPVxuICAgIHsgY29tcGFyYXRvcjsgdHJlZSA9IFRyZWUwLm9mX2xpc3QgbCB+Y29tcGFyZV9lbHQ6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgfVxuICA7O1xuXG4gIGxldCBvZl9zZXF1ZW5jZSB+Y29tcGFyYXRvciBzID1cbiAgICB7IGNvbXBhcmF0b3I7IHRyZWUgPSBUcmVlMC5vZl9zZXF1ZW5jZSBzIH5jb21wYXJlX2VsdDpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSB9XG4gIDs7XG5cbiAgbGV0IG9mX2FycmF5IH5jb21wYXJhdG9yIGEgPVxuICAgIHsgY29tcGFyYXRvcjsgdHJlZSA9IFRyZWUwLm9mX2FycmF5IGEgfmNvbXBhcmVfZWx0OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIH1cbiAgOztcblxuICBsZXQgc3RhYmxlX2RlZHVwX2xpc3QgfmNvbXBhcmF0b3IgeHMgPVxuICAgIFRyZWUwLnN0YWJsZV9kZWR1cF9saXN0IHhzIH5jb21wYXJlX2VsdDpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICA7O1xuXG4gIGxldCBtYXAgfmNvbXBhcmF0b3IgdCB+ZiA9XG4gICAgeyBjb21wYXJhdG9yOyB0cmVlID0gVHJlZTAubWFwIHQudHJlZSB+ZiB+Y29tcGFyZV9lbHQ6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgfVxuICA7O1xuXG4gIGxldCBmaWx0ZXJfbWFwIH5jb21wYXJhdG9yIHQgfmYgPVxuICAgIHsgY29tcGFyYXRvclxuICAgIDsgdHJlZSA9IFRyZWUwLmZpbHRlcl9tYXAgdC50cmVlIH5mIH5jb21wYXJlX2VsdDpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICAgIH1cbiAgOztcblxuICBtb2R1bGUgVHJlZSA9IFRyZWVcbmVuZFxuXG50eXBlICgnZWx0LCAnY21wKSBjb21wYXJhdG9yID1cbiAgKG1vZHVsZSBDb21wYXJhdG9yLlMgd2l0aCB0eXBlIHQgPSAnZWx0IGFuZCB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA9ICdjbXApXG5cbmxldCBjb21wYXJhdG9yX3MgKHR5cGUgayBjbXApIHQgOiAoaywgY21wKSBjb21wYXJhdG9yID1cbiAgKG1vZHVsZSBzdHJ1Y3RcbiAgICB0eXBlIHQgPSBrXG4gICAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSBjbXBcblxuICAgIGxldCBjb21wYXJhdG9yID0gdC5jb21wYXJhdG9yXG4gIGVuZClcbjs7XG5cbmxldCB0b19jb21wYXJhdG9yICh0eXBlIGVsdCBjbXApICgobW9kdWxlIE0pIDogKGVsdCwgY21wKSBjb21wYXJhdG9yKSA9IE0uY29tcGFyYXRvclxubGV0IGVtcHR5IG0gPSBVc2luZ19jb21wYXJhdG9yLmVtcHR5IH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pXG5sZXQgc2luZ2xldG9uIG0gYSA9IFVzaW5nX2NvbXBhcmF0b3Iuc2luZ2xldG9uIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGFcbmxldCB1bmlvbl9saXN0IG0gYSA9IFVzaW5nX2NvbXBhcmF0b3IudW5pb25fbGlzdCB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhXG5cbmxldCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIG0gYSA9XG4gIFVzaW5nX2NvbXBhcmF0b3Iub2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhXG47O1xuXG5sZXQgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgbSB+bGVuIH5mID1cbiAgVXNpbmdfY29tcGFyYXRvci5vZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSB+bGVuIH5mXG47O1xuXG5sZXQgb2Zfc29ydGVkX2FycmF5IG0gYSA9IFVzaW5nX2NvbXBhcmF0b3Iub2Zfc29ydGVkX2FycmF5IH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGFcbmxldCBvZl9saXN0IG0gYSA9IFVzaW5nX2NvbXBhcmF0b3Iub2ZfbGlzdCB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhXG5sZXQgb2Zfc2VxdWVuY2UgbSBhID0gVXNpbmdfY29tcGFyYXRvci5vZl9zZXF1ZW5jZSB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhXG5sZXQgb2ZfYXJyYXkgbSBhID0gVXNpbmdfY29tcGFyYXRvci5vZl9hcnJheSB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhXG5cbmxldCBzdGFibGVfZGVkdXBfbGlzdCBtIGEgPVxuICBVc2luZ19jb21wYXJhdG9yLnN0YWJsZV9kZWR1cF9saXN0IH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGFcbjs7XG5cbmxldCBtYXAgbSBhIH5mID0gVXNpbmdfY29tcGFyYXRvci5tYXAgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgYSB+ZlxubGV0IGZpbHRlcl9tYXAgbSBhIH5mID0gVXNpbmdfY29tcGFyYXRvci5maWx0ZXJfbWFwIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGEgfmZcblxubW9kdWxlIE0gKEVsdCA6IHNpZ1xuICAgIHR5cGUgdFxuICAgIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzXG4gIGVuZCkgPVxuc3RydWN0XG4gIHR5cGUgbm9ucmVjIHQgPSAoRWx0LnQsIEVsdC5jb21wYXJhdG9yX3dpdG5lc3MpIHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBTZXhwX29mX20gPSBzaWdcbiAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gIHZhbCBzZXhwX29mX3QgOiB0IC0+IFNleHBsaWIwLlNleHAudFxuXG4gIFtAQEBlbmRdXG5lbmRcblxubW9kdWxlIHR5cGUgTV9vZl9zZXhwID0gc2lnXG4gIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgb2Zfc2V4cF1cblxuICB2YWwgdF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHRcblxuICBbQEBAZW5kXVxuXG4gIGluY2x1ZGUgQ29tcGFyYXRvci5TIHdpdGggdHlwZSB0IDo9IHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBNX3NleHBfZ3JhbW1hciA9IHNpZ1xuICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfZ3JhbW1hcl1cblxuICB2YWwgdF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG5tb2R1bGUgdHlwZSBDb21wYXJlX20gPSBzaWcgZW5kXG5tb2R1bGUgdHlwZSBFcXVhbF9tID0gc2lnIGVuZFxubW9kdWxlIHR5cGUgSGFzaF9mb2xkX20gPSBIYXNoZXIuU1xuXG5sZXQgc2V4cF9vZl9tX190ICh0eXBlIGVsdCkgKG1vZHVsZSBFbHQgOiBTZXhwX29mX20gd2l0aCB0eXBlIHQgPSBlbHQpIHQgPVxuICBzZXhwX29mX3QgRWx0LnNleHBfb2ZfdCAoZnVuIF8gLT4gU2V4cC5BdG9tIFwiX1wiKSB0XG47O1xuXG5sZXQgbV9fdF9vZl9zZXhwXG4gICAgICAodHlwZSBlbHQgY21wKVxuICAgICAgKG1vZHVsZSBFbHQgOiBNX29mX3NleHAgd2l0aCB0eXBlIHQgPSBlbHQgYW5kIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gY21wKVxuICAgICAgc2V4cFxuICA9XG4gIFVzaW5nX2NvbXBhcmF0b3IudF9vZl9zZXhwX2RpcmVjdCB+Y29tcGFyYXRvcjpFbHQuY29tcGFyYXRvciBFbHQudF9vZl9zZXhwIHNleHBcbjs7XG5cbmxldCBtX190X3NleHBfZ3JhbW1hciAodHlwZSBlbHQpIChtb2R1bGUgRWx0IDogTV9zZXhwX2dyYW1tYXIgd2l0aCB0eXBlIHQgPSBlbHQpXG4gIDogKGVsdCwgXykgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICA9XG4gIFNleHBsaWIwLlNleHBfZ3JhbW1hci5jb2VyY2UgKGxpc3Rfc2V4cF9ncmFtbWFyIEVsdC50X3NleHBfZ3JhbW1hcilcbjs7XG5cbmxldCBjb21wYXJlX21fX3QgKG1vZHVsZSBfIDogQ29tcGFyZV9tKSB0MSB0MiA9IGNvbXBhcmVfZGlyZWN0IHQxIHQyXG5sZXQgZXF1YWxfbV9fdCAobW9kdWxlIF8gOiBFcXVhbF9tKSB0MSB0MiA9IGVxdWFsIHQxIHQyXG5cbmxldCBoYXNoX2ZvbGRfbV9fdCAodHlwZSBlbHQpIChtb2R1bGUgRWx0IDogSGFzaF9mb2xkX20gd2l0aCB0eXBlIHQgPSBlbHQpIHN0YXRlID1cbiAgaGFzaF9mb2xkX2RpcmVjdCBFbHQuaGFzaF9mb2xkX3Qgc3RhdGVcbjs7XG5cbmxldCBoYXNoX21fX3QgZm9sZGVyIHQgPVxuICBsZXQgc3RhdGUgPSBoYXNoX2ZvbGRfbV9fdCBmb2xkZXIgKEhhc2guY3JlYXRlICgpKSB0IGluXG4gIEhhc2guZ2V0X2hhc2hfdmFsdWUgc3RhdGVcbjs7XG5cbm1vZHVsZSBQb2x5ID0gc3RydWN0XG4gIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gQ29tcGFyYXRvci5Qb2x5LmNvbXBhcmF0b3Jfd2l0bmVzc1xuICB0eXBlIG5vbnJlYyAoJ2VsdCwgJ2NtcCkgc2V0ID0gKCdlbHQsIGNvbXBhcmF0b3Jfd2l0bmVzcykgdFxuICB0eXBlIG5vbnJlYyAnZWx0IHQgPSAoJ2VsdCwgY29tcGFyYXRvcl93aXRuZXNzKSB0XG4gIHR5cGUgbm9ucmVjICdlbHQgdHJlZSA9ICgnZWx0LCBjb21wYXJhdG9yX3dpdG5lc3MpIHRyZWVcbiAgdHlwZSBub25yZWMgJ2VsdCBuYW1lZCA9ICgnZWx0LCBjb21wYXJhdG9yX3dpdG5lc3MpIE5hbWVkLnRcblxuICBpbmNsdWRlIEFjY2Vzc29yc1xuXG4gIGxldCBjb21wYXJhdG9yID0gQ29tcGFyYXRvci5Qb2x5LmNvbXBhcmF0b3JcblxuICBpbmNsdWRlIFVzaW5nX2NvbXBhcmF0b3IuRW1wdHlfd2l0aG91dF92YWx1ZV9yZXN0cmljdGlvbiAoQ29tcGFyYXRvci5Qb2x5KVxuXG4gIGxldCBzaW5nbGV0b24gYSA9IFVzaW5nX2NvbXBhcmF0b3Iuc2luZ2xldG9uIH5jb21wYXJhdG9yIGFcbiAgbGV0IHVuaW9uX2xpc3QgYSA9IFVzaW5nX2NvbXBhcmF0b3IudW5pb25fbGlzdCB+Y29tcGFyYXRvciBhXG5cbiAgbGV0IG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgYSA9XG4gICAgVXNpbmdfY29tcGFyYXRvci5vZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIH5jb21wYXJhdG9yIGFcbiAgOztcblxuICBsZXQgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmxlbiB+ZiA9XG4gICAgVXNpbmdfY29tcGFyYXRvci5vZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+Y29tcGFyYXRvciB+bGVuIH5mXG4gIDs7XG5cbiAgbGV0IG9mX3NvcnRlZF9hcnJheSBhID0gVXNpbmdfY29tcGFyYXRvci5vZl9zb3J0ZWRfYXJyYXkgfmNvbXBhcmF0b3IgYVxuICBsZXQgb2ZfbGlzdCBhID0gVXNpbmdfY29tcGFyYXRvci5vZl9saXN0IH5jb21wYXJhdG9yIGFcbiAgbGV0IG9mX3NlcXVlbmNlIGEgPSBVc2luZ19jb21wYXJhdG9yLm9mX3NlcXVlbmNlIH5jb21wYXJhdG9yIGFcbiAgbGV0IG9mX2FycmF5IGEgPSBVc2luZ19jb21wYXJhdG9yLm9mX2FycmF5IH5jb21wYXJhdG9yIGFcbiAgbGV0IHN0YWJsZV9kZWR1cF9saXN0IGEgPSBVc2luZ19jb21wYXJhdG9yLnN0YWJsZV9kZWR1cF9saXN0IH5jb21wYXJhdG9yIGFcbiAgbGV0IG1hcCBhIH5mID0gVXNpbmdfY29tcGFyYXRvci5tYXAgfmNvbXBhcmF0b3IgYSB+ZlxuICBsZXQgZmlsdGVyX21hcCBhIH5mID0gVXNpbmdfY29tcGFyYXRvci5maWx0ZXJfbWFwIH5jb21wYXJhdG9yIGEgfmZcbiAgbGV0IG9mX3RyZWUgdHJlZSA9IHsgY29tcGFyYXRvcjsgdHJlZSB9XG4gIGxldCB0b190cmVlIHQgPSB0LnRyZWVcbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5cbmluY2x1ZGUgKFxuc3RydWN0XG4gIHR5cGUgJ2EgdCA9ICdhIHJlZiBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZXF1YWwsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZSA6ICdhLiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSB0IC0+ICdhIHQgLT4gaW50ID0gY29tcGFyZV9yZWZcbiAgbGV0IGVxdWFsIDogJ2EuICgnYSAtPiAnYSAtPiBib29sKSAtPiAnYSB0IC0+ICdhIHQgLT4gYm9vbCA9IGVxdWFsX3JlZlxuICBsZXQgdF9vZl9zZXhwIDogJ2EuIChTZXhwbGliMC5TZXhwLnQgLT4gJ2EpIC0+IFNleHBsaWIwLlNleHAudCAtPiAnYSB0ID0gcmVmX29mX3NleHBcbiAgbGV0IHNleHBfb2ZfdCA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSB0IC0+IFNleHBsaWIwLlNleHAudCA9IHNleHBfb2ZfcmVmXG5cbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6ICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50IC0+ICdhIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID1cbiAgICBmdW4gXydhX3NleHBfZ3JhbW1hciAtPiByZWZfc2V4cF9ncmFtbWFyIF8nYV9zZXhwX2dyYW1tYXJcbiAgOztcblxuICBbQEBAZW5kXVxuZW5kIDpcbnNpZ1xuICB0eXBlICdhIHQgPSAnYSByZWYgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TMSB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG4gIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkVxdWFsLlMxIHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcbiAgaW5jbHVkZSBTZXhwbGliMC5TZXhwYWJsZS5TMSB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG5cbiAgdmFsIHRfc2V4cF9ncmFtbWFyIDogJ2EgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgLT4gJ2EgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuXG4gIFtAQEBlbmRdXG5lbmQpXG5cbigqIEluIHRoZSBkZWZpbml0aW9uIG9mIFt0XSwgd2UgZG8gbm90IGhhdmUgW1tAQGRlcml2aW5nIGNvbXBhcmUsIHNleHBdXSBiZWNhdXNlXG4gICBpbiBnZW5lcmFsLCBzeW50YXggZXh0ZW5zaW9ucyB0ZW5kIHRvIHVzZSB0aGUgaW1wbGVtZW50YXRpb24gd2hlbiBhdmFpbGFibGUgcmF0aGVyIHRoYW5cbiAgIHVzaW5nIHRoZSBhbGlhcy4gIEhlcmUgdGhhdCB3b3VsZCBsZWFkIHRvIHVzZSB0aGUgcmVjb3JkIHJlcHJlc2VudGF0aW9uIFsgeyBtdXRhYmxlXG4gICBjb250ZW50cyA6ICdhIH0gXSB3aGljaCB3b3VsZCByZXN1bHQgaW4gZGlmZmVyZW50IChhbmQgdW53YW50ZWQpIGJlaGF2aW9yLiAgKilcbnR5cGUgJ2EgdCA9ICdhIHJlZiA9IHsgbXV0YWJsZSBjb250ZW50cyA6ICdhIH1cblxuZXh0ZXJuYWwgY3JlYXRlIDogJ2EgLT4gJ2EgdCA9IFwiJW1ha2VtdXRhYmxlXCJcbmV4dGVybmFsICggISApIDogJ2EgdCAtPiAnYSA9IFwiJWZpZWxkMFwiXG5leHRlcm5hbCAoIDo9ICkgOiAnYSB0IC0+ICdhIC0+IHVuaXQgPSBcIiVzZXRmaWVsZDBcIlxuXG5sZXQgc3dhcCB0MSB0MiA9XG4gIGxldCB0bXAgPSAhdDEgaW5cbiAgdDEgOj0gIXQyO1xuICB0MiA6PSB0bXBcbjs7XG5cbmxldCByZXBsYWNlIHQgZiA9IHQgOj0gZiAhdFxuXG5sZXQgc2V0X3RlbXBvcmFyaWx5IHQgYSB+ZiA9XG4gIGxldCByZXN0b3JlX3RvID0gIXQgaW5cbiAgdCA6PSBhO1xuICBFeG4ucHJvdGVjdCB+ZiB+ZmluYWxseTooZnVuICgpIC0+IHQgOj0gcmVzdG9yZV90bylcbjs7XG5cbm1vZHVsZSBBbmRfdmFsdWUgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gVCA6ICdhIHJlZiAqICdhIC0+IHQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICBsZXQgc2V0IChUIChyLCBhKSkgPSByIDo9IGFcbiAgbGV0IHNldHMgdHMgPSBMaXN0Lml0ZXIgdHMgfmY6c2V0XG4gIGxldCBzbmFwc2hvdCAoVCAociwgXykpID0gVCAociwgIXIpXG4gIGxldCBzbmFwc2hvdHMgdHMgPSBMaXN0Lm1hcCB0cyB+ZjpzbmFwc2hvdFxuZW5kXG5cbmxldCBzZXRzX3RlbXBvcmFyaWx5IGFuZF92YWx1ZXMgfmYgPVxuICBsZXQgcmVzdG9yZV90byA9IEFuZF92YWx1ZS5zbmFwc2hvdHMgYW5kX3ZhbHVlcyBpblxuICBBbmRfdmFsdWUuc2V0cyBhbmRfdmFsdWVzO1xuICBFeG4ucHJvdGVjdCB+ZiB+ZmluYWxseTooZnVuICgpIC0+IEFuZF92YWx1ZS5zZXRzIHJlc3RvcmVfdG8pXG47O1xuIiwib3BlbiEgSW1wb3J0XG5cblxuKCogW3RdIHN0b3JlcyB0aGUgW3QubGVuZ3RoXSBxdWV1ZSBlbGVtZW50cyBhdCBjb25zZWN1dGl2ZSBpbmNyZWFzaW5nIGluZGljZXMgb2YgW3QuZWx0c10sXG4gICBtb2QgdGhlIGNhcGFjaXR5IG9mIFt0XSwgd2hpY2ggaXMgW09wdGlvbl9hcnJheS5sZW5ndGggdC5lbHRzXS4gIFRoZSBjYXBhY2l0eSBpc1xuICAgcmVxdWlyZWQgdG8gYmUgYSBwb3dlciBvZiB0d28gKHVzZXItcmVxdWVzdGVkIGNhcGFjaXRpZXMgYXJlIHJvdW5kZWQgdXAgdG8gdGhlIG5lYXJlc3RcbiAgIHBvd2VyKSwgc28gdGhhdCBtb2QgY2FuIHF1aWNrbHkgYmUgY29tcHV0ZWQgdXNpbmcgW2xhbmQgdC5tYXNrXSwgd2hlcmUgW3QubWFzayA9XG4gICBjYXBhY2l0eSB0IC0gMV0uICBTbywgcXVldWUgZWxlbWVudCBbaV0gaXMgYXQgW3QuZWx0cy4oICh0LmZyb250ICsgaSkgbGFuZCB0Lm1hc2sgKV0uXG5cbiAgIFtudW1fbXV0YXRpb25zXSBpcyB1c2VkIHRvIGRldGVjdCBtb2RpZmljYXRpb24gZHVyaW5nIGl0ZXJhdGlvbi4gKilcbnR5cGUgJ2EgdCA9XG4gIHsgbXV0YWJsZSBudW1fbXV0YXRpb25zIDogaW50XG4gIDsgbXV0YWJsZSBmcm9udCA6IGludFxuICA7IG11dGFibGUgbWFzayA6IGludFxuICA7IG11dGFibGUgbGVuZ3RoIDogaW50XG4gIDsgbXV0YWJsZSBlbHRzIDogJ2EgT3B0aW9uX2FycmF5LnRcbiAgfVxuW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbmxldCBzZXhwX29mX3QgOiAnYS4gKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgdCAtPiBTZXhwbGliMC5TZXhwLnQgPVxuICBmdW4gX29mX2FfXzAwMV9cbiAgICB7IG51bV9tdXRhdGlvbnMgPSBudW1fbXV0YXRpb25zX18wMDNfXG4gICAgOyBmcm9udCA9IGZyb250X18wMDVfXG4gICAgOyBtYXNrID0gbWFza19fMDA3X1xuICAgIDsgbGVuZ3RoID0gbGVuZ3RoX18wMDlfXG4gICAgOyBlbHRzID0gZWx0c19fMDExX1xuICAgIH0gLT5cbiAgICBsZXQgYm5kc19fMDAyXyA9IFtdIGluXG4gICAgbGV0IGJuZHNfXzAwMl8gPVxuICAgICAgbGV0IGFyZ19fMDEyXyA9IE9wdGlvbl9hcnJheS5zZXhwX29mX3QgX29mX2FfXzAwMV8gZWx0c19fMDExXyBpblxuICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiZWx0c1wiOyBhcmdfXzAxMl8gXSA6OiBibmRzX18wMDJfXG4gICAgaW5cbiAgICBsZXQgYm5kc19fMDAyXyA9XG4gICAgICBsZXQgYXJnX18wMTBfID0gc2V4cF9vZl9pbnQgbGVuZ3RoX18wMDlfIGluXG4gICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJsZW5ndGhcIjsgYXJnX18wMTBfIF0gOjogYm5kc19fMDAyX1xuICAgIGluXG4gICAgbGV0IGJuZHNfXzAwMl8gPVxuICAgICAgbGV0IGFyZ19fMDA4XyA9IHNleHBfb2ZfaW50IG1hc2tfXzAwN18gaW5cbiAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIm1hc2tcIjsgYXJnX18wMDhfIF0gOjogYm5kc19fMDAyX1xuICAgIGluXG4gICAgbGV0IGJuZHNfXzAwMl8gPVxuICAgICAgbGV0IGFyZ19fMDA2XyA9IHNleHBfb2ZfaW50IGZyb250X18wMDVfIGluXG4gICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJmcm9udFwiOyBhcmdfXzAwNl8gXSA6OiBibmRzX18wMDJfXG4gICAgaW5cbiAgICBsZXQgYm5kc19fMDAyXyA9XG4gICAgICBsZXQgYXJnX18wMDRfID0gc2V4cF9vZl9pbnQgbnVtX211dGF0aW9uc19fMDAzXyBpblxuICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwibnVtX211dGF0aW9uc1wiOyBhcmdfXzAwNF8gXSA6OiBibmRzX18wMDJfXG4gICAgaW5cbiAgICBTZXhwbGliMC5TZXhwLkxpc3QgYm5kc19fMDAyX1xuOztcblxuW0BAQGVuZF1cblxubW9kdWxlIHR5cGUgUyA9IFF1ZXVlX2ludGYuU1xuXG5sZXQgaW5jX251bV9tdXRhdGlvbnMgdCA9IHQubnVtX211dGF0aW9ucyA8LSB0Lm51bV9tdXRhdGlvbnMgKyAxXG5sZXQgY2FwYWNpdHkgdCA9IHQubWFzayArIDFcbmxldCBlbHRzX2luZGV4IHQgaSA9ICh0LmZyb250ICsgaSkgbGFuZCB0Lm1hc2tcbmxldCB1bnNhZmVfZ2V0IHQgaSA9IE9wdGlvbl9hcnJheS51bnNhZmVfZ2V0X3NvbWVfZXhuIHQuZWx0cyAoZWx0c19pbmRleCB0IGkpXG5sZXQgdW5zYWZlX2lzX3NldCB0IGkgPSBPcHRpb25fYXJyYXkudW5zYWZlX2lzX3NvbWUgdC5lbHRzIChlbHRzX2luZGV4IHQgaSlcbmxldCB1bnNhZmVfc2V0IHQgaSBhID0gT3B0aW9uX2FycmF5LnVuc2FmZV9zZXRfc29tZSB0LmVsdHMgKGVsdHNfaW5kZXggdCBpKSBhXG5sZXQgdW5zYWZlX3Vuc2V0IHQgaSA9IE9wdGlvbl9hcnJheS51bnNhZmVfc2V0X25vbmUgdC5lbHRzIChlbHRzX2luZGV4IHQgaSlcblxubGV0IGNoZWNrX2luZGV4X2V4biB0IGkgPVxuICBpZiBpIDwgMCB8fCBpID49IHQubGVuZ3RoXG4gIHRoZW5cbiAgICBFcnJvci5yYWlzZV9zXG4gICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICBcIlF1ZXVlIGluZGV4IG91dCBvZiBib3VuZHNcIlxuICAgICAgICAgWyBcImluZGV4XCIsIGkgfD4gSW50LnNleHBfb2ZfdDsgXCJsZW5ndGhcIiwgdC5sZW5ndGggfD4gSW50LnNleHBfb2ZfdCBdKVxuOztcblxubGV0IGdldCB0IGkgPVxuICBjaGVja19pbmRleF9leG4gdCBpO1xuICB1bnNhZmVfZ2V0IHQgaVxuOztcblxubGV0IHNldCB0IGkgYSA9XG4gIGNoZWNrX2luZGV4X2V4biB0IGk7XG4gIGluY19udW1fbXV0YXRpb25zIHQ7XG4gIHVuc2FmZV9zZXQgdCBpIGFcbjs7XG5cbmxldCBpc19lbXB0eSB0ID0gdC5sZW5ndGggPSAwXG5sZXQgbGVuZ3RoIHsgbGVuZ3RoOyBfIH0gPSBsZW5ndGhcblxubGV0IGVuc3VyZV9ub19tdXRhdGlvbiB0IG51bV9tdXRhdGlvbnMgPVxuICBpZiB0Lm51bV9tdXRhdGlvbnMgPD4gbnVtX211dGF0aW9uc1xuICB0aGVuXG4gICAgRXJyb3IucmFpc2Vfc1xuICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgXCJtdXRhdGlvbiBvZiBxdWV1ZSBkdXJpbmcgaXRlcmF0aW9uXCJcbiAgICAgICAgIFsgXCJcIiwgdCB8PiBzZXhwX29mX3QgKGZ1biBfIC0+IFNleHAuQXRvbSBcIl9cIikgXSlcbjs7XG5cbmxldCBjb21wYXJlID1cbiAgbGV0IHJlYyB1bnNhZmVfY29tcGFyZV9mcm9tIGNvbXBhcmVfZWx0IHBvcyB+dDEgfnQyIH5sZW4xIH5sZW4yIH5tdXQxIH5tdXQyID1cbiAgICBtYXRjaCBwb3MgPSBsZW4xLCBwb3MgPSBsZW4yIHdpdGhcbiAgICB8IHRydWUsIHRydWUgLT4gMFxuICAgIHwgdHJ1ZSwgZmFsc2UgLT4gLTFcbiAgICB8IGZhbHNlLCB0cnVlIC0+IDFcbiAgICB8IGZhbHNlLCBmYWxzZSAtPlxuICAgICAgbGV0IHggPSBjb21wYXJlX2VsdCAodW5zYWZlX2dldCB0MSBwb3MpICh1bnNhZmVfZ2V0IHQyIHBvcykgaW5cbiAgICAgIGVuc3VyZV9ub19tdXRhdGlvbiB0MSBtdXQxO1xuICAgICAgZW5zdXJlX25vX211dGF0aW9uIHQyIG11dDI7XG4gICAgICAobWF0Y2ggeCB3aXRoXG4gICAgICAgfCAwIC0+IHVuc2FmZV9jb21wYXJlX2Zyb20gY29tcGFyZV9lbHQgKHBvcyArIDEpIH50MSB+dDIgfmxlbjEgfmxlbjIgfm11dDEgfm11dDJcbiAgICAgICB8IG4gLT4gbilcbiAgaW5cbiAgZnVuIGNvbXBhcmVfZWx0IHQxIHQyIC0+XG4gICAgaWYgcGh5c19lcXVhbCB0MSB0MlxuICAgIHRoZW4gMFxuICAgIGVsc2VcbiAgICAgIHVuc2FmZV9jb21wYXJlX2Zyb21cbiAgICAgICAgY29tcGFyZV9lbHRcbiAgICAgICAgMFxuICAgICAgICB+dDFcbiAgICAgICAgfnQyXG4gICAgICAgIH5sZW4xOnQxLmxlbmd0aFxuICAgICAgICB+bGVuMjp0Mi5sZW5ndGhcbiAgICAgICAgfm11dDE6dDEubnVtX211dGF0aW9uc1xuICAgICAgICB+bXV0Mjp0Mi5udW1fbXV0YXRpb25zXG47O1xuXG5sZXQgZXF1YWwgPVxuICBsZXQgcmVjIHVuc2FmZV9lcXVhbF9mcm9tIGVxdWFsX2VsdCBwb3MgfnQxIH50MiB+bXV0MSB+bXV0MiB+bGVuID1cbiAgICBwb3MgPSBsZW5cbiAgICB8fFxuICAgIGxldCBiID0gZXF1YWxfZWx0ICh1bnNhZmVfZ2V0IHQxIHBvcykgKHVuc2FmZV9nZXQgdDIgcG9zKSBpblxuICAgIGVuc3VyZV9ub19tdXRhdGlvbiB0MSBtdXQxO1xuICAgIGVuc3VyZV9ub19tdXRhdGlvbiB0MiBtdXQyO1xuICAgIGIgJiYgdW5zYWZlX2VxdWFsX2Zyb20gZXF1YWxfZWx0IChwb3MgKyAxKSB+dDEgfnQyIH5tdXQxIH5tdXQyIH5sZW5cbiAgaW5cbiAgZnVuIGVxdWFsX2VsdCB0MSB0MiAtPlxuICAgIHBoeXNfZXF1YWwgdDEgdDJcbiAgICB8fFxuICAgIGxldCBsZW4xID0gdDEubGVuZ3RoIGluXG4gICAgbGV0IGxlbjIgPSB0Mi5sZW5ndGggaW5cbiAgICBsZW4xID0gbGVuMlxuICAgICYmIHVuc2FmZV9lcXVhbF9mcm9tXG4gICAgICAgICBlcXVhbF9lbHRcbiAgICAgICAgIDBcbiAgICAgICAgIH50MVxuICAgICAgICAgfnQyXG4gICAgICAgICB+bGVuOmxlbjFcbiAgICAgICAgIH5tdXQxOnQxLm51bV9tdXRhdGlvbnNcbiAgICAgICAgIH5tdXQyOnQyLm51bV9tdXRhdGlvbnNcbjs7XG5cbmxldCBpbnZhcmlhbnQgaW52YXJpYW50X2EgdCA9XG4gIGxldCB7IG51bV9tdXRhdGlvbnM7IG1hc2sgPSBfOyBlbHRzOyBmcm9udDsgbGVuZ3RoIH0gPSB0IGluXG4gIGFzc2VydCAoZnJvbnQgPj0gMCk7XG4gIGFzc2VydCAoZnJvbnQgPCBjYXBhY2l0eSB0KTtcbiAgbGV0IGNhcGFjaXR5ID0gY2FwYWNpdHkgdCBpblxuICBhc3NlcnQgKGNhcGFjaXR5ID0gT3B0aW9uX2FycmF5Lmxlbmd0aCBlbHRzKTtcbiAgYXNzZXJ0IChjYXBhY2l0eSA+PSAxKTtcbiAgYXNzZXJ0IChJbnQuaXNfcG93MiBjYXBhY2l0eSk7XG4gIGFzc2VydCAobGVuZ3RoID49IDApO1xuICBhc3NlcnQgKGxlbmd0aCA8PSBjYXBhY2l0eSk7XG4gIGZvciBpID0gMCB0byBjYXBhY2l0eSAtIDEgZG9cbiAgICBpZiBpIDwgdC5sZW5ndGhcbiAgICB0aGVuIChcbiAgICAgIGludmFyaWFudF9hICh1bnNhZmVfZ2V0IHQgaSk7XG4gICAgICBlbnN1cmVfbm9fbXV0YXRpb24gdCBudW1fbXV0YXRpb25zKVxuICAgIGVsc2UgYXNzZXJ0IChub3QgKHVuc2FmZV9pc19zZXQgdCBpKSlcbiAgZG9uZVxuOztcblxubGV0IGNyZWF0ZSAodHlwZSBhKSA/Y2FwYWNpdHkgKCkgOiBhIHQgPVxuICBsZXQgY2FwYWNpdHkgPVxuICAgIG1hdGNoIGNhcGFjaXR5IHdpdGhcbiAgICB8IE5vbmUgLT4gMVxuICAgIHwgU29tZSBjYXBhY2l0eSAtPlxuICAgICAgaWYgY2FwYWNpdHkgPCAwXG4gICAgICB0aGVuXG4gICAgICAgIEVycm9yLnJhaXNlX3NcbiAgICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgICAgXCJjYW5ub3QgaGF2ZSBxdWV1ZSB3aXRoIG5lZ2F0aXZlIGNhcGFjaXR5XCJcbiAgICAgICAgICAgICBbIFwiY2FwYWNpdHlcIiwgY2FwYWNpdHkgfD4gSW50LnNleHBfb2ZfdCBdKVxuICAgICAgZWxzZSBpZiBjYXBhY2l0eSA9IDBcbiAgICAgIHRoZW4gMVxuICAgICAgZWxzZSBJbnQuY2VpbF9wb3cyIGNhcGFjaXR5XG4gIGluXG4gIHsgbnVtX211dGF0aW9ucyA9IDBcbiAgOyBmcm9udCA9IDBcbiAgOyBtYXNrID0gY2FwYWNpdHkgLSAxXG4gIDsgbGVuZ3RoID0gMFxuICA7IGVsdHMgPSBPcHRpb25fYXJyYXkuY3JlYXRlIH5sZW46Y2FwYWNpdHlcbiAgfVxuOztcblxubGV0IGJsaXRfdG9fYXJyYXkgfnNyYyBkc3QgPVxuICBhc3NlcnQgKHNyYy5sZW5ndGggPD0gT3B0aW9uX2FycmF5Lmxlbmd0aCBkc3QpO1xuICBsZXQgZnJvbnRfbGVuID0gSW50Lm1pbiBzcmMubGVuZ3RoIChjYXBhY2l0eSBzcmMgLSBzcmMuZnJvbnQpIGluXG4gIGxldCByZXN0X2xlbiA9IHNyYy5sZW5ndGggLSBmcm9udF9sZW4gaW5cbiAgT3B0aW9uX2FycmF5LmJsaXQgfmxlbjpmcm9udF9sZW4gfnNyYzpzcmMuZWx0cyB+c3JjX3BvczpzcmMuZnJvbnQgfmRzdCB+ZHN0X3BvczowO1xuICBPcHRpb25fYXJyYXkuYmxpdCB+bGVuOnJlc3RfbGVuIH5zcmM6c3JjLmVsdHMgfnNyY19wb3M6MCB+ZHN0IH5kc3RfcG9zOmZyb250X2xlblxuOztcblxubGV0IHNldF9jYXBhY2l0eSB0IGRlc2lyZWRfY2FwYWNpdHkgPVxuICAoKiBXZSBhbGxvdyBhcmd1bWVudHMgbGVzcyB0aGFuIDEgdG8gW3NldF9jYXBhY2l0eV0sIGJ1dCB0cmFuc2xhdGUgdGhlbSB0byAxIHRvIHNpbXBsaWZ5XG4gICAgIHRoZSBjb2RlIHRoYXQgcmVsaWVzIG9uIHRoZSBhcnJheSBsZW5ndGggYmVpbmcgYSBwb3dlciBvZiAyLiAqKVxuICBpbmNfbnVtX211dGF0aW9ucyB0O1xuICBsZXQgbmV3X2NhcGFjaXR5ID0gSW50LmNlaWxfcG93MiAobWF4IDEgKG1heCBkZXNpcmVkX2NhcGFjaXR5IHQubGVuZ3RoKSkgaW5cbiAgaWYgbmV3X2NhcGFjaXR5IDw+IGNhcGFjaXR5IHRcbiAgdGhlbiAoXG4gICAgbGV0IGRzdCA9IE9wdGlvbl9hcnJheS5jcmVhdGUgfmxlbjpuZXdfY2FwYWNpdHkgaW5cbiAgICBibGl0X3RvX2FycmF5IH5zcmM6dCBkc3Q7XG4gICAgdC5mcm9udCA8LSAwO1xuICAgIHQubWFzayA8LSBuZXdfY2FwYWNpdHkgLSAxO1xuICAgIHQuZWx0cyA8LSBkc3QpXG47O1xuXG5sZXQgZW5xdWV1ZSB0IGEgPVxuICBpbmNfbnVtX211dGF0aW9ucyB0O1xuICBpZiB0Lmxlbmd0aCA9IGNhcGFjaXR5IHQgdGhlbiBzZXRfY2FwYWNpdHkgdCAoMiAqIHQubGVuZ3RoKTtcbiAgdW5zYWZlX3NldCB0IHQubGVuZ3RoIGE7XG4gIHQubGVuZ3RoIDwtIHQubGVuZ3RoICsgMVxuOztcblxubGV0IGRlcXVldWVfbm9uZW1wdHkgdCA9XG4gIGluY19udW1fbXV0YXRpb25zIHQ7XG4gIGxldCBlbHRzID0gdC5lbHRzIGluXG4gIGxldCBmcm9udCA9IHQuZnJvbnQgaW5cbiAgbGV0IHJlcyA9IE9wdGlvbl9hcnJheS5nZXRfc29tZV9leG4gZWx0cyBmcm9udCBpblxuICBPcHRpb25fYXJyYXkuc2V0X25vbmUgZWx0cyBmcm9udDtcbiAgdC5mcm9udCA8LSBlbHRzX2luZGV4IHQgMTtcbiAgdC5sZW5ndGggPC0gdC5sZW5ndGggLSAxO1xuICByZXNcbjs7XG5cbmxldCBkZXF1ZXVlX2V4biB0ID0gaWYgaXNfZW1wdHkgdCB0aGVuIHJhaXNlIENhbWwuUXVldWUuRW1wdHkgZWxzZSBkZXF1ZXVlX25vbmVtcHR5IHRcbmxldCBkZXF1ZXVlIHQgPSBpZiBpc19lbXB0eSB0IHRoZW4gTm9uZSBlbHNlIFNvbWUgKGRlcXVldWVfbm9uZW1wdHkgdClcbmxldCBmcm9udF9ub25lbXB0eSB0ID0gT3B0aW9uX2FycmF5LnVuc2FmZV9nZXRfc29tZV9leG4gdC5lbHRzIHQuZnJvbnRcbmxldCBsYXN0X25vbmVtcHR5IHQgPSB1bnNhZmVfZ2V0IHQgKHQubGVuZ3RoIC0gMSlcbmxldCBwZWVrIHQgPSBpZiBpc19lbXB0eSB0IHRoZW4gTm9uZSBlbHNlIFNvbWUgKGZyb250X25vbmVtcHR5IHQpXG5sZXQgcGVla19leG4gdCA9IGlmIGlzX2VtcHR5IHQgdGhlbiByYWlzZSBDYW1sLlF1ZXVlLkVtcHR5IGVsc2UgZnJvbnRfbm9uZW1wdHkgdFxubGV0IGxhc3QgdCA9IGlmIGlzX2VtcHR5IHQgdGhlbiBOb25lIGVsc2UgU29tZSAobGFzdF9ub25lbXB0eSB0KVxubGV0IGxhc3RfZXhuIHQgPSBpZiBpc19lbXB0eSB0IHRoZW4gcmFpc2UgQ2FtbC5RdWV1ZS5FbXB0eSBlbHNlIGxhc3Rfbm9uZW1wdHkgdFxuXG5sZXQgY2xlYXIgdCA9XG4gIGluY19udW1fbXV0YXRpb25zIHQ7XG4gIGlmIHQubGVuZ3RoID4gMFxuICB0aGVuIChcbiAgICBmb3IgaSA9IDAgdG8gdC5sZW5ndGggLSAxIGRvXG4gICAgICB1bnNhZmVfdW5zZXQgdCBpXG4gICAgZG9uZTtcbiAgICB0Lmxlbmd0aCA8LSAwO1xuICAgIHQuZnJvbnQgPC0gMClcbjs7XG5cbmxldCBibGl0X3RyYW5zZmVyIH5zcmMgfmRzdCA/bGVuICgpID1cbiAgaW5jX251bV9tdXRhdGlvbnMgc3JjO1xuICBpbmNfbnVtX211dGF0aW9ucyBkc3Q7XG4gIGxldCBsZW4gPVxuICAgIG1hdGNoIGxlbiB3aXRoXG4gICAgfCBOb25lIC0+IHNyYy5sZW5ndGhcbiAgICB8IFNvbWUgbGVuIC0+XG4gICAgICBpZiBsZW4gPCAwXG4gICAgICB0aGVuXG4gICAgICAgIEVycm9yLnJhaXNlX3NcbiAgICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgICAgXCJRdWV1ZS5ibGl0X3RyYW5zZmVyOiBuZWdhdGl2ZSBsZW5ndGhcIlxuICAgICAgICAgICAgIFsgXCJsZW5ndGhcIiwgbGVuIHw+IEludC5zZXhwX29mX3QgXSk7XG4gICAgICBtaW4gbGVuIHNyYy5sZW5ndGhcbiAgaW5cbiAgaWYgbGVuID4gMFxuICB0aGVuIChcbiAgICBzZXRfY2FwYWNpdHkgZHN0IChtYXggKGNhcGFjaXR5IGRzdCkgKGRzdC5sZW5ndGggKyBsZW4pKTtcbiAgICBsZXQgZHN0X3N0YXJ0ID0gZHN0LmZyb250ICsgZHN0Lmxlbmd0aCBpblxuICAgIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgICAoKiBUaGlzIGlzIHNpZ25pZmljYW50bHkgZmFzdGVyIHRoYW4gc2ltcGx5IFtlbnF1ZXVlIGRzdCAoZGVxdWV1ZV9ub25lbXB0eSBzcmMpXSAqKVxuICAgICAgbGV0IHNyY19pID0gKHNyYy5mcm9udCArIGkpIGxhbmQgc3JjLm1hc2sgaW5cbiAgICAgIGxldCBkc3RfaSA9IChkc3Rfc3RhcnQgKyBpKSBsYW5kIGRzdC5tYXNrIGluXG4gICAgICBPcHRpb25fYXJyYXkudW5zYWZlX3NldF9zb21lXG4gICAgICAgIGRzdC5lbHRzXG4gICAgICAgIGRzdF9pXG4gICAgICAgIChPcHRpb25fYXJyYXkudW5zYWZlX2dldF9zb21lX2V4biBzcmMuZWx0cyBzcmNfaSk7XG4gICAgICBPcHRpb25fYXJyYXkudW5zYWZlX3NldF9ub25lIHNyYy5lbHRzIHNyY19pXG4gICAgZG9uZTtcbiAgICBkc3QubGVuZ3RoIDwtIGRzdC5sZW5ndGggKyBsZW47XG4gICAgc3JjLmZyb250IDwtIChzcmMuZnJvbnQgKyBsZW4pIGxhbmQgc3JjLm1hc2s7XG4gICAgc3JjLmxlbmd0aCA8LSBzcmMubGVuZ3RoIC0gbGVuKVxuOztcblxubGV0IGVucXVldWVfYWxsIHQgbCA9XG4gICgqIFRyYXZlcnNpbmcgdGhlIGxpc3QgdXAgZnJvbnQgdG8gY29tcHV0ZSBpdHMgbGVuZ3RoIGlzIHByb2JhYmx5IChidXQgbm90IGRlZmluaXRlbHkpXG4gICAgIGJldHRlciB0aGFuIGRvdWJsaW5nIHRoZSB1bmRlcmx5aW5nIGFycmF5IHNpemUgc2V2ZXJhbCB0aW1lcyBmb3IgbGFyZ2UgcXVldWVzLiAqKVxuICBzZXRfY2FwYWNpdHkgdCAoSW50Lm1heCAoY2FwYWNpdHkgdCkgKHQubGVuZ3RoICsgTGlzdC5sZW5ndGggbCkpO1xuICBMaXN0Lml0ZXIgbCB+ZjooZnVuIHggLT4gZW5xdWV1ZSB0IHgpXG47O1xuXG5sZXQgZm9sZCB0IH5pbml0IH5mID1cbiAgaWYgdC5sZW5ndGggPSAwXG4gIHRoZW4gaW5pdFxuICBlbHNlIChcbiAgICBsZXQgbnVtX211dGF0aW9ucyA9IHQubnVtX211dGF0aW9ucyBpblxuICAgIGxldCByID0gcmVmIGluaXQgaW5cbiAgICBmb3IgaSA9IDAgdG8gdC5sZW5ndGggLSAxIGRvXG4gICAgICByIDo9IGYgIXIgKHVuc2FmZV9nZXQgdCBpKTtcbiAgICAgIGVuc3VyZV9ub19tdXRhdGlvbiB0IG51bV9tdXRhdGlvbnNcbiAgICBkb25lO1xuICAgICFyKVxuOztcblxubGV0IGZvbGRpIHQgfmluaXQgfmYgPVxuICBsZXQgaSA9IHJlZiAwIGluXG4gIGZvbGQgdCB+aW5pdCB+ZjooZnVuIGFjYyBhIC0+XG4gICAgbGV0IGFjYyA9IGYgIWkgYWNjIGEgaW5cbiAgICBpIDo9ICFpICsgMTtcbiAgICBhY2MpXG47O1xuXG5cbigqIFtpdGVyXSBpcyBpbXBsZW1lbnRlZCBkaXJlY3RseSBiZWNhdXNlIGltcGxlbWVudGluZyBpdCBpbiB0ZXJtcyBvZiBbZm9sZF0gaXNcbiAgIHNsb3dlci4gKilcbmxldCBpdGVyIHQgfmYgPVxuICBsZXQgbnVtX211dGF0aW9ucyA9IHQubnVtX211dGF0aW9ucyBpblxuICBmb3IgaSA9IDAgdG8gdC5sZW5ndGggLSAxIGRvXG4gICAgZiAodW5zYWZlX2dldCB0IGkpO1xuICAgIGVuc3VyZV9ub19tdXRhdGlvbiB0IG51bV9tdXRhdGlvbnNcbiAgZG9uZVxuOztcblxubGV0IGl0ZXJpIHQgfmYgPVxuICBsZXQgbnVtX211dGF0aW9ucyA9IHQubnVtX211dGF0aW9ucyBpblxuICBmb3IgaSA9IDAgdG8gdC5sZW5ndGggLSAxIGRvXG4gICAgZiBpICh1bnNhZmVfZ2V0IHQgaSk7XG4gICAgZW5zdXJlX25vX211dGF0aW9uIHQgbnVtX211dGF0aW9uc1xuICBkb25lXG47O1xuXG5sZXQgdG9fbGlzdCB0ID1cbiAgbGV0IHJlc3VsdCA9IHJlZiBbXSBpblxuICBmb3IgaSA9IHQubGVuZ3RoIC0gMSBkb3dudG8gMCBkb1xuICAgIHJlc3VsdCA6PSB1bnNhZmVfZ2V0IHQgaSA6OiAhcmVzdWx0XG4gIGRvbmU7XG4gICFyZXN1bHRcbjs7XG5cbm1vZHVsZSBDID0gSW5kZXhlZF9jb250YWluZXIuTWFrZSAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICAgIGxldCBmb2xkID0gZm9sZFxuICAgIGxldCBpdGVyID0gYEN1c3RvbSBpdGVyXG4gICAgbGV0IGxlbmd0aCA9IGBDdXN0b20gbGVuZ3RoXG4gICAgbGV0IGZvbGRpID0gYEN1c3RvbSBmb2xkaVxuICAgIGxldCBpdGVyaSA9IGBDdXN0b20gaXRlcmlcbiAgZW5kKVxuXG5sZXQgY291bnQgPSBDLmNvdW50XG5sZXQgZXhpc3RzID0gQy5leGlzdHNcbmxldCBmaW5kID0gQy5maW5kXG5sZXQgZmluZF9tYXAgPSBDLmZpbmRfbWFwXG5sZXQgZm9sZF9yZXN1bHQgPSBDLmZvbGRfcmVzdWx0XG5sZXQgZm9sZF91bnRpbCA9IEMuZm9sZF91bnRpbFxubGV0IGZvcl9hbGwgPSBDLmZvcl9hbGxcbmxldCBtYXhfZWx0ID0gQy5tYXhfZWx0XG5sZXQgbWVtID0gQy5tZW1cbmxldCBtaW5fZWx0ID0gQy5taW5fZWx0XG5sZXQgc3VtID0gQy5zdW1cbmxldCBjb3VudGkgPSBDLmNvdW50aVxubGV0IGV4aXN0c2kgPSBDLmV4aXN0c2lcbmxldCBmaW5kX21hcGkgPSBDLmZpbmRfbWFwaVxubGV0IGZpbmRpID0gQy5maW5kaVxubGV0IGZvcl9hbGxpID0gQy5mb3JfYWxsaVxuXG5cbigqIEZvciBbY29uY2F0X21hcF0sIFtmaWx0ZXJfbWFwXSwgYW5kIFtmaWx0ZXJdLCB3ZSBkb24ndCBjcmVhdGUgW3RfcmVzdWx0XSB3aXRoIFt0XSdzXG4gICBjYXBhY2l0eSBiZWNhdXNlIHdlIGhhdmUgbm8gaWRlYSBob3cgbWFueSBlbGVtZW50cyBbdF9yZXN1bHRdIHdpbGwgdWx0aW1hdGVseSBob2xkLiAqKVxubGV0IGNvbmNhdF9tYXAgdCB+ZiA9XG4gIGxldCB0X3Jlc3VsdCA9IGNyZWF0ZSAoKSBpblxuICBpdGVyIHQgfmY6KGZ1biBhIC0+IExpc3QuaXRlciAoZiBhKSB+ZjooZnVuIGIgLT4gZW5xdWV1ZSB0X3Jlc3VsdCBiKSk7XG4gIHRfcmVzdWx0XG47O1xuXG5sZXQgY29uY2F0X21hcGkgdCB+ZiA9XG4gIGxldCB0X3Jlc3VsdCA9IGNyZWF0ZSAoKSBpblxuICBpdGVyaSB0IH5mOihmdW4gaSBhIC0+IExpc3QuaXRlciAoZiBpIGEpIH5mOihmdW4gYiAtPiBlbnF1ZXVlIHRfcmVzdWx0IGIpKTtcbiAgdF9yZXN1bHRcbjs7XG5cbmxldCBmaWx0ZXJfbWFwIHQgfmYgPVxuICBsZXQgdF9yZXN1bHQgPSBjcmVhdGUgKCkgaW5cbiAgaXRlciB0IH5mOihmdW4gYSAtPlxuICAgIG1hdGNoIGYgYSB3aXRoXG4gICAgfCBOb25lIC0+ICgpXG4gICAgfCBTb21lIGIgLT4gZW5xdWV1ZSB0X3Jlc3VsdCBiKTtcbiAgdF9yZXN1bHRcbjs7XG5cbmxldCBmaWx0ZXJfbWFwaSB0IH5mID1cbiAgbGV0IHRfcmVzdWx0ID0gY3JlYXRlICgpIGluXG4gIGl0ZXJpIHQgfmY6KGZ1biBpIGEgLT5cbiAgICBtYXRjaCBmIGkgYSB3aXRoXG4gICAgfCBOb25lIC0+ICgpXG4gICAgfCBTb21lIGIgLT4gZW5xdWV1ZSB0X3Jlc3VsdCBiKTtcbiAgdF9yZXN1bHRcbjs7XG5cbmxldCBmaWx0ZXIgdCB+ZiA9XG4gIGxldCB0X3Jlc3VsdCA9IGNyZWF0ZSAoKSBpblxuICBpdGVyIHQgfmY6KGZ1biBhIC0+IGlmIGYgYSB0aGVuIGVucXVldWUgdF9yZXN1bHQgYSk7XG4gIHRfcmVzdWx0XG47O1xuXG5sZXQgZmlsdGVyaSB0IH5mID1cbiAgbGV0IHRfcmVzdWx0ID0gY3JlYXRlICgpIGluXG4gIGl0ZXJpIHQgfmY6KGZ1biBpIGEgLT4gaWYgZiBpIGEgdGhlbiBlbnF1ZXVlIHRfcmVzdWx0IGEpO1xuICB0X3Jlc3VsdFxuOztcblxubGV0IGZpbHRlcl9pbnBsYWNlIHQgfmYgPVxuICBsZXQgdDIgPSBmaWx0ZXIgdCB+ZiBpblxuICBjbGVhciB0O1xuICBibGl0X3RyYW5zZmVyIH5zcmM6dDIgfmRzdDp0ICgpXG47O1xuXG5sZXQgZmlsdGVyaV9pbnBsYWNlIHQgfmYgPVxuICBsZXQgdDIgPSBmaWx0ZXJpIHQgfmYgaW5cbiAgY2xlYXIgdDtcbiAgYmxpdF90cmFuc2ZlciB+c3JjOnQyIH5kc3Q6dCAoKVxuOztcblxubGV0IGNvcHkgc3JjID1cbiAgbGV0IGRzdCA9IGNyZWF0ZSB+Y2FwYWNpdHk6c3JjLmxlbmd0aCAoKSBpblxuICBibGl0X3RvX2FycmF5IH5zcmMgZHN0LmVsdHM7XG4gIGRzdC5sZW5ndGggPC0gc3JjLmxlbmd0aDtcbiAgZHN0XG47O1xuXG5sZXQgb2ZfbGlzdCBsID1cbiAgKCogVHJhdmVyc2luZyB0aGUgbGlzdCB1cCBmcm9udCB0byBjb21wdXRlIGl0cyBsZW5ndGggaXMgcHJvYmFibHkgKGJ1dCBub3QgZGVmaW5pdGVseSlcbiAgICAgYmV0dGVyIHRoYW4gZG91YmxpbmcgdGhlIHVuZGVybHlpbmcgYXJyYXkgc2l6ZSBzZXZlcmFsIHRpbWVzIGZvciBsYXJnZSBxdWV1ZXMuICopXG4gIGxldCB0ID0gY3JlYXRlIH5jYXBhY2l0eTooTGlzdC5sZW5ndGggbCkgKCkgaW5cbiAgTGlzdC5pdGVyIGwgfmY6KGZ1biB4IC0+IGVucXVldWUgdCB4KTtcbiAgdFxuOztcblxuKCogVGhlIHF1ZXVlIFt0XSByZXR1cm5lZCBieSBbY3JlYXRlXSB3aWxsIGhhdmUgW3QubGVuZ3RoID0gMF0sIFt0LmZyb250ID0gMF0sIGFuZFxuICAgW2NhcGFjaXR5IHQgPSBJbnQuY2VpbF9wb3cyIGxlbl0uICBTbywgd2Ugb25seSBoYXZlIHRvIHNldCBbdC5sZW5ndGhdIHRvIFtsZW5dIGFmdGVyXG4gICB0aGUgYmxpdCB0byBtYWludGFpbiBhbGwgdGhlIGludmFyaWFudHM6IFt0Lmxlbmd0aF0gaXMgZXF1YWwgdG8gdGhlIG51bWJlciBvZiBlbGVtZW50c1xuICAgaW4gdGhlIHF1ZXVlLCBbdC5mcm9udF0gaXMgdGhlIGFycmF5IGluZGV4IG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBxdWV1ZSwgYW5kXG4gICBbY2FwYWNpdHkgdCA9IE9wdGlvbl9hcnJheS5sZW5ndGggdC5lbHRzXS4gKilcbmxldCBpbml0IGxlbiB+ZiA9XG4gIGlmIGxlbiA8IDBcbiAgdGhlblxuICAgIEVycm9yLnJhaXNlX3NcbiAgICAgIChTZXhwLm1lc3NhZ2UgXCJRdWV1ZS5pbml0OiBuZWdhdGl2ZSBsZW5ndGhcIiBbIFwibGVuZ3RoXCIsIGxlbiB8PiBJbnQuc2V4cF9vZl90IF0pO1xuICBsZXQgdCA9IGNyZWF0ZSB+Y2FwYWNpdHk6bGVuICgpIGluXG4gIGFzc2VydCAoT3B0aW9uX2FycmF5Lmxlbmd0aCB0LmVsdHMgPj0gbGVuKTtcbiAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICBPcHRpb25fYXJyYXkudW5zYWZlX3NldF9zb21lIHQuZWx0cyBpIChmIGkpXG4gIGRvbmU7XG4gIHQubGVuZ3RoIDwtIGxlbjtcbiAgdFxuOztcblxubGV0IG9mX2FycmF5IGEgPSBpbml0IChBcnJheS5sZW5ndGggYSkgfmY6KEFycmF5LnVuc2FmZV9nZXQgYSlcbmxldCB0b19hcnJheSB0ID0gQXJyYXkuaW5pdCB0Lmxlbmd0aCB+ZjooZnVuIGkgLT4gdW5zYWZlX2dldCB0IGkpXG5cbmxldCBtYXAgdGEgfmYgPVxuICBsZXQgbnVtX211dGF0aW9ucyA9IHRhLm51bV9tdXRhdGlvbnMgaW5cbiAgbGV0IHRiID0gY3JlYXRlIH5jYXBhY2l0eTp0YS5sZW5ndGggKCkgaW5cbiAgdGIubGVuZ3RoIDwtIHRhLmxlbmd0aDtcbiAgZm9yIGkgPSAwIHRvIHRhLmxlbmd0aCAtIDEgZG9cbiAgICBsZXQgYiA9IGYgKHVuc2FmZV9nZXQgdGEgaSkgaW5cbiAgICBlbnN1cmVfbm9fbXV0YXRpb24gdGEgbnVtX211dGF0aW9ucztcbiAgICBPcHRpb25fYXJyYXkudW5zYWZlX3NldF9zb21lIHRiLmVsdHMgaSBiXG4gIGRvbmU7XG4gIHRiXG47O1xuXG5sZXQgbWFwaSB0IH5mID1cbiAgbGV0IGkgPSByZWYgMCBpblxuICBtYXAgdCB+ZjooZnVuIGEgLT5cbiAgICBsZXQgcmVzdWx0ID0gZiAhaSBhIGluXG4gICAgaSA6PSAhaSArIDE7XG4gICAgcmVzdWx0KVxuOztcblxubGV0IHNpbmdsZXRvbiB4ID1cbiAgbGV0IHQgPSBjcmVhdGUgKCkgaW5cbiAgZW5xdWV1ZSB0IHg7XG4gIHRcbjs7XG5cbmxldCBzZXhwX29mX3Qgc2V4cF9vZl9hIHQgPSB0b19saXN0IHQgfD4gTGlzdC5zZXhwX29mX3Qgc2V4cF9vZl9hXG5sZXQgdF9vZl9zZXhwIGFfb2Zfc2V4cCBzZXhwID0gTGlzdC50X29mX3NleHAgYV9vZl9zZXhwIHNleHAgfD4gb2ZfbGlzdFxuXG5sZXQgdF9zZXhwX2dyYW1tYXIgKHR5cGUgYSkgKGdyYW1tYXIgOiBhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50KVxuICA6IGEgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICA9XG4gIFNleHBsaWIwLlNleHBfZ3JhbW1hci5jb2VyY2UgKExpc3QudF9zZXhwX2dyYW1tYXIgZ3JhbW1hcilcbjs7XG4iLCJvcGVuISBJbXBvcnQwXG5cbnR5cGUgJ2EgdCA9ICdhIENhbWwuUXVldWUudFxuXG5sZXQgY3JlYXRlID0gQ2FtbC5RdWV1ZS5jcmVhdGVcbmxldCBjbGVhciA9IENhbWwuUXVldWUuY2xlYXJcbmxldCBjb3B5ID0gQ2FtbC5RdWV1ZS5jb3B5XG5sZXQgaXNfZW1wdHkgPSBDYW1sLlF1ZXVlLmlzX2VtcHR5XG5sZXQgbGVuZ3RoID0gQ2FtbC5RdWV1ZS5sZW5ndGhcbmxldCBwZWVrID0gQ2FtbC5RdWV1ZS5wZWVrXG5sZXQgcG9wID0gQ2FtbC5RdWV1ZS5wb3BcbmxldCBwdXNoID0gQ2FtbC5RdWV1ZS5wdXNoXG5sZXQgdHJhbnNmZXIgPSBDYW1sLlF1ZXVlLnRyYW5zZmVyXG5sZXQgaXRlciB0IH5mID0gQ2FtbC5RdWV1ZS5pdGVyIGYgdFxubGV0IGZvbGQgdCB+aW5pdCB+ZiA9IENhbWwuUXVldWUuZm9sZCBmIGluaXQgdFxuIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIExpbmtlZF9xdWV1ZTBcblxubGV0IGVucXVldWUgdCB4ID0gTGlua2VkX3F1ZXVlMC5wdXNoIHggdFxubGV0IGRlcXVldWUgdCA9IGlmIGlzX2VtcHR5IHQgdGhlbiBOb25lIGVsc2UgU29tZSAoTGlua2VkX3F1ZXVlMC5wb3AgdClcbmxldCBkZXF1ZXVlX2V4biA9IExpbmtlZF9xdWV1ZTAucG9wXG5sZXQgcGVlayB0ID0gaWYgaXNfZW1wdHkgdCB0aGVuIE5vbmUgZWxzZSBTb21lIChMaW5rZWRfcXVldWUwLnBlZWsgdClcbmxldCBwZWVrX2V4biA9IExpbmtlZF9xdWV1ZTAucGVla1xuXG5tb2R1bGUgQyA9IEluZGV4ZWRfY29udGFpbmVyLk1ha2UgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgICBsZXQgZm9sZCA9IGZvbGRcbiAgICBsZXQgaXRlciA9IGBDdXN0b20gaXRlclxuICAgIGxldCBsZW5ndGggPSBgQ3VzdG9tIGxlbmd0aFxuICAgIGxldCBmb2xkaSA9IGBEZWZpbmVfdXNpbmdfZm9sZFxuICAgIGxldCBpdGVyaSA9IGBEZWZpbmVfdXNpbmdfZm9sZFxuICBlbmQpXG5cbmxldCBjb3VudCA9IEMuY291bnRcbmxldCBleGlzdHMgPSBDLmV4aXN0c1xubGV0IGZpbmQgPSBDLmZpbmRcbmxldCBmaW5kX21hcCA9IEMuZmluZF9tYXBcbmxldCBmb2xkX3Jlc3VsdCA9IEMuZm9sZF9yZXN1bHRcbmxldCBmb2xkX3VudGlsID0gQy5mb2xkX3VudGlsXG5sZXQgZm9yX2FsbCA9IEMuZm9yX2FsbFxubGV0IG1heF9lbHQgPSBDLm1heF9lbHRcbmxldCBtZW0gPSBDLm1lbVxubGV0IG1pbl9lbHQgPSBDLm1pbl9lbHRcbmxldCBzdW0gPSBDLnN1bVxubGV0IHRvX2xpc3QgPSBDLnRvX2xpc3RcbmxldCBjb3VudGkgPSBDLmNvdW50aVxubGV0IGV4aXN0c2kgPSBDLmV4aXN0c2lcbmxldCBmaW5kX21hcGkgPSBDLmZpbmRfbWFwaVxubGV0IGZpbmRpID0gQy5maW5kaVxubGV0IGZvbGRpID0gQy5mb2xkaVxubGV0IGZvcl9hbGxpID0gQy5mb3JfYWxsaVxubGV0IGl0ZXJpID0gQy5pdGVyaVxubGV0IHRyYW5zZmVyIH5zcmMgfmRzdCA9IExpbmtlZF9xdWV1ZTAudHJhbnNmZXIgc3JjIGRzdFxuXG5sZXQgY29uY2F0X21hcCB0IH5mID1cbiAgbGV0IHJlcyA9IGNyZWF0ZSAoKSBpblxuICBpdGVyIHQgfmY6KGZ1biBhIC0+IExpc3QuaXRlciAoZiBhKSB+ZjooZnVuIGIgLT4gZW5xdWV1ZSByZXMgYikpO1xuICByZXNcbjs7XG5cbmxldCBjb25jYXRfbWFwaSB0IH5mID1cbiAgbGV0IHJlcyA9IGNyZWF0ZSAoKSBpblxuICBpdGVyaSB0IH5mOihmdW4gaSBhIC0+IExpc3QuaXRlciAoZiBpIGEpIH5mOihmdW4gYiAtPiBlbnF1ZXVlIHJlcyBiKSk7XG4gIHJlc1xuOztcblxubGV0IGZpbHRlcl9tYXAgdCB+ZiA9XG4gIGxldCByZXMgPSBjcmVhdGUgKCkgaW5cbiAgaXRlciB0IH5mOihmdW4gYSAtPlxuICAgIG1hdGNoIGYgYSB3aXRoXG4gICAgfCBOb25lIC0+ICgpXG4gICAgfCBTb21lIGIgLT4gZW5xdWV1ZSByZXMgYik7XG4gIHJlc1xuOztcblxubGV0IGZpbHRlcl9tYXBpIHQgfmYgPVxuICBsZXQgcmVzID0gY3JlYXRlICgpIGluXG4gIGl0ZXJpIHQgfmY6KGZ1biBpIGEgLT5cbiAgICBtYXRjaCBmIGkgYSB3aXRoXG4gICAgfCBOb25lIC0+ICgpXG4gICAgfCBTb21lIGIgLT4gZW5xdWV1ZSByZXMgYik7XG4gIHJlc1xuOztcblxubGV0IGZpbHRlciB0IH5mID1cbiAgbGV0IHJlcyA9IGNyZWF0ZSAoKSBpblxuICBpdGVyIHQgfmY6KGZ1biBhIC0+IGlmIGYgYSB0aGVuIGVucXVldWUgcmVzIGEpO1xuICByZXNcbjs7XG5cbmxldCBmaWx0ZXJpIHQgfmYgPVxuICBsZXQgcmVzID0gY3JlYXRlICgpIGluXG4gIGl0ZXJpIHQgfmY6KGZ1biBpIGEgLT4gaWYgZiBpIGEgdGhlbiBlbnF1ZXVlIHJlcyBhKTtcbiAgcmVzXG47O1xuXG5sZXQgbWFwIHQgfmYgPVxuICBsZXQgcmVzID0gY3JlYXRlICgpIGluXG4gIGl0ZXIgdCB+ZjooZnVuIGEgLT4gZW5xdWV1ZSByZXMgKGYgYSkpO1xuICByZXNcbjs7XG5cbmxldCBtYXBpIHQgfmYgPVxuICBsZXQgcmVzID0gY3JlYXRlICgpIGluXG4gIGl0ZXJpIHQgfmY6KGZ1biBpIGEgLT4gZW5xdWV1ZSByZXMgKGYgaSBhKSk7XG4gIHJlc1xuOztcblxubGV0IGZpbHRlcl9pbnBsYWNlIHEgfmYgPVxuICBsZXQgcScgPSBmaWx0ZXIgcSB+ZiBpblxuICBjbGVhciBxO1xuICB0cmFuc2ZlciB+c3JjOnEnIH5kc3Q6cVxuOztcblxubGV0IGZpbHRlcmlfaW5wbGFjZSBxIH5mID1cbiAgbGV0IHEnID0gZmlsdGVyaSBxIH5mIGluXG4gIGNsZWFyIHE7XG4gIHRyYW5zZmVyIH5zcmM6cScgfmRzdDpxXG47O1xuXG5sZXQgZW5xdWV1ZV9hbGwgdCBsaXN0ID0gTGlzdC5pdGVyIGxpc3QgfmY6KGZ1biB4IC0+IGVucXVldWUgdCB4KVxuXG5sZXQgb2ZfbGlzdCBsaXN0ID1cbiAgbGV0IHQgPSBjcmVhdGUgKCkgaW5cbiAgTGlzdC5pdGVyIGxpc3QgfmY6KGZ1biB4IC0+IGVucXVldWUgdCB4KTtcbiAgdFxuOztcblxubGV0IG9mX2FycmF5IGFycmF5ID1cbiAgbGV0IHQgPSBjcmVhdGUgKCkgaW5cbiAgQXJyYXkuaXRlciBhcnJheSB+ZjooZnVuIHggLT4gZW5xdWV1ZSB0IHgpO1xuICB0XG47O1xuXG5sZXQgaW5pdCBsZW4gfmYgPVxuICBsZXQgdCA9IGNyZWF0ZSAoKSBpblxuICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgIGVucXVldWUgdCAoZiBpKVxuICBkb25lO1xuICB0XG47O1xuXG5sZXQgdG9fYXJyYXkgdCA9XG4gIG1hdGNoIGxlbmd0aCB0IHdpdGhcbiAgfCAwIC0+IFt8fF1cbiAgfCBsZW4gLT5cbiAgICBsZXQgYXJyID0gQXJyYXkuY3JlYXRlIH5sZW4gKHBlZWtfZXhuIHQpIGluXG4gICAgbGV0IGkgPSByZWYgMCBpblxuICAgIGl0ZXIgdCB+ZjooZnVuIHYgLT5cbiAgICAgIGFyci4oIWkpIDwtIHY7XG4gICAgICBpbmNyIGkpO1xuICAgIGFyclxuOztcblxubGV0IHRfb2Zfc2V4cCBhX29mX3NleHAgc2V4cCA9IG9mX2xpc3QgKGxpc3Rfb2Zfc2V4cCBhX29mX3NleHAgc2V4cClcbmxldCBzZXhwX29mX3Qgc2V4cF9vZl9hIHQgPSBzZXhwX29mX2xpc3Qgc2V4cF9vZl9hICh0b19saXN0IHQpXG5cbmxldCB0X3NleHBfZ3JhbW1hciAodHlwZSBhKSAoZ3JhbW1hciA6IGEgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpXG4gIDogYSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gID1cbiAgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLmNvZXJjZSAoTGlzdC50X3NleHBfZ3JhbW1hciBncmFtbWFyKVxuOztcblxubGV0IHNpbmdsZXRvbiBhID1cbiAgbGV0IHQgPSBjcmVhdGUgKCkgaW5cbiAgZW5xdWV1ZSB0IGE7XG4gIHRcbjs7XG4iLCIoKiBBIGZldyBzbWFsbCB0aGluZ3MgY29waWVkIGZyb20gb3RoZXIgcGFydHMgb2YgQmFzZSBiZWNhdXNlIHRoZXkgZGVwZW5kIG9uIHVzLCBzbyB3ZVxuICAgY2FuJ3QgdXNlIHRoZW0uICopXG5cbm9wZW4hIEltcG9ydFxuXG5sZXQgcmFpc2VfcyA9IEVycm9yLnJhaXNlX3NcblxubW9kdWxlIEludCA9IHN0cnVjdFxuICB0eXBlIHQgPSBpbnRcblxuICBsZXQgbWF4ICh4IDogdCkgeSA9IGlmIHggPiB5IHRoZW4geCBlbHNlIHlcbmVuZFxuXG4oKiBJdHMgaW1wb3J0YW50IHRoYXQgRW1wdHkgaGF2ZSBubyBhcmdzLiBJdCdzIHRlbXB0aW5nIHRvIG1ha2UgdGhpcyB0eXBlIGEgcmVjb3JkXG4gICAoZS5nLiB0byBob2xkIHRoZSBjb21wYXJlIGZ1bmN0aW9uKSwgYnV0IGEgbG90IG9mIG1lbW9yeSBpcyBzYXZlZCBieSBFbXB0eSBiZWluZyBhblxuICAgaW1tZWRpYXRlLCBzaW5jZSBhbGwgdW51c2VkIGJ1Y2tldHMgaW4gdGhlIGhhc2h0YmwgZG9uJ3QgdXNlIGFueSBtZW1vcnkgKGJlc2lkZXMgdGhlXG4gICBhcnJheSBjZWxsKSAqKVxudHlwZSAoJ2ssICd2KSB0ID1cbiAgfCBFbXB0eVxuICB8IE5vZGUgb2ZcbiAgICAgIHsgbXV0YWJsZSBsZWZ0IDogKCdrLCAndikgdFxuICAgICAgOyBrZXkgOiAna1xuICAgICAgOyBtdXRhYmxlIHZhbHVlIDogJ3ZcbiAgICAgIDsgbXV0YWJsZSBoZWlnaHQgOiBpbnRcbiAgICAgIDsgbXV0YWJsZSByaWdodCA6ICgnaywgJ3YpIHRcbiAgICAgIH1cbiAgfCBMZWFmIG9mXG4gICAgICB7IGtleSA6ICdrXG4gICAgICA7IG11dGFibGUgdmFsdWUgOiAndlxuICAgICAgfVxuXG5sZXQgZW1wdHkgPSBFbXB0eVxuXG5sZXQgaXNfZW1wdHkgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+IHRydWVcbiAgfCBMZWFmIF8gfCBOb2RlIF8gLT4gZmFsc2Vcbjs7XG5cbmxldCBoZWlnaHQgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+IDBcbiAgfCBMZWFmIF8gLT4gMVxuICB8IE5vZGUgeyBsZWZ0ID0gXzsga2V5ID0gXzsgdmFsdWUgPSBfOyBoZWlnaHQ7IHJpZ2h0ID0gXyB9IC0+IGhlaWdodFxuOztcblxubGV0IGludmFyaWFudCBjb21wYXJlID1cbiAgbGV0IGxlZ2FsX2xlZnRfa2V5IGtleSA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPiAoKVxuICAgIHwgTGVhZiB7IGtleSA9IGxlZnRfa2V5OyB2YWx1ZSA9IF8gfVxuICAgIHwgTm9kZSB7IGxlZnQgPSBfOyBrZXkgPSBsZWZ0X2tleTsgdmFsdWUgPSBfOyBoZWlnaHQgPSBfOyByaWdodCA9IF8gfSAtPlxuICAgICAgYXNzZXJ0IChjb21wYXJlIGxlZnRfa2V5IGtleSA8IDApXG4gIGluXG4gIGxldCBsZWdhbF9yaWdodF9rZXkga2V5ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+ICgpXG4gICAgfCBMZWFmIHsga2V5ID0gcmlnaHRfa2V5OyB2YWx1ZSA9IF8gfVxuICAgIHwgTm9kZSB7IGxlZnQgPSBfOyBrZXkgPSByaWdodF9rZXk7IHZhbHVlID0gXzsgaGVpZ2h0ID0gXzsgcmlnaHQgPSBfIH0gLT5cbiAgICAgIGFzc2VydCAoY29tcGFyZSByaWdodF9rZXkga2V5ID4gMClcbiAgaW5cbiAgbGV0IHJlYyBpbnYgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgfCBMZWFmIF8gLT4gKClcbiAgICB8IE5vZGUgeyBsZWZ0OyBrZXkgPSBrOyB2YWx1ZSA9IF87IGhlaWdodCA9IGg7IHJpZ2h0IH0gLT5cbiAgICAgIGxldCBobCwgaHIgPSBoZWlnaHQgbGVmdCwgaGVpZ2h0IHJpZ2h0IGluXG4gICAgICBpbnYgbGVmdDtcbiAgICAgIGludiByaWdodDtcbiAgICAgIGxlZ2FsX2xlZnRfa2V5IGsgbGVmdDtcbiAgICAgIGxlZ2FsX3JpZ2h0X2tleSBrIHJpZ2h0O1xuICAgICAgYXNzZXJ0IChoID0gSW50Lm1heCBobCBociArIDEpO1xuICAgICAgYXNzZXJ0IChhYnMgKGhsIC0gaHIpIDw9IDIpXG4gIGluXG4gIGludlxuOztcblxubGV0IGludmFyaWFudCB0IH5jb21wYXJlID0gaW52YXJpYW50IGNvbXBhcmUgdFxuXG4oKiBJbiB0aGUgZm9sbG93aW5nIGNvbW1lbnRzLFxuICAgJ3QgaXMgYmFsYW5jZWQnIG1lYW5zIHRoYXQgJ2ludmFyaWFudCB0JyBkb2VzIG5vdFxuICAgcmFpc2UgYW4gZXhjZXB0aW9uLiAgVGhpcyBpbXBsaWVzIG9mIGNvdXJzZSB0aGF0IGVhY2ggbm9kZSdzIGhlaWdodCBmaWVsZCBpc1xuICAgY29ycmVjdC5cbiAgICd0IGlzIGJhbGFuY2VhYmxlJyBtZWFucyB0aGF0IGhlaWdodCBvZiB0aGUgbGVmdCBhbmQgcmlnaHQgc3VidHJlZXMgb2YgdFxuICAgZGlmZmVyIGJ5IGF0IG1vc3QgMy4gKilcblxuKCogQHByZTogbGVmdCBhbmQgcmlnaHQgc3VidHJlZXMgaGF2ZSBjb3JyZWN0IGhlaWdodHNcbiAgIEBwb3N0OiBvdXRwdXQgaGFzIHRoZSBjb3JyZWN0IGhlaWdodCAqKVxubGV0IHVwZGF0ZV9oZWlnaHQgPSBmdW5jdGlvblxuICB8IE5vZGUgKHsgbGVmdDsga2V5ID0gXzsgdmFsdWUgPSBfOyBoZWlnaHQgPSBvbGRfaGVpZ2h0OyByaWdodCB9IGFzIHgpIC0+XG4gICAgbGV0IG5ld19oZWlnaHQgPSBJbnQubWF4IChoZWlnaHQgbGVmdCkgKGhlaWdodCByaWdodCkgKyAxIGluXG4gICAgaWYgbmV3X2hlaWdodCA8PiBvbGRfaGVpZ2h0IHRoZW4geC5oZWlnaHQgPC0gbmV3X2hlaWdodFxuICB8IEVtcHR5IHwgTGVhZiBfIC0+IGFzc2VydCBmYWxzZVxuOztcblxuKCogQHByZTogbGVmdCBhbmQgcmlnaHQgc3VidHJlZXMgYXJlIGJhbGFuY2VkXG4gICBAcHJlOiB0cmVlIGlzIGJhbGFuY2VhYmxlXG4gICBAcG9zdDogb3V0cHV0IGlzIGJhbGFuY2VkIChpbiBwYXJ0aWN1bGFyLCBoZWlnaHQgaXMgY29ycmVjdCkgKilcbmxldCBiYWxhbmNlIHRyZWUgPVxuICBtYXRjaCB0cmVlIHdpdGhcbiAgfCBFbXB0eSB8IExlYWYgXyAtPiB0cmVlXG4gIHwgTm9kZSAoeyBsZWZ0OyBrZXkgPSBfOyB2YWx1ZSA9IF87IGhlaWdodCA9IF87IHJpZ2h0IH0gYXMgcm9vdF9ub2RlKSAtPlxuICAgIGxldCBobCA9IGhlaWdodCBsZWZ0XG4gICAgYW5kIGhyID0gaGVpZ2h0IHJpZ2h0IGluXG4gICAgKCogKyAyIGlzIGNyaXRpY2FsbHkgaW1wb3J0YW50LCBsb3dlcmluZyBpdCB0byAxIHdpbGwgYnJlYWsgdGhlIExlYWZcbiAgICAgICBhc3N1bXB0aW9ucyBpbiB0aGUgY29kZSBiZWxvdywgYW5kIHdpbGwgZm9yY2UgdXMgdG8gcHJvbW90ZSBsZWFmIG5vZGVzIGluXG4gICAgICAgdGhlIGJhbGFuY2Ugcm91dGluZS4gSXQncyBhbHNvIGZhc3Rlciwgc2luY2UgaXQgd2lsbCBiYWxhbmNlIGxlc3Mgb2Z0ZW4uXG4gICAgICAgTm90ZSB0aGF0IHRoZSBmb2xsb3dpbmcgY29kZSBpcyBkZWxpY2F0ZS4gIFRoZSB1cGRhdGVfaGVpZ2h0IGNhbGxzIG11c3RcbiAgICAgICBvY2N1ciBpbiB0aGUgY29ycmVjdCBvcmRlciwgc2luY2UgdXBkYXRlX2hlaWdodCBhc3N1bWVzIGl0cyBjaGlsZHJlbiBoYXZlXG4gICAgICAgdGhlIGNvcnJlY3QgaGVpZ2h0cy4gICopXG4gICAgaWYgaGwgPiBociArIDJcbiAgICB0aGVuIChcbiAgICAgIG1hdGNoIGxlZnQgd2l0aFxuICAgICAgKCogSXQgY2Fubm90IGJlIGEgbGVhZiwgYmVjYXVzZSBldmVuIGlmIHJpZ2h0IGlzIGVtcHR5LCBhIGxlYWZcbiAgICAgICAgIGlzIG9ubHkgaGVpZ2h0IDEgKilcbiAgICAgIHwgRW1wdHkgfCBMZWFmIF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICB8IE5vZGVcbiAgICAgICAgICAoeyBsZWZ0ID0gbGVmdF9ub2RlX2xlZnRcbiAgICAgICAgICAgOyBrZXkgPSBfXG4gICAgICAgICAgIDsgdmFsdWUgPSBfXG4gICAgICAgICAgIDsgaGVpZ2h0ID0gX1xuICAgICAgICAgICA7IHJpZ2h0ID0gbGVmdF9ub2RlX3JpZ2h0XG4gICAgICAgICAgIH0gYXMgbGVmdF9ub2RlKSAtPlxuICAgICAgICBpZiBoZWlnaHQgbGVmdF9ub2RlX2xlZnQgPj0gaGVpZ2h0IGxlZnRfbm9kZV9yaWdodFxuICAgICAgICB0aGVuIChcbiAgICAgICAgICByb290X25vZGUubGVmdCA8LSBsZWZ0X25vZGVfcmlnaHQ7XG4gICAgICAgICAgbGVmdF9ub2RlLnJpZ2h0IDwtIHRyZWU7XG4gICAgICAgICAgdXBkYXRlX2hlaWdodCB0cmVlO1xuICAgICAgICAgIHVwZGF0ZV9oZWlnaHQgbGVmdDtcbiAgICAgICAgICBsZWZ0KVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICAoKiBpZiByaWdodCBpcyBhIGxlYWYsIHRoZW4gbGVmdCBtdXN0IGJlIGVtcHR5LiBUaGF0IG1lYW5zXG4gICAgICAgICAgICAgaGVpZ2h0IGlzIDIuIEV2ZW4gaWYgaHIgaXMgZW1wdHkgd2Ugc3RpbGwgY2FuJ3QgZ2V0IGhlcmUuICopXG4gICAgICAgICAgbWF0Y2ggbGVmdF9ub2RlX3JpZ2h0IHdpdGhcbiAgICAgICAgICB8IEVtcHR5IHwgTGVhZiBfIC0+IGFzc2VydCBmYWxzZVxuICAgICAgICAgIHwgTm9kZVxuICAgICAgICAgICAgICAoeyBsZWZ0ID0gbHJfbGVmdDsga2V5ID0gXzsgdmFsdWUgPSBfOyBoZWlnaHQgPSBfOyByaWdodCA9IGxyX3JpZ2h0IH0gYXNcbiAgICAgICAgICAgICAgIGxyX25vZGUpIC0+XG4gICAgICAgICAgICBsZWZ0X25vZGUucmlnaHQgPC0gbHJfbGVmdDtcbiAgICAgICAgICAgIHJvb3Rfbm9kZS5sZWZ0IDwtIGxyX3JpZ2h0O1xuICAgICAgICAgICAgbHJfbm9kZS5yaWdodCA8LSB0cmVlO1xuICAgICAgICAgICAgbHJfbm9kZS5sZWZ0IDwtIGxlZnQ7XG4gICAgICAgICAgICB1cGRhdGVfaGVpZ2h0IGxlZnQ7XG4gICAgICAgICAgICB1cGRhdGVfaGVpZ2h0IHRyZWU7XG4gICAgICAgICAgICB1cGRhdGVfaGVpZ2h0IGxlZnRfbm9kZV9yaWdodDtcbiAgICAgICAgICAgIGxlZnRfbm9kZV9yaWdodCkpXG4gICAgZWxzZSBpZiBociA+IGhsICsgMlxuICAgIHRoZW4gKFxuICAgICAgKCogc2VlIGFib3ZlIGZvciBhbiBleHBsYW5hdGlvbiBvZiB3aHkgcmlnaHQgY2Fubm90IGJlIGEgbGVhZiAqKVxuICAgICAgbWF0Y2ggcmlnaHQgd2l0aFxuICAgICAgfCBFbXB0eSB8IExlYWYgXyAtPiBhc3NlcnQgZmFsc2VcbiAgICAgIHwgTm9kZVxuICAgICAgICAgICh7IGxlZnQgPSByaWdodF9ub2RlX2xlZnRcbiAgICAgICAgICAgOyBrZXkgPSBfXG4gICAgICAgICAgIDsgdmFsdWUgPSBfXG4gICAgICAgICAgIDsgaGVpZ2h0ID0gX1xuICAgICAgICAgICA7IHJpZ2h0ID0gcmlnaHRfbm9kZV9yaWdodFxuICAgICAgICAgICB9IGFzIHJpZ2h0X25vZGUpIC0+XG4gICAgICAgIGlmIGhlaWdodCByaWdodF9ub2RlX3JpZ2h0ID49IGhlaWdodCByaWdodF9ub2RlX2xlZnRcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgcm9vdF9ub2RlLnJpZ2h0IDwtIHJpZ2h0X25vZGVfbGVmdDtcbiAgICAgICAgICByaWdodF9ub2RlLmxlZnQgPC0gdHJlZTtcbiAgICAgICAgICB1cGRhdGVfaGVpZ2h0IHRyZWU7XG4gICAgICAgICAgdXBkYXRlX2hlaWdodCByaWdodDtcbiAgICAgICAgICByaWdodClcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgKCogc2VlIGFib3ZlIGZvciBhbiBleHBsYW5hdGlvbiBvZiB3aHkgdGhpcyBjYW5ub3QgYmUgYSBsZWFmICopXG4gICAgICAgICAgbWF0Y2ggcmlnaHRfbm9kZV9sZWZ0IHdpdGhcbiAgICAgICAgICB8IEVtcHR5IHwgTGVhZiBfIC0+IGFzc2VydCBmYWxzZVxuICAgICAgICAgIHwgTm9kZVxuICAgICAgICAgICAgICAoeyBsZWZ0ID0gcmxfbGVmdDsga2V5ID0gXzsgdmFsdWUgPSBfOyBoZWlnaHQgPSBfOyByaWdodCA9IHJsX3JpZ2h0IH0gYXNcbiAgICAgICAgICAgICAgIHJsX25vZGUpIC0+XG4gICAgICAgICAgICByaWdodF9ub2RlLmxlZnQgPC0gcmxfcmlnaHQ7XG4gICAgICAgICAgICByb290X25vZGUucmlnaHQgPC0gcmxfbGVmdDtcbiAgICAgICAgICAgIHJsX25vZGUubGVmdCA8LSB0cmVlO1xuICAgICAgICAgICAgcmxfbm9kZS5yaWdodCA8LSByaWdodDtcbiAgICAgICAgICAgIHVwZGF0ZV9oZWlnaHQgcmlnaHQ7XG4gICAgICAgICAgICB1cGRhdGVfaGVpZ2h0IHRyZWU7XG4gICAgICAgICAgICB1cGRhdGVfaGVpZ2h0IHJpZ2h0X25vZGVfbGVmdDtcbiAgICAgICAgICAgIHJpZ2h0X25vZGVfbGVmdCkpXG4gICAgZWxzZSAoXG4gICAgICB1cGRhdGVfaGVpZ2h0IHRyZWU7XG4gICAgICB0cmVlKVxuOztcblxuKCogQHByZTogdHJlZSBpcyBiYWxhbmNlYWJsZVxuICAgQHByZTogYWJzIChoZWlnaHQgKHJpZ2h0IG5vZGUpIC0gaGVpZ2h0IChiYWxhbmNlIHRyZWUpKSA8PSAzXG4gICBAcG9zdDogcmVzdWx0IGlzIGJhbGFuY2VhYmxlICopXG5cbigqIEBwcmU6IHRyZWUgaXMgYmFsYW5jZWFibGVcbiAgIEBwcmU6IGFicyAoaGVpZ2h0IChyaWdodCBub2RlKSAtIGhlaWdodCAoYmFsYW5jZSB0cmVlKSkgPD0gM1xuICAgQHBvc3Q6IHJlc3VsdCBpcyBiYWxhbmNlYWJsZSAqKVxubGV0IHNldF9sZWZ0IG5vZGUgdHJlZSA9XG4gIGxldCB0cmVlID0gYmFsYW5jZSB0cmVlIGluXG4gIG1hdGNoIG5vZGUgd2l0aFxuICB8IE5vZGUgKHsgbGVmdDsga2V5ID0gXzsgdmFsdWUgPSBfOyBoZWlnaHQgPSBfOyByaWdodCA9IF8gfSBhcyByKSAtPlxuICAgIGlmIHBoeXNfZXF1YWwgbGVmdCB0cmVlIHRoZW4gKCkgZWxzZSByLmxlZnQgPC0gdHJlZTtcbiAgICB1cGRhdGVfaGVpZ2h0IG5vZGVcbiAgfCBfIC0+IGFzc2VydCBmYWxzZVxuOztcblxuKCogQHByZTogdHJlZSBpcyBiYWxhbmNlYWJsZVxuICAgQHByZTogYWJzIChoZWlnaHQgKGxlZnQgbm9kZSkgLSBoZWlnaHQgKGJhbGFuY2UgdHJlZSkpIDw9IDNcbiAgIEBwb3N0OiByZXN1bHQgaXMgYmFsYW5jZWFibGUgKilcbmxldCBzZXRfcmlnaHQgbm9kZSB0cmVlID1cbiAgbGV0IHRyZWUgPSBiYWxhbmNlIHRyZWUgaW5cbiAgbWF0Y2ggbm9kZSB3aXRoXG4gIHwgTm9kZSAoeyBsZWZ0ID0gXzsga2V5ID0gXzsgdmFsdWUgPSBfOyBoZWlnaHQgPSBfOyByaWdodCB9IGFzIHIpIC0+XG4gICAgaWYgcGh5c19lcXVhbCByaWdodCB0cmVlIHRoZW4gKCkgZWxzZSByLnJpZ2h0IDwtIHRyZWU7XG4gICAgdXBkYXRlX2hlaWdodCBub2RlXG4gIHwgXyAtPiBhc3NlcnQgZmFsc2Vcbjs7XG5cbigqIEBwcmU6IHQgaXMgYmFsYW5jZWQuXG4gICBAcG9zdDogcmVzdWx0IGlzIGJhbGFuY2VkLCB3aXRoIG5ldyBub2RlIGluc2VydGVkXG4gICBAcG9zdDogIWFkZGVkID0gdHJ1ZSBpZmYgdGhlIHNoYXBlIG9mIHRoZSBpbnB1dCB0cmVlIGNoYW5nZWQuICAqKVxubGV0IGFkZCA9XG4gIGxldCByZWMgYWRkIHQgcmVwbGFjZSBhZGRlZCBjb21wYXJlIGsgdiA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPlxuICAgICAgYWRkZWQgOj0gdHJ1ZTtcbiAgICAgIExlYWYgeyBrZXkgPSBrOyB2YWx1ZSA9IHYgfVxuICAgIHwgTGVhZiAoeyBrZXkgPSBrJzsgdmFsdWUgPSBfIH0gYXMgcikgLT5cbiAgICAgIGxldCBjID0gY29tcGFyZSBrJyBrIGluXG4gICAgICAoKiBUaGlzIGNvbXBhcmUgaXMgcmV2ZXJzZWQgb24gcHVycG9zZSwgd2UgYXJlIHByZXRlbmRpbmdcbiAgICAgICAgIHRoYXQgdGhlIGxlYWYgd2FzIGp1c3QgaW5zZXJ0ZWQgaW5zdGVhZCBvZiB0aGUgb3RoZXIgd2F5XG4gICAgICAgICByb3VuZCwgdGhhdCB3YXkgd2Ugb25seSBhbGxvY2F0ZSBvbmUgbm9kZS4gKilcbiAgICAgIGlmIGMgPSAwXG4gICAgICB0aGVuIChcbiAgICAgICAgYWRkZWQgOj0gZmFsc2U7XG4gICAgICAgIGlmIHJlcGxhY2UgdGhlbiByLnZhbHVlIDwtIHY7XG4gICAgICAgIHQpXG4gICAgICBlbHNlIChcbiAgICAgICAgYWRkZWQgOj0gdHJ1ZTtcbiAgICAgICAgaWYgYyA8IDBcbiAgICAgICAgdGhlbiBOb2RlIHsgbGVmdCA9IHQ7IGtleSA9IGs7IHZhbHVlID0gdjsgaGVpZ2h0ID0gMjsgcmlnaHQgPSBFbXB0eSB9XG4gICAgICAgIGVsc2UgTm9kZSB7IGxlZnQgPSBFbXB0eTsga2V5ID0gazsgdmFsdWUgPSB2OyBoZWlnaHQgPSAyOyByaWdodCA9IHQgfSlcbiAgICB8IE5vZGUgKHsgbGVmdDsga2V5ID0gayc7IHZhbHVlID0gXzsgaGVpZ2h0ID0gXzsgcmlnaHQgfSBhcyByKSAtPlxuICAgICAgbGV0IGMgPSBjb21wYXJlIGsgaycgaW5cbiAgICAgIGlmIGMgPSAwXG4gICAgICB0aGVuIChcbiAgICAgICAgYWRkZWQgOj0gZmFsc2U7XG4gICAgICAgIGlmIHJlcGxhY2UgdGhlbiByLnZhbHVlIDwtIHYpXG4gICAgICBlbHNlIGlmIGMgPCAwXG4gICAgICB0aGVuIHNldF9sZWZ0IHQgKGFkZCBsZWZ0IHJlcGxhY2UgYWRkZWQgY29tcGFyZSBrIHYpXG4gICAgICBlbHNlIHNldF9yaWdodCB0IChhZGQgcmlnaHQgcmVwbGFjZSBhZGRlZCBjb21wYXJlIGsgdik7XG4gICAgICB0XG4gIGluXG4gIGZ1biB0IH5yZXBsYWNlIH5jb21wYXJlIH5hZGRlZCB+a2V5IH5kYXRhIC0+XG4gICAgbGV0IHQgPSBhZGQgdCByZXBsYWNlIGFkZGVkIGNvbXBhcmUga2V5IGRhdGEgaW5cbiAgICBpZiAhYWRkZWQgdGhlbiBiYWxhbmNlIHQgZWxzZSB0XG47O1xuXG5sZXQgcmVjIGZpcnN0IHQgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBFbXB0eSAtPiBOb25lXG4gIHwgTGVhZiB7IGtleSA9IGs7IHZhbHVlID0gdiB9XG4gIHwgTm9kZSB7IGxlZnQgPSBFbXB0eTsga2V5ID0gazsgdmFsdWUgPSB2OyBoZWlnaHQgPSBfOyByaWdodCA9IF8gfSAtPiBTb21lIChrLCB2KVxuICB8IE5vZGUgeyBsZWZ0ID0gbDsga2V5ID0gXzsgdmFsdWUgPSBfOyBoZWlnaHQgPSBfOyByaWdodCA9IF8gfSAtPiBmaXJzdCBsXG47O1xuXG5sZXQgcmVjIGxhc3QgdCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IEVtcHR5IC0+IE5vbmVcbiAgfCBMZWFmIHsga2V5ID0gazsgdmFsdWUgPSB2IH1cbiAgfCBOb2RlIHsgbGVmdCA9IF87IGtleSA9IGs7IHZhbHVlID0gdjsgaGVpZ2h0ID0gXzsgcmlnaHQgPSBFbXB0eSB9IC0+IFNvbWUgKGssIHYpXG4gIHwgTm9kZSB7IGxlZnQgPSBfOyBrZXkgPSBfOyB2YWx1ZSA9IF87IGhlaWdodCA9IF87IHJpZ2h0ID0gciB9IC0+IGxhc3QgclxuOztcblxuXG5sZXRbQGlubGluZSBhbHdheXNdIHJlYyBmaW5kaV9hbmRfY2FsbF9pbXBsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfmNvbXBhcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAga1xuICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcxXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFyZzJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfmNhbGxfaWZfZm91bmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfmNhbGxfaWZfbm90X2ZvdW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH5pZl9mb3VuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICB+aWZfbm90X2ZvdW5kXG4gID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgRW1wdHkgLT4gY2FsbF9pZl9ub3RfZm91bmQgfmlmX25vdF9mb3VuZCBrIGFyZzEgYXJnMlxuICB8IExlYWYgeyBrZXkgPSBrJzsgdmFsdWUgPSB2IH0gLT5cbiAgICBpZiBjb21wYXJlIGsgaycgPSAwXG4gICAgdGhlbiBjYWxsX2lmX2ZvdW5kIH5pZl9mb3VuZCB+a2V5OmsnIH5kYXRhOnYgYXJnMSBhcmcyXG4gICAgZWxzZSBjYWxsX2lmX25vdF9mb3VuZCB+aWZfbm90X2ZvdW5kIGsgYXJnMSBhcmcyXG4gIHwgTm9kZSB7IGxlZnQ7IGtleSA9IGsnOyB2YWx1ZSA9IHY7IGhlaWdodCA9IF87IHJpZ2h0IH0gLT5cbiAgICBsZXQgYyA9IGNvbXBhcmUgayBrJyBpblxuICAgIGlmIGMgPSAwXG4gICAgdGhlbiBjYWxsX2lmX2ZvdW5kIH5pZl9mb3VuZCB+a2V5OmsnIH5kYXRhOnYgYXJnMSBhcmcyXG4gICAgZWxzZVxuICAgICAgZmluZGlfYW5kX2NhbGxfaW1wbFxuICAgICAgICAoaWYgYyA8IDAgdGhlbiBsZWZ0IGVsc2UgcmlnaHQpXG4gICAgICAgIH5jb21wYXJlXG4gICAgICAgIGtcbiAgICAgICAgYXJnMVxuICAgICAgICBhcmcyXG4gICAgICAgIH5jYWxsX2lmX2ZvdW5kXG4gICAgICAgIH5jYWxsX2lmX25vdF9mb3VuZFxuICAgICAgICB+aWZfZm91bmRcbiAgICAgICAgfmlmX25vdF9mb3VuZFxuOztcblxubGV0IGZpbmRfYW5kX2NhbGwgPVxuICBsZXQgY2FsbF9pZl9mb3VuZCB+aWZfZm91bmQgfmtleTpfIH5kYXRhICgpICgpID0gaWZfZm91bmQgZGF0YSBpblxuICBsZXQgY2FsbF9pZl9ub3RfZm91bmQgfmlmX25vdF9mb3VuZCBrZXkgKCkgKCkgPSBpZl9ub3RfZm91bmQga2V5IGluXG4gIGZ1biB0IH5jb21wYXJlIGsgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmQgLT5cbiAgICBmaW5kaV9hbmRfY2FsbF9pbXBsXG4gICAgICB0XG4gICAgICB+Y29tcGFyZVxuICAgICAga1xuICAgICAgKClcbiAgICAgICgpXG4gICAgICB+Y2FsbF9pZl9mb3VuZFxuICAgICAgfmNhbGxfaWZfbm90X2ZvdW5kXG4gICAgICB+aWZfZm91bmRcbiAgICAgIH5pZl9ub3RfZm91bmRcbjs7XG5cbmxldCBmaW5kaV9hbmRfY2FsbCA9XG4gIGxldCBjYWxsX2lmX2ZvdW5kIH5pZl9mb3VuZCB+a2V5IH5kYXRhICgpICgpID0gaWZfZm91bmQgfmtleSB+ZGF0YSBpblxuICBsZXQgY2FsbF9pZl9ub3RfZm91bmQgfmlmX25vdF9mb3VuZCBrZXkgKCkgKCkgPSBpZl9ub3RfZm91bmQga2V5IGluXG4gIGZ1biB0IH5jb21wYXJlIGsgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmQgLT5cbiAgICBmaW5kaV9hbmRfY2FsbF9pbXBsXG4gICAgICB0XG4gICAgICB+Y29tcGFyZVxuICAgICAga1xuICAgICAgKClcbiAgICAgICgpXG4gICAgICB+Y2FsbF9pZl9mb3VuZFxuICAgICAgfmNhbGxfaWZfbm90X2ZvdW5kXG4gICAgICB+aWZfZm91bmRcbiAgICAgIH5pZl9ub3RfZm91bmRcbjs7XG5cbmxldCBmaW5kX2FuZF9jYWxsMSA9XG4gIGxldCBjYWxsX2lmX2ZvdW5kIH5pZl9mb3VuZCB+a2V5Ol8gfmRhdGEgYXJnICgpID0gaWZfZm91bmQgZGF0YSBhcmcgaW5cbiAgbGV0IGNhbGxfaWZfbm90X2ZvdW5kIH5pZl9ub3RfZm91bmQga2V5IGFyZyAoKSA9IGlmX25vdF9mb3VuZCBrZXkgYXJnIGluXG4gIGZ1biB0IH5jb21wYXJlIGsgfmEgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmQgLT5cbiAgICBmaW5kaV9hbmRfY2FsbF9pbXBsXG4gICAgICB0XG4gICAgICB+Y29tcGFyZVxuICAgICAga1xuICAgICAgYVxuICAgICAgKClcbiAgICAgIH5jYWxsX2lmX2ZvdW5kXG4gICAgICB+Y2FsbF9pZl9ub3RfZm91bmRcbiAgICAgIH5pZl9mb3VuZFxuICAgICAgfmlmX25vdF9mb3VuZFxuOztcblxubGV0IGZpbmRpX2FuZF9jYWxsMSA9XG4gIGxldCBjYWxsX2lmX2ZvdW5kIH5pZl9mb3VuZCB+a2V5IH5kYXRhIGFyZyAoKSA9IGlmX2ZvdW5kIH5rZXkgfmRhdGEgYXJnIGluXG4gIGxldCBjYWxsX2lmX25vdF9mb3VuZCB+aWZfbm90X2ZvdW5kIGtleSBhcmcgKCkgPSBpZl9ub3RfZm91bmQga2V5IGFyZyBpblxuICBmdW4gdCB+Y29tcGFyZSBrIH5hIH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kIC0+XG4gICAgZmluZGlfYW5kX2NhbGxfaW1wbFxuICAgICAgdFxuICAgICAgfmNvbXBhcmVcbiAgICAgIGtcbiAgICAgIGFcbiAgICAgICgpXG4gICAgICB+Y2FsbF9pZl9mb3VuZFxuICAgICAgfmNhbGxfaWZfbm90X2ZvdW5kXG4gICAgICB+aWZfZm91bmRcbiAgICAgIH5pZl9ub3RfZm91bmRcbjs7XG5cbmxldCBmaW5kX2FuZF9jYWxsMiA9XG4gIGxldCBjYWxsX2lmX2ZvdW5kIH5pZl9mb3VuZCB+a2V5Ol8gfmRhdGEgYXJnMSBhcmcyID0gaWZfZm91bmQgZGF0YSBhcmcxIGFyZzIgaW5cbiAgbGV0IGNhbGxfaWZfbm90X2ZvdW5kIH5pZl9ub3RfZm91bmQga2V5IGFyZzEgYXJnMiA9IGlmX25vdF9mb3VuZCBrZXkgYXJnMSBhcmcyIGluXG4gIGZ1biB0IH5jb21wYXJlIGsgfmEgfmIgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmQgLT5cbiAgICBmaW5kaV9hbmRfY2FsbF9pbXBsXG4gICAgICB0XG4gICAgICB+Y29tcGFyZVxuICAgICAga1xuICAgICAgYVxuICAgICAgYlxuICAgICAgfmNhbGxfaWZfZm91bmRcbiAgICAgIH5jYWxsX2lmX25vdF9mb3VuZFxuICAgICAgfmlmX2ZvdW5kXG4gICAgICB+aWZfbm90X2ZvdW5kXG47O1xuXG5sZXQgZmluZGlfYW5kX2NhbGwyID1cbiAgbGV0IGNhbGxfaWZfZm91bmQgfmlmX2ZvdW5kIH5rZXkgfmRhdGEgYXJnMSBhcmcyID0gaWZfZm91bmQgfmtleSB+ZGF0YSBhcmcxIGFyZzIgaW5cbiAgbGV0IGNhbGxfaWZfbm90X2ZvdW5kIH5pZl9ub3RfZm91bmQga2V5IGFyZzEgYXJnMiA9IGlmX25vdF9mb3VuZCBrZXkgYXJnMSBhcmcyIGluXG4gIGZ1biB0IH5jb21wYXJlIGsgfmEgfmIgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmQgLT5cbiAgICBmaW5kaV9hbmRfY2FsbF9pbXBsXG4gICAgICB0XG4gICAgICB+Y29tcGFyZVxuICAgICAga1xuICAgICAgYVxuICAgICAgYlxuICAgICAgfmNhbGxfaWZfZm91bmRcbiAgICAgIH5jYWxsX2lmX25vdF9mb3VuZFxuICAgICAgfmlmX2ZvdW5kXG4gICAgICB+aWZfbm90X2ZvdW5kXG47O1xuXG5sZXQgZmluZCA9XG4gIGxldCBpZl9mb3VuZCB2ID0gU29tZSB2IGluXG4gIGxldCBpZl9ub3RfZm91bmQgXyA9IE5vbmUgaW5cbiAgZnVuIHQgfmNvbXBhcmUgayAtPiBmaW5kX2FuZF9jYWxsIHQgfmNvbXBhcmUgayB+aWZfZm91bmQgfmlmX25vdF9mb3VuZFxuOztcblxubGV0IG1lbSA9XG4gIGxldCBpZl9mb3VuZCBfID0gdHJ1ZSBpblxuICBsZXQgaWZfbm90X2ZvdW5kIF8gPSBmYWxzZSBpblxuICBmdW4gdCB+Y29tcGFyZSBrIC0+IGZpbmRfYW5kX2NhbGwgdCB+Y29tcGFyZSBrIH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kXG47O1xuXG5sZXQgcmVtb3ZlID1cbiAgbGV0IHJlYyBtaW5fZWx0IHRyZWUgPVxuICAgIG1hdGNoIHRyZWUgd2l0aFxuICAgIHwgRW1wdHkgLT4gRW1wdHlcbiAgICB8IExlYWYgXyAtPiB0cmVlXG4gICAgfCBOb2RlIHsgbGVmdCA9IEVtcHR5OyBrZXkgPSBfOyB2YWx1ZSA9IF87IGhlaWdodCA9IF87IHJpZ2h0ID0gXyB9IC0+IHRyZWVcbiAgICB8IE5vZGUgeyBsZWZ0OyBrZXkgPSBfOyB2YWx1ZSA9IF87IGhlaWdodCA9IF87IHJpZ2h0ID0gXyB9IC0+IG1pbl9lbHQgbGVmdFxuICBpblxuICBsZXQgcmVjIHJlbW92ZV9taW5fZWx0IHRyZWUgPVxuICAgIG1hdGNoIHRyZWUgd2l0aFxuICAgIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gICAgfCBMZWFmIF8gLT4gRW1wdHkgKCogVGhpcyBtdXN0IGJlIHRoZSByb290ICopXG4gICAgfCBOb2RlIHsgbGVmdCA9IEVtcHR5OyBrZXkgPSBfOyB2YWx1ZSA9IF87IGhlaWdodCA9IF87IHJpZ2h0IH0gLT4gcmlnaHRcbiAgICB8IE5vZGUgeyBsZWZ0ID0gTGVhZiBfOyBrZXkgPSBrOyB2YWx1ZSA9IHY7IGhlaWdodCA9IF87IHJpZ2h0ID0gRW1wdHkgfSAtPlxuICAgICAgTGVhZiB7IGtleSA9IGs7IHZhbHVlID0gdiB9XG4gICAgfCBOb2RlIHsgbGVmdCA9IExlYWYgXzsga2V5ID0gXzsgdmFsdWUgPSBfOyBoZWlnaHQgPSBfOyByaWdodCA9IF8gfSBhcyBub2RlIC0+XG4gICAgICBzZXRfbGVmdCBub2RlIEVtcHR5O1xuICAgICAgdHJlZVxuICAgIHwgTm9kZSB7IGxlZnQ7IGtleSA9IF87IHZhbHVlID0gXzsgaGVpZ2h0ID0gXzsgcmlnaHQgPSBfIH0gYXMgbm9kZSAtPlxuICAgICAgc2V0X2xlZnQgbm9kZSAocmVtb3ZlX21pbl9lbHQgbGVmdCk7XG4gICAgICB0cmVlXG4gIGluXG4gIGxldCBtZXJnZSB0MSB0MiA9XG4gICAgbWF0Y2ggdDEsIHQyIHdpdGhcbiAgICB8IEVtcHR5LCB0IC0+IHRcbiAgICB8IHQsIEVtcHR5IC0+IHRcbiAgICB8IF8sIF8gLT5cbiAgICAgIGxldCB0cmVlID0gbWluX2VsdCB0MiBpblxuICAgICAgKG1hdGNoIHRyZWUgd2l0aFxuICAgICAgIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgfCBMZWFmIHsga2V5ID0gazsgdmFsdWUgPSB2IH0gLT5cbiAgICAgICAgIGxldCB0MiA9IGJhbGFuY2UgKHJlbW92ZV9taW5fZWx0IHQyKSBpblxuICAgICAgICAgTm9kZVxuICAgICAgICAgICB7IGxlZnQgPSB0MVxuICAgICAgICAgICA7IGtleSA9IGtcbiAgICAgICAgICAgOyB2YWx1ZSA9IHZcbiAgICAgICAgICAgOyBoZWlnaHQgPSBJbnQubWF4IChoZWlnaHQgdDEpIChoZWlnaHQgdDIpICsgMVxuICAgICAgICAgICA7IHJpZ2h0ID0gdDJcbiAgICAgICAgICAgfVxuICAgICAgIHwgTm9kZSBfIGFzIG5vZGUgLT5cbiAgICAgICAgIHNldF9yaWdodCBub2RlIChyZW1vdmVfbWluX2VsdCB0Mik7XG4gICAgICAgICBzZXRfbGVmdCBub2RlIHQxO1xuICAgICAgICAgbm9kZSlcbiAgaW5cbiAgbGV0IHJlYyByZW1vdmUgdCByZW1vdmVkIGNvbXBhcmUgayA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPlxuICAgICAgcmVtb3ZlZCA6PSBmYWxzZTtcbiAgICAgIEVtcHR5XG4gICAgfCBMZWFmIHsga2V5ID0gayc7IHZhbHVlID0gXyB9IC0+XG4gICAgICBpZiBjb21wYXJlIGsgaycgPSAwXG4gICAgICB0aGVuIChcbiAgICAgICAgcmVtb3ZlZCA6PSB0cnVlO1xuICAgICAgICBFbXB0eSlcbiAgICAgIGVsc2UgKFxuICAgICAgICByZW1vdmVkIDo9IGZhbHNlO1xuICAgICAgICB0KVxuICAgIHwgTm9kZSB7IGxlZnQ7IGtleSA9IGsnOyB2YWx1ZSA9IF87IGhlaWdodCA9IF87IHJpZ2h0IH0gLT5cbiAgICAgIGxldCBjID0gY29tcGFyZSBrIGsnIGluXG4gICAgICBpZiBjID0gMFxuICAgICAgdGhlbiAoXG4gICAgICAgIHJlbW92ZWQgOj0gdHJ1ZTtcbiAgICAgICAgbWVyZ2UgbGVmdCByaWdodClcbiAgICAgIGVsc2UgaWYgYyA8IDBcbiAgICAgIHRoZW4gKFxuICAgICAgICBzZXRfbGVmdCB0IChyZW1vdmUgbGVmdCByZW1vdmVkIGNvbXBhcmUgayk7XG4gICAgICAgIHQpXG4gICAgICBlbHNlIChcbiAgICAgICAgc2V0X3JpZ2h0IHQgKHJlbW92ZSByaWdodCByZW1vdmVkIGNvbXBhcmUgayk7XG4gICAgICAgIHQpXG4gIGluXG4gIGZ1biB0IH5yZW1vdmVkIH5jb21wYXJlIGsgLT4gYmFsYW5jZSAocmVtb3ZlIHQgcmVtb3ZlZCBjb21wYXJlIGspXG47O1xuXG5sZXQgcmVjIGZvbGQgdCB+aW5pdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IEVtcHR5IC0+IGluaXRcbiAgfCBMZWFmIHsga2V5OyB2YWx1ZSA9IGRhdGEgfSAtPiBmIH5rZXkgfmRhdGEgaW5pdFxuICB8IE5vZGVcbiAgICAgIHsgbGVmdCA9IExlYWYgeyBrZXkgPSBsa2V5OyB2YWx1ZSA9IGxkYXRhIH1cbiAgICAgIDsga2V5XG4gICAgICA7IHZhbHVlID0gZGF0YVxuICAgICAgOyBoZWlnaHQgPSBfXG4gICAgICA7IHJpZ2h0ID0gTGVhZiB7IGtleSA9IHJrZXk7IHZhbHVlID0gcmRhdGEgfVxuICAgICAgfSAtPiBmIH5rZXk6cmtleSB+ZGF0YTpyZGF0YSAoZiB+a2V5IH5kYXRhIChmIH5rZXk6bGtleSB+ZGF0YTpsZGF0YSBpbml0KSlcbiAgfCBOb2RlXG4gICAgICB7IGxlZnQgPSBMZWFmIHsga2V5ID0gbGtleTsgdmFsdWUgPSBsZGF0YSB9XG4gICAgICA7IGtleVxuICAgICAgOyB2YWx1ZSA9IGRhdGFcbiAgICAgIDsgaGVpZ2h0ID0gX1xuICAgICAgOyByaWdodCA9IEVtcHR5XG4gICAgICB9IC0+IGYgfmtleSB+ZGF0YSAoZiB+a2V5OmxrZXkgfmRhdGE6bGRhdGEgaW5pdClcbiAgfCBOb2RlXG4gICAgICB7IGxlZnQgPSBFbXB0eVxuICAgICAgOyBrZXlcbiAgICAgIDsgdmFsdWUgPSBkYXRhXG4gICAgICA7IGhlaWdodCA9IF9cbiAgICAgIDsgcmlnaHQgPSBMZWFmIHsga2V5ID0gcmtleTsgdmFsdWUgPSByZGF0YSB9XG4gICAgICB9IC0+IGYgfmtleTpya2V5IH5kYXRhOnJkYXRhIChmIH5rZXkgfmRhdGEgaW5pdClcbiAgfCBOb2RlXG4gICAgICB7IGxlZnQ7IGtleTsgdmFsdWUgPSBkYXRhOyBoZWlnaHQgPSBfOyByaWdodCA9IExlYWYgeyBrZXkgPSBya2V5OyB2YWx1ZSA9IHJkYXRhIH0gfVxuICAgIC0+IGYgfmtleTpya2V5IH5kYXRhOnJkYXRhIChmIH5rZXkgfmRhdGEgKGZvbGQgbGVmdCB+aW5pdCB+ZikpXG4gIHwgTm9kZVxuICAgICAgeyBsZWZ0ID0gTGVhZiB7IGtleSA9IGxrZXk7IHZhbHVlID0gbGRhdGEgfTsga2V5OyB2YWx1ZSA9IGRhdGE7IGhlaWdodCA9IF87IHJpZ2h0IH1cbiAgICAtPiBmb2xkIHJpZ2h0IH5pbml0OihmIH5rZXkgfmRhdGEgKGYgfmtleTpsa2V5IH5kYXRhOmxkYXRhIGluaXQpKSB+ZlxuICB8IE5vZGUgeyBsZWZ0OyBrZXk7IHZhbHVlID0gZGF0YTsgaGVpZ2h0ID0gXzsgcmlnaHQgfSAtPlxuICAgIGZvbGQgcmlnaHQgfmluaXQ6KGYgfmtleSB+ZGF0YSAoZm9sZCBsZWZ0IH5pbml0IH5mKSkgfmZcbjs7XG5cbmxldCByZWMgaXRlciB0IH5mID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgRW1wdHkgLT4gKClcbiAgfCBMZWFmIHsga2V5OyB2YWx1ZSA9IGRhdGEgfSAtPiBmIH5rZXkgfmRhdGFcbiAgfCBOb2RlIHsgbGVmdDsga2V5OyB2YWx1ZSA9IGRhdGE7IGhlaWdodCA9IF87IHJpZ2h0IH0gLT5cbiAgICBpdGVyIGxlZnQgfmY7XG4gICAgZiB+a2V5IH5kYXRhO1xuICAgIGl0ZXIgcmlnaHQgfmZcbjs7XG5cbmxldCByZWMgbWFwaV9pbnBsYWNlIHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBFbXB0eSAtPiAoKVxuICB8IExlYWYgKHsga2V5OyB2YWx1ZSB9IGFzIHQpIC0+IHQudmFsdWUgPC0gZiB+a2V5IH5kYXRhOnZhbHVlXG4gIHwgTm9kZSAoeyBsZWZ0OyBrZXk7IHZhbHVlOyBoZWlnaHQgPSBfOyByaWdodCB9IGFzIHQpIC0+XG4gICAgbWFwaV9pbnBsYWNlIH5mIGxlZnQ7XG4gICAgdC52YWx1ZSA8LSBmIH5rZXkgfmRhdGE6dmFsdWU7XG4gICAgbWFwaV9pbnBsYWNlIH5mIHJpZ2h0XG47O1xuXG5sZXQgY2hvb3NlX2V4biA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT4gcmFpc2VfcyAoU2V4cC5tZXNzYWdlIFwiW0F2bHRyZWUuY2hvb3NlX2V4bl0gb2YgZW1wdHkgaGFzaHRibFwiIFtdKVxuICB8IExlYWYgeyBrZXk7IHZhbHVlOyBfIH0gfCBOb2RlIHsga2V5OyB2YWx1ZTsgXyB9IC0+IGtleSwgdmFsdWVcbjs7XG4iLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgQnVmZmVyX2ludGZcbmluY2x1ZGUgQ2FtbC5CdWZmZXJcblxubGV0IGNvbnRlbnRzX2J5dGVzID0gdG9fYnl0ZXNcbmxldCBhZGRfc3Vic3RyaW5nIHQgcyB+cG9zIH5sZW4gPSBhZGRfc3Vic3RyaW5nIHQgcyBwb3MgbGVuXG5sZXQgYWRkX3N1YmJ5dGVzIHQgcyB+cG9zIH5sZW4gPSBhZGRfc3ViYnl0ZXMgdCBzIHBvcyBsZW5cbmxldCBzZXhwX29mX3QgdCA9IHNleHBfb2Zfc3RyaW5nIChjb250ZW50cyB0KVxuXG5tb2R1bGUgVG9fYnl0ZXMgPVxuICBCbGl0Lk1ha2VfZGlzdGluY3RcbiAgICAoc3RydWN0XG4gICAgICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gICAgICBsZXQgbGVuZ3RoID0gbGVuZ3RoXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgdCA9IEJ5dGVzLnRcblxuICAgICAgbGV0IGNyZWF0ZSB+bGVuID0gQnl0ZXMuY3JlYXRlIGxlblxuICAgICAgbGV0IGxlbmd0aCA9IEJ5dGVzLmxlbmd0aFxuXG4gICAgICBsZXQgdW5zYWZlX2JsaXQgfnNyYyB+c3JjX3BvcyB+ZHN0IH5kc3RfcG9zIH5sZW4gPVxuICAgICAgICBDYW1sLkJ1ZmZlci5ibGl0IHNyYyBzcmNfcG9zIGRzdCBkc3RfcG9zIGxlblxuICAgICAgOztcbiAgICBlbmQpXG5cbmluY2x1ZGUgVG9fYnl0ZXNcbm1vZHVsZSBUb19zdHJpbmcgPSBCbGl0Lk1ha2VfdG9fc3RyaW5nIChDYW1sLkJ1ZmZlcikgKFRvX2J5dGVzKVxuIl19
