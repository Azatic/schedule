// Generated by js_of_ocaml
//# buildInfo:effects=false, use-js-string=false, version=5.0.1
(function
   (globalThis)
   {"use strict";
    var
     runtime=globalThis.jsoo_runtime,
     caml_bytes_unsafe_set=runtime.caml_bytes_unsafe_set,
     caml_check_bound=runtime.caml_check_bound,
     caml_create_bytes=runtime.caml_create_bytes,
     caml_float_of_string=runtime.caml_float_of_string,
     caml_format_float=runtime.caml_format_float,
     caml_fresh_oo_id=runtime.caml_fresh_oo_id,
     caml_int_of_string=runtime.caml_int_of_string,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_register_global=runtime.caml_register_global,
     caml_string_get=runtime.caml_string_get,
     caml_string_notequal=runtime.caml_string_notequal,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     caml_string_unsafe_get=runtime.caml_string_unsafe_get,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    var
     global_data=runtime.caml_get_global_data(),
     cst$11=caml_string_of_jsbytes(""),
     cst$2=caml_string_of_jsbytes("("),
     cst$3=caml_string_of_jsbytes("()"),
     cst$4=caml_string_of_jsbytes(")"),
     cst$5=caml_string_of_jsbytes(" "),
     cst$6=caml_string_of_jsbytes("("),
     cst$7=caml_string_of_jsbytes("()"),
     cst$8=caml_string_of_jsbytes(")"),
     cst$10=caml_string_of_jsbytes("()"),
     cst$9=caml_string_of_jsbytes("()"),
     cst=caml_string_of_jsbytes("\\"),
     cst_n=caml_string_of_jsbytes("\\n"),
     cst$0=caml_string_of_jsbytes(' "'),
     cst$1=caml_string_of_jsbytes('"'),
     cst_Sexplib0_Sexp_Not_found_s=
      caml_string_of_jsbytes("Sexplib0__Sexp.Not_found_s"),
     cst_Sexplib0_Sexp_Of_sexp_erro=
      caml_string_of_jsbytes("Sexplib0__Sexp.Of_sexp_error"),
     doc_comment_tag=caml_string_of_jsbytes("sexp_grammar.doc_comment"),
     unit_sexp_grammar=[2,0],
     sexp_t_sexp_grammar=[0,caml_string_of_jsbytes("Sexp.t")],
     fun_sexp_grammar=[4,0],
     cst_Assert_failure=caml_string_of_jsbytes("Assert_failure"),
     cst_Match_failure=caml_string_of_jsbytes("Match_failure"),
     cst_fun_of_sexp_cannot_convert=
      caml_string_of_jsbytes("fun_of_sexp: cannot convert function values"),
     cst_opaque_of_sexp_cannot_conv=
      caml_string_of_jsbytes("opaque_of_sexp: cannot convert opaque values"),
     cst_hashtbl_of_sexp_tuple_list=
      caml_string_of_jsbytes("hashtbl_of_sexp: tuple list needed"),
     cst_hashtbl_of_sexp_list_neede=
      caml_string_of_jsbytes("hashtbl_of_sexp: list needed"),
     cst_array_of_sexp_list_needed=
      caml_string_of_jsbytes("array_of_sexp: list needed"),
     cst_list_of_sexp_list_needed=
      caml_string_of_jsbytes("list_of_sexp: list needed"),
     cst_triple_of_sexp_list_needed=
      caml_string_of_jsbytes("triple_of_sexp: list needed"),
     cst_triple_of_sexp_list_must_c=
      caml_string_of_jsbytes
       ("triple_of_sexp: list must contain exactly three elements only"),
     cst_pair_of_sexp_list_needed=
      caml_string_of_jsbytes("pair_of_sexp: list needed"),
     cst_pair_of_sexp_list_must_con=
      caml_string_of_jsbytes
       ("pair_of_sexp: list must contain exactly two elements only"),
     cst_None=caml_string_of_jsbytes("None"),
     cst_none=caml_string_of_jsbytes("none"),
     cst_option_of_sexp_only_none_c=
      caml_string_of_jsbytes("option_of_sexp: only none can be atom"),
     cst_Some=caml_string_of_jsbytes("Some"),
     cst_some=caml_string_of_jsbytes("some"),
     cst_option_of_sexp_list_must_r=
      caml_string_of_jsbytes
       ("option_of_sexp: list must represent optional value"),
     cst_None$0=caml_string_of_jsbytes("None"),
     cst_none$0=caml_string_of_jsbytes("none"),
     cst_option_of_sexp_only_none_c$0=
      caml_string_of_jsbytes("option_of_sexp: only none can be atom"),
     cst_Some$0=caml_string_of_jsbytes("Some"),
     cst_some$0=caml_string_of_jsbytes("some"),
     cst_option_of_sexp_list_must_b=
      caml_string_of_jsbytes("option_of_sexp: list must be (some el)"),
     cst_nativeint_of_sexp=caml_string_of_jsbytes("nativeint_of_sexp: "),
     cst_nativeint_of_sexp_atom_nee=
      caml_string_of_jsbytes("nativeint_of_sexp: atom needed"),
     cst_int64_of_sexp=caml_string_of_jsbytes("int64_of_sexp: "),
     cst_int64_of_sexp_atom_needed=
      caml_string_of_jsbytes("int64_of_sexp: atom needed"),
     cst_int32_of_sexp=caml_string_of_jsbytes("int32_of_sexp: "),
     cst_int32_of_sexp_atom_needed=
      caml_string_of_jsbytes("int32_of_sexp: atom needed"),
     cst_float_of_sexp=caml_string_of_jsbytes("float_of_sexp: "),
     cst_float_of_sexp_atom_needed=
      caml_string_of_jsbytes("float_of_sexp: atom needed"),
     cst_int_of_sexp=caml_string_of_jsbytes("int_of_sexp: "),
     cst_int_of_sexp_atom_needed=
      caml_string_of_jsbytes("int_of_sexp: atom needed"),
     cst_char_of_sexp_atom_string_m=
      caml_string_of_jsbytes
       ("char_of_sexp: atom string must contain one character only"),
     cst_char_of_sexp_atom_needed=
      caml_string_of_jsbytes("char_of_sexp: atom needed"),
     cst_bytes_of_sexp_atom_needed=
      caml_string_of_jsbytes("bytes_of_sexp: atom needed"),
     cst_string_of_sexp_atom_needed=
      caml_string_of_jsbytes("string_of_sexp: atom needed"),
     cst_False=caml_string_of_jsbytes("False"),
     cst_True=caml_string_of_jsbytes("True"),
     cst_false=caml_string_of_jsbytes("false"),
     cst_true=caml_string_of_jsbytes("true"),
     cst_bool_of_sexp_unknown_strin=
      caml_string_of_jsbytes("bool_of_sexp: unknown string"),
     cst_bool_of_sexp_atom_needed=
      caml_string_of_jsbytes("bool_of_sexp: atom needed"),
     cst_unit_of_sexp_empty_list_ne=
      caml_string_of_jsbytes("unit_of_sexp: empty list needed"),
     cst_15G=caml_string_of_jsbytes("%.15G"),
     cst_17G=caml_string_of_jsbytes("%.17G"),
     cst$13=caml_string_of_jsbytes(" "),
     cst_of_sexp_trying_to_convert_=
      caml_string_of_jsbytes("_of_sexp: trying to convert an empty type"),
     cst_of_sexp_the_empty_list_is_=
      caml_string_of_jsbytes
       ("_of_sexp: the empty list is an invalid polymorphic variant"),
     cst_of_sexp_a_nested_list_is_a=
      caml_string_of_jsbytes
       ("_of_sexp: a nested list is an invalid polymorphic variant"),
     cst_of_sexp_polymorphic_varian$0=
      caml_string_of_jsbytes
       ("_of_sexp: polymorphic variant tag takes an argument"),
     cst_of_sexp_polymorphic_varian=
      caml_string_of_jsbytes
       ("_of_sexp: polymorphic variant does not take arguments"),
     cst_of_sexp_no_matching_varian=
      caml_string_of_jsbytes("_of_sexp: no matching variant found"),
     cst_of_sexp_cannot_convert_val=
      caml_string_of_jsbytes
       ("_of_sexp: cannot convert values of types resulting from polymorphic record fields"),
     cst_of_sexp_list_instead_of_at=
      caml_string_of_jsbytes
       ("_of_sexp: list instead of atom for record expected"),
     cst_extra_fields=caml_string_of_jsbytes("extra fields"),
     cst_duplicate_fields=caml_string_of_jsbytes("duplicate fields"),
     cst$12=caml_string_of_jsbytes(" "),
     cst_of_sexp_record_conversion_$0=
      caml_string_of_jsbytes
       ("_of_sexp: record conversion: only pairs expected, their first element must be an atom"),
     cst_of_sexp_record_conversion_=
      caml_string_of_jsbytes
       ("_of_sexp: record conversion: a [sexp.bool] field was given a payload."),
     cst_of_sexp_unexpected_variant=
      caml_string_of_jsbytes("_of_sexp: unexpected variant constructor"),
     cst_of_sexp_expected_a_variant$0=
      caml_string_of_jsbytes
       ("_of_sexp: expected a variant type, saw an empty list"),
     cst_of_sexp_expected_a_variant=
      caml_string_of_jsbytes
       ("_of_sexp: expected a variant type, saw a nested list"),
     cst_of_sexp_this_constructor_r=
      caml_string_of_jsbytes("_of_sexp: this constructor requires arguments"),
     cst_of_sexp_this_constructor_d=
      caml_string_of_jsbytes
       ("_of_sexp: this constructor does not take arguments"),
     cst_Sexplib0_Sexp_conv_error_N=
      caml_string_of_jsbytes("Sexplib0__Sexp_conv_error.No_variant_match"),
     Stdlib_StringLabels=global_data.Stdlib__StringLabels,
     Stdlib_Format=global_data.Stdlib__Format,
     Stdlib_ListLabels=global_data.Stdlib__ListLabels,
     Stdlib_Buffer=global_data.Stdlib__Buffer,
     Stdlib=global_data.Stdlib,
     Stdlib_BytesLabels=global_data.Stdlib__BytesLabels,
     Stdlib_Char=global_data.Stdlib__Char,
     Stdlib_Bytes=global_data.Stdlib__Bytes,
     Assert_failure=global_data.Assert_failure,
     Stdlib_Arg=global_data.Stdlib__Arg,
     Stdlib_Lazy=global_data.Stdlib__Lazy,
     Stdlib_Parsing=global_data.Stdlib__Parsing,
     Stdlib_Queue=global_data.Stdlib__Queue,
     Stdlib_Scanf=global_data.Stdlib__Scanf,
     Stdlib_Stack=global_data.Stdlib__Stack,
     Stdlib_Sys=global_data.Stdlib__Sys,
     Stdlib_Printf=global_data.Stdlib__Printf,
     Stdlib_MoreLabels=global_data.Stdlib__MoreLabels,
     Stdlib_Printexc=global_data.Stdlib__Printexc,
     Stdlib_Obj=global_data.Stdlib__Obj,
     CamlinternalLazy=global_data.CamlinternalLazy,
     Stdlib_Nativeint=global_data.Stdlib__Nativeint,
     Stdlib_Int64=global_data.Stdlib__Int64,
     Stdlib_Int32=global_data.Stdlib__Int32,
     Stdlib_Ephemeron=global_data.Stdlib__Ephemeron,
     Sexplib0=[0];
    caml_register_global(141,Sexplib0,"Sexplib0__");
    var
     _b_=[0,[15,[17,2,0]],caml_string_of_jsbytes("%a@?")],
     _a_=[0,0,0],
     _aG_=[0,0],
     _aH_=[0,1],
     _aC_=[0,caml_string_of_jsbytes("Sexplib.Conv.Of_sexp_error")],
     _aD_=[0,caml_string_of_jsbytes("src/sexp_conv.ml"),410,15],
     _az_=[0,0],
     _aA_=[0,0],
     _aw_=[0,caml_string_of_jsbytes("src/sexp_conv.ml"),334,15],
     _as_=[0,caml_string_of_jsbytes("Exit")],
     _at_=[0,caml_string_of_jsbytes("src/sexp_conv.ml"),338,15],
     _ao_=[0,caml_string_of_jsbytes("End_of_file")],
     _ap_=[0,caml_string_of_jsbytes("src/sexp_conv.ml"),342,15],
     _ak_=[0,caml_string_of_jsbytes("Failure")],
     _al_=[0,caml_string_of_jsbytes("src/sexp_conv.ml"),346,15],
     _ag_=[0,caml_string_of_jsbytes("Not_found")],
     _ah_=[0,caml_string_of_jsbytes("src/sexp_conv.ml"),350,15],
     _ac_=[0,caml_string_of_jsbytes("Invalid_argument")],
     _ad_=[0,caml_string_of_jsbytes("src/sexp_conv.ml"),354,15],
     _$_=[0,caml_string_of_jsbytes("src/sexp_conv.ml"),358,15],
     _X_=[0,caml_string_of_jsbytes("Not_found_s")],
     _Y_=[0,caml_string_of_jsbytes("src/sexp_conv.ml"),362,15],
     _U_=[0,caml_string_of_jsbytes("Sys_error")],
     _V_=[0,caml_string_of_jsbytes("src/sexp_conv.ml"),366,15],
     _Q_=[0,caml_string_of_jsbytes("Arg.Help")],
     _R_=[0,caml_string_of_jsbytes("src/sexp_conv.ml"),370,15],
     _M_=[0,caml_string_of_jsbytes("Arg.Bad")],
     _N_=[0,caml_string_of_jsbytes("src/sexp_conv.ml"),374,15],
     _I_=[0,caml_string_of_jsbytes("Lazy.Undefined")],
     _J_=[0,caml_string_of_jsbytes("src/sexp_conv.ml"),378,15],
     _E_=[0,caml_string_of_jsbytes("Parsing.Parse_error")],
     _F_=[0,caml_string_of_jsbytes("src/sexp_conv.ml"),382,15],
     _A_=[0,caml_string_of_jsbytes("Queue.Empty")],
     _B_=[0,caml_string_of_jsbytes("src/sexp_conv.ml"),386,15],
     _w_=[0,caml_string_of_jsbytes("Scanf.Scan_failure")],
     _x_=[0,caml_string_of_jsbytes("src/sexp_conv.ml"),390,15],
     _s_=[0,caml_string_of_jsbytes("Stack.Empty")],
     _t_=[0,caml_string_of_jsbytes("src/sexp_conv.ml"),394,15],
     _o_=[0,caml_string_of_jsbytes("Sys.Break")],
     _p_=[0,caml_string_of_jsbytes("src/sexp_conv.ml"),398,15],
     _l_=
      [0,
       [2,0,[12,32,[2,0,[12,58,[4,0,0,0,[12,58,[4,0,0,0,0]]]]]]],
       caml_string_of_jsbytes("%s %s:%d:%d")],
     _k_=[0,2],
     _j_=[0,2],
     _h_=[0,caml_string_of_jsbytes("<fun>")],
     _g_=[0,caml_string_of_jsbytes("<opaque>")],
     _d_=[0,caml_string_of_jsbytes("some")],
     _e_=[1,0],
     _f_=[0,caml_string_of_jsbytes("none")],
     _c_=[1,0],
     _aM_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes("_of_sexp: polymorphic variant tag "),
         [3,
          0,
          [11,caml_string_of_jsbytes(" has incorrect number of arguments"),0]]]],
       caml_string_of_jsbytes
        ("%s_of_sexp: polymorphic variant tag %S has incorrect number of arguments")],
     _aL_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes
          ("_of_sexp: the following record elements were undefined: "),
         [2,0,0]]],
       caml_string_of_jsbytes
        ("%s_of_sexp: the following record elements were undefined: %s")],
     _aK_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes("_of_sexp: "),
         [2,0,[11,caml_string_of_jsbytes(": "),[2,0,0]]]]],
       caml_string_of_jsbytes("%s_of_sexp: %s: %s")],
     _aJ_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes("_of_sexp: sum tag "),
         [3,
          0,
          [11,caml_string_of_jsbytes(" has incorrect number of arguments"),0]]]],
       caml_string_of_jsbytes
        ("%s_of_sexp: sum tag %S has incorrect number of arguments")],
     _aI_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes("_of_sexp: tuple of size "),
         [4,0,0,0,[11,caml_string_of_jsbytes(" expected"),0]]]],
       caml_string_of_jsbytes("%s_of_sexp: tuple of size %d expected")];
    function sexp_of_t(t){return t}
    function t_of_sexp(t){return t}
    function compare(a$0,b$0)
     {if(a$0 === b$0)return 0;
      if(0 === a$0[0])
       {var _b8_=a$0[1];
        if(0 !== b$0[0])return -1;
        var b$1=b$0[1];
        return caml_call2(Stdlib_StringLabels[9],_b8_,b$1)}
      var _b9_=a$0[1];
      if(0 === b$0[0])return 1;
      var b$2=b$0[1],a=_b9_,b=b$2;
      for(;;)
       {if(! a)return b?-1:0;
        if(! b)return 1;
        var ys=b[2],y=b[1],xs=a[2],x=a[1],res=compare(x,y);
        if(0 !== res)return res;
        var a=xs,b=ys}}
    function equal(a,b){return 0 === compare(a,b)?1:0}
    var
     Not_found_s=[248,cst_Sexplib0_Sexp_Not_found_s,caml_fresh_oo_id(0)],
     Of_sexp_error=[248,cst_Sexplib0_Sexp_Of_sexp_erro,caml_fresh_oo_id(0)],
     default_indent=[0,1];
    function must_escape(str)
     {var len=caml_ml_string_length(str),_bY_=0 === len?1:0;
      if(_bY_)return _bY_;
      var ix$3=len - 1 | 0,ix=ix$3;
      for(;;)
       {var match=caml_string_get(str,ix),switch$0=0;
        if(92 <= match)
         {var switcher=match - 93 | 0;
          if(33 < switcher >>> 0)
           if(0 <= switcher)switch$0 = 2;else switch$0 = 1;
          else
           if(31 === switcher)
            {var _bZ_=0 < ix?1:0;
             if(_bZ_)
              {var
                ix$0=ix - 1 | 0,
                _b0_=caml_string_get(str,ix$0),
                _b1_=caml_call2(Stdlib_Char[8],_b0_,35);
               if(! _b1_){var ix=ix$0;continue}
               var _b2_=_b1_}
             else
              var _b2_=_bZ_;
             return _b2_}}
        else
         if(42 <= match)
          {if(59 === match)switch$0 = 1}
         else
          if(33 <= match)
           switch(match - 33 | 0)
            {case 2:
              var _b4_=0 < ix?1:0;
              if(_b4_)
               {var
                 ix$2=ix - 1 | 0,
                 _b5_=caml_string_get(str,ix$2),
                 _b6_=caml_call2(Stdlib_Char[8],_b5_,124);
                if(! _b6_){var ix=ix$2;continue}
                var _b7_=_b6_}
              else
               var _b7_=_b4_;
              return _b7_;
             case 1:
             case 7:
             case 8:switch$0 = 1;break
             }
          else
           switch$0 = 2;
        switch(switch$0)
         {case 0:
           var _b3_=0 < ix?1:0;
           if(! _b3_)return _b3_;
           var ix$1=ix - 1 | 0,ix=ix$1;
           continue;
          case 1:return 1;
          default:return 1}}}
    function escaped(s)
     {var n=[0,0],_bO_=caml_ml_string_length(s) - 1 | 0,_bN_=0;
      if(_bO_ >= 0)
       {var i$0=_bN_;
        for(;;)
         {var match=caml_string_unsafe_get(s,i$0),switch$0=0;
          if(32 <= match)
           {var _bV_=match - 34 | 0,switch$1=0;
            if(58 < _bV_ >>> 0)
             {if(93 <= _bV_)switch$1 = 1}
            else
             if(56 < _bV_ - 1 >>> 0){switch$0 = 1;switch$1 = 1}
            if(! switch$1){var _bW_=1;switch$0 = 2}}
          else
           if(11 <= match)
            {if(13 === match)switch$0 = 1}
           else
            if(8 <= match)switch$0 = 1;
          switch(switch$0){case 0:var _bW_=4;break;case 1:var _bW_=2;break}
          n[1] = n[1] + _bW_ | 0;
          var _bX_=i$0 + 1 | 0;
          if(_bO_ !== i$0){var i$0=_bX_;continue}
          break}}
      if(n[1] === caml_ml_string_length(s))return s;
      var s$0=caml_create_bytes(n[1]);
      n[1] = 0;
      var _bQ_=caml_ml_string_length(s) - 1 | 0,_bP_=0;
      if(_bQ_ >= 0)
       {var i=_bP_;
        for(;;)
         {var c=caml_string_unsafe_get(s,i),switch$2=0;
          if(35 <= c)
           if(92 === c)
            switch$2 = 2;
           else
            if(127 <= c)switch$2 = 1;else switch$2 = 3;
          else
           if(32 <= c)
            if(34 <= c)switch$2 = 2;else switch$2 = 3;
           else
            if(14 <= c)
             switch$2 = 1;
            else
             switch(c)
              {case 8:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],98);
                break;
               case 9:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],116);
                break;
               case 10:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],110);
                break;
               case 13:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],114);
                break;
               default:switch$2 = 1}
          switch(switch$2)
           {case 1:
             caml_bytes_unsafe_set(s$0,n[1],92);
             n[1]++;
             var _bS_=caml_call1(Stdlib_Char[1],48 + (c / 100 | 0) | 0);
             caml_bytes_unsafe_set(s$0,n[1],_bS_);
             n[1]++;
             var
              _bT_=
               caml_call1(Stdlib_Char[1],48 + ((c / 10 | 0) % 10 | 0) | 0);
             caml_bytes_unsafe_set(s$0,n[1],_bT_);
             n[1]++;
             var _bU_=caml_call1(Stdlib_Char[1],48 + (c % 10 | 0) | 0);
             caml_bytes_unsafe_set(s$0,n[1],_bU_);
             break;
            case 2:
             caml_bytes_unsafe_set(s$0,n[1],92);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],c);
             break;
            case 3:caml_bytes_unsafe_set(s$0,n[1],c);break
            }
          n[1]++;
          var _bR_=i + 1 | 0;
          if(_bQ_ !== i){var i=_bR_;continue}
          break}}
      return caml_call1(Stdlib_BytesLabels[48],s$0)}
    function esc_str(str)
     {var
       src=escaped(str),
       len=caml_ml_string_length(src),
       dst=caml_create_bytes(len + 2 | 0);
      caml_call5(Stdlib_Bytes[12],src,0,dst,1,len);
      caml_bytes_unsafe_set(dst,0,34);
      caml_bytes_unsafe_set(dst,len + 1 | 0,34);
      return caml_call1(Stdlib_BytesLabels[48],dst)}
    function index_of_newline(str,start)
     {try
       {var _bL_=[0,caml_call3(Stdlib_StringLabels[31],str,start,10)];
        return _bL_}
      catch(_bM_)
       {_bM_ = caml_wrap_exception(_bM_);
        if(_bM_ === Stdlib[8])return 0;
        throw _bM_}}
    function mach_maybe_esc_str(str){return must_escape(str)?esc_str(str):str}
    function pp_hum_indent(indent,ppf,param)
     {if(0 === param[0])
       {var str=param[1];
        if(! must_escape(str))return caml_call2(Stdlib_Format[13],ppf,str);
        var match=index_of_newline(str,0);
        if(match)
         var
          index=match[1],
          _bH_=(index + 1 | 0) === caml_ml_string_length(str)?1:0;
        else
         var _bH_=1;
        if(_bH_)
         {var _bI_=esc_str(str);return caml_call2(Stdlib_Format[13],ppf,_bI_)}
        caml_call2(Stdlib_Format[1],ppf,0);
        caml_call2(Stdlib_Format[13],ppf,cst$0);
        var index$0=0;
        for(;;)
         {var end_pos_opt=index_of_newline(str,index$0);
          if(end_pos_opt)
           var end_pos=end_pos_opt[1],end_pos$0=end_pos;
          else
           var end_pos$0=caml_ml_string_length(str);
          var
           next_line=
            caml_call3
             (Stdlib_StringLabels[15],str,index$0,end_pos$0 - index$0 | 0),
           _bJ_=escaped(next_line);
          caml_call2(Stdlib_Format[13],ppf,_bJ_);
          if(end_pos_opt)
           {var newline_index=end_pos_opt[1];
            caml_call2(Stdlib_Format[13],ppf,cst);
            caml_call2(Stdlib_Format[34],ppf,0);
            caml_call2(Stdlib_Format[13],ppf,cst_n);
            var index$1=newline_index + 1 | 0,index$0=index$1;
            continue}
          caml_call2(Stdlib_Format[13],ppf,cst$1);
          return caml_call2(Stdlib_Format[3],ppf,0)}}
      var _bK_=param[1];
      if(! _bK_)return caml_call2(Stdlib_Format[13],ppf,cst$3);
      var t=_bK_[2],h=_bK_[1];
      caml_call2(Stdlib_Format[1],ppf,indent);
      caml_call2(Stdlib_Format[13],ppf,cst$2);
      pp_hum_indent(indent,ppf,h);
      var param$0=t;
      for(;;)
       {if(param$0)
         {var t$0=param$0[2],h$0=param$0[1];
          caml_call2(Stdlib_Format[27],ppf,0);
          pp_hum_indent(indent,ppf,h$0);
          var param$0=t$0;
          continue}
        caml_call2(Stdlib_Format[13],ppf,cst$4);
        return caml_call2(Stdlib_Format[3],ppf,0)}}
    function pp_mach_internal(may_need_space,ppf,param)
     {if(0 === param[0])
       {var
         str=param[1],
         str$0=mach_maybe_esc_str(str),
         new_may_need_space=str$0 === str?1:0,
         new_may_need_space$0=may_need_space?new_may_need_space:may_need_space;
        if(new_may_need_space$0)caml_call2(Stdlib_Format[13],ppf,cst$5);
        caml_call2(Stdlib_Format[13],ppf,str$0);
        return new_may_need_space}
      var _bG_=param[1];
      if(! _bG_){caml_call2(Stdlib_Format[13],ppf,cst$7);return 0}
      var t=_bG_[2],h=_bG_[1];
      caml_call2(Stdlib_Format[13],ppf,cst$6);
      var
       may_need_space$0=pp_mach_internal(0,ppf,h),
       may_need_space$1=may_need_space$0,
       param$0=t;
      for(;;)
       {if(param$0)
         {var
           t$0=param$0[2],
           h$0=param$0[1],
           may_need_space$2=pp_mach_internal(may_need_space$1,ppf,h$0),
           may_need_space$1=may_need_space$2,
           param$0=t$0;
          continue}
        caml_call2(Stdlib_Format[13],ppf,cst$8);
        return 0}}
    function pp_hum(ppf,sexp)
     {return pp_hum_indent(default_indent[1],ppf,sexp)}
    function pp(ppf,sexp){pp_mach_internal(0,ppf,sexp);return 0}
    function size_loop(acc,param)
     {var _bE_=acc[2],_bF_=acc[1];
      if(0 === param[0])
       {var str=param[1];
        return [0,_bF_ + 1 | 0,_bE_ + caml_ml_string_length(str) | 0]}
      var lst=param[1];
      return caml_call3(Stdlib_ListLabels[25],size_loop,acc,lst)}
    function size(sexp){return size_loop(_a_,sexp)}
    function to_buffer_hum(buf,opt,sexp)
     {if(opt)var sth=opt[1],indent=sth;else var indent=default_indent[1];
      var ppf=caml_call1(Stdlib_Format[111],buf);
      function _bB_(_bC_,_bD_){return pp_hum_indent(indent,_bC_,_bD_)}
      return caml_call4(Stdlib_Format[129],ppf,_b_,_bB_,sexp)}
    function to_buffer(buf,sexp)
     {function loop(may_need_space,param)
       {if(0 === param[0])
         {var
           str=param[1],
           str$0=mach_maybe_esc_str(str),
           new_may_need_space=str$0 === str?1:0,
           new_may_need_space$0=
            may_need_space?new_may_need_space:may_need_space;
          if(new_may_need_space$0)caml_call2(Stdlib_Buffer[12],buf,32);
          caml_call2(Stdlib_Buffer[16],buf,str$0);
          return new_may_need_space}
        var _bA_=param[1];
        if(! _bA_){caml_call2(Stdlib_Buffer[16],buf,cst$9);return 0}
        var t=_bA_[2],h=_bA_[1];
        caml_call2(Stdlib_Buffer[12],buf,40);
        var
         may_need_space$0=loop(0,h),
         may_need_space$1=may_need_space$0,
         param$0=t;
        for(;;)
         {if(param$0)
           {var
             t$0=param$0[2],
             h$0=param$0[1],
             may_need_space$2=loop(may_need_space$1,h$0),
             may_need_space$1=may_need_space$2,
             param$0=t$0;
            continue}
          caml_call2(Stdlib_Buffer[12],buf,41);
          return 0}}
      loop(0,sexp);
      return 0}
    function to_buffer_gen(buf,add_char,add_string,sexp)
     {function loop(may_need_space,param)
       {if(0 === param[0])
         {var
           str=param[1],
           str$0=mach_maybe_esc_str(str),
           new_may_need_space=str$0 === str?1:0,
           new_may_need_space$0=
            may_need_space?new_may_need_space:may_need_space;
          if(new_may_need_space$0)caml_call2(add_char,buf,32);
          caml_call2(add_string,buf,str$0);
          return new_may_need_space}
        var _bz_=param[1];
        if(! _bz_){caml_call2(add_string,buf,cst$10);return 0}
        var t=_bz_[2],h=_bz_[1];
        caml_call2(add_char,buf,40);
        var
         may_need_space$0=loop(0,h),
         may_need_space$1=may_need_space$0,
         param$0=t;
        for(;;)
         {if(param$0)
           {var
             t$0=param$0[2],
             h$0=param$0[1],
             may_need_space$2=loop(may_need_space$1,h$0),
             may_need_space$1=may_need_space$2,
             param$0=t$0;
            continue}
          caml_call2(add_char,buf,41);
          return 0}}
      loop(0,sexp);
      return 0}
    function buffer(param){return caml_call1(Stdlib_Buffer[1],1024)}
    function to_string_hum(indent,sexp)
     {if(0 === sexp[0])
       {var str=sexp[1],match=index_of_newline(str,0),_by_=match?0:1;
        if(_by_)return mach_maybe_esc_str(str)}
      var buf=buffer(0);
      to_buffer_hum(buf,indent,sexp);
      return caml_call1(Stdlib_Buffer[2],buf)}
    function to_string(sexp)
     {if(0 === sexp[0]){var str=sexp[1];return mach_maybe_esc_str(str)}
      var buf=buffer(0);
      to_buffer(buf,sexp);
      return caml_call1(Stdlib_Buffer[2],buf)}
    var of_float_style=[0,1009018843],of_int_style=[0,1009018843];
    function message(name,fields)
     {function conv_fields(param)
       {if(! param)return 0;
        var rest=param[2],match=param[1],fsexp=match[2],fname=match[1];
        return caml_string_notequal(fname,cst$11)
                ?[0,[1,[0,[0,fname],[0,fsexp,0]]],conv_fields(rest)]
                :[0,fsexp,conv_fields(rest)]}
      return [1,[0,[0,name],conv_fields(fields)]]}
    var
     Sexplib0_Sexp=
      [0,
       t_of_sexp,
       sexp_of_t,
       equal,
       compare,
       Not_found_s,
       Of_sexp_error,
       message,
       default_indent,
       pp_hum,
       pp_hum_indent,
       pp,
       pp,
       to_string_hum,
       to_string,
       to_string,
       of_float_style,
       of_int_style,
       [0,
        size,
        buffer,
        to_buffer,
        to_buffer_hum,
        to_buffer,
        to_buffer_gen,
        mach_maybe_esc_str,
        must_escape,
        esc_str]];
    caml_register_global(150,Sexplib0_Sexp,"Sexplib0__Sexp");
    function coerce(t){return t}
    var Sexplib0_Sexp_grammar=[0,coerce,doc_comment_tag];
    caml_register_global(151,Sexplib0_Sexp_grammar,"Sexplib0__Sexp_grammar");
    var
     bool_sexp_grammar=0,
     string_sexp_grammar=4,
     bytes_sexp_grammar=4,
     char_sexp_grammar=1,
     int_sexp_grammar=2,
     float_sexp_grammar=3,
     int32_sexp_grammar=2,
     int64_sexp_grammar=2,
     nativeint_sexp_grammar=2;
    function ref_sexp_grammar(grammar){return grammar}
    function lazy_t_sexp_grammar(grammar){return grammar}
    function option_sexp_grammar(param){return [1,param]}
    function list_sexp_grammar(param){return [2,[1,param]]}
    function array_sexp_grammar(param){return [2,[1,param]]}
    var
     include=
      [0,
       unit_sexp_grammar,
       bool_sexp_grammar,
       string_sexp_grammar,
       bytes_sexp_grammar,
       char_sexp_grammar,
       int_sexp_grammar,
       float_sexp_grammar,
       int32_sexp_grammar,
       int64_sexp_grammar,
       nativeint_sexp_grammar,
       sexp_t_sexp_grammar,
       ref_sexp_grammar,
       lazy_t_sexp_grammar,
       option_sexp_grammar,
       list_sexp_grammar,
       array_sexp_grammar,
       fun_sexp_grammar,
       fun_sexp_grammar];
    caml_register_global(152,include,"Sexplib0__Sexp_conv_grammar");
    var
     default_string_of_float=
      [0,
       function(x)
        {var y=caml_format_float(cst_15G,x);
         return caml_float_of_string(y) == x?y:caml_format_float(cst_17G,x)}],
     read_old_option_format=[0,1],
     write_old_option_format=[0,1];
    function list_map(f,l)
     {var _bx_=caml_call2(Stdlib_ListLabels[21],f,l);
      return caml_call1(Stdlib_ListLabels[9],_bx_)}
    function sexp_of_unit(param){return _c_}
    function sexp_of_bool(b){return [0,caml_call1(Stdlib[30],b)]}
    function sexp_of_string(str){return [0,str]}
    function sexp_of_bytes(bytes)
     {return [0,caml_call1(Stdlib_BytesLabels[6],bytes)]}
    function sexp_of_char(c)
     {return [0,caml_call2(Stdlib_StringLabels[1],1,c)]}
    function sexp_of_int(n){return [0,caml_call1(Stdlib[33],n)]}
    function sexp_of_float(n)
     {return [0,caml_call1(default_string_of_float[1],n)]}
    function sexp_of_int32(n){return [0,caml_call1(Stdlib_Int32[14],n)]}
    function sexp_of_int64(n){return [0,caml_call1(Stdlib_Int64[14],n)]}
    function sexp_of_nativeint(n)
     {return [0,caml_call1(Stdlib_Nativeint[15],n)]}
    function sexp_of_ref(sexp_of_a,rf){return caml_call1(sexp_of_a,rf[1])}
    function sexp_of_lazy_t(sexp_of_a,lv)
     {var
       _bv_=runtime.caml_obj_tag(lv),
       _bw_=
        250 === _bv_?lv[1]:246 === _bv_?caml_call1(CamlinternalLazy[2],lv):lv;
      return caml_call1(sexp_of_a,_bw_)}
    function sexp_of_option(sexp_of_a,param)
     {if(! param)return write_old_option_format[1]?_e_:_f_;
      var x=param[1];
      return write_old_option_format[1]
              ?[1,[0,caml_call1(sexp_of_a,x),0]]
              :[1,[0,_d_,[0,caml_call1(sexp_of_a,x),0]]]}
    function sexp_of_pair(sexp_of_a,sexp_of_b,param)
     {var b=param[2],a=param[1],_bu_=[0,caml_call1(sexp_of_b,b),0];
      return [1,[0,caml_call1(sexp_of_a,a),_bu_]]}
    function sexp_of_triple(sexp_of_a,sexp_of_b,sexp_of_c,param)
     {var
       c=param[3],
       b=param[2],
       a=param[1],
       _bs_=[0,caml_call1(sexp_of_c,c),0],
       _bt_=[0,caml_call1(sexp_of_b,b),_bs_];
      return [1,[0,caml_call1(sexp_of_a,a),_bt_]]}
    function sexp_of_list(sexp_of_a,lst)
     {var _br_=caml_call2(Stdlib_ListLabels[21],sexp_of_a,lst);
      return [1,caml_call1(Stdlib_ListLabels[9],_br_)]}
    function sexp_of_array(sexp_of_a,ar)
     {var lst_ref=[0,0],_bo_=ar.length - 1 - 1 | 0;
      if(_bo_ >= 0)
       {var i=_bo_;
        for(;;)
         {var _bp_=lst_ref[1];
          lst_ref[1]
          =
          [0,caml_call1(sexp_of_a,caml_check_bound(ar,i)[1 + i]),_bp_];
          var _bq_=i - 1 | 0;
          if(0 !== i){var i=_bq_;continue}
          break}}
      return [1,lst_ref[1]]}
    function sexp_of_hashtbl(sexp_of_key,sexp_of_val,htbl)
     {function coll(k,v,acc)
       {var _bn_=[0,caml_call1(sexp_of_val,v),0];
        return [0,[1,[0,caml_call1(sexp_of_key,k),_bn_]],acc]}
      return [1,caml_call3(Stdlib_MoreLabels[1][14],coll,htbl,0)]}
    function sexp_of_opaque(param){return _g_}
    function sexp_of_fun(param){return _h_}
    function equal$0(_bm_,_bl_){return _bm_ === _bl_?1:0}
    var
     hash=Stdlib_Obj[22][3],
     Exn_table=caml_call1(Stdlib_Ephemeron[1][16],[0,equal$0,hash]),
     the_exn_table=caml_call1(Exn_table[1],17);
    function add(opt,param,extension_constructor,sexp_of_exn)
     {if(opt)var sth=opt[1],printexc=sth;else var printexc=1;
      return caml_call3
              (Exn_table[5],
               the_exn_table,
               extension_constructor,
               [0,sexp_of_exn,printexc])}
    function find_auto(for_printexc,exn)
     {var
       extension_constructor=caml_call1(Stdlib_Obj[22][1],exn),
       match=caml_call2(Exn_table[8],the_exn_table,extension_constructor);
      if(! match)return 0;
      var match$0=match[1],printexc=match$0[2],sexp_of_exn=match$0[1];
      if(for_printexc && ! printexc)return 0;
      return [0,caml_call1(sexp_of_exn,exn)]}
    function size$0(param){return caml_call1(Exn_table[24],the_exn_table)[1]}
    var For_unit_tests_only=[0,size$0];
    function sexp_of_exn_opt(exn){return find_auto(0,exn)}
    function sexp_of_exn(exn)
     {var match=sexp_of_exn_opt(exn);
      if(! match)return [1,[0,[0,caml_call1(Stdlib_Printexc[1],exn)],0]];
      var sexp=match[1];
      return sexp}
    function exn_to_string(e){return to_string_hum(0,sexp_of_exn(e))}
    function _i_(exn)
     {var match=find_auto(1,exn);
      if(! match)return 0;
      var sexp=match[1];
      return [0,to_string_hum(_j_,sexp)]}
    caml_call1(Stdlib_Printexc[9],_i_);
    function printexc_prefer_sexp(exn)
     {var match=sexp_of_exn_opt(exn);
      if(! match)return caml_call1(Stdlib_Printexc[1],exn);
      var sexp=match[1];
      return to_string_hum(_k_,sexp)}
    var record_check_extra_fields=[0,1];
    function of_sexp_error_exn(exc,sexp){throw [0,Of_sexp_error,exc,sexp]}
    function of_sexp_error(what,sexp)
     {throw [0,Of_sexp_error,[0,Stdlib[7],what],sexp]}
    function unit_of_sexp(sexp)
     {if(1 === sexp[0] && ! sexp[1])return 0;
      return of_sexp_error(cst_unit_of_sexp_empty_list_ne,sexp)}
    function bool_of_sexp(sexp)
     {if(0 !== sexp[0])
       return of_sexp_error(cst_bool_of_sexp_atom_needed,sexp);
      var _bk_=sexp[1];
      if(caml_string_notequal(_bk_,cst_False))
       {var switch$0=0;
        if(caml_string_notequal(_bk_,cst_True))
         if(caml_string_notequal(_bk_,cst_false))
          {if(caml_string_notequal(_bk_,cst_true))
            return of_sexp_error(cst_bool_of_sexp_unknown_strin,sexp)}
         else
          switch$0 = 1;
        if(! switch$0)return 1}
      return 0}
    function string_of_sexp(sexp)
     {if(0 !== sexp[0])
       return of_sexp_error(cst_string_of_sexp_atom_needed,sexp);
      var str=sexp[1];
      return str}
    function bytes_of_sexp(sexp)
     {if(0 !== sexp[0])
       return of_sexp_error(cst_bytes_of_sexp_atom_needed,sexp);
      var str=sexp[1];
      return caml_call1(Stdlib_BytesLabels[5],str)}
    function char_of_sexp(sexp)
     {if(0 !== sexp[0])
       return of_sexp_error(cst_char_of_sexp_atom_needed,sexp);
      var str=sexp[1];
      if(1 !== caml_ml_string_length(str))
       of_sexp_error(cst_char_of_sexp_atom_string_m,sexp);
      return caml_string_get(str,0)}
    function int_of_sexp(sexp)
     {if(0 !== sexp[0])return of_sexp_error(cst_int_of_sexp_atom_needed,sexp);
      var str=sexp[1];
      try
       {var _bj_=caml_int_of_string(str);return _bj_}
      catch(exc)
       {exc = caml_wrap_exception(exc);
        var _bi_=exn_to_string(exc);
        return of_sexp_error(caml_call2(Stdlib[28],cst_int_of_sexp,_bi_),sexp)}}
    function float_of_sexp(sexp)
     {if(0 !== sexp[0])
       return of_sexp_error(cst_float_of_sexp_atom_needed,sexp);
      var str=sexp[1];
      try
       {var _bh_=caml_float_of_string(str);return _bh_}
      catch(exc)
       {exc = caml_wrap_exception(exc);
        var _bg_=exn_to_string(exc);
        return of_sexp_error
                (caml_call2(Stdlib[28],cst_float_of_sexp,_bg_),sexp)}}
    function int32_of_sexp(sexp)
     {if(0 !== sexp[0])
       return of_sexp_error(cst_int32_of_sexp_atom_needed,sexp);
      var str=sexp[1];
      try
       {var _bf_=caml_int_of_string(str);return _bf_}
      catch(exc)
       {exc = caml_wrap_exception(exc);
        var _be_=exn_to_string(exc);
        return of_sexp_error
                (caml_call2(Stdlib[28],cst_int32_of_sexp,_be_),sexp)}}
    function int64_of_sexp(sexp)
     {if(0 !== sexp[0])
       return of_sexp_error(cst_int64_of_sexp_atom_needed,sexp);
      var str=sexp[1];
      try
       {var _bd_=runtime.caml_int64_of_string(str);return _bd_}
      catch(exc)
       {exc = caml_wrap_exception(exc);
        var _bc_=exn_to_string(exc);
        return of_sexp_error
                (caml_call2(Stdlib[28],cst_int64_of_sexp,_bc_),sexp)}}
    function nativeint_of_sexp(sexp)
     {if(0 !== sexp[0])
       return of_sexp_error(cst_nativeint_of_sexp_atom_nee,sexp);
      var str=sexp[1];
      try
       {var _bb_=caml_int_of_string(str);return _bb_}
      catch(exc)
       {exc = caml_wrap_exception(exc);
        var _ba_=exn_to_string(exc);
        return of_sexp_error
                (caml_call2(Stdlib[28],cst_nativeint_of_sexp,_ba_),sexp)}}
    function ref_of_sexp(a_of_sexp,sexp)
     {return [0,caml_call1(a_of_sexp,sexp)]}
    function lazy_t_of_sexp(a_of_sexp,sexp)
     {var _a$_=caml_call1(a_of_sexp,sexp);
      return caml_call1(Stdlib_Lazy[4],_a$_)}
    function option_of_sexp(a_of_sexp,sexp)
     {if(! read_old_option_format[1])
       {if(0 === sexp[0])
         {var _a6_=sexp[1];
          if
           (caml_string_notequal(_a6_,cst_None$0)
            &&
            caml_string_notequal(_a6_,cst_none$0))
           return of_sexp_error(cst_option_of_sexp_only_none_c$0,sexp);
          return 0}
        var _a7_=sexp[1];
        if(_a7_)
         {var _a8_=_a7_[1];
          if(0 === _a8_[0])
           {var _a9_=_a8_[1],switch$2=0;
            if
             (!
              caml_string_notequal(_a9_,cst_Some$0)
              ||
              !
              caml_string_notequal(_a9_,cst_some$0))
             switch$2 = 1;
            if(switch$2)
             {var _a__=_a7_[2];
              if(_a__ && ! _a__[2])
               {var el$0=_a__[1];return [0,caml_call1(a_of_sexp,el$0)]}}}}
        return of_sexp_error(cst_option_of_sexp_list_must_b,sexp)}
      if(0 === sexp[0])
       {var _a1_=sexp[1];
        if
         (caml_string_notequal(_a1_,cst_None)
          &&
          caml_string_notequal(_a1_,cst_none))
         return of_sexp_error(cst_option_of_sexp_only_none_c,sexp)}
      else
       {var _a2_=sexp[1];
        if(_a2_)
         {var _a3_=_a2_[1];
          if(_a2_[2])
           {var switch$0=0;
            if(0 === _a3_[0])
             {var _a4_=_a3_[1],switch$1=0;
              if
               (caml_string_notequal(_a4_,cst_Some)
                &&
                caml_string_notequal(_a4_,cst_some))
               switch$1 = 1;
              if(! switch$1)
               {var _a5_=_a2_[2];if(! _a5_[2]){var el=_a5_[1];switch$0 = 1}}}
            if(! switch$0)
             return of_sexp_error(cst_option_of_sexp_list_must_r,sexp)}
          else
           var el=_a3_;
          return [0,caml_call1(a_of_sexp,el)]}}
      return 0}
    function pair_of_sexp(a_of_sexp,b_of_sexp,sexp)
     {if(0 === sexp[0])
       return of_sexp_error(cst_pair_of_sexp_list_needed,sexp);
      var _aZ_=sexp[1];
      if(_aZ_)
       {var _a0_=_aZ_[2];
        if(_a0_ && ! _a0_[2])
         {var
           b_sexp=_a0_[1],
           a_sexp=_aZ_[1],
           a=caml_call1(a_of_sexp,a_sexp),
           b=caml_call1(b_of_sexp,b_sexp);
          return [0,a,b]}}
      return of_sexp_error(cst_pair_of_sexp_list_must_con,sexp)}
    function triple_of_sexp(a_of_sexp,b_of_sexp,c_of_sexp,sexp)
     {if(0 === sexp[0])
       return of_sexp_error(cst_triple_of_sexp_list_needed,sexp);
      var _aW_=sexp[1];
      if(_aW_)
       {var _aX_=_aW_[2];
        if(_aX_)
         {var _aY_=_aX_[2];
          if(_aY_ && ! _aY_[2])
           {var
             c_sexp=_aY_[1],
             b_sexp=_aX_[1],
             a_sexp=_aW_[1],
             a=caml_call1(a_of_sexp,a_sexp),
             b=caml_call1(b_of_sexp,b_sexp),
             c=caml_call1(c_of_sexp,c_sexp);
            return [0,a,b,c]}}}
      return of_sexp_error(cst_triple_of_sexp_list_must_c,sexp)}
    function list_of_sexp(a_of_sexp,sexp)
     {if(0 === sexp[0])
       return of_sexp_error(cst_list_of_sexp_list_needed,sexp);
      var lst=sexp[1],rev_lst=caml_call2(Stdlib_ListLabels[21],a_of_sexp,lst);
      return caml_call1(Stdlib_ListLabels[9],rev_lst)}
    function array_of_sexp(a_of_sexp,sexp)
     {if(0 === sexp[0])
       return of_sexp_error(cst_array_of_sexp_list_needed,sexp);
      var _aU_=sexp[1];
      if(! _aU_)return [0];
      var
       t=_aU_[2],
       h=_aU_[1],
       len=caml_call1(Stdlib_ListLabels[1],t) + 1 | 0,
       res=runtime.caml_make_vect(len,caml_call1(a_of_sexp,h)),
       i=1,
       param=t;
      for(;;)
       {if(! param)return res;
        var t$0=param[2],h$0=param[1],_aV_=caml_call1(a_of_sexp,h$0);
        caml_check_bound(res,i)[1 + i] = _aV_;
        var i$0=i + 1 | 0,i=i$0,param=t$0}}
    function hashtbl_of_sexp(key_of_sexp,val_of_sexp,sexp)
     {if(0 === sexp[0])
       return of_sexp_error(cst_hashtbl_of_sexp_list_neede,sexp);
      var lst=sexp[1],htbl=caml_call2(Stdlib_MoreLabels[1][1],0,0);
      function act(param)
       {if(1 === param[0])
         {var _aQ_=param[1];
          if(_aQ_)
           {var _aR_=_aQ_[2];
            if(_aR_ && ! _aR_[2])
             {var
               v_sexp=_aR_[1],
               k_sexp=_aQ_[1],
               _aS_=caml_call1(val_of_sexp,v_sexp),
               _aT_=caml_call1(key_of_sexp,k_sexp);
              return caml_call3(Stdlib_MoreLabels[1][5],htbl,_aT_,_aS_)}}}
        return of_sexp_error(cst_hashtbl_of_sexp_tuple_list,sexp)}
      caml_call2(Stdlib_ListLabels[17],act,lst);
      return htbl}
    function opaque_of_sexp(sexp)
     {return of_sexp_error(cst_opaque_of_sexp_cannot_conv,sexp)}
    function fun_of_sexp(sexp)
     {return of_sexp_error(cst_fun_of_sexp_cannot_convert,sexp)}
    function get_flc_error(name,param)
     {var chr=param[3],line=param[2],file=param[1];
      return [0,caml_call5(Stdlib_Printf[4],_l_,name,file,line,chr)]}
    var _m_=0;
    function _n_(param)
     {if(param === Stdlib_Sys[44])return _o_;throw [0,Assert_failure,_p_]}
    var _q_=[0,[0,Stdlib_Sys[44],_n_],_m_];
    function _r_(param)
     {if(param === Stdlib_Stack[1])return _s_;throw [0,Assert_failure,_t_]}
    var _u_=[0,[0,Stdlib_Stack[1],_r_],_q_];
    function _v_(param)
     {if(param[1] !== Stdlib_Scanf[2])throw [0,Assert_failure,_x_];
      var arg=param[2];
      return [1,[0,_w_,[0,[0,arg],0]]]}
    var _y_=[0,[0,Stdlib_Scanf[2],_v_],_u_];
    function _z_(param)
     {if(param === Stdlib_Queue[1])return _A_;throw [0,Assert_failure,_B_]}
    var _C_=[0,[0,Stdlib_Queue[1],_z_],_y_];
    function _D_(param)
     {if(param === Stdlib_Parsing[10])return _E_;throw [0,Assert_failure,_F_]}
    var _G_=[0,[0,Stdlib_Parsing[10],_D_],_C_];
    function _H_(param)
     {if(param === Stdlib_Lazy[1])return _I_;throw [0,Assert_failure,_J_]}
    var _K_=[0,[0,Stdlib_Lazy[1],_H_],_G_];
    function _L_(param)
     {if(param[1] !== Stdlib_Arg[8])throw [0,Assert_failure,_N_];
      var arg=param[2];
      return [1,[0,_M_,[0,[0,arg],0]]]}
    var _O_=[0,[0,Stdlib_Arg[8],_L_],_K_];
    function _P_(param)
     {if(param[1] !== Stdlib_Arg[7])throw [0,Assert_failure,_R_];
      var arg=param[2];
      return [1,[0,_Q_,[0,[0,arg],0]]]}
    var _S_=[0,[0,Stdlib_Arg[7],_P_],_O_];
    function _T_(param)
     {if(param[1] !== Stdlib[11])throw [0,Assert_failure,_V_];
      var arg=param[2];
      return [1,[0,_U_,[0,[0,arg],0]]]}
    var
     _W_=[0,[0,Stdlib[11],_T_],_S_],
     _Z_=
      [0,
       [0,
        Not_found_s,
        function(param)
         {if(param[1] !== Not_found_s)throw [0,Assert_failure,_Y_];
          var arg=param[2];
          return [1,[0,_X_,[0,arg,0]]]}],
       _W_];
    function ___(param)
     {if(param[1] !== Stdlib[4])throw [0,Assert_failure,_$_];
      var arg=param[2];
      return get_flc_error(cst_Match_failure,arg)}
    var _aa_=[0,[0,Stdlib[4],___],_Z_];
    function _ab_(param)
     {if(param[1] !== Stdlib[6])throw [0,Assert_failure,_ad_];
      var arg=param[2];
      return [1,[0,_ac_,[0,[0,arg],0]]]}
    var _ae_=[0,[0,Stdlib[6],_ab_],_aa_];
    function _af_(param)
     {if(param === Stdlib[8])return _ag_;throw [0,Assert_failure,_ah_]}
    var _ai_=[0,[0,Stdlib[8],_af_],_ae_];
    function _aj_(param)
     {if(param[1] !== Stdlib[7])throw [0,Assert_failure,_al_];
      var arg=param[2];
      return [1,[0,_ak_,[0,[0,arg],0]]]}
    var _am_=[0,[0,Stdlib[7],_aj_],_ai_];
    function _an_(param)
     {if(param === Stdlib[12])return _ao_;throw [0,Assert_failure,_ap_]}
    var _aq_=[0,[0,Stdlib[12],_an_],_am_];
    function _ar_(param)
     {if(param === Stdlib[3])return _as_;throw [0,Assert_failure,_at_]}
    var _au_=[0,[0,Stdlib[3],_ar_],_aq_];
    function _av_(param)
     {if(param[1] !== Stdlib[5])throw [0,Assert_failure,_aw_];
      var arg=param[2];
      return get_flc_error(cst_Assert_failure,arg)}
    var _ax_=[0,[0,Stdlib[5],_av_],_au_];
    function _ay_(param)
     {var handler=param[2],extension_constructor=param[1];
      return add(_aA_,_az_,extension_constructor,handler)}
    caml_call2(Stdlib_ListLabels[17],_ay_,_ax_);
    var
     _aB_=0,
     _aE_=
      [0,
       [0,
        Of_sexp_error,
        function(param)
         {if(param[1] !== Of_sexp_error)throw [0,Assert_failure,_aD_];
          var sexp=param[3],exc=param[2];
          return [1,[0,_aC_,[0,sexp_of_exn(exc),[0,sexp,0]]]]}],
       _aB_];
    function _aF_(param)
     {var handler=param[2],extension_constructor=param[1];
      return add(_aH_,_aG_,extension_constructor,handler)}
    caml_call2(Stdlib_ListLabels[17],_aF_,_aE_);
    var
     Sexplib0_Sexp_conv=
      [0,
       default_string_of_float,
       write_old_option_format,
       read_old_option_format,
       list_map,
       sexp_of_unit,
       sexp_of_bool,
       sexp_of_string,
       sexp_of_bytes,
       sexp_of_char,
       sexp_of_int,
       sexp_of_float,
       sexp_of_int32,
       sexp_of_int64,
       sexp_of_nativeint,
       sexp_of_ref,
       sexp_of_lazy_t,
       sexp_of_option,
       sexp_of_pair,
       sexp_of_triple,
       sexp_of_list,
       sexp_of_array,
       sexp_of_hashtbl,
       sexp_of_opaque,
       sexp_of_fun,
       Of_sexp_error,
       record_check_extra_fields,
       of_sexp_error,
       of_sexp_error_exn,
       unit_of_sexp,
       bool_of_sexp,
       string_of_sexp,
       bytes_of_sexp,
       char_of_sexp,
       int_of_sexp,
       float_of_sexp,
       int32_of_sexp,
       int64_of_sexp,
       nativeint_of_sexp,
       ref_of_sexp,
       lazy_t_of_sexp,
       option_of_sexp,
       pair_of_sexp,
       triple_of_sexp,
       list_of_sexp,
       array_of_sexp,
       hashtbl_of_sexp,
       opaque_of_sexp,
       fun_of_sexp,
       unit_sexp_grammar,
       bool_sexp_grammar,
       string_sexp_grammar,
       bytes_sexp_grammar,
       char_sexp_grammar,
       int_sexp_grammar,
       float_sexp_grammar,
       int32_sexp_grammar,
       int64_sexp_grammar,
       nativeint_sexp_grammar,
       sexp_t_sexp_grammar,
       ref_sexp_grammar,
       lazy_t_sexp_grammar,
       option_sexp_grammar,
       list_sexp_grammar,
       array_sexp_grammar,
       fun_sexp_grammar,
       fun_sexp_grammar,
       sexp_of_exn,
       printexc_prefer_sexp,
       sexp_of_exn_opt,
       [0,add,For_unit_tests_only]];
    caml_register_global(170,Sexplib0_Sexp_conv,"Sexplib0__Sexp_conv");
    function tuple_of_size_n_expected(loc,n,sexp)
     {return of_sexp_error(caml_call3(Stdlib_Printf[4],_aI_,loc,n),sexp)}
    function stag_no_args(loc,sexp)
     {return of_sexp_error
              (caml_call2(Stdlib[28],loc,cst_of_sexp_this_constructor_d),sexp)}
    function stag_incorrect_n_args(loc,tag,sexp)
     {var msg=caml_call3(Stdlib_Printf[4],_aJ_,loc,tag);
      return of_sexp_error(msg,sexp)}
    function stag_takes_args(loc,sexp)
     {return of_sexp_error
              (caml_call2(Stdlib[28],loc,cst_of_sexp_this_constructor_r),sexp)}
    function nested_list_invalid_sum(loc,sexp)
     {return of_sexp_error
              (caml_call2(Stdlib[28],loc,cst_of_sexp_expected_a_variant),sexp)}
    function empty_list_invalid_sum(loc,sexp)
     {return of_sexp_error
              (caml_call2(Stdlib[28],loc,cst_of_sexp_expected_a_variant$0),
               sexp)}
    function unexpected_stag(loc,sexp)
     {return of_sexp_error
              (caml_call2(Stdlib[28],loc,cst_of_sexp_unexpected_variant),sexp)}
    function record_sexp_bool_with_payload(loc,sexp)
     {var msg=caml_call2(Stdlib[28],loc,cst_of_sexp_record_conversion_);
      return of_sexp_error(msg,sexp)}
    function record_only_pairs_expected(loc,sexp)
     {var msg=caml_call2(Stdlib[28],loc,cst_of_sexp_record_conversion_$0);
      return of_sexp_error(msg,sexp)}
    function record_superfluous_fields(what,loc,rev_fld_names,sexp)
     {var
       _aP_=caml_call1(Stdlib_ListLabels[9],rev_fld_names),
       fld_names_str=caml_call2(Stdlib_StringLabels[6],cst$12,_aP_),
       msg=caml_call4(Stdlib_Printf[4],_aK_,loc,what,fld_names_str);
      return of_sexp_error(msg,sexp)}
    function record_duplicate_fields(loc,rev_fld_names,sexp)
     {return record_superfluous_fields
              (cst_duplicate_fields,loc,rev_fld_names,sexp)}
    function record_extra_fields(loc,rev_fld_names,sexp)
     {return record_superfluous_fields
              (cst_extra_fields,loc,rev_fld_names,sexp)}
    function record_get_undefined_loop(fields,param)
     {var fields$0=fields,param$0=param;
      for(;;)
       {if(! param$0)
         {var _aO_=caml_call1(Stdlib_ListLabels[9],fields$0);
          return caml_call2(Stdlib_StringLabels[6],cst$13,_aO_)}
        var _aN_=param$0[1];
        if(_aN_[1])
         {var
           param$1=param$0[2],
           field=_aN_[2],
           fields$1=[0,field,fields$0],
           fields$0=fields$1,
           param$0=param$1;
          continue}
        var param$2=param$0[2],param$0=param$2}}
    function record_undefined_elements(loc,sexp,lst)
     {var
       undefined$0=record_get_undefined_loop(0,lst),
       msg=caml_call3(Stdlib_Printf[4],_aL_,loc,undefined$0);
      return of_sexp_error(msg,sexp)}
    function record_list_instead_atom(loc,sexp)
     {var msg=caml_call2(Stdlib[28],loc,cst_of_sexp_list_instead_of_at);
      return of_sexp_error(msg,sexp)}
    function record_poly_field_value(loc,sexp)
     {var msg=caml_call2(Stdlib[28],loc,cst_of_sexp_cannot_convert_val);
      return of_sexp_error(msg,sexp)}
    var
     No_variant_match=
      [248,cst_Sexplib0_Sexp_conv_error_N,caml_fresh_oo_id(0)];
    function no_variant_match(param){throw No_variant_match}
    function no_matching_variant_found(loc,sexp)
     {return of_sexp_error
              (caml_call2(Stdlib[28],loc,cst_of_sexp_no_matching_varian),sexp)}
    function ptag_no_args(loc,sexp)
     {return of_sexp_error
              (caml_call2(Stdlib[28],loc,cst_of_sexp_polymorphic_varian),sexp)}
    function ptag_incorrect_n_args(loc,cnstr,sexp)
     {var msg=caml_call3(Stdlib_Printf[4],_aM_,loc,cnstr);
      return of_sexp_error(msg,sexp)}
    function ptag_takes_args(loc,sexp)
     {return of_sexp_error
              (caml_call2(Stdlib[28],loc,cst_of_sexp_polymorphic_varian$0),
               sexp)}
    function nested_list_invalid_poly_var(loc,sexp)
     {return of_sexp_error
              (caml_call2(Stdlib[28],loc,cst_of_sexp_a_nested_list_is_a),sexp)}
    function empty_list_invalid_poly_var(loc,sexp)
     {return of_sexp_error
              (caml_call2(Stdlib[28],loc,cst_of_sexp_the_empty_list_is_),sexp)}
    function empty_type(loc,sexp)
     {return of_sexp_error
              (caml_call2(Stdlib[28],loc,cst_of_sexp_trying_to_convert_),sexp)}
    var
     Sexplib0_Sexp_conv_error=
      [0,
       Of_sexp_error,
       tuple_of_size_n_expected,
       stag_no_args,
       stag_incorrect_n_args,
       stag_takes_args,
       nested_list_invalid_sum,
       empty_list_invalid_sum,
       unexpected_stag,
       record_sexp_bool_with_payload,
       record_only_pairs_expected,
       record_superfluous_fields,
       record_duplicate_fields,
       record_extra_fields,
       record_get_undefined_loop,
       record_undefined_elements,
       record_list_instead_atom,
       record_poly_field_value,
       No_variant_match,
       no_variant_match,
       no_matching_variant_found,
       ptag_no_args,
       ptag_incorrect_n_args,
       ptag_takes_args,
       nested_list_invalid_poly_var,
       empty_list_invalid_poly_var,
       empty_type];
    caml_register_global
     (171,Sexplib0_Sexp_conv_error,"Sexplib0__Sexp_conv_error");
    var Sexplib0_Sexpable=[0];
    caml_register_global(172,Sexplib0_Sexpable,"Sexplib0__Sexpable");
    var Sexplib0$0=[0];
    caml_register_global(173,Sexplib0$0,"Sexplib0");
    return}
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJzZXhwbGliMC5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsiZG9jX2NvbW1lbnRfdGFnIiwic2V4cF9vZl90IiwidCIsInRfb2Zfc2V4cCIsImNvbXBhcmUiLCJhJDAiLCJiJDAiLCJiJDEiLCJiJDIiLCJhIiwiYiIsInlzIiwieSIsInhzIiwieCIsInJlcyIsImVxdWFsIiwiZGVmYXVsdF9pbmRlbnQiLCJtdXN0X2VzY2FwZSIsInN0ciIsImxlbiIsIml4JDMiLCJpeCIsIml4JDAiLCJpeCQyIiwiaXgkMSIsImVzY2FwZWQiLCJzIiwibiIsImkkMCIsInMkMCIsImkiLCJjIiwiZXNjX3N0ciIsInNyYyIsImRzdCIsImluZGV4X29mX25ld2xpbmUiLCJzdGFydCIsIm1hY2hfbWF5YmVfZXNjX3N0ciIsInBwX2h1bV9pbmRlbnQiLCJpbmRlbnQiLCJwcGYiLCJpbmRleCIsImluZGV4JDAiLCJlbmRfcG9zX29wdCIsImVuZF9wb3MiLCJlbmRfcG9zJDAiLCJuZXh0X2xpbmUiLCJuZXdsaW5lX2luZGV4IiwiaW5kZXgkMSIsImgiLCJ0JDAiLCJoJDAiLCJwcF9tYWNoX2ludGVybmFsIiwibWF5X25lZWRfc3BhY2UiLCJzdHIkMCIsIm5ld19tYXlfbmVlZF9zcGFjZSIsIm5ld19tYXlfbmVlZF9zcGFjZSQwIiwibWF5X25lZWRfc3BhY2UkMCIsIm1heV9uZWVkX3NwYWNlJDIiLCJwcF9odW0iLCJzZXhwIiwicHAiLCJzaXplX2xvb3AiLCJhY2MiLCJsc3QiLCJzaXplIiwidG9fYnVmZmVyX2h1bSIsImJ1ZiIsIm9wdCIsInN0aCIsInRvX2J1ZmZlciIsImxvb3AiLCJ0b19idWZmZXJfZ2VuIiwiYWRkX2NoYXIiLCJhZGRfc3RyaW5nIiwiYnVmZmVyIiwidG9fc3RyaW5nX2h1bSIsInRvX3N0cmluZyIsIm9mX2Zsb2F0X3N0eWxlIiwib2ZfaW50X3N0eWxlIiwibWVzc2FnZSIsIm5hbWUiLCJmaWVsZHMiLCJjb252X2ZpZWxkcyIsInJlc3QiLCJmc2V4cCIsImZuYW1lIiwiY29lcmNlIiwiZ3JhbW1hciIsInBhcmFtIiwiZGVmYXVsdF9zdHJpbmdfb2ZfZmxvYXQiLCJyZWFkX29sZF9vcHRpb25fZm9ybWF0Iiwid3JpdGVfb2xkX29wdGlvbl9mb3JtYXQiLCJsaXN0X21hcCIsImYiLCJsIiwic2V4cF9vZl91bml0Iiwic2V4cF9vZl9ib29sIiwic2V4cF9vZl9zdHJpbmciLCJzZXhwX29mX2J5dGVzIiwiYnl0ZXMiLCJzZXhwX29mX2NoYXIiLCJzZXhwX29mX2ludCIsInNleHBfb2ZfZmxvYXQiLCJzZXhwX29mX2ludDMyIiwic2V4cF9vZl9pbnQ2NCIsInNleHBfb2ZfbmF0aXZlaW50Iiwic2V4cF9vZl9yZWYiLCJzZXhwX29mX2EiLCJyZiIsInNleHBfb2ZfbGF6eV90IiwibHYiLCJzZXhwX29mX29wdGlvbiIsInNleHBfb2ZfcGFpciIsInNleHBfb2ZfYiIsInNleHBfb2ZfdHJpcGxlIiwic2V4cF9vZl9jIiwic2V4cF9vZl9saXN0Iiwic2V4cF9vZl9hcnJheSIsImFyIiwibHN0X3JlZiIsInNleHBfb2ZfaGFzaHRibCIsInNleHBfb2Zfa2V5Iiwic2V4cF9vZl92YWwiLCJodGJsIiwiY29sbCIsImsiLCJ2Iiwic2V4cF9vZl9vcGFxdWUiLCJzZXhwX29mX2Z1biIsImVxdWFsJDAiLCJoYXNoIiwidGhlX2V4bl90YWJsZSIsImFkZCIsImV4dGVuc2lvbl9jb25zdHJ1Y3RvciIsInNleHBfb2ZfZXhuIiwicHJpbnRleGMiLCJmaW5kX2F1dG8iLCJmb3JfcHJpbnRleGMiLCJleG4iLCJzaXplJDAiLCJzZXhwX29mX2V4bl9vcHQiLCJleG5fdG9fc3RyaW5nIiwiZSIsInByaW50ZXhjX3ByZWZlcl9zZXhwIiwicmVjb3JkX2NoZWNrX2V4dHJhX2ZpZWxkcyIsIm9mX3NleHBfZXJyb3JfZXhuIiwiZXhjIiwib2Zfc2V4cF9lcnJvciIsIndoYXQiLCJ1bml0X29mX3NleHAiLCJib29sX29mX3NleHAiLCJzdHJpbmdfb2Zfc2V4cCIsImJ5dGVzX29mX3NleHAiLCJjaGFyX29mX3NleHAiLCJpbnRfb2Zfc2V4cCIsImZsb2F0X29mX3NleHAiLCJpbnQzMl9vZl9zZXhwIiwiaW50NjRfb2Zfc2V4cCIsIm5hdGl2ZWludF9vZl9zZXhwIiwicmVmX29mX3NleHAiLCJhX29mX3NleHAiLCJsYXp5X3Rfb2Zfc2V4cCIsIm9wdGlvbl9vZl9zZXhwIiwiZWwkMCIsImVsIiwicGFpcl9vZl9zZXhwIiwiYl9vZl9zZXhwIiwiYl9zZXhwIiwiYV9zZXhwIiwidHJpcGxlX29mX3NleHAiLCJjX29mX3NleHAiLCJjX3NleHAiLCJsaXN0X29mX3NleHAiLCJyZXZfbHN0IiwiYXJyYXlfb2Zfc2V4cCIsImhhc2h0Ymxfb2Zfc2V4cCIsImtleV9vZl9zZXhwIiwidmFsX29mX3NleHAiLCJhY3QiLCJ2X3NleHAiLCJrX3NleHAiLCJvcGFxdWVfb2Zfc2V4cCIsImZ1bl9vZl9zZXhwIiwiZ2V0X2ZsY19lcnJvciIsImNociIsImxpbmUiLCJmaWxlIiwiYXJnIiwiaGFuZGxlciIsInR1cGxlX29mX3NpemVfbl9leHBlY3RlZCIsImxvYyIsInN0YWdfbm9fYXJncyIsInN0YWdfaW5jb3JyZWN0X25fYXJncyIsInRhZyIsIm1zZyIsInN0YWdfdGFrZXNfYXJncyIsIm5lc3RlZF9saXN0X2ludmFsaWRfc3VtIiwiZW1wdHlfbGlzdF9pbnZhbGlkX3N1bSIsInVuZXhwZWN0ZWRfc3RhZyIsInJlY29yZF9zZXhwX2Jvb2xfd2l0aF9wYXlsb2FkIiwicmVjb3JkX29ubHlfcGFpcnNfZXhwZWN0ZWQiLCJyZWNvcmRfc3VwZXJmbHVvdXNfZmllbGRzIiwicmV2X2ZsZF9uYW1lcyIsImZsZF9uYW1lc19zdHIiLCJyZWNvcmRfZHVwbGljYXRlX2ZpZWxkcyIsInJlY29yZF9leHRyYV9maWVsZHMiLCJyZWNvcmRfZ2V0X3VuZGVmaW5lZF9sb29wIiwicGFyYW0kMSIsImZpZWxkIiwicGFyYW0kMiIsInJlY29yZF91bmRlZmluZWRfZWxlbWVudHMiLCJ1bmRlZmluZWQkMCIsInJlY29yZF9saXN0X2luc3RlYWRfYXRvbSIsInJlY29yZF9wb2x5X2ZpZWxkX3ZhbHVlIiwibm9fdmFyaWFudF9tYXRjaCIsIm5vX21hdGNoaW5nX3ZhcmlhbnRfZm91bmQiLCJwdGFnX25vX2FyZ3MiLCJwdGFnX2luY29ycmVjdF9uX2FyZ3MiLCJjbnN0ciIsInB0YWdfdGFrZXNfYXJncyIsIm5lc3RlZF9saXN0X2ludmFsaWRfcG9seV92YXIiLCJlbXB0eV9saXN0X2ludmFsaWRfcG9seV92YXIiLCJlbXB0eV90eXBlIl0sInNvdXJjZXMiOlsiL1VzZXJzL2F6YXQvLm9wYW0vNC4xNC4wL2xpYi9zZXhwbGliMC9zZXhwX2dyYW1tYXIubWwiLCIvVXNlcnMvYXphdC8ub3BhbS80LjE0LjAvbGliL3NleHBsaWIwL3NleHAubWwiLCIvVXNlcnMvYXphdC8ub3BhbS80LjE0LjAvbGliL3NleHBsaWIwL3NleHBfY29udl9ncmFtbWFyLm1sIiwiL1VzZXJzL2F6YXQvLm9wYW0vNC4xNC4wL2xpYi9zZXhwbGliMC9zZXhwX2NvbnYubWwiLCIvVXNlcnMvYXphdC8ub3BhbS80LjE0LjAvbGliL3NleHBsaWIwL3NleHBfY29udl9lcnJvci5tbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7STs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0E4TElBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2FDL0tBQyxVQUFVQyxHQUFJLE9BQUpBLENBQUs7YUFDZkMsVUFBVUQsR0FBSSxPQUFKQSxD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QUtBRztPQUlBQztPQUlBQztPQUlBQztPQU1BQztPQU9BQztPQVNBQztPQU1BRztPQUlBQztPQUlJQztPQU1KSTtPQVFBRTtPQUtBQzs7T0FZQUM7T0FFQUM7T0FJQUM7T0FJQUM7T0FVQUU7T0FJQUM7T0FJQUM7T0FJQUM7Ozs7Ozs7VSIsInNvdXJjZXNDb250ZW50IjpbIigqKiBSZXByZXNlbnRhdGlvbiBvZiBTLWV4cHJlc3Npb24gZ3JhbW1hcnMgKilcblxuKCoqIFRoaXMgbW9kdWxlIGRlZmluZXMgYSByZXByZXNlbnRhdGlvbiBmb3Igcy1leHByZXNzaW9uIGdyYW1tYXJzLiBVc2luZyBwcHhfc2V4cF9jb252XG4gICAgYW5kIFtbQEBkZXJpdmluZyBzZXhwX2dyYW1tYXJdXSBwcm9kdWNlcyBhIGdyYW1tYXIgdGhhdCBpcyBjb21wYXRpYmxlIHdpdGggdGhlIGRlcml2ZWRcbiAgICBbb2Zfc2V4cF0gZm9yIGEgZ2l2ZW4gdHlwZS5cblxuICAgIEFzIHdpdGggb3RoZXIgZGVyaXZlZCBkZWZpbml0aW9ucywgcG9seW1vcnBoaWMgdHlwZXMgZGVyaXZlIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhXG4gICAgZ3JhbW1hciBmb3IgZWFjaCB0eXBlIGFyZ3VtZW50IGFuZCBwcm9kdWNlcyBhIGdyYW1tYXIgZm9yIHRoZSBtb25vbW9ycGhpemVkIHR5cGUuXG5cbiAgICBNb25vbW9ycGhpYyB0eXBlcyBkZXJpdmUgYSBncmFtbWFyIGRpcmVjdGx5LiBUbyBhdm9pZCB0b3AtbGV2ZWwgc2lkZSBlZmZlY3RzLFxuICAgIFtbQEBkZXJpdmluZyBzZXhwX2dyYW1tYXJdXSB3cmFwcyBncmFtbWFycyBpbiB0aGUgW0xhenldIGNvbnN0cnVjdG9yIGFzIG5lZWRlZC5cblxuICAgIFRoaXMgdHlwZSBtYXkgY2hhbmdlIG92ZXIgdGltZSBhcyBvdXIgbmVlZHMgZm9yIGV4cHJlc3NpdmUgZ3JhbW1hcnMgY2hhbmdlLiBXZSB3aWxsXG4gICAgYXR0ZW1wdCB0byBtYWtlIGNoYW5nZXMgYmFja3dhcmQtY29tcGF0aWJsZSwgb3IgYXQgbGVhc3QgcHJvdmlkZSBhIHJlYXNvbmFibGUgdXBncmFkZVxuICAgIHBhdGguICopXG5cbltAQEB3YXJuaW5nIFwiLTMwXCJdICgqIGFsbG93IGR1cGxpY2F0ZSBmaWVsZCBuYW1lcyAqKVxuXG4oKiogR3JhbW1hciBvZiBhIHNleHAuICopXG50eXBlIGdyYW1tYXIgPVxuICB8IEFueSBvZiBzdHJpbmcgKCoqIGFjY2VwdHMgYW55IHNleHA7IHN0cmluZyBpcyBhIHR5cGUgbmFtZSBmb3IgaHVtYW4gcmVhZGFiaWxpdHkgKilcbiAgfCBCb29sICgqKiBhY2NlcHRzIHRoZSBhdG9tcyBcInRydWVcIiBvciBcImZhbHNlXCIsIG1vZHVsbyBjYXBpdGFsaXphdGlvbiAqKVxuICB8IENoYXIgKCoqIGFjY2VwdHMgYW55IHNpbmdsZS1jaGFyYWN0ZXIgYXRvbSAqKVxuICB8IEludGVnZXIgKCoqIGFjY2VwdHMgYW55IGF0b20gbWF0Y2hpbmcgb2NhbWwgaW50ZWdlciBzeW50YXgsIHJlZ2FyZGxlc3Mgb2YgYml0IHdpZHRoICopXG4gIHwgRmxvYXQgKCoqIGFjY2VwdHMgYW55IGF0b20gbWF0Y2hpbmcgb2NhbWwgZmxvYXQgc3ludGF4ICopXG4gIHwgU3RyaW5nICgqKiBhY2NlcHRzIGFueSBhdG9tICopXG4gIHwgT3B0aW9uIG9mIGdyYW1tYXIgKCoqIGFjY2VwdHMgYW4gb3B0aW9uLCBib3RoIFtOb25lXSB2cyBbU29tZSBfXSBhbmQgWygpXSB2cyBbKF8pXS4gKilcbiAgfCBMaXN0IG9mIGxpc3RfZ3JhbW1hciAoKiogYWNjZXB0cyBhIGxpc3QgKilcbiAgfCBWYXJpYW50IG9mIHZhcmlhbnQgKCoqIGFjY2VwdHMgY2xhdXNlcyBrZXllZCBieSBhIGxlYWRpbmcgb3Igc29sZSBhdG9tICopXG4gIHwgVW5pb24gb2YgZ3JhbW1hciBsaXN0ICgqKiBhY2NlcHRzIGEgc2V4cCBpZiBhbnkgb2YgdGhlIGxpc3RlZCBncmFtbWFycyBhY2NlcHRzIGl0ICopXG4gIHwgVGFnZ2VkIG9mIGdyYW1tYXIgd2l0aF90YWdcbiAgKCoqIGFubm90YXRlcyBhIGdyYW1tYXIgd2l0aCBhIGNsaWVudC1zcGVjaWZpYyBrZXkvdmFsdWUgcGFpciAqKVxuICB8IFR5dmFyIG9mIHN0cmluZ1xuICAoKiogTmFtZSBvZiBhIHR5cGUgdmFyaWFibGUsIGUuZy4gW1R5dmFyIFwiYVwiXSBmb3IgWydhXS4gT25seSBtZWFuaW5nZnVsIHdoZW4gdGhlIGJvZHkgb2ZcbiAgICAgIHRoZSBpbm5lcm1vc3QgZW5jbG9zaW5nIFtkZWZuXSBkZWZpbmVzIGEgY29ycmVzcG9uZGluZyB0eXBlIHZhcmlhYmxlLiAqKVxuICB8IFR5Y29uIG9mIHN0cmluZyAqIGdyYW1tYXIgbGlzdFxuICAoKiogVHlwZSBjb25zdHJ1Y3RvciBhcHBsaWVkIHRvIGFyZ3VtZW50cy4gRm9yIGV4YW1wbGUsIFtUeWNvbiAoXCJsaXN0XCIsIFsgSW50ZWdlciBdKV1cbiAgICAgIHJlcHJlc2VudHMgW2ludCBsaXN0XS4gT25seSBtZWFuaW5nZnVsIHdoZW4gdGhlIGlubmVybW9zdCBlbmNsb3NpbmcgW1JlY3Vyc2l2ZV1cbiAgICAgIGdyYW1tYXIgZGVmaW5lcyBhIGNvcnJlc3BvbmRpbmcgdHlwZSBjb25zdHJ1Y3Rvci4gKilcbiAgfCBSZWN1cnNpdmUgb2YgZ3JhbW1hciAqIGRlZm4gbGlzdFxuICAoKiogW1JlY3Vyc2l2ZSAoZ3JhbW1hciwgZGVmaW5pdGlvbnMpXSBhbGxvd3MgW2dyYW1tYXJdIHRvIHJlZmVyIHRvIHR5cGUgY29uc3RydWN0b3JzXG4gICAgICBmcm9tIHRoZSBtdXR1YWxseSByZWN1cnNpdmUgW2RlZmluaXRpb25zXS4gVGhlIGRlZmluaXRpb25zIG1heSBhbHNvIHJlZmVyIHRvIGVhY2hcbiAgICAgIG90aGVycycgdHlwZSBjb25zdHJ1Y3RvcnMuXG5cbiAgICAgIE9yZGluYXJpbHksIFtncmFtbWFyXSBpdHNlbGYgaXMganVzdCBhIFtUeWNvbl0gYXJndW1lbnQsIGFsdGhvdWdoIHRlY2huaWNhbGx5IGl0IGNhblxuICAgICAgYmUgYW55IGdyYW1tYXIuXG5cbiAgICAgIEZvciBleGFtcGxlLCB0aGUgZm9sbG93aW5nIGRlZmluaXRpb25zIGRlZmluZSBhIGJpbmFyeSB0cmVlIHBhcmFtZXRlcml6ZWQgYnkgYSB0eXBlXG4gICAgICBzdG9yZWQgYXQgaXRzIGxlYXZlcy5cblxuICAgICAge1tcbiAgICAgICAgbGV0IGRlZm5zID1cbiAgICAgICAgICBbIHsgdHljb24gPSBcInRyZWVcIlxuICAgICAgICAgICAgOyB0eXZhcnMgPSBbXCJhXCJdXG4gICAgICAgICAgICA7IGdyYW1tYXIgPVxuICAgICAgICAgICAgICAgIFZhcmlhbnRcbiAgICAgICAgICAgICAgICAgIHsgbmFtZV9raW5kID0gQ2FwaXRhbGl6ZWRcbiAgICAgICAgICAgICAgICAgIDsgY2xhdXNlcyA9XG4gICAgICAgICAgICAgICAgICAgICAgWyB7IG5hbWUgPSBcIk5vZGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgOyBhcmdzID0gQ29ucyAoVHljb24gKFwibm9kZVwiLCBbVHl2YXIgXCJhXCJdKSwgRW1wdHkpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgOyB7IG5hbWUgPSBcIlRyZWVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgOyBhcmdzID0gQ29ucyAoVHljb24gKFwibGVhZlwiLCBbVHl2YXIgXCJhXCJdKSwgRW1wdHkpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIDsgeyB0eWNvbiA9IFwibm9kZVwiXG4gICAgICAgICAgICA7IHR5dmFycyA9IFtcImFcIl1cbiAgICAgICAgICAgIDsgZ3JhbW1hciA9IExpc3QgKE1hbnkgKFR5Y29uIFwidHJlZVwiLCBbVHl2YXIgXCJhXCJdKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICA7IHsgdHljb24gPSBcImxlYWZcIlxuICAgICAgICAgICAgOyB0eXZhcnMgPSBbXCJhXCJdXG4gICAgICAgICAgICA7IGdyYW1tYXIgPSBbVHl2YXIgXCJhXCJdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXVxuICAgICAgICA7O1xuICAgICAgXX1cblxuICAgICAgTm9ybWFsbHksIHRoZSB0eXBlIG9mIGEgdHJlZSBzdG9yaW5nIGludGVnZXJzIHdvdWxkIGJlIHdyaXR0ZW4gbGlrZSB0aGlzOlxuXG4gICAgICB7W1xuICAgICAgICBSZWN1cnNpdmUgKFR5Y29uIChcInRyZWVcIiwgWyBJbnRlZ2VyIF0pLCBkZWZucylcbiAgICAgIF19XG5cbiAgICAgIEl0IGlzIGVxdWl2YWxlbnQsIHRob3VnaCBuZWVkbGVzc2x5IHZlcmJvc2UsIHRvIHJlcGxhY2UgdGhlIFtUeWNvbl0gcmVmZXJlbmNlIHdpdGhcbiAgICAgIHRoZSBncmFtbWFyIG9mIFtcInRyZWVcIl0sIHN1YnN0aXR1dGluZyBbSW50ZWdlcl0gZm9yIFtUeXZhciBcImFcIl06XG5cbiAgICAgIHtbXG4gICAgICAgIFJlY3Vyc2l2ZVxuICAgICAgICAgICggVmFyaWFudFxuICAgICAgICAgICAgICB7IG5hbWVfa2luZCA9IENhcGl0YWxpemVkXG4gICAgICAgICAgICAgIDsgY2xhdXNlcyA9XG4gICAgICAgICAgICAgICAgICBbIHsgbmFtZSA9IFwiTm9kZVwiXG4gICAgICAgICAgICAgICAgICAgIDsgYXJncyA9IENvbnMgKFR5Y29uIChcIm5vZGVcIiwgW1R5dmFyIFwiYVwiXSksIEVtcHR5KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICA7IHsgbmFtZSA9IFwiVHJlZVwiXG4gICAgICAgICAgICAgICAgICAgIDsgYXJncyA9IENvbnMgKFR5Y29uIChcImxlYWZcIiwgW1R5dmFyIFwiYVwiXSksIEVtcHR5KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAsIGRlZm5zIClcbiAgICAgIF19XG4gICopXG4gIHwgTGF6eSBvZiBncmFtbWFyIGxhenlfdFxuICAoKiogTGF6aWx5IGNvbXB1dGVkIGdyYW1tYXIuIFVzZSBbTGF6eV0gdG8gYXZvaWQgdG9wLWxldmVsIHNpZGUgZWZmZWN0cy4gVG8gZGVmaW5lXG4gICAgICByZWN1cnNpdmUgZ3JhbW1hcnMsIHVzZSBbUmVjdXJzaXZlXSBpbnN0ZWFkLiAqKVxuXG4oKiogR3JhbW1hciBvZiBhIGxpc3Qgb2Ygc2V4cHMuICopXG5hbmQgbGlzdF9ncmFtbWFyID1cbiAgfCBFbXB0eSAoKiogYWNjZXB0cyBhbiBlbXB0eSBsaXN0IG9mIHNleHBzICopXG4gIHwgQ29ucyBvZiBncmFtbWFyICogbGlzdF9ncmFtbWFyXG4gICgqKiBhY2NlcHRzIGEgbm9uLWVtcHR5IGxpc3Qgd2l0aCBoZWFkIGFuZCB0YWlsIG1hdGNoaW5nIHRoZSBnaXZlbiBncmFtbWFycyAqKVxuICB8IE1hbnkgb2YgZ3JhbW1hciAoKiogYWNjZXB0cyB6ZXJvIG9yIG1vcmUgc2V4cHMsIGVhY2ggbWF0Y2hpbmcgdGhlIGdpdmVuIGdyYW1tYXIgKilcbiAgfCBGaWVsZHMgb2YgcmVjb3JkICgqKiBhY2NlcHRzIHNleHBzIHJlcHJlc2VudGluZyBmaWVsZHMgb2YgYSByZWNvcmQgKilcblxuKCoqIENhc2Ugc2Vuc2l0aXZpdHkgb3B0aW9ucyBmb3IgbmFtZXMgb2YgdmFyaWFudCBjb25zdHJ1Y3RvcnMuICopXG5hbmQgY2FzZV9zZW5zaXRpdml0eSA9XG4gIHwgQ2FzZV9pbnNlbnNpdGl2ZSAoKiogQ29tcGFyaXNvbiBpcyBjYXNlIGluc2Vuc2l0aXZlLiBVc2VkIGZvciBjdXN0b20gcGFyc2Vycy4gKilcbiAgfCBDYXNlX3NlbnNpdGl2ZSAoKiogQ29tcGFyaXNvbiBpcyBjYXNlIHNlbnNpdGl2ZS4gVXNlZCBmb3IgcG9seW1vcnBoaWMgdmFyaWFudHMuICopXG4gIHwgQ2FzZV9zZW5zaXRpdmVfZXhjZXB0X2ZpcnN0X2NoYXJhY3RlclxuICAoKiogQ29tcGFyaXNvbiBpcyBjYXNlIGluc2Vuc2l0aXZlIGZvciB0aGUgZmlyc3QgY2hhcmFjdGVyIGFuZCBjYXNlIHNlbnNpdGl2ZSBhZnRlcndhcmQuXG4gICAgICBVc2VkIGZvciByZWd1bGFyIHZhcmlhbnRzLiAqKVxuXG4oKiogR3JhbW1hciBvZiB2YXJpYW50cy4gQWNjZXB0cyBhbnkgc2V4cCBtYXRjaGluZyBvbmUgb2YgdGhlIGNsYXVzZXMuICopXG5hbmQgdmFyaWFudCA9XG4gIHsgY2FzZV9zZW5zaXRpdml0eSA6IGNhc2Vfc2Vuc2l0aXZpdHlcbiAgOyBjbGF1c2VzIDogY2xhdXNlIHdpdGhfdGFnX2xpc3QgbGlzdFxuICB9XG5cbigqKiBHcmFtbWFyIG9mIGEgc2luZ2xlIHZhcmlhbnQgY2xhdXNlLiBBY2NlcHRzIHNleHBzIGJhc2VkIG9uIHRoZSBbY2xhdXNlX2tpbmRdLiAqKVxuYW5kIGNsYXVzZSA9XG4gIHsgbmFtZSA6IHN0cmluZ1xuICA7IGNsYXVzZV9raW5kIDogY2xhdXNlX2tpbmRcbiAgfVxuXG4oKiogR3JhbW1hciBvZiBhIHNpbmdsZSB2YXJpYW50IGNsYXVzZSdzIGNvbnRlbnRzLiBbQXRvbV9jbGF1c2VdIGFjY2VwdHMgYW4gYXRvbSBtYXRjaGluZ1xuICAgIHRoZSBjbGF1c2UncyBuYW1lLiBbTGlzdF9jbGF1c2VdIGFjY2VwdHMgYSBsaXN0IHdob3NlIGhlYWQgaXMgYW4gYXRvbSBtYXRjaGluZyB0aGVcbiAgICBjbGF1c2UncyBuYW1lIGFuZCB3aG9zZSB0YWlsIG1hdGNoZXMgW2FyZ3NdLiBUaGUgY2xhdXNlJ3MgbmFtZSBpcyBtYXRjaGVkIG1vZHVsbyB0aGVcbiAgICB2YXJpYW50J3MgW25hbWVfa2luZF0uICopXG5hbmQgY2xhdXNlX2tpbmQgPVxuICB8IEF0b21fY2xhdXNlXG4gIHwgTGlzdF9jbGF1c2Ugb2YgeyBhcmdzIDogbGlzdF9ncmFtbWFyIH1cblxuKCoqIEdyYW1tYXIgb2YgYSByZWNvcmQuIEFjY2VwdHMgYW55IGxpc3Qgb2Ygc2V4cHMgc3BlY2lmeWluZyBlYWNoIG9mIHRoZSBmaWVsZHMsXG4gICAgcmVnYXJkbGVzcyBvZiBvcmRlci4gSWYgW2FsbG93X2V4dHJhX2ZpZWxkc10gaXMgc3BlY2lmaWVkLCBpZ25vcmVzIHNleHBzIHdpdGggbmFtZXNcbiAgICBub3QgZm91bmQgaW4gW2ZpZWxkc10uICopXG5hbmQgcmVjb3JkID1cbiAgeyBhbGxvd19leHRyYV9maWVsZHMgOiBib29sXG4gIDsgZmllbGRzIDogZmllbGQgd2l0aF90YWdfbGlzdCBsaXN0XG4gIH1cblxuKCoqIEdyYW1tYXIgb2YgYSByZWNvcmQgZmllbGQuIEEgZmllbGQgbXVzdCBzaG93IHVwIGV4YWN0bHkgb25jZSBpbiBhIHJlY29yZCBpZlxuICAgIFtyZXF1aXJlZF0sIG9yIGF0IG1vc3Qgb25jZSBvdGhlcndpc2UuIEFjY2VwdHMgYSBsaXN0IGhlYWRlZCBieSBbbmFtZV0gYXMgYW4gYXRvbSxcbiAgICBmb2xsb3dlZCBieSBzZXhwcyBtYXRjaGluZyBbYXJnc10uICopXG5hbmQgZmllbGQgPVxuICB7IG5hbWUgOiBzdHJpbmdcbiAgOyByZXF1aXJlZCA6IGJvb2xcbiAgOyBhcmdzIDogbGlzdF9ncmFtbWFyXG4gIH1cblxuKCoqIEdyYW1tYXIgdGFnZ2VkIHdpdGggY2xpZW50LXNwZWNpZmljIGtleS92YWx1ZSBwYWlyLiAqKVxuYW5kICdhIHdpdGhfdGFnID1cbiAgeyBrZXkgOiBzdHJpbmdcbiAgOyB2YWx1ZSA6IFNleHAudFxuICA7IGdyYW1tYXIgOiAnYVxuICB9XG5cbmFuZCAnYSB3aXRoX3RhZ19saXN0ID1cbiAgfCBUYWcgb2YgJ2Egd2l0aF90YWdfbGlzdCB3aXRoX3RhZ1xuICB8IE5vX3RhZyBvZiAnYVxuXG4oKiogR3JhbW1hciBvZiBhIHJlY3Vyc2l2ZSB0eXBlIGRlZmluaXRpb24uIE5hbWVzIHRoZSBbdHljb25dIGJlaW5nIGRlZmluZWQsIGFuZCB0aGVcbiAgICBbdHl2YXJzXSBpdCB0YWtlcyBhcyBwYXJhbWV0ZXJzLiBTcGVjaWZpZXMgdGhlIFtncmFtbWFyXSBvZiB0aGUgW3R5Y29uXS4gVGhlIGdyYW1tYXJcbiAgICBtYXkgcmVmZXIgdG8gYW55IG9mIHRoZSBbdHl2YXJzXSwgYW5kIHRvIGFueSBvZiB0aGUgW3R5Y29uXXMgZnJvbSB0aGUgc2FtZSBzZXQgb2ZcbiAgICBbUmVjdXJzaXZlXSBkZWZpbml0aW9ucy4gKilcbmFuZCBkZWZuID1cbiAgeyB0eWNvbiA6IHN0cmluZ1xuICA7IHR5dmFycyA6IHN0cmluZyBsaXN0XG4gIDsgZ3JhbW1hciA6IGdyYW1tYXJcbiAgfVxuXG4oKiogVG9wLWxldmVsIGdyYW1tYXIgdHlwZS4gSGFzIGEgcGhhbnRvbSB0eXBlIHBhcmFtZXRlciB0byBhc3NvY2lhdGUgZWFjaCBncmFtbWFyIHdpdGhcbiAgICB0aGUgdHlwZSBpdHMgc2V4cHMgcmVwcmVzZW50LiBUaGlzIG1ha2VzIGl0IGhhcmRlciB0byBhcHBseSBncmFtbWFycyB0byB0aGUgd3JvbmdcbiAgICB0eXBlLCB3aGlsZSBncmFtbWFycyBjYW4gc3RpbGwgYmUgZWFzaWx5IGNvZXJjZWQgdG8gYSBuZXcgdHlwZSBpZiBuZWVkZWQuICopXG50eXBlIF8gdCA9IHsgdW50eXBlZCA6IGdyYW1tYXIgfSBbQEB1bmJveGVkXVxuXG5sZXQgY29lcmNlICh0eXBlIGEgYikgKHsgdW50eXBlZCA9IF8gfSBhcyB0IDogYSB0KSA6IGIgdCA9IHRcblxuKCoqIFRoaXMgcmVzZXJ2ZWQga2V5IGlzIHVzZWQgZm9yIGFsbCB0YWdzIGdlbmVyYXRlZCBmcm9tIGRvYyBjb21tZW50cy4gKilcbmxldCBkb2NfY29tbWVudF90YWcgPSBcInNleHBfZ3JhbW1hci5kb2NfY29tbWVudFwiXG4iLCJbQEBAb2NhbWwud2FybmluZyBcIi0zXCJdXG5cbigqIGJsaXRfc3RyaW5nIGRvZXNuJ3QgZXhpc3QgaW4gW1N0ZExhYmVscy5CeXRlc10uLi4gICopXG5sZXQgYnl0ZXNfYmxpdF9zdHJpbmcgfnNyYyB+c3JjX3BvcyB+ZHN0IH5kc3RfcG9zIH5sZW4gPVxuICBCeXRlcy5ibGl0X3N0cmluZyBzcmMgc3JjX3BvcyBkc3QgZHN0X3BvcyBsZW5cbjs7XG5cbm9wZW4gU3RkTGFiZWxzXG5vcGVuIEZvcm1hdFxuXG4oKiogVHlwZSBvZiBTLWV4cHJlc3Npb25zICopXG50eXBlIHQgPVxuICB8IEF0b20gb2Ygc3RyaW5nXG4gIHwgTGlzdCBvZiB0IGxpc3RcblxubGV0IHNleHBfb2ZfdCB0ID0gdFxubGV0IHRfb2Zfc2V4cCB0ID0gdFxuXG5sZXQgcmVjIGNvbXBhcmVfbGlzdCBhIGIgPVxuICBtYXRjaCBhLCBiIHdpdGhcbiAgfCBbXSwgW10gLT4gMFxuICB8IFtdLCBfIC0+IC0xXG4gIHwgXywgW10gLT4gMVxuICB8IHggOjogeHMsIHkgOjogeXMgLT5cbiAgICBsZXQgcmVzID0gY29tcGFyZSB4IHkgaW5cbiAgICBpZiByZXMgPD4gMCB0aGVuIHJlcyBlbHNlIGNvbXBhcmVfbGlzdCB4cyB5c1xuXG5hbmQgY29tcGFyZSBhIGIgPVxuICBpZiBhID09IGJcbiAgdGhlbiAwXG4gIGVsc2UgKFxuICAgIG1hdGNoIGEsIGIgd2l0aFxuICAgIHwgQXRvbSBhLCBBdG9tIGIgLT4gU3RyaW5nLmNvbXBhcmUgYSBiXG4gICAgfCBBdG9tIF8sIF8gLT4gLTFcbiAgICB8IF8sIEF0b20gXyAtPiAxXG4gICAgfCBMaXN0IGEsIExpc3QgYiAtPiBjb21wYXJlX2xpc3QgYSBiKVxuOztcblxubGV0IGVxdWFsIGEgYiA9IGNvbXBhcmUgYSBiID0gMFxuXG5leGNlcHRpb24gTm90X2ZvdW5kX3Mgb2YgdFxuZXhjZXB0aW9uIE9mX3NleHBfZXJyb3Igb2YgZXhuICogdFxuXG5tb2R1bGUgUHJpbnRpbmcgPSBzdHJ1Y3RcbiAgKCogRGVmYXVsdCBpbmRlbnRhdGlvbiBsZXZlbCBmb3IgaHVtYW4tcmVhZGFibGUgY29udmVyc2lvbnMgKilcblxuICBsZXQgZGVmYXVsdF9pbmRlbnQgPSByZWYgMVxuXG4gICgqIEVzY2FwaW5nIG9mIHN0cmluZ3MgdXNlZCBhcyBhdG9tcyBpbiBTLWV4cHJlc3Npb25zICopXG5cbiAgbGV0IG11c3RfZXNjYXBlIHN0ciA9XG4gICAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gICAgbGVuID0gMFxuICAgIHx8XG4gICAgbGV0IHJlYyBsb29wIHN0ciBpeCA9XG4gICAgICBtYXRjaCBzdHIuW2l4XSB3aXRoXG4gICAgICB8ICdcIicgfCAnKCcgfCAnKScgfCAnOycgfCAnXFxcXCcgLT4gdHJ1ZVxuICAgICAgfCAnfCcgLT5cbiAgICAgICAgaXggPiAwXG4gICAgICAgICYmXG4gICAgICAgIGxldCBuZXh0ID0gaXggLSAxIGluXG4gICAgICAgIENoYXIuZXF1YWwgc3RyLltuZXh0XSAnIycgfHwgbG9vcCBzdHIgbmV4dFxuICAgICAgfCAnIycgLT5cbiAgICAgICAgaXggPiAwXG4gICAgICAgICYmXG4gICAgICAgIGxldCBuZXh0ID0gaXggLSAxIGluXG4gICAgICAgIENoYXIuZXF1YWwgc3RyLltuZXh0XSAnfCcgfHwgbG9vcCBzdHIgbmV4dFxuICAgICAgfCAnXFwwMDAnIC4uICdcXDAzMicgfCAnXFwxMjcnIC4uICdcXDI1NScgLT4gdHJ1ZVxuICAgICAgfCBfIC0+IGl4ID4gMCAmJiBsb29wIHN0ciAoaXggLSAxKVxuICAgIGluXG4gICAgbG9vcCBzdHIgKGxlbiAtIDEpXG4gIDs7XG5cbiAgbGV0IGVzY2FwZWQgcyA9XG4gICAgbGV0IG4gPSByZWYgMCBpblxuICAgIGZvciBpID0gMCB0byBTdHJpbmcubGVuZ3RoIHMgLSAxIGRvXG4gICAgICBuXG4gICAgICA6PSAhblxuICAgICAgICAgK1xuICAgICAgICAgbWF0Y2ggU3RyaW5nLnVuc2FmZV9nZXQgcyBpIHdpdGhcbiAgICAgICAgIHwgJ1xcXCInIHwgJ1xcXFwnIHwgJ1xcbicgfCAnXFx0JyB8ICdcXHInIHwgJ1xcYicgLT4gMlxuICAgICAgICAgfCAnICcgLi4gJ34nIC0+IDFcbiAgICAgICAgIHwgXyAtPiA0XG4gICAgZG9uZTtcbiAgICBpZiAhbiA9IFN0cmluZy5sZW5ndGggc1xuICAgIHRoZW4gc1xuICAgIGVsc2UgKFxuICAgICAgbGV0IHMnID0gQnl0ZXMuY3JlYXRlICFuIGluXG4gICAgICBuIDo9IDA7XG4gICAgICBmb3IgaSA9IDAgdG8gU3RyaW5nLmxlbmd0aCBzIC0gMSBkb1xuICAgICAgICAobWF0Y2ggU3RyaW5nLnVuc2FmZV9nZXQgcyBpIHdpdGhcbiAgICAgICAgIHwgKCdcXFwiJyB8ICdcXFxcJykgYXMgYyAtPlxuICAgICAgICAgICBCeXRlcy51bnNhZmVfc2V0IHMnICFuICdcXFxcJztcbiAgICAgICAgICAgaW5jciBuO1xuICAgICAgICAgICBCeXRlcy51bnNhZmVfc2V0IHMnICFuIGNcbiAgICAgICAgIHwgJ1xcbicgLT5cbiAgICAgICAgICAgQnl0ZXMudW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7XG4gICAgICAgICAgIGluY3IgbjtcbiAgICAgICAgICAgQnl0ZXMudW5zYWZlX3NldCBzJyAhbiAnbidcbiAgICAgICAgIHwgJ1xcdCcgLT5cbiAgICAgICAgICAgQnl0ZXMudW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7XG4gICAgICAgICAgIGluY3IgbjtcbiAgICAgICAgICAgQnl0ZXMudW5zYWZlX3NldCBzJyAhbiAndCdcbiAgICAgICAgIHwgJ1xccicgLT5cbiAgICAgICAgICAgQnl0ZXMudW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7XG4gICAgICAgICAgIGluY3IgbjtcbiAgICAgICAgICAgQnl0ZXMudW5zYWZlX3NldCBzJyAhbiAncidcbiAgICAgICAgIHwgJ1xcYicgLT5cbiAgICAgICAgICAgQnl0ZXMudW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7XG4gICAgICAgICAgIGluY3IgbjtcbiAgICAgICAgICAgQnl0ZXMudW5zYWZlX3NldCBzJyAhbiAnYidcbiAgICAgICAgIHwgJyAnIC4uICd+JyBhcyBjIC0+IEJ5dGVzLnVuc2FmZV9zZXQgcycgIW4gY1xuICAgICAgICAgfCBjIC0+XG4gICAgICAgICAgIGxldCBhID0gQ2hhci5jb2RlIGMgaW5cbiAgICAgICAgICAgQnl0ZXMudW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7XG4gICAgICAgICAgIGluY3IgbjtcbiAgICAgICAgICAgQnl0ZXMudW5zYWZlX3NldCBzJyAhbiAoQ2hhci5jaHIgKDQ4ICsgKGEgLyAxMDApKSk7XG4gICAgICAgICAgIGluY3IgbjtcbiAgICAgICAgICAgQnl0ZXMudW5zYWZlX3NldCBzJyAhbiAoQ2hhci5jaHIgKDQ4ICsgKGEgLyAxMCBtb2QgMTApKSk7XG4gICAgICAgICAgIGluY3IgbjtcbiAgICAgICAgICAgQnl0ZXMudW5zYWZlX3NldCBzJyAhbiAoQ2hhci5jaHIgKDQ4ICsgKGEgbW9kIDEwKSkpKTtcbiAgICAgICAgaW5jciBuXG4gICAgICBkb25lO1xuICAgICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBzJylcbiAgOztcblxuICBsZXQgZXNjX3N0ciBzdHIgPVxuICAgIGxldCBlc3RyID0gZXNjYXBlZCBzdHIgaW5cbiAgICBsZXQgZWxlbiA9IFN0cmluZy5sZW5ndGggZXN0ciBpblxuICAgIGxldCByZXMgPSBCeXRlcy5jcmVhdGUgKGVsZW4gKyAyKSBpblxuICAgIGJ5dGVzX2JsaXRfc3RyaW5nIH5zcmM6ZXN0ciB+c3JjX3BvczowIH5kc3Q6cmVzIH5kc3RfcG9zOjEgfmxlbjplbGVuO1xuICAgIEJ5dGVzLnVuc2FmZV9zZXQgcmVzIDAgJ1wiJztcbiAgICBCeXRlcy51bnNhZmVfc2V0IHJlcyAoZWxlbiArIDEpICdcIic7XG4gICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXNcbiAgOztcblxuICBsZXQgaW5kZXhfb2ZfbmV3bGluZSBzdHIgc3RhcnQgPVxuICAgIHRyeSBTb21lIChTdHJpbmcuaW5kZXhfZnJvbSBzdHIgc3RhcnQgJ1xcbicpIHdpdGhcbiAgICB8IE5vdF9mb3VuZCAtPiBOb25lXG4gIDs7XG5cbiAgbGV0IGdldF9zdWJzdHJpbmcgc3RyIGluZGV4IGVuZF9wb3Nfb3B0ID1cbiAgICBsZXQgZW5kX3BvcyA9XG4gICAgICBtYXRjaCBlbmRfcG9zX29wdCB3aXRoXG4gICAgICB8IE5vbmUgLT4gU3RyaW5nLmxlbmd0aCBzdHJcbiAgICAgIHwgU29tZSBlbmRfcG9zIC0+IGVuZF9wb3NcbiAgICBpblxuICAgIFN0cmluZy5zdWIgc3RyIH5wb3M6aW5kZXggfmxlbjooZW5kX3BvcyAtIGluZGV4KVxuICA7O1xuXG4gIGxldCBpc19vbmVfbGluZSBzdHIgPVxuICAgIG1hdGNoIGluZGV4X29mX25ld2xpbmUgc3RyIDAgd2l0aFxuICAgIHwgTm9uZSAtPiB0cnVlXG4gICAgfCBTb21lIGluZGV4IC0+IGluZGV4ICsgMSA9IFN0cmluZy5sZW5ndGggc3RyXG4gIDs7XG5cbiAgbGV0IHBwX2h1bV9tYXliZV9lc2Nfc3RyIHBwZiBzdHIgPVxuICAgIGlmIG5vdCAobXVzdF9lc2NhcGUgc3RyKVxuICAgIHRoZW4gcHBfcHJpbnRfc3RyaW5nIHBwZiBzdHJcbiAgICBlbHNlIGlmIGlzX29uZV9saW5lIHN0clxuICAgIHRoZW4gcHBfcHJpbnRfc3RyaW5nIHBwZiAoZXNjX3N0ciBzdHIpXG4gICAgZWxzZSAoXG4gICAgICBsZXQgcmVjIGxvb3AgaW5kZXggPVxuICAgICAgICBsZXQgbmV4dF9uZXdsaW5lID0gaW5kZXhfb2ZfbmV3bGluZSBzdHIgaW5kZXggaW5cbiAgICAgICAgbGV0IG5leHRfbGluZSA9IGdldF9zdWJzdHJpbmcgc3RyIGluZGV4IG5leHRfbmV3bGluZSBpblxuICAgICAgICBwcF9wcmludF9zdHJpbmcgcHBmIChlc2NhcGVkIG5leHRfbGluZSk7XG4gICAgICAgIG1hdGNoIG5leHRfbmV3bGluZSB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiAoKVxuICAgICAgICB8IFNvbWUgbmV3bGluZV9pbmRleCAtPlxuICAgICAgICAgIHBwX3ByaW50X3N0cmluZyBwcGYgXCJcXFxcXCI7XG4gICAgICAgICAgcHBfZm9yY2VfbmV3bGluZSBwcGYgKCk7XG4gICAgICAgICAgcHBfcHJpbnRfc3RyaW5nIHBwZiBcIlxcXFxuXCI7XG4gICAgICAgICAgbG9vcCAobmV3bGluZV9pbmRleCArIDEpXG4gICAgICBpblxuICAgICAgcHBfb3Blbl9ib3ggcHBmIDA7XG4gICAgICAoKiB0aGUgbGVhZGluZyBzcGFjZSBpcyB0byBsaW5lIHVwIHRoZSBsaW5lcyAqKVxuICAgICAgcHBfcHJpbnRfc3RyaW5nIHBwZiBcIiBcXFwiXCI7XG4gICAgICBsb29wIDA7XG4gICAgICBwcF9wcmludF9zdHJpbmcgcHBmIFwiXFxcIlwiO1xuICAgICAgcHBfY2xvc2VfYm94IHBwZiAoKSlcbiAgOztcblxuICBsZXQgbWFjaF9tYXliZV9lc2Nfc3RyIHN0ciA9IGlmIG11c3RfZXNjYXBlIHN0ciB0aGVuIGVzY19zdHIgc3RyIGVsc2Ugc3RyXG5cbiAgKCogT3V0cHV0IG9mIFMtZXhwcmVzc2lvbnMgdG8gZm9ybWF0dGVycyAqKVxuXG4gIGxldCByZWMgcHBfaHVtX2luZGVudCBpbmRlbnQgcHBmID0gZnVuY3Rpb25cbiAgICB8IEF0b20gc3RyIC0+IHBwX2h1bV9tYXliZV9lc2Nfc3RyIHBwZiBzdHJcbiAgICB8IExpc3QgKGggOjogdCkgLT5cbiAgICAgIHBwX29wZW5fYm94IHBwZiBpbmRlbnQ7XG4gICAgICBwcF9wcmludF9zdHJpbmcgcHBmIFwiKFwiO1xuICAgICAgcHBfaHVtX2luZGVudCBpbmRlbnQgcHBmIGg7XG4gICAgICBwcF9odW1fcmVzdCBpbmRlbnQgcHBmIHRcbiAgICB8IExpc3QgW10gLT4gcHBfcHJpbnRfc3RyaW5nIHBwZiBcIigpXCJcblxuICBhbmQgcHBfaHVtX3Jlc3QgaW5kZW50IHBwZiA9IGZ1bmN0aW9uXG4gICAgfCBoIDo6IHQgLT5cbiAgICAgIHBwX3ByaW50X3NwYWNlIHBwZiAoKTtcbiAgICAgIHBwX2h1bV9pbmRlbnQgaW5kZW50IHBwZiBoO1xuICAgICAgcHBfaHVtX3Jlc3QgaW5kZW50IHBwZiB0XG4gICAgfCBbXSAtPlxuICAgICAgcHBfcHJpbnRfc3RyaW5nIHBwZiBcIilcIjtcbiAgICAgIHBwX2Nsb3NlX2JveCBwcGYgKClcbiAgOztcblxuICBsZXQgcmVjIHBwX21hY2hfaW50ZXJuYWwgbWF5X25lZWRfc3BhY2UgcHBmID0gZnVuY3Rpb25cbiAgICB8IEF0b20gc3RyIC0+XG4gICAgICBsZXQgc3RyJyA9IG1hY2hfbWF5YmVfZXNjX3N0ciBzdHIgaW5cbiAgICAgIGxldCBuZXdfbWF5X25lZWRfc3BhY2UgPSBzdHInID09IHN0ciBpblxuICAgICAgaWYgbWF5X25lZWRfc3BhY2UgJiYgbmV3X21heV9uZWVkX3NwYWNlIHRoZW4gcHBfcHJpbnRfc3RyaW5nIHBwZiBcIiBcIjtcbiAgICAgIHBwX3ByaW50X3N0cmluZyBwcGYgc3RyJztcbiAgICAgIG5ld19tYXlfbmVlZF9zcGFjZVxuICAgIHwgTGlzdCAoaCA6OiB0KSAtPlxuICAgICAgcHBfcHJpbnRfc3RyaW5nIHBwZiBcIihcIjtcbiAgICAgIGxldCBtYXlfbmVlZF9zcGFjZSA9IHBwX21hY2hfaW50ZXJuYWwgZmFsc2UgcHBmIGggaW5cbiAgICAgIHBwX21hY2hfcmVzdCBtYXlfbmVlZF9zcGFjZSBwcGYgdDtcbiAgICAgIGZhbHNlXG4gICAgfCBMaXN0IFtdIC0+XG4gICAgICBwcF9wcmludF9zdHJpbmcgcHBmIFwiKClcIjtcbiAgICAgIGZhbHNlXG5cbiAgYW5kIHBwX21hY2hfcmVzdCBtYXlfbmVlZF9zcGFjZSBwcGYgPSBmdW5jdGlvblxuICAgIHwgaCA6OiB0IC0+XG4gICAgICBsZXQgbWF5X25lZWRfc3BhY2UgPSBwcF9tYWNoX2ludGVybmFsIG1heV9uZWVkX3NwYWNlIHBwZiBoIGluXG4gICAgICBwcF9tYWNoX3Jlc3QgbWF5X25lZWRfc3BhY2UgcHBmIHRcbiAgICB8IFtdIC0+IHBwX3ByaW50X3N0cmluZyBwcGYgXCIpXCJcbiAgOztcblxuICBsZXQgcHBfaHVtIHBwZiBzZXhwID0gcHBfaHVtX2luZGVudCAhZGVmYXVsdF9pbmRlbnQgcHBmIHNleHBcbiAgbGV0IHBwX21hY2ggcHBmIHNleHAgPSBpZ25vcmUgKHBwX21hY2hfaW50ZXJuYWwgZmFsc2UgcHBmIHNleHApXG4gIGxldCBwcCA9IHBwX21hY2hcblxuICAoKiBTZXhwIHNpemUgKilcblxuICBsZXQgcmVjIHNpemVfbG9vcCAoKHYsIGMpIGFzIGFjYykgPSBmdW5jdGlvblxuICAgIHwgQXRvbSBzdHIgLT4gdiArIDEsIGMgKyBTdHJpbmcubGVuZ3RoIHN0clxuICAgIHwgTGlzdCBsc3QgLT4gTGlzdC5mb2xkX2xlZnQgbHN0IH5pbml0OmFjYyB+ZjpzaXplX2xvb3BcbiAgOztcblxuICBsZXQgc2l6ZSBzZXhwID0gc2l6ZV9sb29wICgwLCAwKSBzZXhwXG5cbiAgKCogQnVmZmVyIGNvbnZlcnNpb25zICopXG5cbiAgbGV0IHRvX2J1ZmZlcl9odW0gfmJ1ZiA/KGluZGVudCA9ICFkZWZhdWx0X2luZGVudCkgc2V4cCA9XG4gICAgbGV0IHBwZiA9IEZvcm1hdC5mb3JtYXR0ZXJfb2ZfYnVmZmVyIGJ1ZiBpblxuICAgIEZvcm1hdC5mcHJpbnRmIHBwZiBcIiVhQD9cIiAocHBfaHVtX2luZGVudCBpbmRlbnQpIHNleHBcbiAgOztcblxuICBsZXQgdG9fYnVmZmVyX21hY2ggfmJ1ZiBzZXhwID1cbiAgICBsZXQgcmVjIGxvb3AgbWF5X25lZWRfc3BhY2UgPSBmdW5jdGlvblxuICAgICAgfCBBdG9tIHN0ciAtPlxuICAgICAgICBsZXQgc3RyJyA9IG1hY2hfbWF5YmVfZXNjX3N0ciBzdHIgaW5cbiAgICAgICAgbGV0IG5ld19tYXlfbmVlZF9zcGFjZSA9IHN0cicgPT0gc3RyIGluXG4gICAgICAgIGlmIG1heV9uZWVkX3NwYWNlICYmIG5ld19tYXlfbmVlZF9zcGFjZSB0aGVuIEJ1ZmZlci5hZGRfY2hhciBidWYgJyAnO1xuICAgICAgICBCdWZmZXIuYWRkX3N0cmluZyBidWYgc3RyJztcbiAgICAgICAgbmV3X21heV9uZWVkX3NwYWNlXG4gICAgICB8IExpc3QgKGggOjogdCkgLT5cbiAgICAgICAgQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnKCc7XG4gICAgICAgIGxldCBtYXlfbmVlZF9zcGFjZSA9IGxvb3AgZmFsc2UgaCBpblxuICAgICAgICBsb29wX3Jlc3QgbWF5X25lZWRfc3BhY2UgdDtcbiAgICAgICAgZmFsc2VcbiAgICAgIHwgTGlzdCBbXSAtPlxuICAgICAgICBCdWZmZXIuYWRkX3N0cmluZyBidWYgXCIoKVwiO1xuICAgICAgICBmYWxzZVxuICAgIGFuZCBsb29wX3Jlc3QgbWF5X25lZWRfc3BhY2UgPSBmdW5jdGlvblxuICAgICAgfCBoIDo6IHQgLT5cbiAgICAgICAgbGV0IG1heV9uZWVkX3NwYWNlID0gbG9vcCBtYXlfbmVlZF9zcGFjZSBoIGluXG4gICAgICAgIGxvb3BfcmVzdCBtYXlfbmVlZF9zcGFjZSB0XG4gICAgICB8IFtdIC0+IEJ1ZmZlci5hZGRfY2hhciBidWYgJyknXG4gICAgaW5cbiAgICBpZ25vcmUgKGxvb3AgZmFsc2Ugc2V4cClcbiAgOztcblxuICBsZXQgdG9fYnVmZmVyID0gdG9fYnVmZmVyX21hY2hcblxuICBsZXQgdG9fYnVmZmVyX2dlbiB+YnVmIH5hZGRfY2hhciB+YWRkX3N0cmluZyBzZXhwID1cbiAgICBsZXQgcmVjIGxvb3AgbWF5X25lZWRfc3BhY2UgPSBmdW5jdGlvblxuICAgICAgfCBBdG9tIHN0ciAtPlxuICAgICAgICBsZXQgc3RyJyA9IG1hY2hfbWF5YmVfZXNjX3N0ciBzdHIgaW5cbiAgICAgICAgbGV0IG5ld19tYXlfbmVlZF9zcGFjZSA9IHN0cicgPT0gc3RyIGluXG4gICAgICAgIGlmIG1heV9uZWVkX3NwYWNlICYmIG5ld19tYXlfbmVlZF9zcGFjZSB0aGVuIGFkZF9jaGFyIGJ1ZiAnICc7XG4gICAgICAgIGFkZF9zdHJpbmcgYnVmIHN0cic7XG4gICAgICAgIG5ld19tYXlfbmVlZF9zcGFjZVxuICAgICAgfCBMaXN0IChoIDo6IHQpIC0+XG4gICAgICAgIGFkZF9jaGFyIGJ1ZiAnKCc7XG4gICAgICAgIGxldCBtYXlfbmVlZF9zcGFjZSA9IGxvb3AgZmFsc2UgaCBpblxuICAgICAgICBsb29wX3Jlc3QgbWF5X25lZWRfc3BhY2UgdDtcbiAgICAgICAgZmFsc2VcbiAgICAgIHwgTGlzdCBbXSAtPlxuICAgICAgICBhZGRfc3RyaW5nIGJ1ZiBcIigpXCI7XG4gICAgICAgIGZhbHNlXG4gICAgYW5kIGxvb3BfcmVzdCBtYXlfbmVlZF9zcGFjZSA9IGZ1bmN0aW9uXG4gICAgICB8IGggOjogdCAtPlxuICAgICAgICBsZXQgbWF5X25lZWRfc3BhY2UgPSBsb29wIG1heV9uZWVkX3NwYWNlIGggaW5cbiAgICAgICAgbG9vcF9yZXN0IG1heV9uZWVkX3NwYWNlIHRcbiAgICAgIHwgW10gLT4gYWRkX2NoYXIgYnVmICcpJ1xuICAgIGluXG4gICAgaWdub3JlIChsb29wIGZhbHNlIHNleHApXG4gIDs7XG5cbiAgKCogVGhlIG1heGltdW0gc2l6ZSBvZiBhIHRoaW5nIG9uIHRoZSBtaW5vciBoZWFwIGlzIDI1NiB3b3Jkcy5cbiAgICAgUHJldmlvdXNseSwgdGhpcyBzaXplIG9mIHRoZSByZXR1cm5lZCBidWZmZXIgaGVyZSB3YXMgNDA5NiBieXRlcywgd2hpY2hcbiAgICAgY2F1c2VkIHRoZSBCdWZmZXIgdG8gYmUgYWxsb2NhdGVkIG9uIHRoZSAqbWFqb3IqIGhlYXAgZXZlcnkgdGltZS5cblxuICAgICBBY2NvcmRpbmcgdG8gYSBzaW1wbGUgYmVuY2htYXJrIGJ5IFJvbiwgd2UgY2FuIGltcHJvdmUgcGVyZm9ybWFuY2UgZm9yXG4gICAgIHNtYWxsIHMtZXhwcmVzc2lvbnMgYnkgYSBmYWN0b3Igb2YgfjQgaWYgd2Ugb25seSBhbGxvY2F0ZSAxMDI0IGJ5dGVzXG4gICAgICgxMjggd29yZHMgKyBzb21lIHNtYWxsIG92ZXJoZWFkKSB3b3J0aCBvZiBidWZmZXIgaW5pdGlhbGx5LiAgQW5kIG9uZVxuICAgICBjYW4gYXJndWUgdGhhdCBpZiBpdCdzIGZyZWUgdG8gYWxsb2NhdGUgc3RyaW5ncyBzbWFsbGVyIHRoYW4gMjU2IHdvcmRzLFxuICAgICBsYXJnZSBzLWV4cHJlc3Npb25zIHJlcXVpcmluZyBsYXJnZXIgZXhwZW5zaXZlIGJ1ZmZlcnMgd29uJ3Qgbm90aWNlXG4gICAgIHRoZSBleHRyYSB0d28gZG91YmxpbmdzIGZyb20gMTAyNCBieXRlcyB0byAyMDQ4IGFuZCA0MDk2LiBBbmQgZXNwZWNpYWxseVxuICAgICBwZXJmb3JtYW5jZS1zZW5zaXRpdmUgYXBwbGljYXRpb25zIHRvIGFsd2F5cyBwYXNzIGluIGEgbGFyZ2VyIGJ1ZmZlciB0b1xuICAgICB1c2UuICopXG4gIGxldCBidWZmZXIgKCkgPSBCdWZmZXIuY3JlYXRlIDEwMjRcblxuICAoKiBTdHJpbmcgY29udmVyc2lvbnMgKilcblxuICBsZXQgdG9fc3RyaW5nX2h1bSA/aW5kZW50ID0gZnVuY3Rpb25cbiAgICB8IEF0b20gc3RyXG4gICAgICB3aGVuIG1hdGNoIGluZGV4X29mX25ld2xpbmUgc3RyIDAgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gdHJ1ZVxuICAgICAgICB8IFNvbWUgXyAtPiBmYWxzZSAtPiBtYWNoX21heWJlX2VzY19zdHIgc3RyXG4gICAgfCBzZXhwIC0+XG4gICAgICBsZXQgYnVmID0gYnVmZmVyICgpIGluXG4gICAgICB0b19idWZmZXJfaHVtID9pbmRlbnQgc2V4cCB+YnVmO1xuICAgICAgQnVmZmVyLmNvbnRlbnRzIGJ1ZlxuICA7O1xuXG4gIGxldCB0b19zdHJpbmdfbWFjaCA9IGZ1bmN0aW9uXG4gICAgfCBBdG9tIHN0ciAtPiBtYWNoX21heWJlX2VzY19zdHIgc3RyXG4gICAgfCBzZXhwIC0+XG4gICAgICBsZXQgYnVmID0gYnVmZmVyICgpIGluXG4gICAgICB0b19idWZmZXJfbWFjaCBzZXhwIH5idWY7XG4gICAgICBCdWZmZXIuY29udGVudHMgYnVmXG4gIDs7XG5cbiAgbGV0IHRvX3N0cmluZyA9IHRvX3N0cmluZ19tYWNoXG5lbmRcblxuaW5jbHVkZSBQcmludGluZ1xuXG5sZXQgb2ZfZmxvYXRfc3R5bGUgOiBbIGBVbmRlcnNjb3JlcyB8IGBOb191bmRlcnNjb3JlcyBdIHJlZiA9IHJlZiBgTm9fdW5kZXJzY29yZXNcbmxldCBvZl9pbnRfc3R5bGUgOiBbIGBVbmRlcnNjb3JlcyB8IGBOb191bmRlcnNjb3JlcyBdIHJlZiA9IHJlZiBgTm9fdW5kZXJzY29yZXNcblxubW9kdWxlIFByaXZhdGUgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBQcmludGluZ1xuZW5kXG5cbmxldCBtZXNzYWdlIG5hbWUgZmllbGRzID1cbiAgbGV0IHJlYyBjb252X2ZpZWxkcyA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBbXVxuICAgIHwgKGZuYW1lLCBmc2V4cCkgOjogcmVzdCAtPlxuICAgICAgKG1hdGNoIGZuYW1lIHdpdGhcbiAgICAgICB8IFwiXCIgLT4gZnNleHAgOjogY29udl9maWVsZHMgcmVzdFxuICAgICAgIHwgXyAtPiBMaXN0IFsgQXRvbSBmbmFtZTsgZnNleHAgXSA6OiBjb252X2ZpZWxkcyByZXN0KVxuICBpblxuICBMaXN0IChBdG9tIG5hbWUgOjogY29udl9maWVsZHMgZmllbGRzKVxuOztcbiIsImxldCB1bml0X3NleHBfZ3JhbW1hciA6IHVuaXQgU2V4cF9ncmFtbWFyLnQgPSB7IHVudHlwZWQgPSBMaXN0IEVtcHR5IH1cbmxldCBib29sX3NleHBfZ3JhbW1hciA6IGJvb2wgU2V4cF9ncmFtbWFyLnQgPSB7IHVudHlwZWQgPSBCb29sIH1cbmxldCBzdHJpbmdfc2V4cF9ncmFtbWFyIDogc3RyaW5nIFNleHBfZ3JhbW1hci50ID0geyB1bnR5cGVkID0gU3RyaW5nIH1cbmxldCBieXRlc19zZXhwX2dyYW1tYXIgOiBieXRlcyBTZXhwX2dyYW1tYXIudCA9IHsgdW50eXBlZCA9IFN0cmluZyB9XG5sZXQgY2hhcl9zZXhwX2dyYW1tYXIgOiBjaGFyIFNleHBfZ3JhbW1hci50ID0geyB1bnR5cGVkID0gQ2hhciB9XG5sZXQgaW50X3NleHBfZ3JhbW1hciA6IGludCBTZXhwX2dyYW1tYXIudCA9IHsgdW50eXBlZCA9IEludGVnZXIgfVxubGV0IGZsb2F0X3NleHBfZ3JhbW1hciA6IGZsb2F0IFNleHBfZ3JhbW1hci50ID0geyB1bnR5cGVkID0gRmxvYXQgfVxubGV0IGludDMyX3NleHBfZ3JhbW1hciA6IGludDMyIFNleHBfZ3JhbW1hci50ID0geyB1bnR5cGVkID0gSW50ZWdlciB9XG5sZXQgaW50NjRfc2V4cF9ncmFtbWFyIDogaW50NjQgU2V4cF9ncmFtbWFyLnQgPSB7IHVudHlwZWQgPSBJbnRlZ2VyIH1cbmxldCBuYXRpdmVpbnRfc2V4cF9ncmFtbWFyIDogbmF0aXZlaW50IFNleHBfZ3JhbW1hci50ID0geyB1bnR5cGVkID0gSW50ZWdlciB9XG5sZXQgc2V4cF90X3NleHBfZ3JhbW1hciA6IFNleHAudCBTZXhwX2dyYW1tYXIudCA9IHsgdW50eXBlZCA9IEFueSBcIlNleHAudFwiIH1cbmxldCByZWZfc2V4cF9ncmFtbWFyIGdyYW1tYXIgPSBTZXhwX2dyYW1tYXIuY29lcmNlIGdyYW1tYXJcbmxldCBsYXp5X3Rfc2V4cF9ncmFtbWFyIGdyYW1tYXIgPSBTZXhwX2dyYW1tYXIuY29lcmNlIGdyYW1tYXJcblxubGV0IG9wdGlvbl9zZXhwX2dyYW1tYXIgKHsgdW50eXBlZCB9IDogXyBTZXhwX2dyYW1tYXIudCkgOiBfIG9wdGlvbiBTZXhwX2dyYW1tYXIudCA9XG4gIHsgdW50eXBlZCA9IE9wdGlvbiB1bnR5cGVkIH1cbjs7XG5cbmxldCBsaXN0X3NleHBfZ3JhbW1hciAoeyB1bnR5cGVkIH0gOiBfIFNleHBfZ3JhbW1hci50KSA6IF8gbGlzdCBTZXhwX2dyYW1tYXIudCA9XG4gIHsgdW50eXBlZCA9IExpc3QgKE1hbnkgdW50eXBlZCkgfVxuOztcblxubGV0IGFycmF5X3NleHBfZ3JhbW1hciAoeyB1bnR5cGVkIH0gOiBfIFNleHBfZ3JhbW1hci50KSA6IF8gYXJyYXkgU2V4cF9ncmFtbWFyLnQgPVxuICB7IHVudHlwZWQgPSBMaXN0IChNYW55IHVudHlwZWQpIH1cbjs7XG5cbmxldCBlbXB0eV9zZXhwX2dyYW1tYXIgOiBfIFNleHBfZ3JhbW1hci50ID0geyB1bnR5cGVkID0gVW5pb24gW10gfVxubGV0IG9wYXF1ZV9zZXhwX2dyYW1tYXIgPSBlbXB0eV9zZXhwX2dyYW1tYXJcbmxldCBmdW5fc2V4cF9ncmFtbWFyID0gZW1wdHlfc2V4cF9ncmFtbWFyXG4iLCIoKiBVdGlsaXR5IE1vZHVsZSBmb3IgUy1leHByZXNzaW9uIENvbnZlcnNpb25zICopXG5cbm9wZW4gU3RkTGFiZWxzXG5vcGVuIE1vcmVMYWJlbHNcbm9wZW4gUHJpbnRmXG5vcGVuIFNleHBcblxuKCogQ29udmVyc2lvbiBvZiBPQ2FtbC12YWx1ZXMgdG8gUy1leHByZXNzaW9ucyAqKVxuZXh0ZXJuYWwgZm9ybWF0X2Zsb2F0IDogc3RyaW5nIC0+IGZsb2F0IC0+IHN0cmluZyA9IFwiY2FtbF9mb3JtYXRfZmxvYXRcIlxuXG4oKiAnJS4xN2cnIGlzIGd1YXJhbnRlZWQgdG8gYmUgcm91bmQtdHJpcHBhYmxlLlxuXG4gICAnJS4xNWcnIHdpbGwgYmUgcm91bmQtdHJpcHBhYmxlIGFuZCBub3QgaGF2ZSBub2lzZSBhdCB0aGUgbGFzdCBkaWdpdCBvciB0d28gZm9yIGEgZmxvYXRcbiAgIHdoaWNoIHdhcyBjb252ZXJ0ZWQgZnJvbSBhIGRlY2ltYWwgKHN0cmluZykgd2l0aCA8PSAxNSBzaWduaWZpY2FudCBkaWdpdHMuICBTbyBpdCdzXG4gICB3b3J0aCB0cnlpbmcgZmlyc3QgdG8gYXZvaWQgdGhpbmdzIGxpa2UgXCIzLjE0MDAwMDAwMDAwMDAwMDFcIi5cblxuICAgU2VlIGNvbW1lbnQgYWJvdmUgW3RvX3N0cmluZ19yb3VuZF90cmlwcGFibGVdIGluIHshQ29yZS5GbG9hdH0gZm9yXG4gICBkZXRhaWxlZCBleHBsYW5hdGlvbiBhbmQgZXhhbXBsZXMuICopXG5sZXQgZGVmYXVsdF9zdHJpbmdfb2ZfZmxvYXQgPVxuICByZWYgKGZ1biB4IC0+XG4gICAgbGV0IHkgPSBmb3JtYXRfZmxvYXQgXCIlLjE1R1wiIHggaW5cbiAgICBpZiBmbG9hdF9vZl9zdHJpbmcgeSA9IHggdGhlbiB5IGVsc2UgZm9ybWF0X2Zsb2F0IFwiJS4xN0dcIiB4KVxuOztcblxubGV0IHJlYWRfb2xkX29wdGlvbl9mb3JtYXQgPSByZWYgdHJ1ZVxubGV0IHdyaXRlX29sZF9vcHRpb25fZm9ybWF0ID0gcmVmIHRydWVcbmxldCBsaXN0X21hcCBmIGwgPSBMaXN0LnJldiAoTGlzdC5yZXZfbWFwIGwgfmYpXG5sZXQgc2V4cF9vZl91bml0ICgpID0gTGlzdCBbXVxubGV0IHNleHBfb2ZfYm9vbCBiID0gQXRvbSAoc3RyaW5nX29mX2Jvb2wgYilcbmxldCBzZXhwX29mX3N0cmluZyBzdHIgPSBBdG9tIHN0clxubGV0IHNleHBfb2ZfYnl0ZXMgYnl0ZXMgPSBBdG9tIChCeXRlcy50b19zdHJpbmcgYnl0ZXMpXG5sZXQgc2V4cF9vZl9jaGFyIGMgPSBBdG9tIChTdHJpbmcubWFrZSAxIGMpXG5sZXQgc2V4cF9vZl9pbnQgbiA9IEF0b20gKHN0cmluZ19vZl9pbnQgbilcbmxldCBzZXhwX29mX2Zsb2F0IG4gPSBBdG9tICghZGVmYXVsdF9zdHJpbmdfb2ZfZmxvYXQgbilcbmxldCBzZXhwX29mX2ludDMyIG4gPSBBdG9tIChJbnQzMi50b19zdHJpbmcgbilcbmxldCBzZXhwX29mX2ludDY0IG4gPSBBdG9tIChJbnQ2NC50b19zdHJpbmcgbilcbmxldCBzZXhwX29mX25hdGl2ZWludCBuID0gQXRvbSAoTmF0aXZlaW50LnRvX3N0cmluZyBuKVxubGV0IHNleHBfb2ZfcmVmIHNleHBfb2ZfX2EgcmYgPSBzZXhwX29mX19hICFyZlxubGV0IHNleHBfb2ZfbGF6eV90IHNleHBfb2ZfX2EgbHYgPSBzZXhwX29mX19hIChMYXp5LmZvcmNlIGx2KVxuXG5sZXQgc2V4cF9vZl9vcHRpb24gc2V4cF9vZl9fYSA9IGZ1bmN0aW9uXG4gIHwgU29tZSB4IHdoZW4gIXdyaXRlX29sZF9vcHRpb25fZm9ybWF0IC0+IExpc3QgWyBzZXhwX29mX19hIHggXVxuICB8IFNvbWUgeCAtPiBMaXN0IFsgQXRvbSBcInNvbWVcIjsgc2V4cF9vZl9fYSB4IF1cbiAgfCBOb25lIHdoZW4gIXdyaXRlX29sZF9vcHRpb25fZm9ybWF0IC0+IExpc3QgW11cbiAgfCBOb25lIC0+IEF0b20gXCJub25lXCJcbjs7XG5cbmxldCBzZXhwX29mX3BhaXIgc2V4cF9vZl9fYSBzZXhwX29mX19iIChhLCBiKSA9IExpc3QgWyBzZXhwX29mX19hIGE7IHNleHBfb2ZfX2IgYiBdXG5cbmxldCBzZXhwX29mX3RyaXBsZSBzZXhwX29mX19hIHNleHBfb2ZfX2Igc2V4cF9vZl9fYyAoYSwgYiwgYykgPVxuICBMaXN0IFsgc2V4cF9vZl9fYSBhOyBzZXhwX29mX19iIGI7IHNleHBfb2ZfX2MgYyBdXG47O1xuXG4oKiBMaXN0LnJldiAoTGlzdC5yZXZfbWFwIC4uLikgaXMgdGFpbCByZWN1cnNpdmUsIHRoZSBPQ2FtbCBzdGFuZGFyZFxuICAgbGlicmFyeSBMaXN0Lm1hcCBpcyBOT1QuICopXG5sZXQgc2V4cF9vZl9saXN0IHNleHBfb2ZfX2EgbHN0ID0gTGlzdCAoTGlzdC5yZXYgKExpc3QucmV2X21hcCBsc3QgfmY6c2V4cF9vZl9fYSkpXG5cbmxldCBzZXhwX29mX2FycmF5IHNleHBfb2ZfX2EgYXIgPVxuICBsZXQgbHN0X3JlZiA9IHJlZiBbXSBpblxuICBmb3IgaSA9IEFycmF5Lmxlbmd0aCBhciAtIDEgZG93bnRvIDAgZG9cbiAgICBsc3RfcmVmIDo9IHNleHBfb2ZfX2EgYXIuKGkpIDo6ICFsc3RfcmVmXG4gIGRvbmU7XG4gIExpc3QgIWxzdF9yZWZcbjs7XG5cbmxldCBzZXhwX29mX2hhc2h0Ymwgc2V4cF9vZl9rZXkgc2V4cF9vZl92YWwgaHRibCA9XG4gIGxldCBjb2xsIH5rZXk6ayB+ZGF0YTp2IGFjYyA9IExpc3QgWyBzZXhwX29mX2tleSBrOyBzZXhwX29mX3ZhbCB2IF0gOjogYWNjIGluXG4gIExpc3QgKEhhc2h0YmwuZm9sZCBodGJsIH5pbml0OltdIH5mOmNvbGwpXG47O1xuXG5sZXQgc2V4cF9vZl9vcGFxdWUgXyA9IEF0b20gXCI8b3BhcXVlPlwiXG5sZXQgc2V4cF9vZl9mdW4gXyA9IEF0b20gXCI8ZnVuPlwiXG5cbigqIEV4Y2VwdGlvbiBjb252ZXJ0ZXIgcmVnaXN0cmF0aW9uIGFuZCBsb29rdXAgKilcblxubW9kdWxlIEV4bl9jb252ZXJ0ZXIgPSBzdHJ1Y3RcbiAgKCogVGhlc2UgZXhjZXB0aW9uIHJlZ2lzdHJhdGlvbiBmdW5jdGlvbnMgYXNzdW1lIHRoYXQgY29udGV4dC1zd2l0Y2hlc1xuICAgICBjYW5ub3QgaGFwcGVuIHVubGVzcyB0aGVyZSBpcyBhbiBhbGxvY2F0aW9uLiAgSXQgaXMgcmVhc29uYWJsZSB0byBleHBlY3RcbiAgICAgdGhhdCB0aGlzIHdpbGwgcmVtYWluIHRydWUgZm9yIHRoZSBmb3Jlc2VlYWJsZSBmdXR1cmUuICBUaGF0IHdheSB3ZVxuICAgICBhdm9pZCB1c2luZyBtdXRleGVzIGFuZCB0aHVzIGEgZGVwZW5kZW5jeSBvbiB0aGUgdGhyZWFkcyBsaWJyYXJ5LiAqKVxuXG4gICgqIEZhc3QgYW5kIGF1dG9tYXRpYyBleGNlcHRpb24gcmVnaXN0cmF0aW9uICopXG5cbiAgbW9kdWxlIFJlZ2lzdHJhdGlvbiA9IHN0cnVjdFxuICAgIHR5cGUgdCA9XG4gICAgICB7IHNleHBfb2ZfZXhuIDogZXhuIC0+IFNleHAudFxuICAgICAgOyAoKiBJZiBbcHJpbnRleGMgPSB0cnVlXSB0aGVuIHRoaXMgc2V4cCBjb252ZXJ0ZXIgaXMgdXNlZCBmb3IgUHJpbnRleGMudG9fc3RyaW5nICopXG4gICAgICAgIHByaW50ZXhjIDogYm9vbFxuICAgICAgfVxuICBlbmRcblxuICBtb2R1bGUgRXhuX3RhYmxlID0gRXBoZW1lcm9uLksxLk1ha2UgKHN0cnVjdFxuICAgICAgdHlwZSB0ID0gZXh0ZW5zaW9uX2NvbnN0cnVjdG9yXG5cbiAgICAgIGxldCBlcXVhbCA9ICggPT0gKVxuICAgICAgbGV0IGhhc2ggPSBPYmouRXh0ZW5zaW9uX2NvbnN0cnVjdG9yLmlkXG4gICAgZW5kKVxuXG4gIGxldCB0aGVfZXhuX3RhYmxlIDogUmVnaXN0cmF0aW9uLnQgRXhuX3RhYmxlLnQgPSBFeG5fdGFibGUuY3JlYXRlIDE3XG5cbiAgKCogRXBoZW1lcm9ucyBhcmUgdXNlZCBzbyB0aGF0IFtzZXhwX29mX2V4bl0gY2xvc3VyZSBkb24ndCBrZWVwIHRoZVxuICAgICBleHRlbnNpb25fY29uc3RydWN0b3IgbGl2ZS4gKilcbiAgbGV0IGFkZCA/KHByaW50ZXhjID0gdHJ1ZSkgP2ZpbmFsaXNlOl8gZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIHNleHBfb2ZfZXhuID1cbiAgICBFeG5fdGFibGUuYWRkIHRoZV9leG5fdGFibGUgZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIHsgc2V4cF9vZl9leG47IHByaW50ZXhjIH1cbiAgOztcblxuICBsZXQgZmluZF9hdXRvIH5mb3JfcHJpbnRleGMgZXhuID1cbiAgICBsZXQgZXh0ZW5zaW9uX2NvbnN0cnVjdG9yID0gT2JqLkV4dGVuc2lvbl9jb25zdHJ1Y3Rvci5vZl92YWwgZXhuIGluXG4gICAgbWF0Y2ggRXhuX3RhYmxlLmZpbmRfb3B0IHRoZV9leG5fdGFibGUgZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIHdpdGhcbiAgICB8IE5vbmUgLT4gTm9uZVxuICAgIHwgU29tZSB7IHNleHBfb2ZfZXhuOyBwcmludGV4YyB9IC0+XG4gICAgICAobWF0Y2ggZm9yX3ByaW50ZXhjLCBwcmludGV4YyB3aXRoXG4gICAgICAgfCBmYWxzZSwgXyB8IF8sIHRydWUgLT4gU29tZSAoc2V4cF9vZl9leG4gZXhuKVxuICAgICAgIHwgdHJ1ZSwgZmFsc2UgLT4gTm9uZSlcbiAgOztcblxuICBtb2R1bGUgRm9yX3VuaXRfdGVzdHNfb25seSA9IHN0cnVjdFxuICAgIGxldCBzaXplICgpID0gKEV4bl90YWJsZS5zdGF0c19hbGl2ZSB0aGVfZXhuX3RhYmxlKS5udW1fYmluZGluZ3NcbiAgZW5kXG5lbmRcblxubGV0IHNleHBfb2ZfZXhuX29wdF9mb3JfcHJpbnRleGMgZXhuID0gRXhuX2NvbnZlcnRlci5maW5kX2F1dG8gfmZvcl9wcmludGV4Yzp0cnVlIGV4blxubGV0IHNleHBfb2ZfZXhuX29wdCBleG4gPSBFeG5fY29udmVydGVyLmZpbmRfYXV0byB+Zm9yX3ByaW50ZXhjOmZhbHNlIGV4blxuXG5sZXQgc2V4cF9vZl9leG4gZXhuID1cbiAgbWF0Y2ggc2V4cF9vZl9leG5fb3B0IGV4biB3aXRoXG4gIHwgTm9uZSAtPiBMaXN0IFsgQXRvbSAoUHJpbnRleGMudG9fc3RyaW5nIGV4bikgXVxuICB8IFNvbWUgc2V4cCAtPiBzZXhwXG47O1xuXG5sZXQgZXhuX3RvX3N0cmluZyBlID0gU2V4cC50b19zdHJpbmdfaHVtIChzZXhwX29mX2V4biBlKVxuXG4oKiB7W2V4Y2VwdGlvbiBCbGFoIFtAQGRlcml2aW5nIHNleHBdXX0gZ2VuZXJhdGVzIGEgY2FsbCB0byB0aGUgZnVuY3Rpb25cbiAgIFtFeG5fY29udmVydGVyLmFkZF0gZGVmaW5lZCBpbiB0aGlzIGZpbGUuICBTbyB3ZSBhcmUgZ3VhcmFudGVkIHRoYXQgYXMgc29vbiBhcyB3ZVxuICAgbWFyayBhbiBleGNlcHRpb24gYXMgc2V4cGFibGUsIHRoaXMgbW9kdWxlIHdpbGwgYmUgbGlua2VkIGluIGFuZCB0aGlzIHByaW50ZXIgd2lsbCBiZVxuICAgcmVnaXN0ZXJlZCwgd2hpY2ggaXMgd2hhdCB3ZSB3YW50LiAqKVxubGV0ICgpID1cbiAgUHJpbnRleGMucmVnaXN0ZXJfcHJpbnRlciAoZnVuIGV4biAtPlxuICAgIG1hdGNoIHNleHBfb2ZfZXhuX29wdF9mb3JfcHJpbnRleGMgZXhuIHdpdGhcbiAgICB8IE5vbmUgLT4gTm9uZVxuICAgIHwgU29tZSBzZXhwIC0+IFNvbWUgKFNleHAudG9fc3RyaW5nX2h1bSB+aW5kZW50OjIgc2V4cCkpXG47O1xuXG5sZXQgcHJpbnRleGNfcHJlZmVyX3NleHAgZXhuID1cbiAgbWF0Y2ggc2V4cF9vZl9leG5fb3B0IGV4biB3aXRoXG4gIHwgTm9uZSAtPiBQcmludGV4Yy50b19zdHJpbmcgZXhuXG4gIHwgU29tZSBzZXhwIC0+IFNleHAudG9fc3RyaW5nX2h1bSB+aW5kZW50OjIgc2V4cFxuOztcblxuKCogQ29udmVyc2lvbiBvZiBTLWV4cHJlc3Npb25zIHRvIE9DYW1sLXZhbHVlcyAqKVxuXG5leGNlcHRpb24gT2Zfc2V4cF9lcnJvciA9IFNleHAuT2Zfc2V4cF9lcnJvclxuXG5sZXQgcmVjb3JkX2NoZWNrX2V4dHJhX2ZpZWxkcyA9IHJlZiB0cnVlXG5sZXQgb2Zfc2V4cF9lcnJvcl9leG4gZXhjIHNleHAgPSByYWlzZSAoT2Zfc2V4cF9lcnJvciAoZXhjLCBzZXhwKSlcbmxldCBvZl9zZXhwX2Vycm9yIHdoYXQgc2V4cCA9IHJhaXNlIChPZl9zZXhwX2Vycm9yIChGYWlsdXJlIHdoYXQsIHNleHApKVxuXG5sZXQgdW5pdF9vZl9zZXhwIHNleHAgPVxuICBtYXRjaCBzZXhwIHdpdGhcbiAgfCBMaXN0IFtdIC0+ICgpXG4gIHwgQXRvbSBfIHwgTGlzdCBfIC0+IG9mX3NleHBfZXJyb3IgXCJ1bml0X29mX3NleHA6IGVtcHR5IGxpc3QgbmVlZGVkXCIgc2V4cFxuOztcblxubGV0IGJvb2xfb2Zfc2V4cCBzZXhwID1cbiAgbWF0Y2ggc2V4cCB3aXRoXG4gIHwgQXRvbSAoXCJ0cnVlXCIgfCBcIlRydWVcIikgLT4gdHJ1ZVxuICB8IEF0b20gKFwiZmFsc2VcIiB8IFwiRmFsc2VcIikgLT4gZmFsc2VcbiAgfCBBdG9tIF8gLT4gb2Zfc2V4cF9lcnJvciBcImJvb2xfb2Zfc2V4cDogdW5rbm93biBzdHJpbmdcIiBzZXhwXG4gIHwgTGlzdCBfIC0+IG9mX3NleHBfZXJyb3IgXCJib29sX29mX3NleHA6IGF0b20gbmVlZGVkXCIgc2V4cFxuOztcblxubGV0IHN0cmluZ19vZl9zZXhwIHNleHAgPVxuICBtYXRjaCBzZXhwIHdpdGhcbiAgfCBBdG9tIHN0ciAtPiBzdHJcbiAgfCBMaXN0IF8gLT4gb2Zfc2V4cF9lcnJvciBcInN0cmluZ19vZl9zZXhwOiBhdG9tIG5lZWRlZFwiIHNleHBcbjs7XG5cbmxldCBieXRlc19vZl9zZXhwIHNleHAgPVxuICBtYXRjaCBzZXhwIHdpdGhcbiAgfCBBdG9tIHN0ciAtPiBCeXRlcy5vZl9zdHJpbmcgc3RyXG4gIHwgTGlzdCBfIC0+IG9mX3NleHBfZXJyb3IgXCJieXRlc19vZl9zZXhwOiBhdG9tIG5lZWRlZFwiIHNleHBcbjs7XG5cbmxldCBjaGFyX29mX3NleHAgc2V4cCA9XG4gIG1hdGNoIHNleHAgd2l0aFxuICB8IEF0b20gc3RyIC0+XG4gICAgaWYgU3RyaW5nLmxlbmd0aCBzdHIgPD4gMVxuICAgIHRoZW4gb2Zfc2V4cF9lcnJvciBcImNoYXJfb2Zfc2V4cDogYXRvbSBzdHJpbmcgbXVzdCBjb250YWluIG9uZSBjaGFyYWN0ZXIgb25seVwiIHNleHA7XG4gICAgc3RyLlswXVxuICB8IExpc3QgXyAtPiBvZl9zZXhwX2Vycm9yIFwiY2hhcl9vZl9zZXhwOiBhdG9tIG5lZWRlZFwiIHNleHBcbjs7XG5cbmxldCBpbnRfb2Zfc2V4cCBzZXhwID1cbiAgbWF0Y2ggc2V4cCB3aXRoXG4gIHwgQXRvbSBzdHIgLT5cbiAgICAodHJ5IGludF9vZl9zdHJpbmcgc3RyIHdpdGhcbiAgICAgfCBleGMgLT4gb2Zfc2V4cF9lcnJvciAoXCJpbnRfb2Zfc2V4cDogXCIgXiBleG5fdG9fc3RyaW5nIGV4Yykgc2V4cClcbiAgfCBMaXN0IF8gLT4gb2Zfc2V4cF9lcnJvciBcImludF9vZl9zZXhwOiBhdG9tIG5lZWRlZFwiIHNleHBcbjs7XG5cbmxldCBmbG9hdF9vZl9zZXhwIHNleHAgPVxuICBtYXRjaCBzZXhwIHdpdGhcbiAgfCBBdG9tIHN0ciAtPlxuICAgICh0cnkgZmxvYXRfb2Zfc3RyaW5nIHN0ciB3aXRoXG4gICAgIHwgZXhjIC0+IG9mX3NleHBfZXJyb3IgKFwiZmxvYXRfb2Zfc2V4cDogXCIgXiBleG5fdG9fc3RyaW5nIGV4Yykgc2V4cClcbiAgfCBMaXN0IF8gLT4gb2Zfc2V4cF9lcnJvciBcImZsb2F0X29mX3NleHA6IGF0b20gbmVlZGVkXCIgc2V4cFxuOztcblxubGV0IGludDMyX29mX3NleHAgc2V4cCA9XG4gIG1hdGNoIHNleHAgd2l0aFxuICB8IEF0b20gc3RyIC0+XG4gICAgKHRyeSBJbnQzMi5vZl9zdHJpbmcgc3RyIHdpdGhcbiAgICAgfCBleGMgLT4gb2Zfc2V4cF9lcnJvciAoXCJpbnQzMl9vZl9zZXhwOiBcIiBeIGV4bl90b19zdHJpbmcgZXhjKSBzZXhwKVxuICB8IExpc3QgXyAtPiBvZl9zZXhwX2Vycm9yIFwiaW50MzJfb2Zfc2V4cDogYXRvbSBuZWVkZWRcIiBzZXhwXG47O1xuXG5sZXQgaW50NjRfb2Zfc2V4cCBzZXhwID1cbiAgbWF0Y2ggc2V4cCB3aXRoXG4gIHwgQXRvbSBzdHIgLT5cbiAgICAodHJ5IEludDY0Lm9mX3N0cmluZyBzdHIgd2l0aFxuICAgICB8IGV4YyAtPiBvZl9zZXhwX2Vycm9yIChcImludDY0X29mX3NleHA6IFwiIF4gZXhuX3RvX3N0cmluZyBleGMpIHNleHApXG4gIHwgTGlzdCBfIC0+IG9mX3NleHBfZXJyb3IgXCJpbnQ2NF9vZl9zZXhwOiBhdG9tIG5lZWRlZFwiIHNleHBcbjs7XG5cbmxldCBuYXRpdmVpbnRfb2Zfc2V4cCBzZXhwID1cbiAgbWF0Y2ggc2V4cCB3aXRoXG4gIHwgQXRvbSBzdHIgLT5cbiAgICAodHJ5IE5hdGl2ZWludC5vZl9zdHJpbmcgc3RyIHdpdGhcbiAgICAgfCBleGMgLT4gb2Zfc2V4cF9lcnJvciAoXCJuYXRpdmVpbnRfb2Zfc2V4cDogXCIgXiBleG5fdG9fc3RyaW5nIGV4Yykgc2V4cClcbiAgfCBMaXN0IF8gLT4gb2Zfc2V4cF9lcnJvciBcIm5hdGl2ZWludF9vZl9zZXhwOiBhdG9tIG5lZWRlZFwiIHNleHBcbjs7XG5cbmxldCByZWZfb2Zfc2V4cCBhX19vZl9zZXhwIHNleHAgPSByZWYgKGFfX29mX3NleHAgc2V4cClcbmxldCBsYXp5X3Rfb2Zfc2V4cCBhX19vZl9zZXhwIHNleHAgPSBMYXp5LmZyb21fdmFsIChhX19vZl9zZXhwIHNleHApXG5cbmxldCBvcHRpb25fb2Zfc2V4cCBhX19vZl9zZXhwIHNleHAgPVxuICBpZiAhcmVhZF9vbGRfb3B0aW9uX2Zvcm1hdFxuICB0aGVuIChcbiAgICBtYXRjaCBzZXhwIHdpdGhcbiAgICB8IExpc3QgW10gfCBBdG9tIChcIm5vbmVcIiB8IFwiTm9uZVwiKSAtPiBOb25lXG4gICAgfCBMaXN0IFsgZWwgXSB8IExpc3QgWyBBdG9tIChcInNvbWVcIiB8IFwiU29tZVwiKTsgZWwgXSAtPiBTb21lIChhX19vZl9zZXhwIGVsKVxuICAgIHwgTGlzdCBfIC0+IG9mX3NleHBfZXJyb3IgXCJvcHRpb25fb2Zfc2V4cDogbGlzdCBtdXN0IHJlcHJlc2VudCBvcHRpb25hbCB2YWx1ZVwiIHNleHBcbiAgICB8IEF0b20gXyAtPiBvZl9zZXhwX2Vycm9yIFwib3B0aW9uX29mX3NleHA6IG9ubHkgbm9uZSBjYW4gYmUgYXRvbVwiIHNleHApXG4gIGVsc2UgKFxuICAgIG1hdGNoIHNleHAgd2l0aFxuICAgIHwgQXRvbSAoXCJub25lXCIgfCBcIk5vbmVcIikgLT4gTm9uZVxuICAgIHwgTGlzdCBbIEF0b20gKFwic29tZVwiIHwgXCJTb21lXCIpOyBlbCBdIC0+IFNvbWUgKGFfX29mX3NleHAgZWwpXG4gICAgfCBBdG9tIF8gLT4gb2Zfc2V4cF9lcnJvciBcIm9wdGlvbl9vZl9zZXhwOiBvbmx5IG5vbmUgY2FuIGJlIGF0b21cIiBzZXhwXG4gICAgfCBMaXN0IF8gLT4gb2Zfc2V4cF9lcnJvciBcIm9wdGlvbl9vZl9zZXhwOiBsaXN0IG11c3QgYmUgKHNvbWUgZWwpXCIgc2V4cClcbjs7XG5cbmxldCBwYWlyX29mX3NleHAgYV9fb2Zfc2V4cCBiX19vZl9zZXhwIHNleHAgPVxuICBtYXRjaCBzZXhwIHdpdGhcbiAgfCBMaXN0IFsgYV9zZXhwOyBiX3NleHAgXSAtPlxuICAgIGxldCBhID0gYV9fb2Zfc2V4cCBhX3NleHAgaW5cbiAgICBsZXQgYiA9IGJfX29mX3NleHAgYl9zZXhwIGluXG4gICAgYSwgYlxuICB8IExpc3QgXyAtPlxuICAgIG9mX3NleHBfZXJyb3IgXCJwYWlyX29mX3NleHA6IGxpc3QgbXVzdCBjb250YWluIGV4YWN0bHkgdHdvIGVsZW1lbnRzIG9ubHlcIiBzZXhwXG4gIHwgQXRvbSBfIC0+IG9mX3NleHBfZXJyb3IgXCJwYWlyX29mX3NleHA6IGxpc3QgbmVlZGVkXCIgc2V4cFxuOztcblxubGV0IHRyaXBsZV9vZl9zZXhwIGFfX29mX3NleHAgYl9fb2Zfc2V4cCBjX19vZl9zZXhwIHNleHAgPVxuICBtYXRjaCBzZXhwIHdpdGhcbiAgfCBMaXN0IFsgYV9zZXhwOyBiX3NleHA7IGNfc2V4cCBdIC0+XG4gICAgbGV0IGEgPSBhX19vZl9zZXhwIGFfc2V4cCBpblxuICAgIGxldCBiID0gYl9fb2Zfc2V4cCBiX3NleHAgaW5cbiAgICBsZXQgYyA9IGNfX29mX3NleHAgY19zZXhwIGluXG4gICAgYSwgYiwgY1xuICB8IExpc3QgXyAtPlxuICAgIG9mX3NleHBfZXJyb3IgXCJ0cmlwbGVfb2Zfc2V4cDogbGlzdCBtdXN0IGNvbnRhaW4gZXhhY3RseSB0aHJlZSBlbGVtZW50cyBvbmx5XCIgc2V4cFxuICB8IEF0b20gXyAtPiBvZl9zZXhwX2Vycm9yIFwidHJpcGxlX29mX3NleHA6IGxpc3QgbmVlZGVkXCIgc2V4cFxuOztcblxubGV0IGxpc3Rfb2Zfc2V4cCBhX19vZl9zZXhwIHNleHAgPVxuICBtYXRjaCBzZXhwIHdpdGhcbiAgfCBMaXN0IGxzdCAtPlxuICAgIGxldCByZXZfbHN0ID0gTGlzdC5yZXZfbWFwIGxzdCB+ZjphX19vZl9zZXhwIGluXG4gICAgTGlzdC5yZXYgcmV2X2xzdFxuICB8IEF0b20gXyAtPiBvZl9zZXhwX2Vycm9yIFwibGlzdF9vZl9zZXhwOiBsaXN0IG5lZWRlZFwiIHNleHBcbjs7XG5cbmxldCBhcnJheV9vZl9zZXhwIGFfX29mX3NleHAgc2V4cCA9XG4gIG1hdGNoIHNleHAgd2l0aFxuICB8IExpc3QgW10gLT4gW3x8XVxuICB8IExpc3QgKGggOjogdCkgLT5cbiAgICBsZXQgbGVuID0gTGlzdC5sZW5ndGggdCArIDEgaW5cbiAgICBsZXQgcmVzID0gQXJyYXkubWFrZSBsZW4gKGFfX29mX3NleHAgaCkgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9IGZ1bmN0aW9uXG4gICAgICB8IFtdIC0+IHJlc1xuICAgICAgfCBoIDo6IHQgLT5cbiAgICAgICAgcmVzLihpKSA8LSBhX19vZl9zZXhwIGg7XG4gICAgICAgIGxvb3AgKGkgKyAxKSB0XG4gICAgaW5cbiAgICBsb29wIDEgdFxuICB8IEF0b20gXyAtPiBvZl9zZXhwX2Vycm9yIFwiYXJyYXlfb2Zfc2V4cDogbGlzdCBuZWVkZWRcIiBzZXhwXG47O1xuXG5sZXQgaGFzaHRibF9vZl9zZXhwIGtleV9vZl9zZXhwIHZhbF9vZl9zZXhwIHNleHAgPVxuICBtYXRjaCBzZXhwIHdpdGhcbiAgfCBMaXN0IGxzdCAtPlxuICAgIGxldCBodGJsID0gSGFzaHRibC5jcmVhdGUgMCBpblxuICAgIGxldCBhY3QgPSBmdW5jdGlvblxuICAgICAgfCBMaXN0IFsga19zZXhwOyB2X3NleHAgXSAtPlxuICAgICAgICBIYXNodGJsLmFkZCBodGJsIH5rZXk6KGtleV9vZl9zZXhwIGtfc2V4cCkgfmRhdGE6KHZhbF9vZl9zZXhwIHZfc2V4cClcbiAgICAgIHwgTGlzdCBfIHwgQXRvbSBfIC0+IG9mX3NleHBfZXJyb3IgXCJoYXNodGJsX29mX3NleHA6IHR1cGxlIGxpc3QgbmVlZGVkXCIgc2V4cFxuICAgIGluXG4gICAgTGlzdC5pdGVyIGxzdCB+ZjphY3Q7XG4gICAgaHRibFxuICB8IEF0b20gXyAtPiBvZl9zZXhwX2Vycm9yIFwiaGFzaHRibF9vZl9zZXhwOiBsaXN0IG5lZWRlZFwiIHNleHBcbjs7XG5cbmxldCBvcGFxdWVfb2Zfc2V4cCBzZXhwID1cbiAgb2Zfc2V4cF9lcnJvciBcIm9wYXF1ZV9vZl9zZXhwOiBjYW5ub3QgY29udmVydCBvcGFxdWUgdmFsdWVzXCIgc2V4cFxuOztcblxubGV0IGZ1bl9vZl9zZXhwIHNleHAgPSBvZl9zZXhwX2Vycm9yIFwiZnVuX29mX3NleHA6IGNhbm5vdCBjb252ZXJ0IGZ1bmN0aW9uIHZhbHVlc1wiIHNleHBcblxuKCogU2V4cCBHcmFtbWFycyAqKVxuXG5pbmNsdWRlIFNleHBfY29udl9ncmFtbWFyXG5cbigqIFJlZ2lzdGVyaW5nIGRlZmF1bHQgZXhjZXB0aW9uIHByaW50ZXJzICopXG5cbmxldCBnZXRfZmxjX2Vycm9yIG5hbWUgKGZpbGUsIGxpbmUsIGNocikgPSBBdG9tIChzcHJpbnRmIFwiJXMgJXM6JWQ6JWRcIiBuYW1lIGZpbGUgbGluZSBjaHIpXG5cbmxldCAoKSA9XG4gIExpc3QuaXRlclxuICAgIH5mOihmdW4gKGV4dGVuc2lvbl9jb25zdHJ1Y3RvciwgaGFuZGxlcikgLT5cbiAgICAgIEV4bl9jb252ZXJ0ZXIuYWRkIH5wcmludGV4YzpmYWxzZSB+ZmluYWxpc2U6ZmFsc2UgZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIGhhbmRsZXIpXG4gICAgWyAoIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIEFzc2VydF9mYWlsdXJlXVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IEFzc2VydF9mYWlsdXJlIGFyZyAtPiBnZXRfZmxjX2Vycm9yIFwiQXNzZXJ0X2ZhaWx1cmVcIiBhcmdcbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSApXG4gICAgOyAoIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIEV4aXRdXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgRXhpdCAtPiBBdG9tIFwiRXhpdFwiXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIDsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBFbmRfb2ZfZmlsZV1cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBFbmRfb2ZfZmlsZSAtPiBBdG9tIFwiRW5kX29mX2ZpbGVcIlxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICA7ICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgRmFpbHVyZV1cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBGYWlsdXJlIGFyZyAtPiBMaXN0IFsgQXRvbSBcIkZhaWx1cmVcIjsgQXRvbSBhcmcgXVxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICA7ICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgTm90X2ZvdW5kXVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IE5vdF9mb3VuZCAtPiBBdG9tIFwiTm90X2ZvdW5kXCJcbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSApXG4gICAgOyAoIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIEludmFsaWRfYXJndW1lbnRdXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgSW52YWxpZF9hcmd1bWVudCBhcmcgLT4gTGlzdCBbIEF0b20gXCJJbnZhbGlkX2FyZ3VtZW50XCI7IEF0b20gYXJnIF1cbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSApXG4gICAgOyAoIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIE1hdGNoX2ZhaWx1cmVdXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgTWF0Y2hfZmFpbHVyZSBhcmcgLT4gZ2V0X2ZsY19lcnJvciBcIk1hdGNoX2ZhaWx1cmVcIiBhcmdcbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSApXG4gICAgOyAoIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIE5vdF9mb3VuZF9zXVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IE5vdF9mb3VuZF9zIGFyZyAtPiBMaXN0IFsgQXRvbSBcIk5vdF9mb3VuZF9zXCI7IGFyZyBdXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIDsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBTeXNfZXJyb3JdXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgU3lzX2Vycm9yIGFyZyAtPiBMaXN0IFsgQXRvbSBcIlN5c19lcnJvclwiOyBBdG9tIGFyZyBdXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIDsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBBcmcuSGVscF1cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBBcmcuSGVscCBhcmcgLT4gTGlzdCBbIEF0b20gXCJBcmcuSGVscFwiOyBBdG9tIGFyZyBdXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIDsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBBcmcuQmFkXVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IEFyZy5CYWQgYXJnIC0+IExpc3QgWyBBdG9tIFwiQXJnLkJhZFwiOyBBdG9tIGFyZyBdXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIDsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBMYXp5LlVuZGVmaW5lZF1cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBMYXp5LlVuZGVmaW5lZCAtPiBBdG9tIFwiTGF6eS5VbmRlZmluZWRcIlxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICA7ICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgUGFyc2luZy5QYXJzZV9lcnJvcl1cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBQYXJzaW5nLlBhcnNlX2Vycm9yIC0+IEF0b20gXCJQYXJzaW5nLlBhcnNlX2Vycm9yXCJcbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSApXG4gICAgOyAoIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIFF1ZXVlLkVtcHR5XVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IFF1ZXVlLkVtcHR5IC0+IEF0b20gXCJRdWV1ZS5FbXB0eVwiXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIDsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBTY2FuZi5TY2FuX2ZhaWx1cmVdXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgU2NhbmYuU2Nhbl9mYWlsdXJlIGFyZyAtPiBMaXN0IFsgQXRvbSBcIlNjYW5mLlNjYW5fZmFpbHVyZVwiOyBBdG9tIGFyZyBdXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIDsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBTdGFjay5FbXB0eV1cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBTdGFjay5FbXB0eSAtPiBBdG9tIFwiU3RhY2suRW1wdHlcIlxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICA7ICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgU3lzLkJyZWFrXVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IFN5cy5CcmVhayAtPiBBdG9tIFwiU3lzLkJyZWFrXCJcbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSApXG4gICAgXVxuOztcblxubGV0ICgpID1cbiAgTGlzdC5pdGVyXG4gICAgfmY6KGZ1biAoZXh0ZW5zaW9uX2NvbnN0cnVjdG9yLCBoYW5kbGVyKSAtPlxuICAgICAgRXhuX2NvbnZlcnRlci5hZGQgfnByaW50ZXhjOnRydWUgfmZpbmFsaXNlOmZhbHNlIGV4dGVuc2lvbl9jb25zdHJ1Y3RvciBoYW5kbGVyKVxuICAgIFsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBPZl9zZXhwX2Vycm9yXVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IE9mX3NleHBfZXJyb3IgKGV4Yywgc2V4cCkgLT5cbiAgICAgICAgICBMaXN0IFsgQXRvbSBcIlNleHBsaWIuQ29udi5PZl9zZXhwX2Vycm9yXCI7IHNleHBfb2ZfZXhuIGV4Yzsgc2V4cCBdXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIF1cbjs7XG5cbmV4dGVybmFsIGlnbm9yZSA6IF8gLT4gdW5pdCA9IFwiJWlnbm9yZVwiXG5leHRlcm5hbCAoID0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVlcXVhbFwiXG4iLCIoKiBDb252X2Vycm9yOiBNb2R1bGUgZm9yIEhhbmRsaW5nIEVycm9ycyBkdXJpbmcgQXV0b21hdGVkIFMtZXhwcmVzc2lvblxuICAgQ29udmVyc2lvbnMgKilcblxub3BlbiBTdGRMYWJlbHNcbm9wZW4gUHJpbnRmXG5vcGVuIFNleHBfY29udlxuXG5leGNlcHRpb24gT2Zfc2V4cF9lcnJvciA9IE9mX3NleHBfZXJyb3JcblxuKCogRXJyb3JzIGNvbmNlcm5pbmcgdHVwbGVzICopXG5cbmxldCB0dXBsZV9vZl9zaXplX25fZXhwZWN0ZWQgbG9jIG4gc2V4cCA9XG4gIG9mX3NleHBfZXJyb3IgKHNwcmludGYgXCIlc19vZl9zZXhwOiB0dXBsZSBvZiBzaXplICVkIGV4cGVjdGVkXCIgbG9jIG4pIHNleHBcbjs7XG5cbigqIEVycm9ycyBjb25jZXJuaW5nIHN1bSB0eXBlcyAqKVxuXG5sZXQgc3RhZ19ub19hcmdzIGxvYyBzZXhwID1cbiAgb2Zfc2V4cF9lcnJvciAobG9jIF4gXCJfb2Zfc2V4cDogdGhpcyBjb25zdHJ1Y3RvciBkb2VzIG5vdCB0YWtlIGFyZ3VtZW50c1wiKSBzZXhwXG47O1xuXG5sZXQgc3RhZ19pbmNvcnJlY3Rfbl9hcmdzIGxvYyB0YWcgc2V4cCA9XG4gIGxldCBtc2cgPSBzcHJpbnRmIFwiJXNfb2Zfc2V4cDogc3VtIHRhZyAlUyBoYXMgaW5jb3JyZWN0IG51bWJlciBvZiBhcmd1bWVudHNcIiBsb2MgdGFnIGluXG4gIG9mX3NleHBfZXJyb3IgbXNnIHNleHBcbjs7XG5cbmxldCBzdGFnX3Rha2VzX2FyZ3MgbG9jIHNleHAgPVxuICBvZl9zZXhwX2Vycm9yIChsb2MgXiBcIl9vZl9zZXhwOiB0aGlzIGNvbnN0cnVjdG9yIHJlcXVpcmVzIGFyZ3VtZW50c1wiKSBzZXhwXG47O1xuXG5sZXQgbmVzdGVkX2xpc3RfaW52YWxpZF9zdW0gbG9jIHNleHAgPVxuICBvZl9zZXhwX2Vycm9yIChsb2MgXiBcIl9vZl9zZXhwOiBleHBlY3RlZCBhIHZhcmlhbnQgdHlwZSwgc2F3IGEgbmVzdGVkIGxpc3RcIikgc2V4cFxuOztcblxubGV0IGVtcHR5X2xpc3RfaW52YWxpZF9zdW0gbG9jIHNleHAgPVxuICBvZl9zZXhwX2Vycm9yIChsb2MgXiBcIl9vZl9zZXhwOiBleHBlY3RlZCBhIHZhcmlhbnQgdHlwZSwgc2F3IGFuIGVtcHR5IGxpc3RcIikgc2V4cFxuOztcblxubGV0IHVuZXhwZWN0ZWRfc3RhZyBsb2Mgc2V4cCA9XG4gIG9mX3NleHBfZXJyb3IgKGxvYyBeIFwiX29mX3NleHA6IHVuZXhwZWN0ZWQgdmFyaWFudCBjb25zdHJ1Y3RvclwiKSBzZXhwXG47O1xuXG4oKiBFcnJvcnMgY29uY2VybmluZyByZWNvcmRzICopXG5cbmxldCByZWNvcmRfc2V4cF9ib29sX3dpdGhfcGF5bG9hZCBsb2Mgc2V4cCA9XG4gIGxldCBtc2cgPVxuICAgIGxvYyBeIFwiX29mX3NleHA6IHJlY29yZCBjb252ZXJzaW9uOiBhIFtzZXhwLmJvb2xdIGZpZWxkIHdhcyBnaXZlbiBhIHBheWxvYWQuXCJcbiAgaW5cbiAgb2Zfc2V4cF9lcnJvciBtc2cgc2V4cFxuOztcblxubGV0IHJlY29yZF9vbmx5X3BhaXJzX2V4cGVjdGVkIGxvYyBzZXhwID1cbiAgbGV0IG1zZyA9XG4gICAgbG9jXG4gICAgXiBcIl9vZl9zZXhwOiByZWNvcmQgY29udmVyc2lvbjogb25seSBwYWlycyBleHBlY3RlZCwgdGhlaXIgZmlyc3QgZWxlbWVudCBtdXN0IGJlIGFuIFxcXG4gICAgICAgYXRvbVwiXG4gIGluXG4gIG9mX3NleHBfZXJyb3IgbXNnIHNleHBcbjs7XG5cbmxldCByZWNvcmRfc3VwZXJmbHVvdXNfZmllbGRzIH53aGF0IH5sb2MgcmV2X2ZsZF9uYW1lcyBzZXhwID1cbiAgbGV0IGZsZF9uYW1lc19zdHIgPSBTdHJpbmcuY29uY2F0IChMaXN0LnJldiByZXZfZmxkX25hbWVzKSB+c2VwOlwiIFwiIGluXG4gIGxldCBtc2cgPSBzcHJpbnRmIFwiJXNfb2Zfc2V4cDogJXM6ICVzXCIgbG9jIHdoYXQgZmxkX25hbWVzX3N0ciBpblxuICBvZl9zZXhwX2Vycm9yIG1zZyBzZXhwXG47O1xuXG5sZXQgcmVjb3JkX2R1cGxpY2F0ZV9maWVsZHMgbG9jIHJldl9mbGRfbmFtZXMgc2V4cCA9XG4gIHJlY29yZF9zdXBlcmZsdW91c19maWVsZHMgfndoYXQ6XCJkdXBsaWNhdGUgZmllbGRzXCIgfmxvYyByZXZfZmxkX25hbWVzIHNleHBcbjs7XG5cbmxldCByZWNvcmRfZXh0cmFfZmllbGRzIGxvYyByZXZfZmxkX25hbWVzIHNleHAgPVxuICByZWNvcmRfc3VwZXJmbHVvdXNfZmllbGRzIH53aGF0OlwiZXh0cmEgZmllbGRzXCIgfmxvYyByZXZfZmxkX25hbWVzIHNleHBcbjs7XG5cbmxldCByZWMgcmVjb3JkX2dldF91bmRlZmluZWRfbG9vcCBmaWVsZHMgPSBmdW5jdGlvblxuICB8IFtdIC0+IFN0cmluZy5jb25jYXQgKExpc3QucmV2IGZpZWxkcykgfnNlcDpcIiBcIlxuICB8ICh0cnVlLCBmaWVsZCkgOjogcmVzdCAtPiByZWNvcmRfZ2V0X3VuZGVmaW5lZF9sb29wIChmaWVsZCA6OiBmaWVsZHMpIHJlc3RcbiAgfCBfIDo6IHJlc3QgLT4gcmVjb3JkX2dldF91bmRlZmluZWRfbG9vcCBmaWVsZHMgcmVzdFxuOztcblxubGV0IHJlY29yZF91bmRlZmluZWRfZWxlbWVudHMgbG9jIHNleHAgbHN0ID1cbiAgbGV0IHVuZGVmaW5lZCA9IHJlY29yZF9nZXRfdW5kZWZpbmVkX2xvb3AgW10gbHN0IGluXG4gIGxldCBtc2cgPVxuICAgIHNwcmludGYgXCIlc19vZl9zZXhwOiB0aGUgZm9sbG93aW5nIHJlY29yZCBlbGVtZW50cyB3ZXJlIHVuZGVmaW5lZDogJXNcIiBsb2MgdW5kZWZpbmVkXG4gIGluXG4gIG9mX3NleHBfZXJyb3IgbXNnIHNleHBcbjs7XG5cbmxldCByZWNvcmRfbGlzdF9pbnN0ZWFkX2F0b20gbG9jIHNleHAgPVxuICBsZXQgbXNnID0gbG9jIF4gXCJfb2Zfc2V4cDogbGlzdCBpbnN0ZWFkIG9mIGF0b20gZm9yIHJlY29yZCBleHBlY3RlZFwiIGluXG4gIG9mX3NleHBfZXJyb3IgbXNnIHNleHBcbjs7XG5cbmxldCByZWNvcmRfcG9seV9maWVsZF92YWx1ZSBsb2Mgc2V4cCA9XG4gIGxldCBtc2cgPVxuICAgIGxvY1xuICAgIF4gXCJfb2Zfc2V4cDogY2Fubm90IGNvbnZlcnQgdmFsdWVzIG9mIHR5cGVzIHJlc3VsdGluZyBmcm9tIHBvbHltb3JwaGljIHJlY29yZCBmaWVsZHNcIlxuICBpblxuICBvZl9zZXhwX2Vycm9yIG1zZyBzZXhwXG47O1xuXG4oKiBFcnJvcnMgY29uY2VybmluZyBwb2x5bW9ycGhpYyB2YXJpYW50cyAqKVxuXG5leGNlcHRpb24gTm9fdmFyaWFudF9tYXRjaFxuXG5sZXQgbm9fdmFyaWFudF9tYXRjaCAoKSA9IHJhaXNlIE5vX3ZhcmlhbnRfbWF0Y2hcblxubGV0IG5vX21hdGNoaW5nX3ZhcmlhbnRfZm91bmQgbG9jIHNleHAgPVxuICBvZl9zZXhwX2Vycm9yIChsb2MgXiBcIl9vZl9zZXhwOiBubyBtYXRjaGluZyB2YXJpYW50IGZvdW5kXCIpIHNleHBcbjs7XG5cbmxldCBwdGFnX25vX2FyZ3MgbG9jIHNleHAgPVxuICBvZl9zZXhwX2Vycm9yIChsb2MgXiBcIl9vZl9zZXhwOiBwb2x5bW9ycGhpYyB2YXJpYW50IGRvZXMgbm90IHRha2UgYXJndW1lbnRzXCIpIHNleHBcbjs7XG5cbmxldCBwdGFnX2luY29ycmVjdF9uX2FyZ3MgbG9jIGNuc3RyIHNleHAgPVxuICBsZXQgbXNnID1cbiAgICBzcHJpbnRmXG4gICAgICBcIiVzX29mX3NleHA6IHBvbHltb3JwaGljIHZhcmlhbnQgdGFnICVTIGhhcyBpbmNvcnJlY3QgbnVtYmVyIG9mIGFyZ3VtZW50c1wiXG4gICAgICBsb2NcbiAgICAgIGNuc3RyXG4gIGluXG4gIG9mX3NleHBfZXJyb3IgbXNnIHNleHBcbjs7XG5cbmxldCBwdGFnX3Rha2VzX2FyZ3MgbG9jIHNleHAgPVxuICBvZl9zZXhwX2Vycm9yIChsb2MgXiBcIl9vZl9zZXhwOiBwb2x5bW9ycGhpYyB2YXJpYW50IHRhZyB0YWtlcyBhbiBhcmd1bWVudFwiKSBzZXhwXG47O1xuXG5sZXQgbmVzdGVkX2xpc3RfaW52YWxpZF9wb2x5X3ZhciBsb2Mgc2V4cCA9XG4gIG9mX3NleHBfZXJyb3IgKGxvYyBeIFwiX29mX3NleHA6IGEgbmVzdGVkIGxpc3QgaXMgYW4gaW52YWxpZCBwb2x5bW9ycGhpYyB2YXJpYW50XCIpIHNleHBcbjs7XG5cbmxldCBlbXB0eV9saXN0X2ludmFsaWRfcG9seV92YXIgbG9jIHNleHAgPVxuICBvZl9zZXhwX2Vycm9yIChsb2MgXiBcIl9vZl9zZXhwOiB0aGUgZW1wdHkgbGlzdCBpcyBhbiBpbnZhbGlkIHBvbHltb3JwaGljIHZhcmlhbnRcIikgc2V4cFxuOztcblxubGV0IGVtcHR5X3R5cGUgbG9jIHNleHAgPVxuICBvZl9zZXhwX2Vycm9yIChsb2MgXiBcIl9vZl9zZXhwOiB0cnlpbmcgdG8gY29udmVydCBhbiBlbXB0eSB0eXBlXCIpIHNleHBcbjs7XG4iXX0=
