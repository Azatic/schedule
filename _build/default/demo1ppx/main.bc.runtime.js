// Generated by js_of_ocaml
//# buildInfo:effects=false, use-js-string=false, version=5.0.1
(function
   (Object)
   {typeof globalThis
    !==
    "object"
    &&
    (this
      ?get()
      :(Object.defineProperty
         (Object.prototype,"_T_",{configurable:true,get:get}),
        _T_));
    function get()
     {var global=this || self;
      global.globalThis = global;
      delete Object.prototype._T_}}
  (Object));
(function(globalThis)
   {"use strict";
    function caml_int64_is_zero(x){return + x.isZero()}
    function caml_str_repeat(n,s)
     {if(n == 0)return "";
      if(s.repeat)return s.repeat(n);
      var r="",l=0;
      for(;;)
       {if(n & 1)r += s;
        n >>= 1;
        if(n == 0)return r;
        s += s;
        l++;
        if(l == 9)s.slice(0,1)}}
    var caml_int64_offset=Math.pow(2,- 24);
    function caml_raise_constant(tag){throw tag}
    var caml_global_data=[0];
    function caml_raise_zero_divide()
     {caml_raise_constant(caml_global_data.Division_by_zero)}
    function MlInt64(lo,mi,hi)
     {this.lo = lo & 0xffffff;this.mi = mi & 0xffffff;this.hi = hi & 0xffff}
    MlInt64.prototype.caml_custom = "_j";
    MlInt64.prototype.copy
    =
    function(){return new MlInt64(this.lo,this.mi,this.hi)};
    MlInt64.prototype.ucompare
    =
    function(x)
     {if(this.hi > x.hi)return 1;
      if(this.hi < x.hi)return - 1;
      if(this.mi > x.mi)return 1;
      if(this.mi < x.mi)return - 1;
      if(this.lo > x.lo)return 1;
      if(this.lo < x.lo)return - 1;
      return 0};
    MlInt64.prototype.compare
    =
    function(x)
     {var hi=this.hi << 16,xhi=x.hi << 16;
      if(hi > xhi)return 1;
      if(hi < xhi)return - 1;
      if(this.mi > x.mi)return 1;
      if(this.mi < x.mi)return - 1;
      if(this.lo > x.lo)return 1;
      if(this.lo < x.lo)return - 1;
      return 0};
    MlInt64.prototype.neg
    =
    function()
     {var lo=- this.lo,mi=- this.mi + (lo >> 24),hi=- this.hi + (mi >> 24);
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.add
    =
    function(x)
     {var
       lo=this.lo + x.lo,
       mi=this.mi + x.mi + (lo >> 24),
       hi=this.hi + x.hi + (mi >> 24);
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.sub
    =
    function(x)
     {var
       lo=this.lo - x.lo,
       mi=this.mi - x.mi + (lo >> 24),
       hi=this.hi - x.hi + (mi >> 24);
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.mul
    =
    function(x)
     {var
       lo=this.lo * x.lo,
       mi=(lo * caml_int64_offset | 0) + this.mi * x.lo + this.lo * x.mi,
       hi=
        (mi * caml_int64_offset | 0)
        +
        this.hi
        *
        x.lo
        +
        this.mi
        *
        x.mi
        +
        this.lo
        *
        x.hi;
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.isZero
    =
    function(){return (this.lo | this.mi | this.hi) == 0};
    MlInt64.prototype.isNeg = function(){return this.hi << 16 < 0};
    MlInt64.prototype.and
    =
    function(x)
     {return new MlInt64(this.lo & x.lo,this.mi & x.mi,this.hi & x.hi)};
    MlInt64.prototype.or
    =
    function(x)
     {return new MlInt64(this.lo | x.lo,this.mi | x.mi,this.hi | x.hi)};
    MlInt64.prototype.xor
    =
    function(x)
     {return new MlInt64(this.lo ^ x.lo,this.mi ^ x.mi,this.hi ^ x.hi)};
    MlInt64.prototype.shift_left
    =
    function(s)
     {s = s & 63;
      if(s == 0)return this;
      if(s < 24)
       return new
               MlInt64
               (this.lo << s,
                this.mi << s | this.lo >> 24 - s,
                this.hi << s | this.mi >> 24 - s);
      if(s < 48)
       return new
               MlInt64
               (0,this.lo << s - 24,this.mi << s - 24 | this.lo >> 48 - s);
      return new MlInt64(0,0,this.lo << s - 48)};
    MlInt64.prototype.shift_right_unsigned
    =
    function(s)
     {s = s & 63;
      if(s == 0)return this;
      if(s < 24)
       return new
               MlInt64
               (this.lo >> s | this.mi << 24 - s,
                this.mi >> s | this.hi << 24 - s,
                this.hi >> s);
      if(s < 48)
       return new
               MlInt64
               (this.mi >> s - 24 | this.hi << 48 - s,this.hi >> s - 24,0);
      return new MlInt64(this.hi >> s - 48,0,0)};
    MlInt64.prototype.shift_right
    =
    function(s)
     {s = s & 63;
      if(s == 0)return this;
      var h=this.hi << 16 >> 16;
      if(s < 24)
       return new
               MlInt64
               (this.lo >> s | this.mi << 24 - s,
                this.mi >> s | h << 24 - s,
                this.hi << 16 >> s >>> 16);
      var sign=this.hi << 16 >> 31;
      if(s < 48)
       return new
               MlInt64
               (this.mi >> s - 24 | this.hi << 48 - s,
                this.hi << 16 >> s - 24 >> 16,
                sign & 0xffff);
      return new MlInt64(this.hi << 16 >> s - 32,sign,sign)};
    MlInt64.prototype.lsl1
    =
    function()
     {this.hi = this.hi << 1 | this.mi >> 23;
      this.mi = (this.mi << 1 | this.lo >> 23) & 0xffffff;
      this.lo = this.lo << 1 & 0xffffff};
    MlInt64.prototype.lsr1
    =
    function()
     {this.lo = (this.lo >>> 1 | this.mi << 23) & 0xffffff;
      this.mi = (this.mi >>> 1 | this.hi << 23) & 0xffffff;
      this.hi = this.hi >>> 1};
    MlInt64.prototype.udivmod
    =
    function(x)
     {var
       offset=0,
       modulus=this.copy(),
       divisor=x.copy(),
       quotient=new MlInt64(0,0,0);
      while(modulus.ucompare(divisor) > 0){offset++;divisor.lsl1()}
      while(offset >= 0)
       {offset--;
        quotient.lsl1();
        if(modulus.ucompare(divisor) >= 0)
         {quotient.lo++;modulus = modulus.sub(divisor)}
        divisor.lsr1()}
      return {quotient:quotient,modulus:modulus}};
    MlInt64.prototype.div
    =
    function(y)
     {var x=this;
      if(y.isZero())caml_raise_zero_divide();
      var sign=x.hi ^ y.hi;
      if(x.hi & 0x8000)x = x.neg();
      if(y.hi & 0x8000)y = y.neg();
      var q=x.udivmod(y).quotient;
      if(sign & 0x8000)q = q.neg();
      return q};
    MlInt64.prototype.mod
    =
    function(y)
     {var x=this;
      if(y.isZero())caml_raise_zero_divide();
      var sign=x.hi;
      if(x.hi & 0x8000)x = x.neg();
      if(y.hi & 0x8000)y = y.neg();
      var r=x.udivmod(y).modulus;
      if(sign & 0x8000)r = r.neg();
      return r};
    MlInt64.prototype.toInt = function(){return this.lo | this.mi << 24};
    MlInt64.prototype.toFloat
    =
    function()
     {return (this.hi << 16)
             *
             Math.pow(2,32)
             +
             this.mi
             *
             Math.pow(2,24)
             +
             this.lo};
    MlInt64.prototype.toArray
    =
    function()
     {return [this.hi >> 8,
              this.hi & 0xff,
              this.mi >> 16,
              this.mi >> 8 & 0xff,
              this.mi & 0xff,
              this.lo >> 16,
              this.lo >> 8 & 0xff,
              this.lo & 0xff]};
    MlInt64.prototype.lo32
    =
    function(){return this.lo | (this.mi & 0xff) << 24};
    MlInt64.prototype.hi32
    =
    function(){return this.mi >>> 8 & 0xffff | this.hi << 16};
    function caml_int64_of_int32(x)
     {return new MlInt64(x & 0xffffff,x >> 24 & 0xffffff,x >> 31 & 0xffff)}
    function caml_int64_to_int32(x){return x.toInt()}
    function caml_int64_is_negative(x){return + x.isNeg()}
    function caml_int64_neg(x){return x.neg()}
    function caml_subarray_to_jsbytes(a,i,len)
     {var f=String.fromCharCode;
      if(i == 0 && len <= 4096 && len == a.length)return f.apply(null,a);
      var s="";
      for(;0 < len;i += 1024,len -= 1024)
       s += f.apply(null,a.slice(i,i + Math.min(len,1024)));
      return s}
    function caml_convert_string_to_bytes(s)
     {if(s.t == 2)
       s.c += caml_str_repeat(s.l - s.c.length,"\0");
      else
       s.c = caml_subarray_to_jsbytes(s.c,0,s.c.length);
      s.t = 0}
    function caml_jsbytes_of_string(s)
     {s.t & 6 && caml_convert_string_to_bytes(s);return s.c}
    function caml_raise_with_arg(tag,arg){throw [0,tag,arg]}
    function jsoo_is_ascii(s)
     {if(s.length < 24)
       {for(var i=0;i < s.length;i++)if(s.charCodeAt(i) > 127)return false;
        return true}
      else
       return ! /[^\x00-\x7f]/.test(s)}
    function caml_utf16_of_utf8(s)
     {for(var b="",t="",c,c1,c2,v,i=0,l=s.length;i < l;i++)
       {c1 = s.charCodeAt(i);
        if(c1 < 0x80)
         {for(var j=i + 1;j < l && (c1 = s.charCodeAt(j)) < 0x80;j++);
          if(j - i > 512)
           {t.substr(0,1);b += t;t = "";b += s.slice(i,j)}
          else
           t += s.slice(i,j);
          if(j == l)break;
          i = j}
        v = 1;
        if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128)
         {c = c2 + (c1 << 6);
          if(c1 < 0xe0)
           {v = c - 0x3080;if(v < 0x80)v = 1}
          else
           {v = 2;
            if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128)
             {c = c2 + (c << 6);
              if(c1 < 0xf0)
               {v = c - 0xe2080;
                if(v < 0x800 || v >= 0xd7ff && v < 0xe000)v = 2}
              else
               {v = 3;
                if
                 (++i
                  <
                  l
                  &&
                  ((c2 = s.charCodeAt(i)) & - 64)
                  ==
                  128
                  &&
                  c1
                  <
                  0xf5)
                 {v = c2 - 0x3c82080 + (c << 6);
                  if(v < 0x10000 || v > 0x10ffff)v = 3}}}}}
        if(v < 4)
         {i -= v;t += "\ufffd"}
        else
         if(v > 0xffff)
          t += String.fromCharCode(0xd7c0 + (v >> 10),0xdc00 + (v & 0x3FF));
         else
          t += String.fromCharCode(v);
        if(t.length > 1024){t.substr(0,1);b += t;t = ""}}
      return b + t}
    function MlBytes(tag,contents,length)
     {this.t = tag;this.c = contents;this.l = length}
    MlBytes.prototype.toString
    =
    function()
     {switch(this.t)
       {case 9:return this.c;
        default:caml_convert_string_to_bytes(this);case 0:
         if(jsoo_is_ascii(this.c)){this.t = 9;return this.c}this.t = 8;
        case 8:return this.c
        }};
    MlBytes.prototype.toUtf16
    =
    function()
     {var r=this.toString();
      if(this.t == 9)return r;
      return caml_utf16_of_utf8(r)};
    MlBytes.prototype.slice
    =
    function()
     {var content=this.t == 4?this.c.slice():this.c;
      return new MlBytes(this.t,content,this.l)};
    function caml_bytes_of_jsbytes(s){return new MlBytes(0,s,s.length)}
    function caml_string_of_jsbytes(s){return caml_bytes_of_jsbytes(s)}
    function caml_raise_with_string(tag,msg)
     {caml_raise_with_arg(tag,caml_string_of_jsbytes(msg))}
    function caml_invalid_argument(msg)
     {caml_raise_with_string(caml_global_data.Invalid_argument,msg)}
    function caml_parse_format(fmt)
     {fmt = caml_jsbytes_of_string(fmt);
      var len=fmt.length;
      if(len > 31)caml_invalid_argument("format_int: format too long");
      var
       f=
        {justify:"+",
         signstyle:"-",
         filler:" ",
         alternate:false,
         base:0,
         signedconv:false,
         width:0,
         uppercase:false,
         sign:1,
         prec:- 1,
         conv:"f"};
      for(var i=0;i < len;i++)
       {var c=fmt.charAt(i);
        switch(c)
         {case "-":f.justify = "-";break;
          case "+":
          case " ":f.signstyle = c;break;
          case "0":f.filler = "0";break;
          case "#":f.alternate = true;break;
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
           f.width = 0;
           while(c = fmt.charCodeAt(i) - 48,c >= 0 && c <= 9)
            {f.width = f.width * 10 + c;i++}
           i--;
           break;
          case ".":
           f.prec = 0;
           i++;
           while(c = fmt.charCodeAt(i) - 48,c >= 0 && c <= 9)
            {f.prec = f.prec * 10 + c;i++}
           i--;
          case "d":
          case "i":f.signedconv = true;
          case "u":f.base = 10;break;
          case "x":f.base = 16;break;
          case "X":f.base = 16;f.uppercase = true;break;
          case "o":f.base = 8;break;
          case "e":
          case "f":
          case "g":f.signedconv = true;f.conv = c;break;
          case "E":
          case "F":
          case "G":
           f.signedconv = true;
           f.uppercase = true;
           f.conv = c.toLowerCase();
           break
          }}
      return f}
    function caml_finish_formatting(f,rawbuffer)
     {if(f.uppercase)rawbuffer = rawbuffer.toUpperCase();
      var len=rawbuffer.length;
      if(f.signedconv && (f.sign < 0 || f.signstyle != "-"))len++;
      if(f.alternate){if(f.base == 8)len += 1;if(f.base == 16)len += 2}
      var buffer="";
      if(f.justify == "+" && f.filler == " ")
       for(var i=len;i < f.width;i++)buffer += " ";
      if(f.signedconv)
       if(f.sign < 0)
        buffer += "-";
       else
        if(f.signstyle != "-")buffer += f.signstyle;
      if(f.alternate && f.base == 8)buffer += "0";
      if(f.alternate && f.base == 16)buffer += f.uppercase?"0X":"0x";
      if(f.justify == "+" && f.filler == "0")
       for(var i=len;i < f.width;i++)buffer += "0";
      buffer += rawbuffer;
      if(f.justify == "-")for(var i=len;i < f.width;i++)buffer += " ";
      return caml_string_of_jsbytes(buffer)}
    function caml_int64_format(fmt,x)
     {var f=caml_parse_format(fmt);
      if(f.signedconv && caml_int64_is_negative(x))
       {f.sign = - 1;x = caml_int64_neg(x)}
      var
       buffer="",
       wbase=caml_int64_of_int32(f.base),
       cvtbl="0123456789abcdef";
      do
       {var p=x.udivmod(wbase);
        x = p.quotient;
        buffer = cvtbl.charAt(caml_int64_to_int32(p.modulus)) + buffer}
      while
       (! caml_int64_is_zero(x));
      if(f.prec >= 0)
       {f.filler = " ";
        var n=f.prec - buffer.length;
        if(n > 0)buffer = caml_str_repeat(n,"0") + buffer}
      return caml_finish_formatting(f,buffer)}
    function caml_expm1_float(x){return Math.expm1(x)}
    function caml_ml_condition_broadcast(t){return 0}
    function caml_jsstring_of_string(s){return s.toUtf16()}
    function fs_node_supported()
     {return typeof globalThis.process
             !==
             "undefined"
             &&
             typeof globalThis.process.versions
             !==
             "undefined"
             &&
             typeof globalThis.process.versions.node
             !==
             "undefined"}
    function make_path_is_absolute()
     {function posix(path)
       {if(path.charAt(0) === "/")return ["",path.substring(1)];return}
      function win32(path)
       {var
         splitDeviceRe=
          /^([a-zA-Z]:|[\\/]{2}[^\\/]+[\\/]+[^\\/]+)?([\\/])?([\s\S]*?)$/,
         result=splitDeviceRe.exec(path),
         device=result[1] || "",
         isUnc=Boolean(device && device.charAt(1) !== ":");
        if(Boolean(result[2] || isUnc))
         {var root=result[1] || "",sep=result[2] || "";
          return [root,path.substring(root.length + sep.length)]}
        return}
      return fs_node_supported()
              &&
              globalThis.process
              &&
              globalThis.process.platform
              ?globalThis.process.platform === "win32"?win32:posix
              :posix}
    var path_is_absolute=make_path_is_absolute();
    function caml_trailing_slash(name)
     {return name.slice(- 1) !== "/"?name + "/":name}
    if(fs_node_supported() && globalThis.process && globalThis.process.cwd)
     var caml_current_dir=globalThis.process.cwd().replace(/\\/g,"/");
    else
     var caml_current_dir="/static";
    caml_current_dir = caml_trailing_slash(caml_current_dir);
    function caml_make_path(name)
     {name = caml_jsstring_of_string(name);
      if(! path_is_absolute(name))name = caml_current_dir + name;
      var comp0=path_is_absolute(name),comp=comp0[1].split("/"),ncomp=[];
      for(var i=0;i < comp.length;i++)
       switch(comp[i])
        {case "..":if(ncomp.length > 1)ncomp.pop();break;
         case ".":break;
         case "":break;
         default:ncomp.push(comp[i]);break}
      ncomp.unshift(comp0[0]);
      ncomp.orig = name;
      return ncomp}
    function caml_utf8_of_utf16(s)
     {for(var b="",t=b,c,d,i=0,l=s.length;i < l;i++)
       {c = s.charCodeAt(i);
        if(c < 0x80)
         {for(var j=i + 1;j < l && (c = s.charCodeAt(j)) < 0x80;j++);
          if(j - i > 512)
           {t.substr(0,1);b += t;t = "";b += s.slice(i,j)}
          else
           t += s.slice(i,j);
          if(j == l)break;
          i = j}
        if(c < 0x800)
         {t += String.fromCharCode(0xc0 | c >> 6);
          t += String.fromCharCode(0x80 | c & 0x3f)}
        else
         if(c < 0xd800 || c >= 0xdfff)
          t
          +=
          String.fromCharCode
           (0xe0 | c >> 12,0x80 | c >> 6 & 0x3f,0x80 | c & 0x3f);
         else
          if
           (c
            >=
            0xdbff
            ||
            i
            +
            1
            ==
            l
            ||
            (d = s.charCodeAt(i + 1))
            <
            0xdc00
            ||
            d
            >
            0xdfff)
           t += "\xef\xbf\xbd";
          else
           {i++;
            c = (c << 10) + d - 0x35fdc00;
            t
            +=
            String.fromCharCode
             (0xf0 | c >> 18,
              0x80 | c >> 12 & 0x3f,
              0x80 | c >> 6 & 0x3f,
              0x80 | c & 0x3f)}
        if(t.length > 1024){t.substr(0,1);b += t;t = ""}}
      return b + t}
    function caml_bytes_of_utf16_jsstring(s)
     {var tag=9;
      if(! jsoo_is_ascii(s))tag = 8,s = caml_utf8_of_utf16(s);
      return new MlBytes(tag,s,s.length)}
    function caml_string_of_jsstring(s)
     {return caml_bytes_of_utf16_jsstring(s)}
    var
     unix_error=
      ["E2BIG",
       "EACCES",
       "EAGAIN",
       "EBADF",
       "EBUSY",
       "ECHILD",
       "EDEADLK",
       "EDOM",
       "EEXIST",
       "EFAULT",
       "EFBIG",
       "EINTR",
       "EINVAL",
       "EIO",
       "EISDIR",
       "EMFILE",
       "EMLINK",
       "ENAMETOOLONG",
       "ENFILE",
       "ENODEV",
       "ENOENT",
       "ENOEXEC",
       "ENOLCK",
       "ENOMEM",
       "ENOSPC",
       "ENOSYS",
       "ENOTDIR",
       "ENOTEMPTY",
       "ENOTTY",
       "ENXIO",
       "EPERM",
       "EPIPE",
       "ERANGE",
       "EROFS",
       "ESPIPE",
       "ESRCH",
       "EXDEV",
       "EWOULDBLOCK",
       "EINPROGRESS",
       "EALREADY",
       "ENOTSOCK",
       "EDESTADDRREQ",
       "EMSGSIZE",
       "EPROTOTYPE",
       "ENOPROTOOPT",
       "EPROTONOSUPPORT",
       "ESOCKTNOSUPPORT",
       "EOPNOTSUPP",
       "EPFNOSUPPORT",
       "EAFNOSUPPORT",
       "EADDRINUSE",
       "EADDRNOTAVAIL",
       "ENETDOWN",
       "ENETUNREACH",
       "ENETRESET",
       "ECONNABORTED",
       "ECONNRESET",
       "ENOBUFS",
       "EISCONN",
       "ENOTCONN",
       "ESHUTDOWN",
       "ETOOMANYREFS",
       "ETIMEDOUT",
       "ECONNREFUSED",
       "EHOSTDOWN",
       "EHOSTUNREACH",
       "ELOOP",
       "EOVERFLOW"];
    function make_unix_err_args(code,syscall,path,errno)
     {var variant=unix_error.indexOf(code);
      if(variant < 0){if(errno == null)errno = - 9999;variant = [0,errno]}
      var
       args=
        [variant,
         caml_string_of_jsstring(syscall || ""),
         caml_string_of_jsstring(path || "")];
      return args}
    var caml_named_values={};
    function caml_named_value(nm){return caml_named_values[nm]}
    function caml_raise_with_args(tag,args){throw [0,tag].concat(args)}
    function caml_is_ml_bytes(s){return s instanceof MlBytes}
    function caml_is_ml_string(s){return caml_is_ml_bytes(s)}
    function caml_bytes_of_array(a)
     {if(! (a instanceof Uint8Array))a = new Uint8Array(a);
      return new MlBytes(4,a,a.length)}
    function caml_bytes_of_string(s){return s}
    function caml_raise_sys_error(msg)
     {caml_raise_with_string(caml_global_data.Sys_error,msg)}
    function caml_raise_no_such_file(name)
     {caml_raise_sys_error(name + ": No such file or directory")}
    function caml_convert_bytes_to_array(s)
     {var a=new Uint8Array(s.l),b=s.c,l=b.length,i=0;
      for(;i < l;i++)a[i] = b.charCodeAt(i);
      for(l = s.l;i < l;i++)a[i] = 0;
      s.c = a;
      s.t = 4;
      return a}
    function caml_uint8_array_of_bytes(s)
     {if(s.t != 4)caml_convert_bytes_to_array(s);return s.c}
    function caml_create_bytes(len)
     {if(len < 0)caml_invalid_argument("Bytes.create");
      return new MlBytes(len?2:9,"",len)}
    function caml_ml_bytes_length(s){return s.l}
    function caml_blit_bytes(s1,i1,s2,i2,len)
     {if(len == 0)return 0;
      if(i2 == 0 && (len >= s2.l || s2.t == 2 && len >= s2.c.length))
       {s2.c
        =
        s1.t == 4
         ?caml_subarray_to_jsbytes(s1.c,i1,len)
         :i1 == 0 && s1.c.length == len?s1.c:s1.c.substr(i1,len);
        s2.t = s2.c.length == s2.l?0:2}
      else
       if(s2.t == 2 && i2 == s2.c.length)
        {s2.c
         +=
         s1.t == 4
          ?caml_subarray_to_jsbytes(s1.c,i1,len)
          :i1 == 0 && s1.c.length == len?s1.c:s1.c.substr(i1,len);
         s2.t = s2.c.length == s2.l?0:2}
       else
        {if(s2.t != 4)caml_convert_bytes_to_array(s2);
         var c1=s1.c,c2=s2.c;
         if(s1.t == 4)
          if(i2 <= i1)
           for(var i=0;i < len;i++)c2[i2 + i] = c1[i1 + i];
          else
           for(var i=len - 1;i >= 0;i--)c2[i2 + i] = c1[i1 + i];
         else
          {var l=Math.min(len,c1.length - i1);
           for(var i=0;i < l;i++)c2[i2 + i] = c1.charCodeAt(i1 + i);
           for(;i < len;i++)c2[i2 + i] = 0}}
      return 0}
    function MlFile(){}
    function MlFakeFile(content){this.data = content}
    MlFakeFile.prototype = new MlFile();
    MlFakeFile.prototype.constructor = MlFakeFile;
    MlFakeFile.prototype.truncate
    =
    function(len)
     {var old=this.data;
      this.data = caml_create_bytes(len | 0);
      caml_blit_bytes(old,0,this.data,0,len)};
    MlFakeFile.prototype.length
    =
    function(){return caml_ml_bytes_length(this.data)};
    MlFakeFile.prototype.write
    =
    function(offset,buf,pos,len)
     {var clen=this.length();
      if(offset + len >= clen)
       {var new_str=caml_create_bytes(offset + len),old_data=this.data;
        this.data = new_str;
        caml_blit_bytes(old_data,0,this.data,0,clen)}
      caml_blit_bytes(caml_bytes_of_array(buf),pos,this.data,offset,len);
      return 0};
    MlFakeFile.prototype.read
    =
    function(offset,buf,pos,len)
     {var clen=this.length();
      if(offset + len >= clen)len = clen - offset;
      if(len)
       {var data=caml_create_bytes(len | 0);
        caml_blit_bytes(this.data,offset,data,0,len);
        buf.set(caml_uint8_array_of_bytes(data),pos)}
      return len};
    function MlFakeFd(name,file,flags)
     {this.file = file;this.name = name;this.flags = flags}
    MlFakeFd.prototype.err_closed
    =
    function()
     {caml_raise_sys_error(this.name + ": file descriptor already closed")};
    MlFakeFd.prototype.length
    =
    function(){if(this.file)return this.file.length();this.err_closed()};
    MlFakeFd.prototype.write
    =
    function(offset,buf,pos,len)
     {if(this.file)return this.file.write(offset,buf,pos,len);
      this.err_closed()};
    MlFakeFd.prototype.read
    =
    function(offset,buf,pos,len)
     {if(this.file)return this.file.read(offset,buf,pos,len);
      this.err_closed()};
    MlFakeFd.prototype.close = function(){this.file = undefined};
    function MlFakeDevice(root,f)
     {this.content = {};this.root = root;this.lookupFun = f}
    MlFakeDevice.prototype.nm = function(name){return this.root + name};
    MlFakeDevice.prototype.create_dir_if_needed
    =
    function(name)
     {var comp=name.split("/"),res="";
      for(var i=0;i < comp.length - 1;i++)
       {res += comp[i] + "/";
        if(this.content[res])continue;
        this.content[res] = Symbol("directory")}};
    MlFakeDevice.prototype.slash
    =
    function(name){return /\/$/.test(name)?name:name + "/"};
    MlFakeDevice.prototype.lookup
    =
    function(name)
     {if(! this.content[name] && this.lookupFun)
       {var
         res=
          this.lookupFun
           (caml_string_of_jsbytes(this.root),caml_string_of_jsbytes(name));
        if(res !== 0)
         {this.create_dir_if_needed(name);
          this.content[name] = new MlFakeFile(caml_bytes_of_string(res[1]))}}};
    MlFakeDevice.prototype.exists
    =
    function(name)
     {if(name == "")return 1;
      var name_slash=this.slash(name);
      if(this.content[name_slash])return 1;
      this.lookup(name);
      return this.content[name]?1:0};
    MlFakeDevice.prototype.mkdir
    =
    function(name,mode,raise_unix)
     {var unix_error=raise_unix && caml_named_value("Unix.Unix_error");
      if(this.exists(name))
       if(unix_error)
        caml_raise_with_args
         (unix_error,make_unix_err_args("EEXIST","mkdir",this.nm(name)));
       else
        caml_raise_sys_error(name + ": File exists");
      var parent=/^(.*)\/[^/]+/.exec(name);
      parent = parent && parent[1] || "";
      if(! this.exists(parent))
       if(unix_error)
        caml_raise_with_args
         (unix_error,make_unix_err_args("ENOENT","mkdir",this.nm(parent)));
       else
        caml_raise_sys_error(parent + ": No such file or directory");
      if(! this.is_dir(parent))
       if(unix_error)
        caml_raise_with_args
         (unix_error,make_unix_err_args("ENOTDIR","mkdir",this.nm(parent)));
       else
        caml_raise_sys_error(parent + ": Not a directory");
      this.create_dir_if_needed(this.slash(name))};
    MlFakeDevice.prototype.rmdir
    =
    function(name,raise_unix)
     {var
       unix_error=raise_unix && caml_named_value("Unix.Unix_error"),
       name_slash=name == ""?"":this.slash(name),
       r=new RegExp("^" + name_slash + "([^/]+)");
      if(! this.exists(name))
       if(unix_error)
        caml_raise_with_args
         (unix_error,make_unix_err_args("ENOENT","rmdir",this.nm(name)));
       else
        caml_raise_sys_error(name + ": No such file or directory");
      if(! this.is_dir(name))
       if(unix_error)
        caml_raise_with_args
         (unix_error,make_unix_err_args("ENOTDIR","rmdir",this.nm(name)));
       else
        caml_raise_sys_error(name + ": Not a directory");
      for(var n in this.content)
       if(n.match(r))
        if(unix_error)
         caml_raise_with_args
          (unix_error,make_unix_err_args("ENOTEMPTY","rmdir",this.nm(name)));
        else
         caml_raise_sys_error(this.nm(name) + ": Directory not empty");
      delete this.content[name_slash]};
    MlFakeDevice.prototype.readdir
    =
    function(name)
     {var name_slash=name == ""?"":this.slash(name);
      if(! this.exists(name))
       caml_raise_sys_error(name + ": No such file or directory");
      if(! this.is_dir(name))caml_raise_sys_error(name + ": Not a directory");
      var r=new RegExp("^" + name_slash + "([^/]+)"),seen={},a=[];
      for(var n in this.content)
       {var m=n.match(r);
        if(m && ! seen[m[1]]){seen[m[1]] = true;a.push(m[1])}}
      return a};
    MlFakeDevice.prototype.opendir
    =
    function(name,raise_unix)
     {var
       unix_error=raise_unix && caml_named_value("Unix.Unix_error"),
       a=this.readdir(name),
       c=false,
       i=0;
      return {readSync:
              function()
               {if(c)
                 if(unix_error)
                  caml_raise_with_args
                   (unix_error,
                    make_unix_err_args("EBADF","closedir",this.nm(name)));
                 else
                  caml_raise_sys_error(name + ": closedir failed");
                if(i == a.length)return null;
                var entry=a[i];
                i++;
                return {name:entry}},
              closeSync:
              function()
               {if(c)
                 if(unix_error)
                  caml_raise_with_args
                   (unix_error,
                    make_unix_err_args("EBADF","closedir",this.nm(name)));
                 else
                  caml_raise_sys_error(name + ": closedir failed");
                c = true;
                a = []}}};
    MlFakeDevice.prototype.is_dir
    =
    function(name)
     {if(name == "")return true;
      var name_slash=this.slash(name);
      return this.content[name_slash]?1:0};
    MlFakeDevice.prototype.unlink
    =
    function(name)
     {var ok=this.content[name]?true:false;
      delete this.content[name];
      return ok};
    MlFakeDevice.prototype.open
    =
    function(name,f)
     {var file;
      if(f.rdonly && f.wronly)
       caml_raise_sys_error
        (this.nm(name)
         +
         " : flags Open_rdonly and Open_wronly are not compatible");
      if(f.text && f.binary)
       caml_raise_sys_error
        (this.nm(name)
         +
         " : flags Open_text and Open_binary are not compatible");
      this.lookup(name);
      if(this.content[name])
       {if(this.is_dir(name))
         caml_raise_sys_error(this.nm(name) + " : is a directory");
        if(f.create && f.excl)
         caml_raise_sys_error(this.nm(name) + " : file already exists");
        file = this.content[name];
        if(f.truncate)file.truncate()}
      else
       if(f.create)
        {this.create_dir_if_needed(name);
         this.content[name] = new MlFakeFile(caml_create_bytes(0));
         file = this.content[name]}
       else
        caml_raise_no_such_file(this.nm(name));
      return new MlFakeFd(this.nm(name),file,f)};
    MlFakeDevice.prototype.open
    =
    function(name,f)
     {var file;
      if(f.rdonly && f.wronly)
       caml_raise_sys_error
        (this.nm(name)
         +
         " : flags Open_rdonly and Open_wronly are not compatible");
      if(f.text && f.binary)
       caml_raise_sys_error
        (this.nm(name)
         +
         " : flags Open_text and Open_binary are not compatible");
      this.lookup(name);
      if(this.content[name])
       {if(this.is_dir(name))
         caml_raise_sys_error(this.nm(name) + " : is a directory");
        if(f.create && f.excl)
         caml_raise_sys_error(this.nm(name) + " : file already exists");
        file = this.content[name];
        if(f.truncate)file.truncate()}
      else
       if(f.create)
        {this.create_dir_if_needed(name);
         this.content[name] = new MlFakeFile(caml_create_bytes(0));
         file = this.content[name]}
       else
        caml_raise_no_such_file(this.nm(name));
      return new MlFakeFd(this.nm(name),file,f)};
    MlFakeDevice.prototype.register
    =
    function(name,content)
     {var file;
      if(this.content[name])
       caml_raise_sys_error(this.nm(name) + " : file already exists");
      if(caml_is_ml_bytes(content))file = new MlFakeFile(content);
      if(caml_is_ml_string(content))
       file = new MlFakeFile(caml_bytes_of_string(content));
      else
       if(content instanceof Array)
        file = new MlFakeFile(caml_bytes_of_array(content));
       else
        if(typeof content === "string")
         file = new MlFakeFile(caml_bytes_of_jsbytes(content));
        else
         if(content.toString)
          {var
            bytes=
             caml_bytes_of_string(caml_string_of_jsstring(content.toString()));
           file = new MlFakeFile(bytes)}
      if(file)
       {this.create_dir_if_needed(name);this.content[name] = file}
      else
       caml_raise_sys_error
        (this.nm(name) + " : registering file with invalid content type")};
    MlFakeDevice.prototype.constructor = MlFakeDevice;
    function caml_ml_string_length(s){return caml_ml_bytes_length(s)}
    function caml_bytes_unsafe_get(s,i)
     {switch(s.t & 6)
       {default:if(i >= s.c.length)return 0;case 0:return s.c.charCodeAt(i);
        case 4:return s.c[i]
        }}
    function caml_string_unsafe_get(s,i){return caml_bytes_unsafe_get(s,i)}
    function caml_uint8_array_of_string(s)
     {var l=caml_ml_string_length(s),a=new Array(l),i=0;
      for(;i < l;i++)a[i] = caml_string_unsafe_get(s,i);
      return a}
    function caml_bytes_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_bytes_unsafe_set(s,i,c)
     {c &= 0xff;
      if(s.t != 4)
       {if(i == s.c.length)
         {s.c += String.fromCharCode(c);if(i + 1 == s.l)s.t = 0;return 0}
        caml_convert_bytes_to_array(s)}
      s.c[i] = c;
      return 0}
    function caml_bytes_set(s,i,c)
     {if(i >>> 0 >= s.l)caml_bytes_bound_error();
      return caml_bytes_unsafe_set(s,i,c)}
    function MlNodeFd(fd,flags)
     {this.fs = require("fs");this.fd = fd;this.flags = flags}
    MlNodeFd.prototype = new MlFile();
    MlNodeFd.prototype.constructor = MlNodeFd;
    MlNodeFd.prototype.truncate
    =
    function(len)
     {try
       {this.fs.ftruncateSync(this.fd,len | 0)}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeFd.prototype.length
    =
    function()
     {try
       {return this.fs.fstatSync(this.fd).size}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeFd.prototype.write
    =
    function(offset,buf,buf_offset,len)
     {try
       {if(this.flags.isCharacterDevice)
         this.fs.writeSync(this.fd,buf,buf_offset,len);
        else
         this.fs.writeSync(this.fd,buf,buf_offset,len,offset)}
      catch(err){caml_raise_sys_error(err.toString())}
      return 0};
    MlNodeFd.prototype.read
    =
    function(offset,a,buf_offset,len)
     {try
       {if(this.flags.isCharacterDevice)
         var read=this.fs.readSync(this.fd,a,buf_offset,len);
        else
         var read=this.fs.readSync(this.fd,a,buf_offset,len,offset);
        return read}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeFd.prototype.close
    =
    function()
     {try
       {this.fs.closeSync(this.fd);return 0}
      catch(err){caml_raise_sys_error(err.toString())}};
    function MlNodeDevice(root){this.fs = require("fs");this.root = root}
    MlNodeDevice.prototype.nm = function(name){return this.root + name};
    MlNodeDevice.prototype.exists
    =
    function(name)
     {try {return this.fs.existsSync(this.nm(name))?1:0}catch(err){return 0}};
    MlNodeDevice.prototype.mkdir
    =
    function(name,mode,raise_unix)
     {try
       {this.fs.mkdirSync(this.nm(name),{mode:mode});return 0}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.rmdir
    =
    function(name,raise_unix)
     {try
       {this.fs.rmdirSync(this.nm(name));return 0}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.readdir
    =
    function(name,raise_unix)
     {try
       {return this.fs.readdirSync(this.nm(name))}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.is_dir
    =
    function(name)
     {try
       {return this.fs.statSync(this.nm(name)).isDirectory()?1:0}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.unlink
    =
    function(name,raise_unix)
     {try
       {var b=this.fs.existsSync(this.nm(name))?1:0;
        this.fs.unlinkSync(this.nm(name));
        return b}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.open
    =
    function(name,f,raise_unix)
     {var consts=require("constants"),res=0;
      for(var key in f)
       switch(key)
        {case "rdonly":res |= consts.O_RDONLY;break;
         case "wronly":res |= consts.O_WRONLY;break;
         case "append":res |= consts.O_WRONLY | consts.O_APPEND;break;
         case "create":res |= consts.O_CREAT;break;
         case "truncate":res |= consts.O_TRUNC;break;
         case "excl":res |= consts.O_EXCL;break;
         case "binary":res |= consts.O_BINARY;break;
         case "text":res |= consts.O_TEXT;break;
         case "nonblock":res |= consts.O_NONBLOCK;break
         }
      try
       {var
         fd=this.fs.openSync(this.nm(name),res),
         isCharacterDevice=
          this.fs.lstatSync(this.nm(name)).isCharacterDevice();
        f.isCharacterDevice = isCharacterDevice;
        return new MlNodeFd(fd,f)}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.rename
    =
    function(o,n,raise_unix)
     {try
       {this.fs.renameSync(this.nm(o),this.nm(n))}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.stat
    =
    function(name,raise_unix)
     {try
       {var js_stats=this.fs.statSync(this.nm(name));
        return this.stats_from_js(js_stats)}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.lstat
    =
    function(name,raise_unix)
     {try
       {var js_stats=this.fs.lstatSync(this.nm(name));
        return this.stats_from_js(js_stats)}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.symlink
    =
    function(to_dir,target,path,raise_unix)
     {try
       {this.fs.symlinkSync(this.nm(target),this.nm(path),to_dir?"dir":"file");
        return 0}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.readlink
    =
    function(name,raise_unix)
     {try
       {var link=this.fs.readlinkSync(this.nm(name),"utf8");
        return caml_string_of_jsstring(link)}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.opendir
    =
    function(name,raise_unix)
     {try
       {return this.fs.opendirSync(this.nm(name))}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.raise_nodejs_error
    =
    function(err,raise_unix)
     {var unix_error=caml_named_value("Unix.Unix_error");
      if(raise_unix && unix_error)
       {var args=make_unix_err_args(err.code,err.syscall,err.path,err.errno);
        caml_raise_with_args(unix_error,args)}
      else
       caml_raise_sys_error(err.toString())};
    MlNodeDevice.prototype.stats_from_js
    =
    function(js_stats)
     {var file_kind;
      if(js_stats.isFile())
       file_kind = 0;
      else
       if(js_stats.isDirectory())
        file_kind = 1;
       else
        if(js_stats.isCharacterDevice())
         file_kind = 2;
        else
         if(js_stats.isBlockDevice())
          file_kind = 3;
         else
          if(js_stats.isSymbolicLink())
           file_kind = 4;
          else
           if(js_stats.isFIFO())
            file_kind = 5;
           else
            if(js_stats.isSocket())file_kind = 6;
      return [0,
              js_stats.dev,
              js_stats.ino,
              file_kind,
              js_stats.mode,
              js_stats.nlink,
              js_stats.uid,
              js_stats.gid,
              js_stats.rdev,
              js_stats.size,
              js_stats.atimeMs,
              js_stats.mtimeMs,
              js_stats.ctimeMs]};
    MlNodeDevice.prototype.constructor = MlNodeDevice;
    function caml_get_root(path)
     {var x=path_is_absolute(path);if(! x)return;return x[0] + "/"}
    function caml_failwith(msg)
     {if(! caml_global_data.Failure)
       caml_global_data.Failure = [248,caml_string_of_jsbytes("Failure"),- 3];
      caml_raise_with_string(caml_global_data.Failure,msg)}
    var
     caml_root=
      caml_get_root(caml_current_dir)
      ||
      caml_failwith("unable to compute caml_root"),
     jsoo_mount_point=[];
    if(fs_node_supported())
     jsoo_mount_point.push
      ({path:caml_root,device:new MlNodeDevice(caml_root)});
    else
     jsoo_mount_point.push
      ({path:caml_root,device:new MlFakeDevice(caml_root)});
    jsoo_mount_point.push
     ({path:"/static/",device:new MlFakeDevice("/static/")});
    function resolve_fs_device(name)
     {var
       path=caml_make_path(name),
       name=path.join("/"),
       name_slash=caml_trailing_slash(name),
       res;
      for(var i=0;i < jsoo_mount_point.length;i++)
       {var m=jsoo_mount_point[i];
        if
         (name_slash.search(m.path)
          ==
          0
          &&
          (! res || res.path.length < m.path.length))
         res
         =
         {path:m.path,
          device:m.device,
          rest:name.substring(m.path.length,name.length)}}
      if(! res && fs_node_supported())
       {var root=caml_get_root(name);
        if(root && root.match(/^[a-zA-Z]:\/$/))
         {var m={path:root,device:new MlNodeDevice(root)};
          jsoo_mount_point.push(m);
          res
          =
          {path:m.path,
           device:m.device,
           rest:name.substring(m.path.length,name.length)}}}
      if(res)return res;
      caml_raise_sys_error("no device found for " + name_slash)}
    function caml_sys_is_directory(name)
     {var root=resolve_fs_device(name),a=root.device.is_dir(root.rest);
      return a?1:0}
    function caml_raise_not_found()
     {caml_raise_constant(caml_global_data.Not_found)}
    function caml_sys_getenv(name)
     {var process=globalThis.process,n=caml_jsstring_of_string(name);
      if(process && process.env && process.env[n] != undefined)
       return caml_string_of_jsstring(process.env[n]);
      if(globalThis.jsoo_static_env && globalThis.jsoo_static_env[n])
       return caml_string_of_jsstring(globalThis.jsoo_static_env[n]);
      caml_raise_not_found()}
    function shift_right_nat(nat1,ofs1,len1,nat2,ofs2,nbits)
     {if(nbits == 0){nat2.data[ofs2] = 0;return 0}
      var wrap=0;
      for(var i=len1 - 1;i >= 0;i--)
       {var a=nat1.data[ofs1 + i] >>> 0;
        nat1.data[ofs1 + i] = a >>> nbits | wrap;
        wrap = a << 32 - nbits}
      nat2.data[ofs2] = wrap;
      return 0}
    var caml_gr_state;
    function caml_gr_state_get()
     {if(caml_gr_state)return caml_gr_state;
      throw [0,
             caml_named_value("Graphics.Graphic_failure"),
             caml_string_of_jsbytes("Not initialized")]}
    function caml_gr_point_color(x,y)
     {var
       s=caml_gr_state_get(),
       im=s.context.getImageData(x,s.height - y,1,1),
       d=im.data;
      return (d[0] << 16) + (d[1] << 8) + d[2]}
    var MlObjectTable;
    if(typeof globalThis.WeakMap === "undefined")
     MlObjectTable
     =
     function()
       {function NaiveLookup(objs){this.objs = objs}
        NaiveLookup.prototype.get
        =
        function(v)
         {for(var i=0;i < this.objs.length;i++)if(this.objs[i] === v)return i};
        NaiveLookup.prototype.set = function(){};
        return function()
         {this.objs = [];this.lookup = new NaiveLookup(this.objs)}}
      ();
    else
     MlObjectTable
     =
     function(){this.objs = [];this.lookup = new (globalThis.WeakMap)()};
    MlObjectTable.prototype.store
    =
    function(v){this.lookup.set(v,this.objs.length);this.objs.push(v)};
    MlObjectTable.prototype.recall
    =
    function(v)
     {var i=this.lookup.get(v);
      return i === undefined?undefined:this.objs.length - i};
    function caml_sys_rename(o,n)
     {var o_root=resolve_fs_device(o),n_root=resolve_fs_device(n);
      if(o_root.device != n_root.device)
       caml_failwith
        ("caml_sys_rename: cannot move file between two filesystem");
      if(! o_root.device.rename)
       caml_failwith("caml_sys_rename: no implemented");
      o_root.device.rename(o_root.rest,n_root.rest)}
    function caml_log10_float(x){return Math.log10(x)}
    var caml_runtime_warnings=0;
    function caml_ml_enable_runtime_warnings(bool)
     {caml_runtime_warnings = bool;return 0}
    function caml_classify_float(x)
     {if(isFinite(x))
       {if(Math.abs(x) >= 2.2250738585072014e-308)return 0;
        if(x != 0)return 1;
        return 2}
      return isNaN(x)?4:3}
    var caml_ml_channels=new Array();
    function caml_refill(chan)
     {if(chan.refill != null)
       {var str=chan.refill(),str_a=caml_uint8_array_of_string(str);
        if(str_a.length == 0)
         chan.refill = null;
        else
         {if(chan.buffer.length < chan.buffer_max + str_a.length)
           {var b=new Uint8Array(chan.buffer_max + str_a.length);
            b.set(chan.buffer);
            chan.buffer = b}
          chan.buffer.set(str_a,chan.buffer_max);
          chan.offset += str_a.length;
          chan.buffer_max += str_a.length}}
      else
       {var
         nread=
          chan.file.read
           (chan.offset,
            chan.buffer,
            chan.buffer_max,
            chan.buffer.length - chan.buffer_max);
        chan.offset += nread;
        chan.buffer_max += nread}}
    function caml_array_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_ml_input_scan_line(chanid)
     {var chan=caml_ml_channels[chanid],p=chan.buffer_curr;
      do
       if(p >= chan.buffer_max)
        {if(chan.buffer_curr > 0)
          {chan.buffer.set(chan.buffer.subarray(chan.buffer_curr),0);
           p -= chan.buffer_curr;
           chan.buffer_max -= chan.buffer_curr;
           chan.buffer_curr = 0}
         if(chan.buffer_max >= chan.buffer.length)return - chan.buffer_max;
         var prev_max=chan.buffer_max;
         caml_refill(chan);
         if(prev_max == chan.buffer_max)return - chan.buffer_max}
      while
      (chan.buffer[p++] != 10);
      return p - chan.buffer_curr}
    function caml_gc_minor(unit)
     {if(typeof globalThis.gc == "function")globalThis.gc(true);return 0}
    function caml_ml_condition_new(unit){return {condition:1}}
    function caml_int64_of_bytes(a)
     {return new
              MlInt64
              (a[7] << 0 | a[6] << 8 | a[5] << 16,
               a[4] << 0 | a[3] << 8 | a[2] << 16,
               a[1] << 0 | a[0] << 8)}
    function caml_ba_uint8_get64(ba,i0)
     {var ofs=ba.offset(i0);
      if(ofs + 7 >= ba.data.length)caml_array_bound_error();
      var
       b1=ba.get(ofs + 0),
       b2=ba.get(ofs + 1),
       b3=ba.get(ofs + 2),
       b4=ba.get(ofs + 3),
       b5=ba.get(ofs + 4),
       b6=ba.get(ofs + 5),
       b7=ba.get(ofs + 6),
       b8=ba.get(ofs + 7);
      return caml_int64_of_bytes([b8,b7,b6,b5,b4,b3,b2,b1])}
    function caml_int64_to_bytes(x){return x.toArray()}
    function caml_int64_marshal(writer,v,sizes)
     {var b=caml_int64_to_bytes(v);
      for(var i=0;i < 8;i++)writer.write(8,b[i]);
      sizes[0] = 8;
      sizes[1] = 8}
    function caml_ba_num_dims(ba){return ba.dims.length}
    function caml_return_exn_constant(tag){return tag}
    function caml_wrap_exception(e)
     {if(e instanceof Array)return e;
      if
       (globalThis.RangeError
        &&
        e instanceof globalThis.RangeError
        &&
        e.message
        &&
        e.message.match(/maximum call stack/i))
       return caml_return_exn_constant(caml_global_data.Stack_overflow);
      if
       (globalThis.InternalError
        &&
        e instanceof globalThis.InternalError
        &&
        e.message
        &&
        e.message.match(/too much recursion/i))
       return caml_return_exn_constant(caml_global_data.Stack_overflow);
      if(e instanceof globalThis.Error && caml_named_value("jsError"))
       return [0,caml_named_value("jsError"),e];
      return [0,caml_global_data.Failure,caml_string_of_jsstring(String(e))]}
    function caml_create_file(name,content)
     {var root=resolve_fs_device(name);
      if(! root.device.register)caml_failwith("cannot register file");
      root.device.register(root.rest,content);
      return 0}
    function jsoo_create_file(name,content)
     {var
       name=caml_string_of_jsbytes(name),
       content=caml_string_of_jsbytes(content);
      return caml_create_file(name,content)}
    function caml_fs_init()
     {var tmp=globalThis.caml_fs_tmp;
      if(tmp)
       for(var i=0;i < tmp.length;i++)
        jsoo_create_file(tmp[i].name,tmp[i].content);
      globalThis.jsoo_create_file = jsoo_create_file;
      globalThis.caml_fs_tmp = [];
      return 0}
    function caml_mul(a,b){return Math.imul(a,b)}
    function caml_hash_mix_int(h,d)
     {d = caml_mul(d,0xcc9e2d51 | 0);
      d = d << 15 | d >>> 32 - 15;
      d = caml_mul(d,0x1b873593);
      h ^= d;
      h = h << 13 | h >>> 32 - 13;
      return (h + (h << 2) | 0) + (0xe6546b64 | 0) | 0}
    function caml_hash_mix_jsbytes(h,s)
     {var len=s.length,i,w;
      for(i = 0;i + 4 <= len;i += 4)
       {w
        =
        s.charCodeAt(i)
        |
        s.charCodeAt(i + 1)
        <<
        8
        |
        s.charCodeAt(i + 2)
        <<
        16
        |
        s.charCodeAt(i + 3)
        <<
        24;
        h = caml_hash_mix_int(h,w)}
      w = 0;
      switch(len & 3)
       {case 3:w = s.charCodeAt(i + 2) << 16;
        case 2:w |= s.charCodeAt(i + 1) << 8;
        case 1:w |= s.charCodeAt(i);h = caml_hash_mix_int(h,w)
        }
      h ^= len;
      return h}
    function caml_hash_mix_string(h,v)
     {return caml_hash_mix_jsbytes(h,caml_jsbytes_of_string(v))}
    var Base_internalhash_fold_string=caml_hash_mix_string;
    function caml_get_continuation_callstack(){return [0]}
    var caml_parser_trace=0;
    function caml_set_parser_trace(bool)
     {var oldflag=caml_parser_trace;caml_parser_trace = bool;return oldflag}
    function caml_list_of_js_array(a)
     {var l=0;
      for(var i=a.length - 1;i >= 0;i--){var e=a[i];l = [0,e,l]}
      return l}
    function num_digits_nat(nat,ofs,len)
     {for(var i=len - 1;i >= 0;i--)if(nat.data[ofs + i] != 0)return i + 1;
      return 1}
    function caml_hash_nat(x)
     {var len=num_digits_nat(x,0,x.data.length),h=0;
      for(var i=0;i < len;i++)h = caml_hash_mix_int(h,x.data[i]);
      return h}
    function caml_call_gen(f,args)
     {if(f.fun)return caml_call_gen(f.fun,args);
      if(typeof f !== "function")return f;
      var n=f.length | 0;
      if(n === 0)return f.apply(null,args);
      var argsLen=args.length | 0,d=n - argsLen | 0;
      if(d == 0)
       return f.apply(null,args);
      else
       if(d < 0)
        return caml_call_gen(f.apply(null,args.slice(0,n)),args.slice(n));
       else
        return function()
         {var
           extra_args=arguments.length == 0?1:arguments.length,
           nargs=new Array(args.length + extra_args);
          for(var i=0;i < args.length;i++)nargs[i] = args[i];
          for(var i=0;i < arguments.length;i++)
           nargs[args.length + i] = arguments[i];
          return caml_call_gen(f,nargs)}}
    var caml_callback=caml_call_gen;
    function caml_js_wrap_callback_arguments(f)
     {return function()
       {var len=arguments.length,args=new Array(len);
        for(var i=0;i < len;i++)args[i] = arguments[i];
        return caml_callback(f,[args])}}
    function caml_sys_chdir(dir)
     {var root=resolve_fs_device(dir);
      if(root.device.exists(root.rest))
       {if(root.rest)
         caml_current_dir = caml_trailing_slash(root.path + root.rest);
        else
         caml_current_dir = root.path;
        return 0}
      else
       caml_raise_no_such_file(caml_jsbytes_of_string(dir))}
    function caml_obj_tag(x)
     {if(x instanceof Array && x[0] == x[0] >>> 0)
       return x[0];
      else
       if(caml_is_ml_bytes(x))
        return 252;
       else
        if(caml_is_ml_string(x))
         return 252;
        else
         if(x instanceof Function || typeof x == "function")
          return 247;
         else
          if(x && x.caml_custom)return 255;else return 1000}
    function caml_obj_update_tag(b,o,n)
     {if(b[0] == o){b[0] = n;return 1}return 0}
    var caml_ml_domain_unique_token_=[0];
    function caml_ml_domain_unique_token(unit)
     {return caml_ml_domain_unique_token_}
    function caml_lazy_update_to_forcing(o)
     {var t=caml_obj_tag(o);
      if(t != 246 && t != 250 && t != 244)return 4;
      if(caml_obj_update_tag(o,246,244))
       return 0;
      else
       {var field0=o[1];
        t = o[0];
        if(t == 244)
         return field0 == caml_ml_domain_unique_token(0)?1:2;
        else
         if(t == 250)return 3;else return 2}}
    function caml_gc_counters(){return [254,0,0,0]}
    function caml_gr_synchronize()
     {caml_failwith("caml_gr_synchronize not Implemented")}
    function caml_unix_closedir(dir_handle)
     {try
       {dir_handle.pointer.closeSync()}
      catch(e)
       {var unix_error=caml_named_value("Unix.Unix_error");
        caml_raise_with_args
         (unix_error,make_unix_err_args("EBADF","closedir",dir_handle.path))}}
    function caml_unix_opendir(path)
     {var root=resolve_fs_device(path);
      if(! root.device.opendir)
       caml_failwith("caml_unix_opendir: not implemented");
      var dir_handle=root.device.opendir(root.rest,true);
      return {pointer:dir_handle,path:path}}
    function caml_unix_rewinddir(dir_handle)
     {caml_unix_closedir(dir_handle);
      var new_dir_handle=caml_unix_opendir(dir_handle.path);
      dir_handle.pointer = new_dir_handle.pointer;
      return 0}
    function caml_raise_end_of_file()
     {caml_raise_constant(caml_global_data.End_of_file)}
    function caml_unix_readdir(dir_handle)
     {var entry;
      try
       {entry = dir_handle.pointer.readSync()}
      catch(e)
       {var unix_error=caml_named_value("Unix.Unix_error");
        caml_raise_with_args
         (unix_error,make_unix_err_args("EBADF","readdir",dir_handle.path))}
      if(entry === null)
       caml_raise_end_of_file();
      else
       return caml_string_of_jsstring(entry.name)}
    function caml_unix_findfirst(path)
     {var path_js=caml_jsstring_of_string(path);
      path_js = path_js.replace(/(^|[\\\/])\*\.\*$/,"");
      path = caml_string_of_jsstring(path_js);
      var
       dir_handle=caml_unix_opendir(path),
       first_entry=caml_unix_readdir(dir_handle);
      return [0,first_entry,dir_handle]}
    function caml_is_continuation_tag(t){return 0}
    var log2_ok=Math.log2 && Math.log2(1.1235582092889474E+307) == 1020;
    function jsoo_floor_log2(x)
     {if(log2_ok)return Math.floor(Math.log2(x));
      var i=0;
      if(x == 0)return - Infinity;
      if(x >= 1)while(x >= 2){x /= 2;i++}else while(x < 1){x *= 2;i--}
      return i}
    function caml_int32_bits_of_float(x)
     {var float32a=new Float32Array(1);
      float32a[0] = x;
      var int32a=new Int32Array(float32a.buffer);
      return int32a[0] | 0}
    function caml_int64_create_lo_mi_hi(lo,mi,hi)
     {return new MlInt64(lo,mi,hi)}
    function caml_int64_bits_of_float(x)
     {if(! isFinite(x))
       {if(isNaN(x))return caml_int64_create_lo_mi_hi(1,0,0x7ff0);
        return x > 0
                ?caml_int64_create_lo_mi_hi(0,0,0x7ff0)
                :caml_int64_create_lo_mi_hi(0,0,0xfff0)}
      var sign=x == 0 && 1 / x == - Infinity?0x8000:x >= 0?0:0x8000;
      if(sign)x = - x;
      var exp=jsoo_floor_log2(x) + 1023;
      if(exp <= 0)
       {exp = 0;x /= Math.pow(2,- 1026)}
      else
       {x /= Math.pow(2,exp - 1027);
        if(x < 16){x *= 2;exp -= 1}
        if(exp == 0)x /= 2}
      var k=Math.pow(2,24),r3=x | 0;
      x = (x - r3) * k;
      var r2=x | 0;
      x = (x - r2) * k;
      var r1=x | 0;
      r3 = r3 & 0xf | sign | exp << 4;
      return caml_int64_create_lo_mi_hi(r1,r2,r3)}
    function caml_ba_serialize(writer,ba,sz)
     {writer.write(32,ba.dims.length);
      writer.write(32,ba.kind | ba.layout << 8);
      if(ba.caml_custom == "_bigarr02")
       for(var i=0;i < ba.dims.length;i++)
        if(ba.dims[i] < 0xffff)
         writer.write(16,ba.dims[i]);
        else
         {writer.write(16,0xffff);
          writer.write(32,0);
          writer.write(32,ba.dims[i])}
      else
       for(var i=0;i < ba.dims.length;i++)writer.write(32,ba.dims[i]);
      switch(ba.kind)
       {case 2:
        case 3:
        case 12:
         for(var i=0;i < ba.data.length;i++)writer.write(8,ba.data[i]);break;
        case 4:
        case 5:
         for(var i=0;i < ba.data.length;i++)writer.write(16,ba.data[i]);break;
        case 6:
         for(var i=0;i < ba.data.length;i++)writer.write(32,ba.data[i]);break;
        case 8:
        case 9:
         writer.write(8,0);
         for(var i=0;i < ba.data.length;i++)writer.write(32,ba.data[i]);
         break;
        case 7:
         for(var i=0;i < ba.data.length / 2;i++)
          {var b=caml_int64_to_bytes(ba.get(i));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break;
        case 1:
         for(var i=0;i < ba.data.length;i++)
          {var b=caml_int64_to_bytes(caml_int64_bits_of_float(ba.get(i)));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break;
        case 0:
         for(var i=0;i < ba.data.length;i++)
          {var b=caml_int32_bits_of_float(ba.get(i));writer.write(32,b)}
         break;
        case 10:
         for(var i=0;i < ba.data.length / 2;i++)
          {var j=ba.get(i);
           writer.write(32,caml_int32_bits_of_float(j[1]));
           writer.write(32,caml_int32_bits_of_float(j[2]))}
         break;
        case 11:
         for(var i=0;i < ba.data.length / 2;i++)
          {var
            complex=ba.get(i),
            b=caml_int64_to_bytes(caml_int64_bits_of_float(complex[1]));
           for(var j=0;j < 8;j++)writer.write(8,b[j]);
           var b=caml_int64_to_bytes(caml_int64_bits_of_float(complex[2]));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break
        }
      sz[0] = (4 + ba.dims.length) * 4;
      sz[1] = (4 + ba.dims.length) * 8}
    function caml_ba_get_size_per_element(kind)
     {switch(kind){case 7:case 10:case 11:return 2;default:return 1}}
    function caml_ba_create_buffer(kind,size)
     {var view;
      switch(kind)
       {case 0:view = Float32Array;break;
        case 1:view = Float64Array;break;
        case 2:view = Int8Array;break;
        case 3:view = Uint8Array;break;
        case 4:view = Int16Array;break;
        case 5:view = Uint16Array;break;
        case 6:view = Int32Array;break;
        case 7:view = Int32Array;break;
        case 8:view = Int32Array;break;
        case 9:view = Int32Array;break;
        case 10:view = Float32Array;break;
        case 11:view = Float64Array;break;
        case 12:view = Uint8Array;break
        }
      if(! view)caml_invalid_argument("Bigarray.create: unsupported kind");
      var data=new view(size * caml_ba_get_size_per_element(kind));
      return data}
    function caml_int32_float_of_bits(x)
     {var int32a=new Int32Array(1);
      int32a[0] = x;
      var float32a=new Float32Array(int32a.buffer);
      return float32a[0]}
    function caml_int64_float_of_bits(x)
     {var lo=x.lo,mi=x.mi,hi=x.hi,exp=(hi & 0x7fff) >> 4;
      if(exp == 2047)
       return (lo | mi | hi & 0xf) == 0?hi & 0x8000?- Infinity:Infinity:NaN;
      var k=Math.pow(2,- 24),res=(lo * k + mi) * k + (hi & 0xf);
      if(exp > 0)
       {res += 16;res *= Math.pow(2,exp - 1027)}
      else
       res *= Math.pow(2,- 1026);
      if(hi & 0x8000)res = - res;
      return res}
    function caml_ba_get_size(dims)
     {var n_dims=dims.length,size=1;
      for(var i=0;i < n_dims;i++)
       {if(dims[i] < 0)
         caml_invalid_argument("Bigarray.create: negative dimension");
        size = size * dims[i]}
      return size}
    function caml_int64_create_lo_hi(lo,hi)
     {return new
              MlInt64
              (lo & 0xffffff,
               lo >>> 24 & 0xff | (hi & 0xffff) << 8,
               hi >>> 16 & 0xffff)}
    function caml_int64_hi32(v){return v.hi32()}
    function caml_int64_lo32(v){return v.lo32()}
    var caml_ba_custom_name="_bigarr02";
    function Ml_Bigarray(kind,layout,dims,buffer)
     {this.kind = kind;
      this.layout = layout;
      this.dims = dims;
      this.data = buffer}
    Ml_Bigarray.prototype.caml_custom = caml_ba_custom_name;
    Ml_Bigarray.prototype.offset
    =
    function(arg)
     {var ofs=0;
      if(typeof arg === "number")arg = [arg];
      if(! (arg instanceof Array))
       caml_invalid_argument("bigarray.js: invalid offset");
      if(this.dims.length != arg.length)
       caml_invalid_argument("Bigarray.get/set: bad number of dimensions");
      if(this.layout == 0)
       for(var i=0;i < this.dims.length;i++)
        {if(arg[i] < 0 || arg[i] >= this.dims[i])caml_array_bound_error();
         ofs = ofs * this.dims[i] + arg[i]}
      else
       for(var i=this.dims.length - 1;i >= 0;i--)
        {if(arg[i] < 1 || arg[i] > this.dims[i])caml_array_bound_error();
         ofs = ofs * this.dims[i] + (arg[i] - 1)}
      return ofs};
    Ml_Bigarray.prototype.get
    =
    function(ofs)
     {switch(this.kind)
       {case 7:
         var l=this.data[ofs * 2 + 0],h=this.data[ofs * 2 + 1];
         return caml_int64_create_lo_hi(l,h);
        case 10:
        case 11:
         var r=this.data[ofs * 2 + 0],i=this.data[ofs * 2 + 1];
         return [254,r,i];
        default:return this.data[ofs]}};
    Ml_Bigarray.prototype.set
    =
    function(ofs,v)
     {switch(this.kind)
       {case 7:
         this.data[ofs * 2 + 0] = caml_int64_lo32(v);
         this.data[ofs * 2 + 1] = caml_int64_hi32(v);
         break;
        case 10:
        case 11:
         this.data[ofs * 2 + 0] = v[1];this.data[ofs * 2 + 1] = v[2];break;
        default:this.data[ofs] = v;break}
      return 0};
    Ml_Bigarray.prototype.fill
    =
    function(v)
     {switch(this.kind)
       {case 7:
         var a=caml_int64_lo32(v),b=caml_int64_hi32(v);
         if(a == b)
          this.data.fill(a);
         else
          for(var i=0;i < this.data.length;i++)this.data[i] = i % 2 == 0?a:b;
         break;
        case 10:
        case 11:
         var im=v[1],re=v[2];
         if(im == re)
          this.data.fill(im);
         else
          for(var i=0;i < this.data.length;i++)
           this.data[i] = i % 2 == 0?im:re;
         break;
        default:this.data.fill(v);break}};
    Ml_Bigarray.prototype.compare
    =
    function(b,total)
     {if(this.layout != b.layout || this.kind != b.kind)
       {var k1=this.kind | this.layout << 8,k2=b.kind | b.layout << 8;
        return k2 - k1}
      if(this.dims.length != b.dims.length)
       return b.dims.length - this.dims.length;
      for(var i=0;i < this.dims.length;i++)
       if(this.dims[i] != b.dims[i])return this.dims[i] < b.dims[i]?- 1:1;
      switch(this.kind)
       {case 0:
        case 1:
        case 10:
        case 11:
         var x,y;
         for(var i=0;i < this.data.length;i++)
          {x = this.data[i];
           y = b.data[i];
           if(x < y)return - 1;
           if(x > y)return 1;
           if(x != y)
            {if(! total)return NaN;if(x == x)return 1;if(y == y)return - 1}}
         break;
        case 7:
         for(var i=0;i < this.data.length;i += 2)
          {if(this.data[i + 1] < b.data[i + 1])return - 1;
           if(this.data[i + 1] > b.data[i + 1])return 1;
           if(this.data[i] >>> 0 < b.data[i] >>> 0)return - 1;
           if(this.data[i] >>> 0 > b.data[i] >>> 0)return 1}
         break;
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 8:
        case 9:
        case 12:
         for(var i=0;i < this.data.length;i++)
          {if(this.data[i] < b.data[i])return - 1;
           if(this.data[i] > b.data[i])return 1}
         break
        }
      return 0};
    function Ml_Bigarray_c_1_1(kind,layout,dims,buffer)
     {this.kind = kind;
      this.layout = layout;
      this.dims = dims;
      this.data = buffer}
    Ml_Bigarray_c_1_1.prototype = new Ml_Bigarray();
    Ml_Bigarray_c_1_1.prototype.offset
    =
    function(arg)
     {if(typeof arg !== "number")
       if(arg instanceof Array && arg.length == 1)
        arg = arg[0];
       else
        caml_invalid_argument("Ml_Bigarray_c_1_1.offset");
      if(arg < 0 || arg >= this.dims[0])caml_array_bound_error();
      return arg};
    Ml_Bigarray_c_1_1.prototype.get = function(ofs){return this.data[ofs]};
    Ml_Bigarray_c_1_1.prototype.set
    =
    function(ofs,v){this.data[ofs] = v;return 0};
    Ml_Bigarray_c_1_1.prototype.fill
    =
    function(v){this.data.fill(v);return 0};
    function caml_ba_create_unsafe(kind,layout,dims,data)
     {var size_per_element=caml_ba_get_size_per_element(kind);
      if(caml_ba_get_size(dims) * size_per_element != data.length)
       caml_invalid_argument("length doesn't match dims");
      if(layout == 0 && dims.length == 1 && size_per_element == 1)
       return new Ml_Bigarray_c_1_1(kind,layout,dims,data);
      return new Ml_Bigarray(kind,layout,dims,data)}
    function caml_ba_deserialize(reader,sz,name)
     {var num_dims=reader.read32s();
      if(num_dims < 0 || num_dims > 16)
       caml_failwith("input_value: wrong number of bigarray dimensions");
      var tag=reader.read32s(),kind=tag & 0xff,layout=tag >> 8 & 1,dims=[];
      if(name == "_bigarr02")
       for(var i=0;i < num_dims;i++)
        {var size_dim=reader.read16u();
         if(size_dim == 0xffff)
          {var size_dim_hi=reader.read32u(),size_dim_lo=reader.read32u();
           if(size_dim_hi != 0)
            caml_failwith("input_value: bigarray dimension overflow in 32bit");
           size_dim = size_dim_lo}
         dims.push(size_dim)}
      else
       for(var i=0;i < num_dims;i++)dims.push(reader.read32u());
      var
       size=caml_ba_get_size(dims),
       data=caml_ba_create_buffer(kind,size),
       ba=caml_ba_create_unsafe(kind,layout,dims,data);
      switch(kind)
       {case 2:for(var i=0;i < size;i++)data[i] = reader.read8s();break;
        case 3:
        case 12:for(var i=0;i < size;i++)data[i] = reader.read8u();break;
        case 4:for(var i=0;i < size;i++)data[i] = reader.read16s();break;
        case 5:for(var i=0;i < size;i++)data[i] = reader.read16u();break;
        case 6:for(var i=0;i < size;i++)data[i] = reader.read32s();break;
        case 8:
        case 9:
         var sixty=reader.read8u();
         if(sixty)
          caml_failwith
           ("input_value: cannot read bigarray with 64-bit OCaml ints");
         for(var i=0;i < size;i++)data[i] = reader.read32s();
         break;
        case 7:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var int64=caml_int64_of_bytes(t);
           ba.set(i,int64)}
         break;
        case 1:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var f=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           ba.set(i,f)}
         break;
        case 0:
         for(var i=0;i < size;i++)
          {var f=caml_int32_float_of_bits(reader.read32s());ba.set(i,f)}
         break;
        case 10:
         for(var i=0;i < size;i++)
          {var
            re=caml_int32_float_of_bits(reader.read32s()),
            im=caml_int32_float_of_bits(reader.read32s());
           ba.set(i,[254,re,im])}
         break;
        case 11:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var re=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var im=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           ba.set(i,[254,re,im])}
         break
        }
      sz[0] = (4 + num_dims) * 4;
      return caml_ba_create_unsafe(kind,layout,dims,data)}
    function caml_ba_compare(a,b,total){return a.compare(b,total)}
    function caml_hash_mix_int64(h,v)
     {h = caml_hash_mix_int(h,caml_int64_lo32(v));
      h = caml_hash_mix_int(h,caml_int64_hi32(v));
      return h}
    function caml_hash_mix_float(h,v0)
     {return caml_hash_mix_int64(h,caml_int64_bits_of_float(v0))}
    function caml_ba_hash(ba)
     {var num_elts=caml_ba_get_size(ba.dims),h=0;
      switch(ba.kind)
       {case 2:
        case 3:
        case 12:
         if(num_elts > 256)num_elts = 256;
         var w=0,i=0;
         for(i = 0;i + 4 <= ba.data.length;i += 4)
          {w
           =
           ba.data[i + 0]
           |
           ba.data[i + 1]
           <<
           8
           |
           ba.data[i + 2]
           <<
           16
           |
           ba.data[i + 3]
           <<
           24;
           h = caml_hash_mix_int(h,w)}
         w = 0;
         switch(num_elts & 3)
          {case 3:w = ba.data[i + 2] << 16;
           case 2:w |= ba.data[i + 1] << 8;
           case 1:w |= ba.data[i + 0];h = caml_hash_mix_int(h,w)
           }
         break;
        case 4:
        case 5:
         if(num_elts > 128)num_elts = 128;
         var w=0,i=0;
         for(i = 0;i + 2 <= ba.data.length;i += 2)
          {w = ba.data[i + 0] | ba.data[i + 1] << 16;
           h = caml_hash_mix_int(h,w)}
         if((num_elts & 1) != 0)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 6:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 8:
        case 9:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 7:
         if(num_elts > 32)num_elts = 32;
         num_elts *= 2;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 10:num_elts *= 2;
        case 0:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_float(h,ba.data[i]);
         break;
        case 11:num_elts *= 2;
        case 1:
         if(num_elts > 32)num_elts = 32;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_float(h,ba.data[i]);
         break
        }
      return h}
    function caml_int32_unmarshal(reader,size)
     {size[0] = 4;return reader.read32s()}
    function caml_nativeint_unmarshal(reader,size)
     {switch(reader.read8u())
       {case 1:size[0] = 4;return reader.read32s();
        case 2:caml_failwith("input_value: native integer value too large");
        default:caml_failwith("input_value: ill-formed native integer")}}
    function caml_int64_unmarshal(reader,size)
     {var t=new Array(8);
      for(var j=0;j < 8;j++)t[j] = reader.read8u();
      size[0] = 8;
      return caml_int64_of_bytes(t)}
    function caml_int64_compare(x,y,total){return x.compare(y)}
    function caml_int64_hash(v){return v.lo32() ^ v.hi32()}
    var
     caml_custom_ops=
      {"_j":
       {deserialize:caml_int64_unmarshal,
        serialize:caml_int64_marshal,
        fixed_length:8,
        compare:caml_int64_compare,
        hash:caml_int64_hash},
       "_i":{deserialize:caml_int32_unmarshal,fixed_length:4},
       "_n":{deserialize:caml_nativeint_unmarshal,fixed_length:4},
       "_bigarray":
       {deserialize:
        function(reader,sz){return caml_ba_deserialize(reader,sz,"_bigarray")},
        serialize:caml_ba_serialize,
        compare:caml_ba_compare,
        hash:caml_ba_hash},
       "_bigarr02":
       {deserialize:
        function(reader,sz){return caml_ba_deserialize(reader,sz,"_bigarr02")},
        serialize:caml_ba_serialize,
        compare:caml_ba_compare,
        hash:caml_ba_hash}};
    function caml_compare_val_get_custom(a)
     {return caml_custom_ops[a.caml_custom]
             &&
             caml_custom_ops[a.caml_custom].compare}
    function caml_compare_val_number_custom(num,custom,swap,total)
     {var comp=caml_compare_val_get_custom(custom);
      if(comp)
       {var x=swap > 0?comp(custom,num,total):comp(num,custom,total);
        if(total && x != x)return swap;
        if(+ x != + x)return + x;
        if((x | 0) != 0)return x | 0}
      return swap}
    function caml_compare_val_tag(a)
     {if(typeof a === "number")
       return 1000;
      else
       if(caml_is_ml_bytes(a))
        return 252;
       else
        if(caml_is_ml_string(a))
         return 1252;
        else
         if(a instanceof Array && a[0] === a[0] >>> 0 && a[0] <= 255)
          {var tag=a[0] | 0;return tag == 254?0:tag}
         else
          if(a instanceof String)
           return 12520;
          else
           if(typeof a == "string")
            return 12520;
           else
            if(a instanceof Number)
             return 1000;
            else
             if(a && a.caml_custom)
              return 1255;
             else
              if(a && a.compare)
               return 1256;
              else
               if(typeof a == "function")
                return 1247;
               else
                if(typeof a == "symbol")return 1251;
      return 1001}
    function caml_int_compare(a,b)
     {if(a < b)return - 1;if(a == b)return 0;return 1}
    function caml_bytes_compare(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c < s2.c?- 1:s1.c > s2.c?1:0}
    function caml_string_compare(s1,s2){return caml_bytes_compare(s1,s2)}
    function caml_compare_val(a,b,total)
     {var stack=[];
      for(;;)
       {if(! (total && a === b))
         {var tag_a=caml_compare_val_tag(a);
          if(tag_a == 250){a = a[1];continue}
          var tag_b=caml_compare_val_tag(b);
          if(tag_b == 250){b = b[1];continue}
          if(tag_a !== tag_b)
           {if(tag_a == 1000)
             {if(tag_b == 1255)
               return caml_compare_val_number_custom(a,b,- 1,total);
              return - 1}
            if(tag_b == 1000)
             {if(tag_a == 1255)
               return caml_compare_val_number_custom(b,a,1,total);
              return 1}
            return tag_a < tag_b?- 1:1}
          switch(tag_a)
           {case 247:caml_invalid_argument("compare: functional value");break;
            case 248:
             var x=caml_int_compare(a[2],b[2]);if(x != 0)return x | 0;break;
            case 249:caml_invalid_argument("compare: functional value");break;
            case 250:
             caml_invalid_argument
              ("equal: got Forward_tag, should not happen");
             break;
            case 251:caml_invalid_argument("equal: abstract value");break;
            case 252:
             if(a !== b){var x=caml_bytes_compare(a,b);if(x != 0)return x | 0}
             break;
            case 253:
             caml_invalid_argument("equal: got Double_tag, should not happen");
             break;
            case 254:
             caml_invalid_argument
              ("equal: got Double_array_tag, should not happen");
             break;
            case 255:
             caml_invalid_argument("equal: got Custom_tag, should not happen");
             break;
            case 1247:
             caml_invalid_argument("compare: functional value");break;
            case 1255:
             var comp=caml_compare_val_get_custom(a);
             if(comp != caml_compare_val_get_custom(b))
              return a.caml_custom < b.caml_custom?- 1:1;
             if(! comp)caml_invalid_argument("compare: abstract value");
             var x=comp(a,b,total);
             if(x != x)return total?- 1:x;
             if(x !== (x | 0))return - 1;
             if(x != 0)return x | 0;
             break;
            case 1256:
             var x=a.compare(b,total);
             if(x != x)return total?- 1:x;
             if(x !== (x | 0))return - 1;
             if(x != 0)return x | 0;
             break;
            case 1000:
             a = + a;
             b = + b;
             if(a < b)return - 1;
             if(a > b)return 1;
             if(a != b)
              {if(! total)return NaN;if(a == a)return 1;if(b == b)return - 1}
             break;
            case 1001:
             if(a < b)return - 1;
             if(a > b)return 1;
             if(a != b)
              {if(! total)return NaN;if(a == a)return 1;if(b == b)return - 1}
             break;
            case 1251:if(a !== b){if(! total)return NaN;return 1}break;
            case 1252:
             var a=caml_jsbytes_of_string(a),b=caml_jsbytes_of_string(b);
             if(a !== b){if(a < b)return - 1;if(a > b)return 1}
             break;
            case 12520:
             var a=a.toString(),b=b.toString();
             if(a !== b){if(a < b)return - 1;if(a > b)return 1}
             break;
            case 246:
            case 254:
            default:
             if(caml_is_continuation_tag(tag_a))
              {caml_invalid_argument("compare: continuation value");break}
             if(a.length != b.length)return a.length < b.length?- 1:1;
             if(a.length > 1)stack.push(a,b,1);
             break}}
        if(stack.length == 0)return 0;
        var i=stack.pop();
        b = stack.pop();
        a = stack.pop();
        if(i + 1 < a.length)stack.push(a,b,i + 1);
        a = a[i];
        b = b[i]}}
    function caml_greaterthan(x,y){return + (caml_compare_val(x,y,false) > 0)}
    function div_helper(a,b,c)
     {var
       x=a * 65536 + (b >>> 16),
       y=Math.floor(x / c) * 65536,
       z=x % c * 65536,
       w=z + (b & 0x0000FFFF);
      return [y + Math.floor(w / c),w % c]}
    function div_digit_nat(natq,ofsq,natr,ofsr,nat1,ofs1,len,nat2,ofs2)
     {var rem=nat1.data[ofs1 + len - 1] >>> 0;
      for(var i=len - 2;i >= 0;i--)
       {var x=div_helper(rem,nat1.data[ofs1 + i] >>> 0,nat2.data[ofs2] >>> 0);
        natq.data[ofsq + i] = x[0];
        rem = x[1]}
      natr.data[ofsr] = rem;
      return 0}
    function num_leading_zero_bits_in_digit(nat,ofs)
     {var a=nat.data[ofs],b=0;
      if(a & 0xFFFF0000){b += 16;a >>>= 16}
      if(a & 0xFF00){b += 8;a >>>= 8}
      if(a & 0xF0){b += 4;a >>>= 4}
      if(a & 12){b += 2;a >>>= 2}
      if(a & 2){b += 1;a >>>= 1}
      if(a & 1)b += 1;
      return 32 - b}
    function shift_left_nat(nat1,ofs1,len1,nat2,ofs2,nbits)
     {if(nbits == 0){nat2.data[ofs2] = 0;return 0}
      var wrap=0;
      for(var i=0;i < len1;i++)
       {var a=nat1.data[ofs1 + i] >>> 0;
        nat1.data[ofs1 + i] = a << nbits | wrap;
        wrap = a >>> 32 - nbits}
      nat2.data[ofs2] = wrap;
      return 0}
    function MlNat(x)
     {this.data = new Int32Array(x);this.length = this.data.length + 2}
    MlNat.prototype.caml_custom = "_nat";
    function create_nat(size)
     {var arr=new MlNat(size);
      for(var i=0;i < size;i++)arr.data[i] = - 1;
      return arr}
    function set_to_zero_nat(nat,ofs,len)
     {for(var i=0;i < len;i++)nat.data[ofs + i] = 0;return 0}
    function incr_nat(nat,ofs,len,carry_in)
     {var carry=carry_in;
      for(var i=0;i < len;i++)
       {var x=(nat.data[ofs + i] >>> 0) + carry;
        nat.data[ofs + i] = x | 0;
        if(x == x >>> 0){carry = 0;break}else carry = 1}
      return carry}
    function add_nat(nat1,ofs1,len1,nat2,ofs2,len2,carry_in)
     {var carry=carry_in;
      for(var i=0;i < len2;i++)
       {var
         x=
          (nat1.data[ofs1 + i] >>> 0) + (nat2.data[ofs2 + i] >>> 0) + carry;
        nat1.data[ofs1 + i] = x;
        if(x == x >>> 0)carry = 0;else carry = 1}
      return incr_nat(nat1,ofs1 + len2,len1 - len2,carry)}
    function nat_of_array(l){return new MlNat(l)}
    function mult_digit_nat(nat1,ofs1,len1,nat2,ofs2,len2,nat3,ofs3)
     {var carry=0,a=nat3.data[ofs3] >>> 0;
      for(var i=0;i < len2;i++)
       {var
         x1=
          (nat1.data[ofs1 + i] >>> 0)
          +
          (nat2.data[ofs2 + i] >>> 0)
          *
          (a & 0x0000FFFF)
          +
          carry,
         x2=(nat2.data[ofs2 + i] >>> 0) * (a >>> 16);
        carry = Math.floor(x2 / 65536);
        var x3=x1 + x2 % 65536 * 65536;
        nat1.data[ofs1 + i] = x3;
        carry += Math.floor(x3 / 4294967296)}
      return len2 < len1 && carry
              ?add_nat
                (nat1,ofs1 + len2,len1 - len2,nat_of_array([carry]),0,1,0)
              :carry}
    function decr_nat(nat,ofs,len,carry_in)
     {var borrow=carry_in == 1?0:1;
      for(var i=0;i < len;i++)
       {var x=(nat.data[ofs + i] >>> 0) - borrow;
        nat.data[ofs + i] = x;
        if(x >= 0){borrow = 0;break}else borrow = 1}
      return borrow == 1?0:1}
    function sub_nat(nat1,ofs1,len1,nat2,ofs2,len2,carry_in)
     {var borrow=carry_in == 1?0:1;
      for(var i=0;i < len2;i++)
       {var
         x=
          (nat1.data[ofs1 + i] >>> 0) - (nat2.data[ofs2 + i] >>> 0) - borrow;
        nat1.data[ofs1 + i] = x;
        if(x >= 0)borrow = 0;else borrow = 1}
      return decr_nat(nat1,ofs1 + len2,len1 - len2,borrow == 1?0:1)}
    function compare_nat(nat1,ofs1,len1,nat2,ofs2,len2)
     {var a=num_digits_nat(nat1,ofs1,len1),b=num_digits_nat(nat2,ofs2,len2);
      if(a > b)return 1;
      if(a < b)return - 1;
      for(var i=len1 - 1;i >= 0;i--)
       {if(nat1.data[ofs1 + i] >>> 0 > nat2.data[ofs2 + i] >>> 0)return 1;
        if(nat1.data[ofs1 + i] >>> 0 < nat2.data[ofs2 + i] >>> 0)return - 1}
      return 0}
    function div_nat(nat1,ofs1,len1,nat2,ofs2,len2)
     {if(len2 == 1)
       {div_digit_nat(nat1,ofs1 + 1,nat1,ofs1,nat1,ofs1,len1,nat2,ofs2);
        return 0}
      var s=num_leading_zero_bits_in_digit(nat2,ofs2 + len2 - 1);
      shift_left_nat(nat2,ofs2,len2,nat_of_array([0]),0,s);
      shift_left_nat(nat1,ofs1,len1,nat_of_array([0]),0,s);
      var d=(nat2.data[ofs2 + len2 - 1] >>> 0) + 1,a=create_nat(len2 + 1);
      for(var i=len1 - 1;i >= len2;i--)
       {var
         quo=
          d == 4294967296
           ?nat1.data[ofs1 + i] >>> 0
           :div_helper
              (nat1.data[ofs1 + i] >>> 0,nat1.data[ofs1 + i - 1] >>> 0,d)
             [0];
        set_to_zero_nat(a,0,len2 + 1);
        mult_digit_nat(a,0,len2 + 1,nat2,ofs2,len2,nat_of_array([quo]),0);
        sub_nat(nat1,ofs1 + i - len2,len2 + 1,a,0,len2 + 1,1);
        while
         (nat1.data[ofs1 + i]
          !=
          0
          ||
          compare_nat(nat1,ofs1 + i - len2,len2,nat2,ofs2,len2)
          >=
          0)
         {quo = quo + 1;
          sub_nat(nat1,ofs1 + i - len2,len2 + 1,nat2,ofs2,len2,1)}
        nat1.data[ofs1 + i] = quo}
      shift_right_nat(nat1,ofs1,len2,nat_of_array([0]),0,s);
      shift_right_nat(nat2,ofs2,len2,nat_of_array([0]),0,s);
      return 0}
    function caml_ba_blit(src,dst)
     {if(dst.dims.length != src.dims.length)
       caml_invalid_argument("Bigarray.blit: dimension mismatch");
      for(var i=0;i < dst.dims.length;i++)
       if(dst.dims[i] != src.dims[i])
        caml_invalid_argument("Bigarray.blit: dimension mismatch");
      dst.data.set(src.data);
      return 0}
    function is_digit_int(nat,ofs){if(nat.data[ofs] >= 0)return 1;return 0}
    function caml_int64_div(x,y){return x.div(y)}
    function caml_js_html_entities(s)
     {var entity=/^&#?[0-9a-zA-Z]+;$/;
      if(s.match(entity))
       {var str,temp=document.createElement("p");
        temp.innerHTML = s;
        str = temp.textContent || temp.innerText;
        temp = null;
        return str}
      else
       caml_failwith("Invalid entity " + s)}
    function caml_string_unsafe_set(s,i,c)
     {return caml_bytes_unsafe_set(s,i,c)}
    function caml_int64_of_float(x)
     {if(x < 0)x = Math.ceil(x);
      return new
              MlInt64
              (x & 0xffffff,
               Math.floor(x * caml_int64_offset) & 0xffffff,
               Math.floor(x * caml_int64_offset * caml_int64_offset) & 0xffff)}
    function caml_ml_channel_size_64(chanid)
     {var chan=caml_ml_channels[chanid];
      return caml_int64_of_float(chan.file.length())}
    function caml_ba_set_2(ba,i0,i1,v){ba.set(ba.offset([i0,i1]),v);return 0}
    var
     caml_argv=
      function()
        {var process=globalThis.process,main="a.out",args=[];
         if(process && process.argv && process.argv.length > 1)
          {var argv=process.argv;main = argv[1];args = argv.slice(2)}
         var p=caml_string_of_jsstring(main),args2=[0,p];
         for(var i=0;i < args.length;i++)
          args2.push(caml_string_of_jsstring(args[i]));
         return args2}
       (),
     caml_executable_name=caml_argv[1];
    function caml_js_eval_string(s){return eval(caml_jsstring_of_string(s))}
    function serialize_nat(writer,nat,sz)
     {var len=nat.data.length;
      writer.write(32,len);
      for(var i=0;i < len;i++)writer.write(32,nat.data[i]);
      sz[0] = len * 4;
      sz[1] = len * 8}
    function caml_memprof_set(_control){return 0}
    function caml_sys_exit(code)
     {if(globalThis.quit)globalThis.quit(code);
      if(globalThis.process && globalThis.process.exit)
       globalThis.process.exit(code);
      caml_invalid_argument("Function 'exit' not implemented")}
    function caml_channel_descriptor(chanid)
     {var chan=caml_ml_channels[chanid];return chan.fd}
    function caml_js_from_array(a){return a.slice(1)}
    function caml_ba_reshape(ba,vind)
     {vind = caml_js_from_array(vind);
      var new_dim=[],num_dims=vind.length;
      if(num_dims < 0 || num_dims > 16)
       caml_invalid_argument("Bigarray.reshape: bad number of dimensions");
      var num_elts=1;
      for(var i=0;i < num_dims;i++)
       {new_dim[i] = vind[i];
        if(new_dim[i] < 0)
         caml_invalid_argument("Bigarray.reshape: negative dimension");
        num_elts = num_elts * new_dim[i]}
      var size=caml_ba_get_size(ba.dims);
      if(num_elts != size)
       caml_invalid_argument("Bigarray.reshape: size mismatch");
      return caml_ba_create_unsafe(ba.kind,ba.layout,new_dim,ba.data)}
    var caml_oo_last_id=0;
    function caml_set_oo_id(b){b[2] = caml_oo_last_id++;return b}
    function caml_gr_fill_rect(x,y,w,h)
     {var s=caml_gr_state_get();
      s.context.fillRect(x,s.height - y,w,- h);
      return 0}
    function caml_bigstring_blit_string_to_ba(str1,pos1,ba2,pos2,len)
     {if(12 != ba2.kind)
       caml_invalid_argument
        ("caml_bigstring_blit_string_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs2=ba2.offset(pos2);
      if(pos1 + len > caml_ml_string_length(str1))caml_array_bound_error();
      if(ofs2 + len > ba2.data.length)caml_array_bound_error();
      var slice=caml_uint8_array_of_string(str1).slice(pos1,pos1 + len);
      ba2.data.set(slice,ofs2);
      return 0}
    function caml_gr_set_window_title(name)
     {var s=caml_gr_state_get();
      s.title = name;
      var jsname=caml_jsstring_of_string(name);
      if(s.set_title)s.set_title(jsname);
      return 0}
    function caml_get_global_data(){return caml_global_data}
    function caml_int64_shift_right_unsigned(x,s)
     {return x.shift_right_unsigned(s)}
    function caml_ba_uint8_get16(ba,i0)
     {var ofs=ba.offset(i0);
      if(ofs + 1 >= ba.data.length)caml_array_bound_error();
      var b1=ba.get(ofs),b2=ba.get(ofs + 1);
      return b1 | b2 << 8}
    function caml_compare(a,b){return caml_compare_val(a,b,true)}
    var
     caml_MD5Transform=
      function()
        {function add(x,y){return x + y | 0}
         function xx(q,a,b,x,s,t)
          {a = add(add(a,q),add(x,t));return add(a << s | a >>> 32 - s,b)}
         function ff(a,b,c,d,x,s,t){return xx(b & c | ~ b & d,a,b,x,s,t)}
         function gg(a,b,c,d,x,s,t){return xx(b & d | c & ~ d,a,b,x,s,t)}
         function hh(a,b,c,d,x,s,t){return xx(b ^ c ^ d,a,b,x,s,t)}
         function ii(a,b,c,d,x,s,t){return xx(c ^ (b | ~ d),a,b,x,s,t)}
         return function(w,buffer)
          {var a=w[0],b=w[1],c=w[2],d=w[3];
           a = ff(a,b,c,d,buffer[0],7,0xD76AA478);
           d = ff(d,a,b,c,buffer[1],12,0xE8C7B756);
           c = ff(c,d,a,b,buffer[2],17,0x242070DB);
           b = ff(b,c,d,a,buffer[3],22,0xC1BDCEEE);
           a = ff(a,b,c,d,buffer[4],7,0xF57C0FAF);
           d = ff(d,a,b,c,buffer[5],12,0x4787C62A);
           c = ff(c,d,a,b,buffer[6],17,0xA8304613);
           b = ff(b,c,d,a,buffer[7],22,0xFD469501);
           a = ff(a,b,c,d,buffer[8],7,0x698098D8);
           d = ff(d,a,b,c,buffer[9],12,0x8B44F7AF);
           c = ff(c,d,a,b,buffer[10],17,0xFFFF5BB1);
           b = ff(b,c,d,a,buffer[11],22,0x895CD7BE);
           a = ff(a,b,c,d,buffer[12],7,0x6B901122);
           d = ff(d,a,b,c,buffer[13],12,0xFD987193);
           c = ff(c,d,a,b,buffer[14],17,0xA679438E);
           b = ff(b,c,d,a,buffer[15],22,0x49B40821);
           a = gg(a,b,c,d,buffer[1],5,0xF61E2562);
           d = gg(d,a,b,c,buffer[6],9,0xC040B340);
           c = gg(c,d,a,b,buffer[11],14,0x265E5A51);
           b = gg(b,c,d,a,buffer[0],20,0xE9B6C7AA);
           a = gg(a,b,c,d,buffer[5],5,0xD62F105D);
           d = gg(d,a,b,c,buffer[10],9,0x02441453);
           c = gg(c,d,a,b,buffer[15],14,0xD8A1E681);
           b = gg(b,c,d,a,buffer[4],20,0xE7D3FBC8);
           a = gg(a,b,c,d,buffer[9],5,0x21E1CDE6);
           d = gg(d,a,b,c,buffer[14],9,0xC33707D6);
           c = gg(c,d,a,b,buffer[3],14,0xF4D50D87);
           b = gg(b,c,d,a,buffer[8],20,0x455A14ED);
           a = gg(a,b,c,d,buffer[13],5,0xA9E3E905);
           d = gg(d,a,b,c,buffer[2],9,0xFCEFA3F8);
           c = gg(c,d,a,b,buffer[7],14,0x676F02D9);
           b = gg(b,c,d,a,buffer[12],20,0x8D2A4C8A);
           a = hh(a,b,c,d,buffer[5],4,0xFFFA3942);
           d = hh(d,a,b,c,buffer[8],11,0x8771F681);
           c = hh(c,d,a,b,buffer[11],16,0x6D9D6122);
           b = hh(b,c,d,a,buffer[14],23,0xFDE5380C);
           a = hh(a,b,c,d,buffer[1],4,0xA4BEEA44);
           d = hh(d,a,b,c,buffer[4],11,0x4BDECFA9);
           c = hh(c,d,a,b,buffer[7],16,0xF6BB4B60);
           b = hh(b,c,d,a,buffer[10],23,0xBEBFBC70);
           a = hh(a,b,c,d,buffer[13],4,0x289B7EC6);
           d = hh(d,a,b,c,buffer[0],11,0xEAA127FA);
           c = hh(c,d,a,b,buffer[3],16,0xD4EF3085);
           b = hh(b,c,d,a,buffer[6],23,0x04881D05);
           a = hh(a,b,c,d,buffer[9],4,0xD9D4D039);
           d = hh(d,a,b,c,buffer[12],11,0xE6DB99E5);
           c = hh(c,d,a,b,buffer[15],16,0x1FA27CF8);
           b = hh(b,c,d,a,buffer[2],23,0xC4AC5665);
           a = ii(a,b,c,d,buffer[0],6,0xF4292244);
           d = ii(d,a,b,c,buffer[7],10,0x432AFF97);
           c = ii(c,d,a,b,buffer[14],15,0xAB9423A7);
           b = ii(b,c,d,a,buffer[5],21,0xFC93A039);
           a = ii(a,b,c,d,buffer[12],6,0x655B59C3);
           d = ii(d,a,b,c,buffer[3],10,0x8F0CCC92);
           c = ii(c,d,a,b,buffer[10],15,0xFFEFF47D);
           b = ii(b,c,d,a,buffer[1],21,0x85845DD1);
           a = ii(a,b,c,d,buffer[8],6,0x6FA87E4F);
           d = ii(d,a,b,c,buffer[15],10,0xFE2CE6E0);
           c = ii(c,d,a,b,buffer[6],15,0xA3014314);
           b = ii(b,c,d,a,buffer[13],21,0x4E0811A1);
           a = ii(a,b,c,d,buffer[4],6,0xF7537E82);
           d = ii(d,a,b,c,buffer[11],10,0xBD3AF235);
           c = ii(c,d,a,b,buffer[2],15,0x2AD7D2BB);
           b = ii(b,c,d,a,buffer[9],21,0xEB86D391);
           w[0] = add(a,w[0]);
           w[1] = add(b,w[1]);
           w[2] = add(c,w[2]);
           w[3] = add(d,w[3])}}
       ();
    function caml_MD5Update(ctx,input,input_len)
     {var in_buf=ctx.len & 0x3f,input_pos=0;
      ctx.len += input_len;
      if(in_buf)
       {var missing=64 - in_buf;
        if(input_len < missing)
         {ctx.b8.set(input.subarray(0,input_len),in_buf);return}
        ctx.b8.set(input.subarray(0,missing),in_buf);
        caml_MD5Transform(ctx.w,ctx.b32);
        input_len -= missing;
        input_pos += missing}
      while(input_len >= 64)
       {ctx.b8.set(input.subarray(input_pos,input_pos + 64),0);
        caml_MD5Transform(ctx.w,ctx.b32);
        input_len -= 64;
        input_pos += 64}
      if(input_len)
       ctx.b8.set(input.subarray(input_pos,input_pos + input_len),0)}
    function caml_fresh_oo_id(){return caml_oo_last_id++}
    function caml_int64_to_float(x){return x.toFloat()}
    function caml_ba_get_1(ba,i0){return ba.get(ba.offset(i0))}
    function caml_bigstring_memcmp(s1,pos1,s2,pos2,len)
     {for(var i=0;i < len;i++)
       {var a=caml_ba_get_1(s1,pos1 + i),b=caml_ba_get_1(s2,pos2 + i);
        if(a < b)return - 1;
        if(a > b)return 1}
      return 0}
    function caml_new_string(s){return caml_string_of_jsbytes(s)}
    function caml_erf_float(x)
     {var
       a1=0.254829592,
       a2=- 0.284496736,
       a3=1.421413741,
       a4=- 1.453152027,
       a5=1.061405429,
       p=0.3275911,
       sign=1;
      if(x < 0)sign = - 1;
      x = Math.abs(x);
      var
       t=1.0 / (1.0 + p * x),
       y=
        1.0
        -
        ((((a5 * t + a4) * t + a3) * t + a2) * t + a1)
        *
        t
        *
        Math.exp(- (x * x));
      return sign * y}
    function caml_ba_uint8_get32(ba,i0)
     {var ofs=ba.offset(i0);
      if(ofs + 3 >= ba.data.length)caml_array_bound_error();
      var
       b1=ba.get(ofs + 0),
       b2=ba.get(ofs + 1),
       b3=ba.get(ofs + 2),
       b4=ba.get(ofs + 3);
      return b1 << 0 | b2 << 8 | b3 << 16 | b4 << 24}
    function caml_raw_backtrace_length(){return 0}
    function caml_str_initialize(unit){return 0}
    function caml_obj_block(tag,size)
     {var o=new Array(size + 1);
      o[0] = tag;
      for(var i=1;i <= size;i++)o[i] = 0;
      return o}
    function caml_gr_clear_graph()
     {var s=caml_gr_state_get();
      s.canvas.width = s.width;
      s.canvas.height = s.height;
      return 0}
    function bigstring_to_array_buffer(bs){return bs.data.buffer}
    function caml_sys_const_naked_pointers_checked(_unit){return 0}
    function lxor_digit_nat(nat1,ofs1,nat2,ofs2)
     {nat1.data[ofs1] ^= nat2.data[ofs2];return 0}
    function caml_obj_add_offset(v,offset)
     {caml_failwith("Obj.add_offset is not supported")}
    function caml_final_release(){return 0}
    function caml_js_to_array(a)
     {var len=a.length,b=new Array(len + 1);
      b[0] = 0;
      for(var i=0;i < len;i++)b[i + 1] = a[i];
      return b}
    function caml_gr_plot(x,y)
     {var
       s=caml_gr_state_get(),
       im=s.context.createImageData(1,1),
       d=im.data,
       color=s.color;
      d[0] = color >> 16 & 0xff;
      d[1] = color >> 8 & 0xff,d[2] = color >> 0 & 0xff;
      d[3] = 0xFF;
      s.x = x;
      s.y = y;
      s.context.putImageData(im,x,s.height - y);
      return 0}
    function caml_bytes_set16(s,i,i16)
     {if(i >>> 0 >= s.l - 1)caml_bytes_bound_error();
      var b2=0xFF & i16 >> 8,b1=0xFF & i16;
      caml_bytes_unsafe_set(s,i + 0,b1);
      caml_bytes_unsafe_set(s,i + 1,b2);
      return 0}
    function caml_string_set16(s,i,i16){return caml_bytes_set16(s,i,i16)}
    function caml_bytes_set64(s,i,i64)
     {if(i >>> 0 >= s.l - 7)caml_bytes_bound_error();
      var a=caml_int64_to_bytes(i64);
      for(var j=0;j < 8;j++)caml_bytes_unsafe_set(s,i + 7 - j,a[j]);
      return 0}
    function caml_int64_bswap(x)
     {var y=caml_int64_to_bytes(x);
      return caml_int64_of_bytes([y[7],y[6],y[5],y[4],y[3],y[2],y[1],y[0]])}
    function caml_gc_major(unit)
     {if(typeof globalThis.gc == "function")globalThis.gc();return 0}
    function caml_lex_array(s)
     {s = caml_jsbytes_of_string(s);
      var l=s.length / 2,a=new Array(l);
      for(var i=0;i < l;i++)
       a[i]
       =
       (s.charCodeAt(2 * i) | s.charCodeAt(2 * i + 1) << 8)
       <<
       16
       >>
       16;
      return a}
    function caml_lex_engine(tbl,start_state,lexbuf)
     {var
       lex_buffer=2,
       lex_buffer_len=3,
       lex_start_pos=5,
       lex_curr_pos=6,
       lex_last_pos=7,
       lex_last_action=8,
       lex_eof_reached=9,
       lex_base=1,
       lex_backtrk=2,
       lex_default=3,
       lex_trans=4,
       lex_check=5;
      if(! tbl.lex_default)
       {tbl.lex_base = caml_lex_array(tbl[lex_base]);
        tbl.lex_backtrk = caml_lex_array(tbl[lex_backtrk]);
        tbl.lex_check = caml_lex_array(tbl[lex_check]);
        tbl.lex_trans = caml_lex_array(tbl[lex_trans]);
        tbl.lex_default = caml_lex_array(tbl[lex_default])}
      var
       c,
       state=start_state,
       buffer=caml_uint8_array_of_bytes(lexbuf[lex_buffer]);
      if(state >= 0)
       {lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];
        lexbuf[lex_last_action] = - 1}
      else
       state = - state - 1;
      for(;;)
       {var base=tbl.lex_base[state];
        if(base < 0)return - base - 1;
        var backtrk=tbl.lex_backtrk[state];
        if(backtrk >= 0)
         {lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
          lexbuf[lex_last_action] = backtrk}
        if(lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
         if(lexbuf[lex_eof_reached] == 0)return - state - 1;else c = 256;
        else
         {c = buffer[lexbuf[lex_curr_pos]];lexbuf[lex_curr_pos]++}
        if(tbl.lex_check[base + c] == state)
         state = tbl.lex_trans[base + c];
        else
         state = tbl.lex_default[state];
        if(state < 0)
         {lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
          if(lexbuf[lex_last_action] == - 1)
           caml_failwith("lexing: empty token");
          else
           return lexbuf[lex_last_action]}
        else
         if(c == 256)lexbuf[lex_eof_reached] = 0}}
    function caml_sys_file_exists(name)
     {var root=resolve_fs_device(name);return root.device.exists(root.rest)}
    function caml_convert_raw_backtrace_slot()
     {caml_failwith("caml_convert_raw_backtrace_slot")}
    function caml_array_sub(a,i,len)
     {var a2=new Array(len + 1);
      a2[0] = 0;
      for(var i2=1,i1=i + 1;i2 <= len;i2++,i1++)a2[i2] = a[i1];
      return a2}
    function caml_bytes_equal(s1,s2)
     {if(s1 === s2)return 1;
      s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c == s2.c?1:0}
    function caml_gr_size_x(){var s=caml_gr_state_get();return s.width}
    function Base_int_math_int32_clz(x)
     {var n=32,y;
      y = x >> 16;
      if(y != 0){n = n - 16;x = y}
      y = x >> 8;
      if(y != 0){n = n - 8;x = y}
      y = x >> 4;
      if(y != 0){n = n - 4;x = y}
      y = x >> 2;
      if(y != 0){n = n - 2;x = y}
      y = x >> 1;
      if(y != 0)return n - 2;
      return n - x}
    function caml_ml_debug_info_status(){return 0}
    function caml_atomic_fetch_add(ref,i)
     {var old=ref[1];ref[1] += i;return old}
    var
     os_type=
      globalThis.process
       &&
       globalThis.process.platform
       &&
       globalThis.process.platform
       ==
       "win32"
       ?"Cygwin"
       :"Unix";
    function caml_sys_const_ostype_cygwin(){return os_type == "Cygwin"?1:0}
    function caml_cosh_float(x){return Math.cosh(x)}
    function MlMutex(){this.locked = false}
    function caml_ml_mutex_new(unit){return new MlMutex()}
    var caml_ephe_key_offset=3;
    function caml_ephe_check_key(x,i)
     {var weak=x[caml_ephe_key_offset + i];
      if(globalThis.WeakRef && weak instanceof globalThis.WeakRef)
       weak = weak.deref();
      return weak === undefined?0:1}
    function caml_hash_mix_final(h)
     {h ^= h >>> 16;
      h = caml_mul(h,0x85ebca6b | 0);
      h ^= h >>> 13;
      h = caml_mul(h,0xc2b2ae35 | 0);
      h ^= h >>> 16;
      return h}
    function caml_gr_text_size(txt)
     {var
       s=caml_gr_state_get(),
       w=s.context.measureText(caml_jsstring_of_string(txt)).width;
      return [0,w,s.text_size]}
    function caml_lex_run_mem(s,i,mem,curr_pos)
     {for(;;)
       {var dst=s.charCodeAt(i);
        i++;
        if(dst == 0xff)return;
        var src=s.charCodeAt(i);
        i++;
        if(src == 0xff)
         mem[dst + 1] = curr_pos;
        else
         mem[dst + 1] = mem[src + 1]}}
    function caml_lex_run_tag(s,i,mem)
     {for(;;)
       {var dst=s.charCodeAt(i);
        i++;
        if(dst == 0xff)return;
        var src=s.charCodeAt(i);
        i++;
        if(src == 0xff)mem[dst + 1] = - 1;else mem[dst + 1] = mem[src + 1]}}
    function caml_new_lex_engine(tbl,start_state,lexbuf)
     {var
       lex_buffer=2,
       lex_buffer_len=3,
       lex_start_pos=5,
       lex_curr_pos=6,
       lex_last_pos=7,
       lex_last_action=8,
       lex_eof_reached=9,
       lex_mem=10,
       lex_base=1,
       lex_backtrk=2,
       lex_default=3,
       lex_trans=4,
       lex_check=5,
       lex_base_code=6,
       lex_backtrk_code=7,
       lex_default_code=8,
       lex_trans_code=9,
       lex_check_code=10,
       lex_code=11;
      if(! tbl.lex_default)
       {tbl.lex_base = caml_lex_array(tbl[lex_base]);
        tbl.lex_backtrk = caml_lex_array(tbl[lex_backtrk]);
        tbl.lex_check = caml_lex_array(tbl[lex_check]);
        tbl.lex_trans = caml_lex_array(tbl[lex_trans]);
        tbl.lex_default = caml_lex_array(tbl[lex_default])}
      if(! tbl.lex_default_code)
       {tbl.lex_base_code = caml_lex_array(tbl[lex_base_code]);
        tbl.lex_backtrk_code = caml_lex_array(tbl[lex_backtrk_code]);
        tbl.lex_check_code = caml_lex_array(tbl[lex_check_code]);
        tbl.lex_trans_code = caml_lex_array(tbl[lex_trans_code]);
        tbl.lex_default_code = caml_lex_array(tbl[lex_default_code])}
      if(tbl.lex_code == null)
       tbl.lex_code = caml_jsbytes_of_string(tbl[lex_code]);
      var
       c,
       state=start_state,
       buffer=caml_uint8_array_of_bytes(lexbuf[lex_buffer]);
      if(state >= 0)
       {lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];
        lexbuf[lex_last_action] = - 1}
      else
       state = - state - 1;
      for(;;)
       {var base=tbl.lex_base[state];
        if(base < 0)
         {var pc_off=tbl.lex_base_code[state];
          caml_lex_run_tag(tbl.lex_code,pc_off,lexbuf[lex_mem]);
          return - base - 1}
        var backtrk=tbl.lex_backtrk[state];
        if(backtrk >= 0)
         {var pc_off=tbl.lex_backtrk_code[state];
          caml_lex_run_tag(tbl.lex_code,pc_off,lexbuf[lex_mem]);
          lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
          lexbuf[lex_last_action] = backtrk}
        if(lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
         if(lexbuf[lex_eof_reached] == 0)return - state - 1;else c = 256;
        else
         {c = buffer[lexbuf[lex_curr_pos]];lexbuf[lex_curr_pos]++}
        var pstate=state;
        if(tbl.lex_check[base + c] == state)
         state = tbl.lex_trans[base + c];
        else
         state = tbl.lex_default[state];
        if(state < 0)
         {lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
          if(lexbuf[lex_last_action] == - 1)
           caml_failwith("lexing: empty token");
          else
           return lexbuf[lex_last_action]}
        else
         {var base_code=tbl.lex_base_code[pstate],pc_off;
          if(tbl.lex_check_code[base_code + c] == pstate)
           pc_off = tbl.lex_trans_code[base_code + c];
          else
           pc_off = tbl.lex_default_code[pstate];
          if(pc_off > 0)
           caml_lex_run_mem
            (tbl.lex_code,pc_off,lexbuf[lex_mem],lexbuf[lex_curr_pos]);
          if(c == 256)lexbuf[lex_eof_reached] = 0}}}
    function caml_ba_uint8_set64(ba,i0,v)
     {var ofs=ba.offset(i0);
      if(ofs + 7 >= ba.data.length)caml_array_bound_error();
      var v=caml_int64_to_bytes(v);
      for(var i=0;i < 8;i++)ba.set(ofs + i,v[7 - i]);
      return 0}
    function caml_sys_executable_name(a){return caml_executable_name}
    function caml_lessequal(x,y){return + (caml_compare_val(x,y,false) <= 0)}
    function caml_acosh_float(x){return Math.acosh(x)}
    function caml_MD5Init()
     {var
       buffer=new ArrayBuffer(64),
       b32=new Uint32Array(buffer),
       b8=new Uint8Array(buffer);
      return {len:0,
              w:new Uint32Array([0x67452301,0xEFCDAB89,0x98BADCFE,0x10325476]),
              b32:b32,
              b8:b8}}
    function caml_ml_flush(chanid)
     {var chan=caml_ml_channels[chanid];
      if(! chan.opened)caml_raise_sys_error("Cannot flush a closed channel");
      if(! chan.buffer || chan.buffer_curr == 0)return 0;
      if(chan.output)
       chan.output(caml_subarray_to_jsbytes(chan.buffer,0,chan.buffer_curr));
      else
       chan.file.write(chan.offset,chan.buffer,0,chan.buffer_curr);
      chan.offset += chan.buffer_curr;
      chan.buffer_curr = 0;
      return 0}
    function caml_seek_out(chanid,pos)
     {caml_ml_flush(chanid);
      var chan=caml_ml_channels[chanid];
      chan.offset = pos;
      return 0}
    function caml_ml_seek_out_64(chanid,pos)
     {var pos=caml_int64_to_float(pos);return caml_seek_out(chanid,pos)}
    function compare_nat_real(nat1,nat2)
     {return compare_nat(nat1,0,nat1.data.length,nat2,0,nat2.data.length)}
    function caml_gc_set(_control){return 0}
    function caml_js_get(o,f){return o[f]}
    function caml_unix_isatty(fileDescriptor)
     {if(fs_node_supported())
       {var tty=require("tty");return tty.isatty(fileDescriptor)?1:0}
      else
       return 0}
    function caml_ml_set_buffered(chanid,v)
     {caml_ml_channels[chanid].buffered = v;
      if(! v)caml_ml_flush(chanid);
      return 0}
    function caml_hash_mix_bytes_arr(h,s)
     {var len=s.length,i,w;
      for(i = 0;i + 4 <= len;i += 4)
       {w = s[i] | s[i + 1] << 8 | s[i + 2] << 16 | s[i + 3] << 24;
        h = caml_hash_mix_int(h,w)}
      w = 0;
      switch(len & 3)
       {case 3:w = s[i + 2] << 16;
        case 2:w |= s[i + 1] << 8;
        case 1:w |= s[i];h = caml_hash_mix_int(h,w)
        }
      h ^= len;
      return h}
    function caml_ml_bytes_content(s)
     {switch(s.t & 6)
       {default:caml_convert_string_to_bytes(s);case 0:return s.c;
        case 4:return s.c
        }}
    function caml_hash_mix_bytes(h,v)
     {var content=caml_ml_bytes_content(v);
      return typeof content === "string"
              ?caml_hash_mix_jsbytes(h,content)
              :caml_hash_mix_bytes_arr(h,content)}
    function caml_hash(count,limit,seed,obj)
     {var queue,rd,wr,sz,num,h,v,i,len;
      sz = limit;
      if(sz < 0 || sz > 256)sz = 256;
      num = count;
      h = seed;
      queue = [obj];
      rd = 0;
      wr = 1;
      while(rd < wr && num > 0)
       {v = queue[rd++];
        if(v && v.caml_custom)
         {if
           (caml_custom_ops[v.caml_custom]
            &&
            caml_custom_ops[v.caml_custom].hash)
           {var hh=caml_custom_ops[v.caml_custom].hash(v);
            h = caml_hash_mix_int(h,hh);
            num--}}
        else
         if(v instanceof Array && v[0] === (v[0] | 0))
          switch(v[0])
           {case 248:h = caml_hash_mix_int(h,v[2]);num--;break;
            case 250:queue[--rd] = v[1];break;
            default:
             if(caml_is_continuation_tag(v[0]))break;
             var tag=v.length - 1 << 10 | v[0];
             h = caml_hash_mix_int(h,tag);
             for(i = 1,len = v.length;i < len;i++)
              {if(wr >= sz)break;queue[wr++] = v[i]}
             break}
         else
          if(caml_is_ml_bytes(v))
           {h = caml_hash_mix_bytes(h,v);num--}
          else
           if(caml_is_ml_string(v))
            {h = caml_hash_mix_string(h,v);num--}
           else
            if(typeof v === "string")
             {h = caml_hash_mix_jsbytes(h,v);num--}
            else
             if(v === (v | 0))
              {h = caml_hash_mix_int(h,v + v + 1);num--}
             else
              if(v === + v){h = caml_hash_mix_float(h,v);num--}}
      h = caml_hash_mix_final(h);
      return h & 0x3FFFFFFF}
    function Base_hash_string(s){return caml_hash(1,1,0,s)}
    function caml_gc_compaction(){return 0}
    function caml_ephe_get_key(x,i)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.get_key");
      var weak=x[caml_ephe_key_offset + i];
      if(globalThis.WeakRef && weak instanceof globalThis.WeakRef)
       weak = weak.deref();
      return weak === undefined?0:[0,weak]}
    function caml_unix_localtime(t)
     {var
       d=new Date(t * 1000),
       d_num=d.getTime(),
       januaryfirst=new Date(d.getFullYear(),0,1).getTime(),
       doy=Math.floor((d_num - januaryfirst) / 86400000),
       jan=new Date(d.getFullYear(),0,1),
       jul=new Date(d.getFullYear(),6,1),
       stdTimezoneOffset=
        Math.max(jan.getTimezoneOffset(),jul.getTimezoneOffset());
      return [0,
              d.getSeconds(),
              d.getMinutes(),
              d.getHours(),
              d.getDate(),
              d.getMonth(),
              d.getFullYear() - 1900,
              d.getDay(),
              doy,
              d.getTimezoneOffset() < stdTimezoneOffset | 0]}
    function caml_unix_mktime(tm)
     {var
       d=new Date(tm[6] + 1900,tm[5],tm[4],tm[3],tm[2],tm[1]).getTime(),
       t=Math.floor(d / 1000),
       tm2=caml_unix_localtime(t);
      return [0,t,tm2]}
    function caml_bigstring_blit_bytes_to_ba(str1,pos1,ba2,pos2,len)
     {if(12 != ba2.kind)
       caml_invalid_argument
        ("caml_bigstring_blit_string_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs2=ba2.offset(pos2);
      if(pos1 + len > caml_ml_bytes_length(str1))caml_array_bound_error();
      if(ofs2 + len > ba2.data.length)caml_array_bound_error();
      var slice=caml_uint8_array_of_bytes(str1).slice(pos1,pos1 + len);
      ba2.data.set(slice,ofs2);
      return 0}
    var caml_sys_fds=new Array(3);
    function caml_sys_close(fd)
     {var file=caml_sys_fds[fd];
      if(file)file.close();
      delete caml_sys_fds[fd];
      return 0}
    function caml_ml_close_channel(chanid)
     {var chan=caml_ml_channels[chanid];
      chan.opened = false;
      caml_sys_close(chan.fd);
      return 0}
    function caml_exn_with_js_backtrace(exn,force)
     {if(! exn.js_error || force || exn[0] == 248)
       exn.js_error
       =
       new (globalThis.Error)("Js exception containing backtrace");
      return exn}
    function Base_int_math_int_pow_stub(base,exponent)
     {var one=1,mul=[one,base,one,one],res=one;
      while(! exponent == 0)
       {mul[1] = mul[1] * mul[3] | 0;
        mul[2] = mul[1] * mul[1] | 0;
        mul[3] = mul[2] * mul[1] | 0;
        res = res * mul[exponent & 3] | 0;
        exponent = exponent >> 2}
      return res}
    function caml_atomic_exchange(ref,v){var r=ref[1];ref[1] = v;return r}
    function caml_sys_isatty(_chan){return 0}
    function is_digit_zero(nat,ofs){if(nat.data[ofs] == 0)return 1;return 0}
    function caml_unix_lstat(name)
     {var root=resolve_fs_device(name);
      if(! root.device.lstat)
       caml_failwith("caml_unix_lstat: not implemented");
      return root.device.lstat(root.rest,true)}
    function caml_unix_lstat_64(name)
     {var r=caml_unix_lstat(name);r[9] = caml_int64_of_int32(r[9])}
    function caml_js_set(o,f,v){o[f] = v;return 0}
    function caml_array_get(array,index)
     {if(index < 0 || index >= array.length - 1)caml_array_bound_error();
      return array[index + 1]}
    function caml_continuation_use_noexc(cont)
     {var stack=cont[1];cont[1] = 0;return stack}
    function caml_unix_rmdir(name)
     {var root=resolve_fs_device(name);
      if(! root.device.rmdir)
       caml_failwith("caml_unix_rmdir: not implemented");
      return root.device.rmdir(root.rest,true)}
    function caml_log2_float(x){return Math.log2(x)}
    function caml_gc_huge_fallback_count(unit){return 0}
    function caml_spacetime_only_works_for_native_code()
     {caml_failwith("Spacetime profiling only works for native code")}
    function caml_int64_sub(x,y){return x.sub(y)}
    function caml_seek_in(chanid,pos)
     {var chan=caml_ml_channels[chanid];
      if(chan.refill != null)caml_raise_sys_error("Illegal seek");
      if
       (pos
        >=
        chan.offset
        -
        chan.buffer_max
        &&
        pos
        <=
        chan.offset
        &&
        chan.file.flags.binary)
       chan.buffer_curr = chan.buffer_max - (chan.offset - pos);
      else
       {chan.offset = pos;chan.buffer_curr = 0;chan.buffer_max = 0}
      return 0}
    function caml_ml_seek_in_64(chanid,pos)
     {var pos=caml_int64_to_float(pos);return caml_seek_in(chanid,pos)}
    var caml_domain_id=0;
    function caml_ml_mutex_unlock(t){t.locked = false;return 0}
    var caml_domain_latest_idx=1;
    function caml_domain_spawn(f,mutex)
     {var id=caml_domain_latest_idx++,old=caml_domain_id;
      caml_domain_id = id;
      caml_callback(f,[0]);
      caml_domain_id = old;
      caml_ml_mutex_unlock(mutex);
      return id}
    function caml_unix_mkdir(name,perm)
     {var root=resolve_fs_device(name);
      if(! root.device.mkdir)
       caml_failwith("caml_unix_mkdir: not implemented");
      return root.device.mkdir(root.rest,perm,true)}
    function caml_int64_shift_left(x,s){return x.shift_left(s)}
    function caml_notequal(x,y){return + (caml_compare_val(x,y,false) != 0)}
    function caml_sys_const_int_size(){return 32}
    function caml_js_wrap_callback(f)
     {return function()
       {var len=arguments.length;
        if(len > 0)
         {var args=new Array(len);
          for(var i=0;i < len;i++)args[i] = arguments[i]}
        else
         args = [undefined];
        var res=caml_callback(f,args);
        return res instanceof Function?caml_js_wrap_callback(res):res}}
    function caml_js_wrap_meth_callback(f)
     {return function()
       {var len=arguments.length,args=new Array(len + 1);
        args[0] = this;
        for(var i=0;i < len;i++)args[i + 1] = arguments[i];
        var res=caml_callback(f,args);
        return res instanceof Function?caml_js_wrap_callback(res):res}}
    function caml_is_js(){return 1}
    var Base_internalhash_fold_float=caml_hash_mix_float;
    function caml_lazy_update_to_forward(o)
     {caml_obj_update_tag(o,244,250);return 0}
    function caml_ba_dim(ba,i)
     {if(i < 0 || i >= ba.dims.length)caml_invalid_argument("Bigarray.dim");
      return ba.dims[i]}
    function caml_ba_dim_1(ba){return caml_ba_dim(ba,0)}
    function caml_js_meth_call(o,f,args)
     {return o[caml_jsstring_of_string(f)].apply(o,caml_js_from_array(args))}
    var caml_ephe_data_offset=2;
    function caml_weak_create(n)
     {if(n < 0)caml_invalid_argument("Weak.create");
      var x=[251,"caml_ephe_list_head"];
      x.length = caml_ephe_key_offset + n;
      return x}
    function caml_ephe_create(n){var x=caml_weak_create(n);return x}
    function caml_js_to_byte_string(s){return caml_string_of_jsbytes(s)}
    function caml_trampoline(res)
     {var c=1;
      while(res && res.joo_tramp)
       {res = res.joo_tramp.apply(null,res.joo_args);c++}
      return res}
    function caml_maybe_print_stats(unit){return 0}
    function caml_bytes_get64(s,i)
     {if(i >>> 0 >= s.l - 7)caml_bytes_bound_error();
      var a=new Array(8);
      for(var j=0;j < 8;j++)a[7 - j] = caml_bytes_unsafe_get(s,i + j);
      return caml_int64_of_bytes(a)}
    function caml_unix_has_symlink(unit){return fs_node_supported()?1:0}
    function caml_ephe_set_key(x,i,v)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.set");
      if(v instanceof Object && globalThis.WeakRef)
       {if(x[1].register)x[1].register(v,undefined,v);
        x[caml_ephe_key_offset + i] = new (globalThis.WeakRef)(v)}
      else
       x[caml_ephe_key_offset + i] = v;
      return 0}
    function caml_ephe_unset_key(x,i)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.set");
      if
       (globalThis.WeakRef
        &&
        x[caml_ephe_key_offset + i] instanceof globalThis.WeakRef
        &&
        x[1].unregister)
       {var old=x[caml_ephe_key_offset + i].deref();
        if(old !== undefined)
         {var count=0;
          for(var j=caml_ephe_key_offset;j < x.length;j++)
           {var key=x[j];
            if(key instanceof globalThis.WeakRef)
             {key = key.deref();if(key === old)count++}}
          if(count == 1)x[1].unregister(old)}}
      x[caml_ephe_key_offset + i] = undefined;
      return 0}
    function caml_weak_set(x,i,v)
     {if(v == 0)caml_ephe_unset_key(x,i);else caml_ephe_set_key(x,i,v[1]);
      return 0}
    function caml_sys_remove(name)
     {var root=resolve_fs_device(name),ok=root.device.unlink(root.rest);
      if(ok == 0)caml_raise_no_such_file(caml_jsbytes_of_string(name));
      return 0}
    function caml_string_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_string_get32(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s) - 3)caml_string_bound_error();
      var
       b1=caml_string_unsafe_get(s,i),
       b2=caml_string_unsafe_get(s,i + 1),
       b3=caml_string_unsafe_get(s,i + 2),
       b4=caml_string_unsafe_get(s,i + 3);
      return b4 << 24 | b3 << 16 | b2 << 8 | b1}
    function caml_bytes_get(s,i)
     {if(i >>> 0 >= s.l)caml_bytes_bound_error();
      return caml_bytes_unsafe_get(s,i)}
    function caml_hypot_float(x,y){return Math.hypot(x,y)}
    function caml_js_call(f,o,args)
     {return f.apply(o,caml_js_from_array(args))}
    function caml_sys_const_max_wosize(){return 0x7FFFFFFF / 4 | 0}
    function caml_unix_inet_addr_of_string(){return 0}
    function Base_am_testing(x){return 0}
    function caml_bytes_lessthan(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c < s2.c?1:0}
    function caml_erfc_float(x){return 1 - caml_erf_float(x)}
    function caml_gr_fill_poly(ar)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      s.context.moveTo(ar[1][1],s.height - ar[1][2]);
      for(var i=2;i < ar.length;i++)
       s.context.lineTo(ar[i][1],s.height - ar[i][2]);
      s.context.lineTo(ar[1][1],s.height - ar[1][2]);
      s.context.fill();
      return 0}
    function caml_gc_quick_stat(){return [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}
    function caml_ml_input_char(chanid)
     {var chan=caml_ml_channels[chanid];
      if(chan.buffer_curr >= chan.buffer_max)
       {chan.buffer_curr = 0;chan.buffer_max = 0;caml_refill(chan)}
      if(chan.buffer_curr >= chan.buffer_max)caml_raise_end_of_file();
      var res=chan.buffer[chan.buffer_curr];
      chan.buffer_curr++;
      return res}
    function caml_ml_input_int(chanid)
     {var chan=caml_ml_channels[chanid],res=0;
      for(var i=0;i < 4;i++)res = (res << 8) + caml_ml_input_char(chanid);
      return res}
    function caml_gr_display_mode()
     {caml_failwith("caml_gr_display_mode not Implemented")}
    function caml_obj_reachable_words(o){return 0}
    function nth_digit_nat(nat,ofs){return nat.data[ofs]}
    function caml_array_blit(a1,i1,a2,i2,len)
     {if(i2 <= i1)
       for(var j=1;j <= len;j++)a2[i2 + j] = a1[i1 + j];
      else
       for(var j=len;j >= 1;j--)a2[i2 + j] = a1[i1 + j];
      return 0}
    function caml_float_of_string(s)
     {var res;
      s = caml_jsbytes_of_string(s);
      res = + s;
      if(s.length > 0 && res === res)return res;
      s = s.replace(/_/g,"");
      res = + s;
      if(s.length > 0 && res === res || /^[+-]?nan$/i.test(s))return res;
      var m=/^ *([+-]?)0x([0-9a-f]+)\.?([0-9a-f]*)(p([+-]?[0-9]+))?/i.exec(s);
      if(m)
       {var
         m3=m[3].replace(/0+$/,""),
         mantissa=parseInt(m[1] + m[2] + m3,16),
         exponent=(m[5] | 0) - 4 * m3.length;
        res = mantissa * Math.pow(2,exponent);
        return res}
      if(/^\+?inf(inity)?$/i.test(s))return Infinity;
      if(/^-inf(inity)?$/i.test(s))return - Infinity;
      caml_failwith("float_of_string")}
    function caml_sys_getcwd()
     {return caml_string_of_jsbytes(caml_current_dir)}
    function caml_int64_add(x,y){return x.add(y)}
    function caml_int64_mul(x,y){return x.mul(y)}
    function caml_int64_ult(x,y){return x.ucompare(y) < 0}
    function caml_parse_sign_and_base(s)
     {var i=0,len=caml_ml_string_length(s),base=10,sign=1;
      if(len > 0)
       switch(caml_string_unsafe_get(s,i))
        {case 45:i++;sign = - 1;break;case 43:i++;sign = 1;break}
      if(i + 1 < len && caml_string_unsafe_get(s,i) == 48)
       switch(caml_string_unsafe_get(s,i + 1))
        {case 120:
         case 88:base = 16;i += 2;break;
         case 111:
         case 79:base = 8;i += 2;break;
         case 98:
         case 66:base = 2;i += 2;break;
         case 117:
         case 85:i += 2;break
         }
      return [i,sign,base]}
    function caml_parse_digit(c)
     {if(c >= 48 && c <= 57)return c - 48;
      if(c >= 65 && c <= 90)return c - 55;
      if(c >= 97 && c <= 122)return c - 87;
      return - 1}
    function caml_int64_of_string(s)
     {var
       r=caml_parse_sign_and_base(s),
       i=r[0],
       sign=r[1],
       base=r[2],
       base64=caml_int64_of_int32(base),
       threshold=
        new MlInt64(0xffffff,0xfffffff,0xffff).udivmod(base64).quotient,
       c=caml_string_unsafe_get(s,i),
       d=caml_parse_digit(c);
      if(d < 0 || d >= base)caml_failwith("int_of_string");
      var res=caml_int64_of_int32(d);
      for(;;)
       {i++;
        c = caml_string_unsafe_get(s,i);
        if(c == 95)continue;
        d = caml_parse_digit(c);
        if(d < 0 || d >= base)break;
        if(caml_int64_ult(threshold,res))caml_failwith("int_of_string");
        d = caml_int64_of_int32(d);
        res = caml_int64_add(caml_int64_mul(base64,res),d);
        if(caml_int64_ult(res,d))caml_failwith("int_of_string")}
      if(i != caml_ml_string_length(s))caml_failwith("int_of_string");
      if(base == 10 && caml_int64_ult(new MlInt64(0,0,0x8000),res))
       caml_failwith("int_of_string");
      if(sign < 0)res = caml_int64_neg(res);
      return res}
    function caml_ba_set_1(ba,i0,v){ba.set(ba.offset(i0),v);return 0}
    function caml_int64_xor(x,y){return x.xor(y)}
    function caml_int64_or(x,y){return x.or(y)}
    function caml_lxm_next(v)
     {function shift_l(x,k){return caml_int64_shift_left(x,k)}
      function shift_r(x,k){return caml_int64_shift_right_unsigned(x,k)}
      function or(a,b){return caml_int64_or(a,b)}
      function xor(a,b){return caml_int64_xor(a,b)}
      function add(a,b){return caml_int64_add(a,b)}
      function mul(a,b){return caml_int64_mul(a,b)}
      function rotl(x,k){return or(shift_l(x,k),shift_r(x,64 - k))}
      function get(a,i){return caml_ba_get_1(a,i)}
      function set(a,i,x){return caml_ba_set_1(a,i,x)}
      var
       M=caml_int64_of_string(caml_new_string("0xd1342543de82ef95")),
       daba=caml_int64_of_string(caml_new_string("0xdaba0b6eb09322e3")),
       z,
       q0,
       q1,
       st=v,
       a=get(st,0),
       s=get(st,1),
       x0=get(st,2),
       x1=get(st,3);
      z = add(s,x0);
      z = mul(xor(z,shift_r(z,32)),daba);
      z = mul(xor(z,shift_r(z,32)),daba);
      z = xor(z,shift_r(z,32));
      set(st,1,add(mul(s,M),a));
      var q0=x0,q1=x1;
      q1 = xor(q1,q0);
      q0 = rotl(q0,24);
      q0 = xor(xor(q0,q1),shift_l(q1,16));
      q1 = rotl(q1,37);
      set(st,2,q0);
      set(st,3,q1);
      return z}
    function caml_sys_const_big_endian(){return 0}
    function caml_list_to_js_array(l)
     {var a=[];for(;l !== 0;l = l[2])a.push(l[1]);return a}
    var
     caml_legacy_custom_code=false,
     caml_output_val=
      function()
        {function Writer(){this.chunk = []}
         Writer.prototype
         =
         {chunk_idx:20,
          block_len:0,
          obj_counter:0,
          size_32:0,
          size_64:0,
          write:
          function(size,value)
           {for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[this.chunk_idx++] = value >> i & 0xFF},
          write_at:
          function(pos,size,value)
           {var pos=pos;
            for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[pos++] = value >> i & 0xFF},
          write_code:
          function(size,code,value)
           {this.chunk[this.chunk_idx++] = code;
            for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[this.chunk_idx++] = value >> i & 0xFF},
          write_shared:
          function(offset)
           {if(offset < 1 << 8)
             this.write_code(8,0x04,offset);
            else
             if(offset < 1 << 16)
              this.write_code(16,0x05,offset);
             else
              this.write_code(32,0x06,offset)},
          pos:function(){return this.chunk_idx},
          finalize:
          function()
           {this.block_len = this.chunk_idx - 20;
            this.chunk_idx = 0;
            this.write(32,0x8495A6BE);
            this.write(32,this.block_len);
            this.write(32,this.obj_counter);
            this.write(32,this.size_32);
            this.write(32,this.size_64);
            return this.chunk}};
         return function(v,flags)
          {flags = caml_list_to_js_array(flags);
           var
            no_sharing=flags.indexOf(0) !== - 1,
            closures=flags.indexOf(1) !== - 1;
           if(closures)
            console.warn
             ("in caml_output_val: flag Marshal.Closures is not supported.");
           var
            writer=new Writer(),
            stack=[],
            intern_obj_table=no_sharing?null:new MlObjectTable();
           function memo(v)
            {if(no_sharing)return false;
             var existing_offset=intern_obj_table.recall(v);
             if(existing_offset)
              {writer.write_shared(existing_offset);return true}
             else
              {intern_obj_table.store(v);return false}}
           function extern_rec(v)
            {if(v.caml_custom)
              {if(memo(v))return;
               var
                name=v.caml_custom,
                ops=caml_custom_ops[name],
                sz_32_64=[0,0];
               if(! ops.serialize)
                caml_invalid_argument("output_value: abstract value (Custom)");
               if(caml_legacy_custom_code)
                {writer.write(8,0x12);
                 for(var i=0;i < name.length;i++)
                  writer.write(8,name.charCodeAt(i));
                 writer.write(8,0);
                 ops.serialize(writer,v,sz_32_64)}
               else
                if(ops.fixed_length == undefined)
                 {writer.write(8,0x18);
                  for(var i=0;i < name.length;i++)
                   writer.write(8,name.charCodeAt(i));
                  writer.write(8,0);
                  var header_pos=writer.pos();
                  for(var i=0;i < 12;i++)writer.write(8,0);
                  ops.serialize(writer,v,sz_32_64);
                  writer.write_at(header_pos,32,sz_32_64[0]);
                  writer.write_at(header_pos + 4,32,0);
                  writer.write_at(header_pos + 8,32,sz_32_64[1])}
                else
                 {writer.write(8,0x19);
                  for(var i=0;i < name.length;i++)
                   writer.write(8,name.charCodeAt(i));
                  writer.write(8,0);
                  var old_pos=writer.pos();
                  ops.serialize(writer,v,sz_32_64);
                  if(ops.fixed_length != writer.pos() - old_pos)
                   caml_failwith
                    ("output_value: incorrect fixed sizes specified by " + name)}
               writer.size_32 += 2 + (sz_32_64[0] + 3 >> 2);
               writer.size_64 += 2 + (sz_32_64[1] + 7 >> 3)}
             else
              if(v instanceof Array && v[0] === (v[0] | 0))
               {if(v[0] == 251)
                 caml_failwith("output_value: abstract value (Abstract)");
                if(caml_is_continuation_tag(v[0]))
                 caml_invalid_argument("output_value: continuation value");
                if(v.length > 1 && memo(v))return;
                if(v[0] < 16 && v.length - 1 < 8)
                 writer.write(8,0x80 + v[0] + (v.length - 1 << 4));
                else
                 writer.write_code(32,0x08,v.length - 1 << 10 | v[0]);
                writer.size_32 += v.length;
                writer.size_64 += v.length;
                if(v.length > 1)stack.push(v,1)}
              else
               if(caml_is_ml_bytes(v))
                {if(! caml_is_ml_bytes(caml_string_of_jsbytes("")))
                  caml_failwith
                   ("output_value: [Bytes.t] cannot safely be marshaled with [--enable use-js-string]");
                 if(memo(v))return;
                 var len=caml_ml_bytes_length(v);
                 if(len < 0x20)
                  writer.write(8,0x20 + len);
                 else
                  if(len < 0x100)
                   writer.write_code(8,0x09,len);
                  else
                   writer.write_code(32,0x0A,len);
                 for(var i=0;i < len;i++)
                  writer.write(8,caml_bytes_unsafe_get(v,i));
                 writer.size_32 += 1 + ((len + 4) / 4 | 0);
                 writer.size_64 += 1 + ((len + 8) / 8 | 0)}
               else
                if(caml_is_ml_string(v))
                 {var len=caml_ml_string_length(v);
                  if(len < 0x20)
                   writer.write(8,0x20 + len);
                  else
                   if(len < 0x100)
                    writer.write_code(8,0x09,len);
                   else
                    writer.write_code(32,0x0A,len);
                  for(var i=0;i < len;i++)
                   writer.write(8,caml_string_unsafe_get(v,i));
                  writer.size_32 += 1 + ((len + 4) / 4 | 0);
                  writer.size_64 += 1 + ((len + 8) / 8 | 0)}
                else
                 if(v != (v | 0))
                  {var type_of_v=typeof v;
                   caml_failwith
                    ("output_value: abstract value (" + type_of_v + ")")}
                 else
                  if(v >= 0 && v < 0x40)
                   writer.write(8,0X40 + v);
                  else
                   if(v >= - (1 << 7) && v < 1 << 7)
                    writer.write_code(8,0x00,v);
                   else
                    if(v >= - (1 << 15) && v < 1 << 15)
                     writer.write_code(16,0x01,v);
                    else
                     writer.write_code(32,0x02,v)}
           extern_rec(v);
           while(stack.length > 0)
            {var i=stack.pop(),v=stack.pop();
             if(i + 1 < v.length)stack.push(v,i + 1);
             extern_rec(v[i])}
           if(intern_obj_table)
            writer.obj_counter = intern_obj_table.objs.length;
           writer.finalize();
           return writer.chunk}}
       ();
    function caml_string_of_array(a)
     {return caml_string_of_jsbytes(caml_subarray_to_jsbytes(a,0,a.length))}
    function caml_output_value_to_string(v,flags)
     {return caml_string_of_array(caml_output_val(v,flags))}
    function caml_raise_not_a_dir(name)
     {caml_raise_sys_error(name + ": Not a directory")}
    function caml_sys_system_command(cmd)
     {var cmd=caml_jsstring_of_string(cmd);
      if(typeof require != "undefined")
       {var child_process=require("child_process");
        if(child_process && child_process.execSync)
         try
          {child_process.execSync(cmd,{stdio:"inherit"});return 0}
         catch(e){return 1}}
      else
       return 127}
    function caml_js_error_of_exception(exn)
     {if(exn.js_error)return exn.js_error;return null}
    function caml_unix_getuid(unit)
     {if(globalThis.process && globalThis.process.getuid)
       return globalThis.process.getuid();
      caml_raise_not_found()}
    function deserialize_nat(reader,sz)
     {var len=reader.read32s(),nat=new MlNat(len);
      for(var i=0;i < len;i++)nat.data[i] = reader.read32s();
      sz[0] = len * 4;
      return nat}
    function initialize_nat()
     {caml_custom_ops["_nat"]
      =
      {deserialize:deserialize_nat,serialize:serialize_nat,hash:caml_hash_nat}}
    function caml_gr_open_subwindow(a,b,c,d)
     {caml_failwith("caml_gr_open_subwindow not Implemented")}
    function caml_marshal_data_size(s,ofs)
     {function get32(s,i)
       {return caml_bytes_unsafe_get(s,i)
               <<
               24
               |
               caml_bytes_unsafe_get(s,i + 1)
               <<
               16
               |
               caml_bytes_unsafe_get(s,i + 2)
               <<
               8
               |
               caml_bytes_unsafe_get(s,i + 3)}
      if(get32(s,ofs) != (0x8495A6BE | 0))
       caml_failwith("Marshal.data_size: bad object");
      return get32(s,ofs + 4)}
    function MlStringReader(s,i)
     {this.s = caml_jsbytes_of_string(s);this.i = i}
    MlStringReader.prototype
    =
    {read8u:function(){return this.s.charCodeAt(this.i++)},
     read8s:function(){return this.s.charCodeAt(this.i++) << 24 >> 24},
     read16u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return s.charCodeAt(i) << 8 | s.charCodeAt(i + 1)},
     read16s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return s.charCodeAt(i) << 24 >> 16 | s.charCodeAt(i + 1)},
     read32u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return (s.charCodeAt(i)
               <<
               24
               |
               s.charCodeAt(i + 1)
               <<
               16
               |
               s.charCodeAt(i + 2)
               <<
               8
               |
               s.charCodeAt(i + 3))
              >>>
              0},
     read32s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return s.charCodeAt(i)
              <<
              24
              |
              s.charCodeAt(i + 1)
              <<
              16
              |
              s.charCodeAt(i + 2)
              <<
              8
              |
              s.charCodeAt(i + 3)},
     readstr:
     function(len)
      {var i=this.i;
       this.i = i + len;
       return caml_string_of_jsbytes(this.s.substring(i,i + len))}};
    function caml_float_of_bytes(a)
     {return caml_int64_float_of_bits(caml_int64_of_bytes(a))}
    function caml_input_value_from_reader(reader,ofs)
     {var
       _magic=reader.read32u(),
       _block_len=reader.read32u(),
       num_objects=reader.read32u(),
       _size_32=reader.read32u(),
       _size_64=reader.read32u(),
       stack=[],
       intern_obj_table=num_objects > 0?[]:null,
       obj_counter=0;
      function intern_rec()
       {var code=reader.read8u();
        if(code >= 0x40)
         if(code >= 0x80)
          {var tag=code & 0xF,size=code >> 4 & 0x7,v=[tag];
           if(size == 0)return v;
           if(intern_obj_table)intern_obj_table[obj_counter++] = v;
           stack.push(v,size);
           return v}
         else
          return code & 0x3F;
        else
         if(code >= 0x20)
          {var len=code & 0x1F,v=reader.readstr(len);
           if(intern_obj_table)intern_obj_table[obj_counter++] = v;
           return v}
         else
          switch(code)
           {case 0x00:return reader.read8s();
            case 0x01:return reader.read16s();
            case 0x02:return reader.read32s();
            case 0x03:caml_failwith("input_value: integer too large");break;
            case 0x04:
             var offset=reader.read8u();
             return intern_obj_table[obj_counter - offset];
            case 0x05:
             var offset=reader.read16u();
             return intern_obj_table[obj_counter - offset];
            case 0x06:
             var offset=reader.read32u();
             return intern_obj_table[obj_counter - offset];
            case 0x08:
             var
              header=reader.read32u(),
              tag=header & 0xFF,
              size=header >> 10,
              v=[tag];
             if(size == 0)return v;
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             stack.push(v,size);
             return v;
            case 0x13:
             caml_failwith("input_value: data block too large");break;
            case 0x09:
             var len=reader.read8u(),v=reader.readstr(len);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0A:
             var len=reader.read32u(),v=reader.readstr(len);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0C:
             var t=new Array(8);
             for(var i=0;i < 8;i++)t[7 - i] = reader.read8u();
             var v=caml_float_of_bytes(t);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0B:
             var t=new Array(8);
             for(var i=0;i < 8;i++)t[i] = reader.read8u();
             var v=caml_float_of_bytes(t);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0E:
             var len=reader.read8u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[7 - j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x0D:
             var len=reader.read8u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x07:
             var len=reader.read32u(),v=new Array(len + 1);
             v[0] = 254;
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             var t=new Array(8);
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[7 - j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x0F:
             var len=reader.read32u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x10:
            case 0x11:caml_failwith("input_value: code pointer");break;
            case 0x12:
            case 0x18:
            case 0x19:
             var c,s="";
             while((c = reader.read8u()) != 0)s += String.fromCharCode(c);
             var ops=caml_custom_ops[s],expected_size;
             if(! ops)
              caml_failwith("input_value: unknown custom block identifier");
             switch(code)
              {case 0x12:break;
               case 0x19:
                if(! ops.fixed_length)
                 caml_failwith
                  ("input_value: expected a fixed-size custom block");
                expected_size = ops.fixed_length;
                break;
               case 0x18:
                expected_size = reader.read32u();
                reader.read32s();
                reader.read32s();
                break
               }
             var old_pos=reader.i,size=[0],v=ops.deserialize(reader,size);
             if(expected_size != undefined)
              if(expected_size != size[0])
               caml_failwith
                ("input_value: incorrect length of serialized custom block");
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            default:caml_failwith("input_value: ill-formed message")}}
      var res=intern_rec();
      while(stack.length > 0)
       {var size=stack.pop(),v=stack.pop(),d=v.length;
        if(d < size)stack.push(v,size);
        v[d] = intern_rec()}
      if(typeof ofs != "number")ofs[0] = reader.i;
      return res}
    function caml_string_of_bytes(s){return s}
    function caml_input_value_from_bytes(s,ofs)
     {var
       reader=
        new
         MlStringReader
         (caml_string_of_bytes(s),typeof ofs == "number"?ofs:ofs[0]);
      return caml_input_value_from_reader(reader,ofs)}
    function caml_input_value(chanid)
     {var chan=caml_ml_channels[chanid],header=new Uint8Array(20);
      function block(buffer,offset,n)
       {var r=0;
        while(r < n)
         {if(chan.buffer_curr >= chan.buffer_max)
           {chan.buffer_curr = 0;chan.buffer_max = 0;caml_refill(chan)}
          if(chan.buffer_curr >= chan.buffer_max)break;
          buffer[offset + r] = chan.buffer[chan.buffer_curr];
          chan.buffer_curr++;
          r++}
        return r}
      var r=block(header,0,20);
      if(r == 0)
       caml_raise_end_of_file();
      else
       if(r < 20)caml_failwith("input_value: truncated object");
      var
       len=caml_marshal_data_size(caml_bytes_of_array(header),0),
       buf=new Uint8Array(len + 20);
      buf.set(header,0);
      var r=block(buf,20,len);
      if(r < len)
       caml_failwith("input_value: truncated object " + r + "  " + len);
      var
       offset=[0],
       res=caml_input_value_from_bytes(caml_bytes_of_array(buf),offset);
      chan.offset = chan.offset + offset[0];
      return res}
    function caml_input_value_to_outside_heap(c){return caml_input_value(c)}
    function caml_atomic_cas(ref,o,n)
     {if(ref[1] === o){ref[1] = n;return 1}return 0}
    function caml_copysign_float(x,y)
     {if(y == 0)y = 1 / y;x = Math.abs(x);return y < 0?- x:x}
    function caml_gr_set_text_size(size)
     {var s=caml_gr_state_get();
      s.text_size = size;
      s.context.font = s.text_size + "px " + caml_jsstring_of_string(s.font);
      return 0}
    function caml_atomic_load(ref){return ref[1]}
    function caml_MD5Final(ctx)
     {var in_buf=ctx.len & 0x3f;
      ctx.b8[in_buf] = 0x80;
      in_buf++;
      if(in_buf > 56)
       {for(var j=in_buf;j < 64;j++)ctx.b8[j] = 0;
        caml_MD5Transform(ctx.w,ctx.b32);
        for(var j=0;j < 56;j++)ctx.b8[j] = 0}
      else
       for(var j=in_buf;j < 56;j++)ctx.b8[j] = 0;
      ctx.b32[14] = ctx.len << 3;
      ctx.b32[15] = ctx.len >> 29 & 0x1FFFFFFF;
      caml_MD5Transform(ctx.w,ctx.b32);
      var t=new Uint8Array(16);
      for(var i=0;i < 4;i++)
       for(var j=0;j < 4;j++)t[i * 4 + j] = ctx.w[i] >> 8 * j & 0xFF;
      return t}
    function caml_md5_bytes(s,ofs,len)
     {var ctx=caml_MD5Init(),a=caml_uint8_array_of_bytes(s);
      caml_MD5Update(ctx,a.subarray(ofs,ofs + len),len);
      return caml_string_of_array(caml_MD5Final(ctx))}
    function caml_ba_set_generic(ba,i,v)
     {ba.set(ba.offset(caml_js_from_array(i)),v);return 0}
    function caml_ml_condition_wait(t,mutext){return 0}
    function caml_bytes_lessequal(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c <= s2.c?1:0}
    function caml_string_lessequal(s1,s2){return caml_bytes_lessequal(s1,s2)}
    function caml_string_greaterequal(s1,s2)
     {return caml_string_lessequal(s2,s1)}
    function caml_nextafter_float(x,y)
     {if(isNaN(x) || isNaN(y))return NaN;
      if(x == y)return y;
      if(x == 0)return y < 0?- Math.pow(2,- 1074):Math.pow(2,- 1074);
      var bits=caml_int64_bits_of_float(x),one=caml_int64_of_int32(1);
      if(x < y == x > 0)
       bits = caml_int64_add(bits,one);
      else
       bits = caml_int64_sub(bits,one);
      return caml_int64_float_of_bits(bits)}
    function caml_gr_size_y(){var s=caml_gr_state_get();return s.height}
    function caml_pos_in(chanid)
     {var chan=caml_ml_channels[chanid];
      return chan.offset - (chan.buffer_max - chan.buffer_curr)}
    function caml_ml_pos_in(chanid){return caml_pos_in(chanid)}
    function caml_int64_and(x,y){return x.and(y)}
    function Base_int_math_int64_pow_stub(base,exponent)
     {var one=caml_int64_create_lo_hi(1,0),mul=[one,base,one,one],res=one;
      while(! caml_int64_is_zero(exponent))
       {mul[1] = caml_int64_mul(mul[1],mul[3]);
        mul[2] = caml_int64_mul(mul[1],mul[1]);
        mul[3] = caml_int64_mul(mul[2],mul[1]);
        res = caml_int64_mul(res,mul[caml_int64_lo32(exponent) & 3]);
        exponent = caml_int64_shift_right_unsigned(exponent,2)}
      return res}
    function caml_sys_const_word_size(){return 32}
    function caml_unix_unlink(name)
     {var root=resolve_fs_device(name);
      if(! root.device.unlink)
       caml_failwith("caml_unix_unlink: not implemented");
      return root.device.unlink(root.rest,true)}
    function caml_sys_open_for_node(fd,flags)
     {if(flags.name)
       try
        {var fs=require("fs"),fd2=fs.openSync(flags.name,"rs");
         return new MlNodeFd(fd2,flags)}
       catch(e){}
      return new MlNodeFd(fd,flags)}
    function MlFakeFd_out(fd,flags)
     {MlFakeFile.call(this,caml_create_bytes(0));
      this.log = function(s){return 0};
      if(fd == 1 && typeof console.log == "function")
       this.log = console.log;
      else
       if(fd == 2 && typeof console.error == "function")
        this.log = console.error;
       else
        if(typeof console.log == "function")this.log = console.log;
      this.flags = flags}
    MlFakeFd_out.prototype.length = function(){return 0};
    MlFakeFd_out.prototype.write
    =
    function(offset,buf,pos,len)
     {if(this.log)
       {if
         (len
          >
          0
          &&
          pos
          >=
          0
          &&
          pos
          +
          len
          <=
          buf.length
          &&
          buf[pos + len - 1]
          ==
          10)
         len--;
        var src=caml_create_bytes(len);
        caml_blit_bytes(caml_bytes_of_array(buf),pos,src,0,len);
        this.log(src.toUtf16());
        return 0}
      caml_raise_sys_error(this.fd + ": file descriptor already closed")};
    MlFakeFd_out.prototype.read
    =
    function(offset,buf,pos,len)
     {caml_raise_sys_error(this.fd + ": file descriptor is write only")};
    MlFakeFd_out.prototype.close = function(){this.log = undefined};
    function caml_sys_open_internal(file,idx)
     {if(idx == undefined)idx = caml_sys_fds.length;
      caml_sys_fds[idx] = file;
      return idx}
    function caml_sys_open(name,flags,_perms)
     {var f={};
      while(flags)
       {switch(flags[1])
         {case 0:f.rdonly = 1;break;
          case 1:f.wronly = 1;break;
          case 2:f.append = 1;break;
          case 3:f.create = 1;break;
          case 4:f.truncate = 1;break;
          case 5:f.excl = 1;break;
          case 6:f.binary = 1;break;
          case 7:f.text = 1;break;
          case 8:f.nonblock = 1;break
          }
        flags = flags[2]}
      if(f.rdonly && f.wronly)
       caml_raise_sys_error
        (caml_jsbytes_of_string(name)
         +
         " : flags Open_rdonly and Open_wronly are not compatible");
      if(f.text && f.binary)
       caml_raise_sys_error
        (caml_jsbytes_of_string(name)
         +
         " : flags Open_text and Open_binary are not compatible");
      var root=resolve_fs_device(name),file=root.device.open(root.rest,f);
      return caml_sys_open_internal(file,undefined)}
    (function()
       {function file(fd,flags)
         {return fs_node_supported()
                  ?caml_sys_open_for_node(fd,flags)
                  :new MlFakeFd_out(fd,flags)}
        caml_sys_open_internal
         (file(0,{rdonly:1,altname:"/dev/stdin",isCharacterDevice:true}),0);
        caml_sys_open_internal
         (file(1,{buffered:2,wronly:1,isCharacterDevice:true}),1);
        caml_sys_open_internal
         (file(2,{buffered:2,wronly:1,isCharacterDevice:true}),2)}
      ());
    function caml_string_get(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s))caml_string_bound_error();
      return caml_string_unsafe_get(s,i)}
    var
     re_match=
      function()
        {var
          re_word_letters=
           [0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0xFF,
            0x03,
            0xFE,
            0xFF,
            0xFF,
            0x87,
            0xFE,
            0xFF,
            0xFF,
            0x07,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0xFF,
            0xFF,
            0x7F,
            0xFF,
            0xFF,
            0xFF,
            0x7F,
            0xFF],
          opcodes=
           {CHAR:0,
            CHARNORM:1,
            STRING:2,
            STRINGNORM:3,
            CHARCLASS:4,
            BOL:5,
            EOL:6,
            WORDBOUNDARY:7,
            BEGGROUP:8,
            ENDGROUP:9,
            REFGROUP:10,
            ACCEPT:11,
            SIMPLEOPT:12,
            SIMPLESTAR:13,
            SIMPLEPLUS:14,
            GOTO:15,
            PUSHBACK:16,
            SETMARK:17,
            CHECKPROGRESS:18};
         function is_word_letter(c)
          {return re_word_letters[c >> 3] >> (c & 7) & 1}
         function in_bitset(s,i)
          {return caml_string_get(s,i >> 3) >> (i & 7) & 1}
         function re_match_impl(re,s,pos,partial)
          {var
            prog=caml_js_from_array(re[1]),
            cpool=caml_js_from_array(re[2]),
            normtable=caml_jsbytes_of_string(re[3]),
            numgroups=re[4] | 0,
            numregisters=re[5] | 0,
            startchars=re[6] | 0,
            s=caml_uint8_array_of_string(s),
            pc=0,
            quit=false,
            stack=[],
            groups=new Array(numgroups),
            re_register=new Array(numregisters);
           for(var i=0;i < groups.length;i++)groups[i] = {start:- 1,end:- 1};
           groups[0].start = pos;
           function backtrack()
            {while(stack.length)
              {var item=stack.pop();
               if(item.undo)
                item.undo.obj[item.undo.prop] = item.undo.value;
               else
                if(item.pos){pc = item.pos.pc;pos = item.pos.txt;return}}
             quit = true}
           function push(item){stack.push(item)}
           function accept()
            {groups[0].end = pos;
             var result=new Array(1 + groups.length * 2);
             result[0] = 0;
             for(var i=0;i < groups.length;i++)
              {var g=groups[i];
               if(g.start < 0 || g.end < 0)g.start = g.end = - 1;
               result[2 * i + 1] = g.start;
               result[2 * i + 1 + 1] = g.end}
             return result}
           function prefix_match()
            {if(partial)return accept();else backtrack()}
           while(! quit)
            {var
              op=prog[pc] & 0xff,
              sarg=prog[pc] >> 8,
              uarg=sarg & 0xff,
              c=s[pos],
              group;
             pc++;
             switch(op)
              {case opcodes.CHAR:
                if(pos === s.length){prefix_match();break}
                if(c === uarg)pos++;else backtrack();
                break;
               case opcodes.CHARNORM:
                if(pos === s.length){prefix_match();break}
                if(normtable.charCodeAt(c) === uarg)pos++;else backtrack();
                break;
               case opcodes.STRING:
                for
                 (var arg=caml_jsbytes_of_string(cpool[uarg]),i=0;
                  i
                  <
                  arg.length;
                  i++)
                 {if(pos === s.length){prefix_match();break}
                  if(c === arg.charCodeAt(i))
                   c = s[++pos];
                  else
                   {backtrack();break}}
                break;
               case opcodes.STRINGNORM:
                for
                 (var arg=caml_jsbytes_of_string(cpool[uarg]),i=0;
                  i
                  <
                  arg.length;
                  i++)
                 {if(pos === s.length){prefix_match();break}
                  if(normtable.charCodeAt(c) === arg.charCodeAt(i))
                   c = s[++pos];
                  else
                   {backtrack();break}}
                break;
               case opcodes.CHARCLASS:
                if(pos === s.length){prefix_match();break}
                if(in_bitset(cpool[uarg],c))pos++;else backtrack();
                break;
               case opcodes.BOL:
                if(pos > 0 && s[pos - 1] != 10)backtrack();break;
               case opcodes.EOL:
                if(pos < s.length && s[pos] != 10)backtrack();break;
               case opcodes.WORDBOUNDARY:
                if(pos == 0)
                 {if(pos === s.length){prefix_match();break}
                  if(is_word_letter(s[0]))break;
                  backtrack()}
                else
                 if(pos === s.length)
                  {if(is_word_letter(s[pos - 1]))break;backtrack()}
                 else
                  {if(is_word_letter(s[pos - 1]) != is_word_letter(s[pos]))
                    break;
                   backtrack()}
                break;
               case opcodes.BEGGROUP:
                group = groups[uarg];
                push({undo:{obj:group,prop:"start",value:group.start}});
                group.start = pos;
                break;
               case opcodes.ENDGROUP:
                group = groups[uarg];
                push({undo:{obj:group,prop:"end",value:group.end}});
                group.end = pos;
                break;
               case opcodes.REFGROUP:
                group = groups[uarg];
                if(group.start < 0 || group.end < 0){backtrack();break}
                for(var i=group.start;i < group.end;i++)
                 {if(pos === s.length){prefix_match();break}
                  if(s[i] != s[pos]){backtrack();break}
                  pos++}
                break;
               case opcodes.SIMPLEOPT:if(in_bitset(cpool[uarg],c))pos++;break;
               case opcodes.SIMPLESTAR:
                while(in_bitset(cpool[uarg],c))c = s[++pos];break;
               case opcodes.SIMPLEPLUS:
                if(pos === s.length){prefix_match();break}
                if(in_bitset(cpool[uarg],c))
                 do c = s[++pos];while(in_bitset(cpool[uarg],c));
                else
                 backtrack();
                break;
               case opcodes.ACCEPT:return accept();
               case opcodes.GOTO:pc = pc + sarg;break;
               case opcodes.PUSHBACK:push({pos:{pc:pc + sarg,txt:pos}});break;
               case opcodes.SETMARK:
                push
                 ({undo:{obj:re_register,prop:uarg,value:re_register[uarg]}});
                re_register[uarg] = pos;
                break;
               case opcodes.CHECKPROGRESS:
                if(re_register[uarg] === pos)backtrack();break;
               default:throw new Error("Invalid bytecode")}}
           return 0}
         return re_match_impl}
       ();
    function re_search_backward(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.search_backward");
      while(pos >= 0){var res=re_match(re,s,pos,0);if(res)return res;pos--}
      return [0]}
    function caml_js_from_string(s){return caml_jsstring_of_string(s)}
    function caml_ba_sub(ba,ofs,len)
     {var changed_dim,mul=1;
      if(ba.layout == 0)
       {for(var i=1;i < ba.dims.length;i++)mul = mul * ba.dims[i];
        changed_dim = 0}
      else
       {for(var i=0;i < ba.dims.length - 1;i++)mul = mul * ba.dims[i];
        changed_dim = ba.dims.length - 1;
        ofs = ofs - 1}
      if(ofs < 0 || len < 0 || ofs + len > ba.dims[changed_dim])
       caml_invalid_argument("Bigarray.sub: bad sub-array");
      var new_dims=[];
      for(var i=0;i < ba.dims.length;i++)new_dims[i] = ba.dims[i];
      new_dims[changed_dim] = len;
      mul *= caml_ba_get_size_per_element(ba.kind);
      var new_data=ba.data.subarray(ofs * mul,(ofs + len) * mul);
      return caml_ba_create_unsafe(ba.kind,ba.layout,new_dims,new_data)}
    function caml_gc_full_major(unit)
     {if(typeof globalThis.gc == "function")globalThis.gc();return 0}
    function caml_ml_mutex_try_lock(t)
     {if(! t.locked){t.locked = true;return 1}return 0}
    function caml_bytes_set32(s,i,i32)
     {if(i >>> 0 >= s.l - 3)caml_bytes_bound_error();
      var
       b4=0xFF & i32 >> 24,
       b3=0xFF & i32 >> 16,
       b2=0xFF & i32 >> 8,
       b1=0xFF & i32;
      caml_bytes_unsafe_set(s,i + 0,b1);
      caml_bytes_unsafe_set(s,i + 1,b2);
      caml_bytes_unsafe_set(s,i + 2,b3);
      caml_bytes_unsafe_set(s,i + 3,b4);
      return 0}
    function caml_gr_sigio_signal(){return 0}
    function caml_ba_uint8_set32(ba,i0,v)
     {var ofs=ba.offset(i0);
      if(ofs + 3 >= ba.data.length)caml_array_bound_error();
      ba.set(ofs + 0,v & 0xff);
      ba.set(ofs + 1,v >>> 8 & 0xff);
      ba.set(ofs + 2,v >>> 16 & 0xff);
      ba.set(ofs + 3,v >>> 24 & 0xff);
      return 0}
    function caml_sys_const_ostype_unix(){return os_type == "Unix"?1:0}
    function caml_unix_gmtime(t)
     {var
       d=new Date(t * 1000),
       d_num=d.getTime(),
       januaryfirst=new Date(Date.UTC(d.getUTCFullYear(),0,1)).getTime(),
       doy=Math.floor((d_num - januaryfirst) / 86400000);
      return [0,
              d.getUTCSeconds(),
              d.getUTCMinutes(),
              d.getUTCHours(),
              d.getUTCDate(),
              d.getUTCMonth(),
              d.getUTCFullYear() - 1900,
              d.getUTCDay(),
              doy,
              false | 0]}
    function caml_signbit_float(x){if(x == 0)x = 1 / x;return x < 0?1:0}
    function caml_gr_set_line_width(w)
     {var s=caml_gr_state_get();
      s.line_width = w;
      s.context.lineWidth = w;
      return 0}
    function caml_gr_set_font(f)
     {var s=caml_gr_state_get();
      s.font = f;
      s.context.font = s.text_size + "px " + caml_jsstring_of_string(s.font);
      return 0}
    function caml_gr_set_color(color)
     {var s=caml_gr_state_get();
      function convert(number)
       {var str="" + number.toString(16);
        while(str.length < 2)str = "0" + str;
        return str}
      var r=color >> 16 & 0xff,g=color >> 8 & 0xff,b=color >> 0 & 0xff;
      s.color = color;
      var c_str="#" + convert(r) + convert(g) + convert(b);
      s.context.fillStyle = c_str;
      s.context.strokeStyle = c_str;
      return 0}
    function caml_gr_moveto(x,y)
     {var s=caml_gr_state_get();s.x = x;s.y = y;return 0}
    function caml_gr_resize_window(w,h)
     {var s=caml_gr_state_get();
      s.width = w;
      s.height = h;
      s.canvas.width = w;
      s.canvas.height = h;
      return 0}
    function caml_gr_state_init()
     {caml_gr_moveto(caml_gr_state.x,caml_gr_state.y);
      caml_gr_resize_window(caml_gr_state.width,caml_gr_state.height);
      caml_gr_set_line_width(caml_gr_state.line_width);
      caml_gr_set_text_size(caml_gr_state.text_size);
      caml_gr_set_font(caml_gr_state.font);
      caml_gr_set_color(caml_gr_state.color);
      caml_gr_set_window_title(caml_gr_state.title);
      caml_gr_state.context.textBaseline = "bottom"}
    function caml_gr_current_x(){var s=caml_gr_state_get();return s.x}
    function caml_ba_kind_of_typed_array(ta)
     {var kind;
      if(ta instanceof Float32Array)
       kind = 0;
      else
       if(ta instanceof Float64Array)
        kind = 1;
       else
        if(ta instanceof Int8Array)
         kind = 2;
        else
         if(ta instanceof Uint8Array)
          kind = 3;
         else
          if(ta instanceof Int16Array)
           kind = 4;
          else
           if(ta instanceof Uint16Array)
            kind = 5;
           else
            if(ta instanceof Int32Array)
             kind = 6;
            else
             if(ta instanceof Uint32Array)
              kind = 6;
             else
              caml_invalid_argument
               ("caml_ba_kind_of_typed_array: unsupported kind");
      return kind}
    function caml_ba_from_typed_array(ta)
     {var kind=caml_ba_kind_of_typed_array(ta);
      return caml_ba_create_unsafe(kind,0,[ta.length],ta)}
    function caml_ml_seek_out(chanid,pos){return caml_seek_out(chanid,pos)}
    function caml_js_typeof(o){return typeof o}
    function caml_string_hash(h,v)
     {var h=caml_hash_mix_string(h,v),h=caml_hash_mix_final(h);
      return h & 0x3FFFFFFF}
    function caml_restore_raw_backtrace(exn,bt){return 0}
    function Base_int_math_int32_ctz(x)
     {if(x === 0)return 32;
      var n=1;
      if((x & 0x0000FFFF) === 0){n = n + 16;x = x >> 16}
      if((x & 0x000000FF) === 0){n = n + 8;x = x >> 8}
      if((x & 0x0000000F) === 0){n = n + 4;x = x >> 4}
      if((x & 0x00000003) === 0){n = n + 2;x = x >> 2}
      return n - (x & 1)}
    function Base_int_math_nativeint_ctz(x){return Base_int_math_int32_ctz(x)}
    function caml_gr_lineto(x,y)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      s.context.moveTo(s.x,s.height - s.y);
      s.context.lineTo(x,s.height - y);
      s.context.stroke();
      s.x = x;
      s.y = y;
      return 0}
    function caml_js_function_arity(f){return f.length}
    function caml_js_wrap_meth_callback_unsafe(f)
     {return function()
       {var len=caml_js_function_arity(f) - 1,args=new Array(len + 1);
        args[0] = this;
        for(var i=0;i < len;i++)args[i + 1] = arguments[i];
        return caml_callback(f,args)}}
    function caml_ba_dim_3(ba){return caml_ba_dim(ba,2)}
    function caml_is_special_exception(exn)
     {switch(exn[2]){case - 8:case - 11:case - 12:return 1;default:return 0}}
    function caml_format_exception(exn)
     {var r="";
      if(exn[0] == 0)
       {r += exn[1][1];
        if
         (exn.length
          ==
          3
          &&
          exn[2][0]
          ==
          0
          &&
          caml_is_special_exception(exn[1]))
         var bucket=exn[2],start=1;
        else
         var start=2,bucket=exn;
        r += "(";
        for(var i=start;i < bucket.length;i++)
         {if(i > start)r += ", ";
          var v=bucket[i];
          if(typeof v == "number")
           r += v.toString();
          else
           if(v instanceof MlBytes)
            r += '"' + v.toString() + '"';
           else
            if(typeof v == "string")
             r += '"' + v.toString() + '"';
            else
             r += "_"}
        r += ")"}
      else
       if(exn[0] == 248)r += exn[1];
      return r}
    function caml_fatal_uncaught_exception(err)
     {if(err instanceof Array && (err[0] == 0 || err[0] == 248))
       {var handler=caml_named_value("Printexc.handle_uncaught_exception");
        if(handler)
         caml_callback(handler,[err,false]);
        else
         {var
           msg=caml_format_exception(err),
           at_exit=caml_named_value("Pervasives.do_at_exit");
          if(at_exit)caml_callback(at_exit,[0]);
          console.error("Fatal error: exception " + msg + "\n")}}
      else
       throw err}
    function caml_ephe_check_data(x)
     {return x[caml_ephe_data_offset] === undefined?0:1}
    function caml_bytes_get16(s,i)
     {if(i >>> 0 >= s.l - 1)caml_bytes_bound_error();
      var b1=caml_bytes_unsafe_get(s,i),b2=caml_bytes_unsafe_get(s,i + 1);
      return b2 << 8 | b1}
    function caml_obj_make_forward(b,v){b[0] = 250;b[1] = v;return 0}
    function caml_js_from_bool(x){return ! ! x}
    function caml_ml_set_channel_name(chanid,name)
     {var chan=caml_ml_channels[chanid];chan.name = name;return 0}
    function caml_exp2_float(x){return Math.pow(2,x)}
    function caml_gr_close_graph()
     {var s=caml_gr_state_get();
      s.canvas.width = 0;
      s.canvas.height = 0;
      return 0}
    var Base_internalhash_fold_int=caml_hash_mix_int;
    function caml_ml_domain_cpu_relax(unit){return 0}
    function caml_create_string(len)
     {if(len < 0)caml_invalid_argument("String.create");
      return new MlBytes(len?2:9,"",len)}
    function Base_int_math_nativeint_clz(x){return Base_int_math_int32_clz(x)}
    function caml_ml_input_block(chanid,ba,i,l)
     {var
       chan=caml_ml_channels[chanid],
       n=l,
       avail=chan.buffer_max - chan.buffer_curr;
      if(l <= avail)
       {ba.set(chan.buffer.subarray(chan.buffer_curr,chan.buffer_curr + l),i);
        chan.buffer_curr += l}
      else
       if(avail > 0)
        {ba.set
          (chan.buffer.subarray(chan.buffer_curr,chan.buffer_curr + avail),i);
         chan.buffer_curr += avail;
         n = avail}
       else
        {chan.buffer_curr = 0;
         chan.buffer_max = 0;
         caml_refill(chan);
         var avail=chan.buffer_max - chan.buffer_curr;
         if(n > avail)n = avail;
         ba.set(chan.buffer.subarray(chan.buffer_curr,chan.buffer_curr + n),i);
         chan.buffer_curr += n}
      return n}
    function caml_md5_chan(chanid,toread)
     {var ctx=caml_MD5Init(),buffer=new Uint8Array(4096);
      if(toread < 0)
       while(true)
        {var read=caml_ml_input_block(chanid,buffer,0,buffer.length);
         if(read == 0)break;
         caml_MD5Update(ctx,buffer.subarray(0,read),read)}
      else
       while(toread > 0)
        {var
          read=
           caml_ml_input_block
            (chanid,buffer,0,toread > buffer.length?buffer.length:toread);
         if(read == 0)caml_raise_end_of_file();
         caml_MD5Update(ctx,buffer.subarray(0,read),read);
         toread -= read}
      return caml_string_of_array(caml_MD5Final(ctx))}
    function caml_atanh_float(x){return Math.atanh(x)}
    function caml_ml_condition_signal(t){return 0}
    function caml_unix_findnext(dir_handle)
     {return caml_unix_readdir(dir_handle)}
    function caml_ml_output_bytes(chanid,buffer,offset,len)
     {var chan=caml_ml_channels[chanid];
      if(! chan.opened)
       caml_raise_sys_error("Cannot output to a closed channel");
      var buffer=caml_uint8_array_of_bytes(buffer);
      buffer = buffer.subarray(offset,offset + len);
      if(chan.buffer_curr + buffer.length > chan.buffer.length)
       {var b=new Uint8Array(chan.buffer_curr + buffer.length);
        b.set(chan.buffer);
        chan.buffer = b}
      switch(chan.buffered)
       {case 0:
         chan.buffer.set(buffer,chan.buffer_curr);
         chan.buffer_curr += buffer.length;
         caml_ml_flush(chanid);
         break;
        case 1:
         chan.buffer.set(buffer,chan.buffer_curr);
         chan.buffer_curr += buffer.length;
         if(chan.buffer_curr >= chan.buffer.length)caml_ml_flush(chanid);
         break;
        case 2:
         var id=buffer.lastIndexOf(10);
         if(id < 0)
          {chan.buffer.set(buffer,chan.buffer_curr);
           chan.buffer_curr += buffer.length;
           if(chan.buffer_curr >= chan.buffer.length)caml_ml_flush(chanid)}
         else
          {chan.buffer.set(buffer.subarray(0,id + 1),chan.buffer_curr);
           chan.buffer_curr += id + 1;
           caml_ml_flush(chanid);
           chan.buffer.set(buffer.subarray(id + 1),chan.buffer_curr);
           chan.buffer_curr += buffer.length - id - 1}
         break
        }
      return 0}
    function caml_ml_output(chanid,buffer,offset,len)
     {return caml_ml_output_bytes
              (chanid,caml_bytes_of_string(buffer),offset,len)}
    function caml_ml_domain_id(unit){return caml_domain_id}
    function caml_ephe_get_data(x)
     {return x[caml_ephe_data_offset] === undefined
              ?0
              :[0,x[caml_ephe_data_offset]]}
    function caml_xmlhttprequest_create(unit)
     {if(typeof globalThis.XMLHttpRequest !== "undefined")
       try {return new (globalThis.XMLHttpRequest)()}catch(e){}
      if(typeof globalThis.activeXObject !== "undefined")
       {try
         {return new (globalThis.activeXObject)("Msxml2.XMLHTTP")}
        catch(e){}
        try
         {return new (globalThis.activeXObject)("Msxml3.XMLHTTP")}
        catch(e){}
        try
         {return new (globalThis.activeXObject)("Microsoft.XMLHTTP")}
        catch(e){}}
      caml_failwith("Cannot create a XMLHttpRequest")}
    function caml_trampoline_return(f,args)
     {return {joo_tramp:f,joo_args:args}}
    function caml_ml_is_buffered(chanid)
     {return caml_ml_channels[chanid].buffered?1:0}
    function Base_int_math_int64_clz(x)
     {var n=64,y;
      y = caml_int64_shift_right_unsigned(x,32);
      if(! caml_int64_is_zero(y)){n = n - 32;x = y}
      y = caml_int64_shift_right_unsigned(x,16);
      if(! caml_int64_is_zero(y)){n = n - 16;x = y}
      y = caml_int64_shift_right_unsigned(x,8);
      if(! caml_int64_is_zero(y)){n = n - 8;x = y}
      y = caml_int64_shift_right_unsigned(x,4);
      if(! caml_int64_is_zero(y)){n = n - 4;x = y}
      y = caml_int64_shift_right_unsigned(x,2);
      if(! caml_int64_is_zero(y)){n = n - 2;x = y}
      y = caml_int64_shift_right_unsigned(x,1);
      if(! caml_int64_is_zero(y))return n - 2;
      return n - caml_int64_to_int32(x)}
    function caml_array_append(a1,a2)
     {var l1=a1.length,l2=a2.length,l=l1 + l2 - 1,a=new Array(l);
      a[0] = 0;
      var i=1,j=1;
      for(;i < l1;i++)a[i] = a1[i];
      for(;i < l;i++,j++)a[i] = a2[j];
      return a}
    function caml_unix_gettimeofday(){return new Date().getTime() / 1000}
    function caml_unix_time(){return Math.floor(caml_unix_gettimeofday())}
    function caml_ml_set_channel_refill(chanid,f)
     {caml_ml_channels[chanid].refill = f;return 0}
    function caml_fill_bytes(s,i,l,c)
     {if(l > 0)
       if(i == 0 && (l >= s.l || s.t == 2 && l >= s.c.length))
        if(c == 0)
         {s.c = "";s.t = 2}
        else
         {s.c = caml_str_repeat(l,String.fromCharCode(c));s.t = l == s.l?0:2}
       else
        {if(s.t != 4)caml_convert_bytes_to_array(s);
         for(l += i;i < l;i++)s.c[i] = c}
      return 0}
    function caml_js_expr(s)
     {console.error("caml_js_expr: fallback to runtime evaluation\n");
      return eval(caml_jsstring_of_string(s))}
    function caml_ml_runtime_warnings_enabled(_unit)
     {return caml_runtime_warnings}
    function caml_output_value_to_bytes(v,flags)
     {return caml_bytes_of_array(caml_output_val(v,flags))}
    function caml_eventlog_resume(unit){return 0}
    function caml_md5_string(s,ofs,len)
     {return caml_md5_bytes(caml_bytes_of_string(s),ofs,len)}
    function caml_string_equal(s1,s2){return caml_bytes_equal(s1,s2)}
    function caml_array_of_string(x){return caml_uint8_array_of_string(x)}
    function caml_jsoo_flags_use_js_string(unit){return 0}
    function caml_output_value_to_buffer(s,ofs,len,v,flags)
     {var t=caml_output_val(v,flags);
      if(t.length > len)caml_failwith("Marshal.to_buffer: buffer overflow");
      caml_blit_bytes(t,0,s,ofs,t.length);
      return 0}
    function re_replacement_text(repl,groups,orig)
     {var
       repl=caml_jsbytes_of_string(repl),
       len=repl.length,
       orig=caml_jsbytes_of_string(orig),
       res="",
       n=0,
       cur,
       start,
       end,
       c;
      while(n < len)
       {cur = repl.charAt(n++);
        if(cur != "\\")
         res += cur;
        else
         {if(n == len)
           caml_failwith("Str.replace: illegal backslash sequence");
          cur = repl.charAt(n++);
          switch(cur)
           {case "\\":res += cur;break;
            case "0":
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
             c = + cur;
             if(c * 2 >= groups.length - 1)
              caml_failwith("Str.replace: reference to unmatched group");
             start = caml_array_get(groups,c * 2);
             end = caml_array_get(groups,c * 2 + 1);
             if(start == - 1)
              caml_failwith("Str.replace: reference to unmatched group");
             res += orig.slice(start,end);
             break;
            default:res += "\\" + cur}}}
      return caml_string_of_jsbytes(res)}
    function caml_pure_js_expr(s)
     {console.error("caml_pure_js_expr: fallback to runtime evaluation\n");
      return eval(caml_jsstring_of_string(s))}
    function caml_blit_string(a,b,c,d,e)
     {caml_blit_bytes(caml_bytes_of_string(a),b,c,d,e);return 0}
    function blit_nat(nat1,ofs1,nat2,ofs2,len)
     {for(var i=0;i < len;i++)nat1.data[ofs1 + i] = nat2.data[ofs2 + i];
      return 0}
    function caml_bigstring_blit_ba_to_bytes(ba1,pos1,bytes2,pos2,len)
     {if(12 != ba1.kind)
       caml_invalid_argument
        ("caml_bigstring_blit_string_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs1=ba1.offset(pos1);
      if(ofs1 + len > ba1.data.length)caml_array_bound_error();
      if(pos2 + len > caml_ml_bytes_length(bytes2))caml_array_bound_error();
      var slice=ba1.data.slice(ofs1,ofs1 + len);
      caml_blit_bytes(caml_bytes_of_array(slice),0,bytes2,pos2,len);
      return 0}
    function caml_unix_stat(name)
     {var root=resolve_fs_device(name);
      if(! root.device.stat)caml_failwith("caml_unix_stat: not implemented");
      return root.device.stat(root.rest,true)}
    function caml_register_named_value(nm,v)
     {caml_named_values[caml_jsbytes_of_string(nm)] = v;return 0}
    function jsoo_create_file_extern(name,content)
     {if(globalThis.jsoo_create_file)
       globalThis.jsoo_create_file(name,content);
      else
       {if(! globalThis.caml_fs_tmp)globalThis.caml_fs_tmp = [];
        globalThis.caml_fs_tmp.push({name:name,content:content})}
      return 0}
    function caml_unix_stat_64(name)
     {var r=caml_unix_stat(name);r[9] = caml_int64_of_int32(r[9])}
    function caml_to_js_string(s){return caml_jsstring_of_string(s)}
    function caml_ml_mutex_lock(t)
     {if(t.locked)
       caml_failwith("Mutex.lock: mutex already locked. Cannot wait.");
      else
       t.locked = true;
      return 0}
    function re_search_forward(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.search_forward");
      while(pos <= caml_ml_string_length(s))
       {var res=re_match(re,s,pos,0);if(res)return res;pos++}
      return [0]}
    var caml_blit_string_to_bigstring=caml_bigstring_blit_string_to_ba;
    function caml_make_vect(len,init)
     {if(len < 0)caml_array_bound_error();
      var len=len + 1 | 0,b=new Array(len);
      b[0] = 0;
      for(var i=1;i < len;i++)b[i] = init;
      return b}
    function caml_ml_seek_in(chanid,pos){return caml_seek_in(chanid,pos)}
    function caml_sys_read_directory(name)
     {var
       root=resolve_fs_device(name),
       a=root.device.readdir(root.rest),
       l=new Array(a.length + 1);
      l[0] = 0;
      for(var i=0;i < a.length;i++)l[i + 1] = caml_string_of_jsbytes(a[i]);
      return l}
    function caml_ml_output_char(chanid,c)
     {var s=caml_string_of_jsbytes(String.fromCharCode(c));
      caml_ml_output(chanid,s,0,1);
      return 0}
    function caml_sys_const_ostype_win32(){return os_type == "Win32"?1:0}
    function caml_obj_is_block(x){return + (x instanceof Array)}
    function caml_obj_set_raw_field(o,i,v){return o[i + 1] = v}
    function caml_js_var(x)
     {var x=caml_jsstring_of_string(x);
      if(! x.match(/^[a-zA-Z_$][a-zA-Z_$0-9]*(\.[a-zA-Z_$][a-zA-Z_$0-9]*)*$/))
       console.error
        ('caml_js_var: "'
         +
         x
         +
         '" is not a valid JavaScript variable. continuing ..');
      return eval(x)}
    function caml_trunc_float(x){return Math.trunc(x)}
    function caml_ephe_unset_data(x)
     {if(globalThis.FinalizationRegistry && globalThis.WeakRef)
       if(x[1] instanceof globalThis.FinalizationRegistry)
        for(var j=caml_ephe_key_offset;j < x.length;j++)
         {var key=x[j];
          if(key instanceof globalThis.WeakRef)
           {key = key.deref();if(key)x[1].unregister(key)}}
      x[caml_ephe_data_offset] = undefined;
      return 0}
    function caml_ephe_set_data(x,data)
     {if(globalThis.FinalizationRegistry && globalThis.WeakRef)
       if(! (x[1] instanceof globalThis.FinalizationRegistry))
        {x[1]
         =
         new
          (globalThis.FinalizationRegistry)
          (function(){caml_ephe_unset_data(x)});
         for(var j=caml_ephe_key_offset;j < x.length;j++)
          {var key=x[j];
           if(key instanceof globalThis.WeakRef)
            {key = key.deref();if(key)x[1].register(key,undefined,key)}}}
      x[caml_ephe_data_offset] = data;
      return 0}
    function caml_ephe_blit_data(src,dst)
     {var n=src[caml_ephe_data_offset];
      if(n === undefined)
       caml_ephe_unset_data(dst);
      else
       caml_ephe_set_data(dst,n);
      return 0}
    var Base_internalhash_fold_int64=caml_hash_mix_int64;
    function caml_is_printable(c){return + (c > 31 && c < 127)}
    function caml_array_of_bytes(x){return caml_uint8_array_of_bytes(x)}
    function caml_equal(x,y){return + (caml_compare_val(x,y,false) == 0)}
    function re_partial_match(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.partial_match");
      var res=re_match(re,s,pos,1);
      return res?res:[0]}
    function caml_sys_random_seed()
     {if(globalThis.crypto)
       if(typeof globalThis.crypto.getRandomValues === "function")
        {var a=new Uint32Array(1);
         globalThis.crypto.getRandomValues(a);
         return [0,a[0]]}
       else
        if(globalThis.crypto.randomBytes === "function")
         {var buff=globalThis.crypto.randomBytes(4),a=new Uint32Array(buff);
          return [0,a[0]]}
      var now=new Date().getTime(),x=now ^ 0xffffffff * Math.random();
      return [0,x]}
    var all_finalizers=new (globalThis.Set)();
    function caml_final_register_called_without_value(cb,a)
     {if(globalThis.FinalizationRegistry && a instanceof Object)
       {var
         x=
          new
           (globalThis.FinalizationRegistry)
           (function(x){all_finalizers.delete(x);cb(0);return});
        x.register(a,x);
        all_finalizers.add(x)}
      return 0}
    function caml_ba_get_2(ba,i0,i1){return ba.get(ba.offset([i0,i1]))}
    function caml_ba_uint8_set16(ba,i0,v)
     {var ofs=ba.offset(i0);
      if(ofs + 1 >= ba.data.length)caml_array_bound_error();
      ba.set(ofs + 0,v & 0xff);
      ba.set(ofs + 1,v >>> 8 & 0xff);
      return 0}
    function caml_lazy_reset_to_lazy(o)
     {caml_obj_update_tag(o,244,246);return 0}
    function caml_js_delete(o,f){delete o[f];return 0}
    function caml_int_of_string(s)
     {var
       r=caml_parse_sign_and_base(s),
       i=r[0],
       sign=r[1],
       base=r[2],
       len=caml_ml_string_length(s),
       threshold=- 1 >>> 0,
       c=i < len?caml_string_unsafe_get(s,i):0,
       d=caml_parse_digit(c);
      if(d < 0 || d >= base)caml_failwith("int_of_string");
      var res=d;
      for(i++;i < len;i++)
       {c = caml_string_unsafe_get(s,i);
        if(c == 95)continue;
        d = caml_parse_digit(c);
        if(d < 0 || d >= base)break;
        res = base * res + d;
        if(res > threshold)caml_failwith("int_of_string")}
      if(i != len)caml_failwith("int_of_string");
      res = sign * res;
      if(base == 10 && (res | 0) != res)caml_failwith("int_of_string");
      return res | 0}
    function caml_list_mount_point()
     {var prev=0;
      for(var i=0;i < jsoo_mount_point.length;i++)
       {var old=prev;
        prev = [0,caml_string_of_jsbytes(jsoo_mount_point[i].path),old]}
      return prev}
    var
     caml_marshal_constants=
      {PREFIX_SMALL_BLOCK:0x80,
       PREFIX_SMALL_INT:0x40,
       PREFIX_SMALL_STRING:0x20,
       CODE_INT8:0x00,
       CODE_INT16:0x01,
       CODE_INT32:0x02,
       CODE_INT64:0x03,
       CODE_SHARED8:0x04,
       CODE_SHARED16:0x05,
       CODE_SHARED32:0x06,
       CODE_BLOCK32:0x08,
       CODE_BLOCK64:0x13,
       CODE_STRING8:0x09,
       CODE_STRING32:0x0A,
       CODE_DOUBLE_BIG:0x0B,
       CODE_DOUBLE_LITTLE:0x0C,
       CODE_DOUBLE_ARRAY8_BIG:0x0D,
       CODE_DOUBLE_ARRAY8_LITTLE:0x0E,
       CODE_DOUBLE_ARRAY32_BIG:0x0F,
       CODE_DOUBLE_ARRAY32_LITTLE:0x07,
       CODE_CODEPOINTER:0x10,
       CODE_INFIXPOINTER:0x11,
       CODE_CUSTOM:0x12,
       CODE_CUSTOM_LEN:0x18,
       CODE_CUSTOM_FIXED:0x19};
    function caml_obj_raw_field(o,i){return o[i + 1]}
    function caml_js_equals(x,y){return + (x == y)}
    function caml_obj_compare_and_swap(x,i,old,n)
     {if(x[i + 1] == old){x[i + 1] = n;return 1}return 0}
    function bigstring_to_typed_array(bs){return bs.data}
    function caml_gr_arc_aux(ctx,cx,cy,ry,rx,a1,a2)
     {while(a1 > a2)a2 += 360;
      a1 /= 180;
      a2 /= 180;
      var
       rot=0,
       xPos,
       yPos,
       xPos_prev,
       yPos_prev,
       space=2,
       num=(a2 - a1) * Math.PI * ((rx + ry) / 2) / space | 0,
       delta=(a2 - a1) * Math.PI / num,
       i=a1 * Math.PI;
      for(var j=0;j <= num;j++)
       {xPos
        =
        cx
        -
        rx
        *
        Math.sin(i)
        *
        Math.sin(rot * Math.PI)
        +
        ry
        *
        Math.cos(i)
        *
        Math.cos(rot * Math.PI);
        xPos = xPos.toFixed(2);
        yPos
        =
        cy
        +
        ry
        *
        Math.cos(i)
        *
        Math.sin(rot * Math.PI)
        +
        rx
        *
        Math.sin(i)
        *
        Math.cos(rot * Math.PI);
        yPos = yPos.toFixed(2);
        if(j == 0)
         ctx.moveTo(xPos,yPos);
        else
         if(xPos_prev != xPos || yPos_prev != yPos)ctx.lineTo(xPos,yPos);
        xPos_prev = xPos;
        yPos_prev = yPos;
        i -= delta}
      return 0}
    function caml_gr_fill_arc(x,y,rx,ry,a1,a2)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      caml_gr_arc_aux(s.context,x,s.height - y,rx,ry,a1,a2);
      s.context.fill();
      return 0}
    function caml_ba_slice(ba,vind)
     {vind = caml_js_from_array(vind);
      var num_inds=vind.length,index=[],sub_dims=[],ofs;
      if(num_inds > ba.dims.length)
       caml_invalid_argument("Bigarray.slice: too many indices");
      if(ba.layout == 0)
       {for(var i=0;i < num_inds;i++)index[i] = vind[i];
        for(;i < ba.dims.length;i++)index[i] = 0;
        sub_dims = ba.dims.slice(num_inds)}
      else
       {for(var i=0;i < num_inds;i++)
         index[ba.dims.length - num_inds + i] = vind[i];
        for(var i=0;i < ba.dims.length - num_inds;i++)index[i] = 1;
        sub_dims = ba.dims.slice(0,ba.dims.length - num_inds)}
      ofs = ba.offset(index);
      var
       size=caml_ba_get_size(sub_dims),
       size_per_element=caml_ba_get_size_per_element(ba.kind),
       new_data=
        ba.data.subarray
         (ofs * size_per_element,(ofs + size) * size_per_element);
      return caml_ba_create_unsafe(ba.kind,ba.layout,sub_dims,new_data)}
    function caml_js_wrap_callback_unsafe(f)
     {return function()
       {var len=caml_js_function_arity(f),args=new Array(len);
        for(var i=0;i < len;i++)args[i] = arguments[i];
        return caml_callback(f,args)}}
    function caml_ba_kind(ba){return ba.kind}
    function caml_js_fun_call(f,a)
     {switch(a.length)
       {case 1:return f();
        case 2:return f(a[1]);
        case 3:return f(a[1],a[2]);
        case 4:return f(a[1],a[2],a[3]);
        case 5:return f(a[1],a[2],a[3],a[4]);
        case 6:return f(a[1],a[2],a[3],a[4],a[5]);
        case 7:return f(a[1],a[2],a[3],a[4],a[5],a[6]);
        case 8:return f(a[1],a[2],a[3],a[4],a[5],a[6],a[7])
        }
      return f.apply(null,caml_js_from_array(a))}
    function caml_gc_major_slice(work){return 0}
    function caml_js_pure_expr(f){return caml_callback(f,[0])}
    function compare_digits_nat(nat1,ofs1,nat2,ofs2)
     {if(nat1.data[ofs1] > nat2.data[ofs2])return 1;
      if(nat1.data[ofs1] < nat2.data[ofs2])return - 1;
      return 0}
    function caml_ml_input(chanid,b,i,l)
     {var ba=caml_uint8_array_of_bytes(b);
      return caml_ml_input_block(chanid,ba,i,l)}
    function caml_gr_wait_event(_evl)
     {caml_failwith
       ("caml_gr_wait_event not Implemented: use Graphics_js instead")}
    function caml_gr_sigio_handler(){return 0}
    function caml_hash_mix_bigstring(h,bs)
     {return caml_hash_mix_bytes_arr(h,bs.data)}
    function caml_record_backtrace(){return 0}
    function caml_unix_cleanup(){}
    function caml_sys_const_backend_type()
     {return [0,caml_string_of_jsbytes("js_of_ocaml")]}
    function caml_sys_get_config()
     {return [0,caml_string_of_jsbytes(os_type),32,0]}
    function caml_obj_is_shared(x){return 1}
    function caml_ml_out_channels_list()
     {var l=0;
      for(var c=0;c < caml_ml_channels.length;c++)
       if
        (caml_ml_channels[c]
         &&
         caml_ml_channels[c].opened
         &&
         caml_ml_channels[c].out)
        l = [0,caml_ml_channels[c].fd,l];
      return l}
    function caml_asinh_float(x){return Math.asinh(x)}
    function caml_pos_out(chanid)
     {var chan=caml_ml_channels[chanid];return chan.offset + chan.buffer_curr}
    function bigstring_of_array_buffer(ab)
     {var ta=new Uint8Array(ab);
      return caml_ba_create_unsafe(12,0,[ta.length],ta)}
    function caml_mod(x,y){if(y == 0)caml_raise_zero_divide();return x % y}
    function caml_ba_init(){return 0}
    function caml_unix_filedescr_of_fd(x){return x}
    function re_string_match(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.string_match");
      var res=re_match(re,s,pos,0);
      return res?res:[0]}
    function BigStringReader(bs,i){this.s = bs;this.i = i}
    BigStringReader.prototype
    =
    {read8u:function(){return caml_ba_get_1(this.s,this.i++)},
     read8s:function(){return caml_ba_get_1(this.s,this.i++) << 24 >> 24},
     read16u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return caml_ba_get_1(s,i) << 8 | caml_ba_get_1(s,i + 1)},
     read16s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return caml_ba_get_1(s,i) << 24 >> 16 | caml_ba_get_1(s,i + 1)},
     read32u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return (caml_ba_get_1(s,i)
               <<
               24
               |
               caml_ba_get_1(s,i + 1)
               <<
               16
               |
               caml_ba_get_1(s,i + 2)
               <<
               8
               |
               caml_ba_get_1(s,i + 3))
              >>>
              0},
     read32s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return caml_ba_get_1(s,i)
              <<
              24
              |
              caml_ba_get_1(s,i + 1)
              <<
              16
              |
              caml_ba_get_1(s,i + 2)
              <<
              8
              |
              caml_ba_get_1(s,i + 3)},
     readstr:
     function(len)
      {var i=this.i,arr=new Array(len);
       for(var j=0;j < len;j++)arr[j] = caml_ba_get_1(this.s,i + j);
       this.i = i + len;
       return caml_string_of_array(arr)}};
    function caml_gr_dump_image(im)
     {var data=[0];
      for(var i=0;i < im.height;i++)
       {data[i + 1] = [0];
        for(var j=0;j < im.width;j++)
         {var
           o=i * (im.width * 4) + j * 4,
           r=im.data[o + 0],
           g=im.data[o + 1],
           b=im.data[o + 2];
          data[i + 1][j + 1] = (r << 16) + (g << 8) + b}}
      return data}
    function caml_ba_get_generic(ba,i)
     {var ofs=ba.offset(caml_js_from_array(i));return ba.get(ofs)}
    function caml_unix_startup(){}
    function caml_get_exception_backtrace(){return 0}
    function caml_format_float(fmt,x)
     {function toFixed(x,dp)
       {if(Math.abs(x) < 1.0)
         return x.toFixed(dp);
        else
         {var e=parseInt(x.toString().split("+")[1]);
          if(e > 20)
           {e -= 20;
            x /= Math.pow(10,e);
            x += new Array(e + 1).join("0");
            if(dp > 0)x = x + "." + new Array(dp + 1).join("0");
            return x}
          else
           return x.toFixed(dp)}}
      var s,f=caml_parse_format(fmt),prec=f.prec < 0?6:f.prec;
      if(x < 0 || x == 0 && 1 / x == - Infinity){f.sign = - 1;x = - x}
      if(isNaN(x))
       {s = "nan";f.filler = " "}
      else
       if(! isFinite(x))
        {s = "inf";f.filler = " "}
       else
        switch(f.conv)
         {case "e":
           var s=x.toExponential(prec),i=s.length;
           if(s.charAt(i - 3) == "e")
            s = s.slice(0,i - 1) + "0" + s.slice(i - 1);
           break;
          case "f":s = toFixed(x,prec);break;
          case "g":
           prec = prec?prec:1;
           s = x.toExponential(prec - 1);
           var j=s.indexOf("e"),exp=+ s.slice(j + 1);
           if(exp < - 4 || x >= 1e21 || x.toFixed(0).length > prec)
            {var i=j - 1;
             while(s.charAt(i) == "0")i--;
             if(s.charAt(i) == ".")i--;
             s = s.slice(0,i + 1) + s.slice(j);
             i = s.length;
             if(s.charAt(i - 3) == "e")
              s = s.slice(0,i - 1) + "0" + s.slice(i - 1);
             break}
           else
            {var p=prec;
             if(exp < 0)
              {p -= exp + 1;s = x.toFixed(p)}
             else
              while(s = x.toFixed(p),s.length > prec + 1)p--;
             if(p)
              {var i=s.length - 1;
               while(s.charAt(i) == "0")i--;
               if(s.charAt(i) == ".")i--;
               s = s.slice(0,i + 1)}}
           break
          }
      return caml_finish_formatting(f,s)}
    function caml_mount_autoload(name,f)
     {var path=caml_make_path(name),name=caml_trailing_slash(path.join("/"));
      jsoo_mount_point.push({path:name,device:new MlFakeDevice(name,f)});
      return 0}
    function Base_int_math_int_clz(x){return Base_int_math_int32_clz(x)}
    function caml_bigstring_blit_ba_to_ba(ba1,pos1,ba2,pos2,len)
     {if(12 != ba1.kind)
       caml_invalid_argument("caml_bigstring_blit_ba_to_ba: kind mismatch");
      if(12 != ba2.kind)
       caml_invalid_argument("caml_bigstring_blit_ba_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs1=ba1.offset(pos1),ofs2=ba2.offset(pos2);
      if(ofs1 + len > ba1.data.length)caml_array_bound_error();
      if(ofs2 + len > ba2.data.length)caml_array_bound_error();
      var slice=ba1.data.subarray(ofs1,ofs1 + len);
      ba2.data.set(slice,pos2);
      return 0}
    var caml_blit_bigstring_to_bigstring=caml_bigstring_blit_ba_to_ba;
    function caml_string_lessthan(s1,s2){return caml_bytes_lessthan(s1,s2)}
    function caml_string_greaterthan(s1,s2)
     {return caml_string_lessthan(s2,s1)}
    function caml_div(x,y)
     {if(y == 0)caml_raise_zero_divide();return x / y | 0}
    function caml_obj_dup(x)
     {var l=x.length,a=new Array(l);
      for(var i=0;i < l;i++)a[i] = x[i];
      return a}
    function caml_ephe_get_data_copy(x)
     {return x[caml_ephe_data_offset] === undefined
              ?0
              :[0,caml_obj_dup(x[caml_ephe_data_offset])]}
    function caml_memprof_start(rate,stack_size,tracker){return 0}
    function caml_sys_get_argv(a){return [0,caml_argv[1],caml_argv]}
    function caml_ml_domain_set_name(_name){return 0}
    function caml_js_to_bool(x){return + x}
    function caml_gr_create_image(x,y)
     {var s=caml_gr_state_get();return s.context.createImageData(x,y)}
    function caml_ephe_get_key_copy(x,i)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.get_copy");
      var y=caml_ephe_get_key(x,i);
      if(y === 0)return y;
      var z=y[1];
      if(z instanceof Array)return [0,caml_obj_dup(z)];
      return y}
    function caml_lessthan(x,y){return + (caml_compare_val(x,y,false) < 0)}
    function caml_raw_backtrace_next_slot(){return 0}
    function caml_register_global(n,v,name_opt)
     {if(name_opt && globalThis.toplevelReloc)
       n = caml_callback(globalThis.toplevelReloc,[name_opt]);
      caml_global_data[n + 1] = v;
      if(name_opt)caml_global_data[name_opt] = v}
    function mult_nat(nat1,ofs1,len1,nat2,ofs2,len2,nat3,ofs3,len3)
     {var carry=0;
      for(var i=0;i < len3;i++)
       carry
       +=
       mult_digit_nat(nat1,ofs1 + i,len1 - i,nat2,ofs2,len2,nat3,ofs3 + i);
      return carry}
    function square_nat(nat1,ofs1,len1,nat2,ofs2,len2)
     {var carry=0;
      carry += add_nat(nat1,ofs1,len1,nat1,ofs1,len1,0);
      carry += mult_nat(nat1,ofs1,len1,nat2,ofs2,len2,nat2,ofs2,len2);
      return carry}
    function caml_js_from_float(x){return x}
    function caml_floatarray_create(len)
     {if(len < 0)caml_array_bound_error();
      var len=len + 1 | 0,b=new Array(len);
      b[0] = 254;
      for(var i=1;i < len;i++)b[i] = 0;
      return b}
    function caml_gc_stat(){return [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}
    function caml_get_major_credit(n){return 0}
    function caml_sys_modify_argv(arg){caml_argv = arg;return 0}
    var caml_method_cache=[];
    function caml_get_public_method(obj,tag,cacheid)
     {var meths=obj[1],ofs=caml_method_cache[cacheid];
      if(ofs === undefined)
       for(var i=caml_method_cache.length;i < cacheid;i++)
        caml_method_cache[i] = 0;
      else
       if(meths[ofs] === tag)return meths[ofs - 1];
      var li=3,hi=meths[1] * 2 + 1,mi;
      while(li < hi)
       {mi = li + hi >> 1 | 1;if(tag < meths[mi + 1])hi = mi - 2;else li = mi}
      caml_method_cache[cacheid] = li + 1;
      return tag == meths[li + 1]?meths[li]:0}
    function caml_js_get_console()
     {var
       c=console,
       m=
        ["log",
         "debug",
         "info",
         "warn",
         "error",
         "assert",
         "dir",
         "dirxml",
         "trace",
         "group",
         "groupCollapsed",
         "groupEnd",
         "time",
         "timeEnd"];
      function f(){}
      for(var i=0;i < m.length;i++)if(! c[m[i]])c[m[i]] = f;
      return c}
    function caml_sys_unsafe_getenv(name){return caml_sys_getenv(name)}
    function caml_ml_open_descriptor_in(fd)
     {var file=caml_sys_fds[fd];
      if(file.flags.wronly)caml_raise_sys_error("fd " + fd + " is writeonly");
      var
       refill=null,
       channel=
        {file:file,
         offset:file.flags.append?file.length():0,
         fd:fd,
         opened:true,
         out:false,
         buffer_curr:0,
         buffer_max:0,
         buffer:new Uint8Array(65536),
         refill:refill};
      caml_ml_channels[channel.fd] = channel;
      return channel.fd}
    function bigstring_of_typed_array(ba)
     {var
       ta=
        new
         Uint8Array
         (ba.buffer,ba.byteOffset,ba.length * ba.BYTES_PER_ELEMENT);
      return caml_ba_create_unsafe(12,0,[ta.length],ta)}
    function caml_round_float(x){return Math.round(x)}
    function caml_ojs_new_arr(c,a)
     {switch(a.length)
       {case 0:return new c();
        case 1:return new c(a[0]);
        case 2:return new c(a[0],a[1]);
        case 3:return new c(a[0],a[1],a[2]);
        case 4:return new c(a[0],a[1],a[2],a[3]);
        case 5:return new c(a[0],a[1],a[2],a[3],a[4]);
        case 6:return new c(a[0],a[1],a[2],a[3],a[4],a[5]);
        case 7:return new c(a[0],a[1],a[2],a[3],a[4],a[5],a[6])
        }
      function F(){return c.apply(this,a)}
      F.prototype = c.prototype;
      return new F()}
    function complement_nat(nat,ofs,len)
     {for(var i=0;i < len;i++)
       nat.data[ofs + i] = (- 1 >>> 0) - (nat.data[ofs + i] >>> 0)}
    var caml_domain_dls=[0];
    function caml_domain_dls_set(a){caml_domain_dls = a}
    function caml_lazy_read_result(o){return caml_obj_tag(o) == 250?o[1]:o}
    var caml_js_regexps={amp:/&/g,lt:/</g,quot:/\"/g,all:/[&<\"]/};
    function caml_js_html_escape(s)
     {if(! caml_js_regexps.all.test(s))return s;
      return s.replace(caml_js_regexps.amp,"&amp;").replace
               (caml_js_regexps.lt,"&lt;").replace
              (caml_js_regexps.quot,"&quot;")}
    function caml_ba_dim_2(ba){return caml_ba_dim(ba,1)}
    function caml_js_wrap_meth_callback_arguments(f)
     {return function()
       {var len=arguments.length,args=new Array(len);
        for(var i=0;i < len;i++)args[i] = arguments[i];
        return caml_callback(f,[this,args])}}
    function caml_sinh_float(x){return Math.sinh(x)}
    function caml_ldexp_float(x,exp)
     {exp |= 0;
      if(exp > 1023)
       {exp -= 1023;
        x *= Math.pow(2,1023);
        if(exp > 1023){exp -= 1023;x *= Math.pow(2,1023)}}
      if(exp < - 1023){exp += 1023;x *= Math.pow(2,- 1023)}
      x *= Math.pow(2,exp);
      return x}
    function caml_gr_state_set(ctx)
     {caml_gr_state = ctx;caml_gr_state_init();return 0}
    function caml_js_wrap_callback_strict(arity,f)
     {return function()
       {var
         n=arguments.length,
         args=new Array(arity),
         len=Math.min(arguments.length,arity);
        for(var i=0;i < len;i++)args[i] = arguments[i];
        return caml_callback(f,args)}}
    function caml_gc_minor_words(unit){return 0}
    function caml_get_current_callstack(){return [0]}
    function land_digit_nat(nat1,ofs1,nat2,ofs2)
     {nat1.data[ofs1] &= nat2.data[ofs2];return 0}
    function caml_int64_mod(x,y){return x.mod(y)}
    function caml_obj_set_tag(x,tag){x[0] = tag;return 0}
    function caml_int32_bswap(x)
     {return (x & 0x000000FF)
             <<
             24
             |
             (x & 0x0000FF00)
             <<
             8
             |
             (x & 0x00FF0000)
             >>>
             8
             |
             (x & 0xFF000000)
             >>>
             24}
    function caml_ba_set_3(ba,i0,i1,i2,v)
     {ba.set(ba.offset([i0,i1,i2]),v);return 0}
    function caml_js_instanceof(o,c){return o instanceof c?1:0}
    function caml_get_major_bucket(n){return 0}
    var caml_blit_bigstring_to_string=caml_bigstring_blit_ba_to_bytes;
    function set_digit_nat_native(nat,ofs,digit)
     {nat.data[ofs] = digit;return 0}
    function nth_digit_nat_native(nat,ofs){return nat.data[ofs]}
    function caml_string_set64(s,i,i64){return caml_bytes_set64(s,i,i64)}
    function caml_gr_state_create(canvas,w,h)
     {var context=canvas.getContext("2d");
      return {context:context,
              canvas:canvas,
              x:0,
              y:0,
              width:w,
              height:h,
              line_width:1,
              font:caml_string_of_jsbytes("fixed"),
              text_size:26,
              color:0x000000,
              title:caml_string_of_jsbytes("")}}
    function caml_gr_draw_arc(x,y,rx,ry,a1,a2)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      caml_gr_arc_aux(s.context,x,s.height - y,rx,ry,a1,a2);
      s.context.stroke();
      return 0}
    function caml_ba_map_file(vfd,kind,layout,shared,dims,pos)
     {caml_failwith("caml_ba_map_file not implemented")}
    function caml_ba_map_file_bytecode(argv,argn)
     {return caml_ba_map_file(argv[0],argv[1],argv[2],argv[3],argv[4],argv[5])}
    function caml_ba_create_from(data1,data2,jstyp,kind,layout,dims)
     {if(data2 || caml_ba_get_size_per_element(kind) == 2)
       caml_invalid_argument
        ("caml_ba_create_from: use return caml_ba_create_unsafe");
      return caml_ba_create_unsafe(kind,layout,dims,data1)}
    function caml_tanh_float(x){return Math.tanh(x)}
    function Base_int_math_int_ctz(x){return Base_int_math_int32_ctz(x)}
    function caml_gr_draw_str(str)
     {var s=caml_gr_state_get(),m=s.context.measureText(str),dx=m.width;
      s.context.fillText(str,s.x,s.height - s.y);
      s.x += dx | 0;
      return 0}
    function caml_gr_draw_string(str)
     {caml_gr_draw_str(caml_jsstring_of_string(str));return 0}
    function caml_gr_draw_char(c)
     {caml_gr_draw_str(String.fromCharCode(c));return 0}
    function caml_unmount(name)
     {var
       path=caml_make_path(name),
       name=caml_trailing_slash(path.join("/")),
       idx=- 1;
      for(var i=0;i < jsoo_mount_point.length;i++)
       if(jsoo_mount_point[i].path == name)idx = i;
      if(idx > - 1)jsoo_mount_point.splice(idx,1);
      return 0}
    function caml_input_value_from_string(s,ofs)
     {var reader=new MlStringReader(s,typeof ofs == "number"?ofs:ofs[0]);
      return caml_input_value_from_reader(reader,ofs)}
    function caml_ml_pos_in_64(chanid)
     {return caml_int64_of_float(caml_pos_in(chanid))}
    function caml_gr_draw_image(im,x,y)
     {var s=caml_gr_state_get();
      if(! im.image)
       {var canvas=document.createElement("canvas");
        canvas.width = s.width;
        canvas.height = s.height;
        canvas.getContext("2d").putImageData(im,0,0);
        var image=new (globalThis.Image)();
        image.onload
        =
        function()
         {s.context.drawImage(image,x,s.height - im.height - y);
          im.image = image};
        image.src = canvas.toDataURL("image/png")}
      else
       s.context.drawImage(im.image,x,s.height - im.height - y);
      return 0}
    function caml_register_channel_for_spacetime(_channel){return 0}
    function caml_string_set(s,i,c)
     {if(i >>> 0 >= s.l)caml_string_bound_error();
      return caml_string_unsafe_set(s,i,c)}
    function caml_sys_rmdir(name)
     {var root=resolve_fs_device(name);root.device.rmdir(root.rest);return 0}
    function caml_unix_symlink(to_dir,src,dst)
     {var src_root=resolve_fs_device(src),dst_root=resolve_fs_device(dst);
      if(src_root.device != dst_root.device)
       caml_failwith
        ("caml_unix_symlink: cannot symlink between two filesystems");
      if(! src_root.device.symlink)
       caml_failwith("caml_unix_symlink: not implemented");
      return src_root.device.symlink(to_dir,src_root.rest,dst_root.rest,true)}
    function Base_int_math_int64_ctz(x)
     {if(caml_int64_is_zero(x))return 64;
      var n=1;
      function is_zero(x){return caml_int64_is_zero(x)}
      function land(x,y){return caml_int64_and(x,y)}
      function small_int64(x){return caml_int64_create_lo_mi_hi(x,0,0)}
      if
       (is_zero(land(x,caml_int64_create_lo_mi_hi(0xFFFFFF,0x0000FF,0x0000))))
       {n = n + 32;x = caml_int64_shift_right_unsigned(x,32)}
      if(is_zero(land(x,small_int64(0x00FFFF))))
       {n = n + 16;x = caml_int64_shift_right_unsigned(x,16)}
      if(is_zero(land(x,small_int64(0x0000FF))))
       {n = n + 8;x = caml_int64_shift_right_unsigned(x,8)}
      if(is_zero(land(x,small_int64(0x00000F))))
       {n = n + 4;x = caml_int64_shift_right_unsigned(x,4)}
      if(is_zero(land(x,small_int64(0x000003))))
       {n = n + 2;x = caml_int64_shift_right_unsigned(x,2)}
      return n - caml_int64_to_int32(caml_int64_and(x,small_int64(0x000001)))}
    function caml_ml_pos_out(chanid){return caml_pos_out(chanid)}
    function Base_caml_exn_is_most_recent_exn(x){return 1}
    function caml_spacetime_enabled(_unit){return 0}
    function caml_bytes_notequal(s1,s2){return 1 - caml_bytes_equal(s1,s2)}
    function caml_runtime_parameters(_unit){return caml_string_of_jsbytes("")}
    function caml_js_object(a)
     {var o={};
      for(var i=1;i < a.length;i++)
       {var p=a[i];o[caml_jsstring_of_string(p[1])] = p[2]}
      return o}
    function caml_ba_create(kind,layout,dims_ml)
     {var
       dims=caml_js_from_array(dims_ml),
       data=caml_ba_create_buffer(kind,caml_ba_get_size(dims));
      return caml_ba_create_unsafe(kind,layout,dims,data)}
    function caml_gr_remember_mode()
     {caml_failwith("caml_gr_remember_mode not Implemented")}
    function Base_internalhash_get_hash_value(seed)
     {var h=caml_hash_mix_final(seed);return h & 0x3FFFFFFF}
    function caml_fma_float(x,y,z)
     {var
       SPLIT=Math.pow(2,27) + 1,
       MIN_VALUE=Math.pow(2,- 1022),
       EPSILON=Math.pow(2,- 52),
       C=416,
       A=Math.pow(2,+ C),
       B=Math.pow(2,- C);
      function multiply(a,b)
       {var
         at=SPLIT * a,
         ahi=at - (at - a),
         alo=a - ahi,
         bt=SPLIT * b,
         bhi=bt - (bt - b),
         blo=b - bhi,
         p=a * b,
         e=ahi * bhi - p + ahi * blo + alo * bhi + alo * blo;
        return {p:p,e:e}}
      function add(a,b)
       {var s=a + b,v=s - a,e=a - (s - v) + (b - v);return {s:s,e:e}}
      function adjust(x,y)
       {return x !== 0 && y !== 0 && SPLIT * x - (SPLIT * x - x) === x
                ?x * (1 + (x < 0?- 1:+ 1) * (y < 0?- 1:+ 1) * EPSILON)
                :x}
      if
       (x
        ===
        0
        ||
        x
        !==
        x
        ||
        x
        ===
        +
        (1 / 0)
        ||
        x
        ===
        -
        (1 / 0)
        ||
        y
        ===
        0
        ||
        y
        !==
        y
        ||
        y
        ===
        +
        (1 / 0)
        ||
        y
        ===
        -
        (1 / 0))
       return x * y + z;
      if(z === 0)return x * y;
      if(z !== z || z === + (1 / 0) || z === - (1 / 0))return z;
      var scale=1;
      while(Math.abs(x) > A){scale *= A;x *= B}
      while(Math.abs(y) > A){scale *= A;y *= B}
      if(scale === 1 / 0)return x * y * scale;
      while(Math.abs(x) < B){scale *= B;x *= A}
      while(Math.abs(y) < B){scale *= B;y *= A}
      if(scale === 0)return z;
      var xs=x,ys=y,zs=z / scale;
      if(Math.abs(zs) > Math.abs(xs * ys) * 4 / EPSILON)return z;
      if(Math.abs(zs) < Math.abs(xs * ys) * EPSILON / 4 * EPSILON / 4)
       zs = (z < 0?- 1:+ 1) * MIN_VALUE;
      var
       xy=multiply(xs,ys),
       s=add(xy.p,zs),
       u=add(xy.e,s.e),
       i=add(s.s,u.s),
       f=i.s + adjust(i.e,u.e);
      if(f === 0)return f;
      var fs=f * scale;
      if(Math.abs(fs) > MIN_VALUE)return fs;
      return fs + adjust(f - fs / scale,i.e) * scale}
    function caml_recommended_domain_count(unit){return 1}
    function caml_bswap16(x){return (x & 0x00FF) << 8 | (x & 0xFF00) >> 8}
    function caml_ml_set_binary_mode(chanid,mode)
     {var chan=caml_ml_channels[chanid];
      chan.file.flags.text = ! mode;
      chan.file.flags.binary = mode;
      return 0}
    function caml_final_register(){return 0}
    function caml_gr_draw_rect(x,y,w,h)
     {var s=caml_gr_state_get();
      s.context.strokeRect(x,s.height - y,w,- h);
      return 0}
    function caml_string_get16(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s) - 1)caml_string_bound_error();
      var b1=caml_string_unsafe_get(s,i),b2=caml_string_unsafe_get(s,i + 1);
      return b2 << 8 | b1}
    function caml_output_value(chanid,v,flags)
     {var s=caml_output_value_to_string(v,flags);
      caml_ml_output(chanid,s,0,caml_ml_string_length(s));
      return 0}
    function caml_ba_get_3(ba,i0,i1,i2){return ba.get(ba.offset([i0,i1,i2]))}
    function caml_ephe_blit_key(a1,i1,a2,i2,len)
     {caml_array_blit
       (a1,caml_ephe_key_offset + i1 - 1,a2,caml_ephe_key_offset + i2 - 1,len);
      return 0}
    var caml_initial_time=new Date().getTime() * 0.001;
    function caml_sys_time()
     {var now=new Date().getTime();return now * 0.001 - caml_initial_time}
    function caml_sys_time_include_children(b){return caml_sys_time()}
    function Base_clear_caml_backtrace_pos(x){return 0}
    function caml_check_bound(array,index)
     {if(index >>> 0 >= array.length - 1)caml_array_bound_error();
      return array}
    function caml_unix_getpwuid(unit){caml_raise_not_found()}
    function caml_ba_to_typed_array(ba){return ba.data}
    function caml_domain_dls_get(unit){return caml_domain_dls}
    function caml_bytes_get32(s,i)
     {if(i >>> 0 >= s.l - 3)caml_bytes_bound_error();
      var
       b1=caml_bytes_unsafe_get(s,i),
       b2=caml_bytes_unsafe_get(s,i + 1),
       b3=caml_bytes_unsafe_get(s,i + 2),
       b4=caml_bytes_unsafe_get(s,i + 3);
      return b4 << 24 | b3 << 16 | b2 << 8 | b1}
    function caml_frexp_float(x)
     {if(x == 0 || ! isFinite(x))return [0,x,0];
      var neg=x < 0;
      if(neg)x = - x;
      var exp=Math.max(- 1023,jsoo_floor_log2(x) + 1);
      x *= Math.pow(2,- exp);
      while(x < 0.5){x *= 2;exp--}
      while(x >= 1){x *= 0.5;exp++}
      if(neg)x = - x;
      return [0,x,exp]}
    function caml_string_get64(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s) - 7)caml_string_bound_error();
      var a=new Array(8);
      for(var j=0;j < 8;j++)a[7 - j] = caml_string_unsafe_get(s,i + j);
      return caml_int64_of_bytes(a)}
    function caml_js_error_option_of_exception(exn)
     {if(exn.js_error)return [0,exn.js_error];return 0}
    function caml_ml_pos_out_64(chanid)
     {return caml_int64_of_float(caml_pos_out(chanid))}
    function caml_unix_findclose(dir_handle)
     {return caml_unix_closedir(dir_handle)}
    function caml_gr_close_subwindow(a)
     {caml_failwith("caml_gr_close_subwindow not Implemented")}
    function caml_floatarray_blit(a1,i1,a2,i2,len)
     {if(i2 <= i1)
       for(var j=1;j <= len;j++)a2[i2 + j] = a1[i1 + j];
      else
       for(var j=len;j >= 1;j--)a2[i2 + j] = a1[i1 + j];
      return 0}
    function caml_get_minor_free(unit){return 0}
    function caml_set_static_env(k,v)
     {if(! globalThis.jsoo_static_env)globalThis.jsoo_static_env = {};
      globalThis.jsoo_static_env[k] = v;
      return 0}
    function caml_ba_change_layout(ba,layout)
     {if(ba.layout == layout)return ba;
      var new_dims=[];
      for(var i=0;i < ba.dims.length;i++)
       new_dims[i] = ba.dims[ba.dims.length - i - 1];
      return caml_ba_create_unsafe(ba.kind,layout,new_dims,ba.data)}
    function Base_hash_double(d){return caml_hash(1,1,0,d)}
    function caml_js_new(c,a)
     {switch(a.length)
       {case 1:return new c();
        case 2:return new c(a[1]);
        case 3:return new c(a[1],a[2]);
        case 4:return new c(a[1],a[2],a[3]);
        case 5:return new c(a[1],a[2],a[3],a[4]);
        case 6:return new c(a[1],a[2],a[3],a[4],a[5]);
        case 7:return new c(a[1],a[2],a[3],a[4],a[5],a[6]);
        case 8:return new c(a[1],a[2],a[3],a[4],a[5],a[6],a[7])
        }
      function F(){return c.apply(this,caml_js_from_array(a))}
      F.prototype = c.prototype;
      return new F()}
    function caml_gr_current_y(){var s=caml_gr_state_get();return s.y}
    function caml_format_int(fmt,i)
     {if(caml_jsbytes_of_string(fmt) == "%d")
       return caml_string_of_jsbytes("" + i);
      var f=caml_parse_format(fmt);
      if(i < 0)if(f.signedconv){f.sign = - 1;i = - i}else i >>>= 0;
      var s=i.toString(f.base);
      if(f.prec >= 0)
       {f.filler = " ";
        var n=f.prec - s.length;
        if(n > 0)s = caml_str_repeat(n,"0") + s}
      return caml_finish_formatting(f,s)}
    function jsoo_effect_not_supported()
     {caml_failwith("Effect handlers are not supported")}
    function caml_continuation_use_and_update_handler_noexc
     (cont,hval,hexn,heff)
     {var stack=caml_continuation_use_noexc(cont);
      stack[3] = [0,hval,hexn,heff];
      return stack}
    function caml_obj_truncate(x,s)
     {if(s <= 0 || s + 1 > x.length)caml_invalid_argument("Obj.truncate");
      if(x.length != s + 1)x.length = s + 1;
      return 0}
    function caml_js_to_string(s){return caml_string_of_jsstring(s)}
    function is_digit_odd(nat,ofs){if(nat.data[ofs] & 1)return 1;return 0}
    function caml_runtime_variant(_unit){return caml_string_of_jsbytes("")}
    function caml_ml_open_descriptor_out(fd)
     {var file=caml_sys_fds[fd];
      if(file.flags.rdonly)caml_raise_sys_error("fd " + fd + " is readonly");
      var
       buffered=file.flags.buffered !== undefined?file.flags.buffered:1,
       channel=
        {file:file,
         offset:file.flags.append?file.length():0,
         fd:fd,
         opened:true,
         out:true,
         buffer_curr:0,
         buffer:new Uint8Array(65536),
         buffered:buffered};
      caml_ml_channels[channel.fd] = channel;
      return channel.fd}
    function caml_array_concat(l)
     {var a=[0];
      while(l !== 0)
       {var b=l[1];for(var i=1;i < b.length;i++)a.push(b[i]);l = l[2]}
      return a}
    function caml_gr_open_graph(info)
     {var info=caml_jsstring_of_string(info);
      function get(name)
       {var res=info.match("(^|,) *" + name + " *= *([a-zA-Z0-9_]+) *(,|$)");
        if(res)return res[2]}
      var specs=[];
      if(! (info == ""))specs.push(info);
      var target=get("target");
      if(! target)target = "";
      var status=get("status");
      if(! status)specs.push("status=1");
      var w=get("width");
      w = w?parseInt(w):200;
      specs.push("width=" + w);
      var h=get("height");
      h = h?parseInt(h):200;
      specs.push("height=" + h);
      var win=globalThis.open("about:blank",target,specs.join(","));
      if(! win)caml_failwith("Graphics.open_graph: cannot open the window");
      var doc=win.document,canvas=doc.createElement("canvas");
      canvas.width = w;
      canvas.height = h;
      var ctx=caml_gr_state_create(canvas,w,h);
      ctx.set_title = function(title){doc.title = title};
      caml_gr_state_set(ctx);
      var body=doc.body;
      body.style.margin = "0px";
      body.appendChild(canvas);
      return 0}
    function caml_make_float_vect(len)
     {if(len < 0)caml_array_bound_error();
      var len=len + 1 | 0,b=new Array(len);
      b[0] = 254;
      for(var i=1;i < len;i++)b[i] = 0;
      return b}
    function caml_cbrt_float(x){return Math.cbrt(x)}
    function caml_memprof_stop(unit){return 0}
    function caml_eventlog_pause(unit){return 0}
    function caml_greaterequal(x,y)
     {return + (caml_compare_val(x,y,false) >= 0)}
    function caml_get_exception_raw_backtrace(){return [0]}
    function caml_log1p_float(x){return Math.log1p(x)}
    var ms_to_nano=caml_int64_of_int32(1000 * 1000);
    function time_now_nanoseconds_since_unix_epoch_or_zero()
     {var ms=Date.now(),ms_i63=caml_int64_of_float(ms * 2);
      return caml_int64_mul(ms_i63,ms_to_nano)}
    function caml_lazy_make_forward(v){return [250,v]}
    function lor_digit_nat(nat1,ofs1,nat2,ofs2)
     {nat1.data[ofs1] |= nat2.data[ofs2];return 0}
    function caml_gr_blit_image(im,x,y)
     {var
       s=caml_gr_state_get(),
       im2=
        s.context.getImageData(x,s.height - im.height - y,im.width,im.height);
      for(var i=0;i < im2.data.length;i += 4)
       {im.data[i] = im2.data[i];
        im.data[i + 1] = im2.data[i + 1];
        im.data[i + 2] = im2.data[i + 2];
        im.data[i + 3] = im2.data[i + 3]}
      return 0}
    function caml_gr_window_id(a)
     {caml_failwith("caml_gr_window_id not Implemented")}
    function caml_js_on_ie()
     {var ua=globalThis.navigator?globalThis.navigator.userAgent:"";
      return ua.indexOf("MSIE") != - 1 && ua.indexOf("Opera") != 0}
    function caml_int64_shift_right(x,s){return x.shift_right(s)}
    function caml_ba_layout(ba){return ba.layout}
    function caml_convert_raw_backtrace(){return [0]}
    function caml_array_set(array,index,newval)
     {if(index < 0 || index >= array.length - 1)caml_array_bound_error();
      array[index + 1] = newval;
      return 0}
    function caml_alloc_stack(hv,hx,hf){return 0}
    function caml_bytes_greaterequal(s1,s2)
     {return caml_bytes_lessequal(s2,s1)}
    function set_digit_nat(nat,ofs,digit){nat.data[ofs] = digit;return 0}
    function caml_gr_doc_of_state(state)
     {if(state.canvas.ownerDocument)return state.canvas.ownerDocument}
    function caml_ml_output_int(chanid,i)
     {var
       arr=[i >> 24 & 0xFF,i >> 16 & 0xFF,i >> 8 & 0xFF,i & 0xFF],
       s=caml_string_of_array(arr);
      caml_ml_output(chanid,s,0,4);
      return 0}
    function caml_obj_with_tag(tag,x)
     {var l=x.length,a=new Array(l);
      a[0] = tag;
      for(var i=1;i < l;i++)a[i] = x[i];
      return a}
    function caml_ml_channel_size(chanid)
     {var chan=caml_ml_channels[chanid];return chan.file.length()}
    function caml_raw_backtrace_slot()
     {caml_invalid_argument
       ("Printexc.get_raw_backtrace_slot: index out of bounds")}
    function caml_hexstring_of_float(x,prec,style)
     {if(! isFinite(x))
       {if(isNaN(x))return caml_string_of_jsstring("nan");
        return caml_string_of_jsstring(x > 0?"infinity":"-infinity")}
      var sign=x == 0 && 1 / x == - Infinity?1:x >= 0?0:1;
      if(sign)x = - x;
      var exp=0;
      if(x == 0)
       ;
      else
       if(x < 1)
        while(x < 1 && exp > - 1022){x *= 2;exp--}
       else
        while(x >= 2){x /= 2;exp++}
      var exp_sign=exp < 0?"":"+",sign_str="";
      if(sign)
       sign_str = "-";
      else
       switch(style)
        {case 43:sign_str = "+";break;
         case 32:sign_str = " ";break;
         default:break}
      if(prec >= 0 && prec < 13)
       {var cst=Math.pow(2,prec * 4);x = Math.round(x * cst) / cst}
      var x_str=x.toString(16);
      if(prec >= 0)
       {var idx=x_str.indexOf(".");
        if(idx < 0)
         x_str += "." + caml_str_repeat(prec,"0");
        else
         {var size=idx + 1 + prec;
          if(x_str.length < size)
           x_str += caml_str_repeat(size - x_str.length,"0");
          else
           x_str = x_str.substr(0,size)}}
      return caml_string_of_jsstring
              (sign_str + "0x" + x_str + "p" + exp_sign + exp.toString(10))}
    function caml_js_wrap_meth_callback_strict(arity,f)
     {return function()
       {var args=new Array(arity + 1),len=Math.min(arguments.length,arity);
        args[0] = this;
        for(var i=0;i < len;i++)args[i + 1] = arguments[i];
        return caml_callback(f,args)}}
    function caml_unix_readlink(name)
     {var root=resolve_fs_device(name);
      if(! root.device.readlink)
       caml_failwith("caml_unix_readlink: not implemented");
      return root.device.readlink(root.rest,true)}
    function caml_backtrace_status(){return 0}
    function caml_sys_argv(a){return caml_argv}
    function caml_install_signal_handler(){return 0}
    function caml_ba_fill(ba,v){ba.fill(v);return 0}
    function caml_modf_float(x)
     {if(isFinite(x))
       {var neg=1 / x < 0;
        x = Math.abs(x);
        var i=Math.floor(x),f=x - i;
        if(neg){i = - i;f = - f}
        return [0,f,i]}
      if(isNaN(x))return [0,NaN,NaN];
      return [0,1 / x,x]}
    function caml_gc_get(){return [0,0,0,0,0,0,0,0,0]}
    function caml_float_compare(x,y)
     {if(x === y)return 0;
      if(x < y)return - 1;
      if(x > y)return 1;
      if(x === x)return 1;
      if(y === y)return - 1;
      return 0}
    function caml_string_set32(s,i,i32){return caml_bytes_set32(s,i,i32)}
    function caml_parse_engine(tables,env,cmd,arg)
     {var
       ERRCODE=256,
       loop=6,
       testshift=7,
       shift=8,
       shift_recover=9,
       reduce=10,
       READ_TOKEN=0,
       RAISE_PARSE_ERROR=1,
       GROW_STACKS_1=2,
       GROW_STACKS_2=3,
       COMPUTE_SEMANTIC_ACTION=4,
       CALL_ERROR_FUNCTION=5,
       env_s_stack=1,
       env_v_stack=2,
       env_symb_start_stack=3,
       env_symb_end_stack=4,
       env_stacksize=5,
       env_stackbase=6,
       env_curr_char=7,
       env_lval=8,
       env_symb_start=9,
       env_symb_end=10,
       env_asp=11,
       env_rule_len=12,
       env_rule_number=13,
       env_sp=14,
       env_state=15,
       env_errflag=16,
       tbl_transl_const=2,
       tbl_transl_block=3,
       tbl_lhs=4,
       tbl_len=5,
       tbl_defred=6,
       tbl_dgoto=7,
       tbl_sindex=8,
       tbl_rindex=9,
       tbl_gindex=10,
       tbl_tablesize=11,
       tbl_table=12,
       tbl_check=13,
       tbl_names_const=15,
       tbl_names_block=16;
      function log(x)
       {var s=caml_string_of_jsbytes(x + "\n");
        caml_ml_output(2,s,0,caml_ml_string_length(s))}
      function token_name(names,number)
       {var str=caml_jsstring_of_string(names);
        if(str[0] == "\x00")return "<unknown token>";
        return str.split("\x00")[number]}
      function print_token(state,tok)
       {var token,kind;
        if(tok instanceof Array)
         {token = token_name(tables[tbl_names_block],tok[0]);
          if(typeof tok[1] == "number")
           kind = "" + tok[1];
          else
           if(typeof tok[1] == "string")
            kind = tok[1];
           else
            if(tok[1] instanceof MlBytes)
             kind = caml_jsbytes_of_string(tok[1]);
            else
             kind = "_";
          log("State " + state + ": read token " + token + "(" + kind + ")")}
        else
         {token = token_name(tables[tbl_names_const],tok);
          log("State " + state + ": read token " + token)}}
      if(! tables.dgoto)
       {tables.defred = caml_lex_array(tables[tbl_defred]);
        tables.sindex = caml_lex_array(tables[tbl_sindex]);
        tables.check = caml_lex_array(tables[tbl_check]);
        tables.rindex = caml_lex_array(tables[tbl_rindex]);
        tables.table = caml_lex_array(tables[tbl_table]);
        tables.len = caml_lex_array(tables[tbl_len]);
        tables.lhs = caml_lex_array(tables[tbl_lhs]);
        tables.gindex = caml_lex_array(tables[tbl_gindex]);
        tables.dgoto = caml_lex_array(tables[tbl_dgoto])}
      var
       res=0,
       n,
       n1,
       n2,
       state1,
       sp=env[env_sp],
       state=env[env_state],
       errflag=env[env_errflag];
      exit:
      for(;;)
       next:
       switch(cmd)
        {case 0:state = 0;errflag = 0;
         case 6:
          n = tables.defred[state];
          if(n != 0){cmd = reduce;break}
          if(env[env_curr_char] >= 0){cmd = testshift;break}
          res = READ_TOKEN;
          break exit;
         case 1:
          if(arg instanceof Array)
           {env[env_curr_char] = tables[tbl_transl_block][arg[0] + 1];
            env[env_lval] = arg[1]}
          else
           {env[env_curr_char] = tables[tbl_transl_const][arg + 1];
            env[env_lval] = 0}
          if(caml_parser_trace)print_token(state,arg);
         case 7:
          n1 = tables.sindex[state];
          n2 = n1 + env[env_curr_char];
          if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            env[env_curr_char])
           {cmd = shift;break}
          n1 = tables.rindex[state];
          n2 = n1 + env[env_curr_char];
          if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            env[env_curr_char])
           {n = tables.table[n2];cmd = reduce;break}
          if(errflag <= 0){res = CALL_ERROR_FUNCTION;break exit}
         case 5:
          if(errflag < 3)
           {errflag = 3;
            for(;;)
             {state1 = env[env_s_stack][sp + 1];
              n1 = tables.sindex[state1];
              n2 = n1 + ERRCODE;
              if
               (n1
                !=
                0
                &&
                n2
                >=
                0
                &&
                n2
                <=
                tables[tbl_tablesize]
                &&
                tables.check[n2]
                ==
                ERRCODE)
               {if(caml_parser_trace)log("Recovering in state " + state1);
                cmd = shift_recover;
                break next}
              else
               {if(caml_parser_trace)log("Discarding state " + state1);
                if(sp <= env[env_stackbase])
                 {if(caml_parser_trace)log("No more states to discard");
                  return RAISE_PARSE_ERROR}
                sp--}}}
          else
           {if(env[env_curr_char] == 0)return RAISE_PARSE_ERROR;
            if(caml_parser_trace)log("Discarding last token read");
            env[env_curr_char] = - 1;
            cmd = loop;
            break}
         case 8:env[env_curr_char] = - 1;if(errflag > 0)errflag--;
         case 9:
          if(caml_parser_trace)
           log("State " + state + ": shift to state " + tables.table[n2]);
          state = tables.table[n2];
          sp++;
          if(sp >= env[env_stacksize]){res = GROW_STACKS_1;break exit}
         case 2:
          env[env_s_stack][sp + 1] = state;
          env[env_v_stack][sp + 1] = env[env_lval];
          env[env_symb_start_stack][sp + 1] = env[env_symb_start];
          env[env_symb_end_stack][sp + 1] = env[env_symb_end];
          cmd = loop;
          break;
         case 10:
          if(caml_parser_trace)
           log("State " + state + ": reduce by rule " + n);
          var m=tables.len[n];
          env[env_asp] = sp;
          env[env_rule_number] = n;
          env[env_rule_len] = m;
          sp = sp - m + 1;
          m = tables.lhs[n];
          state1 = env[env_s_stack][sp];
          n1 = tables.gindex[m];
          n2 = n1 + state1;
          if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            state1)
           state = tables.table[n2];
          else
           state = tables.dgoto[m];
          if(sp >= env[env_stacksize]){res = GROW_STACKS_2;break exit}
         case 3:res = COMPUTE_SEMANTIC_ACTION;break exit;
         case 4:
          env[env_s_stack][sp + 1] = state;
          env[env_v_stack][sp + 1] = arg;
          var asp=env[env_asp];
          env[env_symb_end_stack][sp + 1] = env[env_symb_end_stack][asp + 1];
          if(sp > asp)
           env[env_symb_start_stack][sp + 1]
           =
           env[env_symb_end_stack][asp + 1];
          cmd = loop;
          break;
         default:return RAISE_PARSE_ERROR}
      env[env_sp] = sp;
      env[env_state] = state;
      env[env_errflag] = errflag;
      return res}
    function caml_jsoo_flags_effects(unit){return 0}
    function caml_update_dummy(x,y)
     {if(typeof y === "function"){x.fun = y;return 0}
      if(y.fun){x.fun = y.fun;return 0}
      var i=y.length;
      while(i--)x[i] = y[i];
      return 0}
    function caml_array_fill(array,ofs,len,v)
     {for(var i=0;i < len;i++)array[ofs + i + 1] = v;return 0}
    function caml_sys_mkdir(name,perm)
     {var root=resolve_fs_device(name);
      root.device.mkdir(root.rest,perm);
      return 0}
    function caml_string_notequal(s1,s2){return 1 - caml_string_equal(s1,s2)}
    function caml_bytes_greaterthan(s1,s2){return caml_bytes_lessthan(s2,s1)}
    function caml_gr_make_image(arr)
     {var
       s=caml_gr_state_get(),
       h=arr.length - 1,
       w=arr[1].length - 1,
       im=s.context.createImageData(w,h);
      for(var i=0;i < h;i++)
       for(var j=0;j < w;j++)
        {var c=arr[i + 1][j + 1],o=i * (w * 4) + j * 4;
         if(c == - 1)
          {im.data[o + 0] = 0;
           im.data[o + 1] = 0;
           im.data[o + 2] = 0;
           im.data[o + 3] = 0}
         else
          {im.data[o + 0] = c >> 16 & 0xff;
           im.data[o + 1] = c >> 8 & 0xff;
           im.data[o + 2] = c >> 0 & 0Xff;
           im.data[o + 3] = 0xff}}
      return im}
    function Base_int_math_int_popcount(v)
     {v = v - (v >>> 1 & 0x55555555);
      v = (v & 0x33333333) + (v >>> 2 & 0x33333333);
      return (v + (v >>> 4) & 0xF0F0F0F) * 0x1010101 >>> 24}
    function caml_ml_set_channel_output(chanid,f)
     {var chan=caml_ml_channels[chanid];
      chan.output = function(s){f(s)};
      return 0}
    function caml_read_file_content(name)
     {var
       name=typeof name == "string"?caml_string_of_jsbytes(name):name,
       root=resolve_fs_device(name);
      if(root.device.exists(root.rest))
       {var
         file=root.device.open(root.rest,{rdonly:1}),
         len=file.length(),
         buf=new Uint8Array(len);
        file.read(0,buf,0,len);
        return caml_string_of_array(buf)}
      caml_raise_no_such_file(caml_jsbytes_of_string(name))}
    function caml_js_to_float(x){return x}
    function caml_setup_uncaught_exception_handler()
     {var process=globalThis.process;
      if(process && process.on)
       process.on
        ("uncaughtException",
         function(err,origin)
          {caml_fatal_uncaught_exception(err);process.exit(2)});
      else
       if(globalThis.addEventListener)
        globalThis.addEventListener
         ("error",
          function(event)
           {if(event.error)caml_fatal_uncaught_exception(event.error)})}
    caml_setup_uncaught_exception_handler();
    globalThis.jsoo_runtime
    =
    {time_now_nanoseconds_since_unix_epoch_or_zero:
     time_now_nanoseconds_since_unix_epoch_or_zero,
     Base_int_math_int_popcount:Base_int_math_int_popcount,
     Base_clear_caml_backtrace_pos:Base_clear_caml_backtrace_pos,
     Base_caml_exn_is_most_recent_exn:Base_caml_exn_is_most_recent_exn,
     Base_int_math_int32_clz:Base_int_math_int32_clz,
     Base_int_math_int_clz:Base_int_math_int_clz,
     Base_int_math_nativeint_clz:Base_int_math_nativeint_clz,
     Base_int_math_int64_clz:Base_int_math_int64_clz,
     Base_int_math_int32_ctz:Base_int_math_int32_ctz,
     Base_int_math_int_ctz:Base_int_math_int_ctz,
     Base_int_math_nativeint_ctz:Base_int_math_nativeint_ctz,
     Base_int_math_int64_ctz:Base_int_math_int64_ctz,
     Base_int_math_int_pow_stub:Base_int_math_int_pow_stub,
     Base_int_math_int64_pow_stub:Base_int_math_int64_pow_stub,
     Base_hash_string:Base_hash_string,
     Base_hash_double:Base_hash_double,
     Base_am_testing:Base_am_testing,
     Base_internalhash_fold_int64:Base_internalhash_fold_int64,
     Base_internalhash_fold_int:Base_internalhash_fold_int,
     Base_internalhash_fold_float:Base_internalhash_fold_float,
     Base_internalhash_fold_string:Base_internalhash_fold_string,
     Base_internalhash_get_hash_value:Base_internalhash_get_hash_value,
     caml_alloc_stack:caml_alloc_stack,
     caml_continuation_use_noexc:caml_continuation_use_noexc,
     caml_continuation_use_and_update_handler_noexc:
     caml_continuation_use_and_update_handler_noexc,
     caml_get_continuation_callstack:caml_get_continuation_callstack,
     caml_ml_condition_new:caml_ml_condition_new,
     caml_ml_condition_wait:caml_ml_condition_wait,
     caml_ml_condition_broadcast:caml_ml_condition_broadcast,
     caml_ml_condition_signal:caml_ml_condition_signal,
     jsoo_effect_not_supported:jsoo_effect_not_supported,
     MlMutex:MlMutex,
     caml_ml_mutex_new:caml_ml_mutex_new,
     caml_ml_mutex_lock:caml_ml_mutex_lock,
     caml_ml_mutex_try_lock:caml_ml_mutex_try_lock,
     caml_ml_mutex_unlock:caml_ml_mutex_unlock,
     caml_lxm_next:caml_lxm_next,
     caml_domain_dls:caml_domain_dls,
     caml_domain_dls_set:caml_domain_dls_set,
     caml_domain_dls_get:caml_domain_dls_get,
     caml_atomic_load:caml_atomic_load,
     caml_atomic_cas:caml_atomic_cas,
     caml_atomic_fetch_add:caml_atomic_fetch_add,
     caml_atomic_exchange:caml_atomic_exchange,
     caml_ml_domain_unique_token:caml_ml_domain_unique_token,
     caml_ml_domain_set_name:caml_ml_domain_set_name,
     caml_recommended_domain_count:caml_recommended_domain_count,
     caml_domain_id:caml_domain_id,
     caml_domain_spawn:caml_domain_spawn,
     caml_ml_domain_id:caml_ml_domain_id,
     caml_ml_domain_cpu_relax:caml_ml_domain_cpu_relax,
     caml_ephe_key_offset:caml_ephe_key_offset,
     caml_ephe_data_offset:caml_ephe_data_offset,
     caml_ephe_set_key:caml_ephe_set_key,
     caml_ephe_unset_key:caml_ephe_unset_key,
     caml_ephe_create:caml_ephe_create,
     caml_weak_create:caml_weak_create,
     caml_weak_set:caml_weak_set,
     caml_ephe_get_key:caml_ephe_get_key,
     caml_ephe_get_key_copy:caml_ephe_get_key_copy,
     caml_ephe_check_key:caml_ephe_check_key,
     caml_ephe_blit_key:caml_ephe_blit_key,
     caml_ephe_blit_data:caml_ephe_blit_data,
     caml_ephe_get_data:caml_ephe_get_data,
     caml_ephe_get_data_copy:caml_ephe_get_data_copy,
     caml_ephe_set_data:caml_ephe_set_data,
     caml_ephe_unset_data:caml_ephe_unset_data,
     caml_ephe_check_data:caml_ephe_check_data,
     caml_unix_gettimeofday:caml_unix_gettimeofday,
     caml_unix_time:caml_unix_time,
     caml_unix_gmtime:caml_unix_gmtime,
     caml_unix_localtime:caml_unix_localtime,
     caml_unix_mktime:caml_unix_mktime,
     caml_unix_startup:caml_unix_startup,
     caml_unix_cleanup:caml_unix_cleanup,
     caml_unix_filedescr_of_fd:caml_unix_filedescr_of_fd,
     caml_unix_isatty:caml_unix_isatty,
     make_unix_err_args:make_unix_err_args,
     caml_unix_stat:caml_unix_stat,
     caml_unix_stat_64:caml_unix_stat_64,
     caml_unix_lstat:caml_unix_lstat,
     caml_unix_lstat_64:caml_unix_lstat_64,
     caml_unix_mkdir:caml_unix_mkdir,
     caml_unix_rmdir:caml_unix_rmdir,
     caml_unix_symlink:caml_unix_symlink,
     caml_unix_readlink:caml_unix_readlink,
     caml_unix_unlink:caml_unix_unlink,
     caml_unix_getuid:caml_unix_getuid,
     caml_unix_getpwuid:caml_unix_getpwuid,
     caml_unix_has_symlink:caml_unix_has_symlink,
     caml_unix_opendir:caml_unix_opendir,
     caml_unix_readdir:caml_unix_readdir,
     caml_unix_closedir:caml_unix_closedir,
     caml_unix_rewinddir:caml_unix_rewinddir,
     caml_unix_findfirst:caml_unix_findfirst,
     caml_unix_findnext:caml_unix_findnext,
     caml_unix_findclose:caml_unix_findclose,
     caml_unix_inet_addr_of_string:caml_unix_inet_addr_of_string,
     re_match:re_match,
     re_search_forward:re_search_forward,
     re_search_backward:re_search_backward,
     re_string_match:re_string_match,
     re_partial_match:re_partial_match,
     re_replacement_text:re_replacement_text,
     caml_str_initialize:caml_str_initialize,
     caml_raise_sys_error:caml_raise_sys_error,
     caml_sys_exit:caml_sys_exit,
     caml_is_special_exception:caml_is_special_exception,
     caml_format_exception:caml_format_exception,
     caml_fatal_uncaught_exception:caml_fatal_uncaught_exception,
     caml_set_static_env:caml_set_static_env,
     caml_sys_getenv:caml_sys_getenv,
     caml_sys_unsafe_getenv:caml_sys_unsafe_getenv,
     caml_argv:caml_argv,
     caml_executable_name:caml_executable_name,
     caml_sys_get_argv:caml_sys_get_argv,
     caml_sys_argv:caml_sys_argv,
     caml_sys_modify_argv:caml_sys_modify_argv,
     caml_sys_executable_name:caml_sys_executable_name,
     caml_sys_system_command:caml_sys_system_command,
     caml_sys_time:caml_sys_time,
     caml_sys_time_include_children:caml_sys_time_include_children,
     caml_sys_random_seed:caml_sys_random_seed,
     caml_sys_const_big_endian:caml_sys_const_big_endian,
     caml_sys_const_word_size:caml_sys_const_word_size,
     caml_sys_const_int_size:caml_sys_const_int_size,
     caml_sys_const_max_wosize:caml_sys_const_max_wosize,
     caml_sys_const_ostype_unix:caml_sys_const_ostype_unix,
     caml_sys_const_ostype_win32:caml_sys_const_ostype_win32,
     caml_sys_const_ostype_cygwin:caml_sys_const_ostype_cygwin,
     caml_sys_const_backend_type:caml_sys_const_backend_type,
     os_type:os_type,
     caml_sys_get_config:caml_sys_get_config,
     caml_sys_isatty:caml_sys_isatty,
     caml_runtime_variant:caml_runtime_variant,
     caml_runtime_parameters:caml_runtime_parameters,
     caml_install_signal_handler:caml_install_signal_handler,
     caml_runtime_warnings:caml_runtime_warnings,
     caml_ml_enable_runtime_warnings:caml_ml_enable_runtime_warnings,
     caml_ml_runtime_warnings_enabled:caml_ml_runtime_warnings_enabled,
     caml_spacetime_enabled:caml_spacetime_enabled,
     caml_sys_const_naked_pointers_checked:
     caml_sys_const_naked_pointers_checked,
     caml_register_channel_for_spacetime:caml_register_channel_for_spacetime,
     caml_spacetime_only_works_for_native_code:
     caml_spacetime_only_works_for_native_code,
     caml_call_gen:caml_call_gen,
     caml_named_values:caml_named_values,
     caml_register_named_value:caml_register_named_value,
     caml_named_value:caml_named_value,
     caml_global_data:caml_global_data,
     caml_register_global:caml_register_global,
     caml_get_global_data:caml_get_global_data,
     caml_is_printable:caml_is_printable,
     caml_maybe_print_stats:caml_maybe_print_stats,
     caml_parser_trace:caml_parser_trace,
     caml_parse_engine:caml_parse_engine,
     caml_set_parser_trace:caml_set_parser_trace,
     caml_update_dummy:caml_update_dummy,
     caml_obj_is_block:caml_obj_is_block,
     caml_obj_tag:caml_obj_tag,
     caml_obj_set_tag:caml_obj_set_tag,
     caml_obj_block:caml_obj_block,
     caml_obj_with_tag:caml_obj_with_tag,
     caml_obj_dup:caml_obj_dup,
     caml_obj_truncate:caml_obj_truncate,
     caml_obj_make_forward:caml_obj_make_forward,
     caml_obj_compare_and_swap:caml_obj_compare_and_swap,
     caml_obj_is_shared:caml_obj_is_shared,
     caml_lazy_make_forward:caml_lazy_make_forward,
     caml_get_public_method:caml_get_public_method,
     caml_oo_last_id:caml_oo_last_id,
     caml_set_oo_id:caml_set_oo_id,
     caml_fresh_oo_id:caml_fresh_oo_id,
     caml_obj_raw_field:caml_obj_raw_field,
     caml_obj_set_raw_field:caml_obj_set_raw_field,
     caml_obj_reachable_words:caml_obj_reachable_words,
     caml_obj_add_offset:caml_obj_add_offset,
     caml_obj_update_tag:caml_obj_update_tag,
     caml_lazy_update_to_forcing:caml_lazy_update_to_forcing,
     caml_lazy_update_to_forward:caml_lazy_update_to_forward,
     caml_lazy_reset_to_lazy:caml_lazy_reset_to_lazy,
     caml_lazy_read_result:caml_lazy_read_result,
     caml_is_continuation_tag:caml_is_continuation_tag,
     initialize_nat:initialize_nat,
     MlNat:MlNat,
     caml_hash_nat:caml_hash_nat,
     nat_of_array:nat_of_array,
     create_nat:create_nat,
     set_to_zero_nat:set_to_zero_nat,
     blit_nat:blit_nat,
     set_digit_nat:set_digit_nat,
     nth_digit_nat:nth_digit_nat,
     set_digit_nat_native:set_digit_nat_native,
     nth_digit_nat_native:nth_digit_nat_native,
     num_digits_nat:num_digits_nat,
     num_leading_zero_bits_in_digit:num_leading_zero_bits_in_digit,
     is_digit_int:is_digit_int,
     is_digit_zero:is_digit_zero,
     is_digit_odd:is_digit_odd,
     incr_nat:incr_nat,
     add_nat:add_nat,
     complement_nat:complement_nat,
     decr_nat:decr_nat,
     sub_nat:sub_nat,
     mult_digit_nat:mult_digit_nat,
     mult_nat:mult_nat,
     square_nat:square_nat,
     shift_left_nat:shift_left_nat,
     div_helper:div_helper,
     div_digit_nat:div_digit_nat,
     div_nat:div_nat,
     shift_right_nat:shift_right_nat,
     compare_digits_nat:compare_digits_nat,
     compare_nat:compare_nat,
     compare_nat_real:compare_nat_real,
     land_digit_nat:land_digit_nat,
     lor_digit_nat:lor_digit_nat,
     lxor_digit_nat:lxor_digit_nat,
     serialize_nat:serialize_nat,
     deserialize_nat:deserialize_nat,
     caml_str_repeat:caml_str_repeat,
     caml_subarray_to_jsbytes:caml_subarray_to_jsbytes,
     caml_utf8_of_utf16:caml_utf8_of_utf16,
     caml_utf16_of_utf8:caml_utf16_of_utf8,
     jsoo_is_ascii:jsoo_is_ascii,
     caml_bytes_unsafe_get:caml_bytes_unsafe_get,
     caml_bytes_unsafe_set:caml_bytes_unsafe_set,
     caml_string_bound_error:caml_string_bound_error,
     caml_bytes_bound_error:caml_bytes_bound_error,
     caml_string_get:caml_string_get,
     caml_string_get16:caml_string_get16,
     caml_bytes_get16:caml_bytes_get16,
     caml_string_get32:caml_string_get32,
     caml_bytes_get32:caml_bytes_get32,
     caml_string_get64:caml_string_get64,
     caml_bytes_get64:caml_bytes_get64,
     caml_bytes_get:caml_bytes_get,
     caml_string_set:caml_string_set,
     caml_bytes_set16:caml_bytes_set16,
     caml_string_set16:caml_string_set16,
     caml_bytes_set32:caml_bytes_set32,
     caml_string_set32:caml_string_set32,
     caml_bytes_set64:caml_bytes_set64,
     caml_string_set64:caml_string_set64,
     caml_bytes_set:caml_bytes_set,
     caml_bytes_of_utf16_jsstring:caml_bytes_of_utf16_jsstring,
     MlBytes:MlBytes,
     caml_convert_string_to_bytes:caml_convert_string_to_bytes,
     caml_convert_bytes_to_array:caml_convert_bytes_to_array,
     caml_uint8_array_of_bytes:caml_uint8_array_of_bytes,
     caml_uint8_array_of_string:caml_uint8_array_of_string,
     caml_create_string:caml_create_string,
     caml_create_bytes:caml_create_bytes,
     caml_string_of_array:caml_string_of_array,
     caml_bytes_of_array:caml_bytes_of_array,
     caml_bytes_compare:caml_bytes_compare,
     caml_bytes_equal:caml_bytes_equal,
     caml_string_notequal:caml_string_notequal,
     caml_bytes_notequal:caml_bytes_notequal,
     caml_bytes_lessequal:caml_bytes_lessequal,
     caml_bytes_lessthan:caml_bytes_lessthan,
     caml_string_greaterequal:caml_string_greaterequal,
     caml_bytes_greaterequal:caml_bytes_greaterequal,
     caml_string_greaterthan:caml_string_greaterthan,
     caml_bytes_greaterthan:caml_bytes_greaterthan,
     caml_fill_bytes:caml_fill_bytes,
     caml_blit_bytes:caml_blit_bytes,
     caml_blit_string:caml_blit_string,
     caml_ml_bytes_length:caml_ml_bytes_length,
     caml_bytes_of_jsbytes:caml_bytes_of_jsbytes,
     caml_string_unsafe_get:caml_string_unsafe_get,
     caml_string_unsafe_set:caml_string_unsafe_set,
     caml_ml_string_length:caml_ml_string_length,
     caml_string_compare:caml_string_compare,
     caml_string_equal:caml_string_equal,
     caml_string_lessequal:caml_string_lessequal,
     caml_string_lessthan:caml_string_lessthan,
     caml_string_of_bytes:caml_string_of_bytes,
     caml_bytes_of_string:caml_bytes_of_string,
     caml_string_of_jsbytes:caml_string_of_jsbytes,
     caml_jsbytes_of_string:caml_jsbytes_of_string,
     caml_jsstring_of_string:caml_jsstring_of_string,
     caml_string_of_jsstring:caml_string_of_jsstring,
     caml_is_ml_bytes:caml_is_ml_bytes,
     caml_ml_bytes_content:caml_ml_bytes_content,
     caml_is_ml_string:caml_is_ml_string,
     caml_js_to_byte_string:caml_js_to_byte_string,
     caml_new_string:caml_new_string,
     caml_js_from_string:caml_js_from_string,
     caml_to_js_string:caml_to_js_string,
     caml_js_to_string:caml_js_to_string,
     caml_array_of_string:caml_array_of_string,
     caml_array_of_bytes:caml_array_of_bytes,
     caml_md5_chan:caml_md5_chan,
     caml_md5_string:caml_md5_string,
     caml_MD5Transform:caml_MD5Transform,
     caml_MD5Init:caml_MD5Init,
     caml_MD5Update:caml_MD5Update,
     caml_MD5Final:caml_MD5Final,
     caml_md5_bytes:caml_md5_bytes,
     caml_marshal_constants:caml_marshal_constants,
     MlStringReader:MlStringReader,
     BigStringReader:BigStringReader,
     caml_float_of_bytes:caml_float_of_bytes,
     caml_input_value_from_string:caml_input_value_from_string,
     caml_input_value_from_bytes:caml_input_value_from_bytes,
     caml_int64_unmarshal:caml_int64_unmarshal,
     caml_int64_marshal:caml_int64_marshal,
     caml_int32_unmarshal:caml_int32_unmarshal,
     caml_nativeint_unmarshal:caml_nativeint_unmarshal,
     caml_custom_ops:caml_custom_ops,
     caml_input_value_from_reader:caml_input_value_from_reader,
     caml_marshal_data_size:caml_marshal_data_size,
     MlObjectTable:MlObjectTable,
     caml_legacy_custom_code:caml_legacy_custom_code,
     caml_output_val:caml_output_val,
     caml_output_value_to_string:caml_output_value_to_string,
     caml_output_value_to_bytes:caml_output_value_to_bytes,
     caml_output_value_to_buffer:caml_output_value_to_buffer,
     caml_lex_array:caml_lex_array,
     caml_lex_engine:caml_lex_engine,
     caml_new_lex_engine:caml_new_lex_engine,
     caml_js_on_ie:caml_js_on_ie,
     caml_js_html_escape:caml_js_html_escape,
     caml_js_html_entities:caml_js_html_entities,
     caml_js_get_console:caml_js_get_console,
     caml_xmlhttprequest_create:caml_xmlhttprequest_create,
     caml_js_error_of_exception:caml_js_error_of_exception,
     caml_js_pure_expr:caml_js_pure_expr,
     caml_js_set:caml_js_set,
     caml_js_get:caml_js_get,
     caml_js_delete:caml_js_delete,
     caml_js_instanceof:caml_js_instanceof,
     caml_js_typeof:caml_js_typeof,
     caml_trampoline:caml_trampoline,
     caml_trampoline_return:caml_trampoline_return,
     caml_callback:caml_callback,
     caml_is_js:caml_is_js,
     caml_jsoo_flags_use_js_string:caml_jsoo_flags_use_js_string,
     caml_jsoo_flags_effects:caml_jsoo_flags_effects,
     caml_wrap_exception:caml_wrap_exception,
     caml_exn_with_js_backtrace:caml_exn_with_js_backtrace,
     caml_js_error_option_of_exception:caml_js_error_option_of_exception,
     caml_js_from_bool:caml_js_from_bool,
     caml_js_to_bool:caml_js_to_bool,
     caml_js_from_float:caml_js_from_float,
     caml_js_to_float:caml_js_to_float,
     caml_js_from_array:caml_js_from_array,
     caml_js_to_array:caml_js_to_array,
     caml_list_of_js_array:caml_list_of_js_array,
     caml_list_to_js_array:caml_list_to_js_array,
     caml_js_var:caml_js_var,
     caml_js_call:caml_js_call,
     caml_js_fun_call:caml_js_fun_call,
     caml_js_meth_call:caml_js_meth_call,
     caml_js_new:caml_js_new,
     caml_ojs_new_arr:caml_ojs_new_arr,
     caml_js_wrap_callback:caml_js_wrap_callback,
     caml_js_wrap_callback_arguments:caml_js_wrap_callback_arguments,
     caml_js_wrap_callback_strict:caml_js_wrap_callback_strict,
     caml_js_wrap_callback_unsafe:caml_js_wrap_callback_unsafe,
     caml_js_wrap_meth_callback:caml_js_wrap_meth_callback,
     caml_js_wrap_meth_callback_arguments:caml_js_wrap_meth_callback_arguments,
     caml_js_wrap_meth_callback_strict:caml_js_wrap_meth_callback_strict,
     caml_js_wrap_meth_callback_unsafe:caml_js_wrap_meth_callback_unsafe,
     caml_js_function_arity:caml_js_function_arity,
     caml_js_equals:caml_js_equals,
     caml_js_eval_string:caml_js_eval_string,
     caml_js_expr:caml_js_expr,
     caml_pure_js_expr:caml_pure_js_expr,
     caml_js_object:caml_js_object,
     caml_sys_fds:caml_sys_fds,
     caml_sys_close:caml_sys_close,
     caml_sys_open:caml_sys_open,
     caml_ml_set_channel_name:caml_ml_set_channel_name,
     caml_ml_channels:caml_ml_channels,
     caml_ml_out_channels_list:caml_ml_out_channels_list,
     caml_ml_open_descriptor_out:caml_ml_open_descriptor_out,
     caml_ml_open_descriptor_in:caml_ml_open_descriptor_in,
     caml_channel_descriptor:caml_channel_descriptor,
     caml_ml_set_binary_mode:caml_ml_set_binary_mode,
     caml_ml_close_channel:caml_ml_close_channel,
     caml_ml_channel_size:caml_ml_channel_size,
     caml_ml_channel_size_64:caml_ml_channel_size_64,
     caml_ml_set_channel_output:caml_ml_set_channel_output,
     caml_ml_set_channel_refill:caml_ml_set_channel_refill,
     caml_refill:caml_refill,
     caml_ml_input:caml_ml_input,
     caml_ml_input_block:caml_ml_input_block,
     caml_input_value:caml_input_value,
     caml_input_value_to_outside_heap:caml_input_value_to_outside_heap,
     caml_ml_input_char:caml_ml_input_char,
     caml_ml_input_int:caml_ml_input_int,
     caml_seek_in:caml_seek_in,
     caml_ml_seek_in:caml_ml_seek_in,
     caml_ml_seek_in_64:caml_ml_seek_in_64,
     caml_pos_in:caml_pos_in,
     caml_ml_pos_in:caml_ml_pos_in,
     caml_ml_pos_in_64:caml_ml_pos_in_64,
     caml_ml_input_scan_line:caml_ml_input_scan_line,
     caml_ml_flush:caml_ml_flush,
     caml_ml_output_bytes:caml_ml_output_bytes,
     caml_ml_output:caml_ml_output,
     caml_ml_output_char:caml_ml_output_char,
     caml_output_value:caml_output_value,
     caml_seek_out:caml_seek_out,
     caml_ml_seek_out:caml_ml_seek_out,
     caml_ml_seek_out_64:caml_ml_seek_out_64,
     caml_pos_out:caml_pos_out,
     caml_ml_pos_out:caml_ml_pos_out,
     caml_ml_pos_out_64:caml_ml_pos_out_64,
     caml_ml_output_int:caml_ml_output_int,
     caml_ml_is_buffered:caml_ml_is_buffered,
     caml_ml_set_buffered:caml_ml_set_buffered,
     caml_format_int:caml_format_int,
     caml_parse_sign_and_base:caml_parse_sign_and_base,
     caml_parse_digit:caml_parse_digit,
     caml_int_of_string:caml_int_of_string,
     caml_mul:caml_mul,
     caml_div:caml_div,
     caml_mod:caml_mod,
     caml_bswap16:caml_bswap16,
     caml_int32_bswap:caml_int32_bswap,
     caml_int64_bswap:caml_int64_bswap,
     caml_int64_offset:caml_int64_offset,
     MlInt64:MlInt64,
     caml_int64_ult:caml_int64_ult,
     caml_int64_compare:caml_int64_compare,
     caml_int64_neg:caml_int64_neg,
     caml_int64_add:caml_int64_add,
     caml_int64_sub:caml_int64_sub,
     caml_int64_mul:caml_int64_mul,
     caml_int64_is_zero:caml_int64_is_zero,
     caml_int64_is_negative:caml_int64_is_negative,
     caml_int64_and:caml_int64_and,
     caml_int64_or:caml_int64_or,
     caml_int64_xor:caml_int64_xor,
     caml_int64_shift_left:caml_int64_shift_left,
     caml_int64_shift_right_unsigned:caml_int64_shift_right_unsigned,
     caml_int64_shift_right:caml_int64_shift_right,
     caml_int64_div:caml_int64_div,
     caml_int64_mod:caml_int64_mod,
     caml_int64_of_int32:caml_int64_of_int32,
     caml_int64_to_int32:caml_int64_to_int32,
     caml_int64_to_float:caml_int64_to_float,
     caml_int64_of_float:caml_int64_of_float,
     caml_int64_format:caml_int64_format,
     caml_int64_of_string:caml_int64_of_string,
     caml_int64_create_lo_mi_hi:caml_int64_create_lo_mi_hi,
     caml_int64_create_lo_hi:caml_int64_create_lo_hi,
     caml_int64_lo32:caml_int64_lo32,
     caml_int64_hi32:caml_int64_hi32,
     caml_int64_of_bytes:caml_int64_of_bytes,
     caml_int64_to_bytes:caml_int64_to_bytes,
     caml_int64_hash:caml_int64_hash,
     jsoo_floor_log2:jsoo_floor_log2,
     caml_int64_bits_of_float:caml_int64_bits_of_float,
     caml_int32_bits_of_float:caml_int32_bits_of_float,
     caml_hexstring_of_float:caml_hexstring_of_float,
     caml_int64_float_of_bits:caml_int64_float_of_bits,
     caml_nextafter_float:caml_nextafter_float,
     caml_trunc_float:caml_trunc_float,
     caml_int32_float_of_bits:caml_int32_float_of_bits,
     caml_classify_float:caml_classify_float,
     caml_modf_float:caml_modf_float,
     caml_ldexp_float:caml_ldexp_float,
     caml_frexp_float:caml_frexp_float,
     caml_float_compare:caml_float_compare,
     caml_copysign_float:caml_copysign_float,
     caml_signbit_float:caml_signbit_float,
     caml_expm1_float:caml_expm1_float,
     caml_exp2_float:caml_exp2_float,
     caml_log1p_float:caml_log1p_float,
     caml_log2_float:caml_log2_float,
     caml_hypot_float:caml_hypot_float,
     caml_log10_float:caml_log10_float,
     caml_cosh_float:caml_cosh_float,
     caml_acosh_float:caml_acosh_float,
     caml_sinh_float:caml_sinh_float,
     caml_asinh_float:caml_asinh_float,
     caml_tanh_float:caml_tanh_float,
     caml_atanh_float:caml_atanh_float,
     caml_round_float:caml_round_float,
     caml_cbrt_float:caml_cbrt_float,
     caml_erf_float:caml_erf_float,
     caml_erfc_float:caml_erfc_float,
     caml_fma_float:caml_fma_float,
     caml_format_float:caml_format_float,
     caml_float_of_string:caml_float_of_string,
     caml_hash_mix_int:caml_hash_mix_int,
     caml_hash_mix_final:caml_hash_mix_final,
     caml_hash_mix_float:caml_hash_mix_float,
     caml_hash_mix_int64:caml_hash_mix_int64,
     caml_hash_mix_jsbytes:caml_hash_mix_jsbytes,
     caml_hash_mix_bytes_arr:caml_hash_mix_bytes_arr,
     caml_hash_mix_bytes:caml_hash_mix_bytes,
     caml_hash_mix_string:caml_hash_mix_string,
     caml_hash:caml_hash,
     caml_string_hash:caml_string_hash,
     caml_gr_state:caml_gr_state,
     caml_gr_state_get:caml_gr_state_get,
     caml_gr_state_set:caml_gr_state_set,
     caml_gr_open_graph:caml_gr_open_graph,
     caml_gr_state_init:caml_gr_state_init,
     caml_gr_state_create:caml_gr_state_create,
     caml_gr_doc_of_state:caml_gr_doc_of_state,
     caml_gr_close_graph:caml_gr_close_graph,
     caml_gr_set_window_title:caml_gr_set_window_title,
     caml_gr_resize_window:caml_gr_resize_window,
     caml_gr_clear_graph:caml_gr_clear_graph,
     caml_gr_size_x:caml_gr_size_x,
     caml_gr_size_y:caml_gr_size_y,
     caml_gr_set_color:caml_gr_set_color,
     caml_gr_plot:caml_gr_plot,
     caml_gr_point_color:caml_gr_point_color,
     caml_gr_moveto:caml_gr_moveto,
     caml_gr_current_x:caml_gr_current_x,
     caml_gr_current_y:caml_gr_current_y,
     caml_gr_lineto:caml_gr_lineto,
     caml_gr_draw_rect:caml_gr_draw_rect,
     caml_gr_arc_aux:caml_gr_arc_aux,
     caml_gr_draw_arc:caml_gr_draw_arc,
     caml_gr_set_line_width:caml_gr_set_line_width,
     caml_gr_fill_rect:caml_gr_fill_rect,
     caml_gr_fill_poly:caml_gr_fill_poly,
     caml_gr_fill_arc:caml_gr_fill_arc,
     caml_gr_draw_str:caml_gr_draw_str,
     caml_gr_draw_char:caml_gr_draw_char,
     caml_gr_draw_string:caml_gr_draw_string,
     caml_gr_set_font:caml_gr_set_font,
     caml_gr_set_text_size:caml_gr_set_text_size,
     caml_gr_text_size:caml_gr_text_size,
     caml_gr_make_image:caml_gr_make_image,
     caml_gr_dump_image:caml_gr_dump_image,
     caml_gr_draw_image:caml_gr_draw_image,
     caml_gr_create_image:caml_gr_create_image,
     caml_gr_blit_image:caml_gr_blit_image,
     caml_gr_sigio_handler:caml_gr_sigio_handler,
     caml_gr_sigio_signal:caml_gr_sigio_signal,
     caml_gr_wait_event:caml_gr_wait_event,
     caml_gr_synchronize:caml_gr_synchronize,
     caml_gr_remember_mode:caml_gr_remember_mode,
     caml_gr_display_mode:caml_gr_display_mode,
     caml_gr_window_id:caml_gr_window_id,
     caml_gr_open_subwindow:caml_gr_open_subwindow,
     caml_gr_close_subwindow:caml_gr_close_subwindow,
     caml_gc_minor:caml_gc_minor,
     caml_gc_major:caml_gc_major,
     caml_gc_full_major:caml_gc_full_major,
     caml_gc_compaction:caml_gc_compaction,
     caml_gc_counters:caml_gc_counters,
     caml_gc_quick_stat:caml_gc_quick_stat,
     caml_gc_stat:caml_gc_stat,
     caml_gc_set:caml_gc_set,
     caml_gc_get:caml_gc_get,
     caml_memprof_set:caml_memprof_set,
     caml_final_register:caml_final_register,
     caml_final_register_called_without_value:
     caml_final_register_called_without_value,
     caml_final_release:caml_final_release,
     caml_memprof_start:caml_memprof_start,
     caml_memprof_stop:caml_memprof_stop,
     caml_eventlog_resume:caml_eventlog_resume,
     caml_eventlog_pause:caml_eventlog_pause,
     caml_gc_huge_fallback_count:caml_gc_huge_fallback_count,
     caml_gc_major_slice:caml_gc_major_slice,
     caml_gc_minor_words:caml_gc_minor_words,
     caml_get_minor_free:caml_get_minor_free,
     caml_get_major_bucket:caml_get_major_bucket,
     caml_get_major_credit:caml_get_major_credit,
     fs_node_supported:fs_node_supported,
     MlNodeDevice:MlNodeDevice,
     MlNodeFd:MlNodeFd,
     caml_sys_open_for_node:caml_sys_open_for_node,
     MlFakeDevice:MlFakeDevice,
     MlFakeFile:MlFakeFile,
     MlFakeFd_out:MlFakeFd_out,
     MlFakeFd:MlFakeFd,
     caml_trailing_slash:caml_trailing_slash,
     caml_current_dir:caml_current_dir,
     caml_get_root:caml_get_root,
     caml_root:caml_root,
     MlFile:MlFile,
     path_is_absolute:path_is_absolute,
     caml_make_path:caml_make_path,
     jsoo_mount_point:jsoo_mount_point,
     caml_list_mount_point:caml_list_mount_point,
     resolve_fs_device:resolve_fs_device,
     caml_mount_autoload:caml_mount_autoload,
     caml_unmount:caml_unmount,
     caml_sys_getcwd:caml_sys_getcwd,
     caml_sys_chdir:caml_sys_chdir,
     caml_raise_no_such_file:caml_raise_no_such_file,
     caml_raise_not_a_dir:caml_raise_not_a_dir,
     caml_sys_file_exists:caml_sys_file_exists,
     caml_sys_read_directory:caml_sys_read_directory,
     caml_sys_remove:caml_sys_remove,
     caml_sys_is_directory:caml_sys_is_directory,
     caml_sys_rename:caml_sys_rename,
     caml_sys_mkdir:caml_sys_mkdir,
     caml_sys_rmdir:caml_sys_rmdir,
     caml_ba_map_file:caml_ba_map_file,
     caml_ba_map_file_bytecode:caml_ba_map_file_bytecode,
     jsoo_create_file_extern:jsoo_create_file_extern,
     caml_fs_init:caml_fs_init,
     caml_create_file:caml_create_file,
     jsoo_create_file:jsoo_create_file,
     caml_read_file_content:caml_read_file_content,
     caml_parse_format:caml_parse_format,
     caml_finish_formatting:caml_finish_formatting,
     caml_raise_constant:caml_raise_constant,
     caml_return_exn_constant:caml_return_exn_constant,
     caml_raise_with_arg:caml_raise_with_arg,
     caml_raise_with_args:caml_raise_with_args,
     caml_raise_with_string:caml_raise_with_string,
     caml_failwith:caml_failwith,
     caml_invalid_argument:caml_invalid_argument,
     caml_raise_end_of_file:caml_raise_end_of_file,
     caml_raise_zero_divide:caml_raise_zero_divide,
     caml_raise_not_found:caml_raise_not_found,
     caml_array_bound_error:caml_array_bound_error,
     caml_compare_val_tag:caml_compare_val_tag,
     caml_compare_val_get_custom:caml_compare_val_get_custom,
     caml_compare_val_number_custom:caml_compare_val_number_custom,
     caml_compare_val:caml_compare_val,
     caml_compare:caml_compare,
     caml_int_compare:caml_int_compare,
     caml_equal:caml_equal,
     caml_notequal:caml_notequal,
     caml_greaterequal:caml_greaterequal,
     caml_greaterthan:caml_greaterthan,
     caml_lessequal:caml_lessequal,
     caml_lessthan:caml_lessthan,
     caml_blit_bigstring_to_bigstring:caml_blit_bigstring_to_bigstring,
     caml_blit_bigstring_to_string:caml_blit_bigstring_to_string,
     caml_blit_string_to_bigstring:caml_blit_string_to_bigstring,
     caml_hash_mix_bigstring:caml_hash_mix_bigstring,
     bigstring_to_array_buffer:bigstring_to_array_buffer,
     bigstring_to_typed_array:bigstring_to_typed_array,
     bigstring_of_array_buffer:bigstring_of_array_buffer,
     bigstring_of_typed_array:bigstring_of_typed_array,
     caml_bigstring_memcmp:caml_bigstring_memcmp,
     caml_bigstring_blit_ba_to_ba:caml_bigstring_blit_ba_to_ba,
     caml_bigstring_blit_string_to_ba:caml_bigstring_blit_string_to_ba,
     caml_bigstring_blit_bytes_to_ba:caml_bigstring_blit_bytes_to_ba,
     caml_bigstring_blit_ba_to_bytes:caml_bigstring_blit_ba_to_bytes,
     caml_ba_init:caml_ba_init,
     caml_ba_get_size:caml_ba_get_size,
     caml_ba_get_size_per_element:caml_ba_get_size_per_element,
     caml_ba_create_buffer:caml_ba_create_buffer,
     caml_ba_custom_name:caml_ba_custom_name,
     Ml_Bigarray:Ml_Bigarray,
     Ml_Bigarray_c_1_1:Ml_Bigarray_c_1_1,
     caml_ba_compare:caml_ba_compare,
     caml_ba_create_unsafe:caml_ba_create_unsafe,
     caml_ba_create:caml_ba_create,
     caml_ba_change_layout:caml_ba_change_layout,
     caml_ba_kind:caml_ba_kind,
     caml_ba_layout:caml_ba_layout,
     caml_ba_num_dims:caml_ba_num_dims,
     caml_ba_dim:caml_ba_dim,
     caml_ba_dim_1:caml_ba_dim_1,
     caml_ba_dim_2:caml_ba_dim_2,
     caml_ba_dim_3:caml_ba_dim_3,
     caml_ba_get_generic:caml_ba_get_generic,
     caml_ba_uint8_get16:caml_ba_uint8_get16,
     caml_ba_uint8_get32:caml_ba_uint8_get32,
     caml_ba_uint8_get64:caml_ba_uint8_get64,
     caml_ba_get_1:caml_ba_get_1,
     caml_ba_get_2:caml_ba_get_2,
     caml_ba_get_3:caml_ba_get_3,
     caml_ba_set_generic:caml_ba_set_generic,
     caml_ba_uint8_set16:caml_ba_uint8_set16,
     caml_ba_uint8_set32:caml_ba_uint8_set32,
     caml_ba_uint8_set64:caml_ba_uint8_set64,
     caml_ba_set_1:caml_ba_set_1,
     caml_ba_set_2:caml_ba_set_2,
     caml_ba_set_3:caml_ba_set_3,
     caml_ba_fill:caml_ba_fill,
     caml_ba_blit:caml_ba_blit,
     caml_ba_sub:caml_ba_sub,
     caml_ba_slice:caml_ba_slice,
     caml_ba_reshape:caml_ba_reshape,
     caml_ba_serialize:caml_ba_serialize,
     caml_ba_deserialize:caml_ba_deserialize,
     caml_ba_create_from:caml_ba_create_from,
     caml_ba_hash:caml_ba_hash,
     caml_ba_to_typed_array:caml_ba_to_typed_array,
     caml_ba_kind_of_typed_array:caml_ba_kind_of_typed_array,
     caml_ba_from_typed_array:caml_ba_from_typed_array,
     caml_ml_debug_info_status:caml_ml_debug_info_status,
     caml_backtrace_status:caml_backtrace_status,
     caml_get_exception_backtrace:caml_get_exception_backtrace,
     caml_get_exception_raw_backtrace:caml_get_exception_raw_backtrace,
     caml_record_backtrace:caml_record_backtrace,
     caml_convert_raw_backtrace:caml_convert_raw_backtrace,
     caml_raw_backtrace_length:caml_raw_backtrace_length,
     caml_raw_backtrace_next_slot:caml_raw_backtrace_next_slot,
     caml_raw_backtrace_slot:caml_raw_backtrace_slot,
     caml_restore_raw_backtrace:caml_restore_raw_backtrace,
     caml_get_current_callstack:caml_get_current_callstack,
     caml_convert_raw_backtrace_slot:caml_convert_raw_backtrace_slot,
     caml_array_sub:caml_array_sub,
     caml_array_append:caml_array_append,
     caml_array_concat:caml_array_concat,
     caml_array_blit:caml_array_blit,
     caml_floatarray_blit:caml_floatarray_blit,
     caml_array_set:caml_array_set,
     caml_array_get:caml_array_get,
     caml_array_fill:caml_array_fill,
     caml_check_bound:caml_check_bound,
     caml_make_vect:caml_make_vect,
     caml_make_float_vect:caml_make_float_vect,
     caml_floatarray_create:caml_floatarray_create};
    caml_fs_init();
    caml_register_global
     (0,[248,caml_string_of_jsbytes("Out_of_memory"),-1],"Out_of_memory");
    caml_register_global
     (1,[248,caml_string_of_jsbytes("Sys_error"),-2],"Sys_error");
    caml_register_global
     (2,[248,caml_string_of_jsbytes("Failure"),-3],"Failure");
    caml_register_global
     (3,
      [248,caml_string_of_jsbytes("Invalid_argument"),-4],
      "Invalid_argument");
    caml_register_global
     (4,[248,caml_string_of_jsbytes("End_of_file"),-5],"End_of_file");
    caml_register_global
     (5,
      [248,caml_string_of_jsbytes("Division_by_zero"),-6],
      "Division_by_zero");
    caml_register_global
     (6,[248,caml_string_of_jsbytes("Not_found"),-7],"Not_found");
    caml_register_global
     (7,[248,caml_string_of_jsbytes("Match_failure"),-8],"Match_failure");
    caml_register_global
     (8,[248,caml_string_of_jsbytes("Stack_overflow"),-9],"Stack_overflow");
    caml_register_global
     (9,[248,caml_string_of_jsbytes("Sys_blocked_io"),-10],"Sys_blocked_io");
    caml_register_global
     (10,[248,caml_string_of_jsbytes("Assert_failure"),-11],"Assert_failure");
    caml_register_global
     (11,
      [248,caml_string_of_jsbytes("Undefined_recursive_module"),-12],
      "Undefined_recursive_module");
    return}
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJtYWluLmJjLnJ1bnRpbWUuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsiT2JqZWN0IiwiZ2xvYmFsVGhpcyIsInRoaXMiLCJnZXQiLCJfVF8iLCJnbG9iYWwiLCJzZWxmIiwiY2FtbF9pbnQ2NF9pc196ZXJvIiwieCIsImNhbWxfc3RyX3JlcGVhdCIsIm4iLCJzIiwiciIsImwiLCJjYW1sX2ludDY0X29mZnNldCIsIk1hdGgiLCJjYW1sX3JhaXNlX2NvbnN0YW50IiwidGFnIiwiY2FtbF9nbG9iYWxfZGF0YSIsImNhbWxfcmFpc2VfemVyb19kaXZpZGUiLCJNbEludDY0IiwibG8iLCJtaSIsImhpIiwieGhpIiwiaCIsInNpZ24iLCJvZmZzZXQiLCJtb2R1bHVzIiwiZGl2aXNvciIsInF1b3RpZW50IiwieSIsInEiLCJjYW1sX2ludDY0X29mX2ludDMyIiwiY2FtbF9pbnQ2NF90b19pbnQzMiIsImNhbWxfaW50NjRfaXNfbmVnYXRpdmUiLCJjYW1sX2ludDY0X25lZyIsImNhbWxfc3ViYXJyYXlfdG9fanNieXRlcyIsImEiLCJpIiwibGVuIiwiZiIsIlN0cmluZyIsIm51bGwiLCJjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzIiwiY2FtbF9qc2J5dGVzX29mX3N0cmluZyIsImNhbWxfcmFpc2Vfd2l0aF9hcmciLCJhcmciLCJqc29vX2lzX2FzY2lpIiwiY2FtbF91dGYxNl9vZl91dGY4IiwiYiIsInQiLCJjIiwiYzEiLCJjMiIsInYiLCJqIiwiTWxCeXRlcyIsImNvbnRlbnRzIiwibGVuZ3RoIiwiY29udGVudCIsImNhbWxfYnl0ZXNfb2ZfanNieXRlcyIsImNhbWxfc3RyaW5nX29mX2pzYnl0ZXMiLCJjYW1sX3JhaXNlX3dpdGhfc3RyaW5nIiwibXNnIiwiY2FtbF9pbnZhbGlkX2FyZ3VtZW50IiwiY2FtbF9wYXJzZV9mb3JtYXQiLCJmbXQiLCJjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nIiwicmF3YnVmZmVyIiwiYnVmZmVyIiwiY2FtbF9pbnQ2NF9mb3JtYXQiLCJ3YmFzZSIsImN2dGJsIiwicCIsImNhbWxfZXhwbTFfZmxvYXQiLCJjYW1sX21sX2NvbmRpdGlvbl9icm9hZGNhc3QiLCJjYW1sX2pzc3RyaW5nX29mX3N0cmluZyIsImZzX25vZGVfc3VwcG9ydGVkIiwibWFrZV9wYXRoX2lzX2Fic29sdXRlIiwicG9zaXgiLCJwYXRoIiwid2luMzIiLCJzcGxpdERldmljZVJlIiwicmVzdWx0IiwiZGV2aWNlIiwiaXNVbmMiLCJCb29sZWFuIiwicm9vdCIsInNlcCIsInBhdGhfaXNfYWJzb2x1dGUiLCJjYW1sX3RyYWlsaW5nX3NsYXNoIiwibmFtZSIsImNhbWxfY3VycmVudF9kaXIiLCJjYW1sX21ha2VfcGF0aCIsImNvbXAwIiwiY29tcCIsIm5jb21wIiwiY2FtbF91dGY4X29mX3V0ZjE2IiwiZCIsImNhbWxfYnl0ZXNfb2ZfdXRmMTZfanNzdHJpbmciLCJjYW1sX3N0cmluZ19vZl9qc3N0cmluZyIsInVuaXhfZXJyb3IiLCJtYWtlX3VuaXhfZXJyX2FyZ3MiLCJjb2RlIiwic3lzY2FsbCIsImVycm5vIiwidmFyaWFudCIsImFyZ3MiLCJjYW1sX25hbWVkX3ZhbHVlcyIsImNhbWxfbmFtZWRfdmFsdWUiLCJubSIsImNhbWxfcmFpc2Vfd2l0aF9hcmdzIiwiY2FtbF9pc19tbF9ieXRlcyIsImNhbWxfaXNfbWxfc3RyaW5nIiwiY2FtbF9ieXRlc19vZl9hcnJheSIsIlVpbnQ4QXJyYXkiLCJjYW1sX2J5dGVzX29mX3N0cmluZyIsImNhbWxfcmFpc2Vfc3lzX2Vycm9yIiwiY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUiLCJjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXkiLCJjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzIiwiY2FtbF9jcmVhdGVfYnl0ZXMiLCJjYW1sX21sX2J5dGVzX2xlbmd0aCIsImNhbWxfYmxpdF9ieXRlcyIsInMxIiwiaTEiLCJzMiIsImkyIiwiTWxGaWxlIiwiTWxGYWtlRmlsZSIsIm9sZCIsImJ1ZiIsInBvcyIsImNsZW4iLCJuZXdfc3RyIiwib2xkX2RhdGEiLCJkYXRhIiwiTWxGYWtlRmQiLCJmaWxlIiwiZmxhZ3MiLCJ1bmRlZmluZWQiLCJNbEZha2VEZXZpY2UiLCJyZXMiLCJTeW1ib2wiLCJuYW1lX3NsYXNoIiwibW9kZSIsInJhaXNlX3VuaXgiLCJwYXJlbnQiLCJSZWdFeHAiLCJzZWVuIiwibSIsImVudHJ5Iiwib2siLCJBcnJheSIsImJ5dGVzIiwiY2FtbF9tbF9zdHJpbmdfbGVuZ3RoIiwiY2FtbF9ieXRlc191bnNhZmVfZ2V0IiwiY2FtbF9zdHJpbmdfdW5zYWZlX2dldCIsImNhbWxfdWludDhfYXJyYXlfb2Zfc3RyaW5nIiwiY2FtbF9ieXRlc19ib3VuZF9lcnJvciIsImNhbWxfYnl0ZXNfdW5zYWZlX3NldCIsImNhbWxfYnl0ZXNfc2V0IiwiTWxOb2RlRmQiLCJmZCIsInJlcXVpcmUiLCJlcnIiLCJidWZfb2Zmc2V0IiwicmVhZCIsIk1sTm9kZURldmljZSIsImNvbnN0cyIsImtleSIsImlzQ2hhcmFjdGVyRGV2aWNlIiwibyIsImpzX3N0YXRzIiwidG9fZGlyIiwidGFyZ2V0IiwibGluayIsImZpbGVfa2luZCIsImNhbWxfZ2V0X3Jvb3QiLCJjYW1sX2ZhaWx3aXRoIiwiY2FtbF9yb290IiwianNvb19tb3VudF9wb2ludCIsInJlc29sdmVfZnNfZGV2aWNlIiwiY2FtbF9zeXNfaXNfZGlyZWN0b3J5IiwiY2FtbF9yYWlzZV9ub3RfZm91bmQiLCJjYW1sX3N5c19nZXRlbnYiLCJwcm9jZXNzIiwic2hpZnRfcmlnaHRfbmF0IiwibmF0MSIsIm9mczEiLCJsZW4xIiwibmF0MiIsIm9mczIiLCJuYml0cyIsIndyYXAiLCJjYW1sX2dyX3N0YXRlIiwiY2FtbF9ncl9zdGF0ZV9nZXQiLCJjYW1sX2dyX3BvaW50X2NvbG9yIiwiaW0iLCJNbE9iamVjdFRhYmxlIiwiTmFpdmVMb29rdXAiLCJvYmpzIiwiY2FtbF9zeXNfcmVuYW1lIiwib19yb290Iiwibl9yb290IiwiY2FtbF9sb2cxMF9mbG9hdCIsImNhbWxfcnVudGltZV93YXJuaW5ncyIsImNhbWxfbWxfZW5hYmxlX3J1bnRpbWVfd2FybmluZ3MiLCJib29sIiwiY2FtbF9jbGFzc2lmeV9mbG9hdCIsImlzRmluaXRlIiwiaXNOYU4iLCJjYW1sX21sX2NoYW5uZWxzIiwiY2FtbF9yZWZpbGwiLCJjaGFuIiwic3RyIiwic3RyX2EiLCJucmVhZCIsImNhbWxfYXJyYXlfYm91bmRfZXJyb3IiLCJjYW1sX21sX2lucHV0X3NjYW5fbGluZSIsImNoYW5pZCIsInByZXZfbWF4IiwiY2FtbF9nY19taW5vciIsInVuaXQiLCJjYW1sX21sX2NvbmRpdGlvbl9uZXciLCJjYW1sX2ludDY0X29mX2J5dGVzIiwiY2FtbF9iYV91aW50OF9nZXQ2NCIsImJhIiwiaTAiLCJvZnMiLCJiMSIsImIyIiwiYjMiLCJiNCIsImI1IiwiYjYiLCJiNyIsImI4IiwiY2FtbF9pbnQ2NF90b19ieXRlcyIsImNhbWxfaW50NjRfbWFyc2hhbCIsIndyaXRlciIsInNpemVzIiwiY2FtbF9iYV9udW1fZGltcyIsImNhbWxfcmV0dXJuX2V4bl9jb25zdGFudCIsImNhbWxfd3JhcF9leGNlcHRpb24iLCJlIiwiY2FtbF9jcmVhdGVfZmlsZSIsImpzb29fY3JlYXRlX2ZpbGUiLCJjYW1sX2ZzX2luaXQiLCJ0bXAiLCJjYW1sX211bCIsImNhbWxfaGFzaF9taXhfaW50IiwiY2FtbF9oYXNoX21peF9qc2J5dGVzIiwidyIsImNhbWxfaGFzaF9taXhfc3RyaW5nIiwiQmFzZV9pbnRlcm5hbGhhc2hfZm9sZF9zdHJpbmciLCJjYW1sX2dldF9jb250aW51YXRpb25fY2FsbHN0YWNrIiwiY2FtbF9wYXJzZXJfdHJhY2UiLCJjYW1sX3NldF9wYXJzZXJfdHJhY2UiLCJvbGRmbGFnIiwiY2FtbF9saXN0X29mX2pzX2FycmF5IiwibnVtX2RpZ2l0c19uYXQiLCJuYXQiLCJjYW1sX2hhc2hfbmF0IiwiY2FtbF9jYWxsX2dlbiIsImFyZ3NMZW4iLCJleHRyYV9hcmdzIiwiYXJndW1lbnRzIiwibmFyZ3MiLCJjYW1sX2NhbGxiYWNrIiwiY2FtbF9qc193cmFwX2NhbGxiYWNrX2FyZ3VtZW50cyIsImNhbWxfc3lzX2NoZGlyIiwiZGlyIiwiY2FtbF9vYmpfdGFnIiwiRnVuY3Rpb24iLCJjYW1sX29ial91cGRhdGVfdGFnIiwiY2FtbF9tbF9kb21haW5fdW5pcXVlX3Rva2VuXyIsImNhbWxfbWxfZG9tYWluX3VuaXF1ZV90b2tlbiIsImNhbWxfbGF6eV91cGRhdGVfdG9fZm9yY2luZyIsImZpZWxkMCIsImNhbWxfZ2NfY291bnRlcnMiLCJjYW1sX2dyX3N5bmNocm9uaXplIiwiY2FtbF91bml4X2Nsb3NlZGlyIiwiZGlyX2hhbmRsZSIsImNhbWxfdW5peF9vcGVuZGlyIiwiY2FtbF91bml4X3Jld2luZGRpciIsIm5ld19kaXJfaGFuZGxlIiwiY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSIsImNhbWxfdW5peF9yZWFkZGlyIiwiY2FtbF91bml4X2ZpbmRmaXJzdCIsInBhdGhfanMiLCJmaXJzdF9lbnRyeSIsImNhbWxfaXNfY29udGludWF0aW9uX3RhZyIsImxvZzJfb2siLCJqc29vX2Zsb29yX2xvZzIiLCJJbmZpbml0eSIsImNhbWxfaW50MzJfYml0c19vZl9mbG9hdCIsImZsb2F0MzJhIiwiRmxvYXQzMkFycmF5IiwiaW50MzJhIiwiSW50MzJBcnJheSIsImNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpIiwiY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0IiwiZXhwIiwiayIsInIzIiwicjIiLCJyMSIsImNhbWxfYmFfc2VyaWFsaXplIiwic3oiLCJjb21wbGV4IiwiY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudCIsImtpbmQiLCJjYW1sX2JhX2NyZWF0ZV9idWZmZXIiLCJzaXplIiwidmlldyIsIkZsb2F0NjRBcnJheSIsIkludDhBcnJheSIsIkludDE2QXJyYXkiLCJVaW50MTZBcnJheSIsImNhbWxfaW50MzJfZmxvYXRfb2ZfYml0cyIsImNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyIsIk5hTiIsImNhbWxfYmFfZ2V0X3NpemUiLCJkaW1zIiwibl9kaW1zIiwiY2FtbF9pbnQ2NF9jcmVhdGVfbG9faGkiLCJjYW1sX2ludDY0X2hpMzIiLCJjYW1sX2ludDY0X2xvMzIiLCJjYW1sX2JhX2N1c3RvbV9uYW1lIiwiTWxfQmlnYXJyYXkiLCJsYXlvdXQiLCJyZSIsInRvdGFsIiwiazEiLCJrMiIsIk1sX0JpZ2FycmF5X2NfMV8xIiwiY2FtbF9iYV9jcmVhdGVfdW5zYWZlIiwic2l6ZV9wZXJfZWxlbWVudCIsImNhbWxfYmFfZGVzZXJpYWxpemUiLCJyZWFkZXIiLCJudW1fZGltcyIsInNpemVfZGltIiwic2l6ZV9kaW1faGkiLCJzaXplX2RpbV9sbyIsInNpeHR5IiwiaW50NjQiLCJjYW1sX2JhX2NvbXBhcmUiLCJjYW1sX2hhc2hfbWl4X2ludDY0IiwiY2FtbF9oYXNoX21peF9mbG9hdCIsInYwIiwiY2FtbF9iYV9oYXNoIiwibnVtX2VsdHMiLCJjYW1sX2ludDMyX3VubWFyc2hhbCIsImNhbWxfbmF0aXZlaW50X3VubWFyc2hhbCIsImNhbWxfaW50NjRfdW5tYXJzaGFsIiwiY2FtbF9pbnQ2NF9jb21wYXJlIiwiY2FtbF9pbnQ2NF9oYXNoIiwiY2FtbF9jdXN0b21fb3BzIiwiY2FtbF9jb21wYXJlX3ZhbF9nZXRfY3VzdG9tIiwiY2FtbF9jb21wYXJlX3ZhbF9udW1iZXJfY3VzdG9tIiwibnVtIiwiY3VzdG9tIiwic3dhcCIsImNhbWxfY29tcGFyZV92YWxfdGFnIiwiTnVtYmVyIiwiY2FtbF9pbnRfY29tcGFyZSIsImNhbWxfYnl0ZXNfY29tcGFyZSIsImNhbWxfc3RyaW5nX2NvbXBhcmUiLCJjYW1sX2NvbXBhcmVfdmFsIiwic3RhY2siLCJ0YWdfYSIsInRhZ19iIiwiY2FtbF9ncmVhdGVydGhhbiIsImRpdl9oZWxwZXIiLCJ6IiwiZGl2X2RpZ2l0X25hdCIsIm5hdHEiLCJvZnNxIiwibmF0ciIsIm9mc3IiLCJyZW0iLCJudW1fbGVhZGluZ196ZXJvX2JpdHNfaW5fZGlnaXQiLCJzaGlmdF9sZWZ0X25hdCIsIk1sTmF0IiwiY3JlYXRlX25hdCIsImFyciIsInNldF90b196ZXJvX25hdCIsImluY3JfbmF0IiwiY2FycnlfaW4iLCJjYXJyeSIsImFkZF9uYXQiLCJsZW4yIiwibmF0X29mX2FycmF5IiwibXVsdF9kaWdpdF9uYXQiLCJuYXQzIiwib2ZzMyIsIngxIiwieDIiLCJ4MyIsImRlY3JfbmF0IiwiYm9ycm93Iiwic3ViX25hdCIsImNvbXBhcmVfbmF0IiwiZGl2X25hdCIsInF1byIsImNhbWxfYmFfYmxpdCIsInNyYyIsImRzdCIsImlzX2RpZ2l0X2ludCIsImNhbWxfaW50NjRfZGl2IiwiY2FtbF9qc19odG1sX2VudGl0aWVzIiwiZW50aXR5IiwidGVtcCIsImRvY3VtZW50IiwiY2FtbF9zdHJpbmdfdW5zYWZlX3NldCIsImNhbWxfaW50NjRfb2ZfZmxvYXQiLCJjYW1sX21sX2NoYW5uZWxfc2l6ZV82NCIsImNhbWxfYmFfc2V0XzIiLCJjYW1sX2FyZ3YiLCJtYWluIiwiYXJndiIsImFyZ3MyIiwiY2FtbF9leGVjdXRhYmxlX25hbWUiLCJjYW1sX2pzX2V2YWxfc3RyaW5nIiwiZXZhbCIsInNlcmlhbGl6ZV9uYXQiLCJjYW1sX21lbXByb2Zfc2V0IiwiX2NvbnRyb2wiLCJjYW1sX3N5c19leGl0IiwiY2FtbF9jaGFubmVsX2Rlc2NyaXB0b3IiLCJjYW1sX2pzX2Zyb21fYXJyYXkiLCJjYW1sX2JhX3Jlc2hhcGUiLCJ2aW5kIiwibmV3X2RpbSIsImNhbWxfb29fbGFzdF9pZCIsImNhbWxfc2V0X29vX2lkIiwiY2FtbF9ncl9maWxsX3JlY3QiLCJjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYSIsInN0cjEiLCJwb3MxIiwiYmEyIiwicG9zMiIsInNsaWNlIiwiY2FtbF9ncl9zZXRfd2luZG93X3RpdGxlIiwianNuYW1lIiwiY2FtbF9nZXRfZ2xvYmFsX2RhdGEiLCJjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkIiwiY2FtbF9iYV91aW50OF9nZXQxNiIsImNhbWxfY29tcGFyZSIsImNhbWxfTUQ1VHJhbnNmb3JtIiwiYWRkIiwieHgiLCJmZiIsImdnIiwiaGgiLCJpaSIsImNhbWxfTUQ1VXBkYXRlIiwiY3R4IiwiaW5wdXQiLCJpbnB1dF9sZW4iLCJpbl9idWYiLCJpbnB1dF9wb3MiLCJtaXNzaW5nIiwiY2FtbF9mcmVzaF9vb19pZCIsImNhbWxfaW50NjRfdG9fZmxvYXQiLCJjYW1sX2JhX2dldF8xIiwiY2FtbF9iaWdzdHJpbmdfbWVtY21wIiwiY2FtbF9uZXdfc3RyaW5nIiwiY2FtbF9lcmZfZmxvYXQiLCJhMSIsImEyIiwiYTMiLCJhNCIsImE1IiwiY2FtbF9iYV91aW50OF9nZXQzMiIsImNhbWxfcmF3X2JhY2t0cmFjZV9sZW5ndGgiLCJjYW1sX3N0cl9pbml0aWFsaXplIiwiY2FtbF9vYmpfYmxvY2siLCJjYW1sX2dyX2NsZWFyX2dyYXBoIiwiYmlnc3RyaW5nX3RvX2FycmF5X2J1ZmZlciIsImJzIiwiY2FtbF9zeXNfY29uc3RfbmFrZWRfcG9pbnRlcnNfY2hlY2tlZCIsIl91bml0IiwibHhvcl9kaWdpdF9uYXQiLCJjYW1sX29ial9hZGRfb2Zmc2V0IiwiY2FtbF9maW5hbF9yZWxlYXNlIiwiY2FtbF9qc190b19hcnJheSIsImNhbWxfZ3JfcGxvdCIsImNvbG9yIiwiY2FtbF9ieXRlc19zZXQxNiIsImkxNiIsImNhbWxfc3RyaW5nX3NldDE2IiwiY2FtbF9ieXRlc19zZXQ2NCIsImk2NCIsImNhbWxfaW50NjRfYnN3YXAiLCJjYW1sX2djX21ham9yIiwiY2FtbF9sZXhfYXJyYXkiLCJjYW1sX2xleF9lbmdpbmUiLCJ0YmwiLCJzdGFydF9zdGF0ZSIsImxleGJ1ZiIsImxleF9idWZmZXIiLCJsZXhfYnVmZmVyX2xlbiIsImxleF9zdGFydF9wb3MiLCJsZXhfY3Vycl9wb3MiLCJsZXhfbGFzdF9wb3MiLCJsZXhfbGFzdF9hY3Rpb24iLCJsZXhfZW9mX3JlYWNoZWQiLCJsZXhfYmFzZSIsImxleF9iYWNrdHJrIiwibGV4X2RlZmF1bHQiLCJsZXhfdHJhbnMiLCJsZXhfY2hlY2siLCJzdGF0ZSIsImJhc2UiLCJiYWNrdHJrIiwiY2FtbF9zeXNfZmlsZV9leGlzdHMiLCJjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZV9zbG90IiwiY2FtbF9hcnJheV9zdWIiLCJjYW1sX2J5dGVzX2VxdWFsIiwiY2FtbF9ncl9zaXplX3giLCJCYXNlX2ludF9tYXRoX2ludDMyX2NseiIsImNhbWxfbWxfZGVidWdfaW5mb19zdGF0dXMiLCJjYW1sX2F0b21pY19mZXRjaF9hZGQiLCJyZWYiLCJvc190eXBlIiwiY2FtbF9zeXNfY29uc3Rfb3N0eXBlX2N5Z3dpbiIsImNhbWxfY29zaF9mbG9hdCIsIk1sTXV0ZXgiLCJjYW1sX21sX211dGV4X25ldyIsImNhbWxfZXBoZV9rZXlfb2Zmc2V0IiwiY2FtbF9lcGhlX2NoZWNrX2tleSIsIndlYWsiLCJjYW1sX2hhc2hfbWl4X2ZpbmFsIiwiY2FtbF9ncl90ZXh0X3NpemUiLCJ0eHQiLCJjYW1sX2xleF9ydW5fbWVtIiwibWVtIiwiY3Vycl9wb3MiLCJjYW1sX2xleF9ydW5fdGFnIiwiY2FtbF9uZXdfbGV4X2VuZ2luZSIsImxleF9tZW0iLCJsZXhfYmFzZV9jb2RlIiwibGV4X2JhY2t0cmtfY29kZSIsImxleF9kZWZhdWx0X2NvZGUiLCJsZXhfdHJhbnNfY29kZSIsImxleF9jaGVja19jb2RlIiwibGV4X2NvZGUiLCJwY19vZmYiLCJwc3RhdGUiLCJiYXNlX2NvZGUiLCJjYW1sX2JhX3VpbnQ4X3NldDY0IiwiY2FtbF9zeXNfZXhlY3V0YWJsZV9uYW1lIiwiY2FtbF9sZXNzZXF1YWwiLCJjYW1sX2Fjb3NoX2Zsb2F0IiwiY2FtbF9NRDVJbml0IiwiQXJyYXlCdWZmZXIiLCJiMzIiLCJVaW50MzJBcnJheSIsImNhbWxfbWxfZmx1c2giLCJjYW1sX3NlZWtfb3V0IiwiY2FtbF9tbF9zZWVrX291dF82NCIsImNvbXBhcmVfbmF0X3JlYWwiLCJjYW1sX2djX3NldCIsImNhbWxfanNfZ2V0IiwiY2FtbF91bml4X2lzYXR0eSIsImZpbGVEZXNjcmlwdG9yIiwidHR5IiwiY2FtbF9tbF9zZXRfYnVmZmVyZWQiLCJjYW1sX2hhc2hfbWl4X2J5dGVzX2FyciIsImNhbWxfbWxfYnl0ZXNfY29udGVudCIsImNhbWxfaGFzaF9taXhfYnl0ZXMiLCJjYW1sX2hhc2giLCJjb3VudCIsImxpbWl0Iiwic2VlZCIsIm9iaiIsInF1ZXVlIiwicmQiLCJ3ciIsIkJhc2VfaGFzaF9zdHJpbmciLCJjYW1sX2djX2NvbXBhY3Rpb24iLCJjYW1sX2VwaGVfZ2V0X2tleSIsImNhbWxfdW5peF9sb2NhbHRpbWUiLCJEYXRlIiwiZF9udW0iLCJqYW51YXJ5Zmlyc3QiLCJkb3kiLCJqYW4iLCJqdWwiLCJzdGRUaW1lem9uZU9mZnNldCIsImNhbWxfdW5peF9ta3RpbWUiLCJ0bSIsInRtMiIsImNhbWxfYmlnc3RyaW5nX2JsaXRfYnl0ZXNfdG9fYmEiLCJjYW1sX3N5c19mZHMiLCJjYW1sX3N5c19jbG9zZSIsImNhbWxfbWxfY2xvc2VfY2hhbm5lbCIsImNhbWxfZXhuX3dpdGhfanNfYmFja3RyYWNlIiwiZXhuIiwiZm9yY2UiLCJCYXNlX2ludF9tYXRoX2ludF9wb3dfc3R1YiIsImV4cG9uZW50Iiwib25lIiwibXVsIiwiY2FtbF9hdG9taWNfZXhjaGFuZ2UiLCJjYW1sX3N5c19pc2F0dHkiLCJfY2hhbiIsImlzX2RpZ2l0X3plcm8iLCJjYW1sX3VuaXhfbHN0YXQiLCJjYW1sX3VuaXhfbHN0YXRfNjQiLCJjYW1sX2pzX3NldCIsImNhbWxfYXJyYXlfZ2V0IiwiYXJyYXkiLCJpbmRleCIsImNhbWxfY29udGludWF0aW9uX3VzZV9ub2V4YyIsImNvbnQiLCJjYW1sX3VuaXhfcm1kaXIiLCJjYW1sX2xvZzJfZmxvYXQiLCJjYW1sX2djX2h1Z2VfZmFsbGJhY2tfY291bnQiLCJjYW1sX3NwYWNldGltZV9vbmx5X3dvcmtzX2Zvcl9uYXRpdmVfY29kZSIsImNhbWxfaW50NjRfc3ViIiwiY2FtbF9zZWVrX2luIiwiY2FtbF9tbF9zZWVrX2luXzY0IiwiY2FtbF9kb21haW5faWQiLCJjYW1sX21sX211dGV4X3VubG9jayIsImNhbWxfZG9tYWluX2xhdGVzdF9pZHgiLCJjYW1sX2RvbWFpbl9zcGF3biIsIm11dGV4IiwiaWQiLCJjYW1sX3VuaXhfbWtkaXIiLCJwZXJtIiwiY2FtbF9pbnQ2NF9zaGlmdF9sZWZ0IiwiY2FtbF9ub3RlcXVhbCIsImNhbWxfc3lzX2NvbnN0X2ludF9zaXplIiwiY2FtbF9qc193cmFwX2NhbGxiYWNrIiwiY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2siLCJjYW1sX2lzX2pzIiwiQmFzZV9pbnRlcm5hbGhhc2hfZm9sZF9mbG9hdCIsImNhbWxfbGF6eV91cGRhdGVfdG9fZm9yd2FyZCIsImNhbWxfYmFfZGltIiwiY2FtbF9iYV9kaW1fMSIsImNhbWxfanNfbWV0aF9jYWxsIiwiY2FtbF9lcGhlX2RhdGFfb2Zmc2V0IiwiY2FtbF93ZWFrX2NyZWF0ZSIsImNhbWxfZXBoZV9jcmVhdGUiLCJjYW1sX2pzX3RvX2J5dGVfc3RyaW5nIiwiY2FtbF90cmFtcG9saW5lIiwiY2FtbF9tYXliZV9wcmludF9zdGF0cyIsImNhbWxfYnl0ZXNfZ2V0NjQiLCJjYW1sX3VuaXhfaGFzX3N5bWxpbmsiLCJjYW1sX2VwaGVfc2V0X2tleSIsImNhbWxfZXBoZV91bnNldF9rZXkiLCJjYW1sX3dlYWtfc2V0IiwiY2FtbF9zeXNfcmVtb3ZlIiwiY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IiLCJjYW1sX3N0cmluZ19nZXQzMiIsImNhbWxfYnl0ZXNfZ2V0IiwiY2FtbF9oeXBvdF9mbG9hdCIsImNhbWxfanNfY2FsbCIsImNhbWxfc3lzX2NvbnN0X21heF93b3NpemUiLCJjYW1sX3VuaXhfaW5ldF9hZGRyX29mX3N0cmluZyIsIkJhc2VfYW1fdGVzdGluZyIsImNhbWxfYnl0ZXNfbGVzc3RoYW4iLCJjYW1sX2VyZmNfZmxvYXQiLCJjYW1sX2dyX2ZpbGxfcG9seSIsImFyIiwiY2FtbF9nY19xdWlja19zdGF0IiwiY2FtbF9tbF9pbnB1dF9jaGFyIiwiY2FtbF9tbF9pbnB1dF9pbnQiLCJjYW1sX2dyX2Rpc3BsYXlfbW9kZSIsImNhbWxfb2JqX3JlYWNoYWJsZV93b3JkcyIsIm50aF9kaWdpdF9uYXQiLCJjYW1sX2FycmF5X2JsaXQiLCJjYW1sX2Zsb2F0X29mX3N0cmluZyIsIm0zIiwibWFudGlzc2EiLCJwYXJzZUludCIsImNhbWxfc3lzX2dldGN3ZCIsImNhbWxfaW50NjRfYWRkIiwiY2FtbF9pbnQ2NF9tdWwiLCJjYW1sX2ludDY0X3VsdCIsImNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZSIsImNhbWxfcGFyc2VfZGlnaXQiLCJjYW1sX2ludDY0X29mX3N0cmluZyIsImJhc2U2NCIsInRocmVzaG9sZCIsImNhbWxfYmFfc2V0XzEiLCJjYW1sX2ludDY0X3hvciIsImNhbWxfaW50NjRfb3IiLCJjYW1sX2x4bV9uZXh0Iiwic2hpZnRfbCIsInNoaWZ0X3IiLCJvciIsInhvciIsInJvdGwiLCJzZXQiLCJNIiwiZGFiYSIsInEwIiwicTEiLCJzdCIsIngwIiwiY2FtbF9zeXNfY29uc3RfYmlnX2VuZGlhbiIsImNhbWxfbGlzdF90b19qc19hcnJheSIsImNhbWxfbGVnYWN5X2N1c3RvbV9jb2RlIiwiY2FtbF9vdXRwdXRfdmFsIiwiV3JpdGVyIiwidmFsdWUiLCJub19zaGFyaW5nIiwiY2xvc3VyZXMiLCJjb25zb2xlIiwiaW50ZXJuX29ial90YWJsZSIsIm1lbW8iLCJleGlzdGluZ19vZmZzZXQiLCJleHRlcm5fcmVjIiwib3BzIiwic3pfMzJfNjQiLCJoZWFkZXJfcG9zIiwib2xkX3BvcyIsInR5cGVfb2ZfdiIsImNhbWxfc3RyaW5nX29mX2FycmF5IiwiY2FtbF9vdXRwdXRfdmFsdWVfdG9fc3RyaW5nIiwiY2FtbF9yYWlzZV9ub3RfYV9kaXIiLCJjYW1sX3N5c19zeXN0ZW1fY29tbWFuZCIsImNtZCIsImNoaWxkX3Byb2Nlc3MiLCJjYW1sX2pzX2Vycm9yX29mX2V4Y2VwdGlvbiIsImNhbWxfdW5peF9nZXR1aWQiLCJkZXNlcmlhbGl6ZV9uYXQiLCJpbml0aWFsaXplX25hdCIsImNhbWxfZ3Jfb3Blbl9zdWJ3aW5kb3ciLCJjYW1sX21hcnNoYWxfZGF0YV9zaXplIiwiZ2V0MzIiLCJNbFN0cmluZ1JlYWRlciIsImNhbWxfZmxvYXRfb2ZfYnl0ZXMiLCJjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyIiwiX21hZ2ljIiwiX2Jsb2NrX2xlbiIsIm51bV9vYmplY3RzIiwiX3NpemVfMzIiLCJfc2l6ZV82NCIsIm9ial9jb3VudGVyIiwiaW50ZXJuX3JlYyIsImhlYWRlciIsImV4cGVjdGVkX3NpemUiLCJjYW1sX3N0cmluZ19vZl9ieXRlcyIsImNhbWxfaW5wdXRfdmFsdWVfZnJvbV9ieXRlcyIsImNhbWxfaW5wdXRfdmFsdWUiLCJibG9jayIsImNhbWxfaW5wdXRfdmFsdWVfdG9fb3V0c2lkZV9oZWFwIiwiY2FtbF9hdG9taWNfY2FzIiwiY2FtbF9jb3B5c2lnbl9mbG9hdCIsImNhbWxfZ3Jfc2V0X3RleHRfc2l6ZSIsImNhbWxfYXRvbWljX2xvYWQiLCJjYW1sX01ENUZpbmFsIiwiY2FtbF9tZDVfYnl0ZXMiLCJjYW1sX2JhX3NldF9nZW5lcmljIiwiY2FtbF9tbF9jb25kaXRpb25fd2FpdCIsIm11dGV4dCIsImNhbWxfYnl0ZXNfbGVzc2VxdWFsIiwiY2FtbF9zdHJpbmdfbGVzc2VxdWFsIiwiY2FtbF9zdHJpbmdfZ3JlYXRlcmVxdWFsIiwiY2FtbF9uZXh0YWZ0ZXJfZmxvYXQiLCJiaXRzIiwiY2FtbF9ncl9zaXplX3kiLCJjYW1sX3Bvc19pbiIsImNhbWxfbWxfcG9zX2luIiwiY2FtbF9pbnQ2NF9hbmQiLCJCYXNlX2ludF9tYXRoX2ludDY0X3Bvd19zdHViIiwiY2FtbF9zeXNfY29uc3Rfd29yZF9zaXplIiwiY2FtbF91bml4X3VubGluayIsImNhbWxfc3lzX29wZW5fZm9yX25vZGUiLCJmcyIsImZkMiIsIk1sRmFrZUZkX291dCIsImNhbWxfc3lzX29wZW5faW50ZXJuYWwiLCJpZHgiLCJjYW1sX3N5c19vcGVuIiwiX3Blcm1zIiwiY2FtbF9zdHJpbmdfZ2V0IiwicmVfbWF0Y2giLCJyZV93b3JkX2xldHRlcnMiLCJvcGNvZGVzIiwiaXNfd29yZF9sZXR0ZXIiLCJpbl9iaXRzZXQiLCJyZV9tYXRjaF9pbXBsIiwicGFydGlhbCIsInByb2ciLCJjcG9vbCIsIm5vcm10YWJsZSIsIm51bWdyb3VwcyIsIm51bXJlZ2lzdGVycyIsInN0YXJ0Y2hhcnMiLCJwYyIsInF1aXQiLCJncm91cHMiLCJyZV9yZWdpc3RlciIsImJhY2t0cmFjayIsIml0ZW0iLCJwdXNoIiwiYWNjZXB0IiwiZyIsInByZWZpeF9tYXRjaCIsIm9wIiwic2FyZyIsInVhcmciLCJncm91cCIsIkVycm9yIiwicmVfc2VhcmNoX2JhY2t3YXJkIiwiY2FtbF9qc19mcm9tX3N0cmluZyIsImNhbWxfYmFfc3ViIiwiY2hhbmdlZF9kaW0iLCJuZXdfZGltcyIsIm5ld19kYXRhIiwiY2FtbF9nY19mdWxsX21ham9yIiwiY2FtbF9tbF9tdXRleF90cnlfbG9jayIsImNhbWxfYnl0ZXNfc2V0MzIiLCJpMzIiLCJjYW1sX2dyX3NpZ2lvX3NpZ25hbCIsImNhbWxfYmFfdWludDhfc2V0MzIiLCJjYW1sX3N5c19jb25zdF9vc3R5cGVfdW5peCIsImNhbWxfdW5peF9nbXRpbWUiLCJjYW1sX3NpZ25iaXRfZmxvYXQiLCJjYW1sX2dyX3NldF9saW5lX3dpZHRoIiwiY2FtbF9ncl9zZXRfZm9udCIsImNhbWxfZ3Jfc2V0X2NvbG9yIiwiY29udmVydCIsIm51bWJlciIsImNfc3RyIiwiY2FtbF9ncl9tb3ZldG8iLCJjYW1sX2dyX3Jlc2l6ZV93aW5kb3ciLCJjYW1sX2dyX3N0YXRlX2luaXQiLCJjYW1sX2dyX2N1cnJlbnRfeCIsImNhbWxfYmFfa2luZF9vZl90eXBlZF9hcnJheSIsInRhIiwiY2FtbF9iYV9mcm9tX3R5cGVkX2FycmF5IiwiY2FtbF9tbF9zZWVrX291dCIsImNhbWxfanNfdHlwZW9mIiwiY2FtbF9zdHJpbmdfaGFzaCIsImNhbWxfcmVzdG9yZV9yYXdfYmFja3RyYWNlIiwiYnQiLCJCYXNlX2ludF9tYXRoX2ludDMyX2N0eiIsIkJhc2VfaW50X21hdGhfbmF0aXZlaW50X2N0eiIsImNhbWxfZ3JfbGluZXRvIiwiY2FtbF9qc19mdW5jdGlvbl9hcml0eSIsImNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX3Vuc2FmZSIsImNhbWxfYmFfZGltXzMiLCJjYW1sX2lzX3NwZWNpYWxfZXhjZXB0aW9uIiwiY2FtbF9mb3JtYXRfZXhjZXB0aW9uIiwiYnVja2V0Iiwic3RhcnQiLCJjYW1sX2ZhdGFsX3VuY2F1Z2h0X2V4Y2VwdGlvbiIsImhhbmRsZXIiLCJhdF9leGl0IiwiY2FtbF9lcGhlX2NoZWNrX2RhdGEiLCJjYW1sX2J5dGVzX2dldDE2IiwiY2FtbF9vYmpfbWFrZV9mb3J3YXJkIiwiY2FtbF9qc19mcm9tX2Jvb2wiLCJjYW1sX21sX3NldF9jaGFubmVsX25hbWUiLCJjYW1sX2V4cDJfZmxvYXQiLCJjYW1sX2dyX2Nsb3NlX2dyYXBoIiwiQmFzZV9pbnRlcm5hbGhhc2hfZm9sZF9pbnQiLCJjYW1sX21sX2RvbWFpbl9jcHVfcmVsYXgiLCJjYW1sX2NyZWF0ZV9zdHJpbmciLCJCYXNlX2ludF9tYXRoX25hdGl2ZWludF9jbHoiLCJjYW1sX21sX2lucHV0X2Jsb2NrIiwiYXZhaWwiLCJjYW1sX21kNV9jaGFuIiwidG9yZWFkIiwiY2FtbF9hdGFuaF9mbG9hdCIsImNhbWxfbWxfY29uZGl0aW9uX3NpZ25hbCIsImNhbWxfdW5peF9maW5kbmV4dCIsImNhbWxfbWxfb3V0cHV0X2J5dGVzIiwiY2FtbF9tbF9vdXRwdXQiLCJjYW1sX21sX2RvbWFpbl9pZCIsImNhbWxfZXBoZV9nZXRfZGF0YSIsImNhbWxfeG1saHR0cHJlcXVlc3RfY3JlYXRlIiwiY2FtbF90cmFtcG9saW5lX3JldHVybiIsImNhbWxfbWxfaXNfYnVmZmVyZWQiLCJCYXNlX2ludF9tYXRoX2ludDY0X2NseiIsImNhbWxfYXJyYXlfYXBwZW5kIiwibDEiLCJsMiIsImNhbWxfdW5peF9nZXR0aW1lb2ZkYXkiLCJjYW1sX3VuaXhfdGltZSIsImNhbWxfbWxfc2V0X2NoYW5uZWxfcmVmaWxsIiwiY2FtbF9maWxsX2J5dGVzIiwiY2FtbF9qc19leHByIiwiY2FtbF9tbF9ydW50aW1lX3dhcm5pbmdzX2VuYWJsZWQiLCJjYW1sX291dHB1dF92YWx1ZV90b19ieXRlcyIsImNhbWxfZXZlbnRsb2dfcmVzdW1lIiwiY2FtbF9tZDVfc3RyaW5nIiwiY2FtbF9zdHJpbmdfZXF1YWwiLCJjYW1sX2FycmF5X29mX3N0cmluZyIsImNhbWxfanNvb19mbGFnc191c2VfanNfc3RyaW5nIiwiY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnVmZmVyIiwicmVfcmVwbGFjZW1lbnRfdGV4dCIsInJlcGwiLCJvcmlnIiwiY3VyIiwiZW5kIiwiY2FtbF9wdXJlX2pzX2V4cHIiLCJjYW1sX2JsaXRfc3RyaW5nIiwiYmxpdF9uYXQiLCJjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2J5dGVzIiwiYmExIiwiYnl0ZXMyIiwiY2FtbF91bml4X3N0YXQiLCJjYW1sX3JlZ2lzdGVyX25hbWVkX3ZhbHVlIiwianNvb19jcmVhdGVfZmlsZV9leHRlcm4iLCJjYW1sX3VuaXhfc3RhdF82NCIsImNhbWxfdG9fanNfc3RyaW5nIiwiY2FtbF9tbF9tdXRleF9sb2NrIiwicmVfc2VhcmNoX2ZvcndhcmQiLCJjYW1sX2JsaXRfc3RyaW5nX3RvX2JpZ3N0cmluZyIsImNhbWxfbWFrZV92ZWN0IiwiaW5pdCIsImNhbWxfbWxfc2Vla19pbiIsImNhbWxfc3lzX3JlYWRfZGlyZWN0b3J5IiwiY2FtbF9tbF9vdXRwdXRfY2hhciIsImNhbWxfc3lzX2NvbnN0X29zdHlwZV93aW4zMiIsImNhbWxfb2JqX2lzX2Jsb2NrIiwiY2FtbF9vYmpfc2V0X3Jhd19maWVsZCIsImNhbWxfanNfdmFyIiwiY2FtbF90cnVuY19mbG9hdCIsImNhbWxfZXBoZV91bnNldF9kYXRhIiwiY2FtbF9lcGhlX3NldF9kYXRhIiwiY2FtbF9lcGhlX2JsaXRfZGF0YSIsIkJhc2VfaW50ZXJuYWxoYXNoX2ZvbGRfaW50NjQiLCJjYW1sX2lzX3ByaW50YWJsZSIsImNhbWxfYXJyYXlfb2ZfYnl0ZXMiLCJjYW1sX2VxdWFsIiwicmVfcGFydGlhbF9tYXRjaCIsImNhbWxfc3lzX3JhbmRvbV9zZWVkIiwiYnVmZiIsIm5vdyIsImFsbF9maW5hbGl6ZXJzIiwiY2FtbF9maW5hbF9yZWdpc3Rlcl9jYWxsZWRfd2l0aG91dF92YWx1ZSIsImNiIiwiY2FtbF9iYV9nZXRfMiIsImNhbWxfYmFfdWludDhfc2V0MTYiLCJjYW1sX2xhenlfcmVzZXRfdG9fbGF6eSIsImNhbWxfanNfZGVsZXRlIiwiY2FtbF9pbnRfb2Zfc3RyaW5nIiwiY2FtbF9saXN0X21vdW50X3BvaW50IiwicHJldiIsImNhbWxfbWFyc2hhbF9jb25zdGFudHMiLCJjYW1sX29ial9yYXdfZmllbGQiLCJjYW1sX2pzX2VxdWFscyIsImNhbWxfb2JqX2NvbXBhcmVfYW5kX3N3YXAiLCJiaWdzdHJpbmdfdG9fdHlwZWRfYXJyYXkiLCJjYW1sX2dyX2FyY19hdXgiLCJjeCIsImN5IiwicnkiLCJyeCIsInJvdCIsInhQb3MiLCJ5UG9zIiwieFBvc19wcmV2IiwieVBvc19wcmV2Iiwic3BhY2UiLCJkZWx0YSIsImNhbWxfZ3JfZmlsbF9hcmMiLCJjYW1sX2JhX3NsaWNlIiwibnVtX2luZHMiLCJzdWJfZGltcyIsImNhbWxfanNfd3JhcF9jYWxsYmFja191bnNhZmUiLCJjYW1sX2JhX2tpbmQiLCJjYW1sX2pzX2Z1bl9jYWxsIiwiY2FtbF9nY19tYWpvcl9zbGljZSIsIndvcmsiLCJjYW1sX2pzX3B1cmVfZXhwciIsImNvbXBhcmVfZGlnaXRzX25hdCIsImNhbWxfbWxfaW5wdXQiLCJjYW1sX2dyX3dhaXRfZXZlbnQiLCJfZXZsIiwiY2FtbF9ncl9zaWdpb19oYW5kbGVyIiwiY2FtbF9oYXNoX21peF9iaWdzdHJpbmciLCJjYW1sX3JlY29yZF9iYWNrdHJhY2UiLCJjYW1sX3VuaXhfY2xlYW51cCIsImNhbWxfc3lzX2NvbnN0X2JhY2tlbmRfdHlwZSIsImNhbWxfc3lzX2dldF9jb25maWciLCJjYW1sX29ial9pc19zaGFyZWQiLCJjYW1sX21sX291dF9jaGFubmVsc19saXN0IiwiY2FtbF9hc2luaF9mbG9hdCIsImNhbWxfcG9zX291dCIsImJpZ3N0cmluZ19vZl9hcnJheV9idWZmZXIiLCJhYiIsImNhbWxfbW9kIiwiY2FtbF9iYV9pbml0IiwiY2FtbF91bml4X2ZpbGVkZXNjcl9vZl9mZCIsInJlX3N0cmluZ19tYXRjaCIsIkJpZ1N0cmluZ1JlYWRlciIsImNhbWxfZ3JfZHVtcF9pbWFnZSIsImNhbWxfYmFfZ2V0X2dlbmVyaWMiLCJjYW1sX3VuaXhfc3RhcnR1cCIsImNhbWxfZ2V0X2V4Y2VwdGlvbl9iYWNrdHJhY2UiLCJjYW1sX2Zvcm1hdF9mbG9hdCIsInRvRml4ZWQiLCJkcCIsInByZWMiLCJjYW1sX21vdW50X2F1dG9sb2FkIiwiQmFzZV9pbnRfbWF0aF9pbnRfY2x6IiwiY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYSIsImNhbWxfYmxpdF9iaWdzdHJpbmdfdG9fYmlnc3RyaW5nIiwiY2FtbF9zdHJpbmdfbGVzc3RoYW4iLCJjYW1sX3N0cmluZ19ncmVhdGVydGhhbiIsImNhbWxfZGl2IiwiY2FtbF9vYmpfZHVwIiwiY2FtbF9lcGhlX2dldF9kYXRhX2NvcHkiLCJjYW1sX21lbXByb2Zfc3RhcnQiLCJyYXRlIiwic3RhY2tfc2l6ZSIsInRyYWNrZXIiLCJjYW1sX3N5c19nZXRfYXJndiIsImNhbWxfbWxfZG9tYWluX3NldF9uYW1lIiwiX25hbWUiLCJjYW1sX2pzX3RvX2Jvb2wiLCJjYW1sX2dyX2NyZWF0ZV9pbWFnZSIsImNhbWxfZXBoZV9nZXRfa2V5X2NvcHkiLCJjYW1sX2xlc3N0aGFuIiwiY2FtbF9yYXdfYmFja3RyYWNlX25leHRfc2xvdCIsImNhbWxfcmVnaXN0ZXJfZ2xvYmFsIiwibmFtZV9vcHQiLCJtdWx0X25hdCIsImxlbjMiLCJzcXVhcmVfbmF0IiwiY2FtbF9qc19mcm9tX2Zsb2F0IiwiY2FtbF9mbG9hdGFycmF5X2NyZWF0ZSIsImNhbWxfZ2Nfc3RhdCIsImNhbWxfZ2V0X21ham9yX2NyZWRpdCIsImNhbWxfc3lzX21vZGlmeV9hcmd2IiwiY2FtbF9tZXRob2RfY2FjaGUiLCJjYW1sX2dldF9wdWJsaWNfbWV0aG9kIiwiY2FjaGVpZCIsIm1ldGhzIiwibGkiLCJjYW1sX2pzX2dldF9jb25zb2xlIiwiY2FtbF9zeXNfdW5zYWZlX2dldGVudiIsImNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX2luIiwicmVmaWxsIiwiY2hhbm5lbCIsImJpZ3N0cmluZ19vZl90eXBlZF9hcnJheSIsImNhbWxfcm91bmRfZmxvYXQiLCJjYW1sX29qc19uZXdfYXJyIiwiRiIsImNvbXBsZW1lbnRfbmF0IiwiY2FtbF9kb21haW5fZGxzIiwiY2FtbF9kb21haW5fZGxzX3NldCIsImNhbWxfbGF6eV9yZWFkX3Jlc3VsdCIsImNhbWxfanNfcmVnZXhwcyIsImNhbWxfanNfaHRtbF9lc2NhcGUiLCJjYW1sX2JhX2RpbV8yIiwiY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfYXJndW1lbnRzIiwiY2FtbF9zaW5oX2Zsb2F0IiwiY2FtbF9sZGV4cF9mbG9hdCIsImNhbWxfZ3Jfc3RhdGVfc2V0IiwiY2FtbF9qc193cmFwX2NhbGxiYWNrX3N0cmljdCIsImFyaXR5IiwiY2FtbF9nY19taW5vcl93b3JkcyIsImNhbWxfZ2V0X2N1cnJlbnRfY2FsbHN0YWNrIiwibGFuZF9kaWdpdF9uYXQiLCJjYW1sX2ludDY0X21vZCIsImNhbWxfb2JqX3NldF90YWciLCJjYW1sX2ludDMyX2Jzd2FwIiwiY2FtbF9iYV9zZXRfMyIsImNhbWxfanNfaW5zdGFuY2VvZiIsImNhbWxfZ2V0X21ham9yX2J1Y2tldCIsImNhbWxfYmxpdF9iaWdzdHJpbmdfdG9fc3RyaW5nIiwic2V0X2RpZ2l0X25hdF9uYXRpdmUiLCJkaWdpdCIsIm50aF9kaWdpdF9uYXRfbmF0aXZlIiwiY2FtbF9zdHJpbmdfc2V0NjQiLCJjYW1sX2dyX3N0YXRlX2NyZWF0ZSIsImNhbnZhcyIsImNvbnRleHQiLCJjYW1sX2dyX2RyYXdfYXJjIiwiY2FtbF9iYV9tYXBfZmlsZSIsInZmZCIsInNoYXJlZCIsImNhbWxfYmFfbWFwX2ZpbGVfYnl0ZWNvZGUiLCJhcmduIiwiY2FtbF9iYV9jcmVhdGVfZnJvbSIsImRhdGExIiwiZGF0YTIiLCJqc3R5cCIsImNhbWxfdGFuaF9mbG9hdCIsIkJhc2VfaW50X21hdGhfaW50X2N0eiIsImNhbWxfZ3JfZHJhd19zdHIiLCJkeCIsImNhbWxfZ3JfZHJhd19zdHJpbmciLCJjYW1sX2dyX2RyYXdfY2hhciIsImNhbWxfdW5tb3VudCIsImNhbWxfaW5wdXRfdmFsdWVfZnJvbV9zdHJpbmciLCJjYW1sX21sX3Bvc19pbl82NCIsImNhbWxfZ3JfZHJhd19pbWFnZSIsImltYWdlIiwiY2FtbF9yZWdpc3Rlcl9jaGFubmVsX2Zvcl9zcGFjZXRpbWUiLCJfY2hhbm5lbCIsImNhbWxfc3RyaW5nX3NldCIsImNhbWxfc3lzX3JtZGlyIiwiY2FtbF91bml4X3N5bWxpbmsiLCJzcmNfcm9vdCIsImRzdF9yb290IiwiQmFzZV9pbnRfbWF0aF9pbnQ2NF9jdHoiLCJpc196ZXJvIiwibGFuZCIsInNtYWxsX2ludDY0IiwiY2FtbF9tbF9wb3Nfb3V0IiwiQmFzZV9jYW1sX2V4bl9pc19tb3N0X3JlY2VudF9leG4iLCJjYW1sX3NwYWNldGltZV9lbmFibGVkIiwiY2FtbF9ieXRlc19ub3RlcXVhbCIsImNhbWxfcnVudGltZV9wYXJhbWV0ZXJzIiwiY2FtbF9qc19vYmplY3QiLCJjYW1sX2JhX2NyZWF0ZSIsImRpbXNfbWwiLCJjYW1sX2dyX3JlbWVtYmVyX21vZGUiLCJCYXNlX2ludGVybmFsaGFzaF9nZXRfaGFzaF92YWx1ZSIsImNhbWxfZm1hX2Zsb2F0IiwiU1BMSVQiLCJNSU5fVkFMVUUiLCJFUFNJTE9OIiwiQyIsIkEiLCJCIiwibXVsdGlwbHkiLCJhdCIsImFoaSIsImFsbyIsImJoaSIsImJsbyIsImFkanVzdCIsInNjYWxlIiwieHMiLCJ5cyIsInpzIiwieHkiLCJ1IiwiY2FtbF9yZWNvbW1lbmRlZF9kb21haW5fY291bnQiLCJjYW1sX2Jzd2FwMTYiLCJjYW1sX21sX3NldF9iaW5hcnlfbW9kZSIsImNhbWxfZmluYWxfcmVnaXN0ZXIiLCJjYW1sX2dyX2RyYXdfcmVjdCIsImNhbWxfc3RyaW5nX2dldDE2IiwiY2FtbF9vdXRwdXRfdmFsdWUiLCJjYW1sX2JhX2dldF8zIiwiY2FtbF9lcGhlX2JsaXRfa2V5IiwiY2FtbF9pbml0aWFsX3RpbWUiLCJjYW1sX3N5c190aW1lIiwiY2FtbF9zeXNfdGltZV9pbmNsdWRlX2NoaWxkcmVuIiwiQmFzZV9jbGVhcl9jYW1sX2JhY2t0cmFjZV9wb3MiLCJjYW1sX2NoZWNrX2JvdW5kIiwiY2FtbF91bml4X2dldHB3dWlkIiwiY2FtbF9iYV90b190eXBlZF9hcnJheSIsImNhbWxfZG9tYWluX2Rsc19nZXQiLCJjYW1sX2J5dGVzX2dldDMyIiwiY2FtbF9mcmV4cF9mbG9hdCIsIm5lZyIsImNhbWxfc3RyaW5nX2dldDY0IiwiY2FtbF9qc19lcnJvcl9vcHRpb25fb2ZfZXhjZXB0aW9uIiwiY2FtbF9tbF9wb3Nfb3V0XzY0IiwiY2FtbF91bml4X2ZpbmRjbG9zZSIsImNhbWxfZ3JfY2xvc2Vfc3Vid2luZG93IiwiY2FtbF9mbG9hdGFycmF5X2JsaXQiLCJjYW1sX2dldF9taW5vcl9mcmVlIiwiY2FtbF9zZXRfc3RhdGljX2VudiIsImNhbWxfYmFfY2hhbmdlX2xheW91dCIsIkJhc2VfaGFzaF9kb3VibGUiLCJjYW1sX2pzX25ldyIsImNhbWxfZ3JfY3VycmVudF95IiwiY2FtbF9mb3JtYXRfaW50IiwianNvb19lZmZlY3Rfbm90X3N1cHBvcnRlZCIsImNhbWxfY29udGludWF0aW9uX3VzZV9hbmRfdXBkYXRlX2hhbmRsZXJfbm9leGMiLCJodmFsIiwiaGV4biIsImhlZmYiLCJjYW1sX29ial90cnVuY2F0ZSIsImNhbWxfanNfdG9fc3RyaW5nIiwiaXNfZGlnaXRfb2RkIiwiY2FtbF9ydW50aW1lX3ZhcmlhbnQiLCJjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9vdXQiLCJidWZmZXJlZCIsImNhbWxfYXJyYXlfY29uY2F0IiwiY2FtbF9ncl9vcGVuX2dyYXBoIiwiaW5mbyIsInNwZWNzIiwic3RhdHVzIiwid2luIiwiZG9jIiwidGl0bGUiLCJib2R5IiwiY2FtbF9tYWtlX2Zsb2F0X3ZlY3QiLCJjYW1sX2NicnRfZmxvYXQiLCJjYW1sX21lbXByb2Zfc3RvcCIsImNhbWxfZXZlbnRsb2dfcGF1c2UiLCJjYW1sX2dyZWF0ZXJlcXVhbCIsImNhbWxfZ2V0X2V4Y2VwdGlvbl9yYXdfYmFja3RyYWNlIiwiY2FtbF9sb2cxcF9mbG9hdCIsIm1zX3RvX25hbm8iLCJ0aW1lX25vd19uYW5vc2Vjb25kc19zaW5jZV91bml4X2Vwb2NoX29yX3plcm8iLCJtcyIsIm1zX2k2MyIsImNhbWxfbGF6eV9tYWtlX2ZvcndhcmQiLCJsb3JfZGlnaXRfbmF0IiwiY2FtbF9ncl9ibGl0X2ltYWdlIiwiaW0yIiwiY2FtbF9ncl93aW5kb3dfaWQiLCJjYW1sX2pzX29uX2llIiwidWEiLCJjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0IiwiY2FtbF9iYV9sYXlvdXQiLCJjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZSIsImNhbWxfYXJyYXlfc2V0IiwibmV3dmFsIiwiY2FtbF9hbGxvY19zdGFjayIsImh2IiwiaHgiLCJoZiIsImNhbWxfYnl0ZXNfZ3JlYXRlcmVxdWFsIiwic2V0X2RpZ2l0X25hdCIsImNhbWxfZ3JfZG9jX29mX3N0YXRlIiwiY2FtbF9tbF9vdXRwdXRfaW50IiwiY2FtbF9vYmpfd2l0aF90YWciLCJjYW1sX21sX2NoYW5uZWxfc2l6ZSIsImNhbWxfcmF3X2JhY2t0cmFjZV9zbG90IiwiY2FtbF9oZXhzdHJpbmdfb2ZfZmxvYXQiLCJzdHlsZSIsImV4cF9zaWduIiwic2lnbl9zdHIiLCJjc3QiLCJ4X3N0ciIsImNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX3N0cmljdCIsImNhbWxfdW5peF9yZWFkbGluayIsImNhbWxfYmFja3RyYWNlX3N0YXR1cyIsImNhbWxfc3lzX2FyZ3YiLCJjYW1sX2luc3RhbGxfc2lnbmFsX2hhbmRsZXIiLCJjYW1sX2JhX2ZpbGwiLCJjYW1sX21vZGZfZmxvYXQiLCJjYW1sX2djX2dldCIsImNhbWxfZmxvYXRfY29tcGFyZSIsImNhbWxfc3RyaW5nX3NldDMyIiwiY2FtbF9wYXJzZV9lbmdpbmUiLCJ0YWJsZXMiLCJlbnYiLCJFUlJDT0RFIiwibG9vcCIsInRlc3RzaGlmdCIsInNoaWZ0Iiwic2hpZnRfcmVjb3ZlciIsInJlZHVjZSIsIlJFQURfVE9LRU4iLCJSQUlTRV9QQVJTRV9FUlJPUiIsIkdST1dfU1RBQ0tTXzEiLCJHUk9XX1NUQUNLU18yIiwiQ09NUFVURV9TRU1BTlRJQ19BQ1RJT04iLCJDQUxMX0VSUk9SX0ZVTkNUSU9OIiwiZW52X3Nfc3RhY2siLCJlbnZfdl9zdGFjayIsImVudl9zeW1iX3N0YXJ0X3N0YWNrIiwiZW52X3N5bWJfZW5kX3N0YWNrIiwiZW52X3N0YWNrc2l6ZSIsImVudl9zdGFja2Jhc2UiLCJlbnZfY3Vycl9jaGFyIiwiZW52X2x2YWwiLCJlbnZfc3ltYl9zdGFydCIsImVudl9zeW1iX2VuZCIsImVudl9hc3AiLCJlbnZfcnVsZV9sZW4iLCJlbnZfcnVsZV9udW1iZXIiLCJlbnZfc3AiLCJlbnZfc3RhdGUiLCJlbnZfZXJyZmxhZyIsInRibF90cmFuc2xfY29uc3QiLCJ0YmxfdHJhbnNsX2Jsb2NrIiwidGJsX2xocyIsInRibF9sZW4iLCJ0YmxfZGVmcmVkIiwidGJsX2Rnb3RvIiwidGJsX3NpbmRleCIsInRibF9yaW5kZXgiLCJ0YmxfZ2luZGV4IiwidGJsX3RhYmxlc2l6ZSIsInRibF90YWJsZSIsInRibF9jaGVjayIsInRibF9uYW1lc19jb25zdCIsInRibF9uYW1lc19ibG9jayIsImxvZyIsInRva2VuX25hbWUiLCJuYW1lcyIsInByaW50X3Rva2VuIiwidG9rIiwidG9rZW4iLCJuMSIsIm4yIiwic3RhdGUxIiwic3AiLCJlcnJmbGFnIiwiYXNwIiwiY2FtbF9qc29vX2ZsYWdzX2VmZmVjdHMiLCJjYW1sX3VwZGF0ZV9kdW1teSIsImNhbWxfYXJyYXlfZmlsbCIsImNhbWxfc3lzX21rZGlyIiwiY2FtbF9zdHJpbmdfbm90ZXF1YWwiLCJjYW1sX2J5dGVzX2dyZWF0ZXJ0aGFuIiwiY2FtbF9ncl9tYWtlX2ltYWdlIiwiQmFzZV9pbnRfbWF0aF9pbnRfcG9wY291bnQiLCJjYW1sX21sX3NldF9jaGFubmVsX291dHB1dCIsImNhbWxfcmVhZF9maWxlX2NvbnRlbnQiLCJjYW1sX2pzX3RvX2Zsb2F0IiwiY2FtbF9zZXR1cF91bmNhdWdodF9leGNlcHRpb25faGFuZGxlciIsIm9yaWdpbiIsImV2ZW50Il0sInNvdXJjZXMiOlsiIiwiL2J1aWx0aW4vK2ludDY0LmpzIiwiL2J1aWx0aW4vK21sQnl0ZXMuanMiLCIvYnVpbHRpbi8rZmFpbC5qcyIsIi9idWlsdGluLytzdGRsaWIuanMiLCIvYnVpbHRpbi8rZm9ybWF0LmpzIiwiL2J1aWx0aW4vK2llZWVfNzU0LmpzIiwiL2J1aWx0aW4vK2VmZmVjdC5qcyIsIi9idWlsdGluLytmc19ub2RlLmpzIiwiL2J1aWx0aW4vK2ZzLmpzIiwiL2J1aWx0aW4vK3VuaXguanMiLCIvYnVpbHRpbi8rc3lzLmpzIiwiL2J1aWx0aW4vK2ZzX2Zha2UuanMiLCIvYnVpbHRpbi8rbmF0LmpzIiwiL2J1aWx0aW4vK2dyYXBoaWNzLmpzIiwiL2J1aWx0aW4vK21hcnNoYWwuanMiLCIvYnVpbHRpbi8raW8uanMiLCIvYnVpbHRpbi8rZ2MuanMiLCIvYnVpbHRpbi8rYmlnYXJyYXkuanMiLCIvYnVpbHRpbi8ranNsaWIuanMiLCIvYnVpbHRpbi8raW50cy5qcyIsIi9idWlsdGluLytoYXNoLmpzIiwiL1VzZXJzL2F6YXQvLm9wYW0vNC4xNC4wL2xpYi9iYXNlL2Jhc2VfaW50ZXJuYWxoYXNoX3R5cGVzL3J1bnRpbWUuanMiLCIvYnVpbHRpbi8rcGFyc2luZy5qcyIsIi9idWlsdGluLytvYmouanMiLCIvYnVpbHRpbi8rZG9tYWluLmpzIiwiL2J1aWx0aW4vK2NvbXBhcmUuanMiLCIvYnVpbHRpbi8ranNsaWJfanNfb2Zfb2NhbWwuanMiLCIvYnVpbHRpbi8rYmlnc3RyaW5nLmpzIiwiL2J1aWx0aW4vK21kNS5qcyIsIi9idWlsdGluLytiYWNrdHJhY2UuanMiLCIvYnVpbHRpbi8rc3RyLmpzIiwiL2J1aWx0aW4vK2xleGluZy5qcyIsIi9idWlsdGluLythcnJheS5qcyIsIi9Vc2Vycy9hemF0Ly5vcGFtLzQuMTQuMC9saWIvYmFzZS9ydW50aW1lLmpzIiwiL2J1aWx0aW4vK3N5bmMuanMiLCIvYnVpbHRpbi8rd2Vhay5qcyIsIi9idWlsdGluLytwcm5nLmpzIiwiL2J1aWx0aW4vK2JpZ3N0cmluZy1jc3RydWN0LmpzIiwiL1VzZXJzL2F6YXQvLm9wYW0vNC4xNC4wL2xpYi90aW1lX25vdy9ydW50aW1lLmpzIl0sIm1hcHBpbmdzIjoiOztBQUNBLENBQUM7SUFBVUE7SUFDVCxPQUFPQzs7OztLQUNMQztPQUNFO1FBQ0M7VUFBc0JGLDhDQUVoQkc7UUFDSEM7SUFFUixTQUFTRDtNQUNQLElBQUlFLE9BQVNILFFBQVFJO01BQ3JCLG9CQUFvQkQ7TUFDcEIsT0FBT0wsb0JBQ1QsQ0FiRDtHQWNDQTs7O0lDMk5GLFNBQVNPLG1CQUFtQkMsR0FBSyxTQUFRLFVBQVk7SUN6THJELFNBQVNDLGdCQUFnQkMsRUFBR0M7TUFDMUIsR0FBR0QsT0FBUTtNQUNYLEdBQUlDLFNBQVUsT0FBUSxTQUFTRDtNQUMvQixJQUFNLEtBQVE7TUFDZDtPQUFRLENBQ04sR0FBSUEsTUFBTyxLQUFLQztRQUNoQjtRQUNBLEdBQUlELE9BQVEsT0FBT0U7UUFDbkIsS0FBS0Q7UUFDTDtRQUNBLEdBQUlFLE9BQVEsYUFNaEI7SUQ3Q0EsSUFBSUMsa0JBQW9CO0lFQXhCLFNBQVNFLG9CQUFxQkMsS0FBTyxNQUFNQSxHQUFLO0lDZ0ZoRCxJQUFJQztJRHhDSixTQUFTQztNQUNQLG9CQUFvQkQsa0NBQ3RCO0lGdENBLFNBQVNFLFFBQVNDLEdBQUdDLEdBQUdDO01BQ3RCLFVBQVVGLGNBQ1YsVUFBVUMsY0FDVixVQUFVQyxXQUNaO0lBQ0E7SUFDQTs7ZUFDRSxXQUFXSCxRQUFRbEIsUUFBUUEsUUFBUUEsUUFEWjtJQUl6Qjs7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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1UiLCJzb3VyY2VzQ29udGVudCI6W251bGwsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X29mZnNldFxudmFyIGNhbWxfaW50NjRfb2Zmc2V0ID0gTWF0aC5wb3coMiwgLTI0KTtcblxuLy9Qcm92aWRlczogTWxJbnQ2NFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZmZzZXQsIGNhbWxfcmFpc2VfemVyb19kaXZpZGVcbmZ1bmN0aW9uIE1sSW50NjQgKGxvLG1pLGhpKSB7XG4gIHRoaXMubG8gPSBsbyAmIDB4ZmZmZmZmO1xuICB0aGlzLm1pID0gbWkgJiAweGZmZmZmZjtcbiAgdGhpcy5oaSA9IGhpICYgMHhmZmZmO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuY2FtbF9jdXN0b20gPSBcIl9qXCJcbk1sSW50NjQucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCh0aGlzLmxvLHRoaXMubWksdGhpcy5oaSk7XG59XG5cbk1sSW50NjQucHJvdG90eXBlLnVjb21wYXJlID0gZnVuY3Rpb24gKHgpIHtcbiAgaWYgKHRoaXMuaGkgPiB4LmhpKSByZXR1cm4gMTtcbiAgaWYgKHRoaXMuaGkgPCB4LmhpKSByZXR1cm4gLTE7XG4gIGlmICh0aGlzLm1pID4geC5taSkgcmV0dXJuIDE7XG4gIGlmICh0aGlzLm1pIDwgeC5taSkgcmV0dXJuIC0xO1xuICBpZiAodGhpcy5sbyA+IHgubG8pIHJldHVybiAxO1xuICBpZiAodGhpcy5sbyA8IHgubG8pIHJldHVybiAtMTtcbiAgcmV0dXJuIDA7XG59XG5NbEludDY0LnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gKHgpIHtcbiAgdmFyIGhpID0gdGhpcy5oaSA8PCAxNjtcbiAgdmFyIHhoaSA9IHguaGkgPDwgMTY7XG4gIGlmIChoaSA+IHhoaSkgcmV0dXJuIDE7XG4gIGlmIChoaSA8IHhoaSkgcmV0dXJuIC0xO1xuICBpZiAodGhpcy5taSA+IHgubWkpIHJldHVybiAxO1xuICBpZiAodGhpcy5taSA8IHgubWkpIHJldHVybiAtMTtcbiAgaWYgKHRoaXMubG8gPiB4LmxvKSByZXR1cm4gMTtcbiAgaWYgKHRoaXMubG8gPCB4LmxvKSByZXR1cm4gLTE7XG4gIHJldHVybiAwO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbG8gPSAtIHRoaXMubG87XG4gIHZhciBtaSA9IC0gdGhpcy5taSArIChsbyA+PiAyNCk7XG4gIHZhciBoaSA9IC0gdGhpcy5oaSArIChtaSA+PiAyNCk7XG4gIHJldHVybiBuZXcgTWxJbnQ2NChsbywgbWksIGhpKTtcbn1cbk1sSW50NjQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh4KSB7XG4gIHZhciBsbyA9IHRoaXMubG8gKyB4LmxvO1xuICB2YXIgbWkgPSB0aGlzLm1pICsgeC5taSArIChsbyA+PiAyNCk7XG4gIHZhciBoaSA9IHRoaXMuaGkgKyB4LmhpICsgKG1pID4+IDI0KTtcbiAgcmV0dXJuIG5ldyBNbEludDY0KGxvLCBtaSwgaGkpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24gKHgpIHtcbiAgdmFyIGxvID0gdGhpcy5sbyAtIHgubG87XG4gIHZhciBtaSA9IHRoaXMubWkgLSB4Lm1pICsgKGxvID4+IDI0KTtcbiAgdmFyIGhpID0gdGhpcy5oaSAtIHguaGkgKyAobWkgPj4gMjQpO1xuICByZXR1cm4gbmV3IE1sSW50NjQobG8sIG1pLCBoaSk7XG59XG5NbEludDY0LnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiAoeCkge1xuICB2YXIgbG8gPSB0aGlzLmxvICogeC5sbztcbiAgdmFyIG1pID0gKChsbyAqIGNhbWxfaW50NjRfb2Zmc2V0KSB8IDApICsgdGhpcy5taSAqIHgubG8gKyB0aGlzLmxvICogeC5taTtcbiAgdmFyIGhpID0gKChtaSAqIGNhbWxfaW50NjRfb2Zmc2V0KSB8IDApICsgdGhpcy5oaSAqIHgubG8gKyB0aGlzLm1pICogeC5taSArIHRoaXMubG8gKiB4LmhpO1xuICByZXR1cm4gbmV3IE1sSW50NjQobG8sIG1pLCBoaSk7XG59XG5NbEludDY0LnByb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAodGhpcy5sb3x0aGlzLm1pfHRoaXMuaGkpID09IDA7XG59XG5NbEludDY0LnByb3RvdHlwZS5pc05lZyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICh0aGlzLmhpIDw8IDE2KSA8IDA7XG59XG5NbEludDY0LnByb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiAoeCkge1xuICByZXR1cm4gbmV3IE1sSW50NjQodGhpcy5sbyAmIHgubG8sIHRoaXMubWkgJiB4Lm1pLCB0aGlzLmhpICYgeC5oaSk7XG59XG5NbEludDY0LnByb3RvdHlwZS5vciA9IGZ1bmN0aW9uICh4KSB7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCh0aGlzLmxvfHgubG8sIHRoaXMubWl8eC5taSwgdGhpcy5oaXx4LmhpKTtcbn1cbk1sSW50NjQucHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uICh4KSB7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCh0aGlzLmxvXngubG8sIHRoaXMubWleeC5taSwgdGhpcy5oaV54LmhpKTtcbn1cbk1sSW50NjQucHJvdG90eXBlLnNoaWZ0X2xlZnQgPSBmdW5jdGlvbiAocykge1xuICBzID0gcyAmIDYzO1xuICBpZiAocyA9PSAwKSByZXR1cm4gdGhpcztcbiAgaWYgKHMgPCAyNCkge1xuICAgIHJldHVybiBuZXcgTWxJbnQ2NCAodGhpcy5sbyA8PCBzLFxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMubWkgPDwgcykgfCAodGhpcy5sbyA+PiAoMjQgLSBzKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5oaSA8PCBzKSB8ICh0aGlzLm1pID4+ICgyNCAtIHMpKSk7XG4gIH1cbiAgaWYgKHMgPCA0OClcbiAgICByZXR1cm4gbmV3IE1sSW50NjQgKDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvIDw8IChzIC0gMjQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMubWkgPDwgKHMgLSAyNCkpIHwgKHRoaXMubG8gPj4gKDQ4IC0gcykpKTtcbiAgcmV0dXJuIG5ldyBNbEludDY0KDAsIDAsIHRoaXMubG8gPDwgKHMgLSA0OCkpXG59XG5NbEludDY0LnByb3RvdHlwZS5zaGlmdF9yaWdodF91bnNpZ25lZCA9IGZ1bmN0aW9uIChzKSB7XG4gIHMgPSBzICYgNjM7XG4gIGlmIChzID09IDApIHJldHVybiB0aGlzO1xuICBpZiAocyA8IDI0KVxuICAgIHJldHVybiBuZXcgTWxJbnQ2NCAoXG4gICAgICAodGhpcy5sbyA+PiBzKSB8ICh0aGlzLm1pIDw8ICgyNCAtIHMpKSxcbiAgICAgICh0aGlzLm1pID4+IHMpIHwgKHRoaXMuaGkgPDwgKDI0IC0gcykpLFxuICAgICAgKHRoaXMuaGkgPj4gcykpO1xuICBpZiAocyA8IDQ4KVxuICAgIHJldHVybiBuZXcgTWxJbnQ2NCAoXG4gICAgICAodGhpcy5taSA+PiAocyAtIDI0KSkgfCAodGhpcy5oaSA8PCAoNDggLSBzKSksXG4gICAgICAodGhpcy5oaSA+PiAocyAtIDI0KSksXG4gICAgICAwKTtcbiAgcmV0dXJuIG5ldyBNbEludDY0ICh0aGlzLmhpID4+IChzIC0gNDgpLCAwLCAwKTtcbn1cbk1sSW50NjQucHJvdG90eXBlLnNoaWZ0X3JpZ2h0ID0gZnVuY3Rpb24gKHMpIHtcbiAgcyA9IHMgJiA2MztcbiAgaWYgKHMgPT0gMCkgcmV0dXJuIHRoaXM7XG4gIHZhciBoID0gKHRoaXMuaGkgPDwgMTYpID4+IDE2O1xuICBpZiAocyA8IDI0KVxuICAgIHJldHVybiBuZXcgTWxJbnQ2NCAoXG4gICAgICAodGhpcy5sbyA+PiBzKSB8ICh0aGlzLm1pIDw8ICgyNCAtIHMpKSxcbiAgICAgICh0aGlzLm1pID4+IHMpIHwgKGggPDwgKDI0IC0gcykpLFxuICAgICAgKCh0aGlzLmhpIDw8IDE2KSA+PiBzKSA+Pj4gMTYpO1xuICB2YXIgc2lnbiA9ICh0aGlzLmhpIDw8IDE2KSA+PiAzMTtcbiAgaWYgKHMgPCA0OClcbiAgICByZXR1cm4gbmV3IE1sSW50NjQgKFxuICAgICAgKHRoaXMubWkgPj4gKHMgLSAyNCkpIHwgKHRoaXMuaGkgPDwgKDQ4IC0gcykpLFxuICAgICAgKHRoaXMuaGkgPDwgMTYpID4+IChzIC0gMjQpID4+IDE2LFxuICAgICAgc2lnbiAmIDB4ZmZmZik7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCAoKHRoaXMuaGkgPDwgMTYpID4+IChzIC0gMzIpLCBzaWduLCBzaWduKTtcbn1cbk1sSW50NjQucHJvdG90eXBlLmxzbDEgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuaGkgPSAodGhpcy5oaSA8PCAxKSB8ICh0aGlzLm1pID4+IDIzKTtcbiAgdGhpcy5taSA9ICgodGhpcy5taSA8PCAxKSB8ICh0aGlzLmxvID4+IDIzKSkgJiAweGZmZmZmZjtcbiAgdGhpcy5sbyA9ICh0aGlzLmxvIDw8IDEpICYgMHhmZmZmZmY7XG59XG5NbEludDY0LnByb3RvdHlwZS5sc3IxID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmxvID0gKCh0aGlzLmxvID4+PiAxKSB8ICh0aGlzLm1pIDw8IDIzKSkgJiAweGZmZmZmZjtcbiAgdGhpcy5taSA9ICgodGhpcy5taSA+Pj4gMSkgfCAodGhpcy5oaSA8PCAyMykpICYgMHhmZmZmZmY7XG4gIHRoaXMuaGkgPSB0aGlzLmhpID4+PiAxO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUudWRpdm1vZCA9IGZ1bmN0aW9uICh4KSB7XG4gIHZhciBvZmZzZXQgPSAwO1xuICB2YXIgbW9kdWx1cyA9IHRoaXMuY29weSgpO1xuICB2YXIgZGl2aXNvciA9IHguY29weSgpO1xuICB2YXIgcXVvdGllbnQgPSBuZXcgTWxJbnQ2NCgwLDAsMCk7XG4gIHdoaWxlIChtb2R1bHVzLnVjb21wYXJlKGRpdmlzb3IpID4gMCkge1xuICAgIG9mZnNldCsrO1xuICAgIGRpdmlzb3IubHNsMSgpO1xuICB9XG4gIHdoaWxlIChvZmZzZXQgPj0gMCkge1xuICAgIG9mZnNldCAtLTtcbiAgICBxdW90aWVudC5sc2wxKCk7XG4gICAgaWYgKG1vZHVsdXMudWNvbXBhcmUoZGl2aXNvcikgPj0gMCkge1xuICAgICAgcXVvdGllbnQubG8gKys7XG4gICAgICBtb2R1bHVzID0gbW9kdWx1cy5zdWIoZGl2aXNvcik7XG4gICAgfVxuICAgIGRpdmlzb3IubHNyMSgpO1xuICB9XG4gIHJldHVybiB7IHF1b3RpZW50IDogcXVvdGllbnQsIG1vZHVsdXMgOiBtb2R1bHVzIH07XG59XG5NbEludDY0LnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbiAoeSlcbntcbiAgdmFyIHggPSB0aGlzO1xuICBpZiAoeS5pc1plcm8oKSkgY2FtbF9yYWlzZV96ZXJvX2RpdmlkZSAoKTtcbiAgdmFyIHNpZ24gPSB4LmhpIF4geS5oaTtcbiAgaWYgKHguaGkgJiAweDgwMDApIHggPSB4Lm5lZygpO1xuICBpZiAoeS5oaSAmIDB4ODAwMCkgeSA9IHkubmVnKCk7XG4gIHZhciBxID0geC51ZGl2bW9kKHkpLnF1b3RpZW50O1xuICBpZiAoc2lnbiAmIDB4ODAwMCkgcSA9IHEubmVnKCk7XG4gIHJldHVybiBxO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUubW9kID0gZnVuY3Rpb24gKHkpXG57XG4gIHZhciB4ID0gdGhpcztcbiAgaWYgKHkuaXNaZXJvKCkpIGNhbWxfcmFpc2VfemVyb19kaXZpZGUgKCk7XG4gIHZhciBzaWduID0geC5oaTtcbiAgaWYgKHguaGkgJiAweDgwMDApIHggPSB4Lm5lZygpO1xuICBpZiAoeS5oaSAmIDB4ODAwMCkgeSA9IHkubmVnKCk7XG4gIHZhciByID0geC51ZGl2bW9kKHkpLm1vZHVsdXM7XG4gIGlmIChzaWduICYgMHg4MDAwKSByID0gci5uZWcoKTtcbiAgcmV0dXJuIHI7XG59XG5NbEludDY0LnByb3RvdHlwZS50b0ludCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubG8gfCAodGhpcy5taSA8PCAyNCk7XG59XG5NbEludDY0LnByb3RvdHlwZS50b0Zsb2F0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gKCh0aGlzLmhpIDw8IDE2KSAqIE1hdGgucG93KDIsIDMyKSArIHRoaXMubWkgKiBNYXRoLnBvdygyLCAyNCkpICsgdGhpcy5sbztcbn1cbk1sSW50NjQucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBbdGhpcy5oaSA+PiA4LFxuICAgICAgICAgIHRoaXMuaGkgJiAweGZmLFxuICAgICAgICAgIHRoaXMubWkgPj4gMTYsXG4gICAgICAgICAgKHRoaXMubWkgPj4gOCkgJiAweGZmLFxuICAgICAgICAgIHRoaXMubWkgJiAweGZmLFxuICAgICAgICAgIHRoaXMubG8gPj4gMTYsXG4gICAgICAgICAgKHRoaXMubG8gPj4gOCkgJiAweGZmLFxuICAgICAgICAgIHRoaXMubG8gJiAweGZmXTtcbn1cbk1sSW50NjQucHJvdG90eXBlLmxvMzIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmxvIHwgKCh0aGlzLm1pICYgMHhmZikgPDwgMjQpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuaGkzMiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICgodGhpcy5taSA+Pj4gOCkgJiAweGZmZmYpIHwgKHRoaXMuaGkgPDwgMTYpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3VsdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF91bHQoeCx5KSB7IHJldHVybiB4LnVjb21wYXJlKHkpIDwgMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2NvbXBhcmUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfY29tcGFyZSh4LHksIHRvdGFsKSB7IHJldHVybiB4LmNvbXBhcmUoeSkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X25lZyBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9uZWcgKHgpIHsgcmV0dXJuIHgubmVnKCkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2FkZCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9hZGQgKHgsIHkpIHsgcmV0dXJuIHguYWRkKHkpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9zdWIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfc3ViICh4LCB5KSB7IHJldHVybiB4LnN1Yih5KSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfbXVsIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mZnNldFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9tdWwoeCx5KSB7IHJldHVybiB4Lm11bCh5KSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfaXNfemVybyBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9pc196ZXJvKHgpIHsgcmV0dXJuICt4LmlzWmVybygpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfaXNfbmVnYXRpdmUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfaXNfbmVnYXRpdmUoeCkgeyByZXR1cm4gK3guaXNOZWcoKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2FuZCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9hbmQgKHgsIHkpIHsgcmV0dXJuIHguYW5kKHkpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfb3IgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfb3IgKHgsIHkpIHsgcmV0dXJuIHgub3IoeSk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF94b3IgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfeG9yICh4LCB5KSB7IHJldHVybiB4Lnhvcih5KSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfc2hpZnRfbGVmdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9zaGlmdF9sZWZ0ICh4LCBzKSB7IHJldHVybiB4LnNoaWZ0X2xlZnQocykgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkICh4LCBzKSB7IHJldHVybiB4LnNoaWZ0X3JpZ2h0X3Vuc2lnbmVkKHMpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9zaGlmdF9yaWdodCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9zaGlmdF9yaWdodCAoeCwgcykgeyByZXR1cm4geC5zaGlmdF9yaWdodChzKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfZGl2IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2RpdiAoeCwgeSkgeyByZXR1cm4geC5kaXYoeSkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X21vZCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9tb2QgKHgsIHkpIHsgcmV0dXJuIHgubW9kKHkpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9vZl9pbnQzMiBjb25zdFxuLy9SZXF1aXJlczogTWxJbnQ2NFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9vZl9pbnQzMiAoeCkge1xuICByZXR1cm4gbmV3IE1sSW50NjQoeCAmIDB4ZmZmZmZmLCAoeCA+PiAyNCkgJiAweGZmZmZmZiwgKHggPj4gMzEpICYgMHhmZmZmKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3RvX2ludDMyIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3RvX2ludDMyICh4KSB7IHJldHVybiB4LnRvSW50KCkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3RvX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3RvX2Zsb2F0ICh4KSB7IHJldHVybiB4LnRvRmxvYXQgKCkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X29mX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mZnNldCwgTWxJbnQ2NFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9vZl9mbG9hdCAoeCkge1xuICBpZiAoeCA8IDApIHggPSBNYXRoLmNlaWwoeCk7XG4gIHJldHVybiBuZXcgTWxJbnQ2NChcbiAgICB4ICYgMHhmZmZmZmYsXG4gICAgTWF0aC5mbG9vcih4ICogY2FtbF9pbnQ2NF9vZmZzZXQpICYgMHhmZmZmZmYsXG4gICAgTWF0aC5mbG9vcih4ICogY2FtbF9pbnQ2NF9vZmZzZXQgKiBjYW1sX2ludDY0X29mZnNldCkgJiAweGZmZmYpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2Zvcm1hdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9wYXJzZV9mb3JtYXQsIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmdcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfaXNfbmVnYXRpdmUsIGNhbWxfaW50NjRfbmVnXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2ludDMyLCBjYW1sX2ludDY0X3RvX2ludDMyXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2lzX3plcm8sIGNhbWxfc3RyX3JlcGVhdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9mb3JtYXQgKGZtdCwgeCkge1xuICB2YXIgZiA9IGNhbWxfcGFyc2VfZm9ybWF0KGZtdCk7XG4gIGlmIChmLnNpZ25lZGNvbnYgJiYgY2FtbF9pbnQ2NF9pc19uZWdhdGl2ZSh4KSkge1xuICAgIGYuc2lnbiA9IC0xOyB4ID0gY2FtbF9pbnQ2NF9uZWcoeCk7XG4gIH1cbiAgdmFyIGJ1ZmZlciA9IFwiXCI7XG4gIHZhciB3YmFzZSA9IGNhbWxfaW50NjRfb2ZfaW50MzIoZi5iYXNlKTtcbiAgdmFyIGN2dGJsID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG4gIGRvIHtcbiAgICB2YXIgcCA9IHgudWRpdm1vZCh3YmFzZSk7XG4gICAgeCA9IHAucXVvdGllbnQ7XG4gICAgYnVmZmVyID0gY3Z0YmwuY2hhckF0KGNhbWxfaW50NjRfdG9faW50MzIocC5tb2R1bHVzKSkgKyBidWZmZXI7XG4gIH0gd2hpbGUgKCEgY2FtbF9pbnQ2NF9pc196ZXJvKHgpKTtcbiAgaWYgKGYucHJlYyA+PSAwKSB7XG4gICAgZi5maWxsZXIgPSAnICc7XG4gICAgdmFyIG4gPSBmLnByZWMgLSBidWZmZXIubGVuZ3RoO1xuICAgIGlmIChuID4gMCkgYnVmZmVyID0gY2FtbF9zdHJfcmVwZWF0IChuLCAnMCcpICsgYnVmZmVyO1xuICB9XG4gIHJldHVybiBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nKGYsIGJ1ZmZlcik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2UsIGNhbWxfZmFpbHdpdGgsIGNhbWxfcGFyc2VfZGlnaXRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfaW50MzIsIGNhbWxfaW50NjRfdWx0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2FkZCwgY2FtbF9pbnQ2NF9tdWwsIGNhbWxfaW50NjRfbmVnXG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGgsY2FtbF9zdHJpbmdfdW5zYWZlX2dldCwgTWxJbnQ2NFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9vZl9zdHJpbmcocykge1xuICB2YXIgciA9IGNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZSAocyk7XG4gIHZhciBpID0gclswXSwgc2lnbiA9IHJbMV0sIGJhc2UgPSByWzJdO1xuICB2YXIgYmFzZTY0ID0gY2FtbF9pbnQ2NF9vZl9pbnQzMihiYXNlKTtcbiAgdmFyIHRocmVzaG9sZCA9XG4gICAgICBuZXcgTWxJbnQ2NCgweGZmZmZmZiwgMHhmZmZmZmZmLCAweGZmZmYpLnVkaXZtb2QoYmFzZTY0KS5xdW90aWVudDtcbiAgdmFyIGMgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkpO1xuICB2YXIgZCA9IGNhbWxfcGFyc2VfZGlnaXQoYyk7XG4gIGlmIChkIDwgMCB8fCBkID49IGJhc2UpIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICB2YXIgcmVzID0gY2FtbF9pbnQ2NF9vZl9pbnQzMihkKTtcbiAgZm9yICg7Oykge1xuICAgIGkrKztcbiAgICBjID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpKTtcbiAgICBpZiAoYyA9PSA5NSkgY29udGludWU7XG4gICAgZCA9IGNhbWxfcGFyc2VfZGlnaXQoYyk7XG4gICAgaWYgKGQgPCAwIHx8IGQgPj0gYmFzZSkgYnJlYWs7XG4gICAgLyogRGV0ZWN0IG92ZXJmbG93IGluIG11bHRpcGxpY2F0aW9uIGJhc2UgKiByZXMgKi9cbiAgICBpZiAoY2FtbF9pbnQ2NF91bHQodGhyZXNob2xkLCByZXMpKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgICBkID0gY2FtbF9pbnQ2NF9vZl9pbnQzMihkKTtcbiAgICByZXMgPSBjYW1sX2ludDY0X2FkZChjYW1sX2ludDY0X211bChiYXNlNjQsIHJlcyksIGQpO1xuICAgIC8qIERldGVjdCBvdmVyZmxvdyBpbiBhZGRpdGlvbiAoYmFzZSAqIHJlcykgKyBkICovXG4gICAgaWYgKGNhbWxfaW50NjRfdWx0KHJlcywgZCkpIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICB9XG4gIGlmIChpICE9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSkgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIGlmIChiYXNlID09IDEwICYmIGNhbWxfaW50NjRfdWx0KG5ldyBNbEludDY0KDAsIDAsIDB4ODAwMCksIHJlcykpXG4gICAgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIGlmIChzaWduIDwgMCkgcmVzID0gY2FtbF9pbnQ2NF9uZWcocmVzKTtcbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkgY29uc3Rcbi8vUmVxdWlyZXM6IE1sSW50NjRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpKGxvLCBtaSwgaGkpe1xuICByZXR1cm4gbmV3IE1sSW50NjQobG8sIG1pLCBoaSlcbn1cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfY3JlYXRlX2xvX2hpIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEludDY0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2NyZWF0ZV9sb19oaShsbywgaGkpe1xuICByZXR1cm4gbmV3IE1sSW50NjQgKFxuICAgIGxvICYgMHhmZmZmZmYsXG4gICAgKChsbyA+Pj4gMjQpICYgMHhmZikgfCAoKGhpICYgMHhmZmZmKSA8PCA4KSxcbiAgICAoaGkgPj4+IDE2KSAmIDB4ZmZmZik7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2xvMzIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfbG8zMih2KXsgcmV0dXJuIHYubG8zMigpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9oaTMyIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2hpMzIodil7IHJldHVybiB2LmhpMzIoKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfb2ZfYnl0ZXMgY29uc3Rcbi8vUmVxdWlyZXM6IE1sSW50NjRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfb2ZfYnl0ZXMoYSkge1xuICByZXR1cm4gbmV3IE1sSW50NjQoYVs3XSA8PCAwIHwgKGFbNl0gPDwgOCkgfCAoYVs1XSA8PCAxNiksXG4gICAgICAgICAgICAgICAgICAgICBhWzRdIDw8IDAgfCAoYVszXSA8PCA4KSB8IChhWzJdIDw8IDE2KSxcbiAgICAgICAgICAgICAgICAgICAgIGFbMV0gPDwgMCB8IChhWzBdIDw8IDgpKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfdG9fYnl0ZXMgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfdG9fYnl0ZXMoeCkgeyByZXR1cm4geC50b0FycmF5KCkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2hhc2ggY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfaGFzaCh2KXtcbiAgcmV0dXJuICh2LmxvMzIoKSkgXiAodi5oaTMyKCkpXG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAtMjAxNCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLyBBbiBPQ2FtbCBzdHJpbmcgaXMgYW4gb2JqZWN0IHdpdGggdGhyZWUgZmllbGRzOlxuLy8gLSB0YWcgJ3QnXG4vLyAtIGxlbmd0aCAnbCdcbi8vIC0gY29udGVudHMgJ2MnXG4vL1xuLy8gVGhlIGNvbnRlbnRzIG9mIHRoZSBzdHJpbmcgY2FuIGJlIGVpdGhlciBhIEphdmFTY3JpcHQgYXJyYXkgb3Jcbi8vIGEgSmF2YVNjcmlwdCBzdHJpbmcuIFRoZSBsZW5ndGggb2YgdGhpcyBzdHJpbmcgY2FuIGJlIGxlc3MgdGhhbiB0aGVcbi8vIGxlbmd0aCBvZiB0aGUgT0NhbWwgc3RyaW5nLiBJbiB0aGlzIGNhc2UsIHJlbWFpbmluZyBieXRlcyBhcmVcbi8vIGFzc3VtZWQgdG8gYmUgemVyb2VzLiBBcnJheXMgYXJlIG11dGFibGUgYnV0IGNvbnN1bWVzIG1vcmUgbWVtb3J5XG4vLyB0aGFuIHN0cmluZ3MuIEEgY29tbW9uIHBhdHRlcm4gaXMgdG8gc3RhcnQgZnJvbSBhbiBlbXB0eSBzdHJpbmcgYW5kXG4vLyBwcm9ncmVzc2l2ZWx5IGZpbGwgaXQgZnJvbSB0aGUgc3RhcnQuIFBhcnRpYWwgc3RyaW5ncyBtYWtlcyBpdFxuLy8gcG9zc2libGUgdG8gaW1wbGVtZW50IHRoaXMgZWZmaWNpZW50bHkuXG4vL1xuLy8gV2hlbiBjb252ZXJ0aW5nIHRvIGFuZCBmcm9tIFVURi0xNiwgd2Uga2VlcCB0cmFjayBvZiB3aGV0aGVyIHRoZVxuLy8gc3RyaW5nIGlzIGNvbXBvc2VkIG9ubHkgb2YgQVNDSUkgY2hhcmFjdGVycyAoaW4gd2hpY2ggY2FzZSwgbm9cbi8vIGNvbnZlcnNpb24gbmVlZHMgdG8gYmUgcGVyZm9ybWVkKSBvciBub3QuXG4vL1xuLy8gVGhlIHN0cmluZyB0YWcgY2FuIHRodXMgdGFrZSB0aGUgZm9sbG93aW5nIHZhbHVlczpcbi8vICAgZnVsbCBzdHJpbmcgICAgIEJZVEUgfCBVTktOT1dOOiAgICAgIDBcbi8vICAgICAgICAgICAgICAgICAgIEJZVEUgfCBBU0NJSTogICAgICAgIDlcbi8vICAgICAgICAgICAgICAgICAgIEJZVEUgfCBOT1RfQVNDSUk6ICAgIDhcbi8vICAgc3RyaW5nIHByZWZpeCAgIFBBUlRJQUw6ICAgICAgICAgICAgIDJcbi8vICAgYXJyYXkgICAgICAgICAgIEFSUkFZOiAgICAgICAgICAgICAgIDRcbi8vXG4vLyBPbmUgY2FuIHVzZSBiaXQgbWFza2luZyB0byBkaXNjcmltaW5hdGUgdGhlc2UgZGlmZmVyZW50IGNhc2VzOlxuLy8gICBrbm93bl9lbmNvZGluZyh4KSA9IHgmOFxuLy8gICBpc19hc2NpaSh4KSA9ICAgICAgIHgmMVxuLy8gICBraW5kKHgpID0gICAgICAgICAgIHgmNlxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cl9yZXBlYXRcbmZ1bmN0aW9uIGNhbWxfc3RyX3JlcGVhdChuLCBzKSB7XG4gIGlmKG4gPT0gMCkgcmV0dXJuIFwiXCI7XG4gIGlmIChzLnJlcGVhdCkge3JldHVybiBzLnJlcGVhdChuKTt9IC8vIEVDTUFzY3JpcHQgNiBhbmQgRmlyZWZveCAyNCtcbiAgdmFyIHIgPSBcIlwiLCBsID0gMDtcbiAgZm9yKDs7KSB7XG4gICAgaWYgKG4gJiAxKSByICs9IHM7XG4gICAgbiA+Pj0gMTtcbiAgICBpZiAobiA9PSAwKSByZXR1cm4gcjtcbiAgICBzICs9IHM7XG4gICAgbCsrO1xuICAgIGlmIChsID09IDkpIHtcbiAgICAgIHMuc2xpY2UoMCwxKTsgLy8gZmxhdHRlbiB0aGUgc3RyaW5nXG4gICAgICAvLyB0aGVuLCB0aGUgZmxhdHRlbmluZyBvZiB0aGUgd2hvbGUgc3RyaW5nIHdpbGwgYmUgZmFzdGVyLFxuICAgICAgLy8gYXMgaXQgd2lsbCBiZSBjb21wb3NlZCBvZiBsYXJnZXIgcGllY2VzXG4gICAgfVxuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3ViYXJyYXlfdG9fanNieXRlc1xuLy9XZWFrZGVmXG4vLyBQcmUgRUNNQVNjcmlwdCA1LCBbYXBwbHldIHdvdWxkIG5vdCBzdXBwb3J0IGFycmF5LWxpa2Ugb2JqZWN0LlxuLy8gSW4gc3VjaCBzZXR1cCwgVHlwZWRfYXJyYXkgd291bGQgYmUgaW1wbGVtZW50ZWQgYXMgcG9seWZpbGwsIGFuZCBbZi5hcHBseV0gd291bGRcbi8vIGZhaWwgaGVyZS4gTWFyayB0aGUgcHJpbWl0aXZlIGFzIFdlYWtkZWYsIHNvIHRoYXQgcGVvcGxlIGNhbiBvdmVycmlkZSBpdCBlYXNpbHkuXG5mdW5jdGlvbiBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMgKGEsIGksIGxlbikge1xuICB2YXIgZiA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG4gIGlmIChpID09IDAgJiYgbGVuIDw9IDQwOTYgJiYgbGVuID09IGEubGVuZ3RoKSByZXR1cm4gZi5hcHBseSAobnVsbCwgYSk7XG4gIHZhciBzID0gXCJcIjtcbiAgZm9yICg7IDAgPCBsZW47IGkgKz0gMTAyNCxsZW4tPTEwMjQpXG4gICAgcyArPSBmLmFwcGx5IChudWxsLCBhLnNsaWNlKGksaSArIE1hdGgubWluKGxlbiwgMTAyNCkpKTtcbiAgcmV0dXJuIHM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdXRmOF9vZl91dGYxNlxuZnVuY3Rpb24gY2FtbF91dGY4X29mX3V0ZjE2KHMpIHtcbiAgZm9yICh2YXIgYiA9IFwiXCIsIHQgPSBiLCBjLCBkLCBpID0gMCwgbCA9IHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgYyA9IHMuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgIGZvciAodmFyIGogPSBpICsgMTsgKGogPCBsKSAmJiAoYyA9IHMuY2hhckNvZGVBdChqKSkgPCAweDgwOyBqKyspO1xuICAgICAgaWYgKGogLSBpID4gNTEyKSB7IHQuc3Vic3RyKDAsIDEpOyBiICs9IHQ7IHQgPSBcIlwiOyBiICs9IHMuc2xpY2UoaSwgaikgfVxuICAgICAgZWxzZSB0ICs9IHMuc2xpY2UoaSwgaik7XG4gICAgICBpZiAoaiA9PSBsKSBicmVhaztcbiAgICAgIGkgPSBqO1xuICAgIH1cbiAgICBpZiAoYyA8IDB4ODAwKSB7XG4gICAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhjMCB8IChjID4+IDYpKTtcbiAgICAgIHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweDgwIHwgKGMgJiAweDNmKSk7XG4gICAgfSBlbHNlIGlmIChjIDwgMHhkODAwIHx8IGMgPj0gMHhkZmZmKSB7XG4gICAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhlMCB8IChjID4+IDEyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKChjID4+IDYpICYgMHgzZiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8IChjICYgMHgzZikpO1xuICAgIH0gZWxzZSBpZiAoYyA+PSAweGRiZmYgfHwgaSArIDEgPT0gbCB8fFxuICAgICAgICAgICAgICAgKGQgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBkID4gMHhkZmZmKSB7XG4gICAgICAvLyBVbm1hdGNoZWQgc3Vycm9nYXRlIHBhaXIsIHJlcGxhY2VkIGJ5IFxcdWZmZmQgKHJlcGxhY2VtZW50IGNoYXJhY3RlcilcbiAgICAgIHQgKz0gXCJcXHhlZlxceGJmXFx4YmRcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgaSsrO1xuICAgICAgYyA9IChjIDw8IDEwKSArIGQgLSAweDM1ZmRjMDA7XG4gICAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhmMCB8IChjID4+IDE4KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKChjID4+IDEyKSAmIDB4M2YpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoKGMgPj4gNikgJiAweDNmKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKGMgJiAweDNmKSk7XG4gICAgfVxuICAgIGlmICh0Lmxlbmd0aCA+IDEwMjQpIHt0LnN1YnN0cigwLCAxKTsgYiArPSB0OyB0ID0gXCJcIjt9XG4gIH1cbiAgcmV0dXJuIGIrdDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91dGYxNl9vZl91dGY4XG5mdW5jdGlvbiBjYW1sX3V0ZjE2X29mX3V0Zjgocykge1xuICBmb3IgKHZhciBiID0gXCJcIiwgdCA9IFwiXCIsIGMsIGMxLCBjMiwgdiwgaSA9IDAsIGwgPSBzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGMxID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjMSA8IDB4ODApIHtcbiAgICAgIGZvciAodmFyIGogPSBpICsgMTsgKGogPCBsKSAmJiAoYzEgPSBzLmNoYXJDb2RlQXQoaikpIDwgMHg4MDsgaisrKTtcbiAgICAgIGlmIChqIC0gaSA+IDUxMikgeyB0LnN1YnN0cigwLCAxKTsgYiArPSB0OyB0ID0gXCJcIjsgYiArPSBzLnNsaWNlKGksIGopIH1cbiAgICAgIGVsc2UgdCArPSBzLnNsaWNlKGksIGopO1xuICAgICAgaWYgKGogPT0gbCkgYnJlYWs7XG4gICAgICBpID0gajtcbiAgICB9XG4gICAgdiA9IDE7XG4gICAgaWYgKCgrK2kgPCBsKSAmJiAoKChjMiA9IHMuY2hhckNvZGVBdChpKSkgJiAtNjQpID09IDEyOCkpIHtcbiAgICAgIGMgPSBjMiArIChjMSA8PCA2KTtcbiAgICAgIGlmIChjMSA8IDB4ZTApIHtcbiAgICAgICAgdiA9IGMgLSAweDMwODA7XG4gICAgICAgIGlmICh2IDwgMHg4MCkgdiA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2ID0gMjtcbiAgICAgICAgaWYgKCgrK2kgPCBsKSAmJiAoKChjMiA9IHMuY2hhckNvZGVBdChpKSkgJiAtNjQpID09IDEyOCkpIHtcbiAgICAgICAgICBjID0gYzIgKyAoYyA8PCA2KTtcbiAgICAgICAgICBpZiAoYzEgPCAweGYwKSB7XG4gICAgICAgICAgICB2ID0gYyAtIDB4ZTIwODA7XG4gICAgICAgICAgICBpZiAoKHYgPCAweDgwMCkgfHwgKCh2ID49IDB4ZDdmZikgJiYgKHYgPCAweGUwMDApKSkgdiA9IDI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHYgPSAzO1xuICAgICAgICAgICAgaWYgKCgrK2kgPCBsKSAmJiAoKChjMiA9IHMuY2hhckNvZGVBdChpKSkgJiAtNjQpID09IDEyOCkgJiZcbiAgICAgICAgICAgICAgICAoYzEgPCAweGY1KSkge1xuICAgICAgICAgICAgICB2ID0gYzIgLSAweDNjODIwODAgKyAoYyA8PCA2KTtcbiAgICAgICAgICAgICAgaWYgKHYgPCAweDEwMDAwIHx8IHYgPiAweDEwZmZmZikgdiA9IDM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh2IDwgNCkgeyAvLyBJbnZhbGlkIHNlcXVlbmNlXG4gICAgICBpIC09IHY7XG4gICAgICB0ICs9IFwiXFx1ZmZmZFwiO1xuICAgIH0gZWxzZSBpZiAodiA+IDB4ZmZmZilcbiAgICAgIHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGQ3YzAgKyAodiA+PiAxMCksIDB4ZGMwMCArICh2ICYgMHgzRkYpKVxuICAgIGVsc2VcbiAgICAgIHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh2KTtcbiAgICBpZiAodC5sZW5ndGggPiAxMDI0KSB7dC5zdWJzdHIoMCwgMSk7IGIgKz0gdDsgdCA9IFwiXCI7fVxuICB9XG4gIHJldHVybiBiK3Q7XG59XG5cbi8vUHJvdmlkZXM6IGpzb29faXNfYXNjaWlcbmZ1bmN0aW9uIGpzb29faXNfYXNjaWkgKHMpIHtcbiAgLy8gVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBnZXRzIGJldHRlciBhdCBhcm91bmQgdGhpcyBwb2ludCBmb3IgYWxsIGJyb3dzZXJzXG4gIGlmIChzLmxlbmd0aCA8IDI0KSB7XG4gICAgLy8gU3BpZGVybW9ua2V5IGdldHMgbXVjaCBzbG93ZXIgd2hlbiBzLmxlbmd0aCA+PSAyNCAob24gNjQgYml0IGFyY2hzKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkrKykgaWYgKHMuY2hhckNvZGVBdChpKSA+IDEyNykgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2VcbiAgICByZXR1cm4gIS9bXlxceDAwLVxceDdmXS8udGVzdChzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc191bnNhZmVfZ2V0IG11dGFibGVcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSkge1xuICBzd2l0Y2ggKHMudCAmIDYpIHtcbiAgZGVmYXVsdDogLyogUEFSVElBTCAqL1xuICAgIGlmIChpID49IHMuYy5sZW5ndGgpIHJldHVybiAwO1xuICBjYXNlIDA6IC8qIEJZVEVTICovXG4gICAgcmV0dXJuIHMuYy5jaGFyQ29kZUF0KGkpO1xuICBjYXNlIDQ6IC8qIEFSUkFZICovXG4gICAgcmV0dXJuIHMuY1tpXVxuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfdW5zYWZlX3NldFxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5XG5mdW5jdGlvbiBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGksIGMpIHtcbiAgLy8gVGhlIE9DYW1sIGNvbXBpbGVyIHVzZXMgQ2hhci51bnNhZmVfY2hyIG9uIGludGVnZXJzIGxhcmdlciB0aGFuIDI1NSFcbiAgYyAmPSAweGZmO1xuICBpZiAocy50ICE9IDQgLyogQVJSQVkgKi8pIHtcbiAgICBpZiAoaSA9PSBzLmMubGVuZ3RoKSB7XG4gICAgICBzLmMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSAoYyk7XG4gICAgICBpZiAoaSArIDEgPT0gcy5sKSBzLnQgPSAwOyAvKkJZVEVTIHwgVU5LT1dOKi9cbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXkgKHMpO1xuICB9XG4gIHMuY1tpXSA9IGM7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX3N0cmluZ19ib3VuZF9lcnJvciAoKSB7XG4gIGNhbWxfaW52YWxpZF9hcmd1bWVudCAoXCJpbmRleCBvdXQgb2YgYm91bmRzXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IgKCkge1xuICBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiaW5kZXggb3V0IG9mIGJvdW5kc1wiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19ib3VuZF9lcnJvciwgY2FtbF9zdHJpbmdfdW5zYWZlX2dldFxuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19nZXQgKHMsIGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpKSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2dldDE2XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0LCBjYW1sX3N0cmluZ19ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19nZXQxNihzLGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpIC0gMSkgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSksXG4gICAgICBiMiA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkgKyAxKTtcbiAgcmV0dXJuIChiMiA8PCA4IHwgYjEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2dldDE2XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQsIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ2V0MTYocyxpKSB7XG4gIGlmIChpID4+PiAwID49IHMubCAtIDEpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpKSxcbiAgICAgIGIyID0gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpICsgMSk7XG4gIHJldHVybiAoYjIgPDwgOCB8IGIxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZ2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQsIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2dldDMyKHMsaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBjYW1sX21sX3N0cmluZ19sZW5ndGgocykgLSAzKSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpKSxcbiAgICAgIGIyID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSArIDEpLFxuICAgICAgYjMgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpICsgMiksXG4gICAgICBiNCA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkgKyAzKTtcbiAgcmV0dXJuIChiNCA8PCAyNCB8IGIzIDw8IDE2IHwgYjIgPDwgOCB8IGIxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19nZXQzMlxuLy9SZXF1aXJlczogY2FtbF9ieXRlc191bnNhZmVfZ2V0LCBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2dldDMyKHMsaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgLSAzKSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSksXG4gICAgICBiMiA9IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSArIDEpLFxuICAgICAgYjMgPSBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkgKyAyKSxcbiAgICAgIGI0ID0gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpICsgMyk7XG4gIHJldHVybiAoYjQgPDwgMjQgfCBiMyA8PCAxNiB8IGIyIDw8IDggfCBiMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2dldDY0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0LCBjYW1sX3N0cmluZ19ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19nZXQ2NChzLGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpIC0gNykgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGEgPSBuZXcgQXJyYXkoOCk7XG4gIGZvcih2YXIgaiA9IDA7IGogPCA4OyBqKyspe1xuICAgIGFbNyAtIGpdID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSArIGopO1xuICB9XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2J5dGVzKGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2dldDY0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQsIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ2V0NjQocyxpKSB7XG4gIGlmIChpID4+PiAwID49IHMubCAtIDcpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGEgPSBuZXcgQXJyYXkoOCk7XG4gIGZvcih2YXIgaiA9IDA7IGogPCA4OyBqKyspe1xuICAgIGFbNyAtIGpdID0gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpICsgaik7XG4gIH1cbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfYnl0ZXMoYSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yLCBjYW1sX2J5dGVzX3Vuc2FmZV9nZXRcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ2V0IChzLCBpKSB7XG4gIGlmIChpID4+PiAwID49IHMubCkgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldCAocywgaSwgYykge1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9zdHJpbmdfc2V0XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQsIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQgKHMsIGksIGMpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sKSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gY2FtbF9zdHJpbmdfdW5zYWZlX3NldCAocywgaSwgYyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfc2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IsIGNhbWxfYnl0ZXNfdW5zYWZlX3NldFxuZnVuY3Rpb24gY2FtbF9ieXRlc19zZXQxNihzLGksaTE2KXtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sIC0gMSkgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICB2YXIgYjIgPSAweEZGICYgaTE2ID4+IDgsXG4gICAgICBiMSA9IDB4RkYgJiBpMTY7XG4gIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSArIDAsIGIxKTtcbiAgY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpICsgMSwgYjIpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXQxNlxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQxNihzLGksaTE2KXtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfc3RyaW5nX3NldDE2XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXQxNlxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19zZXQxNlxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0MTYocyxpLGkxNil7XG4gIHJldHVybiBjYW1sX2J5dGVzX3NldDE2KHMsaSxpMTYpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX3NldDMyXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yLCBjYW1sX2J5dGVzX3Vuc2FmZV9zZXRcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfc2V0MzIocyxpLGkzMil7XG4gIGlmIChpID4+PiAwID49IHMubCAtIDMpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGI0ID0gMHhGRiAmIGkzMiA+PiAyNCxcbiAgICAgIGIzID0gMHhGRiAmIGkzMiA+PiAxNixcbiAgICAgIGIyID0gMHhGRiAmIGkzMiA+PiA4LFxuICAgICAgYjEgPSAweEZGICYgaTMyO1xuICBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGkgKyAwLCBiMSk7XG4gIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSArIDEsIGIyKTtcbiAgY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpICsgMiwgYjMpO1xuICBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGkgKyAzLCBiNCk7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldDMyXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldDMyKHMsaSxpMzIpe1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9zdHJpbmdfc2V0MzJcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldDMyXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3NldDMyXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQzMihzLGksaTMyKXtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfc2V0MzIocyxpLGkzMik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfc2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IsIGNhbWxfYnl0ZXNfdW5zYWZlX3NldFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19zZXQ2NChzLGksaTY0KXtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sIC0gNykgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICB2YXIgYSA9IGNhbWxfaW50NjRfdG9fYnl0ZXMoaTY0KTtcbiAgZm9yKHZhciBqID0gMDsgaiA8IDg7IGorKykge1xuICAgIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSArIDcgLSBqLCBhW2pdKTtcbiAgfVxuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQ2NChzLGksaTY0KXtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfc3RyaW5nX3NldDY0XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19zZXQ2NFxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0NjQocyxpLGk2NCl7XG4gIHJldHVybiBjYW1sX2J5dGVzX3NldDY0KHMsaSxpNjQpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX3NldFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19ib3VuZF9lcnJvciwgY2FtbF9ieXRlc191bnNhZmVfc2V0XG5mdW5jdGlvbiBjYW1sX2J5dGVzX3NldCAocywgaSwgYykge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSwgYyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfb2ZfdXRmMTZfanNzdHJpbmdcbi8vUmVxdWlyZXM6IGpzb29faXNfYXNjaWksIGNhbWxfdXRmOF9vZl91dGYxNiwgTWxCeXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19vZl91dGYxNl9qc3N0cmluZyAocykge1xuICB2YXIgdGFnID0gOSAvKiBCWVRFUyB8IEFTQ0lJICovO1xuICBpZiAoIWpzb29faXNfYXNjaWkocykpXG4gICAgdGFnID0gOCAvKiBCWVRFUyB8IE5PVF9BU0NJSSAqLywgcyA9IGNhbWxfdXRmOF9vZl91dGYxNihzKTtcbiAgcmV0dXJuIG5ldyBNbEJ5dGVzKHRhZywgcywgcy5sZW5ndGgpO1xufVxuXG5cbi8vUHJvdmlkZXM6IE1sQnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMsIGpzb29faXNfYXNjaWksIGNhbWxfdXRmMTZfb2ZfdXRmOFxuZnVuY3Rpb24gTWxCeXRlcyAodGFnLCBjb250ZW50cywgbGVuZ3RoKSB7XG4gIHRoaXMudD10YWc7IHRoaXMuYz1jb250ZW50czsgdGhpcy5sPWxlbmd0aDtcbn1cbk1sQnl0ZXMucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKXtcbiAgc3dpdGNoICh0aGlzLnQpIHtcbiAgY2FzZSA5OiAvKkJZVEVTIHwgQVNDSUkqL1xuICAgIHJldHVybiB0aGlzLmM7XG4gIGRlZmF1bHQ6XG4gICAgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyh0aGlzKTtcbiAgY2FzZSAwOiAvKkJZVEVTIHwgVU5LT1dOKi9cbiAgICBpZiAoanNvb19pc19hc2NpaSh0aGlzLmMpKSB7XG4gICAgICB0aGlzLnQgPSA5OyAvKkJZVEVTIHwgQVNDSUkqL1xuICAgICAgcmV0dXJuIHRoaXMuYztcbiAgICB9XG4gICAgdGhpcy50ID0gODsgLypCWVRFUyB8IE5PVF9BU0NJSSovXG4gIGNhc2UgODogLypCWVRFUyB8IE5PVF9BU0NJSSovXG4gICAgcmV0dXJuIHRoaXMuYztcbiAgfVxufTtcbk1sQnl0ZXMucHJvdG90eXBlLnRvVXRmMTYgPSBmdW5jdGlvbiAoKXtcbiAgdmFyIHIgPSB0aGlzLnRvU3RyaW5nKCk7XG4gIGlmKHRoaXMudCA9PSA5KSByZXR1cm4gclxuICByZXR1cm4gY2FtbF91dGYxNl9vZl91dGY4KHIpO1xufVxuTWxCeXRlcy5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoKXtcbiAgdmFyIGNvbnRlbnQgPSB0aGlzLnQgPT0gNCA/IHRoaXMuYy5zbGljZSgpIDogdGhpcy5jO1xuICByZXR1cm4gbmV3IE1sQnl0ZXModGhpcy50LGNvbnRlbnQsdGhpcy5sKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9zdHJfcmVwZWF0LCBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMgKHMpIHtcbiAgLyogQXNzdW1lcyBub3QgQllURVMgKi9cbiAgaWYgKHMudCA9PSAyIC8qIFBBUlRJQUwgKi8pXG4gICAgcy5jICs9IGNhbWxfc3RyX3JlcGVhdChzLmwgLSBzLmMubGVuZ3RoLCAnXFwwJylcbiAgZWxzZVxuICAgIHMuYyA9IGNhbWxfc3ViYXJyYXlfdG9fanNieXRlcyAocy5jLCAwLCBzLmMubGVuZ3RoKTtcbiAgcy50ID0gMDsgLypCWVRFUyB8IFVOS09XTiovXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29udmVydF9ieXRlc190b19hcnJheVxuZnVuY3Rpb24gY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5IChzKSB7XG4gIC8qIEFzc3VtZXMgbm90IEFSUkFZICovXG4gIHZhciBhID0gbmV3IFVpbnQ4QXJyYXkocy5sKTtcbiAgdmFyIGIgPSBzLmMsIGwgPSBiLmxlbmd0aCwgaSA9IDA7XG4gIGZvciAoOyBpIDwgbDsgaSsrKSBhW2ldID0gYi5jaGFyQ29kZUF0KGkpO1xuICBmb3IgKGwgPSBzLmw7IGkgPCBsOyBpKyspIGFbaV0gPSAwO1xuICBzLmMgPSBhO1xuICBzLnQgPSA0OyAvKiBBUlJBWSAqL1xuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91aW50OF9hcnJheV9vZl9ieXRlcyBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXMgKHMpIHtcbiAgaWYgKHMudCAhPSA0IC8qIEFSUkFZICovKSBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXkocyk7XG4gIHJldHVybiBzLmM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdWludDhfYXJyYXlfb2Zfc3RyaW5nIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9ieXRlc190b19hcnJheVxuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX3N0cmluZ191bnNhZmVfZ2V0XG5mdW5jdGlvbiBjYW1sX3VpbnQ4X2FycmF5X29mX3N0cmluZyAocykge1xuICB2YXIgbCA9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKTtcbiAgdmFyIGEgPSBuZXcgQXJyYXkobCk7XG4gIHZhciBpID0gMDtcbiAgZm9yICg7IGkgPCBsOyBpKyspIGFbaV0gPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsaSk7XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NyZWF0ZV9zdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IE1sQnl0ZXMsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9jcmVhdGVfc3RyaW5nKGxlbikge1xuICBpZihsZW4gPCAwKSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJTdHJpbmcuY3JlYXRlXCIpO1xuICByZXR1cm4gbmV3IE1sQnl0ZXMobGVuPzI6OSxcIlwiLGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY3JlYXRlX3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfY3JlYXRlX3N0cmluZyhsZW4pIHtcbiAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiU3RyaW5nLmNyZWF0ZVwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jcmVhdGVfYnl0ZXMgY29uc3Rcbi8vUmVxdWlyZXM6IE1sQnl0ZXMsY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2NyZWF0ZV9ieXRlcyhsZW4pIHtcbiAgaWYgKGxlbiA8IDApIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJ5dGVzLmNyZWF0ZVwiKTtcbiAgcmV0dXJuIG5ldyBNbEJ5dGVzKGxlbj8yOjksXCJcIixsZW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9zdWJhcnJheV90b19qc2J5dGVzLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl9hcnJheSAoYSkge1xuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMoYSwwLGEubGVuZ3RoKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfb2ZfYXJyYXlcbi8vUmVxdWlyZXM6IE1sQnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfb2ZfYXJyYXkgKGEpIHtcbiAgaWYoISAoYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgYSA9IG5ldyBVaW50OEFycmF5KGEpO1xuICB9XG4gIHJldHVybiBuZXcgTWxCeXRlcyg0LGEsYS5sZW5ndGgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2NvbXBhcmUgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19jb21wYXJlKHMxLCBzMikge1xuICAoczEudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczEpO1xuICAoczIudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczIpO1xuICByZXR1cm4gKHMxLmMgPCBzMi5jKT8tMTooczEuYyA+IHMyLmMpPzE6MDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2VxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZXF1YWwoczEsIHMyKSB7XG4gIGlmKHMxID09PSBzMikgcmV0dXJuIDE7XG4gIChzMS50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMSk7XG4gIChzMi50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMik7XG4gIHJldHVybiAoczEuYyA9PSBzMi5jKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX25vdGVxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2VxdWFsXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19ub3RlcXVhbChzMSwgczIpIHsgcmV0dXJuIDEtY2FtbF9zdHJpbmdfZXF1YWwoczEsIHMyKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX25vdGVxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfZXF1YWxcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfbm90ZXF1YWwoczEsIHMyKSB7IHJldHVybiAxLWNhbWxfYnl0ZXNfZXF1YWwoczEsIHMyKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2xlc3NlcXVhbCBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2xlc3NlcXVhbChzMSwgczIpIHtcbiAgKHMxLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMxKTtcbiAgKHMyLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMyKTtcbiAgcmV0dXJuIChzMS5jIDw9IHMyLmMpPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19sZXNzdGhhbiBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2xlc3N0aGFuKHMxLCBzMikge1xuICAoczEudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczEpO1xuICAoczIudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczIpO1xuICByZXR1cm4gKHMxLmMgPCBzMi5jKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2dyZWF0ZXJlcXVhbFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfbGVzc2VxdWFsXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19ncmVhdGVyZXF1YWwoczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19sZXNzZXF1YWwoczIsczEpO1xufVxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19ncmVhdGVyZXF1YWxcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfbGVzc2VxdWFsXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2dyZWF0ZXJlcXVhbChzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfbGVzc2VxdWFsKHMyLHMxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZ3JlYXRlcnRoYW5cbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2xlc3N0aGFuXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19ncmVhdGVydGhhbihzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX2xlc3N0aGFuKHMyLCBzMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZ3JlYXRlcnRoYW5cbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfbGVzc3RoYW5cbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ3JlYXRlcnRoYW4oczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX2xlc3N0aGFuKHMyLCBzMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmlsbF9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9zdHJfcmVwZWF0LCBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXlcbi8vQWxpYXM6IGNhbWxfZmlsbF9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZmlsbF9ieXRlcyhzLCBpLCBsLCBjKSB7XG4gIGlmIChsID4gMCkge1xuICAgIGlmIChpID09IDAgJiYgKGwgPj0gcy5sIHx8IChzLnQgPT0gMiAvKiBQQVJUSUFMICovICYmIGwgPj0gcy5jLmxlbmd0aCkpKSB7XG4gICAgICBpZiAoYyA9PSAwKSB7XG4gICAgICAgIHMuYyA9IFwiXCI7XG4gICAgICAgIHMudCA9IDI7IC8qIFBBUlRJQUwgKi9cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMuYyA9IGNhbWxfc3RyX3JlcGVhdCAobCwgU3RyaW5nLmZyb21DaGFyQ29kZShjKSk7XG4gICAgICAgIHMudCA9IChsID09IHMubCk/MCAvKiBCWVRFUyB8IFVOS09XTiAqLyA6MjsgLyogUEFSVElBTCAqL1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocy50ICE9IDQgLyogQVJSQVkgKi8pIGNhbWxfY29udmVydF9ieXRlc190b19hcnJheShzKTtcbiAgICAgIGZvciAobCArPSBpOyBpIDwgbDsgaSsrKSBzLmNbaV0gPSBjO1xuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ibGl0X2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMsIGNhbWxfY29udmVydF9ieXRlc190b19hcnJheVxuZnVuY3Rpb24gY2FtbF9ibGl0X2J5dGVzKHMxLCBpMSwgczIsIGkyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSAwKSByZXR1cm4gMDtcbiAgaWYgKChpMiA9PSAwKSAmJlxuICAgICAgKGxlbiA+PSBzMi5sIHx8IChzMi50ID09IDIgLyogUEFSVElBTCAqLyAmJiBsZW4gPj0gczIuYy5sZW5ndGgpKSkge1xuICAgIHMyLmMgPSAoczEudCA9PSA0IC8qIEFSUkFZICovKT9cbiAgICAgIGNhbWxfc3ViYXJyYXlfdG9fanNieXRlcyhzMS5jLCBpMSwgbGVuKTpcbiAgICAgIChpMSA9PSAwICYmIHMxLmMubGVuZ3RoID09IGxlbik/czEuYzpzMS5jLnN1YnN0cihpMSwgbGVuKTtcbiAgICBzMi50ID0gKHMyLmMubGVuZ3RoID09IHMyLmwpPzAgLyogQllURVMgfCBVTktPV04gKi8gOjI7IC8qIFBBUlRJQUwgKi9cbiAgfSBlbHNlIGlmIChzMi50ID09IDIgLyogUEFSVElBTCAqLyAmJiBpMiA9PSBzMi5jLmxlbmd0aCkge1xuICAgIHMyLmMgKz0gKHMxLnQgPT0gNCAvKiBBUlJBWSAqLyk/XG4gICAgICBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMoczEuYywgaTEsIGxlbik6XG4gICAgICAoaTEgPT0gMCAmJiBzMS5jLmxlbmd0aCA9PSBsZW4pP3MxLmM6czEuYy5zdWJzdHIoaTEsIGxlbik7XG4gICAgczIudCA9IChzMi5jLmxlbmd0aCA9PSBzMi5sKT8wIC8qIEJZVEVTIHwgVU5LT1dOICovIDoyOyAvKiBQQVJUSUFMICovXG4gIH0gZWxzZSB7XG4gICAgaWYgKHMyLnQgIT0gNCAvKiBBUlJBWSAqLykgY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5KHMyKTtcbiAgICB2YXIgYzEgPSBzMS5jLCBjMiA9IHMyLmM7XG4gICAgaWYgKHMxLnQgPT0gNCAvKiBBUlJBWSAqLykge1xuICAgICAgaWYgKGkyIDw9IGkxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGMyIFtpMiArIGldID0gYzEgW2kxICsgaV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIGMyIFtpMiArIGldID0gYzEgW2kxICsgaV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBsID0gTWF0aC5taW4gKGxlbiwgYzEubGVuZ3RoIC0gaTEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIGMyIFtpMiArIGldID0gYzEuY2hhckNvZGVBdChpMSArIGkpO1xuICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykgYzIgW2kyICsgaV0gPSAwO1xuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ibGl0X3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9ibGl0X2J5dGVzLCBjYW1sX2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9ibGl0X3N0cmluZyhhLGIsYyxkLGUpIHtcbiAgY2FtbF9ibGl0X2J5dGVzKGNhbWxfYnl0ZXNfb2Zfc3RyaW5nKGEpLGIsYyxkLGUpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2J5dGVzX2xlbmd0aCBjb25zdFxuZnVuY3Rpb24gY2FtbF9tbF9ieXRlc19sZW5ndGgocykgeyByZXR1cm4gcy5sIH1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCBjb25zdFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpKSB7XG4gIHJldHVybiBzLmNoYXJDb2RlQXQoaSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfdW5zYWZlX3NldCAocywgaSwgYykge1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9zdHJpbmdfdW5zYWZlX3NldFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoIGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSB7XG4gIHJldHVybiBzLmxlbmd0aFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19jb21wYXJlIGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2NvbXBhcmUoczEsIHMyKSB7XG4gIHJldHVybiAoczEgPCBzMik/LTE6KHMxID4gczIpPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZXF1YWwgY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZXF1YWwoczEsIHMyKSB7XG4gIGlmKHMxID09PSBzMikgcmV0dXJuIDE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19sZXNzZXF1YWwgY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfbGVzc2VxdWFsKHMxLCBzMikge1xuICByZXR1cm4gKHMxIDw9IHMyKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2xlc3N0aGFuIGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2xlc3N0aGFuKHMxLCBzMikge1xuICByZXR1cm4gKHMxIDwgczIpPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfb2ZfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfb2ZfYnl0ZXMocykge1xuICAocy50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzKTtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMocy5jKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19vZl9zdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfb2ZfanNieXRlcywgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2J5dGVzX29mX3N0cmluZyhzKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX29mX2pzYnl0ZXMoY2FtbF9qc2J5dGVzX29mX3N0cmluZyhzKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMgY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyh4KSB7IHJldHVybiB4IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZyBjb25zdFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHgpIHsgcmV0dXJuIHggfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczoganNvb19pc19hc2NpaSwgY2FtbF91dGYxNl9vZl91dGY4XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpIHtcbiAgaWYoanNvb19pc19hc2NpaShzKSlcbiAgICByZXR1cm4gcztcbiAgcmV0dXJuIGNhbWxfdXRmMTZfb2ZfdXRmOChzKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczoganNvb19pc19hc2NpaSwgY2FtbF91dGY4X29mX3V0ZjE2LCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nIChzKSB7XG4gIGlmIChqc29vX2lzX2FzY2lpKHMpKVxuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHMpXG4gIGVsc2UgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoY2FtbF91dGY4X29mX3V0ZjE2KHMpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19vZl9qc2J5dGVzIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEJ5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX29mX2pzYnl0ZXMocykgeyByZXR1cm4gbmV3IE1sQnl0ZXMoMCxzLHMubGVuZ3RoKTsgfVxuXG5cbi8vIFRoZSBzZWN0aW9uIGJlbG93IHNob3VsZCBiZSB1c2VkIHdoZW4gdXNlLWpzLXN0cmluZz1mYWxzZVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXRcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfdW5zYWZlX2dldChzLGkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ191bnNhZmVfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9zZXRcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQgKHMsIGksIGMpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfdW5zYWZlX3NldChzLGksYyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9tbF9ieXRlc19sZW5ndGhcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSB7XG4gIHJldHVybiBjYW1sX21sX2J5dGVzX2xlbmd0aChzKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19jb21wYXJlXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2NvbXBhcmVcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2NvbXBhcmUoczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX2NvbXBhcmUoczEsczIpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2VxdWFsXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2VxdWFsXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19lcXVhbChzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfZXF1YWwoczEsczIpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2xlc3NlcXVhbFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19sZXNzZXF1YWxcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2xlc3NlcXVhbChzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfbGVzc2VxdWFsKHMxLHMyKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19sZXNzdGhhblxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19sZXNzdGhhblxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfbGVzc3RoYW4oczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX2xlc3N0aGFuKHMxLHMyKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9ieXRlc1xuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfb2ZfYnl0ZXMocykgeyByZXR1cm4gcyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfb2Zfc3RyaW5nIGNvbnN0XG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2J5dGVzX29mX3N0cmluZyhzKSB7IHJldHVybiBzIH1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlcyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19vZl9qc2J5dGVzXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHMpIHsgcmV0dXJuIGNhbWxfYnl0ZXNfb2ZfanNieXRlcyhzKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHMpIHtcbiAgKHMudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMocyk7XG4gIHJldHVybiBzLmMgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyBtdXRhYmxlIChjb25zdClcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpe1xuICByZXR1cm4gcy50b1V0ZjE2KClcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfb2ZfdXRmMTZfanNzdHJpbmdcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nIChzKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX29mX3V0ZjE2X2pzc3RyaW5nKHMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lzX21sX2J5dGVzXG4vL1JlcXVpcmVzOiBNbEJ5dGVzXG5mdW5jdGlvbiBjYW1sX2lzX21sX2J5dGVzKHMpIHtcbiAgcmV0dXJuIChzIGluc3RhbmNlb2YgTWxCeXRlcyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfYnl0ZXNfY29udGVudFxuLy9SZXF1aXJlczogTWxCeXRlcywgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9tbF9ieXRlc19jb250ZW50KHMpIHtcbiAgc3dpdGNoIChzLnQgJiA2KSB7XG4gIGRlZmF1bHQ6IC8qIFBBUlRJQUwgKi9cbiAgICBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMpO1xuICBjYXNlIDA6IC8qIEJZVEVTICovXG4gICAgcmV0dXJuIHMuYztcbiAgY2FzZSA0OlxuICAgIHJldHVybiBzLmNcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lzX21sX3N0cmluZ1xuLy9SZXF1aXJlczoganNvb19pc19hc2NpaVxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2lzX21sX3N0cmluZyhzKSB7XG4gIHJldHVybiAodHlwZW9mIHMgPT09IFwic3RyaW5nXCIgJiYgIS9bXlxceDAwLVxceGZmXS8udGVzdChzKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaXNfbWxfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2lzX21sX2J5dGVzXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2lzX21sX3N0cmluZyhzKSB7XG4gIHJldHVybiBjYW1sX2lzX21sX2J5dGVzKHMpO1xufVxuXG4vLyBUaGUgZnVuY3Rpb25zIGJlbG93IGFyZSBkZXByZWNhdGVkXG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfdG9fYnl0ZV9zdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfanNfdG9fYnl0ZV9zdHJpbmcocykgeyByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhzKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfbmV3X3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9uZXdfc3RyaW5nIChzKSB7IHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHMpIH1cblxuLy9Qcm92aWRlczogY2FtbF9qc19mcm9tX3N0cmluZyBtdXRhYmxlIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzX2Zyb21fc3RyaW5nKHMpIHtcbiAgcmV0dXJuIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdG9fanNfc3RyaW5nIG11dGFibGUgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfdG9fanNfc3RyaW5nKHMpIHtcbiAgcmV0dXJuIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfdG9fc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc190b19zdHJpbmcgKHMpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKHMpO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX3VpbnQ4X2FycmF5X29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9hcnJheV9vZl9zdHJpbmcoeCkgeyByZXR1cm4gY2FtbF91aW50OF9hcnJheV9vZl9zdHJpbmcoeCkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X29mX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2FycmF5X29mX2J5dGVzKHgpIHsgcmV0dXJuIGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXMoeCkgfVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9SYWlzZSBleGNlcHRpb25cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV9jb25zdGFudCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX3JhaXNlX2NvbnN0YW50ICh0YWcpIHsgdGhyb3cgdGFnOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmV0dXJuX2V4bl9jb25zdGFudCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX3JldHVybl9leG5fY29uc3RhbnQgKHRhZykgeyByZXR1cm4gdGFnOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfd2l0aF9hcmcgKGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfd2l0aF9hcmcgKHRhZywgYXJnKSB7IHRocm93IFswLCB0YWcsIGFyZ107IH1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV93aXRoX2FyZ3MgKGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfd2l0aF9hcmdzICh0YWcsIGFyZ3MpIHsgdGhyb3cgWzAsIHRhZ10uY29uY2F0KGFyZ3MpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfd2l0aF9hcmcsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcgKHRhZywgbXNnKSB7XG4gIGNhbWxfcmFpc2Vfd2l0aF9hcmcgKHRhZywgY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhtc2cpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mYWlsd2l0aCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nLCBjYW1sX2dsb2JhbF9kYXRhLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX2ZhaWx3aXRoIChtc2cpIHtcbiAgaWYoIWNhbWxfZ2xvYmFsX2RhdGEuRmFpbHVyZSlcbiAgICBjYW1sX2dsb2JhbF9kYXRhLkZhaWx1cmU9WzI0OCxjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwiRmFpbHVyZVwiKSwtM107XG4gIGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcoY2FtbF9nbG9iYWxfZGF0YS5GYWlsdXJlLCBtc2cpO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nLCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX2ludmFsaWRfYXJndW1lbnQgKG1zZykge1xuICBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nKGNhbWxfZ2xvYmFsX2RhdGEuSW52YWxpZF9hcmd1bWVudCwgbXNnKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9jb25zdGFudCwgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSAoKSB7XG4gIGNhbWxfcmFpc2VfY29uc3RhbnQoY2FtbF9nbG9iYWxfZGF0YS5FbmRfb2ZfZmlsZSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2VfemVyb19kaXZpZGVcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfY29uc3RhbnQsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfcmFpc2VfemVyb19kaXZpZGUgKCkge1xuICBjYW1sX3JhaXNlX2NvbnN0YW50KGNhbWxfZ2xvYmFsX2RhdGEuRGl2aXNpb25fYnlfemVybyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfbm90X2ZvdW5kXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2NvbnN0YW50LCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX3JhaXNlX25vdF9mb3VuZCAoKSB7XG4gIGNhbWxfcmFpc2VfY29uc3RhbnQoY2FtbF9nbG9iYWxfZGF0YS5Ob3RfZm91bmQpOyB9XG5cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yICgpIHtcbiAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiaW5kZXggb3V0IG9mIGJvdW5kc1wiKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NhbGxfZ2VuIChjb25zdCwgc2hhbGxvdylcbi8vSWY6ICFlZmZlY3RzXG4vL1dlYWtkZWZcbmZ1bmN0aW9uIGNhbWxfY2FsbF9nZW4oZiwgYXJncykge1xuICBpZihmLmZ1bilcbiAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLmZ1biwgYXJncyk7XG4gIC8vRklYTUUsIGNhbiBoYXBwZW4gd2l0aCB0b28gbWFueSBhcmd1bWVudHNcbiAgaWYodHlwZW9mIGYgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGY7XG4gIHZhciBuID0gZi5sZW5ndGggfCAwO1xuICBpZihuID09PSAwKSByZXR1cm4gZi5hcHBseShudWxsLGFyZ3MpO1xuICB2YXIgYXJnc0xlbiA9IGFyZ3MubGVuZ3RoIHwgMDtcbiAgdmFyIGQgPSBuIC0gYXJnc0xlbiB8IDA7XG4gIGlmIChkID09IDApXG4gICAgcmV0dXJuIGYuYXBwbHkobnVsbCwgYXJncyk7XG4gIGVsc2UgaWYgKGQgPCAwKSB7XG4gICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZi5hcHBseShudWxsLGFyZ3Muc2xpY2UoMCxuKSksYXJncy5zbGljZShuKSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpe1xuICAgICAgdmFyIGV4dHJhX2FyZ3MgPSAoYXJndW1lbnRzLmxlbmd0aCA9PSAwKT8xOmFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICB2YXIgbmFyZ3MgPSBuZXcgQXJyYXkoYXJncy5sZW5ndGgrZXh0cmFfYXJncyk7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKyApIG5hcmdzW2ldID0gYXJnc1tpXTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKysgKSBuYXJnc1thcmdzLmxlbmd0aCtpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYsIG5hcmdzKVxuICAgIH1cbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NhbGxfZ2VuIChjb25zdCwgc2hhbGxvdylcbi8vSWY6IGVmZmVjdHNcbi8vV2Vha2RlZlxuZnVuY3Rpb24gY2FtbF9jYWxsX2dlbihmLCBhcmdzKSB7XG4gIGlmIChmLmZ1bilcbiAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLmZ1biwgYXJncyk7XG4gIGlmICh0eXBlb2YgZiAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gYXJnc1thcmdzLmxlbmd0aC0xXShmKTtcbiAgdmFyIG4gPSBmLmxlbmd0aCB8IDA7XG4gIGlmIChuID09PSAwKSByZXR1cm4gZi5hcHBseShudWxsLCBhcmdzKTtcbiAgdmFyIGFyZ3NMZW4gPSBhcmdzLmxlbmd0aCB8IDA7XG4gIHZhciBkID0gbiAtIGFyZ3NMZW4gfCAwO1xuICBpZiAoZCA9PSAwKSB7XG4gICAgcmV0dXJuIGYuYXBwbHkobnVsbCwgYXJncyk7XG4gIH0gZWxzZSBpZiAoZCA8IDApIHtcbiAgICB2YXIgcmVzdCA9IGFyZ3Muc2xpY2UobiAtIDEpO1xuICAgIHZhciBrID0gYXJncyBbYXJnc0xlbiAtIDFdO1xuICAgIGFyZ3MgPSBhcmdzLnNsaWNlKDAsIG4pO1xuICAgIGFyZ3NbbiAtIDFdID0gZnVuY3Rpb24gKGcpIHtcbiAgICAgIHZhciBhcmdzID0gcmVzdC5zbGljZSgpO1xuICAgICAgYXJnc1thcmdzLmxlbmd0aCAtIDFdID0gaztcbiAgICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGcsIGFyZ3MpOyB9O1xuICAgIHJldHVybiBmLmFwcGx5KG51bGwsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIGFyZ3NMZW4tLTtcbiAgICB2YXIgayA9IGFyZ3MgW2FyZ3NMZW5dO1xuICAgIHJldHVybiBrIChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZXh0cmFfYXJncyA9IChhcmd1bWVudHMubGVuZ3RoID09IDApPzE6YXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIHZhciBuYXJncyA9IG5ldyBBcnJheShhcmdzTGVuICsgZXh0cmFfYXJncyk7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXJnc0xlbjsgaSsrICkgbmFyZ3NbaV0gPSBhcmdzW2ldO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyApXG4gICAgICAgIG5hcmdzW2FyZ3NMZW4gKyBpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYsIG5hcmdzKVxuICAgIH0pO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbmFtZWRfdmFsdWVzXG52YXIgY2FtbF9uYW1lZF92YWx1ZXMgPSB7fTtcblxuLy9Qcm92aWRlczogY2FtbF9yZWdpc3Rlcl9uYW1lZF92YWx1ZSAoY29uc3QsY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX25hbWVkX3ZhbHVlcywgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9yZWdpc3Rlcl9uYW1lZF92YWx1ZShubSx2KSB7XG4gIGNhbWxfbmFtZWRfdmFsdWVzW2NhbWxfanNieXRlc19vZl9zdHJpbmcobm0pXSA9IHY7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX25hbWVkX3ZhbHVlXG4vL1JlcXVpcmVzOiBjYW1sX25hbWVkX3ZhbHVlc1xuZnVuY3Rpb24gY2FtbF9uYW1lZF92YWx1ZShubSkge1xuICByZXR1cm4gY2FtbF9uYW1lZF92YWx1ZXNbbm1dXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2xvYmFsX2RhdGFcbnZhciBjYW1sX2dsb2JhbF9kYXRhID0gWzBdO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3JlZ2lzdGVyX2dsb2JhbCAoY29uc3QsIHNoYWxsb3csIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YSwgY2FtbF9jYWxsYmFja1xuZnVuY3Rpb24gY2FtbF9yZWdpc3Rlcl9nbG9iYWwgKG4sIHYsIG5hbWVfb3B0KSB7XG4gIGlmKG5hbWVfb3B0ICYmIGdsb2JhbFRoaXMudG9wbGV2ZWxSZWxvYylcbiAgICBuID0gY2FtbF9jYWxsYmFjayhnbG9iYWxUaGlzLnRvcGxldmVsUmVsb2MsIFtuYW1lX29wdF0pO1xuICBjYW1sX2dsb2JhbF9kYXRhW24gKyAxXSA9IHY7XG4gIGlmKG5hbWVfb3B0KSBjYW1sX2dsb2JhbF9kYXRhW25hbWVfb3B0XSA9IHY7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X2dsb2JhbF9kYXRhIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfZ2V0X2dsb2JhbF9kYXRhICgpIHsgcmV0dXJuIGNhbWxfZ2xvYmFsX2RhdGE7IH1cblxuLy9Qcm92aWRlczogY2FtbF9pc19wcmludGFibGUgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9pc19wcmludGFibGUoYykgeyByZXR1cm4gKyhjID4gMzEgJiYgYyA8IDEyNyk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9tYXliZV9wcmludF9zdGF0c1xuZnVuY3Rpb24gY2FtbF9tYXliZV9wcmludF9zdGF0cyh1bml0KSB7IHJldHVybiAwIH1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gRm9ybWF0XG5cbi8vUHJvdmlkZXM6IGNhbWxfcGFyc2VfZm9ybWF0XG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfcGFyc2VfZm9ybWF0IChmbXQpIHtcbiAgZm10ID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhmbXQpO1xuICB2YXIgbGVuID0gZm10Lmxlbmd0aDtcbiAgaWYgKGxlbiA+IDMxKSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJmb3JtYXRfaW50OiBmb3JtYXQgdG9vIGxvbmdcIik7XG4gIHZhciBmID1cbiAgICAgIHsganVzdGlmeTonKycsIHNpZ25zdHlsZTonLScsIGZpbGxlcjonICcsIGFsdGVybmF0ZTpmYWxzZSxcbiAgICAgICAgYmFzZTowLCBzaWduZWRjb252OmZhbHNlLCB3aWR0aDowLCB1cHBlcmNhc2U6ZmFsc2UsXG4gICAgICAgIHNpZ246MSwgcHJlYzotMSwgY29udjonZicgfTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBjID0gZm10LmNoYXJBdChpKTtcbiAgICBzd2l0Y2ggKGMpIHtcbiAgICBjYXNlICctJzpcbiAgICAgIGYuanVzdGlmeSA9ICctJzsgYnJlYWs7XG4gICAgY2FzZSAnKyc6IGNhc2UgJyAnOlxuICAgICAgZi5zaWduc3R5bGUgPSBjOyBicmVhaztcbiAgICBjYXNlICcwJzpcbiAgICAgIGYuZmlsbGVyID0gJzAnOyBicmVhaztcbiAgICBjYXNlICcjJzpcbiAgICAgIGYuYWx0ZXJuYXRlID0gdHJ1ZTsgYnJlYWs7XG4gICAgY2FzZSAnMSc6IGNhc2UgJzInOiBjYXNlICczJzogY2FzZSAnNCc6IGNhc2UgJzUnOlxuICAgIGNhc2UgJzYnOiBjYXNlICc3JzogY2FzZSAnOCc6IGNhc2UgJzknOlxuICAgICAgZi53aWR0aCA9IDA7XG4gICAgICB3aGlsZSAoYz1mbXQuY2hhckNvZGVBdChpKSAtIDQ4LCBjID49IDAgJiYgYyA8PSA5KSB7XG4gICAgICAgIGYud2lkdGggPSBmLndpZHRoICogMTAgKyBjOyBpKytcbiAgICAgIH1cbiAgICAgIGktLTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJy4nOlxuICAgICAgZi5wcmVjID0gMDtcbiAgICAgIGkrKztcbiAgICAgIHdoaWxlIChjPWZtdC5jaGFyQ29kZUF0KGkpIC0gNDgsIGMgPj0gMCAmJiBjIDw9IDkpIHtcbiAgICAgICAgZi5wcmVjID0gZi5wcmVjICogMTAgKyBjOyBpKytcbiAgICAgIH1cbiAgICAgIGktLTtcbiAgICBjYXNlICdkJzogY2FzZSAnaSc6XG4gICAgICBmLnNpZ25lZGNvbnYgPSB0cnVlOyAvKiBmYWxsdGhyb3VnaCAqL1xuICAgIGNhc2UgJ3UnOlxuICAgICAgZi5iYXNlID0gMTA7IGJyZWFrO1xuICAgIGNhc2UgJ3gnOlxuICAgICAgZi5iYXNlID0gMTY7IGJyZWFrO1xuICAgIGNhc2UgJ1gnOlxuICAgICAgZi5iYXNlID0gMTY7IGYudXBwZXJjYXNlID0gdHJ1ZTsgYnJlYWs7XG4gICAgY2FzZSAnbyc6XG4gICAgICBmLmJhc2UgPSA4OyBicmVhaztcbiAgICBjYXNlICdlJzogY2FzZSAnZic6IGNhc2UgJ2cnOlxuICAgICAgZi5zaWduZWRjb252ID0gdHJ1ZTsgZi5jb252ID0gYzsgYnJlYWs7XG4gICAgY2FzZSAnRSc6IGNhc2UgJ0YnOiBjYXNlICdHJzpcbiAgICAgIGYuc2lnbmVkY29udiA9IHRydWU7IGYudXBwZXJjYXNlID0gdHJ1ZTtcbiAgICAgIGYuY29udiA9IGMudG9Mb3dlckNhc2UgKCk7IGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9maW5pc2hfZm9ybWF0dGluZ1xuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9maW5pc2hfZm9ybWF0dGluZyhmLCByYXdidWZmZXIpIHtcbiAgaWYgKGYudXBwZXJjYXNlKSByYXdidWZmZXIgPSByYXdidWZmZXIudG9VcHBlckNhc2UoKTtcbiAgdmFyIGxlbiA9IHJhd2J1ZmZlci5sZW5ndGg7XG4gIC8qIEFkanVzdCBsZW4gdG8gcmVmbGVjdCBhZGRpdGlvbmFsIGNoYXJzIChzaWduLCBldGMpICovXG4gIGlmIChmLnNpZ25lZGNvbnYgJiYgKGYuc2lnbiA8IDAgfHwgZi5zaWduc3R5bGUgIT0gJy0nKSkgbGVuKys7XG4gIGlmIChmLmFsdGVybmF0ZSkge1xuICAgIGlmIChmLmJhc2UgPT0gOCkgbGVuICs9IDE7XG4gICAgaWYgKGYuYmFzZSA9PSAxNikgbGVuICs9IDI7XG4gIH1cbiAgLyogRG8gdGhlIGZvcm1hdHRpbmcgKi9cbiAgdmFyIGJ1ZmZlciA9IFwiXCI7XG4gIGlmIChmLmp1c3RpZnkgPT0gJysnICYmIGYuZmlsbGVyID09ICcgJylcbiAgICBmb3IgKHZhciBpID0gbGVuOyBpIDwgZi53aWR0aDsgaSsrKSBidWZmZXIgKz0gJyAnO1xuICBpZiAoZi5zaWduZWRjb252KSB7XG4gICAgaWYgKGYuc2lnbiA8IDApIGJ1ZmZlciArPSAnLSc7XG4gICAgZWxzZSBpZiAoZi5zaWduc3R5bGUgIT0gJy0nKSBidWZmZXIgKz0gZi5zaWduc3R5bGU7XG4gIH1cbiAgaWYgKGYuYWx0ZXJuYXRlICYmIGYuYmFzZSA9PSA4KSBidWZmZXIgKz0gJzAnO1xuICBpZiAoZi5hbHRlcm5hdGUgJiYgZi5iYXNlID09IDE2KSBidWZmZXIgKz0gZi51cHBlcmNhc2U/XCIwWFwiOlwiMHhcIjtcbiAgaWYgKGYuanVzdGlmeSA9PSAnKycgJiYgZi5maWxsZXIgPT0gJzAnKVxuICAgIGZvciAodmFyIGkgPSBsZW47IGkgPCBmLndpZHRoOyBpKyspIGJ1ZmZlciArPSAnMCc7XG4gIGJ1ZmZlciArPSByYXdidWZmZXI7XG4gIGlmIChmLmp1c3RpZnkgPT0gJy0nKVxuICAgIGZvciAodmFyIGkgPSBsZW47IGkgPCBmLndpZHRoOyBpKyspIGJ1ZmZlciArPSAnICc7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGJ1ZmZlcik7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczoganNvb19mbG9vcl9sb2cyXG52YXIgbG9nMl9vayA9IE1hdGgubG9nMiAmJiBNYXRoLmxvZzIoMS4xMjM1NTgyMDkyODg5NDc0RSszMDcpID09IDEwMjBcbmZ1bmN0aW9uIGpzb29fZmxvb3JfbG9nMih4KSB7XG4gIGlmKGxvZzJfb2spIHJldHVybiBNYXRoLmZsb29yKE1hdGgubG9nMih4KSlcbiAgdmFyIGkgPSAwO1xuICBpZiAoeCA9PSAwKSByZXR1cm4gLUluZmluaXR5O1xuICBpZih4Pj0xKSB7d2hpbGUgKHg+PTIpIHt4Lz0yOyBpKyt9IH1cbiAgZWxzZSB7d2hpbGUgKHggPCAxKSB7eCo9MjsgaS0tfSB9O1xuICByZXR1cm4gaTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBqc29vX2Zsb29yX2xvZzIsIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpXG5mdW5jdGlvbiBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQgKHgpIHtcbiAgaWYgKCFpc0Zpbml0ZSh4KSkge1xuICAgIGlmIChpc05hTih4KSlcbiAgICAgIHJldHVybiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaSgxLCAwLCAweDdmZjApO1xuICAgIGlmICh4ID4gMClcbiAgICAgIHJldHVybiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaSgwLCAwLCAweDdmZjApXG4gICAgZWxzZVxuICAgICAgcmV0dXJuIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpKDAsIDAsIDB4ZmZmMClcbiAgfVxuICB2YXIgc2lnbiA9ICh4PT0wICYmIDEveCA9PSAtSW5maW5pdHkpPzB4ODAwMDooeD49MCk/MDoweDgwMDA7XG4gIGlmIChzaWduKSB4ID0gLXg7XG4gIC8vIEludDY0LmJpdHNfb2ZfZmxvYXQgMS4xMjM1NTgyMDkyODg5NDc0RSszMDcgPSAweDdmYjAwMDAwMDAwMDAwMDBMXG4gIC8vIHVzaW5nIE1hdGguTE9HMkUqTWF0aC5sb2coeCkgaW4gcGxhY2Ugb2YgTWF0aC5sb2cyIHJlc3VsdCBpbiBwcmVjaXNpb24gbG9zdFxuICB2YXIgZXhwID0ganNvb19mbG9vcl9sb2cyKHgpICsgMTAyMztcbiAgaWYgKGV4cCA8PSAwKSB7XG4gICAgZXhwID0gMDtcbiAgICB4IC89IE1hdGgucG93KDIsLTEwMjYpO1xuICB9IGVsc2Uge1xuICAgIHggLz0gTWF0aC5wb3coMixleHAtMTAyNyk7XG4gICAgaWYgKHggPCAxNikge1xuICAgICAgeCAqPSAyOyBleHAgLT0xOyB9XG4gICAgaWYgKGV4cCA9PSAwKSB7XG4gICAgICB4IC89IDI7IH1cbiAgfVxuICB2YXIgayA9IE1hdGgucG93KDIsMjQpO1xuICB2YXIgcjMgPSB4fDA7XG4gIHggPSAoeCAtIHIzKSAqIGs7XG4gIHZhciByMiA9IHh8MDtcbiAgeCA9ICh4IC0gcjIpICogaztcbiAgdmFyIHIxID0geHwwO1xuICByMyA9IChyMyAmMHhmKSB8IHNpZ24gfCBleHAgPDwgNDtcbiAgcmV0dXJuIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpKHIxLCByMiwgcjMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGpzb29fZmxvb3JfbG9nMlxuZnVuY3Rpb24gY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0ICh4KSB7XG4gIHZhciBmbG9hdDMyYSA9IG5ldyBGbG9hdDMyQXJyYXkoMSk7XG4gIGZsb2F0MzJhWzBdID0geDtcbiAgdmFyIGludDMyYSA9IG5ldyBJbnQzMkFycmF5KGZsb2F0MzJhLmJ1ZmZlcik7XG4gIHJldHVybiBpbnQzMmFbMF0gfCAwO1xufVxuXG4vL0ZQIGxpdGVyYWxzIGNhbiBiZSB3cml0dGVuIHVzaW5nIHRoZSBoZXhhZGVjaW1hbFxuLy9ub3RhdGlvbiAweDxtYW50aXNzYSBpbiBoZXg+cDxleHBvbmVudD4gZnJvbSBJU08gQzk5LlxuLy9odHRwczovL2dpdGh1Yi5jb20vZGFua29nYWkvanMtaGV4ZmxvYXQvYmxvYi9tYXN0ZXIvaGV4ZmxvYXQuanNcbi8vUHJvdmlkZXM6IGNhbWxfaGV4c3RyaW5nX29mX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZywgY2FtbF9zdHJfcmVwZWF0XG5mdW5jdGlvbiBjYW1sX2hleHN0cmluZ19vZl9mbG9hdCAoeCwgcHJlYywgc3R5bGUpIHtcbiAgaWYgKCFpc0Zpbml0ZSh4KSkge1xuICAgIGlmIChpc05hTih4KSkgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKFwibmFuXCIpO1xuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyAoKHggPiAwKT9cImluZmluaXR5XCI6XCItaW5maW5pdHlcIik7XG4gIH1cbiAgdmFyIHNpZ24gPSAoeD09MCAmJiAxL3ggPT0gLUluZmluaXR5KT8xOih4Pj0wKT8wOjE7XG4gIGlmKHNpZ24pIHggPSAteDtcbiAgdmFyIGV4cCA9IDA7XG4gIGlmICh4ID09IDApIHsgfVxuICBlbHNlIGlmICh4IDwgMSkge1xuICAgIHdoaWxlICh4IDwgMSAmJiBleHAgPiAtMTAyMikgIHsgeCAqPSAyOyBleHAtLSB9XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHggPj0gMikgeyB4IC89IDI7IGV4cCsrIH1cbiAgfVxuICB2YXIgZXhwX3NpZ24gPSBleHAgPCAwID8gJycgOiAnKyc7XG4gIHZhciBzaWduX3N0ciA9ICcnO1xuICBpZiAoc2lnbikgc2lnbl9zdHIgPSAnLSdcbiAgZWxzZSB7XG4gICAgc3dpdGNoKHN0eWxlKXtcbiAgICBjYXNlIDQzIC8qICcrJyAqLzogc2lnbl9zdHIgPSAnKyc7IGJyZWFrO1xuICAgIGNhc2UgMzIgLyogJyAnICovOiBzaWduX3N0ciA9ICcgJzsgYnJlYWs7XG4gICAgZGVmYXVsdDogYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChwcmVjID49IDAgJiYgcHJlYyA8IDEzKSB7XG4gICAgLyogSWYgYSBwcmVjaXNpb24gaXMgZ2l2ZW4sIGFuZCBpcyBzbWFsbCwgcm91bmQgbWFudGlzc2EgYWNjb3JkaW5nbHkgKi9cbiAgICB2YXIgY3N0ID0gTWF0aC5wb3coMixwcmVjICogNCk7XG4gICAgeCA9IE1hdGgucm91bmQoeCAqIGNzdCkgLyBjc3Q7XG4gIH1cbiAgdmFyIHhfc3RyID0geC50b1N0cmluZygxNik7XG4gIGlmKHByZWMgPj0gMCl7XG4gICAgdmFyIGlkeCA9IHhfc3RyLmluZGV4T2YoJy4nKTtcbiAgICBpZihpZHg8MCkge1xuICAgICAgeF9zdHIgKz0gJy4nICsgY2FtbF9zdHJfcmVwZWF0KHByZWMsICcwJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHNpemUgPSBpZHgrMStwcmVjO1xuICAgICAgaWYoeF9zdHIubGVuZ3RoIDwgc2l6ZSlcbiAgICAgICAgeF9zdHIgKz0gY2FtbF9zdHJfcmVwZWF0KHNpemUgLSB4X3N0ci5sZW5ndGgsICcwJyk7XG4gICAgICBlbHNlXG4gICAgICAgIHhfc3RyID0geF9zdHIuc3Vic3RyKDAsc2l6ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyAoc2lnbl9zdHIgKyAnMHgnICsgeF9zdHIgKyAncCcgKyBleHBfc2lnbiArIGV4cC50b1N0cmluZygxMCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyAoeCkge1xuICB2YXIgbG8gPSB4LmxvO1xuICB2YXIgbWkgPSB4Lm1pO1xuICB2YXIgaGkgPSB4LmhpO1xuICB2YXIgZXhwID0gKGhpICYgMHg3ZmZmKSA+PiA0O1xuICBpZiAoZXhwID09IDIwNDcpIHtcbiAgICBpZiAoKGxvfG1pfChoaSYweGYpKSA9PSAwKVxuICAgICAgcmV0dXJuIChoaSAmIDB4ODAwMCk/KC1JbmZpbml0eSk6SW5maW5pdHk7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIE5hTjtcbiAgfVxuICB2YXIgayA9IE1hdGgucG93KDIsLTI0KTtcbiAgdmFyIHJlcyA9IChsbyprK21pKSprKyhoaSYweGYpO1xuICBpZiAoZXhwID4gMCkge1xuICAgIHJlcyArPSAxNjtcbiAgICByZXMgKj0gTWF0aC5wb3coMixleHAtMTAyNyk7XG4gIH0gZWxzZVxuICAgIHJlcyAqPSBNYXRoLnBvdygyLC0xMDI2KTtcbiAgaWYgKGhpICYgMHg4MDAwKSByZXMgPSAtIHJlcztcbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9uZXh0YWZ0ZXJfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cywgY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0LCBjYW1sX2ludDY0X2FkZCwgY2FtbF9pbnQ2NF9zdWIsY2FtbF9pbnQ2NF9vZl9pbnQzMlxuZnVuY3Rpb24gY2FtbF9uZXh0YWZ0ZXJfZmxvYXQgKHgseSkge1xuICBpZihpc05hTih4KSB8fCBpc05hTih5KSkgcmV0dXJuIE5hTjtcbiAgaWYoeD09eSkgcmV0dXJuIHk7XG4gIGlmKHg9PTApe1xuICAgIGlmKHkgPCAwKVxuICAgICAgcmV0dXJuIC1NYXRoLnBvdygyLCAtMTA3NClcbiAgICBlbHNlXG4gICAgICByZXR1cm4gTWF0aC5wb3coMiwgLTEwNzQpXG4gIH1cbiAgdmFyIGJpdHMgPSBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQoeCk7XG4gIHZhciBvbmUgPSBjYW1sX2ludDY0X29mX2ludDMyKDEpO1xuICBpZiAoKHg8eSkgPT0gKHg+MCkpXG4gICAgYml0cyA9IGNhbWxfaW50NjRfYWRkKGJpdHMsIG9uZSlcbiAgZWxzZVxuICAgIGJpdHMgPSBjYW1sX2ludDY0X3N1YihiaXRzLCBvbmUpXG4gIHJldHVybiBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMoYml0cyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdHJ1bmNfZmxvYXRcbmZ1bmN0aW9uIGNhbWxfdHJ1bmNfZmxvYXQoeCl7XG4gIHJldHVybiBNYXRoLnRydW5jKHgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHMgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50MzJfZmxvYXRfb2ZfYml0cyAoeCkge1xuICB2YXIgaW50MzJhID0gbmV3IEludDMyQXJyYXkoMSk7XG4gIGludDMyYVswXSA9IHg7XG4gIHZhciBmbG9hdDMyYSA9IG5ldyBGbG9hdDMyQXJyYXkoaW50MzJhLmJ1ZmZlcik7XG4gIHJldHVybiBmbG9hdDMyYVswXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jbGFzc2lmeV9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9jbGFzc2lmeV9mbG9hdCAoeCkge1xuICBpZiAoaXNGaW5pdGUgKHgpKSB7XG4gICAgaWYgKE1hdGguYWJzKHgpID49IDIuMjI1MDczODU4NTA3MjAxNGUtMzA4KSByZXR1cm4gMDtcbiAgICBpZiAoeCAhPSAwKSByZXR1cm4gMTtcbiAgICByZXR1cm4gMjtcbiAgfVxuICByZXR1cm4gaXNOYU4oeCk/NDozO1xufVxuLy9Qcm92aWRlczogY2FtbF9tb2RmX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX21vZGZfZmxvYXQgKHgpIHtcbiAgaWYgKGlzRmluaXRlICh4KSkge1xuICAgIHZhciBuZWcgPSAoMS94KSA8IDA7XG4gICAgeCA9IE1hdGguYWJzKHgpO1xuICAgIHZhciBpID0gTWF0aC5mbG9vciAoeCk7XG4gICAgdmFyIGYgPSB4IC0gaTtcbiAgICBpZiAobmVnKSB7IGkgPSAtaTsgZiA9IC1mOyB9XG4gICAgcmV0dXJuIFswLCBmLCBpXTtcbiAgfVxuICBpZiAoaXNOYU4gKHgpKSByZXR1cm4gWzAsIE5hTiwgTmFOXTtcbiAgcmV0dXJuIFswLCAxL3gsIHhdO1xufVxuLy9Qcm92aWRlczogY2FtbF9sZGV4cF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9sZGV4cF9mbG9hdCAoeCxleHApIHtcbiAgZXhwIHw9IDA7XG4gIGlmIChleHAgPiAxMDIzKSB7XG4gICAgZXhwIC09IDEwMjM7XG4gICAgeCAqPSBNYXRoLnBvdygyLCAxMDIzKTtcbiAgICBpZiAoZXhwID4gMTAyMykgeyAgLy8gaW4gY2FzZSB4IGlzIHN1Ym5vcm1hbFxuICAgICAgZXhwIC09IDEwMjM7XG4gICAgICB4ICo9IE1hdGgucG93KDIsIDEwMjMpO1xuICAgIH1cbiAgfVxuICBpZiAoZXhwIDwgLTEwMjMpIHtcbiAgICBleHAgKz0gMTAyMztcbiAgICB4ICo9IE1hdGgucG93KDIsIC0xMDIzKTtcbiAgfVxuICB4ICo9IE1hdGgucG93KDIsIGV4cCk7XG4gIHJldHVybiB4O1xufVxuLy9Qcm92aWRlczogY2FtbF9mcmV4cF9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczoganNvb19mbG9vcl9sb2cyXG5mdW5jdGlvbiBjYW1sX2ZyZXhwX2Zsb2F0ICh4KSB7XG4gIGlmICgoeCA9PSAwKSB8fCAhaXNGaW5pdGUoeCkpIHJldHVybiBbMCwgeCwgMF07XG4gIHZhciBuZWcgPSB4IDwgMDtcbiAgaWYgKG5lZykgeCA9IC0geDtcbiAgdmFyIGV4cCA9IE1hdGgubWF4KC0xMDIzLCBqc29vX2Zsb29yX2xvZzIoeCkgKyAxKTtcbiAgeCAqPSBNYXRoLnBvdygyLC1leHApO1xuICB3aGlsZSAoeCA8IDAuNSkge1xuICAgIHggKj0gMjtcbiAgICBleHAtLTtcbiAgfVxuICB3aGlsZSAoeCA+PSAxKSB7XG4gICAgeCAqPSAwLjU7XG4gICAgZXhwKys7XG4gIH1cbiAgaWYgKG5lZykgeCA9IC0geDtcbiAgcmV0dXJuIFswLCB4LCBleHBdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zsb2F0X2NvbXBhcmUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZmxvYXRfY29tcGFyZSAoeCwgeSkge1xuICBpZiAoeCA9PT0geSkgcmV0dXJuIDA7XG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xO1xuICBpZiAoeCA+IHkpIHJldHVybiAxO1xuICBpZiAoeCA9PT0geCkgcmV0dXJuIDE7XG4gIGlmICh5ID09PSB5KSByZXR1cm4gLTE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvcHlzaWduX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2NvcHlzaWduX2Zsb2F0ICh4LCB5KSB7XG4gIGlmICh5ID09IDApIHkgPSAxIC8geTtcbiAgeCA9IE1hdGguYWJzKHgpO1xuICByZXR1cm4gKHkgPCAwKT8oLXgpOng7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc2lnbmJpdF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9zaWduYml0X2Zsb2F0KHgpIHtcbiAgaWYgKHggPT0gMCkgeCA9IDEgLyB4O1xuICByZXR1cm4gKHggPCAwKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXhwbTFfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZXhwbTFfZmxvYXQgKHgpIHsgcmV0dXJuIE1hdGguZXhwbTEoeCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfZXhwMl9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9leHAyX2Zsb2F0KHgpIHsgcmV0dXJuIE1hdGgucG93KDIsIHgpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2xvZzFwX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2xvZzFwX2Zsb2F0KHgpIHsgcmV0dXJuIE1hdGgubG9nMXAoeCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfbG9nMl9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9sb2cyX2Zsb2F0KHgpIHsgcmV0dXJuIE1hdGgubG9nMih4KTsgfVxuLy9Qcm92aWRlczogY2FtbF9oeXBvdF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9oeXBvdF9mbG9hdCAoeCwgeSkgeyByZXR1cm4gTWF0aC5oeXBvdCh4LCB5KTsgfVxuLy9Qcm92aWRlczogY2FtbF9sb2cxMF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9sb2cxMF9mbG9hdCAoeCkgeyByZXR1cm4gTWF0aC5sb2cxMCh4KTsgfVxuLy9Qcm92aWRlczogY2FtbF9jb3NoX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2Nvc2hfZmxvYXQgKHgpIHsgcmV0dXJuIE1hdGguY29zaCh4KTsgfVxuLy9Qcm92aWRlczogY2FtbF9hY29zaF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9hY29zaF9mbG9hdCAoeCkgeyByZXR1cm4gTWF0aC5hY29zaCh4KTsgfVxuLy9Qcm92aWRlczogY2FtbF9zaW5oX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX3NpbmhfZmxvYXQgKHgpIHsgcmV0dXJuIE1hdGguc2luaCh4KTsgfVxuLy9Qcm92aWRlczogY2FtbF9hc2luaF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9hc2luaF9mbG9hdCAoeCkgeyByZXR1cm4gTWF0aC5hc2luaCh4KTsgfVxuLy9Qcm92aWRlczogY2FtbF90YW5oX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX3RhbmhfZmxvYXQgKHgpIHsgcmV0dXJuIE1hdGgudGFuaCh4KTsgfVxuLy9Qcm92aWRlczogY2FtbF9hdGFuaF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9hdGFuaF9mbG9hdCAoeCkgeyByZXR1cm4gTWF0aC5hdGFuaCh4KTsgfVxuLy9Qcm92aWRlczogY2FtbF9yb3VuZF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9yb3VuZF9mbG9hdCAoeCkgeyByZXR1cm4gTWF0aC5yb3VuZCh4KTsgfVxuLy9Qcm92aWRlczogY2FtbF9jYnJ0X2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2NicnRfZmxvYXQgKHgpIHsgcmV0dXJuIE1hdGguY2JydCh4KTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VyZl9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9lcmZfZmxvYXQoeCkge1xuICB2YXIgYTEgPSAwLjI1NDgyOTU5MjtcbiAgdmFyIGEyID0gLTAuMjg0NDk2NzM2O1xuICB2YXIgYTMgPSAxLjQyMTQxMzc0MTtcbiAgdmFyIGE0ID0gLTEuNDUzMTUyMDI3O1xuICB2YXIgYTUgPSAxLjA2MTQwNTQyOTtcbiAgdmFyIHAgPSAwLjMyNzU5MTE7XG5cbiAgdmFyIHNpZ24gPSAxO1xuICBpZiAoeCA8IDApIHtcbiAgICBzaWduID0gLTE7XG4gIH1cbiAgeCA9IE1hdGguYWJzKHgpO1xuICB2YXIgdCA9IDEuMCAvICgxLjAgKyBwICogeCk7XG4gIHZhciB5ID0gMS4wIC0gKCgoKGE1ICogdCArIGE0KSAqIHQgKyBhMykgKiB0ICsgYTIpICogdCArIGExKSAqIHQgKiBNYXRoLmV4cCgteCAqIHgpO1xuXG4gIHJldHVybiBzaWduICogeTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcmZjX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2VyZl9mbG9hdFxuZnVuY3Rpb24gY2FtbF9lcmZjX2Zsb2F0KHgpIHtcbiAgcmV0dXJuIDEgLSBjYW1sX2VyZl9mbG9hdCh4KTtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZtYV9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9mbWFfZmxvYXQoeCwgeSwgeikge1xuICB2YXIgU1BMSVQgPSBNYXRoLnBvdygyLCAyNykgKyAxO1xuICB2YXIgTUlOX1ZBTFVFID0gTWF0aC5wb3coMiwgLTEwMjIpO1xuICB2YXIgRVBTSUxPTiA9IE1hdGgucG93KDIsIC01Mik7XG4gIHZhciBDID0gNDE2O1xuICB2YXIgQSA9IE1hdGgucG93KDIsICtDKTtcbiAgdmFyIEIgPSBNYXRoLnBvdygyLCAtQyk7XG5cbiAgZnVuY3Rpb24gbXVsdGlwbHkgKGEsIGIpIHtcbiAgICB2YXIgYXQgPSBTUExJVCAqIGE7XG4gICAgdmFyIGFoaSA9IGF0IC0gKGF0IC0gYSk7XG4gICAgdmFyIGFsbyA9IGEgLSBhaGk7XG4gICAgdmFyIGJ0ID0gU1BMSVQgKiBiO1xuICAgIHZhciBiaGkgPSBidCAtIChidCAtIGIpO1xuICAgIHZhciBibG8gPSBiIC0gYmhpO1xuICAgIHZhciBwID0gYSAqIGI7XG4gICAgdmFyIGUgPSAoKGFoaSAqIGJoaSAtIHApICsgYWhpICogYmxvICsgYWxvICogYmhpKSArIGFsbyAqIGJsbztcbiAgICByZXR1cm4ge1xuICAgICAgcDogcCxcbiAgICAgIGU6IGVcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIGFkZCAoYSwgYikge1xuICAgIHZhciBzID0gYSArIGI7XG4gICAgdmFyIHYgPSBzIC0gYTtcbiAgICB2YXIgZSA9IChhIC0gKHMgLSB2KSkgKyAoYiAtIHYpO1xuICAgIHJldHVybiB7XG4gICAgICBzOiBzLFxuICAgICAgZTogZVxuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gYWRqdXN0ICh4LCB5KSB7XG4gICAgcmV0dXJuIHggIT09IDAgJiYgeSAhPT0gMCAmJiBTUExJVCAqIHggLSAoU1BMSVQgKiB4IC0geCkgPT09IHggPyB4ICogKDEgKyAoeCA8IDAgPyAtMSA6ICsxKSAqICh5IDwgMCA/IC0xIDogKzEpICogRVBTSUxPTikgOiB4O1xuICB9O1xuXG4gIGlmICh4ID09PSAwIHx8IHggIT09IHggfHwgeCA9PT0gKzEgLyAwIHx8IHggPT09IC0xIC8gMCB8fFxuICAgICAgeSA9PT0gMCB8fCB5ICE9PSB5IHx8IHkgPT09ICsxIC8gMCB8fCB5ID09PSAtMSAvIDApIHtcbiAgICByZXR1cm4geCAqIHkgKyB6O1xuICB9XG4gIGlmICh6ID09PSAwKSB7XG4gICAgcmV0dXJuIHggKiB5O1xuICB9XG4gIGlmICh6ICE9PSB6IHx8IHogPT09ICsxIC8gMCB8fCB6ID09PSAtMSAvIDApIHtcbiAgICByZXR1cm4gejtcbiAgfVxuXG4gIHZhciBzY2FsZSA9IDE7XG4gIHdoaWxlIChNYXRoLmFicyh4KSA+IEEpIHtcbiAgICBzY2FsZSAqPSBBO1xuICAgIHggKj0gQjtcbiAgfVxuICB3aGlsZSAoTWF0aC5hYnMoeSkgPiBBKSB7XG4gICAgc2NhbGUgKj0gQTtcbiAgICB5ICo9IEI7XG4gIH1cbiAgaWYgKHNjYWxlID09PSAxIC8gMCkge1xuICAgIHJldHVybiB4ICogeSAqIHNjYWxlO1xuICB9XG4gIHdoaWxlIChNYXRoLmFicyh4KSA8IEIpIHtcbiAgICBzY2FsZSAqPSBCO1xuICAgIHggKj0gQTtcbiAgfVxuICB3aGlsZSAoTWF0aC5hYnMoeSkgPCBCKSB7XG4gICAgc2NhbGUgKj0gQjtcbiAgICB5ICo9IEE7XG4gIH1cbiAgaWYgKHNjYWxlID09PSAwKSB7XG4gICAgcmV0dXJuIHo7XG4gIH1cblxuICB2YXIgeHMgPSB4O1xuICB2YXIgeXMgPSB5O1xuICB2YXIgenMgPSB6IC8gc2NhbGU7XG5cbiAgaWYgKE1hdGguYWJzKHpzKSA+IE1hdGguYWJzKHhzICogeXMpICogNCAvIEVQU0lMT04pIHtcbiAgICByZXR1cm4gejtcbiAgfVxuICBpZiAoTWF0aC5hYnMoenMpIDwgTWF0aC5hYnMoeHMgKiB5cykgKiBFUFNJTE9OIC8gNCAqIEVQU0lMT04gLyA0KSB7XG4gICAgenMgPSAoeiA8IDAgPyAtMSA6ICsxKSAqIE1JTl9WQUxVRTtcbiAgfVxuXG4gIHZhciB4eSA9IG11bHRpcGx5KHhzLCB5cyk7XG4gIHZhciBzID0gYWRkKHh5LnAsIHpzKTtcbiAgdmFyIHUgPSBhZGQoeHkuZSwgcy5lKTtcbiAgdmFyIGkgPSBhZGQocy5zLCB1LnMpO1xuXG4gIHZhciBmID0gaS5zICsgYWRqdXN0KGkuZSwgdS5lKTtcbiAgaWYgKGYgPT09IDApIHtcbiAgICByZXR1cm4gZjtcbiAgfVxuXG4gIHZhciBmcyA9IGYgKiBzY2FsZTtcbiAgaWYgKE1hdGguYWJzKGZzKSA+IE1JTl9WQUxVRSkge1xuICAgIHJldHVybiBmcztcbiAgfVxuXG4gIC8vIEl0IGlzIHBvc3NpYmxlIHRoYXQgdGhlcmUgd2FzIGV4dHJhIHJvdW5kaW5nIGZvciBhIGRlbm9ybWFsaXplZCB2YWx1ZS5cbiAgcmV0dXJuIGZzICsgYWRqdXN0KGYgLSBmcyAvIHNjYWxlLCBpLmUpICogc2NhbGU7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZm9ybWF0X2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3BhcnNlX2Zvcm1hdCwgY2FtbF9maW5pc2hfZm9ybWF0dGluZ1xuZnVuY3Rpb24gY2FtbF9mb3JtYXRfZmxvYXQgKGZtdCwgeCkge1xuICBmdW5jdGlvbiB0b0ZpeGVkKHgsZHApIHtcbiAgICBpZiAoTWF0aC5hYnMoeCkgPCAxLjApIHtcbiAgICAgIHJldHVybiB4LnRvRml4ZWQoZHApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZSA9IHBhcnNlSW50KHgudG9TdHJpbmcoKS5zcGxpdCgnKycpWzFdKTtcbiAgICAgIGlmIChlID4gMjApIHtcbiAgICAgICAgZSAtPSAyMDtcbiAgICAgICAgeCAvPSBNYXRoLnBvdygxMCxlKTtcbiAgICAgICAgeCArPSAobmV3IEFycmF5KGUrMSkpLmpvaW4oJzAnKTtcbiAgICAgICAgaWYoZHAgPiAwKSB7XG4gICAgICAgICAgeCA9IHggKyAnLicgKyAobmV3IEFycmF5KGRwKzEpKS5qb2luKCcwJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHg7XG4gICAgICB9XG4gICAgICBlbHNlIHJldHVybiB4LnRvRml4ZWQoZHApXG4gICAgfVxuICB9XG4gIHZhciBzLCBmID0gY2FtbF9wYXJzZV9mb3JtYXQoZm10KTtcbiAgdmFyIHByZWMgPSAoZi5wcmVjIDwgMCk/NjpmLnByZWM7XG4gIGlmICh4IDwgMCB8fCAoeCA9PSAwICYmIDEveCA9PSAtSW5maW5pdHkpKSB7IGYuc2lnbiA9IC0xOyB4ID0gLXg7IH1cbiAgaWYgKGlzTmFOKHgpKSB7IHMgPSBcIm5hblwiOyBmLmZpbGxlciA9ICcgJzsgfVxuICBlbHNlIGlmICghaXNGaW5pdGUoeCkpIHsgcyA9IFwiaW5mXCI7IGYuZmlsbGVyID0gJyAnOyB9XG4gIGVsc2VcbiAgICBzd2l0Y2ggKGYuY29udikge1xuICAgIGNhc2UgJ2UnOlxuICAgICAgdmFyIHMgPSB4LnRvRXhwb25lbnRpYWwocHJlYyk7XG4gICAgICAvLyBleHBvbmVudCBzaG91bGQgYmUgYXQgbGVhc3QgdHdvIGRpZ2l0c1xuICAgICAgdmFyIGkgPSBzLmxlbmd0aDtcbiAgICAgIGlmIChzLmNoYXJBdChpIC0gMykgPT0gJ2UnKVxuICAgICAgICBzID0gcy5zbGljZSAoMCwgaSAtIDEpICsgJzAnICsgcy5zbGljZSAoaSAtIDEpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZic6XG4gICAgICBzID0gdG9GaXhlZCh4LCBwcmVjKTsgYnJlYWs7XG4gICAgY2FzZSAnZyc6XG4gICAgICBwcmVjID0gcHJlYz9wcmVjOjE7XG4gICAgICBzID0geC50b0V4cG9uZW50aWFsKHByZWMgLSAxKTtcbiAgICAgIHZhciBqID0gcy5pbmRleE9mKCdlJyk7XG4gICAgICB2YXIgZXhwID0gK3Muc2xpY2UoaiArIDEpO1xuICAgICAgaWYgKGV4cCA8IC00IHx8IHggPj0gMWUyMSB8fCB4LnRvRml4ZWQoMCkubGVuZ3RoID4gcHJlYykge1xuICAgICAgICAvLyByZW1vdmUgdHJhaWxpbmcgemVyb2VzXG4gICAgICAgIHZhciBpID0gaiAtIDE7IHdoaWxlIChzLmNoYXJBdChpKSA9PSAnMCcpIGktLTtcbiAgICAgICAgaWYgKHMuY2hhckF0KGkpID09ICcuJykgaS0tO1xuICAgICAgICBzID0gcy5zbGljZSgwLCBpICsgMSkgKyBzLnNsaWNlKGopO1xuICAgICAgICBpID0gcy5sZW5ndGg7XG4gICAgICAgIGlmIChzLmNoYXJBdChpIC0gMykgPT0gJ2UnKVxuICAgICAgICAgIHMgPSBzLnNsaWNlICgwLCBpIC0gMSkgKyAnMCcgKyBzLnNsaWNlIChpIC0gMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHAgPSBwcmVjO1xuICAgICAgICBpZiAoZXhwIDwgMCkgeyBwIC09IGV4cCArIDE7IHMgPSB4LnRvRml4ZWQocCk7IH1cbiAgICAgICAgZWxzZSB3aGlsZSAocyA9IHgudG9GaXhlZChwKSwgcy5sZW5ndGggPiBwcmVjICsgMSkgcC0tO1xuICAgICAgICBpZiAocCkge1xuICAgICAgICAgIC8vIHJlbW92ZSB0cmFpbGluZyB6ZXJvZXNcbiAgICAgICAgICB2YXIgaSA9IHMubGVuZ3RoIC0gMTsgd2hpbGUgKHMuY2hhckF0KGkpID09ICcwJykgaS0tO1xuICAgICAgICAgIGlmIChzLmNoYXJBdChpKSA9PSAnLicpIGktLTtcbiAgICAgICAgICBzID0gcy5zbGljZSgwLCBpICsgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgcmV0dXJuIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmcoZiwgcyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmxvYXRfb2Zfc3RyaW5nIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGgsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZmxvYXRfb2Zfc3RyaW5nKHMpIHtcbiAgdmFyIHJlcztcbiAgcyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcocylcbiAgcmVzID0gK3M7XG4gIGlmICgocy5sZW5ndGggPiAwKSAmJiAocmVzID09PSByZXMpKSByZXR1cm4gcmVzO1xuICBzID0gcy5yZXBsYWNlKC9fL2csXCJcIik7XG4gIHJlcyA9ICtzO1xuICBpZiAoKChzLmxlbmd0aCA+IDApICYmIChyZXMgPT09IHJlcykpIHx8IC9eWystXT9uYW4kL2kudGVzdChzKSkgcmV0dXJuIHJlcztcbiAgdmFyIG0gPSAvXiAqKFsrLV0/KTB4KFswLTlhLWZdKylcXC4/KFswLTlhLWZdKikocChbKy1dP1swLTldKykpPy9pLmV4ZWMocyk7XG4gIC8vICAgICAgICAgIDEgICAgICAgIDIgICAgICAgICAgICAgMyAgICAgICAgICAgNVxuICBpZihtKXtcbiAgICB2YXIgbTMgPSBtWzNdLnJlcGxhY2UoLzArJC8sJycpO1xuICAgIHZhciBtYW50aXNzYSA9IHBhcnNlSW50KG1bMV0gKyBtWzJdICsgbTMsIDE2KTtcbiAgICB2YXIgZXhwb25lbnQgPSAobVs1XXwwKSAtIDQqbTMubGVuZ3RoO1xuICAgIHJlcyA9IG1hbnRpc3NhICogTWF0aC5wb3coMiwgZXhwb25lbnQpO1xuICAgIHJldHVybiByZXM7XG4gIH1cbiAgaWYoL15cXCs/aW5mKGluaXR5KT8kL2kudGVzdChzKSkgcmV0dXJuIEluZmluaXR5O1xuICBpZigvXi1pbmYoaW5pdHkpPyQvaS50ZXN0KHMpKSByZXR1cm4gLUluZmluaXR5O1xuICBjYW1sX2ZhaWx3aXRoKFwiZmxvYXRfb2Zfc3RyaW5nXCIpO1xufVxuIiwiLypcblRvIGRlYWwgd2l0aCBlZmZlY3RzLCB0aGUgZXhlY3V0aW9uIGNvbnRleHQgaXMgaW50dWl0aXZlbHkgY29tcG9zZWQgb2ZcbmEgc3RhY2sgb2YgZmliZXJzLiBFYWNoIGZpYmVyIGhhcyBhIGN1cnJlbnQgbG93LWxldmVsIGNvbnRpbnVhdGlvblxuKG9uZS1hcmd1bWVudCBKYXZhU2NyaXB0IGZ1bmN0aW9uKSwgYSBzdGFjayBvZiBleGNlcHRpb24gaGFuZGxlcnMgYW5kXG5hIHRyaXBsZSBvZiBoYW5kbGVycywgd2hpY2ggYXJlIGludm9rZWQgd2hlbiB0aGUgZmliZXIgdGVybWluYXRlc1xuKGVpdGhlciB3aXRoIGEgdmFsdWUgb3IgYW4gZXhjZXB0aW9uKSBvciB3aGVuIGFuIGVmZmVjdCBpcyBwZXJmb3JtZWQuXG5UaGUgbG93LWxldmVsIGNvbnRpbnVhdGlvbiBvZiB0aGUgdG9wbW9zdCBmaWJlciAod2hpY2ggaXMgY3VycmVudGx5XG5leGVjdXRpbmcpIGlzIHBhc3NlZCBmcm9tIGZ1bmN0aW9uIHRvIGZ1bmN0aW9uIGFzIGFuIGFkZGl0aW9uYWxcbmFyZ3VtZW50LiBJdHMgc3RhY2sgb2YgZXhjZXB0aW9uIGhhbmRsZXJzIGlzIHN0b3JlZCBpblxuW2NhbWxfZXhuX3N0YWNrXS4gRXhjZXB0aW9uIGhhbmRsZXJzIGFyZSBwdXNoZWQgaW50byB0aGlzIHN0YWNrIHdoZW5cbmVudGVyaW5nIGEgW3RyeSAuLi4gd2l0aCAuLi5dIGFuZCBwb3BwZWQgb24gZXhpdC4gVGhlbiwgaGFuZGxlcnMgYW5kXG50aGUgcmVtYWluaW5nIGZpYmVycyBhcmUgc3RvcmVkIGluIFtjYW1sX2ZpYmVyX3N0YWNrXS4gVG8gaW5zdGFsbCBhblxuZWZmZWN0IGhhbmRsZXIsIHdlIHB1c2ggYSBuZXcgZmliZXIgaW50byB0aGUgZXhlY3V0aW9uIGNvbnRleHQuXG5cbldlIGhhdmUgYmFzaWNhbGx5IHRoZSBmb2xsb3dpbmcgdHlwZSBmb3IgcmVpZmllZCBjb250aW51YXRpb25zICh0eXBlXG5bY29udGludWF0aW9uXSBpbiBtb2R1bGUgW0VmZmVjdF0gb2YgdGhlIHN0YW5kYXJkIGxpYnJhcnkpOlxuXG4gIHR5cGUgKCdhLCAnYikgY29udGludWF0aW9uID0gKCdhLCAnYikgc3RhY2sgcmVmXG5cbiAgYW5kIChfLCBfKSBzdGFjayA9XG4gICAgICBDb25zIDogKCdiIC0+IHVuaXQpICogICAgICAgICAgICAgKCogbG93LWxldmVsIGNvbnRpbnVhdGlvbiAqKVxuICAgICAgICAgICAgIChleG4gLT4gdW5pdCkgbGlzdCAqICAgICAgICgqIGV4Y2VwdGlvbiBoYW5kbGVycyAqKVxuICAgICAgICAgICAgICgnYiwgJ2MpIGhhbmRsZXIgKlxuICAgICAgICAgICAgICgnYSwgJ2IpIHN0YWNrXG4gICAgICAgICAgICAgLT4gKCdhLCAnYykgc3RhY2tcbiAgICB8IEVtcHR5IDogKCdhLCAnYSkgc3RhY2tcblxuICBhbmQgKCdhLCdiKSBoYW5kbGVyID0gICAoKiBBcyBpbiBtb2R1bGUgRWZmZWN0IGZyb20gdGhlIHN0YW5kYXJkIGxpYnJhcnkgKilcbiAgICB7IHJldGM6ICdhIC0+ICdiO1xuICAgICAgZXhuYzogZXhuIC0+ICdiO1xuICAgICAgZWZmYzogJ2MuJ2MgRWZmZWN0LnQgLT4gKCgnYywnYikgY29udGludWF0aW9uIC0+ICdiKSBvcHRpb24gfVxuXG5Db250aW51YXRpb25zIGFyZSBvbmUtc2hvdC4gQSBjb250aW51YXRpb24gW3JlZiBFbXB0eV0gaGFzIGFscmVhZHlcbmJlZW4gcmVzdW1lZC5cblxuQSBjb250aW51YXRpb24gaXMgYmFzaWNhbGx5IGNvbXBvc2VkIG9mIGEgbGlzdCBvZiBmaWJlcnMsIHdoaWNoIGVhY2hcbmhhcyBpdHMgbG93LWxldmVsIGNvbnRpbnVhdGlvbiwgaXRzIHN0YWNrIG9mIGV4Y2VwdGlvbiBoYW5kbGVycyBhbmQgYVxudHJpcGxlIG9mIGhhbmRsZXJzIHRvIGRlYWwgd2l0aCB3aGVuIHRoZSBmaWJlciB0ZXJtaW5hdGVzIG9yIGFuXG5lZmZlY3QgaXMgcGVyZm9ybWVkLiBXaGVuIHJlc3VtaW5nIGEgY29udGludWF0aW9uLCB0aGUgaW5uZXJtb3N0IGZpYmVyXG5pcyByZXN1bWVkIGZpcnN0LlxuXG5UaGUgaGFuZGxlcnMgYXJlIENQUy10cmFuc2Zvcm1lZCBmdW5jdGlvbnM6IHRoZXkgYWN0dWFsbHkgdGFrZSBhblxuYWRkaXRpb25hbCBwYXJhbWV0ZXIgd2hpY2ggaXMgdGhlIGN1cnJlbnQgbG93LWxldmVsIGNvbnRpbnVhdGlvbi5cbiovXG5cbi8vUHJvdmlkZXM6IGNhbWxfZXhuX3N0YWNrXG4vL0lmOiBlZmZlY3RzXG4vLyBUaGlzIGlzIGFuIE9DYW1sIGxpc3Qgb2YgZXhjZXB0aW9uIGhhbmRsZXJzXG52YXIgY2FtbF9leG5fc3RhY2sgPSAwO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3B1c2hfdHJhcFxuLy9SZXF1aXJlczogY2FtbF9leG5fc3RhY2tcbi8vSWY6IGVmZmVjdHNcbmZ1bmN0aW9uIGNhbWxfcHVzaF90cmFwKGhhbmRsZXIpIHtcbiAgY2FtbF9leG5fc3RhY2s9WzAsaGFuZGxlcixjYW1sX2V4bl9zdGFja107XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcG9wX3RyYXBcbi8vUmVxdWlyZXM6IGNhbWxfZXhuX3N0YWNrXG4vL0lmOiBlZmZlY3RzXG5mdW5jdGlvbiBjYW1sX3BvcF90cmFwKCkge1xuICBpZiAoIWNhbWxfZXhuX3N0YWNrKSByZXR1cm4gZnVuY3Rpb24oeCl7dGhyb3cgeDt9XG4gIHZhciBoID0gY2FtbF9leG5fc3RhY2tbMV07XG4gIGNhbWxfZXhuX3N0YWNrPWNhbWxfZXhuX3N0YWNrWzJdO1xuICByZXR1cm4gaFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZpYmVyX3N0YWNrXG4vL0lmOiBlZmZlY3RzXG4vLyBUaGlzIGhhcyB0aGUgc2hhcGUge2gsIHI6e2ssIHgsIGV9fSB3aGVyZSBoIGlzIGEgdHJpcGxlIG9mIGhhbmRsZXJzXG4vLyAoc2VlIGVmZmVjdC5qcykgYW5kIGssIHggYW5kIGUgYXJlIHRoZSBzYXZlZCBjb250aW51YXRpb24sXG4vLyBleGNlcHRpb24gc3RhY2sgYW5kIGZpYmVyIHN0YWNrIG9mIHRoZSBwYXJlbnQgZmliZXIuXG52YXIgY2FtbF9maWJlcl9zdGFjaztcblxuLy9Qcm92aWRlczpjYW1sX3Jlc3VtZV9zdGFja1xuLy9SZXF1aXJlczogY2FtbF9uYW1lZF92YWx1ZSwgY2FtbF9yYWlzZV9jb25zdGFudCwgY2FtbF9leG5fc3RhY2ssIGNhbWxfZmliZXJfc3RhY2tcbi8vSWY6IGVmZmVjdHNcbmZ1bmN0aW9uIGNhbWxfcmVzdW1lX3N0YWNrKHN0YWNrLCBrKSB7XG4gIGlmICghc3RhY2spIGNhbWxfcmFpc2VfY29uc3RhbnRcbiAgICAgICAgICAgICAgICAgKGNhbWxfbmFtZWRfdmFsdWUoXCJFZmZlY3QuQ29udGludWF0aW9uX2FscmVhZHlfcmVzdW1lZFwiKSk7XG4gIC8vIFVwZGF0ZSB0aGUgZXhlY3V0aW9uIGNvbnRleHQgd2l0aCB0aGUgc3RhY2sgb2YgZmliZXJzIGluIFtzdGFja10gaW5cbiAgLy8gb3JkZXIgdG8gcmVzdW1lIHRoZSBjb250aW51YXRpb25cbiAgZG8ge1xuICAgIGNhbWxfZmliZXJfc3RhY2sgPVxuICAgICAge2g6c3RhY2tbM10sIHI6e2s6aywgeDpjYW1sX2V4bl9zdGFjaywgZTpjYW1sX2ZpYmVyX3N0YWNrfX07XG4gICAgayA9IHN0YWNrWzFdO1xuICAgIGNhbWxfZXhuX3N0YWNrID0gc3RhY2tbMl07XG4gICAgc3RhY2sgPSBzdGFja1s0XTtcbiAgfSB3aGlsZSAoc3RhY2spXG4gIHJldHVybiBrO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3BvcF9maWJlclxuLy9SZXF1aXJlczogY2FtbF9leG5fc3RhY2ssIGNhbWxfZmliZXJfc3RhY2tcbi8vSWY6IGVmZmVjdHNcbmZ1bmN0aW9uIGNhbWxfcG9wX2ZpYmVyKCkge1xuICAvLyBNb3ZlIHRvIHRoZSBwYXJlbnQgZmliZXIsIHJldHVybmluZyB0aGUgcGFyZW50J3MgbG93LWxldmVsIGNvbnRpbnVhdGlvblxuICB2YXIgcmVtID0gY2FtbF9maWJlcl9zdGFjay5yO1xuICBjYW1sX2V4bl9zdGFjayA9IHJlbS54O1xuICBjYW1sX2ZpYmVyX3N0YWNrID0gcmVtLmU7XG4gIHJldHVybiByZW0uaztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9wZXJmb3JtX2VmZmVjdFxuLy9SZXF1aXJlczogY2FtbF9wb3BfZmliZXIsIGNhbWxfc3RhY2tfY2hlY2tfZGVwdGgsIGNhbWxfdHJhbXBvbGluZV9yZXR1cm4sIGNhbWxfZXhuX3N0YWNrLCBjYW1sX2ZpYmVyX3N0YWNrXG4vL0lmOiBlZmZlY3RzXG5mdW5jdGlvbiBjYW1sX3BlcmZvcm1fZWZmZWN0KGVmZiwgY29udCwgazApIHtcbiAgLy8gQWxsb2NhdGUgYSBjb250aW51YXRpb24gaWYgd2UgZG9uJ3QgYWxyZWFkeSBoYXZlIG9uZVxuICBpZiAoIWNvbnQpIGNvbnQgPSBbMjQ1IC8qY29udGludWF0aW9uKi8sIDBdO1xuICAvLyBHZXQgY3VycmVudCBlZmZlY3QgaGFuZGxlclxuICB2YXIgaGFuZGxlciA9IGNhbWxfZmliZXJfc3RhY2suaFszXTtcbiAgLy8gQ29ucyB0aGUgY3VycmVudCBmaWJlciBvbnRvIHRoZSBjb250aW51YXRpb246XG4gIC8vICAgY29udCA6PSBDb25zIChrLCBleG5fc3RhY2ssIGhhbmRsZXJzLCAhY29udClcbiAgY29udFsxXSA9IFswLGswLGNhbWxfZXhuX3N0YWNrLGNhbWxfZmliZXJfc3RhY2suaCxjb250WzFdXTtcbiAgLy8gTW92ZSB0byBwYXJlbnQgZmliZXIgYW5kIGV4ZWN1dGUgdGhlIGVmZmVjdCBoYW5kbGVyIHRoZXJlXG4gIC8vIFRoZSBoYW5kbGVyIGlzIGRlZmluZWQgaW4gU3RkbGliLkVmZmVjdCwgc28gd2Uga25vdyB0aGF0IHRoZSBhcml0eSBtYXRjaGVzXG4gIHZhciBrMSA9IGNhbWxfcG9wX2ZpYmVyKCk7XG4gIHJldHVybiBjYW1sX3N0YWNrX2NoZWNrX2RlcHRoKCk/aGFuZGxlcihlZmYsY29udCxrMSxrMSlcbiAgICAgICAgIDpjYW1sX3RyYW1wb2xpbmVfcmV0dXJuKGhhbmRsZXIsW2VmZixjb250LGsxLGsxXSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYWxsb2Nfc3RhY2tcbi8vUmVxdWlyZXM6IGNhbWxfcG9wX2ZpYmVyLCBjYW1sX2ZpYmVyX3N0YWNrLCBjYW1sX2NhbGxfZ2VuXG4vL0lmOiBlZmZlY3RzXG5mdW5jdGlvbiBjYW1sX2FsbG9jX3N0YWNrKGh2LCBoeCwgaGYpIHtcbiAgZnVuY3Rpb24gaHZhbCh4KSB7XG4gICAgLy8gQ2FsbCBbaHZdIGluIHRoZSBwYXJlbnQgZmliZXJcbiAgICB2YXIgZj1jYW1sX2ZpYmVyX3N0YWNrLmhbMV07XG4gICAgdmFyIGs9Y2FtbF9wb3BfZmliZXIoKTtcbiAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLCBbeCwga10pO1xuICB9XG4gIGZ1bmN0aW9uIGhleG4oZSkge1xuICAgIC8vIENhbGwgW2h4XSBpbiB0aGUgcGFyZW50IGZpYmVyXG4gICAgdmFyIGY9Y2FtbF9maWJlcl9zdGFjay5oWzJdO1xuICAgIHZhciBrPWNhbWxfcG9wX2ZpYmVyKCk7XG4gICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZiwgW2UsIGtdKTtcbiAgfVxuICByZXR1cm4gWzAsIGh2YWwsIFswLCBoZXhuLCAwXSwgWzAsIGh2LCBoeCwgaGZdLCAwXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hbGxvY19zdGFja1xuLy9JZjogIWVmZmVjdHNcbmZ1bmN0aW9uIGNhbWxfYWxsb2Nfc3RhY2soaHYsIGh4LCBoZikge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jb250aW51YXRpb25fdXNlX25vZXhjXG5mdW5jdGlvbiBjYW1sX2NvbnRpbnVhdGlvbl91c2Vfbm9leGMoY29udCkge1xuICB2YXIgc3RhY2s9Y29udFsxXTtcbiAgY29udFsxXT0wO1xuICByZXR1cm4gc3RhY2s7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29udGludWF0aW9uX3VzZV9hbmRfdXBkYXRlX2hhbmRsZXJfbm9leGNcbi8vUmVxdWlyZXM6IGNhbWxfY29udGludWF0aW9uX3VzZV9ub2V4Y1xuZnVuY3Rpb24gY2FtbF9jb250aW51YXRpb25fdXNlX2FuZF91cGRhdGVfaGFuZGxlcl9ub2V4Yyhjb250LCBodmFsLCBoZXhuLCBoZWZmKSB7XG4gIHZhciBzdGFjayA9IGNhbWxfY29udGludWF0aW9uX3VzZV9ub2V4Yyhjb250KTtcbiAgc3RhY2tbM10gPSBbMCwgaHZhbCwgaGV4biwgaGVmZl07XG4gIHJldHVybiBzdGFjaztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9nZXRfY29udGludWF0aW9uX2NhbGxzdGFja1xuZnVuY3Rpb24gY2FtbF9nZXRfY29udGludWF0aW9uX2NhbGxzdGFjayAoKSB7IHJldHVybiBbMF07IH1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9jb25kaXRpb25fbmV3XG5mdW5jdGlvbiBjYW1sX21sX2NvbmRpdGlvbl9uZXcodW5pdCl7XG4gICAgcmV0dXJuIHtjb25kaXRpb246MX07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY29uZGl0aW9uX3dhaXRcbmZ1bmN0aW9uIGNhbWxfbWxfY29uZGl0aW9uX3dhaXQodCxtdXRleHQpe1xuICAgIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2NvbmRpdGlvbl9icm9hZGNhc3RcbmZ1bmN0aW9uIGNhbWxfbWxfY29uZGl0aW9uX2Jyb2FkY2FzdCh0KXtcbiAgICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9jb25kaXRpb25fc2lnbmFsXG5mdW5jdGlvbiBjYW1sX21sX2NvbmRpdGlvbl9zaWduYWwodCl7XG4gICAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGpzb29fZWZmZWN0X25vdF9zdXBwb3J0ZWRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vIUlmOiBlZmZlY3RzXG5mdW5jdGlvbiBqc29vX2VmZmVjdF9ub3Rfc3VwcG9ydGVkKCl7XG4gIGNhbWxfZmFpbHdpdGgoXCJFZmZlY3QgaGFuZGxlcnMgYXJlIG5vdCBzdXBwb3J0ZWRcIik7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSsOpcsO0bWUgVm91aWxsb24sIEh1Z28gSGV1emFyZFxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBmc19ub2RlX3N1cHBvcnRlZFxuZnVuY3Rpb24gZnNfbm9kZV9zdXBwb3J0ZWQgKCkge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBnbG9iYWxUaGlzLnByb2Nlc3MgIT09ICd1bmRlZmluZWQnXG4gICAgICAmJiB0eXBlb2YgZ2xvYmFsVGhpcy5wcm9jZXNzLnZlcnNpb25zICE9PSAndW5kZWZpbmVkJ1xuICAgICAgJiYgdHlwZW9mIGdsb2JhbFRoaXMucHJvY2Vzcy52ZXJzaW9ucy5ub2RlICE9PSAndW5kZWZpbmVkJylcbn1cbi8vUHJvdmlkZXM6IGZzX25vZGVfc3VwcG9ydGVkXG4vL0lmOiBicm93c2VyXG5mdW5jdGlvbiBmc19ub2RlX3N1cHBvcnRlZCAoKSB7XG4gIHJldHVybiBmYWxzZVxufVxuXG5cbi8vUHJvdmlkZXM6IE1sTm9kZURldmljZVxuLy9SZXF1aXJlczogTWxOb2RlRmQsIGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX3JhaXNlX3dpdGhfYXJnc1xuLy9SZXF1aXJlczogbWFrZV91bml4X2Vycl9hcmdzLCBjYW1sX25hbWVkX3ZhbHVlLCBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xuZnVuY3Rpb24gTWxOb2RlRGV2aWNlKHJvb3QpIHtcbiAgdGhpcy5mcyA9IHJlcXVpcmUoJ2ZzJyk7XG4gIHRoaXMucm9vdCA9IHJvb3Q7XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLm5tID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gKHRoaXMucm9vdCArIG5hbWUpO1xufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5leGlzdHMgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHRoaXMuZnMuZXhpc3RzU3luYyh0aGlzLm5tKG5hbWUpKT8xOjA7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiAwO1xuICB9XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLm1rZGlyID0gZnVuY3Rpb24obmFtZSwgbW9kZSwgcmFpc2VfdW5peCkge1xuICB0cnkge1xuICAgIHRoaXMuZnMubWtkaXJTeW5jKHRoaXMubm0obmFtZSkse21vZGU6bW9kZX0pO1xuICAgIHJldHVybiAwXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRoaXMucmFpc2Vfbm9kZWpzX2Vycm9yKGVyciwgcmFpc2VfdW5peCk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUucm1kaXIgPSBmdW5jdGlvbihuYW1lLCByYWlzZV91bml4KSB7XG4gIHRyeSB7XG4gICAgdGhpcy5mcy5ybWRpclN5bmModGhpcy5ubShuYW1lKSk7XG4gICAgcmV0dXJuIDBcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhpcy5yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4KTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5yZWFkZGlyID0gZnVuY3Rpb24obmFtZSwgcmFpc2VfdW5peCkge1xuICB0cnkge1xuICAgIHJldHVybiB0aGlzLmZzLnJlYWRkaXJTeW5jKHRoaXMubm0obmFtZSkpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aGlzLnJhaXNlX25vZGVqc19lcnJvcihlcnIsIHJhaXNlX3VuaXgpO1xuICB9XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLmlzX2RpciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdGhpcy5mcy5zdGF0U3luYyh0aGlzLm5tKG5hbWUpKS5pc0RpcmVjdG9yeSgpPzE6MDtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLnVubGluayA9IGZ1bmN0aW9uKG5hbWUsIHJhaXNlX3VuaXgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYiA9IHRoaXMuZnMuZXhpc3RzU3luYyh0aGlzLm5tKG5hbWUpKT8xOjA7XG4gICAgdGhpcy5mcy51bmxpbmtTeW5jKHRoaXMubm0obmFtZSkpO1xuICAgIHJldHVybiBiO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aGlzLnJhaXNlX25vZGVqc19lcnJvcihlcnIsIHJhaXNlX3VuaXgpO1xuICB9XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbihuYW1lLCBmLCByYWlzZV91bml4KSB7XG4gIHZhciBjb25zdHMgPSByZXF1aXJlKCdjb25zdGFudHMnKTtcbiAgdmFyIHJlcyA9IDA7XG4gIGZvcih2YXIga2V5IGluIGYpe1xuICAgIHN3aXRjaChrZXkpe1xuICAgIGNhc2UgXCJyZG9ubHlcIiAgOiByZXMgfD0gY29uc3RzLk9fUkRPTkxZOyBicmVhaztcbiAgICBjYXNlIFwid3Jvbmx5XCIgIDogcmVzIHw9IGNvbnN0cy5PX1dST05MWTsgYnJlYWs7XG4gICAgY2FzZSBcImFwcGVuZFwiICA6XG4gICAgICByZXMgfD0gY29uc3RzLk9fV1JPTkxZIHwgY29uc3RzLk9fQVBQRU5EO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNyZWF0ZVwiICAgOiByZXMgfD0gY29uc3RzLk9fQ1JFQVQ7ICAgIGJyZWFrO1xuICAgIGNhc2UgXCJ0cnVuY2F0ZVwiIDogcmVzIHw9IGNvbnN0cy5PX1RSVU5DOyAgICBicmVhaztcbiAgICBjYXNlIFwiZXhjbFwiICAgICA6IHJlcyB8PSBjb25zdHMuT19FWENMOyAgICAgYnJlYWs7XG4gICAgY2FzZSBcImJpbmFyeVwiICAgOiByZXMgfD0gY29uc3RzLk9fQklOQVJZOyAgIGJyZWFrO1xuICAgIGNhc2UgXCJ0ZXh0XCIgICAgIDogcmVzIHw9IGNvbnN0cy5PX1RFWFQ7ICAgICBicmVhaztcbiAgICBjYXNlIFwibm9uYmxvY2tcIiA6IHJlcyB8PSBjb25zdHMuT19OT05CTE9DSzsgYnJlYWs7XG4gICAgfVxuICB9XG4gIHRyeSB7XG4gICAgdmFyIGZkID0gdGhpcy5mcy5vcGVuU3luYyh0aGlzLm5tKG5hbWUpLCByZXMpO1xuICAgIHZhciBpc0NoYXJhY3RlckRldmljZSA9IHRoaXMuZnMubHN0YXRTeW5jKHRoaXMubm0obmFtZSkpLmlzQ2hhcmFjdGVyRGV2aWNlKCk7XG4gICAgZi5pc0NoYXJhY3RlckRldmljZSA9IGlzQ2hhcmFjdGVyRGV2aWNlO1xuICAgIHJldHVybiBuZXcgTWxOb2RlRmQoZmQsIGYpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aGlzLnJhaXNlX25vZGVqc19lcnJvcihlcnIsIHJhaXNlX3VuaXgpO1xuICB9XG59XG5cbk1sTm9kZURldmljZS5wcm90b3R5cGUucmVuYW1lID0gZnVuY3Rpb24obywgbiwgcmFpc2VfdW5peCkge1xuICB0cnkge1xuICAgIHRoaXMuZnMucmVuYW1lU3luYyh0aGlzLm5tKG8pLCB0aGlzLm5tKG4pKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhpcy5yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4KTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5zdGF0ID0gZnVuY3Rpb24obmFtZSwgcmFpc2VfdW5peCkge1xuICB0cnkge1xuICAgIHZhciBqc19zdGF0cyA9IHRoaXMuZnMuc3RhdFN5bmModGhpcy5ubShuYW1lKSk7XG4gICAgcmV0dXJuIHRoaXMuc3RhdHNfZnJvbV9qcyhqc19zdGF0cyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRoaXMucmFpc2Vfbm9kZWpzX2Vycm9yKGVyciwgcmFpc2VfdW5peCk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUubHN0YXQgPSBmdW5jdGlvbihuYW1lLCByYWlzZV91bml4KSB7XG4gIHRyeSB7XG4gICAgdmFyIGpzX3N0YXRzID0gdGhpcy5mcy5sc3RhdFN5bmModGhpcy5ubShuYW1lKSk7XG4gICAgcmV0dXJuIHRoaXMuc3RhdHNfZnJvbV9qcyhqc19zdGF0cyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRoaXMucmFpc2Vfbm9kZWpzX2Vycm9yKGVyciwgcmFpc2VfdW5peCk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUuc3ltbGluayA9IGZ1bmN0aW9uKHRvX2RpciwgdGFyZ2V0LCBwYXRoLCByYWlzZV91bml4KSB7XG4gIHRyeSB7XG4gICAgdGhpcy5mcy5zeW1saW5rU3luYyh0aGlzLm5tKHRhcmdldCksIHRoaXMubm0ocGF0aCksIHRvX2RpciA/ICdkaXInIDogJ2ZpbGUnKTtcbiAgICByZXR1cm4gMDtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhpcy5yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4KTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5yZWFkbGluayA9IGZ1bmN0aW9uKG5hbWUsIHJhaXNlX3VuaXgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgbGluayA9IHRoaXMuZnMucmVhZGxpbmtTeW5jKHRoaXMubm0obmFtZSksICd1dGY4Jyk7XG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKGxpbmspO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aGlzLnJhaXNlX25vZGVqc19lcnJvcihlcnIsIHJhaXNlX3VuaXgpO1xuICB9XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLm9wZW5kaXIgPSBmdW5jdGlvbihuYW1lLCByYWlzZV91bml4KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHRoaXMuZnMub3BlbmRpclN5bmModGhpcy5ubShuYW1lKSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRoaXMucmFpc2Vfbm9kZWpzX2Vycm9yKGVyciwgcmFpc2VfdW5peCk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUucmFpc2Vfbm9kZWpzX2Vycm9yID0gZnVuY3Rpb24oZXJyLCByYWlzZV91bml4KSB7XG4gIHZhciB1bml4X2Vycm9yID0gY2FtbF9uYW1lZF92YWx1ZShcIlVuaXguVW5peF9lcnJvclwiKTtcbiAgaWYgKHJhaXNlX3VuaXggJiYgdW5peF9lcnJvcikge1xuICAgIHZhciBhcmdzID0gbWFrZV91bml4X2Vycl9hcmdzKGVyci5jb2RlLCBlcnIuc3lzY2FsbCwgZXJyLnBhdGgsIGVyci5lcnJubyk7XG4gICAgY2FtbF9yYWlzZV93aXRoX2FyZ3ModW5peF9lcnJvciwgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLnN0YXRzX2Zyb21fanMgPSBmdW5jdGlvbihqc19zdGF0cykge1xuICAvKiA9PT1Vbml4LmZpbGVfa2luZD09PVxuICAgKiB0eXBlIGZpbGVfa2luZCA9XG4gICAqICAgICBTX1JFRyAgICAgICAgICAgICAgICAgICAgICAgKCoqIFJlZ3VsYXIgZmlsZSAqKVxuICAgKiAgIHwgU19ESVIgICAgICAgICAgICAgICAgICAgICAgICgqKiBEaXJlY3RvcnkgKilcbiAgICogICB8IFNfQ0hSICAgICAgICAgICAgICAgICAgICAgICAoKiogQ2hhcmFjdGVyIGRldmljZSAqKVxuICAgKiAgIHwgU19CTEsgICAgICAgICAgICAgICAgICAgICAgICgqKiBCbG9jayBkZXZpY2UgKilcbiAgICogICB8IFNfTE5LICAgICAgICAgICAgICAgICAgICAgICAoKiogU3ltYm9saWMgbGluayAqKVxuICAgKiAgIHwgU19GSUZPICAgICAgICAgICAgICAgICAgICAgICgqKiBOYW1lZCBwaXBlICopXG4gICAqICAgfCBTX1NPQ0sgICAgICAgICAgICAgICAgICAgICAgKCoqIFNvY2tldCAqKVxuICAgKi9cbiAgdmFyIGZpbGVfa2luZDtcbiAgaWYgKGpzX3N0YXRzLmlzRmlsZSgpKSB7XG4gICAgZmlsZV9raW5kID0gMDtcbiAgfSBlbHNlIGlmIChqc19zdGF0cy5pc0RpcmVjdG9yeSgpKSB7XG4gICAgZmlsZV9raW5kID0gMTtcbiAgfSBlbHNlIGlmIChqc19zdGF0cy5pc0NoYXJhY3RlckRldmljZSgpKSB7XG4gICAgZmlsZV9raW5kID0gMjtcbiAgfSBlbHNlIGlmIChqc19zdGF0cy5pc0Jsb2NrRGV2aWNlKCkpIHtcbiAgICBmaWxlX2tpbmQgPSAzO1xuICB9IGVsc2UgaWYgKGpzX3N0YXRzLmlzU3ltYm9saWNMaW5rKCkpIHtcbiAgICBmaWxlX2tpbmQgPSA0O1xuICB9IGVsc2UgaWYgKGpzX3N0YXRzLmlzRklGTygpKSB7XG4gICAgZmlsZV9raW5kID0gNTtcbiAgfSBlbHNlIGlmIChqc19zdGF0cy5pc1NvY2tldCgpKSB7XG4gICAgZmlsZV9raW5kID0gNjtcbiAgfVxuICAvKiA9PT1Vbml4LnN0YXRzPT09XG4gICAqIHR5cGUgc3RhdHMgPVxuICAgKiAgeyBzdF9kZXYgOiBpbnQ7ICAgICAgICAgICAgICAgKCoqIERldmljZSBudW1iZXIgKilcbiAgICogICAgc3RfaW5vIDogaW50OyAgICAgICAgICAgICAgICgqKiBJbm9kZSBudW1iZXIgKilcbiAgICogICAgc3Rfa2luZCA6IGZpbGVfa2luZDsgICAgICAgICgqKiBLaW5kIG9mIHRoZSBmaWxlICopXG4gICAqICAgIHN0X3Blcm0gOiBmaWxlX3Blcm07ICAgICAgICAoKiogQWNjZXNzIHJpZ2h0cyAqKVxuICAgKiAgICBzdF9ubGluayA6IGludDsgICAgICAgICAgICAgKCoqIE51bWJlciBvZiBsaW5rcyAqKVxuICAgKiAgICBzdF91aWQgOiBpbnQ7ICAgICAgICAgICAgICAgKCoqIFVzZXIgaWQgb2YgdGhlIG93bmVyICopXG4gICAqICAgIHN0X2dpZCA6IGludDsgICAgICAgICAgICAgICAoKiogR3JvdXAgSUQgb2YgdGhlIGZpbGUncyBncm91cCAqKVxuICAgKiAgICBzdF9yZGV2IDogaW50OyAgICAgICAgICAgICAgKCoqIERldmljZSBJRCAoaWYgc3BlY2lhbCBmaWxlKSAqKVxuICAgKiAgICBzdF9zaXplIDogaW50OyAgICAgICAgICAgICAgKCoqIFNpemUgaW4gYnl0ZXMgKilcbiAgICogICAgc3RfYXRpbWUgOiBmbG9hdDsgICAgICAgICAgICgqKiBMYXN0IGFjY2VzcyB0aW1lICopXG4gICAqICAgIHN0X210aW1lIDogZmxvYXQ7ICAgICAgICAgICAoKiogTGFzdCBtb2RpZmljYXRpb24gdGltZSAqKVxuICAgKiAgICBzdF9jdGltZSA6IGZsb2F0OyAgICAgICAgICAgKCoqIExhc3Qgc3RhdHVzIGNoYW5nZSB0aW1lICopXG4gICAqICB9XG4gICAqL1xuICByZXR1cm4gQkxPQ0soXG4gICAgMCxcbiAgICBqc19zdGF0cy5kZXYsXG4gICAganNfc3RhdHMuaW5vLFxuICAgIGZpbGVfa2luZCxcbiAgICBqc19zdGF0cy5tb2RlLFxuICAgIGpzX3N0YXRzLm5saW5rLFxuICAgIGpzX3N0YXRzLnVpZCxcbiAgICBqc19zdGF0cy5naWQsXG4gICAganNfc3RhdHMucmRldixcbiAgICBqc19zdGF0cy5zaXplLFxuICAgIGpzX3N0YXRzLmF0aW1lTXMsXG4gICAganNfc3RhdHMubXRpbWVNcyxcbiAgICBqc19zdGF0cy5jdGltZU1zXG4gICk7XG59XG5cbk1sTm9kZURldmljZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNbE5vZGVEZXZpY2VcblxuLy9Qcm92aWRlczogTWxOb2RlRGV2aWNlXG4vL0lmOiBicm93c2VyXG5mdW5jdGlvbiBNbE5vZGVEZXZpY2UoKSB7XG59XG5cbi8vUHJvdmlkZXM6IE1sTm9kZUZkXG4vL1JlcXVpcmVzOiBNbEZpbGUsIGNhbWxfdWludDhfYXJyYXlfb2Zfc3RyaW5nLCBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzLCBjYW1sX2J5dGVzX3NldCwgY2FtbF9yYWlzZV9zeXNfZXJyb3JcbmZ1bmN0aW9uIE1sTm9kZUZkKGZkLCBmbGFncyl7XG4gIHRoaXMuZnMgPSByZXF1aXJlKCdmcycpO1xuICB0aGlzLmZkID0gZmQ7XG4gIHRoaXMuZmxhZ3MgPSBmbGFncztcbn1cbk1sTm9kZUZkLnByb3RvdHlwZSA9IG5ldyBNbEZpbGUgKCk7XG5NbE5vZGVGZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNbE5vZGVGZDtcblxuTWxOb2RlRmQucHJvdG90eXBlLnRydW5jYXRlID0gZnVuY3Rpb24obGVuKXtcbiAgdHJ5IHtcbiAgICB0aGlzLmZzLmZ0cnVuY2F0ZVN5bmModGhpcy5mZCxsZW58MCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxufVxuTWxOb2RlRmQucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdGhpcy5mcy5mc3RhdFN5bmModGhpcy5mZCkuc2l6ZTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG59XG5NbE5vZGVGZC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihvZmZzZXQsYnVmLGJ1Zl9vZmZzZXQsbGVuKXtcbiAgdHJ5IHtcbiAgICBpZih0aGlzLmZsYWdzLmlzQ2hhcmFjdGVyRGV2aWNlKVxuICAgICAgdGhpcy5mcy53cml0ZVN5bmModGhpcy5mZCwgYnVmLCBidWZfb2Zmc2V0LCBsZW4pO1xuICAgIGVsc2VcbiAgICAgIHRoaXMuZnMud3JpdGVTeW5jKHRoaXMuZmQsIGJ1ZiwgYnVmX29mZnNldCwgbGVuLCBvZmZzZXQpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5NbE5vZGVGZC5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKG9mZnNldCxhLGJ1Zl9vZmZzZXQsbGVuKXtcbiAgdHJ5IHtcbiAgICBpZih0aGlzLmZsYWdzLmlzQ2hhcmFjdGVyRGV2aWNlKVxuICAgICAgdmFyIHJlYWQgPSB0aGlzLmZzLnJlYWRTeW5jKHRoaXMuZmQsIGEsIGJ1Zl9vZmZzZXQsIGxlbik7XG4gICAgZWxzZVxuICAgICAgdmFyIHJlYWQgPSB0aGlzLmZzLnJlYWRTeW5jKHRoaXMuZmQsIGEsIGJ1Zl9vZmZzZXQsIGxlbiwgb2Zmc2V0KTtcbiAgICByZXR1cm4gcmVhZDtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG59XG5NbE5vZGVGZC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpe1xuICB0cnkge1xuICAgIHRoaXMuZnMuY2xvc2VTeW5jKHRoaXMuZmQpO1xuICAgIHJldHVybiAwXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxufVxuXG5cbi8vUHJvdmlkZXM6IE1sTm9kZUZkXG4vL0lmOiBicm93c2VyXG5mdW5jdGlvbiBNbE5vZGVGZCgpe1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX29wZW5fZm9yX25vZGVcbi8vUmVxdWlyZXM6IE1sTm9kZUZkXG5mdW5jdGlvbiBjYW1sX3N5c19vcGVuX2Zvcl9ub2RlKGZkLCBmbGFncyl7XG4gIGlmKGZsYWdzLm5hbWUpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIGZzID0gcmVxdWlyZShcImZzXCIpO1xuICAgICAgdmFyIGZkMiA9IGZzLm9wZW5TeW5jKGZsYWdzLm5hbWUsIFwicnNcIik7XG4gICAgICByZXR1cm4gbmV3IE1sTm9kZUZkKGZkMiwgZmxhZ3MpO1xuICAgIH0gY2F0Y2goZSkgeyAgfVxuICB9XG4gIHJldHVybiBuZXcgTWxOb2RlRmQoZmQsIGZsYWdzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfb3Blbl9mb3Jfbm9kZVxuLy9JZjogYnJvd3NlclxuZnVuY3Rpb24gY2FtbF9zeXNfb3Blbl9mb3Jfbm9kZShmZCwgZmxhZ3Mpe1xuICByZXR1cm4gbnVsbDtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxNCBKw6lyw7RtZSBWb3VpbGxvbiwgSHVnbyBIZXV6YXJkXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gRHVtbXkgZmlsZXN5c3RlbVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3RyYWlsaW5nX3NsYXNoXG5mdW5jdGlvbiBjYW1sX3RyYWlsaW5nX3NsYXNoKG5hbWUpe1xuICByZXR1cm4gKG5hbWUuc2xpY2UoLTEpICE9PSBcIi9cIikgPyAobmFtZSArIFwiL1wiKSA6IG5hbWU7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY3VycmVudF9kaXJcbi8vUmVxdWlyZXM6IGNhbWxfdHJhaWxpbmdfc2xhc2gsIGZzX25vZGVfc3VwcG9ydGVkXG5pZihmc19ub2RlX3N1cHBvcnRlZCAoKSAmJiBnbG9iYWxUaGlzLnByb2Nlc3MgJiYgZ2xvYmFsVGhpcy5wcm9jZXNzLmN3ZClcbiAgdmFyIGNhbWxfY3VycmVudF9kaXIgPSBnbG9iYWxUaGlzLnByb2Nlc3MuY3dkKCkucmVwbGFjZSgvXFxcXC9nLCcvJyk7XG5lbHNlXG4gIHZhciBjYW1sX2N1cnJlbnRfZGlyID0gIFwiL3N0YXRpY1wiO1xuY2FtbF9jdXJyZW50X2RpciA9IGNhbWxfdHJhaWxpbmdfc2xhc2goY2FtbF9jdXJyZW50X2Rpcik7XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X3Jvb3Rcbi8vUmVxdWlyZXM6IHBhdGhfaXNfYWJzb2x1dGVcbmZ1bmN0aW9uIGNhbWxfZ2V0X3Jvb3QocGF0aCl7XG4gIHZhciB4ID0gcGF0aF9pc19hYnNvbHV0ZShwYXRoKTtcbiAgaWYgKCF4KSByZXR1cm47XG4gIHJldHVybiB4WzBdICsgXCIvXCJ9XG5cbi8vUHJvdmlkZXM6IGNhbWxfcm9vdFxuLy9SZXF1aXJlczogY2FtbF9nZXRfcm9vdCwgY2FtbF9jdXJyZW50X2RpciwgY2FtbF9mYWlsd2l0aFxudmFyIGNhbWxfcm9vdCA9IGNhbWxfZ2V0X3Jvb3QoY2FtbF9jdXJyZW50X2RpcikgfHwgY2FtbF9mYWlsd2l0aChcInVuYWJsZSB0byBjb21wdXRlIGNhbWxfcm9vdFwiKTtcblxuXG4vL1Byb3ZpZGVzOiBNbEZpbGVcbmZ1bmN0aW9uIE1sRmlsZSgpeyAgfVxuXG4vL1Byb3ZpZGVzOiBwYXRoX2lzX2Fic29sdXRlXG4vL1JlcXVpcmVzOiBmc19ub2RlX3N1cHBvcnRlZFxuZnVuY3Rpb24gbWFrZV9wYXRoX2lzX2Fic29sdXRlKCkge1xuICBmdW5jdGlvbiBwb3NpeChwYXRoKSB7XG4gICAgaWYgKHBhdGguY2hhckF0KDApID09PSAnLycpIHJldHVybiBbXCJcIiwgcGF0aC5zdWJzdHJpbmcoMSldO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdpbjMyKHBhdGgpIHtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi9iM2ZjYzI0NWZiMjU1Mzk5MDllZjFkNWVhYTAxZGJmOTJlMTY4NjMzL2xpYi9wYXRoLmpzI0w1NlxuICAgIHZhciBzcGxpdERldmljZVJlID0gL14oW2EtekEtWl06fFtcXFxcL117Mn1bXlxcXFwvXStbXFxcXC9dK1teXFxcXC9dKyk/KFtcXFxcL10pPyhbXFxzXFxTXSo/KSQvO1xuICAgIHZhciByZXN1bHQgPSBzcGxpdERldmljZVJlLmV4ZWMocGF0aCk7XG4gICAgdmFyIGRldmljZSA9IHJlc3VsdFsxXSB8fCAnJztcbiAgICB2YXIgaXNVbmMgPSBCb29sZWFuKGRldmljZSAmJiBkZXZpY2UuY2hhckF0KDEpICE9PSAnOicpO1xuXG4gICAgLy8gVU5DIHBhdGhzIGFyZSBhbHdheXMgYWJzb2x1dGVcbiAgICBpZiAoQm9vbGVhbihyZXN1bHRbMl0gfHwgaXNVbmMpKSB7XG4gICAgICB2YXIgcm9vdCA9IChyZXN1bHRbMV0gfHwgJycpO1xuICAgICAgdmFyIHNlcCA9IChyZXN1bHRbMl0gfHwgJycpO1xuICAgICAgcmV0dXJuIFtyb290LCBwYXRoLnN1YnN0cmluZyhyb290Lmxlbmd0aCArIHNlcC5sZW5ndGgpXVxuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgaWYoZnNfbm9kZV9zdXBwb3J0ZWQgKCkgJiYgZ2xvYmFsVGhpcy5wcm9jZXNzICYmIGdsb2JhbFRoaXMucHJvY2Vzcy5wbGF0Zm9ybSkge1xuICAgIHJldHVybiBnbG9iYWxUaGlzLnByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicgPyB3aW4zMiA6IHBvc2l4O1xuICB9XG4gIGVsc2UgcmV0dXJuIHBvc2l4XG59XG52YXIgcGF0aF9pc19hYnNvbHV0ZSA9IG1ha2VfcGF0aF9pc19hYnNvbHV0ZSgpO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX21ha2VfcGF0aFxuLy9SZXF1aXJlczogY2FtbF9jdXJyZW50X2RpclxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcsIHBhdGhfaXNfYWJzb2x1dGVcbmZ1bmN0aW9uIGNhbWxfbWFrZV9wYXRoIChuYW1lKSB7XG4gIG5hbWU9Y2FtbF9qc3N0cmluZ19vZl9zdHJpbmcobmFtZSk7XG4gIGlmKCAhcGF0aF9pc19hYnNvbHV0ZShuYW1lKSApXG4gICAgbmFtZSA9IGNhbWxfY3VycmVudF9kaXIgKyBuYW1lO1xuICB2YXIgY29tcDAgPSBwYXRoX2lzX2Fic29sdXRlKG5hbWUpO1xuICB2YXIgY29tcCA9IGNvbXAwWzFdLnNwbGl0KFwiL1wiKTtcbiAgdmFyIG5jb21wID0gW11cbiAgZm9yKHZhciBpID0gMDsgaTxjb21wLmxlbmd0aDsgaSsrKXtcbiAgICBzd2l0Y2goY29tcFtpXSl7XG4gICAgY2FzZSBcIi4uXCI6IGlmKG5jb21wLmxlbmd0aD4xKSBuY29tcC5wb3AoKTsgYnJlYWs7XG4gICAgY2FzZSBcIi5cIjogYnJlYWs7XG4gICAgY2FzZSBcIlwiOiBicmVhaztcbiAgICBkZWZhdWx0OiBuY29tcC5wdXNoKGNvbXBbaV0pO2JyZWFrXG4gICAgfVxuICB9XG4gIG5jb21wLnVuc2hpZnQoY29tcDBbMF0pO1xuICBuY29tcC5vcmlnID0gbmFtZTtcbiAgcmV0dXJuIG5jb21wO1xufVxuXG4vL1Byb3ZpZGVzOmpzb29fbW91bnRfcG9pbnRcbi8vUmVxdWlyZXM6IE1sRmFrZURldmljZSwgTWxOb2RlRGV2aWNlLCBjYW1sX3Jvb3QsIGZzX25vZGVfc3VwcG9ydGVkXG52YXIganNvb19tb3VudF9wb2ludCA9IFtdXG5pZiAoZnNfbm9kZV9zdXBwb3J0ZWQoKSkge1xuICBqc29vX21vdW50X3BvaW50LnB1c2goe3BhdGg6Y2FtbF9yb290LGRldmljZTpuZXcgTWxOb2RlRGV2aWNlKGNhbWxfcm9vdCl9KTtcbn0gZWxzZSB7XG4gIGpzb29fbW91bnRfcG9pbnQucHVzaCh7cGF0aDpjYW1sX3Jvb3QsZGV2aWNlOm5ldyBNbEZha2VEZXZpY2UoY2FtbF9yb290KX0pO1xufVxuanNvb19tb3VudF9wb2ludC5wdXNoKHtwYXRoOlwiL3N0YXRpYy9cIiwgZGV2aWNlOm5ldyBNbEZha2VEZXZpY2UoXCIvc3RhdGljL1wiKX0pO1xuXG4vL1Byb3ZpZGVzOmNhbWxfbGlzdF9tb3VudF9wb2ludFxuLy9SZXF1aXJlczoganNvb19tb3VudF9wb2ludCwgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9saXN0X21vdW50X3BvaW50KCl7XG4gIHZhciBwcmV2ID0gMFxuICBmb3IodmFyIGkgPSAwOyBpIDwganNvb19tb3VudF9wb2ludC5sZW5ndGg7IGkrKyl7XG4gICAgdmFyIG9sZCA9IHByZXY7XG4gICAgcHJldiA9IFswLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGpzb29fbW91bnRfcG9pbnRbaV0ucGF0aCksIG9sZF1cbiAgfVxuICByZXR1cm4gcHJldjtcbn1cblxuLy9Qcm92aWRlczogcmVzb2x2ZV9mc19kZXZpY2Vcbi8vUmVxdWlyZXM6IGNhbWxfbWFrZV9wYXRoLCBqc29vX21vdW50X3BvaW50LCBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9nZXRfcm9vdCwgTWxOb2RlRGV2aWNlLCBjYW1sX3RyYWlsaW5nX3NsYXNoLCBmc19ub2RlX3N1cHBvcnRlZFxuZnVuY3Rpb24gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSl7XG4gIHZhciBwYXRoID0gY2FtbF9tYWtlX3BhdGgobmFtZSk7XG4gIHZhciBuYW1lID0gcGF0aC5qb2luKFwiL1wiKTtcbiAgdmFyIG5hbWVfc2xhc2ggPSBjYW1sX3RyYWlsaW5nX3NsYXNoKG5hbWUpO1xuICB2YXIgcmVzO1xuICBmb3IodmFyIGkgPSAwOyBpIDwganNvb19tb3VudF9wb2ludC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBtID0ganNvb19tb3VudF9wb2ludFtpXTtcbiAgICBpZihuYW1lX3NsYXNoLnNlYXJjaChtLnBhdGgpID09IDBcbiAgICAgICAmJiAoIXJlcyB8fCByZXMucGF0aC5sZW5ndGggPCBtLnBhdGgubGVuZ3RoKSlcbiAgICAgIHJlcyA9IHtwYXRoOm0ucGF0aCxkZXZpY2U6bS5kZXZpY2UscmVzdDpuYW1lLnN1YnN0cmluZyhtLnBhdGgubGVuZ3RoLG5hbWUubGVuZ3RoKX07XG4gIH1cbiAgaWYoICFyZXMgJiYgZnNfbm9kZV9zdXBwb3J0ZWQoKSkge1xuICAgIHZhciByb290ID0gY2FtbF9nZXRfcm9vdChuYW1lKTtcbiAgICBpZiAocm9vdCAmJiByb290Lm1hdGNoKC9eW2EtekEtWl06XFwvJC8pKXtcbiAgICAgIHZhciBtID0ge3BhdGg6cm9vdCxkZXZpY2U6bmV3IE1sTm9kZURldmljZShyb290KX07XG4gICAgICBqc29vX21vdW50X3BvaW50LnB1c2gobSk7XG4gICAgICByZXMgPSB7cGF0aDptLnBhdGgsZGV2aWNlOm0uZGV2aWNlLHJlc3Q6bmFtZS5zdWJzdHJpbmcobS5wYXRoLmxlbmd0aCxuYW1lLmxlbmd0aCl9O1xuICAgIH1cbiAgfVxuICBpZiggcmVzICkgcmV0dXJuIHJlcztcbiAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJubyBkZXZpY2UgZm91bmQgZm9yIFwiICsgbmFtZV9zbGFzaCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbW91bnRfYXV0b2xvYWRcbi8vUmVxdWlyZXM6IE1sRmFrZURldmljZSwgY2FtbF9tYWtlX3BhdGgsIGpzb29fbW91bnRfcG9pbnQsIGNhbWxfdHJhaWxpbmdfc2xhc2hcbmZ1bmN0aW9uIGNhbWxfbW91bnRfYXV0b2xvYWQobmFtZSxmKXtcbiAgdmFyIHBhdGggPSBjYW1sX21ha2VfcGF0aChuYW1lKTtcbiAgdmFyIG5hbWUgPSBjYW1sX3RyYWlsaW5nX3NsYXNoKHBhdGguam9pbihcIi9cIikpO1xuICBqc29vX21vdW50X3BvaW50LnB1c2goe3BhdGg6bmFtZSxkZXZpY2U6bmV3IE1sRmFrZURldmljZShuYW1lLGYpfSlcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5tb3VudFxuLy9SZXF1aXJlczoganNvb19tb3VudF9wb2ludCwgY2FtbF9tYWtlX3BhdGgsIGNhbWxfdHJhaWxpbmdfc2xhc2hcbmZ1bmN0aW9uIGNhbWxfdW5tb3VudChuYW1lKXtcbiAgdmFyIHBhdGggPSBjYW1sX21ha2VfcGF0aChuYW1lKTtcbiAgdmFyIG5hbWUgPSBjYW1sX3RyYWlsaW5nX3NsYXNoKHBhdGguam9pbihcIi9cIikpO1xuICB2YXIgaWR4ID0gLTE7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBqc29vX21vdW50X3BvaW50Lmxlbmd0aDsgaSsrKVxuICAgIGlmKGpzb29fbW91bnRfcG9pbnRbaV0ucGF0aCA9PSBuYW1lKSBpZHggPSBpO1xuICBpZihpZHggPiAtMSkganNvb19tb3VudF9wb2ludC5zcGxpY2UoaWR4LDEpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19nZXRjd2Rcbi8vUmVxdWlyZXM6IGNhbWxfY3VycmVudF9kaXIsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfc3lzX2dldGN3ZCgpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoY2FtbF9jdXJyZW50X2Rpcik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NoZGlyXG4vL1JlcXVpcmVzOiBjYW1sX2N1cnJlbnRfZGlyLCBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZSwgcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfdHJhaWxpbmdfc2xhc2gsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3lzX2NoZGlyKGRpcikge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKGRpcik7XG4gIGlmKHJvb3QuZGV2aWNlLmV4aXN0cyhyb290LnJlc3QpKSB7XG4gICAgaWYocm9vdC5yZXN0KSBjYW1sX2N1cnJlbnRfZGlyID0gY2FtbF90cmFpbGluZ19zbGFzaChyb290LnBhdGggKyByb290LnJlc3QpO1xuICAgIGVsc2UgY2FtbF9jdXJyZW50X2RpciA9IHJvb3QucGF0aDtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBlbHNlIHtcbiAgICBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZShjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKGRpcikpO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvclxuZnVuY3Rpb24gY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUobmFtZSl7XG4gIGNhbWxfcmFpc2Vfc3lzX2Vycm9yIChuYW1lICsgXCI6IE5vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnlcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfbm90X2FfZGlyXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvclxuZnVuY3Rpb24gY2FtbF9yYWlzZV9ub3RfYV9kaXIobmFtZSl7XG4gIGNhbWxfcmFpc2Vfc3lzX2Vycm9yIChuYW1lICsgXCI6IE5vdCBhIGRpcmVjdG9yeVwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZmlsZV9leGlzdHNcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlXG5mdW5jdGlvbiBjYW1sX3N5c19maWxlX2V4aXN0cyAobmFtZSkge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICByZXR1cm4gcm9vdC5kZXZpY2UuZXhpc3RzKHJvb3QucmVzdCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3JlYWRfZGlyZWN0b3J5XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX25vdF9hX2RpciwgcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfc3lzX3JlYWRfZGlyZWN0b3J5KG5hbWUpe1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICB2YXIgYSA9IHJvb3QuZGV2aWNlLnJlYWRkaXIocm9vdC5yZXN0KTtcbiAgdmFyIGwgPSBuZXcgQXJyYXkoYS5sZW5ndGggKyAxKTtcbiAgbFswXSA9IDA7XG4gIGZvcih2YXIgaT0wO2k8YS5sZW5ndGg7aSsrKVxuICAgIGxbaSsxXSA9IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoYVtpXSk7XG4gIHJldHVybiBsO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19yZW1vdmVcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlLCByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9zeXNfcmVtb3ZlKG5hbWUpe1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICB2YXIgb2sgPSByb290LmRldmljZS51bmxpbmsocm9vdC5yZXN0KTtcbiAgaWYob2sgPT0gMCkgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUoY2FtbF9qc2J5dGVzX29mX3N0cmluZyhuYW1lKSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19pc19kaXJlY3Rvcnlcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlXG5mdW5jdGlvbiBjYW1sX3N5c19pc19kaXJlY3RvcnkobmFtZSl7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHZhciBhID0gcm9vdC5kZXZpY2UuaXNfZGlyKHJvb3QucmVzdCk7XG4gIHJldHVybiBhPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfcmVuYW1lXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoLCByZXNvbHZlX2ZzX2RldmljZVxuZnVuY3Rpb24gY2FtbF9zeXNfcmVuYW1lKG8sbil7XG4gIHZhciBvX3Jvb3QgPSByZXNvbHZlX2ZzX2RldmljZShvKTtcbiAgdmFyIG5fcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG4pO1xuICBpZihvX3Jvb3QuZGV2aWNlICE9IG5fcm9vdC5kZXZpY2UpXG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfc3lzX3JlbmFtZTogY2Fubm90IG1vdmUgZmlsZSBiZXR3ZWVuIHR3byBmaWxlc3lzdGVtXCIpO1xuICBpZighb19yb290LmRldmljZS5yZW5hbWUpXG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfc3lzX3JlbmFtZTogbm8gaW1wbGVtZW50ZWRcIik7XG4gIG9fcm9vdC5kZXZpY2UucmVuYW1lKG9fcm9vdC5yZXN0LCBuX3Jvb3QucmVzdCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX21rZGlyXG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9yYWlzZV9zeXNfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfc3lzX21rZGlyKG5hbWUsIHBlcm0pe1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICByb290LmRldmljZS5ta2Rpcihyb290LnJlc3QscGVybSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19ybWRpclxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX3JhaXNlX25vdF9hX2RpclxuZnVuY3Rpb24gY2FtbF9zeXNfcm1kaXIobmFtZSl7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHJvb3QuZGV2aWNlLnJtZGlyKHJvb3QucmVzdCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX21hcF9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2JhX21hcF9maWxlKHZmZCwga2luZCwgbGF5b3V0LCBzaGFyZWQsIGRpbXMsIHBvcykge1xuICAvLyB2YXIgZGF0YSA9IGNhbWxfc3lzX2Zkc1t2ZmRdO1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9iYV9tYXBfZmlsZSBub3QgaW1wbGVtZW50ZWRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfbWFwX2ZpbGVfYnl0ZWNvZGVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfbWFwX2ZpbGVcbmZ1bmN0aW9uIGNhbWxfYmFfbWFwX2ZpbGVfYnl0ZWNvZGUoYXJndixhcmduKXtcbiAgcmV0dXJuIGNhbWxfYmFfbWFwX2ZpbGUoYXJndlswXSxhcmd2WzFdLGFyZ3ZbMl0sYXJndlszXSxhcmd2WzRdLGFyZ3ZbNV0pO1xufVxuXG4vL1Byb3ZpZGVzOiBqc29vX2NyZWF0ZV9maWxlX2V4dGVyblxuZnVuY3Rpb24ganNvb19jcmVhdGVfZmlsZV9leHRlcm4obmFtZSxjb250ZW50KXtcbiAgaWYoZ2xvYmFsVGhpcy5qc29vX2NyZWF0ZV9maWxlKVxuICAgIGdsb2JhbFRoaXMuanNvb19jcmVhdGVfZmlsZShuYW1lLGNvbnRlbnQpO1xuICBlbHNlIHtcbiAgICBpZighZ2xvYmFsVGhpcy5jYW1sX2ZzX3RtcCkgZ2xvYmFsVGhpcy5jYW1sX2ZzX3RtcCA9IFtdO1xuICAgIGdsb2JhbFRoaXMuY2FtbF9mc190bXAucHVzaCh7bmFtZTpuYW1lLGNvbnRlbnQ6Y29udGVudH0pO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZzX2luaXRcbi8vUmVxdWlyZXM6IGpzb29fY3JlYXRlX2ZpbGVcbmZ1bmN0aW9uIGNhbWxfZnNfaW5pdCAoKXtcbiAgdmFyIHRtcD1nbG9iYWxUaGlzLmNhbWxfZnNfdG1wXG4gIGlmKHRtcCl7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRtcC5sZW5ndGg7IGkrKyl7XG4gICAgICBqc29vX2NyZWF0ZV9maWxlKHRtcFtpXS5uYW1lLHRtcFtpXS5jb250ZW50KTtcbiAgICB9XG4gIH1cbiAgZ2xvYmFsVGhpcy5qc29vX2NyZWF0ZV9maWxlID0ganNvb19jcmVhdGVfZmlsZTtcbiAgZ2xvYmFsVGhpcy5jYW1sX2ZzX3RtcCA9IFtdO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jcmVhdGVfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfY3JlYXRlX2ZpbGUobmFtZSxjb250ZW50KSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIGlmKCEgcm9vdC5kZXZpY2UucmVnaXN0ZXIpIGNhbWxfZmFpbHdpdGgoXCJjYW5ub3QgcmVnaXN0ZXIgZmlsZVwiKTtcbiAgcm9vdC5kZXZpY2UucmVnaXN0ZXIocm9vdC5yZXN0LGNvbnRlbnQpO1xuICByZXR1cm4gMDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBqc29vX2NyZWF0ZV9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX2NyZWF0ZV9maWxlLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBqc29vX2NyZWF0ZV9maWxlKG5hbWUsY29udGVudCkge1xuICB2YXIgbmFtZSA9IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMobmFtZSk7XG4gIHZhciBjb250ZW50ID0gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhjb250ZW50KTtcbiAgcmV0dXJuIGNhbWxfY3JlYXRlX2ZpbGUobmFtZSwgY29udGVudCk7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9yZWFkX2ZpbGVfY29udGVudFxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlLCBjYW1sX3N0cmluZ19vZl9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlcywgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9yZWFkX2ZpbGVfY29udGVudCAobmFtZSkge1xuICB2YXIgbmFtZSA9ICh0eXBlb2YgbmFtZSA9PSBcInN0cmluZ1wiKT9jYW1sX3N0cmluZ19vZl9qc2J5dGVzKG5hbWUpOm5hbWU7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIGlmKHJvb3QuZGV2aWNlLmV4aXN0cyhyb290LnJlc3QpKSB7XG4gICAgdmFyIGZpbGUgPSByb290LmRldmljZS5vcGVuKHJvb3QucmVzdCx7cmRvbmx5OjF9KTtcbiAgICB2YXIgbGVuICA9IGZpbGUubGVuZ3RoKCk7XG4gICAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbik7XG4gICAgZmlsZS5yZWFkKDAsYnVmLDAsbGVuKTtcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfYXJyYXkoYnVmKVxuICB9XG4gIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlKGNhbWxfanNieXRlc19vZl9zdHJpbmcobmFtZSkpO1xufVxuIiwiLy9Qcm92aWRlczogY2FtbF91bml4X2dldHRpbWVvZmRheVxuLy9BbGlhczogdW5peF9nZXR0aW1lb2ZkYXlcbmZ1bmN0aW9uIGNhbWxfdW5peF9nZXR0aW1lb2ZkYXkgKCkge1xuICByZXR1cm4gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAvIDEwMDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF90aW1lXG4vL1JlcXVpcmVzOiBjYW1sX3VuaXhfZ2V0dGltZW9mZGF5XG4vL0FsaWFzOiB1bml4X3RpbWVcbmZ1bmN0aW9uIGNhbWxfdW5peF90aW1lICgpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoY2FtbF91bml4X2dldHRpbWVvZmRheSAoKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9nbXRpbWVcbi8vQWxpYXM6IHVuaXhfZ210aW1lXG5mdW5jdGlvbiBjYW1sX3VuaXhfZ210aW1lICh0KSB7XG4gIHZhciBkID0gbmV3IERhdGUgKHQgKiAxMDAwKTtcbiAgdmFyIGRfbnVtID0gZC5nZXRUaW1lKCk7XG4gIHZhciBqYW51YXJ5Zmlyc3QgPSAobmV3IERhdGUoRGF0ZS5VVEMoZC5nZXRVVENGdWxsWWVhcigpLCAwLCAxKSkpLmdldFRpbWUoKTtcbiAgdmFyIGRveSA9IE1hdGguZmxvb3IoKGRfbnVtIC0gamFudWFyeWZpcnN0KSAvIDg2NDAwMDAwKTtcbiAgcmV0dXJuIEJMT0NLKDAsIGQuZ2V0VVRDU2Vjb25kcygpLCBkLmdldFVUQ01pbnV0ZXMoKSwgZC5nZXRVVENIb3VycygpLFxuICAgICAgICAgICAgICAgZC5nZXRVVENEYXRlKCksIGQuZ2V0VVRDTW9udGgoKSwgZC5nZXRVVENGdWxsWWVhcigpIC0gMTkwMCxcbiAgICAgICAgICAgICAgIGQuZ2V0VVRDRGF5KCksIGRveSxcbiAgICAgICAgICAgICAgIGZhbHNlIHwgMCAvKiBmb3IgVVRDIGRheWxpZ2h0IHNhdmluZ3MgdGltZSBpcyBmYWxzZSAqLylcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X2xvY2FsdGltZVxuLy9BbGlhczogdW5peF9sb2NhbHRpbWVcbmZ1bmN0aW9uIGNhbWxfdW5peF9sb2NhbHRpbWUgKHQpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSAodCAqIDEwMDApO1xuICB2YXIgZF9udW0gPSBkLmdldFRpbWUoKTtcbiAgdmFyIGphbnVhcnlmaXJzdCA9IChuZXcgRGF0ZShkLmdldEZ1bGxZZWFyKCksIDAsIDEpKS5nZXRUaW1lKCk7XG4gIHZhciBkb3kgPSBNYXRoLmZsb29yKChkX251bSAtIGphbnVhcnlmaXJzdCkgLyA4NjQwMDAwMCk7XG4gIHZhciBqYW4gPSBuZXcgRGF0ZShkLmdldEZ1bGxZZWFyKCksIDAsIDEpO1xuICB2YXIganVsID0gbmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLCA2LCAxKTtcbiAgdmFyIHN0ZFRpbWV6b25lT2Zmc2V0ID0gTWF0aC5tYXgoamFuLmdldFRpbWV6b25lT2Zmc2V0KCksIGp1bC5nZXRUaW1lem9uZU9mZnNldCgpKTtcbiAgcmV0dXJuIEJMT0NLKDAsIGQuZ2V0U2Vjb25kcygpLCBkLmdldE1pbnV0ZXMoKSwgZC5nZXRIb3VycygpLFxuICAgICAgICAgICAgICAgZC5nZXREYXRlKCksIGQuZ2V0TW9udGgoKSwgZC5nZXRGdWxsWWVhcigpIC0gMTkwMCxcbiAgICAgICAgICAgICAgIGQuZ2V0RGF5KCksIGRveSxcbiAgICAgICAgICAgICAgIChkLmdldFRpbWV6b25lT2Zmc2V0KCkgPCBzdGRUaW1lem9uZU9mZnNldCkgfCAwIC8qIGRheWxpZ2h0IHNhdmluZ3MgdGltZSAgZmllbGQuICovKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfbWt0aW1lXG4vL1JlcXVpcmVzOiBjYW1sX3VuaXhfbG9jYWx0aW1lXG4vL0FsaWFzOiB1bml4X21rdGltZVxuZnVuY3Rpb24gY2FtbF91bml4X21rdGltZSh0bSl7XG4gIHZhciBkID0gKG5ldyBEYXRlKHRtWzZdKzE5MDAsdG1bNV0sdG1bNF0sdG1bM10sdG1bMl0sdG1bMV0pKS5nZXRUaW1lKCk7XG4gIHZhciB0ID0gTWF0aC5mbG9vcihkIC8gMTAwMCk7XG4gIHZhciB0bTIgPSBjYW1sX3VuaXhfbG9jYWx0aW1lKHQpO1xuICByZXR1cm4gQkxPQ0soMCx0LHRtMik7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfc3RhcnR1cCBjb25zdFxuLy9BbGlhczogd2luX3N0YXJ0dXBcbmZ1bmN0aW9uIGNhbWxfdW5peF9zdGFydHVwKCkge31cblxuLy9Qcm92aWRlczogY2FtbF91bml4X2NsZWFudXAgY29uc3Rcbi8vQWxpYXM6IHdpbl9jbGVhbnVwXG5mdW5jdGlvbiBjYW1sX3VuaXhfY2xlYW51cCgpIHt9XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9maWxlZGVzY3Jfb2ZfZmQgY29uc3Rcbi8vQWxpYXM6IHdpbl9oYW5kbGVfZmRcbmZ1bmN0aW9uIGNhbWxfdW5peF9maWxlZGVzY3Jfb2ZfZmQoeCkge3JldHVybiB4O31cblxuLy9Qcm92aWRlczogY2FtbF91bml4X2lzYXR0eVxuLy9SZXF1aXJlczogZnNfbm9kZV9zdXBwb3J0ZWRcbi8vQWxpYXM6IHVuaXhfaXNhdHR5XG5mdW5jdGlvbiBjYW1sX3VuaXhfaXNhdHR5KGZpbGVEZXNjcmlwdG9yKSB7XG4gIGlmKGZzX25vZGVfc3VwcG9ydGVkKCkpIHtcbiAgICB2YXIgdHR5ID0gcmVxdWlyZSgndHR5Jyk7XG4gICAgcmV0dXJuIHR0eS5pc2F0dHkoZmlsZURlc2NyaXB0b3IpPzE6MDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMDtcbiAgfVxufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9pc2F0dHlcbi8vQWxpYXM6IHVuaXhfaXNhdHR5XG4vL0lmOiBicm93c2VyXG5mdW5jdGlvbiBjYW1sX3VuaXhfaXNhdHR5KGZpbGVEZXNjcmlwdG9yKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBtYWtlX3VuaXhfZXJyX2FyZ3Ncbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG52YXIgdW5peF9lcnJvciA9IFtcbiAgLyogPT09VW5peC5lcnJvcj09PVxuICAgKlxuICAgKiBUaGlzIGFycmF5IGlzIGluIG9yZGVyIG9mIHRoZSB2YXJpYW50IGluIE9DYW1sXG4gICAqL1xuICBcIkUyQklHXCIsIFwiRUFDQ0VTXCIsIFwiRUFHQUlOXCIsIFwiRUJBREZcIiwgXCJFQlVTWVwiLCBcIkVDSElMRFwiLCBcIkVERUFETEtcIiwgXCJFRE9NXCIsXG4gIFwiRUVYSVNUXCIsIFwiRUZBVUxUXCIsIFwiRUZCSUdcIiwgXCJFSU5UUlwiLCBcIkVJTlZBTFwiLCBcIkVJT1wiLCBcIkVJU0RJUlwiLCBcIkVNRklMRVwiLFxuICBcIkVNTElOS1wiLCBcIkVOQU1FVE9PTE9OR1wiLCBcIkVORklMRVwiLCBcIkVOT0RFVlwiLCBcIkVOT0VOVFwiLCBcIkVOT0VYRUNcIiwgXCJFTk9MQ0tcIixcbiAgXCJFTk9NRU1cIiwgXCJFTk9TUENcIiwgXCJFTk9TWVNcIiwgXCJFTk9URElSXCIsIFwiRU5PVEVNUFRZXCIsIFwiRU5PVFRZXCIsIFwiRU5YSU9cIixcbiAgXCJFUEVSTVwiLCBcIkVQSVBFXCIsIFwiRVJBTkdFXCIsIFwiRVJPRlNcIiwgXCJFU1BJUEVcIiwgXCJFU1JDSFwiLCBcIkVYREVWXCIsIFwiRVdPVUxEQkxPQ0tcIixcbiAgXCJFSU5QUk9HUkVTU1wiLCBcIkVBTFJFQURZXCIsIFwiRU5PVFNPQ0tcIiwgXCJFREVTVEFERFJSRVFcIiwgXCJFTVNHU0laRVwiLFxuICBcIkVQUk9UT1RZUEVcIiwgXCJFTk9QUk9UT09QVFwiLCBcIkVQUk9UT05PU1VQUE9SVFwiLCBcIkVTT0NLVE5PU1VQUE9SVFwiLFxuICBcIkVPUE5PVFNVUFBcIiwgXCJFUEZOT1NVUFBPUlRcIiwgXCJFQUZOT1NVUFBPUlRcIiwgXCJFQUREUklOVVNFXCIsIFwiRUFERFJOT1RBVkFJTFwiLFxuICBcIkVORVRET1dOXCIsIFwiRU5FVFVOUkVBQ0hcIiwgXCJFTkVUUkVTRVRcIiwgXCJFQ09OTkFCT1JURURcIiwgXCJFQ09OTlJFU0VUXCIsIFwiRU5PQlVGU1wiLFxuICBcIkVJU0NPTk5cIiwgXCJFTk9UQ09OTlwiLCBcIkVTSFVURE9XTlwiLCBcIkVUT09NQU5ZUkVGU1wiLCBcIkVUSU1FRE9VVFwiLCBcIkVDT05OUkVGVVNFRFwiLFxuICBcIkVIT1NURE9XTlwiLCBcIkVIT1NUVU5SRUFDSFwiLCBcIkVMT09QXCIsIFwiRU9WRVJGTE9XXCJcbl07XG5mdW5jdGlvbiBtYWtlX3VuaXhfZXJyX2FyZ3MoY29kZSwgc3lzY2FsbCwgcGF0aCwgZXJybm8pIHtcbiAgdmFyIHZhcmlhbnQgPSB1bml4X2Vycm9yLmluZGV4T2YoY29kZSk7XG4gIGlmICh2YXJpYW50IDwgMCkge1xuICAgIC8vIERlZmF1bHQgaWYgdW5kZWZpbmVkXG4gICAgaWYgKGVycm5vID09IG51bGwpIHtcbiAgICAgIGVycm5vID0gLTk5OTlcbiAgICB9XG4gICAgLy8gSWYgbm9uZSBvZiB0aGUgYWJvdmUgdmFyaWFudHMsIGZhbGxiYWNrIHRvIEVVTktOT1dORVJSKGludClcbiAgICB2YXJpYW50ID0gQkxPQ0soMCwgZXJybm8pO1xuICB9XG4gIHZhciBhcmdzID0gW1xuICAgIHZhcmlhbnQsXG4gICAgY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcoc3lzY2FsbCB8fCBcIlwiKSxcbiAgICBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhwYXRoIHx8IFwiXCIpXG4gIF07XG4gIHJldHVybiBhcmdzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfc3RhdFxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfZmFpbHdpdGhcbi8vQWxpYXM6IHVuaXhfc3RhdFxuZnVuY3Rpb24gY2FtbF91bml4X3N0YXQobmFtZSkge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICBpZiAoIXJvb3QuZGV2aWNlLnN0YXQpIHtcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF91bml4X3N0YXQ6IG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICByZXR1cm4gcm9vdC5kZXZpY2Uuc3RhdChyb290LnJlc3QsIC8qIHJhaXNlIFVuaXhfZXJyb3IgKi8gdHJ1ZSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9zdGF0XzY0XG4vL1JlcXVpcmVzOiBjYW1sX3VuaXhfc3RhdCwgY2FtbF9pbnQ2NF9vZl9pbnQzMlxuLy9BbGlhczogdW5peF9zdGF0XzY0XG5mdW5jdGlvbiBjYW1sX3VuaXhfc3RhdF82NChuYW1lKSB7XG4gIHZhciByID0gY2FtbF91bml4X3N0YXQobmFtZSk7XG4gIHJbOV0gPSBjYW1sX2ludDY0X29mX2ludDMyKHJbOV0pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfbHN0YXRcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX2ZhaWx3aXRoXG4vL0FsaWFzOiB1bml4X2xzdGF0XG5mdW5jdGlvbiBjYW1sX3VuaXhfbHN0YXQobmFtZSkge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICBpZiAoIXJvb3QuZGV2aWNlLmxzdGF0KSB7XG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfdW5peF9sc3RhdDogbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIHJldHVybiByb290LmRldmljZS5sc3RhdChyb290LnJlc3QsIC8qIHJhaXNlIFVuaXhfZXJyb3IgKi8gdHJ1ZSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9sc3RhdF82NFxuLy9SZXF1aXJlczogY2FtbF91bml4X2xzdGF0LCBjYW1sX2ludDY0X29mX2ludDMyXG4vL0FsaWFzOiB1bml4X2xzdGF0XzY0XG5mdW5jdGlvbiBjYW1sX3VuaXhfbHN0YXRfNjQobmFtZSkge1xuICB2YXIgciA9IGNhbWxfdW5peF9sc3RhdChuYW1lKTtcbiAgcls5XSA9IGNhbWxfaW50NjRfb2ZfaW50MzIocls5XSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9ta2RpclxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfZmFpbHdpdGhcbi8vQWxpYXM6IHVuaXhfbWtkaXJcbmZ1bmN0aW9uIGNhbWxfdW5peF9ta2RpcihuYW1lLCBwZXJtKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIGlmICghcm9vdC5kZXZpY2UubWtkaXIpIHtcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF91bml4X21rZGlyOiBub3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgcmV0dXJuIHJvb3QuZGV2aWNlLm1rZGlyKHJvb3QucmVzdCwgcGVybSwgLyogcmFpc2UgVW5peF9lcnJvciAqLyB0cnVlKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X3JtZGlyXG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9mYWlsd2l0aFxuLy9BbGlhczogdW5peF9ybWRpclxuZnVuY3Rpb24gY2FtbF91bml4X3JtZGlyKG5hbWUpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgaWYgKCFyb290LmRldmljZS5ybWRpcikge1xuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3VuaXhfcm1kaXI6IG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICByZXR1cm4gcm9vdC5kZXZpY2Uucm1kaXIocm9vdC5yZXN0LCAvKiByYWlzZSBVbml4X2Vycm9yICovIHRydWUpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfc3ltbGlua1xuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfZmFpbHdpdGhcbi8vQWxpYXM6IHVuaXhfc3ltbGlua1xuZnVuY3Rpb24gY2FtbF91bml4X3N5bWxpbmsodG9fZGlyLCBzcmMsIGRzdCkge1xuICB2YXIgc3JjX3Jvb3QgPSByZXNvbHZlX2ZzX2RldmljZShzcmMpO1xuICB2YXIgZHN0X3Jvb3QgPSByZXNvbHZlX2ZzX2RldmljZShkc3QpO1xuICBpZihzcmNfcm9vdC5kZXZpY2UgIT0gZHN0X3Jvb3QuZGV2aWNlKVxuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3VuaXhfc3ltbGluazogY2Fubm90IHN5bWxpbmsgYmV0d2VlbiB0d28gZmlsZXN5c3RlbXNcIik7XG4gIGlmICghc3JjX3Jvb3QuZGV2aWNlLnN5bWxpbmspIHtcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF91bml4X3N5bWxpbms6IG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICByZXR1cm4gc3JjX3Jvb3QuZGV2aWNlLnN5bWxpbmsodG9fZGlyLCBzcmNfcm9vdC5yZXN0LCBkc3Rfcm9vdC5yZXN0LCAvKiByYWlzZSBVbml4X2Vycm9yICovIHRydWUpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfcmVhZGxpbmtcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX2ZhaWx3aXRoXG4vL0FsaWFzOiB1bml4X3JlYWRsaW5rXG5mdW5jdGlvbiBjYW1sX3VuaXhfcmVhZGxpbmsobmFtZSkge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICBpZiAoIXJvb3QuZGV2aWNlLnJlYWRsaW5rKSB7XG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfdW5peF9yZWFkbGluazogbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIHJldHVybiByb290LmRldmljZS5yZWFkbGluayhyb290LnJlc3QsIC8qIHJhaXNlIFVuaXhfZXJyb3IgKi8gdHJ1ZSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF91bmxpbmtcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX2ZhaWx3aXRoXG4vL0FsaWFzOiB1bml4X3VubGlua1xuZnVuY3Rpb24gY2FtbF91bml4X3VubGluayhuYW1lKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIGlmICghcm9vdC5kZXZpY2UudW5saW5rKSB7XG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfdW5peF91bmxpbms6IG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICByZXR1cm4gcm9vdC5kZXZpY2UudW5saW5rKHJvb3QucmVzdCwgLyogcmFpc2UgVW5peF9lcnJvciAqLyB0cnVlKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X2dldHVpZFxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9ub3RfZm91bmRcbi8vQWxpYXM6IHVuaXhfZ2V0dWlkXG5mdW5jdGlvbiBjYW1sX3VuaXhfZ2V0dWlkKHVuaXQpIHtcbiAgaWYoZ2xvYmFsVGhpcy5wcm9jZXNzICYmIGdsb2JhbFRoaXMucHJvY2Vzcy5nZXR1aWQpe1xuICAgIHJldHVybiBnbG9iYWxUaGlzLnByb2Nlc3MuZ2V0dWlkKCk7XG4gIH1cbiAgY2FtbF9yYWlzZV9ub3RfZm91bmQoKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X2dldHB3dWlkXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX25vdF9mb3VuZFxuLy9BbGlhczogdW5peF9nZXRwd3VpZFxuZnVuY3Rpb24gY2FtbF91bml4X2dldHB3dWlkKHVuaXQpIHtcbiAgY2FtbF9yYWlzZV9ub3RfZm91bmQoKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X2hhc19zeW1saW5rXG4vL1JlcXVpcmVzOiBmc19ub2RlX3N1cHBvcnRlZFxuLy9BbGlhczogdW5peF9oYXNfc3ltbGlua1xuZnVuY3Rpb24gY2FtbF91bml4X2hhc19zeW1saW5rKHVuaXQpIHtcbiAgcmV0dXJuIGZzX25vZGVfc3VwcG9ydGVkKCk/MTowXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9vcGVuZGlyXG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9mYWlsd2l0aFxuLy9BbGlhczogdW5peF9vcGVuZGlyXG5mdW5jdGlvbiBjYW1sX3VuaXhfb3BlbmRpcihwYXRoKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UocGF0aCk7XG4gIGlmICghcm9vdC5kZXZpY2Uub3BlbmRpcikge1xuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3VuaXhfb3BlbmRpcjogbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIHZhciBkaXJfaGFuZGxlID0gcm9vdC5kZXZpY2Uub3BlbmRpcihyb290LnJlc3QsIC8qIHJhaXNlIFVuaXhfZXJyb3IgKi8gdHJ1ZSk7XG4gIHJldHVybiB7IHBvaW50ZXIgOiBkaXJfaGFuZGxlLCBwYXRoOiBwYXRoIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X3JlYWRkaXJcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfZW5kX29mX2ZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG4vL1JlcXVpcmVzOiBtYWtlX3VuaXhfZXJyX2FyZ3MsIGNhbWxfcmFpc2Vfd2l0aF9hcmdzLCBjYW1sX25hbWVkX3ZhbHVlXG4vL0FsaWFzOiB1bml4X3JlYWRkaXJcbmZ1bmN0aW9uIGNhbWxfdW5peF9yZWFkZGlyKGRpcl9oYW5kbGUpIHtcbiAgdmFyIGVudHJ5O1xuICB0cnkge1xuICAgICAgZW50cnkgPSBkaXJfaGFuZGxlLnBvaW50ZXIucmVhZFN5bmMoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgICAgdmFyIHVuaXhfZXJyb3IgPSBjYW1sX25hbWVkX3ZhbHVlKCdVbml4LlVuaXhfZXJyb3InKTtcbiAgICAgIGNhbWxfcmFpc2Vfd2l0aF9hcmdzKHVuaXhfZXJyb3IsIG1ha2VfdW5peF9lcnJfYXJncyhcIkVCQURGXCIsIFwicmVhZGRpclwiLCBkaXJfaGFuZGxlLnBhdGgpKTtcbiAgfVxuICBpZiAoZW50cnkgPT09IG51bGwpIHtcbiAgICAgIGNhbWxfcmFpc2VfZW5kX29mX2ZpbGUoKTtcbiAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhlbnRyeS5uYW1lKTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfY2xvc2VkaXJcbi8vUmVxdWlyZXM6IG1ha2VfdW5peF9lcnJfYXJncywgY2FtbF9yYWlzZV93aXRoX2FyZ3MsIGNhbWxfbmFtZWRfdmFsdWVcbi8vQWxpYXM6IHVuaXhfY2xvc2VkaXJcbmZ1bmN0aW9uIGNhbWxfdW5peF9jbG9zZWRpcihkaXJfaGFuZGxlKSB7XG4gIHRyeSB7XG4gICAgICBkaXJfaGFuZGxlLnBvaW50ZXIuY2xvc2VTeW5jKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHZhciB1bml4X2Vycm9yID0gY2FtbF9uYW1lZF92YWx1ZSgnVW5peC5Vbml4X2Vycm9yJyk7XG4gICAgICBjYW1sX3JhaXNlX3dpdGhfYXJncyh1bml4X2Vycm9yLCBtYWtlX3VuaXhfZXJyX2FyZ3MoXCJFQkFERlwiLCBcImNsb3NlZGlyXCIsIGRpcl9oYW5kbGUucGF0aCkpO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9yZXdpbmRkaXJcbi8vUmVxdWlyZXM6IGNhbWxfdW5peF9jbG9zZWRpciwgY2FtbF91bml4X29wZW5kaXJcbi8vQWxpYXM6IHVuaXhfcmV3aW5kZGlyXG5mdW5jdGlvbiBjYW1sX3VuaXhfcmV3aW5kZGlyKGRpcl9oYW5kbGUpIHtcbiAgY2FtbF91bml4X2Nsb3NlZGlyKGRpcl9oYW5kbGUpO1xuICB2YXIgbmV3X2Rpcl9oYW5kbGUgPSBjYW1sX3VuaXhfb3BlbmRpcihkaXJfaGFuZGxlLnBhdGgpO1xuICBkaXJfaGFuZGxlLnBvaW50ZXIgPSBuZXdfZGlyX2hhbmRsZS5wb2ludGVyO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X2ZpbmRmaXJzdFxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcsIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX3VuaXhfb3BlbmRpciwgY2FtbF91bml4X3JlYWRkaXJcbi8vQWxpYXM6IHdpbl9maW5kZmlyc3RcbmZ1bmN0aW9uIGNhbWxfdW5peF9maW5kZmlyc3QocGF0aCkge1xuICAvLyBUaGUgV2luZG93cyBjb2RlIGFkZHMgdGhpcyBnbG9iIHRvIHRoZSBwYXRoLCBzbyB3ZSBuZWVkIHRvIHJlbW92ZSBpdFxuICB2YXIgcGF0aF9qcyA9IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHBhdGgpO1xuICBwYXRoX2pzID0gcGF0aF9qcy5yZXBsYWNlKC8oXnxbXFxcXFxcL10pXFwqXFwuXFwqJC8sIFwiXCIpO1xuICBwYXRoID0gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcocGF0aF9qcyk7XG4gIC8vICouKiBpcyBub3cgc3RyaXBwZWRcbiAgdmFyIGRpcl9oYW5kbGUgPSBjYW1sX3VuaXhfb3BlbmRpcihwYXRoKTtcbiAgdmFyIGZpcnN0X2VudHJ5ID0gY2FtbF91bml4X3JlYWRkaXIoZGlyX2hhbmRsZSk7XG4gIC8vIFRoZSBXaW5kb3dzIGJpbmRpbmdzIHR5cGUgZGlyX2hhbmRsZSBhcyBhbiBgaW50YCBidXQgaXQncyBub3QgaW4gSlNcbiAgcmV0dXJuIFswLCBmaXJzdF9lbnRyeSwgZGlyX2hhbmRsZV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9maW5kbmV4dFxuLy9SZXF1aXJlczogY2FtbF91bml4X3JlYWRkaXJcbi8vQWxpYXM6IHdpbl9maW5kbmV4dFxuZnVuY3Rpb24gY2FtbF91bml4X2ZpbmRuZXh0KGRpcl9oYW5kbGUpIHtcbiAgcmV0dXJuIGNhbWxfdW5peF9yZWFkZGlyKGRpcl9oYW5kbGUpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfZmluZGNsb3NlXG4vL1JlcXVpcmVzOiBjYW1sX3VuaXhfY2xvc2VkaXJcbi8vQWxpYXM6IHdpbl9maW5kY2xvc2VcbmZ1bmN0aW9uIGNhbWxfdW5peF9maW5kY2xvc2UoZGlyX2hhbmRsZSkge1xuICByZXR1cm4gY2FtbF91bml4X2Nsb3NlZGlyKGRpcl9oYW5kbGUpO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9pbmV0X2FkZHJfb2Zfc3RyaW5nXG4vL0FsaWFzOiB1bml4X2luZXRfYWRkcl9vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfdW5peF9pbmV0X2FkZHJfb2Zfc3RyaW5nICgpIHtyZXR1cm4gMDt9XG5cblxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBTeXNcblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV9zeXNfZXJyb3IgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV93aXRoX3N0cmluZywgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9yYWlzZV9zeXNfZXJyb3IgKG1zZykge1xuICBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nKGNhbWxfZ2xvYmFsX2RhdGEuU3lzX2Vycm9yLCBtc2cpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19leGl0XG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfc3lzX2V4aXQgKGNvZGUpIHtcbiAgaWYoZ2xvYmFsVGhpcy5xdWl0KSBnbG9iYWxUaGlzLnF1aXQoY29kZSk7XG4gIC8vbm9kZWpzXG4gIGlmKGdsb2JhbFRoaXMucHJvY2VzcyAmJiBnbG9iYWxUaGlzLnByb2Nlc3MuZXhpdClcbiAgICBnbG9iYWxUaGlzLnByb2Nlc3MuZXhpdChjb2RlKTtcbiAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiRnVuY3Rpb24gJ2V4aXQnIG5vdCBpbXBsZW1lbnRlZFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pc19zcGVjaWFsX2V4Y2VwdGlvblxuZnVuY3Rpb24gY2FtbF9pc19zcGVjaWFsX2V4Y2VwdGlvbihleG4pe1xuICBzd2l0Y2goZXhuWzJdKSB7XG4gIGNhc2UgLTg6IC8vIE1hdGNoX2ZhaWx1cmVcbiAgY2FzZSAtMTE6IC8vIEFzc2VydF9mYWlsdXJlXG4gIGNhc2UgLTEyOiAvLyBVbmRlZmluZWRfcmVjdXJzaXZlX21vZHVsZVxuICAgIHJldHVybiAxO1xuICBkZWZhdWx0OlxuICAgIHJldHVybiAwO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZm9ybWF0X2V4Y2VwdGlvblxuLy9SZXF1aXJlczogTWxCeXRlcywgY2FtbF9pc19zcGVjaWFsX2V4Y2VwdGlvblxuZnVuY3Rpb24gY2FtbF9mb3JtYXRfZXhjZXB0aW9uKGV4bil7XG4gIHZhciByID0gXCJcIjtcbiAgaWYoZXhuWzBdID09IDApIHtcbiAgICByICs9IGV4blsxXVsxXTtcbiAgICBpZihleG4ubGVuZ3RoID09IDMgJiYgZXhuWzJdWzBdID09IDAgJiYgY2FtbF9pc19zcGVjaWFsX2V4Y2VwdGlvbihleG5bMV0pKSB7XG5cbiAgICAgIHZhciBidWNrZXQgPSBleG5bMl07XG4gICAgICB2YXIgc3RhcnQgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3RhcnQgPSAyXG4gICAgICB2YXIgYnVja2V0ID0gZXhuO1xuICAgIH1cbiAgICByICs9IFwiKFwiO1xuICAgIGZvcih2YXIgaSA9IHN0YXJ0OyBpIDwgYnVja2V0Lmxlbmd0aDsgaSArKyl7XG4gICAgICBpZihpID4gc3RhcnQpIHIrPVwiLCBcIjtcbiAgICAgIHZhciB2ID0gYnVja2V0W2ldXG4gICAgICBpZih0eXBlb2YgdiA9PSBcIm51bWJlclwiKVxuICAgICAgICByKz0gdi50b1N0cmluZygpO1xuICAgICAgZWxzZSBpZih2IGluc3RhbmNlb2YgTWxCeXRlcyl7XG4gICAgICAgIHIrPSAnXCInICsgdi50b1N0cmluZygpICsgJ1wiJztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYodHlwZW9mIHYgPT0gXCJzdHJpbmdcIil7XG4gICAgICAgIHIrPSAnXCInICsgdi50b1N0cmluZygpICsgJ1wiJztcbiAgICAgIH1cbiAgICAgIGVsc2UgciArPSBcIl9cIjtcbiAgICB9XG4gICAgciArPSBcIilcIlxuICB9IGVsc2UgaWYgKGV4blswXSA9PSAyNDgpe1xuICAgIHIgKz0gZXhuWzFdXG4gIH1cbiAgcmV0dXJuIHJcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mYXRhbF91bmNhdWdodF9leGNlcHRpb25cbi8vUmVxdWlyZXM6IGNhbWxfbmFtZWRfdmFsdWUsIGNhbWxfZm9ybWF0X2V4Y2VwdGlvbiwgY2FtbF9jYWxsYmFja1xuZnVuY3Rpb24gY2FtbF9mYXRhbF91bmNhdWdodF9leGNlcHRpb24oZXJyKXtcbiAgaWYoZXJyIGluc3RhbmNlb2YgQXJyYXkgJiYgKGVyclswXSA9PSAwIHx8IGVyclswXSA9PSAyNDgpKSB7XG4gICAgdmFyIGhhbmRsZXIgPSBjYW1sX25hbWVkX3ZhbHVlKFwiUHJpbnRleGMuaGFuZGxlX3VuY2F1Z2h0X2V4Y2VwdGlvblwiKTtcbiAgICBpZihoYW5kbGVyKSBjYW1sX2NhbGxiYWNrKGhhbmRsZXIsIFtlcnIsZmFsc2VdKTtcbiAgICBlbHNlIHtcbiAgICAgIHZhciBtc2cgPSBjYW1sX2Zvcm1hdF9leGNlcHRpb24oZXJyKTtcbiAgICAgIHZhciBhdF9leGl0ID0gY2FtbF9uYW1lZF92YWx1ZShcIlBlcnZhc2l2ZXMuZG9fYXRfZXhpdFwiKTtcbiAgICAgIGlmKGF0X2V4aXQpIGNhbWxfY2FsbGJhY2soYXRfZXhpdCwgWzBdKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYXRhbCBlcnJvcjogZXhjZXB0aW9uIFwiICsgbXNnICsgXCJcXG5cIik7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIHRocm93IGVyclxuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc2V0X3N0YXRpY19lbnZcbmZ1bmN0aW9uIGNhbWxfc2V0X3N0YXRpY19lbnYoayx2KXtcbiAgaWYoIWdsb2JhbFRoaXMuanNvb19zdGF0aWNfZW52KVxuICAgIGdsb2JhbFRoaXMuanNvb19zdGF0aWNfZW52ID0ge31cbiAgZ2xvYmFsVGhpcy5qc29vX3N0YXRpY19lbnZba10gPSB2O1xuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2dldGVudiAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX25vdF9mb3VuZFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N5c19nZXRlbnYgKG5hbWUpIHtcbiAgdmFyIHByb2Nlc3MgPSBnbG9iYWxUaGlzLnByb2Nlc3M7XG4gIHZhciBuID0gY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcobmFtZSk7XG4gIC8vbm9kZWpzIGVudlxuICBpZihwcm9jZXNzXG4gICAgICYmIHByb2Nlc3MuZW52XG4gICAgICYmIHByb2Nlc3MuZW52W25dICE9IHVuZGVmaW5lZClcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcocHJvY2Vzcy5lbnZbbl0pO1xuICBpZihnbG9iYWxUaGlzLmpzb29fc3RhdGljX2VudlxuICAgICAmJiBnbG9iYWxUaGlzLmpzb29fc3RhdGljX2VudltuXSlcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcoZ2xvYmFsVGhpcy5qc29vX3N0YXRpY19lbnZbbl0pXG4gIGNhbWxfcmFpc2Vfbm90X2ZvdW5kICgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c191bnNhZmVfZ2V0ZW52XG4vL1JlcXVpcmVzOiBjYW1sX3N5c19nZXRlbnZcbmZ1bmN0aW9uIGNhbWxfc3lzX3Vuc2FmZV9nZXRlbnYobmFtZSl7XG4gIHJldHVybiBjYW1sX3N5c19nZXRlbnYgKG5hbWUpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FyZ3Zcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG52YXIgY2FtbF9hcmd2ID0gKChmdW5jdGlvbiAoKSB7XG4gIHZhciBwcm9jZXNzID0gZ2xvYmFsVGhpcy5wcm9jZXNzO1xuICB2YXIgbWFpbiA9IFwiYS5vdXRcIjtcbiAgdmFyIGFyZ3MgPSBbXVxuXG4gIGlmKHByb2Nlc3NcbiAgICAgJiYgcHJvY2Vzcy5hcmd2XG4gICAgICYmIHByb2Nlc3MuYXJndi5sZW5ndGggPiAxKSB7XG4gICAgdmFyIGFyZ3YgPSBwcm9jZXNzLmFyZ3ZcbiAgICAvL25vZGVqc1xuICAgIG1haW4gPSBhcmd2WzFdO1xuICAgIGFyZ3MgPSBhcmd2LnNsaWNlKDIpO1xuICB9XG5cbiAgdmFyIHAgPSBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhtYWluKTtcbiAgdmFyIGFyZ3MyID0gWzAsIHBdO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKylcbiAgICBhcmdzMi5wdXNoKGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKGFyZ3NbaV0pKTtcbiAgcmV0dXJuIGFyZ3MyO1xufSkoKSlcblxuLy9Qcm92aWRlczogY2FtbF9leGVjdXRhYmxlX25hbWVcbi8vUmVxdWlyZXM6IGNhbWxfYXJndlxudmFyIGNhbWxfZXhlY3V0YWJsZV9uYW1lID0gY2FtbF9hcmd2WzFdXG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2dldF9hcmd2XG4vL1JlcXVpcmVzOiBjYW1sX2FyZ3ZcbmZ1bmN0aW9uIGNhbWxfc3lzX2dldF9hcmd2IChhKSB7XG4gIHJldHVybiBbMCwgY2FtbF9hcmd2WzFdLCBjYW1sX2FyZ3ZdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19hcmd2XG4vL1JlcXVpcmVzOiBjYW1sX2FyZ3ZcbmZ1bmN0aW9uIGNhbWxfc3lzX2FyZ3YgKGEpIHtcbiAgcmV0dXJuIGNhbWxfYXJndjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfbW9kaWZ5X2FyZ3Zcbi8vUmVxdWlyZXM6IGNhbWxfYXJndlxuZnVuY3Rpb24gY2FtbF9zeXNfbW9kaWZ5X2FyZ3YoYXJnKXtcbiAgY2FtbF9hcmd2ID0gYXJnO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZXhlY3V0YWJsZV9uYW1lIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2V4ZWN1dGFibGVfbmFtZVxuZnVuY3Rpb24gY2FtbF9zeXNfZXhlY3V0YWJsZV9uYW1lKGEpe1xuICByZXR1cm4gY2FtbF9leGVjdXRhYmxlX25hbWVcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfc3lzdGVtX2NvbW1hbmRcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N5c19zeXN0ZW1fY29tbWFuZChjbWQpe1xuICB2YXIgY21kID0gY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcoY21kKTtcbiAgaWYgKHR5cGVvZiByZXF1aXJlICE9IFwidW5kZWZpbmVkXCIpe1xuICAgIHZhciBjaGlsZF9wcm9jZXNzID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpO1xuICAgIGlmKGNoaWxkX3Byb2Nlc3MgJiYgY2hpbGRfcHJvY2Vzcy5leGVjU3luYylcbiAgICAgIHRyeSB7XG4gICAgICAgIGNoaWxkX3Byb2Nlc3MuZXhlY1N5bmMoY21kLHtzdGRpbzogJ2luaGVyaXQnfSk7XG4gICAgICAgIHJldHVybiAwXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiAxXG4gICAgICB9XG4gIH1cbiAgZWxzZSByZXR1cm4gMTI3O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19zeXN0ZW1fY29tbWFuZFxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbi8vSWY6IGJyb3dzZXJcbmZ1bmN0aW9uIGNhbWxfc3lzX3N5c3RlbV9jb21tYW5kKGNtZCl7XG4gIHJldHVybiAxMjc7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3RpbWUgbXV0YWJsZVxudmFyIGNhbWxfaW5pdGlhbF90aW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAqIDAuMDAxO1xuZnVuY3Rpb24gY2FtbF9zeXNfdGltZSAoKSB7XG4gIHZhciBub3cgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICByZXR1cm4gbm93ICogMC4wMDEgLSBjYW1sX2luaXRpYWxfdGltZTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfdGltZV9pbmNsdWRlX2NoaWxkcmVuXG4vL1JlcXVpcmVzOiBjYW1sX3N5c190aW1lXG5mdW5jdGlvbiBjYW1sX3N5c190aW1lX2luY2x1ZGVfY2hpbGRyZW4oYikge1xuICByZXR1cm4gY2FtbF9zeXNfdGltZSgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19yYW5kb21fc2VlZCBtdXRhYmxlXG4vL1RoZSBmdW5jdGlvbiBuZWVkcyB0byByZXR1cm4gYW4gYXJyYXkgc2luY2UgT0NhbWwgNC4wLi4uXG5mdW5jdGlvbiBjYW1sX3N5c19yYW5kb21fc2VlZCAoKSB7XG4gIGlmKGdsb2JhbFRoaXMuY3J5cHRvKSB7XG4gICAgaWYodHlwZW9mIGdsb2JhbFRoaXMuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PT0gJ2Z1bmN0aW9uJyl7XG4gICAgICAvLyBXZWJicm93c2Vyc1xuICAgICAgdmFyIGEgPSBuZXcgVWludDMyQXJyYXkoMSk7XG4gICAgICBnbG9iYWxUaGlzLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYSk7XG4gICAgICByZXR1cm4gWzAsYVswXV07XG4gICAgfSBlbHNlIGlmKGdsb2JhbFRoaXMuY3J5cHRvLnJhbmRvbUJ5dGVzID09PSAnZnVuY3Rpb24nKXtcbiAgICAgIC8vIE5vZGVqc1xuICAgICAgdmFyIGJ1ZmYgPSBnbG9iYWxUaGlzLmNyeXB0by5yYW5kb21CeXRlcyg0KTtcbiAgICAgIHZhciBhID0gbmV3IFVpbnQzMkFycmF5KGJ1ZmYpO1xuICAgICAgcmV0dXJuIFswLGFbMF1dO1xuICAgIH1cbiAgfVxuICB2YXIgbm93ID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgdmFyIHggPSBub3deMHhmZmZmZmZmZipNYXRoLnJhbmRvbSgpO1xuICByZXR1cm4gWzAseF07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X2JpZ19lbmRpYW4gY29uc3RcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X2JpZ19lbmRpYW4gKCkgeyByZXR1cm4gMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF93b3JkX3NpemUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X3dvcmRfc2l6ZSAoKSB7IHJldHVybiAzMjsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9pbnRfc2l6ZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3RfaW50X3NpemUgKCkgeyByZXR1cm4gMzI7IH1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3RfbWF4X3dvc2l6ZSBjb25zdFxuLy8gbWF4X2ludCAvIDQgc28gdGhhdCB0aGUgZm9sbG93aW5nIGRvZXMgbm90IG92ZXJmbG93XG4vL2xldCBtYXhfc3RyaW5nX2xlbmd0aCA9IHdvcmRfc2l6ZSAvIDggKiBtYXhfYXJyYXlfbGVuZ3RoIC0gMTs7XG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9tYXhfd29zaXplICgpIHsgcmV0dXJuICgweDdGRkZGRkZGLzQpIHwgMDt9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X29zdHlwZV91bml4IGNvbnN0XG4vL1JlcXVpcmVzOiBvc190eXBlXG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9vc3R5cGVfdW5peCAoKSB7IHJldHVybiBvc190eXBlID09IFwiVW5peFwiID8gMSA6IDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X29zdHlwZV93aW4zMiBjb25zdFxuLy9SZXF1aXJlczogb3NfdHlwZVxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3Rfb3N0eXBlX3dpbjMyICgpIHsgcmV0dXJuIG9zX3R5cGUgPT0gXCJXaW4zMlwiID8gMSA6IDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X29zdHlwZV9jeWd3aW4gY29uc3Rcbi8vUmVxdWlyZXM6IG9zX3R5cGVcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X29zdHlwZV9jeWd3aW4gKCkgeyByZXR1cm4gb3NfdHlwZSA9PSBcIkN5Z3dpblwiID8gMSA6IDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3RfYmFja2VuZF90eXBlIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9iYWNrZW5kX3R5cGUgKCkge1xuICByZXR1cm4gWzAsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJqc19vZl9vY2FtbFwiKV07XG59XG5cbi8vUHJvdmlkZXM6IG9zX3R5cGVcbnZhciBvc190eXBlID0gKGdsb2JhbFRoaXMucHJvY2VzcyAmJlxuICAgICAgICAgICAgICAgZ2xvYmFsVGhpcy5wcm9jZXNzLnBsYXRmb3JtICYmXG4gICAgICAgICAgICAgICBnbG9iYWxUaGlzLnByb2Nlc3MucGxhdGZvcm0gPT0gXCJ3aW4zMlwiKSA/IFwiQ3lnd2luXCIgOiBcIlVuaXhcIjtcblxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19nZXRfY29uZmlnIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzLCBvc190eXBlXG5mdW5jdGlvbiBjYW1sX3N5c19nZXRfY29uZmlnICgpIHtcbiAgcmV0dXJuIFswLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKG9zX3R5cGUpLCAzMiwgMF07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2lzYXR0eVxuZnVuY3Rpb24gY2FtbF9zeXNfaXNhdHR5KF9jaGFuKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3J1bnRpbWVfdmFyaWFudFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9ydW50aW1lX3ZhcmlhbnQoX3VuaXQpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJcIik7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX3J1bnRpbWVfcGFyYW1ldGVyc1xuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9ydW50aW1lX3BhcmFtZXRlcnMoX3VuaXQpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5zdGFsbF9zaWduYWxfaGFuZGxlciBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnN0YWxsX3NpZ25hbF9oYW5kbGVyKCl7cmV0dXJuIDB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfcnVudGltZV93YXJuaW5nc1xudmFyIGNhbWxfcnVudGltZV93YXJuaW5ncyA9IDA7XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfZW5hYmxlX3J1bnRpbWVfd2FybmluZ3Ncbi8vUmVxdWlyZXM6IGNhbWxfcnVudGltZV93YXJuaW5nc1xuZnVuY3Rpb24gY2FtbF9tbF9lbmFibGVfcnVudGltZV93YXJuaW5ncyAoYm9vbCkge1xuICBjYW1sX3J1bnRpbWVfd2FybmluZ3MgPSBib29sO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9ydW50aW1lX3dhcm5pbmdzX2VuYWJsZWRcbi8vUmVxdWlyZXM6IGNhbWxfcnVudGltZV93YXJuaW5nc1xuZnVuY3Rpb24gY2FtbF9tbF9ydW50aW1lX3dhcm5pbmdzX2VuYWJsZWQgKF91bml0KSB7XG4gIHJldHVybiBjYW1sX3J1bnRpbWVfd2FybmluZ3M7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9zcGFjZXRpbWVfZW5hYmxlZCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX3NwYWNldGltZV9lbmFibGVkKF91bml0KSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9uYWtlZF9wb2ludGVyc19jaGVja2VkIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X25ha2VkX3BvaW50ZXJzX2NoZWNrZWQoX3VuaXQpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmVnaXN0ZXJfY2hhbm5lbF9mb3Jfc3BhY2V0aW1lIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfcmVnaXN0ZXJfY2hhbm5lbF9mb3Jfc3BhY2V0aW1lKF9jaGFubmVsKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3NwYWNldGltZV9vbmx5X3dvcmtzX2Zvcl9uYXRpdmVfY29kZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9zcGFjZXRpbWVfb25seV93b3Jrc19mb3JfbmF0aXZlX2NvZGUoKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJTcGFjZXRpbWUgcHJvZmlsaW5nIG9ubHkgd29ya3MgZm9yIG5hdGl2ZSBjb2RlXCIpO1xufVxuXG4vL0Fsd2F5c1xuLy9SZXF1aXJlczogY2FtbF9mYXRhbF91bmNhdWdodF9leGNlcHRpb25cbmZ1bmN0aW9uIGNhbWxfc2V0dXBfdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIoKSB7XG4gIHZhciBwcm9jZXNzID0gZ2xvYmFsVGhpcy5wcm9jZXNzO1xuICBpZihwcm9jZXNzICYmIHByb2Nlc3Mub24pIHtcbiAgICBwcm9jZXNzLm9uKCd1bmNhdWdodEV4Y2VwdGlvbicsIGZ1bmN0aW9uIChlcnIsIG9yaWdpbikge1xuICAgICAgY2FtbF9mYXRhbF91bmNhdWdodF9leGNlcHRpb24oZXJyKTtcbiAgICAgIHByb2Nlc3MuZXhpdCAoMik7XG4gICAgfSlcbiAgfVxuICBlbHNlIGlmKGdsb2JhbFRoaXMuYWRkRXZlbnRMaXN0ZW5lcil7XG4gICAgZ2xvYmFsVGhpcy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZ1bmN0aW9uKGV2ZW50KXtcbiAgICAgIGlmKGV2ZW50LmVycm9yKXtcbiAgICAgICAgY2FtbF9mYXRhbF91bmNhdWdodF9leGNlcHRpb24oZXZlbnQuZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5jYW1sX3NldHVwX3VuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyKCk7XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSsOpcsO0bWUgVm91aWxsb24sIEh1Z28gSGV1emFyZFxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBNbEZha2VEZXZpY2Vcbi8vUmVxdWlyZXM6IE1sRmFrZUZpbGUsIE1sRmFrZUZkLCBjYW1sX2NyZWF0ZV9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzLCBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9ieXRlc19vZl9hcnJheSwgY2FtbF9ieXRlc19vZl9zdHJpbmcsIGNhbWxfYnl0ZXNfb2ZfanNieXRlc1xuLy9SZXF1aXJlczogY2FtbF9pc19tbF9ieXRlcywgY2FtbF9pc19tbF9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfbmFtZWRfdmFsdWUsIGNhbWxfcmFpc2Vfd2l0aF9hcmdzLCBjYW1sX25hbWVkX3ZhbHVlc1xuLy9SZXF1aXJlczogbWFrZV91bml4X2Vycl9hcmdzXG5mdW5jdGlvbiBNbEZha2VEZXZpY2UgKHJvb3QsIGYpIHtcbiAgdGhpcy5jb250ZW50PXt9O1xuICB0aGlzLnJvb3QgPSByb290O1xuICB0aGlzLmxvb2t1cEZ1biA9IGY7XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLm5tID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gKHRoaXMucm9vdCArIG5hbWUpO1xufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5jcmVhdGVfZGlyX2lmX25lZWRlZCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIGNvbXAgPSBuYW1lLnNwbGl0KFwiL1wiKTtcbiAgdmFyIHJlcyA9IFwiXCI7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBjb21wLmxlbmd0aCAtIDE7IGkrKyl7XG4gICAgcmVzICs9IGNvbXBbaV0gKyBcIi9cIjtcbiAgICBpZih0aGlzLmNvbnRlbnRbcmVzXSkgY29udGludWU7XG4gICAgdGhpcy5jb250ZW50W3Jlc10gPSBTeW1ib2woXCJkaXJlY3RvcnlcIik7XG4gIH1cbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUuc2xhc2ggPSBmdW5jdGlvbihuYW1lKXtcbiAgcmV0dXJuIC9cXC8kLy50ZXN0KG5hbWUpP25hbWU6KG5hbWUgKyBcIi9cIik7XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLmxvb2t1cCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgaWYoIXRoaXMuY29udGVudFtuYW1lXSAmJiB0aGlzLmxvb2t1cEZ1bikge1xuICAgIHZhciByZXMgPSB0aGlzLmxvb2t1cEZ1bihjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHRoaXMucm9vdCksIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMobmFtZSkpO1xuICAgIGlmKHJlcyAhPT0gMCkge1xuICAgICAgdGhpcy5jcmVhdGVfZGlyX2lmX25lZWRlZChuYW1lKTtcbiAgICAgIHRoaXMuY29udGVudFtuYW1lXT1uZXcgTWxGYWtlRmlsZShjYW1sX2J5dGVzX29mX3N0cmluZyhyZXNbMV0pKTtcbiAgICB9XG4gIH1cbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUuZXhpc3RzID0gZnVuY3Rpb24obmFtZSkge1xuICAvLyBUaGUgcm9vdCBvZiB0aGUgZGV2aWNlIGV4aXN0c1xuICBpZihuYW1lID09IFwiXCIpIHJldHVybiAxO1xuICAvLyBDaGVjayBpZiBhIGRpcmVjdG9yeSBleGlzdHNcbiAgdmFyIG5hbWVfc2xhc2ggPSB0aGlzLnNsYXNoKG5hbWUpO1xuICBpZih0aGlzLmNvbnRlbnRbbmFtZV9zbGFzaF0pIHJldHVybiAxO1xuICAvLyBDaGVjayBpZiBhIGZpbGUgZXhpc3RzXG4gIHRoaXMubG9va3VwKG5hbWUpO1xuICByZXR1cm4gdGhpcy5jb250ZW50W25hbWVdPzE6MDtcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUubWtkaXIgPSBmdW5jdGlvbihuYW1lLG1vZGUsIHJhaXNlX3VuaXgpIHtcbiAgdmFyIHVuaXhfZXJyb3IgPSByYWlzZV91bml4ICYmIGNhbWxfbmFtZWRfdmFsdWUoJ1VuaXguVW5peF9lcnJvcicpO1xuICBpZih0aGlzLmV4aXN0cyhuYW1lKSkge1xuICAgIGlmICh1bml4X2Vycm9yKSB7XG4gICAgICBjYW1sX3JhaXNlX3dpdGhfYXJncyh1bml4X2Vycm9yLCBtYWtlX3VuaXhfZXJyX2FyZ3MoXCJFRVhJU1RcIiwgXCJta2RpclwiLCB0aGlzLm5tKG5hbWUpKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IobmFtZSArIFwiOiBGaWxlIGV4aXN0c1wiKTtcbiAgICB9XG4gIH1cbiAgdmFyIHBhcmVudCA9IC9eKC4qKVxcL1teL10rLy5leGVjKG5hbWUpO1xuICBwYXJlbnQgPSAocGFyZW50ICYmIHBhcmVudFsxXSkgfHwgJyc7XG4gIGlmKCF0aGlzLmV4aXN0cyhwYXJlbnQpKXtcbiAgICBpZiAodW5peF9lcnJvcikge1xuICAgICAgY2FtbF9yYWlzZV93aXRoX2FyZ3ModW5peF9lcnJvciwgbWFrZV91bml4X2Vycl9hcmdzKFwiRU5PRU5UXCIsIFwibWtkaXJcIiwgdGhpcy5ubShwYXJlbnQpKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IocGFyZW50ICsgXCI6IE5vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnlcIik7XG4gICAgfVxuICB9XG4gIGlmKCF0aGlzLmlzX2RpcihwYXJlbnQpKXtcbiAgICBpZiAodW5peF9lcnJvcikge1xuICAgICAgY2FtbF9yYWlzZV93aXRoX2FyZ3ModW5peF9lcnJvciwgbWFrZV91bml4X2Vycl9hcmdzKFwiRU5PVERJUlwiLCBcIm1rZGlyXCIsIHRoaXMubm0ocGFyZW50KSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHBhcmVudCArIFwiOiBOb3QgYSBkaXJlY3RvcnlcIik7XG4gICAgfVxuICB9XG4gIHRoaXMuY3JlYXRlX2Rpcl9pZl9uZWVkZWQodGhpcy5zbGFzaChuYW1lKSk7XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLnJtZGlyID0gZnVuY3Rpb24obmFtZSwgcmFpc2VfdW5peCkge1xuICB2YXIgdW5peF9lcnJvciA9IHJhaXNlX3VuaXggJiYgY2FtbF9uYW1lZF92YWx1ZSgnVW5peC5Vbml4X2Vycm9yJyk7XG4gIHZhciBuYW1lX3NsYXNoID0gKG5hbWUgPT0gXCJcIik/XCJcIjoodGhpcy5zbGFzaChuYW1lKSk7XG4gIHZhciByID0gbmV3IFJlZ0V4cChcIl5cIiArIG5hbWVfc2xhc2ggKyBcIihbXi9dKylcIik7XG4gIGlmKCF0aGlzLmV4aXN0cyhuYW1lKSkge1xuICAgIGlmICh1bml4X2Vycm9yKSB7XG4gICAgICBjYW1sX3JhaXNlX3dpdGhfYXJncyh1bml4X2Vycm9yLCBtYWtlX3VuaXhfZXJyX2FyZ3MoXCJFTk9FTlRcIiwgXCJybWRpclwiLCB0aGlzLm5tKG5hbWUpKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IobmFtZSArIFwiOiBObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5XCIpO1xuICAgIH1cbiAgfVxuICBpZighdGhpcy5pc19kaXIobmFtZSkpIHtcbiAgICBpZiAodW5peF9lcnJvcikge1xuICAgICAgY2FtbF9yYWlzZV93aXRoX2FyZ3ModW5peF9lcnJvciwgbWFrZV91bml4X2Vycl9hcmdzKFwiRU5PVERJUlwiLCBcInJtZGlyXCIsIHRoaXMubm0obmFtZSkpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihuYW1lICsgXCI6IE5vdCBhIGRpcmVjdG9yeVwiKTtcbiAgICB9XG4gIH1cbiAgZm9yKHZhciBuIGluIHRoaXMuY29udGVudCkge1xuICAgIGlmKG4ubWF0Y2gocikpIHtcbiAgICAgIGlmICh1bml4X2Vycm9yKSB7XG4gICAgICAgIGNhbWxfcmFpc2Vfd2l0aF9hcmdzKHVuaXhfZXJyb3IsIG1ha2VfdW5peF9lcnJfYXJncyhcIkVOT1RFTVBUWVwiLCBcInJtZGlyXCIsIHRoaXMubm0obmFtZSkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIjogRGlyZWN0b3J5IG5vdCBlbXB0eVwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZGVsZXRlIHRoaXMuY29udGVudFtuYW1lX3NsYXNoXTtcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUucmVhZGRpciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIG5hbWVfc2xhc2ggPSAobmFtZSA9PSBcIlwiKT9cIlwiOih0aGlzLnNsYXNoKG5hbWUpKTtcbiAgaWYoIXRoaXMuZXhpc3RzKG5hbWUpKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IobmFtZSArIFwiOiBObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5XCIpO1xuICB9XG4gIGlmKCF0aGlzLmlzX2RpcihuYW1lKSkge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKG5hbWUgKyBcIjogTm90IGEgZGlyZWN0b3J5XCIpO1xuICB9XG4gIHZhciByID0gbmV3IFJlZ0V4cChcIl5cIiArIG5hbWVfc2xhc2ggKyBcIihbXi9dKylcIik7XG4gIHZhciBzZWVuID0ge31cbiAgdmFyIGEgPSBbXTtcbiAgZm9yKHZhciBuIGluIHRoaXMuY29udGVudCkge1xuICAgIHZhciBtID0gbi5tYXRjaChyKTtcbiAgICBpZihtICYmICFzZWVuW21bMV1dKSB7c2VlblttWzFdXSA9IHRydWU7IGEucHVzaChtWzFdKX1cbiAgfVxuICByZXR1cm4gYTtcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUub3BlbmRpciA9IGZ1bmN0aW9uKG5hbWUsIHJhaXNlX3VuaXgpIHtcbiAgdmFyIHVuaXhfZXJyb3IgPSByYWlzZV91bml4ICYmIGNhbWxfbmFtZWRfdmFsdWUoJ1VuaXguVW5peF9lcnJvcicpO1xuXG4gIHZhciBhID0gdGhpcy5yZWFkZGlyKG5hbWUpO1xuICB2YXIgYyA9IGZhbHNlO1xuICB2YXIgaSA9IDA7XG4gIHJldHVybiB7IHJlYWRTeW5jIDogKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoYykge1xuICAgICAgaWYgKHVuaXhfZXJyb3IpIHtcbiAgICAgICAgY2FtbF9yYWlzZV93aXRoX2FyZ3ModW5peF9lcnJvciwgbWFrZV91bml4X2Vycl9hcmdzKFwiRUJBREZcIiwgXCJjbG9zZWRpclwiLCB0aGlzLm5tKG5hbWUpKSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IobmFtZSArIFwiOiBjbG9zZWRpciBmYWlsZWRcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmKGkgPT0gYS5sZW5ndGgpIHJldHVybiBudWxsO1xuICAgIHZhciBlbnRyeSA9IGFbaV07XG4gICAgaSsrO1xuICAgIHJldHVybiB7IG5hbWU6IGVudHJ5IH1cbiAgfSlcbiAgICAsIGNsb3NlU3luYzogKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChjKSB7XG4gICAgICAgIGlmICh1bml4X2Vycm9yKSB7XG4gICAgICAgICAgY2FtbF9yYWlzZV93aXRoX2FyZ3ModW5peF9lcnJvciwgbWFrZV91bml4X2Vycl9hcmdzKFwiRUJBREZcIiwgXCJjbG9zZWRpclwiLCB0aGlzLm5tKG5hbWUpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IobmFtZSArIFwiOiBjbG9zZWRpciBmYWlsZWRcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGMgPSB0cnVlO1xuICAgICAgYSA9IFtdO1xuICAgIH0pXG4gIH1cbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUuaXNfZGlyID0gZnVuY3Rpb24obmFtZSkge1xuICBpZihuYW1lID09IFwiXCIpICByZXR1cm4gdHJ1ZTtcbiAgdmFyIG5hbWVfc2xhc2ggPSB0aGlzLnNsYXNoKG5hbWUpO1xuICByZXR1cm4gdGhpcy5jb250ZW50W25hbWVfc2xhc2hdPzE6MDtcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUudW5saW5rID0gZnVuY3Rpb24obmFtZSkge1xuICB2YXIgb2sgPSB0aGlzLmNvbnRlbnRbbmFtZV0/dHJ1ZTpmYWxzZTtcbiAgZGVsZXRlIHRoaXMuY29udGVudFtuYW1lXTtcbiAgcmV0dXJuIG9rO1xufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24obmFtZSwgZikge1xuICB2YXIgZmlsZTtcbiAgaWYoZi5yZG9ubHkgJiYgZi53cm9ubHkpXG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5ubShuYW1lKSArIFwiIDogZmxhZ3MgT3Blbl9yZG9ubHkgYW5kIE9wZW5fd3Jvbmx5IGFyZSBub3QgY29tcGF0aWJsZVwiKTtcbiAgaWYoZi50ZXh0ICYmIGYuYmluYXJ5KVxuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IGZsYWdzIE9wZW5fdGV4dCBhbmQgT3Blbl9iaW5hcnkgYXJlIG5vdCBjb21wYXRpYmxlXCIpO1xuICB0aGlzLmxvb2t1cChuYW1lKTtcbiAgaWYgKHRoaXMuY29udGVudFtuYW1lXSkge1xuICAgIGlmICh0aGlzLmlzX2RpcihuYW1lKSkgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5ubShuYW1lKSArIFwiIDogaXMgYSBkaXJlY3RvcnlcIik7XG4gICAgaWYgKGYuY3JlYXRlICYmIGYuZXhjbCkgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5ubShuYW1lKSArIFwiIDogZmlsZSBhbHJlYWR5IGV4aXN0c1wiKTtcbiAgICBmaWxlID0gdGhpcy5jb250ZW50W25hbWVdO1xuICAgIGlmKGYudHJ1bmNhdGUpIGZpbGUudHJ1bmNhdGUoKTtcbiAgfSBlbHNlIGlmIChmLmNyZWF0ZSkge1xuICAgIHRoaXMuY3JlYXRlX2Rpcl9pZl9uZWVkZWQobmFtZSk7XG4gICAgdGhpcy5jb250ZW50W25hbWVdID0gbmV3IE1sRmFrZUZpbGUoY2FtbF9jcmVhdGVfYnl0ZXMoMCkpO1xuICAgIGZpbGUgPSB0aGlzLmNvbnRlbnRbbmFtZV07XG4gIH0gZWxzZSB7XG4gICAgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUgKHRoaXMubm0obmFtZSkpO1xuICB9XG4gIHJldHVybiBuZXcgTWxGYWtlRmQodGhpcy5ubShuYW1lKSwgZmlsZSwgZik7XG59XG5cbk1sRmFrZURldmljZS5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uKG5hbWUsIGYpIHtcbiAgdmFyIGZpbGU7XG4gIGlmKGYucmRvbmx5ICYmIGYud3Jvbmx5KVxuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IGZsYWdzIE9wZW5fcmRvbmx5IGFuZCBPcGVuX3dyb25seSBhcmUgbm90IGNvbXBhdGlibGVcIik7XG4gIGlmKGYudGV4dCAmJiBmLmJpbmFyeSlcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiBmbGFncyBPcGVuX3RleHQgYW5kIE9wZW5fYmluYXJ5IGFyZSBub3QgY29tcGF0aWJsZVwiKTtcbiAgdGhpcy5sb29rdXAobmFtZSk7XG4gIGlmICh0aGlzLmNvbnRlbnRbbmFtZV0pIHtcbiAgICBpZiAodGhpcy5pc19kaXIobmFtZSkpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IGlzIGEgZGlyZWN0b3J5XCIpO1xuICAgIGlmIChmLmNyZWF0ZSAmJiBmLmV4Y2wpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IGZpbGUgYWxyZWFkeSBleGlzdHNcIik7XG4gICAgZmlsZSA9IHRoaXMuY29udGVudFtuYW1lXTtcbiAgICBpZihmLnRydW5jYXRlKSBmaWxlLnRydW5jYXRlKCk7XG4gIH0gZWxzZSBpZiAoZi5jcmVhdGUpIHtcbiAgICB0aGlzLmNyZWF0ZV9kaXJfaWZfbmVlZGVkKG5hbWUpO1xuICAgIHRoaXMuY29udGVudFtuYW1lXSA9IG5ldyBNbEZha2VGaWxlKGNhbWxfY3JlYXRlX2J5dGVzKDApKTtcbiAgICBmaWxlID0gdGhpcy5jb250ZW50W25hbWVdO1xuICB9IGVsc2Uge1xuICAgIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlICh0aGlzLm5tKG5hbWUpKTtcbiAgfVxuICByZXR1cm4gbmV3IE1sRmFrZUZkKHRoaXMubm0obmFtZSksIGZpbGUsIGYpO1xufVxuXG5NbEZha2VEZXZpY2UucHJvdG90eXBlLnJlZ2lzdGVyPSBmdW5jdGlvbiAobmFtZSxjb250ZW50KXtcbiAgdmFyIGZpbGU7XG4gIGlmKHRoaXMuY29udGVudFtuYW1lXSkgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5ubShuYW1lKSArIFwiIDogZmlsZSBhbHJlYWR5IGV4aXN0c1wiKTtcbiAgaWYoY2FtbF9pc19tbF9ieXRlcyhjb250ZW50KSlcbiAgICBmaWxlID0gbmV3IE1sRmFrZUZpbGUoY29udGVudCk7XG4gIGlmKGNhbWxfaXNfbWxfc3RyaW5nKGNvbnRlbnQpKVxuICAgIGZpbGUgPSBuZXcgTWxGYWtlRmlsZShjYW1sX2J5dGVzX29mX3N0cmluZyhjb250ZW50KSk7XG4gIGVsc2UgaWYoY29udGVudCBpbnN0YW5jZW9mIEFycmF5KVxuICAgIGZpbGUgPSBuZXcgTWxGYWtlRmlsZShjYW1sX2J5dGVzX29mX2FycmF5KGNvbnRlbnQpKTtcbiAgZWxzZSBpZih0eXBlb2YgY29udGVudCA9PT0gXCJzdHJpbmdcIilcbiAgICBmaWxlID0gbmV3IE1sRmFrZUZpbGUoY2FtbF9ieXRlc19vZl9qc2J5dGVzKGNvbnRlbnQpKTtcbiAgZWxzZSBpZihjb250ZW50LnRvU3RyaW5nKSB7XG4gICAgdmFyIGJ5dGVzID0gY2FtbF9ieXRlc19vZl9zdHJpbmcoY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcoY29udGVudC50b1N0cmluZygpKSk7XG4gICAgZmlsZSA9IG5ldyBNbEZha2VGaWxlKGJ5dGVzKTtcbiAgfVxuICBpZihmaWxlKXtcbiAgICB0aGlzLmNyZWF0ZV9kaXJfaWZfbmVlZGVkKG5hbWUpO1xuICAgIHRoaXMuY29udGVudFtuYW1lXSA9IGZpbGU7XG4gIH1cbiAgZWxzZSBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiByZWdpc3RlcmluZyBmaWxlIHdpdGggaW52YWxpZCBjb250ZW50IHR5cGVcIik7XG59XG5cbk1sRmFrZURldmljZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNbEZha2VEZXZpY2VcblxuLy9Qcm92aWRlczogTWxGYWtlRmlsZVxuLy9SZXF1aXJlczogTWxGaWxlXG4vL1JlcXVpcmVzOiBjYW1sX2NyZWF0ZV9ieXRlcywgY2FtbF9tbF9ieXRlc19sZW5ndGgsIGNhbWxfYmxpdF9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF91aW50OF9hcnJheV9vZl9ieXRlcywgY2FtbF9ieXRlc19vZl9hcnJheVxuZnVuY3Rpb24gTWxGYWtlRmlsZShjb250ZW50KXtcbiAgdGhpcy5kYXRhID0gY29udGVudDtcbn1cbk1sRmFrZUZpbGUucHJvdG90eXBlID0gbmV3IE1sRmlsZSAoKTtcbk1sRmFrZUZpbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWxGYWtlRmlsZVxuTWxGYWtlRmlsZS5wcm90b3R5cGUudHJ1bmNhdGUgPSBmdW5jdGlvbihsZW4pe1xuICB2YXIgb2xkID0gdGhpcy5kYXRhO1xuICB0aGlzLmRhdGEgPSBjYW1sX2NyZWF0ZV9ieXRlcyhsZW58MCk7XG4gIGNhbWxfYmxpdF9ieXRlcyhvbGQsIDAsIHRoaXMuZGF0YSwgMCwgbGVuKTtcbn1cbk1sRmFrZUZpbGUucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKHRoaXMuZGF0YSk7XG59XG5NbEZha2VGaWxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKG9mZnNldCxidWYscG9zLGxlbil7XG4gIHZhciBjbGVuID0gdGhpcy5sZW5ndGgoKTtcbiAgaWYob2Zmc2V0ICsgbGVuID49IGNsZW4pIHtcbiAgICB2YXIgbmV3X3N0ciA9IGNhbWxfY3JlYXRlX2J5dGVzKG9mZnNldCArIGxlbik7XG4gICAgdmFyIG9sZF9kYXRhID0gdGhpcy5kYXRhO1xuICAgIHRoaXMuZGF0YSA9IG5ld19zdHI7XG4gICAgY2FtbF9ibGl0X2J5dGVzKG9sZF9kYXRhLCAwLCB0aGlzLmRhdGEsIDAsIGNsZW4pO1xuICB9XG4gIGNhbWxfYmxpdF9ieXRlcyhjYW1sX2J5dGVzX29mX2FycmF5KGJ1ZiksIHBvcywgdGhpcy5kYXRhLCBvZmZzZXQsIGxlbik7XG4gIHJldHVybiAwXG59XG5NbEZha2VGaWxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24ob2Zmc2V0LGJ1Zixwb3MsbGVuKXtcbiAgdmFyIGNsZW4gPSB0aGlzLmxlbmd0aCgpO1xuICBpZihvZmZzZXQgKyBsZW4gPj0gY2xlbikge1xuICAgIGxlbiA9IGNsZW4gLSBvZmZzZXQ7XG4gIH1cbiAgaWYobGVuKSB7XG4gICAgdmFyIGRhdGEgPSBjYW1sX2NyZWF0ZV9ieXRlcyhsZW58MCk7XG4gICAgY2FtbF9ibGl0X2J5dGVzKHRoaXMuZGF0YSwgb2Zmc2V0LCBkYXRhLCAwLCBsZW4pO1xuICAgIGJ1Zi5zZXQoY2FtbF91aW50OF9hcnJheV9vZl9ieXRlcyhkYXRhKSwgcG9zKTtcbiAgfVxuICByZXR1cm4gbGVuXG59XG5cblxuLy9Qcm92aWRlczogTWxGYWtlRmRfb3V0XG4vL1JlcXVpcmVzOiBNbEZha2VGaWxlLCBjYW1sX2NyZWF0ZV9ieXRlcywgY2FtbF9ibGl0X2J5dGVzLCBjYW1sX2J5dGVzX29mX2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvclxuZnVuY3Rpb24gTWxGYWtlRmRfb3V0KGZkLGZsYWdzKSB7XG4gIE1sRmFrZUZpbGUuY2FsbCh0aGlzLCBjYW1sX2NyZWF0ZV9ieXRlcygwKSk7XG4gIHRoaXMubG9nID0gKGZ1bmN0aW9uIChzKSB7IHJldHVybiAwIH0pO1xuICBpZihmZCA9PSAxICYmIHR5cGVvZiBjb25zb2xlLmxvZyA9PSBcImZ1bmN0aW9uXCIpXG4gICAgdGhpcy5sb2cgPSBjb25zb2xlLmxvZztcbiAgZWxzZSBpZihmZCA9PSAyICYmIHR5cGVvZiBjb25zb2xlLmVycm9yID09IFwiZnVuY3Rpb25cIilcbiAgICB0aGlzLmxvZyA9IGNvbnNvbGUuZXJyb3I7XG4gIGVsc2UgaWYodHlwZW9mIGNvbnNvbGUubG9nID09IFwiZnVuY3Rpb25cIilcbiAgICB0aGlzLmxvZyA9IGNvbnNvbGUubG9nXG4gIHRoaXMuZmxhZ3MgPSBmbGFncztcbn1cbk1sRmFrZUZkX291dC5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24oKSB7IHJldHVybiAwIH1cbk1sRmFrZUZkX291dC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAob2Zmc2V0LGJ1Zixwb3MsbGVuKSB7XG4gIGlmKHRoaXMubG9nKSB7XG4gICAgaWYobGVuID4gMFxuICAgICAgICYmIHBvcyA+PSAwXG4gICAgICAgJiYgcG9zK2xlbiA8PSBidWYubGVuZ3RoXG4gICAgICAgJiYgYnVmW3BvcytsZW4tMV0gPT0gMTApXG4gICAgICBsZW4gLS07XG4gICAgLy8gRG8gbm90IG91dHB1dCB0aGUgbGFzdCBcXG4gaWYgcHJlc2VudFxuICAgIC8vIGFzIGNvbnNvbGUgbG9nZ2luZyBkaXNwbGF5IGEgbmV3bGluZSBhdCB0aGUgZW5kXG4gICAgdmFyIHNyYyA9IGNhbWxfY3JlYXRlX2J5dGVzKGxlbik7XG4gICAgY2FtbF9ibGl0X2J5dGVzKGNhbWxfYnl0ZXNfb2ZfYXJyYXkoYnVmKSwgcG9zLCBzcmMsIDAsIGxlbik7XG4gICAgdGhpcy5sb2coc3JjLnRvVXRmMTYoKSk7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5mZCAgKyBcIjogZmlsZSBkZXNjcmlwdG9yIGFscmVhZHkgY2xvc2VkXCIpO1xufVxuTWxGYWtlRmRfb3V0LnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKG9mZnNldCwgYnVmLCBwb3MsIGxlbikge1xuICBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLmZkICArIFwiOiBmaWxlIGRlc2NyaXB0b3IgaXMgd3JpdGUgb25seVwiKTtcbn1cbk1sRmFrZUZkX291dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMubG9nID0gdW5kZWZpbmVkO1xufVxuXG5cbi8vUHJvdmlkZXM6IE1sRmFrZUZkXG4vL1JlcXVpcmVzOiBNbEZha2VGaWxlXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvclxuZnVuY3Rpb24gTWxGYWtlRmQobmFtZSwgZmlsZSxmbGFncykge1xuICB0aGlzLmZpbGUgPSBmaWxlO1xuICB0aGlzLm5hbWUgPSBuYW1lO1xuICB0aGlzLmZsYWdzID0gZmxhZ3M7XG59XG5cbk1sRmFrZUZkLnByb3RvdHlwZS5lcnJfY2xvc2VkID0gZnVuY3Rpb24gKCkge1xuICBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5hbWUgICsgXCI6IGZpbGUgZGVzY3JpcHRvciBhbHJlYWR5IGNsb3NlZFwiKTtcbn1cbk1sRmFrZUZkLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbigpIHtcbiAgaWYodGhpcy5maWxlKSByZXR1cm4gdGhpcy5maWxlLmxlbmd0aCAoKVxuICB0aGlzLmVycl9jbG9zZWQoKTtcbn1cbk1sRmFrZUZkLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChvZmZzZXQsYnVmLHBvcyxsZW4pIHtcbiAgaWYodGhpcy5maWxlKSByZXR1cm4gdGhpcy5maWxlLndyaXRlKG9mZnNldCxidWYscG9zLGxlbilcbiAgdGhpcy5lcnJfY2xvc2VkKCk7XG59XG5NbEZha2VGZC5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChvZmZzZXQsIGJ1ZiwgcG9zLCBsZW4pIHtcbiAgaWYodGhpcy5maWxlKSByZXR1cm4gdGhpcy5maWxlLnJlYWQob2Zmc2V0LCBidWYsIHBvcywgbGVuKVxuICB0aGlzLmVycl9jbG9zZWQoKTtcbn1cbk1sRmFrZUZkLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5maWxlID0gdW5kZWZpbmVkO1xufVxuIiwiLy9Qcm92aWRlczogaW5pdGlhbGl6ZV9uYXRcbi8vUmVxdWlyZXM6IGNhbWxfY3VzdG9tX29wc1xuLy9SZXF1aXJlczogc2VyaWFsaXplX25hdCwgZGVzZXJpYWxpemVfbmF0LCBjYW1sX2hhc2hfbmF0XG5mdW5jdGlvbiBpbml0aWFsaXplX25hdCgpIHtcbiAgY2FtbF9jdXN0b21fb3BzW1wiX25hdFwiXSA9XG4gICAgeyBkZXNlcmlhbGl6ZSA6IGRlc2VyaWFsaXplX25hdCxcbiAgICAgIHNlcmlhbGl6ZSA6IHNlcmlhbGl6ZV9uYXQsXG4gICAgICBoYXNoIDogY2FtbF9oYXNoX25hdFxuICAgIH1cbn1cblxuLy9Qcm92aWRlczogTWxOYXRcbmZ1bmN0aW9uIE1sTmF0KHgpe1xuICB0aGlzLmRhdGEgPSBuZXcgSW50MzJBcnJheSh4KTtcbiAgLy8gbGVuZ3RoX25hdCBpc24ndCBleHRlcm5hbCwgc28gd2UgaGF2ZSB0byBtYWtlIHRoZSBPYmouc2l6ZVxuICAvLyB3b3JrIG91dCByaWdodC4gVGhlICsyIHRvIGFycmF5IGxlbmd0aCBzZWVtcyB0byB3b3JrLlxuICB0aGlzLmxlbmd0aCA9IHRoaXMuZGF0YS5sZW5ndGggKyAyXG59XG5cbk1sTmF0LnByb3RvdHlwZS5jYW1sX2N1c3RvbSA9IFwiX25hdFwiO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbmF0XG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2ludCwgbnVtX2RpZ2l0c19uYXRcbmZ1bmN0aW9uIGNhbWxfaGFzaF9uYXQoeCkge1xuICB2YXIgbGVuID0gbnVtX2RpZ2l0c19uYXQoeCwgMCwgeC5kYXRhLmxlbmd0aCk7XG4gIHZhciBoID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB4LmRhdGFbaV0pO1xuICB9XG4gIHJldHVybiBoO1xufVxuXG5cbi8vUHJvdmlkZXM6IG5hdF9vZl9hcnJheVxuLy9SZXF1aXJlczogTWxOYXRcbmZ1bmN0aW9uIG5hdF9vZl9hcnJheShsKXtcbiAgcmV0dXJuIG5ldyBNbE5hdChsKTtcbn1cblxuLy9Qcm92aWRlczogY3JlYXRlX25hdFxuLy9SZXF1aXJlczogTWxOYXRcbmZ1bmN0aW9uIGNyZWF0ZV9uYXQoc2l6ZSkge1xuICB2YXIgYXJyID0gbmV3IE1sTmF0KHNpemUpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgYXJyLmRhdGFbaV0gPSAtMTtcbiAgfVxuICByZXR1cm4gYXJyO1xufVxuXG4vL1Byb3ZpZGVzOiBzZXRfdG9femVyb19uYXRcbmZ1bmN0aW9uIHNldF90b196ZXJvX25hdChuYXQsIG9mcywgbGVuKSB7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG5hdC5kYXRhW29mcytpXSA9IDA7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGJsaXRfbmF0XG5mdW5jdGlvbiBibGl0X25hdChuYXQxLCBvZnMxLCBuYXQyLCBvZnMyLCBsZW4pIHtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgbmF0MS5kYXRhW29mczEraV0gPSBuYXQyLmRhdGFbb2ZzMitpXTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogc2V0X2RpZ2l0X25hdFxuZnVuY3Rpb24gc2V0X2RpZ2l0X25hdChuYXQsIG9mcywgZGlnaXQpIHtcbiAgbmF0LmRhdGFbb2ZzXSA9IGRpZ2l0O1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbnRoX2RpZ2l0X25hdFxuZnVuY3Rpb24gbnRoX2RpZ2l0X25hdChuYXQsIG9mcykge1xuICByZXR1cm4gbmF0LmRhdGFbb2ZzXTtcbn1cblxuLy9Qcm92aWRlczogc2V0X2RpZ2l0X25hdF9uYXRpdmVcbmZ1bmN0aW9uIHNldF9kaWdpdF9uYXRfbmF0aXZlKG5hdCwgb2ZzLCBkaWdpdCkge1xuICBuYXQuZGF0YVtvZnNdID0gZGlnaXQ7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBudGhfZGlnaXRfbmF0X25hdGl2ZVxuZnVuY3Rpb24gbnRoX2RpZ2l0X25hdF9uYXRpdmUobmF0LCBvZnMpIHtcbiAgcmV0dXJuIG5hdC5kYXRhW29mc107XG59XG5cbi8vUHJvdmlkZXM6IG51bV9kaWdpdHNfbmF0XG5mdW5jdGlvbiBudW1fZGlnaXRzX25hdChuYXQsIG9mcywgbGVuKSB7XG4gIGZvcih2YXIgaSA9IGxlbiAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYobmF0LmRhdGFbb2ZzK2ldICE9IDApIHJldHVybiBpKzE7XG4gIH1cbiAgcmV0dXJuIDE7IC8vIDAgY291bnRzIGFzIDEgZGlnaXRcbn1cblxuLy9Qcm92aWRlczogbnVtX2xlYWRpbmdfemVyb19iaXRzX2luX2RpZ2l0XG5mdW5jdGlvbiBudW1fbGVhZGluZ196ZXJvX2JpdHNfaW5fZGlnaXQobmF0LCBvZnMpIHtcbiAgdmFyIGEgPSBuYXQuZGF0YVtvZnNdO1xuICB2YXIgYiA9IDA7XG4gIGlmKGEgJiAweEZGRkYwMDAwKSB7IGIgKz0xNjsgYSA+Pj49MTY7IH1cbiAgaWYoYSAmIDB4RkYwMCkgICAgIHsgYiArPSA4OyBhID4+Pj0gODsgfVxuICBpZihhICYgMHhGMCkgICAgICAgeyBiICs9IDQ7IGEgPj4+PSA0OyB9XG4gIGlmKGEgJiAxMikgICAgICAgICB7IGIgKz0gMjsgYSA+Pj49IDI7IH1cbiAgaWYoYSAmIDIpICAgICAgICAgIHsgYiArPSAxOyBhID4+Pj0gMTsgfVxuICBpZihhICYgMSkgICAgICAgICAgeyBiICs9IDE7IH1cbiAgcmV0dXJuIDMyIC0gYjtcbn1cblxuLy9Qcm92aWRlczogaXNfZGlnaXRfaW50XG5mdW5jdGlvbiBpc19kaWdpdF9pbnQobmF0LCBvZnMpIHtcbiAgaWYgKG5hdC5kYXRhW29mc10gPj0gMCkgcmV0dXJuIDFcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGlzX2RpZ2l0X3plcm9cbmZ1bmN0aW9uIGlzX2RpZ2l0X3plcm8obmF0LCBvZnMpIHtcbiAgaWYobmF0LmRhdGFbb2ZzXSA9PSAwKSByZXR1cm4gMTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGlzX2RpZ2l0X29kZFxuZnVuY3Rpb24gaXNfZGlnaXRfb2RkKG5hdCwgb2ZzKSB7XG4gIGlmKG5hdC5kYXRhW29mc10gJiAxKSByZXR1cm4gMTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGluY3JfbmF0XG5mdW5jdGlvbiBpbmNyX25hdChuYXQsIG9mcywgbGVuLCBjYXJyeV9pbikge1xuICB2YXIgY2FycnkgPSBjYXJyeV9pbjtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIHggPSAobmF0LmRhdGFbb2ZzK2ldID4+PiAwKSArIGNhcnJ5O1xuICAgIG5hdC5kYXRhW29mcytpXSA9ICh4IHwgMCk7XG4gICAgaWYoeCA9PSAoeCA+Pj4gMCkpIHtcbiAgICAgIGNhcnJ5ID0gMDtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYXJyeSA9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBjYXJyeTtcbn1cblxuLy8gbGVuMSA+PSBsZW4yXG4vL1Byb3ZpZGVzOiBhZGRfbmF0XG4vL1JlcXVpcmVzOiBpbmNyX25hdFxuZnVuY3Rpb24gYWRkX25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yLCBjYXJyeV9pbikge1xuICB2YXIgY2FycnkgPSBjYXJyeV9pbjtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjI7IGkrKykge1xuICAgIHZhciB4ID0gKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSArIChuYXQyLmRhdGFbb2ZzMitpXSA+Pj4gMCkgKyBjYXJyeTtcbiAgICBuYXQxLmRhdGFbb2ZzMStpXSA9IHhcbiAgICBpZih4ID09ICh4ID4+PiAwKSkge1xuICAgICAgY2FycnkgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYXJyeSA9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBpbmNyX25hdChuYXQxLCBvZnMxK2xlbjIsIGxlbjEtbGVuMiwgY2FycnkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjb21wbGVtZW50X25hdFxuZnVuY3Rpb24gY29tcGxlbWVudF9uYXQobmF0LCBvZnMsIGxlbikge1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBuYXQuZGF0YVtvZnMraV0gPSAoLTEgPj4+IDApIC0gKG5hdC5kYXRhW29mcytpXSA+Pj4gMCk7XG4gIH1cbn1cblxuLy8gb2NhbWwgZmxpcHMgY2FycnlfaW5cbi8vUHJvdmlkZXM6IGRlY3JfbmF0XG5mdW5jdGlvbiBkZWNyX25hdChuYXQsIG9mcywgbGVuLCBjYXJyeV9pbikge1xuICB2YXIgYm9ycm93ID0gKGNhcnJ5X2luID09IDEpID8gMCA6IDE7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciB4ID0gKG5hdC5kYXRhW29mcytpXSA+Pj4wKSAtIGJvcnJvdztcbiAgICBuYXQuZGF0YVtvZnMraV0gPSB4O1xuICAgIGlmICh4ID49IDApIHtcbiAgICAgIGJvcnJvdyA9IDA7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2Uge1xuICAgICAgYm9ycm93ID0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIChib3Jyb3cgPT0gMSkgPyAwIDogMTtcbn1cblxuLy8gb2NhbWwgZmxpcHMgY2FycnlfaW5cbi8vIGxlbjEgPj0gbGVuMlxuLy9Qcm92aWRlczogc3ViX25hdFxuLy9SZXF1aXJlczogZGVjcl9uYXRcbmZ1bmN0aW9uIHN1Yl9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbGVuMiwgY2FycnlfaW4pIHtcbiAgdmFyIGJvcnJvdyA9IChjYXJyeV9pbiA9PSAxKSA/IDAgOiAxO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuMjsgaSsrKSB7XG4gICAgdmFyIHggPSAobmF0MS5kYXRhW29mczEraV0gPj4+IDApIC0gKG5hdDIuZGF0YVtvZnMyK2ldID4+PiAwKSAtIGJvcnJvdztcbiAgICBuYXQxLmRhdGFbb2ZzMStpXSA9IHg7XG4gICAgaWYgKHggPj0gMCkge1xuICAgICAgYm9ycm93ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgYm9ycm93ID0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlY3JfbmF0KG5hdDEsIG9mczErbGVuMiwgbGVuMS1sZW4yLCAoYm9ycm93PT0xKT8wOjEpO1xufVxuXG4vLyBuYXQxICs9IG5hdDIgKiBuYXQzW29mczNdXG4vLyBsZW4xID49IGxlbjJcbi8vUHJvdmlkZXM6IG11bHRfZGlnaXRfbmF0XG4vL1JlcXVpcmVzOiBhZGRfbmF0LCBuYXRfb2ZfYXJyYXlcbmZ1bmN0aW9uIG11bHRfZGlnaXRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIsIG5hdDMsIG9mczMpIHtcbiAgdmFyIGNhcnJ5ID0gMDtcbiAgdmFyIGEgPSAobmF0My5kYXRhW29mczNdID4+PiAwKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjI7IGkrKykge1xuICAgIHZhciB4MSA9IChuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMCkgKyAobmF0Mi5kYXRhW29mczIraV0gPj4+IDApICogKGEgJiAweDAwMDBGRkZGKSArIGNhcnJ5O1xuICAgIHZhciB4MiA9IChuYXQyLmRhdGFbb2ZzMitpXSA+Pj4gMCkgKiAoYSA+Pj4gMTYpO1xuICAgIGNhcnJ5ID0gTWF0aC5mbG9vcih4Mi82NTUzNik7XG4gICAgdmFyIHgzID0geDEgKyAoeDIgJSA2NTUzNikgKiA2NTUzNjtcbiAgICBuYXQxLmRhdGFbb2ZzMStpXSA9IHgzO1xuICAgIGNhcnJ5ICs9IE1hdGguZmxvb3IoeDMvNDI5NDk2NzI5Nik7XG4gIH1cblxuICBpZihsZW4yIDwgbGVuMSAmJiBjYXJyeSkge1xuICAgIHJldHVybiBhZGRfbmF0KG5hdDEsIG9mczErbGVuMiwgbGVuMS1sZW4yLCBuYXRfb2ZfYXJyYXkoW2NhcnJ5XSksIDAsIDEsIDApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjYXJyeTtcbiAgfVxufVxuXG4vLyBuYXQxICs9IG5hdDIgKiBuYXQzXG4vLyBsZW4xID49IGxlbjIgKyBsZW4zLlxuLy9Qcm92aWRlczogbXVsdF9uYXRcbi8vUmVxdWlyZXM6IG11bHRfZGlnaXRfbmF0XG5mdW5jdGlvbiBtdWx0X25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yLCBuYXQzLCBvZnMzLCBsZW4zKSB7XG4gIHZhciBjYXJyeSA9IDA7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW4zOyBpKyspIHtcbiAgICBjYXJyeSArPSBtdWx0X2RpZ2l0X25hdChuYXQxLCBvZnMxK2ksIGxlbjEtaSwgbmF0Miwgb2ZzMiwgbGVuMiwgbmF0Mywgb2ZzMytpKTtcbiAgfVxuICByZXR1cm4gY2Fycnk7XG59XG5cbi8vIG5hdDEgPSAyICogbmF0MSArIG5hdDIgKiBuYXQyXG4vLyBsZW4xID49IDIgKiBsZW4yXG4vL1Byb3ZpZGVzOiBzcXVhcmVfbmF0XG4vL1JlcXVpcmVzOiBtdWx0X25hdCwgYWRkX25hdFxuZnVuY3Rpb24gc3F1YXJlX25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yKSB7XG4gIHZhciBjYXJyeSA9IDA7XG4gIGNhcnJ5ICs9IGFkZF9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0MSwgb2ZzMSwgbGVuMSwgMCk7XG4gIGNhcnJ5ICs9IG11bHRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIsIG5hdDIsIG9mczIsIGxlbjIpO1xuICByZXR1cm4gY2Fycnk7XG59XG5cblxuLy8gMCA8PSBzaGlmdCA8IDMyXG4vL1Byb3ZpZGVzOiBzaGlmdF9sZWZ0X25hdFxuZnVuY3Rpb24gc2hpZnRfbGVmdF9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbmJpdHMpIHtcbiAgaWYobmJpdHMgPT0gMCkge1xuICAgIG5hdDIuZGF0YVtvZnMyXSA9IDA7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgdmFyIHdyYXAgPSAwO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuMTsgaSsrKSB7XG4gICAgdmFyIGEgPSAobmF0MS5kYXRhW29mczEraV0gPj4+IDApO1xuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0gKGEgPDwgbmJpdHMpIHwgd3JhcDtcbiAgICB3cmFwID0gYSA+Pj4gKDMyIC0gbmJpdHMpO1xuICB9XG4gIG5hdDIuZGF0YVtvZnMyXSA9IHdyYXA7XG4gIHJldHVybiAwO1xufVxuXG4vLyBBc3N1bWluZyBjID4gYSwgcmV0dXJucyBbcXVvdGllbnQsIHJlbWFpbmRlcl0gb2YgKGE8PDMyICsgYikvY1xuLy9Qcm92aWRlczogZGl2X2hlbHBlclxuZnVuY3Rpb24gZGl2X2hlbHBlcihhLCBiLCBjKSB7XG4gIHZhciB4ID0gYSAqIDY1NTM2ICsgKGI+Pj4xNik7XG4gIHZhciB5ID0gTWF0aC5mbG9vcih4L2MpICogNjU1MzY7XG4gIHZhciB6ID0gKHggJSBjKSAqIDY1NTM2O1xuICB2YXIgdyA9IHogKyAoYiAmIDB4MDAwMEZGRkYpO1xuICByZXR1cm4gW3kgKyBNYXRoLmZsb29yKHcvYyksIHcgJSBjXTtcbn1cblxuLy8gbmF0MVtvZnMxK2xlbl0gPCBuYXQyW29mczJdXG4vL1Byb3ZpZGVzOiBkaXZfZGlnaXRfbmF0XG4vL1JlcXVpcmVzOiBkaXZfaGVscGVyXG5mdW5jdGlvbiBkaXZfZGlnaXRfbmF0KG5hdHEsIG9mc3EsIG5hdHIsIG9mc3IsIG5hdDEsIG9mczEsIGxlbiwgbmF0Miwgb2ZzMikge1xuICB2YXIgcmVtID0gKG5hdDEuZGF0YVtvZnMxK2xlbi0xXSA+Pj4wKTtcbiAgLy8gbmF0cVtvZnNxK2xlbi0xXSBpcyBndWFyYW50ZWVkIHRvIGJlIHplcm8gKGR1ZSB0byB0aGUgTVNEIHJlcXVpcmVtZW50KSxcbiAgLy8gYW5kIHNob3VsZCBub3QgYmUgd3JpdHRlbiB0by5cbiAgZm9yKHZhciBpID0gbGVuLTI7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIHggPSBkaXZfaGVscGVyKHJlbSwgKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSwgKG5hdDIuZGF0YVtvZnMyXSA+Pj4gMCkpO1xuICAgIG5hdHEuZGF0YVtvZnNxK2ldID0geFswXTtcbiAgICByZW0gPSB4WzFdO1xuICB9XG4gIG5hdHIuZGF0YVtvZnNyXSA9IHJlbTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vIG5hdDFbbmF0MjpdIDo9IG5hdDEgLyBuYXQyXG4vLyBuYXQxWzpuYXQyXSA6PSBuYXQxICUgbmF0MlxuLy8gbGVuMSA+IGxlbjIsIG5hdDJbb2ZzMitsZW4yLTFdID4gbmF0MVtvZnMxK2xlbjEtMV1cbi8vUHJvdmlkZXM6IGRpdl9uYXRcbi8vUmVxdWlyZXM6IGRpdl9kaWdpdF9uYXQsIGRpdl9oZWxwZXIsIG51bV9sZWFkaW5nX3plcm9fYml0c19pbl9kaWdpdCwgc2hpZnRfbGVmdF9uYXQsIHNoaWZ0X3JpZ2h0X25hdCwgY3JlYXRlX25hdCwgc2V0X3RvX3plcm9fbmF0LCBtdWx0X2RpZ2l0X25hdCwgc3ViX25hdCwgY29tcGFyZV9uYXQsIG5hdF9vZl9hcnJheVxuZnVuY3Rpb24gZGl2X25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yKSB7XG4gIGlmKGxlbjIgPT0gMSkge1xuICAgIGRpdl9kaWdpdF9uYXQobmF0MSwgb2ZzMSsxLCBuYXQxLCBvZnMxLCBuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyKTtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciBzID0gbnVtX2xlYWRpbmdfemVyb19iaXRzX2luX2RpZ2l0KG5hdDIsIG9mczIrbGVuMi0xKTtcbiAgc2hpZnRfbGVmdF9uYXQobmF0Miwgb2ZzMiwgbGVuMiwgbmF0X29mX2FycmF5KFswXSksIDAsIHMpO1xuICBzaGlmdF9sZWZ0X25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXRfb2ZfYXJyYXkoWzBdKSwgMCwgcyk7XG5cbiAgdmFyIGQgPSAobmF0Mi5kYXRhW29mczIrbGVuMi0xXSA+Pj4gMCkgKyAxO1xuICB2YXIgYSA9IGNyZWF0ZV9uYXQobGVuMisxKTtcbiAgZm9yICh2YXIgaSA9IGxlbjEgLSAxOyBpID49IGxlbjI7IGktLSkge1xuICAgIC8vIERlY2VudCBsb3dlciBib3VuZCBvbiBxdW9cbiAgICB2YXIgcXVvID0gZCA9PSA0Mjk0OTY3Mjk2ID8gKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSA6IGRpdl9oZWxwZXIoKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSwgKG5hdDEuZGF0YVtvZnMxK2ktMV0gPj4+MCksIGQpWzBdO1xuICAgIHNldF90b196ZXJvX25hdChhLCAwLCBsZW4yKzEpO1xuICAgIG11bHRfZGlnaXRfbmF0KGEsIDAsIGxlbjIrMSwgbmF0Miwgb2ZzMiwgbGVuMiwgbmF0X29mX2FycmF5KFtxdW9dKSwgMCk7XG4gICAgc3ViX25hdChuYXQxLCBvZnMxK2ktbGVuMiwgbGVuMisxLCBhLCAwLCBsZW4yKzEsIDEpO1xuXG4gICAgd2hpbGUgKG5hdDEuZGF0YVtvZnMxK2ldICE9IDAgfHwgY29tcGFyZV9uYXQobmF0MSwgb2ZzMStpLWxlbjIsIGxlbjIsIG5hdDIsIG9mczIsIGxlbjIpID49IDApIHtcbiAgICAgIHF1byA9IHF1byArIDE7XG4gICAgICBzdWJfbmF0KG5hdDEsIG9mczEraS1sZW4yLCBsZW4yKzEsIG5hdDIsIG9mczIsIGxlbjIsIDEpO1xuICAgIH1cblxuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0gcXVvO1xuICB9XG5cbiAgc2hpZnRfcmlnaHRfbmF0KG5hdDEsIG9mczEsIGxlbjIsIG5hdF9vZl9hcnJheShbMF0pLCAwLCBzKTsgLy8gc2hpZnQgcmVtYWluZGVyXG4gIHNoaWZ0X3JpZ2h0X25hdChuYXQyLCBvZnMyLCBsZW4yLCBuYXRfb2ZfYXJyYXkoWzBdKSwgMCwgcyk7IC8vIHJlc3RvcmVcbiAgcmV0dXJuIDA7XG59XG5cblxuLy8gMCA8PSBzaGlmdCA8IDMyXG4vL1Byb3ZpZGVzOiBzaGlmdF9yaWdodF9uYXRcbmZ1bmN0aW9uIHNoaWZ0X3JpZ2h0X25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBuYml0cykge1xuICBpZihuYml0cyA9PSAwKSB7XG4gICAgbmF0Mi5kYXRhW29mczJdID0gMDtcbiAgICByZXR1cm4gMDtcbiAgfVxuICB2YXIgd3JhcCA9IDA7XG4gIGZvcih2YXIgaSA9IGxlbjEtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgYSA9IG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwO1xuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0gKGEgPj4+IG5iaXRzKSB8IHdyYXA7XG4gICAgd3JhcCA9IGEgPDwgKDMyIC0gbmJpdHMpO1xuICB9XG4gIG5hdDIuZGF0YVtvZnMyXSA9IHdyYXA7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjb21wYXJlX2RpZ2l0c19uYXRcbmZ1bmN0aW9uIGNvbXBhcmVfZGlnaXRzX25hdChuYXQxLCBvZnMxLCBuYXQyLCBvZnMyKSB7XG4gIGlmKG5hdDEuZGF0YVtvZnMxXSA+IG5hdDIuZGF0YVtvZnMyXSkgcmV0dXJuIDE7XG4gIGlmKG5hdDEuZGF0YVtvZnMxXSA8IG5hdDIuZGF0YVtvZnMyXSkgcmV0dXJuIC0xO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY29tcGFyZV9uYXRcbi8vUmVxdWlyZXM6IG51bV9kaWdpdHNfbmF0XG5mdW5jdGlvbiBjb21wYXJlX25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yKSB7XG4gIHZhciBhID0gbnVtX2RpZ2l0c19uYXQobmF0MSwgb2ZzMSwgbGVuMSk7XG4gIHZhciBiID0gbnVtX2RpZ2l0c19uYXQobmF0Miwgb2ZzMiwgbGVuMik7XG4gIGlmKGEgPiBiKSByZXR1cm4gMTtcbiAgaWYoYSA8IGIpIHJldHVybiAtMTtcbiAgZm9yKHZhciBpID0gbGVuMSAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKChuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMCkgPiAobmF0Mi5kYXRhW29mczIraV0gPj4+IDApKSByZXR1cm4gMTtcbiAgICBpZiAoKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSA8IChuYXQyLmRhdGFbb2ZzMitpXSA+Pj4gMCkpIHJldHVybiAtMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY29tcGFyZV9uYXRfcmVhbFxuLy9SZXF1aXJlczogY29tcGFyZV9uYXRcbmZ1bmN0aW9uIGNvbXBhcmVfbmF0X3JlYWwobmF0MSxuYXQyKXtcbiAgcmV0dXJuIGNvbXBhcmVfbmF0KG5hdDEsMCxuYXQxLmRhdGEubGVuZ3RoLG5hdDIsMCxuYXQyLmRhdGEubGVuZ3RoKTtcbn1cblxuLy9Qcm92aWRlczogbGFuZF9kaWdpdF9uYXRcbmZ1bmN0aW9uIGxhbmRfZGlnaXRfbmF0KG5hdDEsIG9mczEsIG5hdDIsIG9mczIpIHtcbiAgbmF0MS5kYXRhW29mczFdICY9IG5hdDIuZGF0YVtvZnMyXTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGxvcl9kaWdpdF9uYXRcbmZ1bmN0aW9uIGxvcl9kaWdpdF9uYXQobmF0MSwgb2ZzMSwgbmF0Miwgb2ZzMikge1xuICBuYXQxLmRhdGFbb2ZzMV0gfD0gbmF0Mi5kYXRhW29mczJdO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbHhvcl9kaWdpdF9uYXRcbmZ1bmN0aW9uIGx4b3JfZGlnaXRfbmF0KG5hdDEsIG9mczEsIG5hdDIsIG9mczIpIHtcbiAgbmF0MS5kYXRhW29mczFdIF49IG5hdDIuZGF0YVtvZnMyXTtcbiAgcmV0dXJuIDA7XG59XG5cblxuLy9Qcm92aWRlczogc2VyaWFsaXplX25hdFxuZnVuY3Rpb24gc2VyaWFsaXplX25hdCh3cml0ZXIsIG5hdCwgc3ope1xuICB2YXIgbGVuID0gbmF0LmRhdGEubGVuZ3RoO1xuICB3cml0ZXIud3JpdGUoMzIsIGxlbik7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKyl7XG4gICAgd3JpdGVyLndyaXRlKDMyLCBuYXQuZGF0YVtpXSk7XG4gIH1cbiAgc3pbMF0gPSBsZW4gKiA0O1xuICBzelsxXSA9IGxlbiAqIDg7XG59XG5cbi8vUHJvdmlkZXM6IGRlc2VyaWFsaXplX25hdFxuLy9SZXF1aXJlczogTWxOYXRcbmZ1bmN0aW9uIGRlc2VyaWFsaXplX25hdChyZWFkZXIsIHN6KXtcbiAgdmFyIGxlbiA9IHJlYWRlci5yZWFkMzJzKCk7XG4gIHZhciBuYXQgPSBuZXcgTWxOYXQobGVuKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKXtcbiAgICBuYXQuZGF0YVtpXSA9IHJlYWRlci5yZWFkMzJzKCk7XG4gIH1cbiAgc3pbMF0gPSBsZW4gKiA0O1xuICByZXR1cm4gbmF0O1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IEh1Z28gSGV1emFyZFxuXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zdGF0ZVxudmFyIGNhbWxfZ3Jfc3RhdGU7XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlXG4vL1JlcXVpcmVzOiBjYW1sX25hbWVkX3ZhbHVlLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX2dyX3N0YXRlX2dldCgpIHtcbiAgaWYoY2FtbF9ncl9zdGF0ZSkge1xuICAgIHJldHVybiBjYW1sX2dyX3N0YXRlO1xuICB9XG4gIHRocm93IFswLGNhbWxfbmFtZWRfdmFsdWUoXCJHcmFwaGljcy5HcmFwaGljX2ZhaWx1cmVcIiksIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJOb3QgaW5pdGlhbGl6ZWRcIildXG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3N0YXRlX3NldFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZSxjYW1sX2dyX3N0YXRlX2luaXRcbmZ1bmN0aW9uIGNhbWxfZ3Jfc3RhdGVfc2V0KGN0eCkge1xuICBjYW1sX2dyX3N0YXRlPWN0eDtcbiAgY2FtbF9ncl9zdGF0ZV9pbml0KClcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfb3Blbl9ncmFwaFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9jcmVhdGVcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9ncl9vcGVuX2dyYXBoKGluZm8pe1xuICB2YXIgaW5mbyA9IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKGluZm8pO1xuICBmdW5jdGlvbiBnZXQobmFtZSl7XG4gICAgdmFyIHJlcyA9IGluZm8ubWF0Y2goXCIoXnwsKSAqXCIrbmFtZStcIiAqPSAqKFthLXpBLVowLTlfXSspICooLHwkKVwiKTtcbiAgICBpZihyZXMpIHJldHVybiByZXNbMl07XG4gIH1cbiAgdmFyIHNwZWNzID0gW107XG4gIGlmKCEoaW5mbz09XCJcIikpIHNwZWNzLnB1c2goaW5mbyk7XG4gIHZhciB0YXJnZXQgPSBnZXQoXCJ0YXJnZXRcIik7XG4gIGlmKCF0YXJnZXQpIHRhcmdldD1cIlwiO1xuICB2YXIgc3RhdHVzID0gZ2V0KFwic3RhdHVzXCIpO1xuICBpZighc3RhdHVzKSBzcGVjcy5wdXNoKFwic3RhdHVzPTFcIilcblxuICB2YXIgdyA9IGdldChcIndpZHRoXCIpO1xuICB3ID0gdz9wYXJzZUludCh3KToyMDA7XG4gIHNwZWNzLnB1c2goXCJ3aWR0aD1cIit3KTtcblxuICB2YXIgaCA9IGdldChcImhlaWdodFwiKTtcbiAgaCA9IGg/cGFyc2VJbnQoaCk6MjAwO1xuICBzcGVjcy5wdXNoKFwiaGVpZ2h0PVwiK2gpO1xuXG4gIHZhciB3aW4gPSBnbG9iYWxUaGlzLm9wZW4oXCJhYm91dDpibGFua1wiLHRhcmdldCxzcGVjcy5qb2luKFwiLFwiKSk7XG4gIGlmKCF3aW4pIHtjYW1sX2ZhaWx3aXRoKFwiR3JhcGhpY3Mub3Blbl9ncmFwaDogY2Fubm90IG9wZW4gdGhlIHdpbmRvd1wiKX1cbiAgdmFyIGRvYyA9IHdpbi5kb2N1bWVudDtcbiAgdmFyIGNhbnZhcyA9IGRvYy5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICBjYW52YXMud2lkdGggPSB3O1xuICBjYW52YXMuaGVpZ2h0ID0gaDtcbiAgdmFyIGN0eCA9IGNhbWxfZ3Jfc3RhdGVfY3JlYXRlKGNhbnZhcyx3LGgpO1xuICBjdHguc2V0X3RpdGxlID0gZnVuY3Rpb24gKHRpdGxlKSB7XG4gICAgZG9jLnRpdGxlID0gdGl0bGU7XG4gIH07XG4gIGNhbWxfZ3Jfc3RhdGVfc2V0KGN0eCk7XG4gIHZhciBib2R5ID0gZG9jLmJvZHk7XG4gIGJvZHkuc3R5bGUubWFyZ2luID0gXCIwcHhcIjtcbiAgYm9keS5hcHBlbmRDaGlsZChjYW52YXMpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zdGF0ZV9pbml0XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3NldF9jb2xvcixjYW1sX2dyX21vdmV0byxjYW1sX2dyX3Jlc2l6ZV93aW5kb3dcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc2V0X2xpbmVfd2lkdGgsY2FtbF9ncl9zZXRfdGV4dF9zaXplLGNhbWxfZ3Jfc2V0X2ZvbnRcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc2V0X3dpbmRvd190aXRsZVxuZnVuY3Rpb24gY2FtbF9ncl9zdGF0ZV9pbml0KCl7XG4gIGNhbWxfZ3JfbW92ZXRvKGNhbWxfZ3Jfc3RhdGUueCxjYW1sX2dyX3N0YXRlLnkpO1xuICBjYW1sX2dyX3Jlc2l6ZV93aW5kb3coY2FtbF9ncl9zdGF0ZS53aWR0aCxjYW1sX2dyX3N0YXRlLmhlaWdodCk7XG4gIGNhbWxfZ3Jfc2V0X2xpbmVfd2lkdGgoY2FtbF9ncl9zdGF0ZS5saW5lX3dpZHRoKTtcbiAgY2FtbF9ncl9zZXRfdGV4dF9zaXplKGNhbWxfZ3Jfc3RhdGUudGV4dF9zaXplKTtcbiAgY2FtbF9ncl9zZXRfZm9udChjYW1sX2dyX3N0YXRlLmZvbnQpO1xuICBjYW1sX2dyX3NldF9jb2xvcihjYW1sX2dyX3N0YXRlLmNvbG9yKTtcbiAgY2FtbF9ncl9zZXRfd2luZG93X3RpdGxlKGNhbWxfZ3Jfc3RhdGUudGl0bGUpO1xuICAvL2NhbWxfZ3JfcmVzaXplX3dpbmRvdyBtaWdodCByZXNldCBzb21lIGNhbnZhcycgcHJvcGVydGllc1xuICBjYW1sX2dyX3N0YXRlLmNvbnRleHQudGV4dEJhc2VsaW5lID0gJ2JvdHRvbSc7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc3RhdGVfY3JlYXRlXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX2dyX3N0YXRlX2NyZWF0ZShjYW52YXMsdyxoKXtcbiAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICByZXR1cm4ge1xuICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgY2FudmFzIDogY2FudmFzLFxuICAgIHggOiAwLFxuICAgIHkgOiAwLFxuICAgIHdpZHRoIDogdyxcbiAgICBoZWlnaHQgOiBoLFxuICAgIGxpbmVfd2lkdGggOiAxLFxuICAgIGZvbnQgOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwiZml4ZWRcIiksXG4gICAgdGV4dF9zaXplIDogMjYsXG4gICAgY29sb3IgOiAweDAwMDAwMCxcbiAgICB0aXRsZSA6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJcIilcbiAgfTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9kb2Nfb2Zfc3RhdGVcbmZ1bmN0aW9uIGNhbWxfZ3JfZG9jX29mX3N0YXRlKHN0YXRlKSB7XG4gIGlmKHN0YXRlLmNhbnZhcy5vd25lckRvY3VtZW50KVxuICAgIHJldHVybiBzdGF0ZS5jYW52YXMub3duZXJEb2N1bWVudDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9jbG9zZV9ncmFwaFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfY2xvc2VfZ3JhcGgoKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmNhbnZhcy53aWR0aCA9IDA7XG4gIHMuY2FudmFzLmhlaWdodCA9IDA7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NldF93aW5kb3dfdGl0bGVcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9ncl9zZXRfd2luZG93X3RpdGxlKG5hbWUpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMudGl0bGUgPSBuYW1lO1xuICB2YXIganNuYW1lID0gY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcobmFtZSk7XG4gIGlmKHMuc2V0X3RpdGxlKSBzLnNldF90aXRsZShqc25hbWUpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9yZXNpemVfd2luZG93XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9yZXNpemVfd2luZG93KHcsaCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKVxuICBzLndpZHRoID0gdztcbiAgcy5oZWlnaHQgPSBoO1xuICBzLmNhbnZhcy53aWR0aCA9IHc7XG4gIHMuY2FudmFzLmhlaWdodCA9IGg7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2NsZWFyX2dyYXBoXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9jbGVhcl9ncmFwaCgpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY2FudmFzLndpZHRoID0gcy53aWR0aDtcbiAgcy5jYW52YXMuaGVpZ2h0ID0gcy5oZWlnaHQ7XG4gIC8vICBzLmNvbnRleHQuc3Ryb2tlUmVjdCAoMC4sIDAuLCBzLndpZHRoLCBzLmhlaWdodCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NpemVfeFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2l6ZV94KCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcmV0dXJuIHMud2lkdGg7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NpemVfeVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2l6ZV95KCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcmV0dXJuIHMuaGVpZ2h0O1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2V0X2NvbG9yXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9zZXRfY29sb3IoY29sb3Ipe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIGZ1bmN0aW9uIGNvbnZlcnQobnVtYmVyKSB7XG4gICAgdmFyIHN0ciA9ICcnICsgbnVtYmVyLnRvU3RyaW5nKDE2KTtcbiAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IDIpIHN0ciA9ICcwJyArIHN0cjtcbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIHZhclxuICByID0gKGNvbG9yID4+IDE2KSAmIDB4ZmYsXG4gIGcgPSAoY29sb3IgPj4gOCkgICYgMHhmZixcbiAgYiA9IChjb2xvciA+PiAwKSAgJiAweGZmO1xuICBzLmNvbG9yPWNvbG9yO1xuICB2YXIgY19zdHIgPSAnIycgKyBjb252ZXJ0KHIpICsgY29udmVydChnKSArIGNvbnZlcnQoYik7XG4gIHMuY29udGV4dC5maWxsU3R5bGUgPSAgIGNfc3RyO1xuICBzLmNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjX3N0cjtcbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3Bsb3Rcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX3Bsb3QoeCx5KXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICB2YXIgaW09cy5jb250ZXh0LmNyZWF0ZUltYWdlRGF0YSgxLDEpO1xuICB2YXIgZCA9IGltLmRhdGE7XG4gIHZhciBjb2xvciA9IHMuY29sb3I7XG4gIGRbMF0gPSAoY29sb3IgPj4gMTYpICYgMHhmZjsgLy9yXG4gIGRbMV0gPSAoY29sb3IgPj4gOCkgICYgMHhmZiwgLy9nXG4gIGRbMl0gPSAoY29sb3IgPj4gMCkgICYgMHhmZjsgLy9iXG4gIGRbM10gPSAweEZGOyAvL2FcbiAgcy54PXg7XG4gIHMueT15O1xuICBzLmNvbnRleHQucHV0SW1hZ2VEYXRhKGltLHgscy5oZWlnaHQgLSB5KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfcG9pbnRfY29sb3Jcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX3BvaW50X2NvbG9yKHgseSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgdmFyIGltPXMuY29udGV4dC5nZXRJbWFnZURhdGEoeCxzLmhlaWdodCAtIHksMSwxKTtcbiAgdmFyIGQgPSBpbS5kYXRhO1xuICByZXR1cm4gKGRbMF0gPDwgMTYpICsgKGRbMV0gPDwgOCkgKyBkWzJdO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9tb3ZldG9cbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX21vdmV0byh4LHkpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMueD14O1xuICBzLnk9eTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfY3VycmVudF94XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9jdXJyZW50X3goKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICByZXR1cm4gcy54XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2N1cnJlbnRfeVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfY3VycmVudF95KCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcmV0dXJuIHMueVxufVxuLy9Qcm92aWRlczogY2FtbF9ncl9saW5ldG9cbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2xpbmV0byh4LHkpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY29udGV4dC5iZWdpblBhdGgoKTtcbiAgcy5jb250ZXh0Lm1vdmVUbyhzLngscy5oZWlnaHQgLSBzLnkpO1xuICBzLmNvbnRleHQubGluZVRvKHgscy5oZWlnaHQgLSB5KTtcbiAgcy5jb250ZXh0LnN0cm9rZSgpO1xuICBzLng9eDtcbiAgcy55PXk7XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9kcmF3X3JlY3Rcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2RyYXdfcmVjdCh4LHksdyxoKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmNvbnRleHQuc3Ryb2tlUmVjdCh4LHMuaGVpZ2h0IC0geSx3LC1oKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfYXJjX2F1eFxuZnVuY3Rpb24gY2FtbF9ncl9hcmNfYXV4KGN0eCxjeCxjeSxyeSxyeCxhMSxhMil7XG4gIHdoaWxlKGExPmEyKSBhMis9MzYwO1xuICBhMSAvPSAxODA7XG4gIGEyIC89IDE4MDtcbiAgdmFyIHJvdCA9IDAseFBvcyx5UG9zLHhQb3NfcHJldix5UG9zX3ByZXY7XG4gIHZhciBzcGFjZSA9IDI7XG4gIHZhciBudW0gPSAoKChhMiAtIGExKSAqIE1hdGguUEkgKiAoKHJ4K3J5KS8yKSkgLyBzcGFjZSkgfCAwO1xuICB2YXIgZGVsdGEgPSAoYTIgLSBhMSkgKiBNYXRoLlBJIC8gbnVtO1xuICB2YXIgaSA9IGExICogTWF0aC5QSTtcbiAgZm9yICh2YXIgaj0wO2o8PW51bTtqKyspe1xuICAgIHhQb3MgPSBjeCAtIChyeCAqIE1hdGguc2luKGkpKSAqIE1hdGguc2luKHJvdCAqIE1hdGguUEkpICsgKHJ5ICogTWF0aC5jb3MoaSkpICogTWF0aC5jb3Mocm90ICogTWF0aC5QSSk7XG4gICAgeFBvcyA9IHhQb3MudG9GaXhlZCgyKTtcbiAgICB5UG9zID0gY3kgKyAocnkgKiBNYXRoLmNvcyhpKSkgKiBNYXRoLnNpbihyb3QgKiBNYXRoLlBJKSArIChyeCAqIE1hdGguc2luKGkpKSAqIE1hdGguY29zKHJvdCAqIE1hdGguUEkpO1xuICAgIHlQb3MgPSB5UG9zLnRvRml4ZWQoMik7XG4gICAgaWYgKGo9PTApIHtcbiAgICAgIGN0eC5tb3ZlVG8oeFBvcywgeVBvcyk7XG4gICAgfSBlbHNlIGlmICh4UG9zX3ByZXYhPXhQb3MgfHwgeVBvc19wcmV2IT15UG9zKXtcbiAgICAgIGN0eC5saW5lVG8oeFBvcywgeVBvcyk7XG4gICAgfVxuICAgIHhQb3NfcHJldj14UG9zO1xuICAgIHlQb3NfcHJldj15UG9zO1xuICAgIGktPSBkZWx0YTsvL2Njd1xuICB9XG4gIHJldHVybiAwO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZHJhd19hcmNcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0LCBjYW1sX2dyX2FyY19hdXhcbmZ1bmN0aW9uIGNhbWxfZ3JfZHJhd19hcmMoeCx5LHJ4LHJ5LGExLGEyKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmNvbnRleHQuYmVnaW5QYXRoKCk7XG4gIGNhbWxfZ3JfYXJjX2F1eChzLmNvbnRleHQseCxzLmhlaWdodCAtIHkscngscnksYTEsYTIpO1xuICBzLmNvbnRleHQuc3Ryb2tlKCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NldF9saW5lX3dpZHRoXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9zZXRfbGluZV93aWR0aCh3KXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmxpbmVfd2lkdGggPSB3O1xuICBzLmNvbnRleHQubGluZVdpZHRoID0gd1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9maWxsX3JlY3Rcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2ZpbGxfcmVjdCh4LHksdyxoKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmNvbnRleHQuZmlsbFJlY3QoeCxzLmhlaWdodCAtIHksdywtaCk7XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9maWxsX3BvbHlcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2ZpbGxfcG9seShhcil7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5jb250ZXh0LmJlZ2luUGF0aCgpO1xuICBzLmNvbnRleHQubW92ZVRvKGFyWzFdWzFdLHMuaGVpZ2h0IC0gYXJbMV1bMl0pO1xuICBmb3IodmFyIGkgPSAyOyBpIDwgYXIubGVuZ3RoOyBpKyspXG4gICAgcy5jb250ZXh0LmxpbmVUbyhhcltpXVsxXSxzLmhlaWdodCAtIGFyW2ldWzJdKTtcbiAgcy5jb250ZXh0LmxpbmVUbyhhclsxXVsxXSxzLmhlaWdodCAtIGFyWzFdWzJdKTtcbiAgcy5jb250ZXh0LmZpbGwoKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZmlsbF9hcmNcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0LCBjYW1sX2dyX2FyY19hdXhcbmZ1bmN0aW9uIGNhbWxfZ3JfZmlsbF9hcmMoeCx5LHJ4LHJ5LGExLGEyKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmNvbnRleHQuYmVnaW5QYXRoKCk7XG4gIGNhbWxfZ3JfYXJjX2F1eChzLmNvbnRleHQseCxzLmhlaWdodCAtIHkscngscnksYTEsYTIpO1xuICBzLmNvbnRleHQuZmlsbCgpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9kcmF3X3N0clxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfZHJhd19zdHIoc3RyKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICB2YXIgbSA9IHMuY29udGV4dC5tZWFzdXJlVGV4dChzdHIpO1xuICB2YXIgZHggPSBtLndpZHRoO1xuICBzLmNvbnRleHQuZmlsbFRleHQoc3RyLHMueCxzLmhlaWdodCAtIHMueSk7XG4gIHMueCArPSBkeCB8IDA7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2RyYXdfY2hhclxuLy9SZXF1aXJlczogY2FtbF9ncl9kcmF3X3N0clxuZnVuY3Rpb24gY2FtbF9ncl9kcmF3X2NoYXIoYyl7XG4gIGNhbWxfZ3JfZHJhd19zdHIoU3RyaW5nLmZyb21DaGFyQ29kZShjKSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2RyYXdfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2dyX2RyYXdfc3RyXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9ncl9kcmF3X3N0cmluZyhzdHIpe1xuICBjYW1sX2dyX2RyYXdfc3RyKGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHN0cikpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zZXRfZm9udFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2dyX3NldF9mb250KGYpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuZm9udCA9IGY7XG4gIHMuY29udGV4dC5mb250ID0gcy50ZXh0X3NpemUgKyBcInB4IFwiICsgY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocy5mb250KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2V0X3RleHRfc2l6ZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2dyX3NldF90ZXh0X3NpemUoc2l6ZSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy50ZXh0X3NpemUgPSBzaXplO1xuICBzLmNvbnRleHQuZm9udCA9IHMudGV4dF9zaXplICsgXCJweCBcIiArIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMuZm9udCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3RleHRfc2l6ZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2dyX3RleHRfc2l6ZSh0eHQpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHZhciB3ID0gcy5jb250ZXh0Lm1lYXN1cmVUZXh0KGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHR4dCkpLndpZHRoO1xuICByZXR1cm4gWzAsdyxzLnRleHRfc2l6ZV07XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9ncl9tYWtlX2ltYWdlXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9tYWtlX2ltYWdlKGFycil7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgdmFyIGggPSBhcnIubGVuZ3RoIC0gMSA7XG4gIHZhciB3ID0gYXJyWzFdLmxlbmd0aCAtIDE7XG4gIHZhciBpbSA9IHMuY29udGV4dC5jcmVhdGVJbWFnZURhdGEodyxoKTtcbiAgZm9yKHZhciBpPTA7aTxoO2krKyl7XG4gICAgZm9yKHZhciBqPTA7ajx3O2orKyl7XG4gICAgICB2YXIgYyA9IGFycltpKzFdW2orMV07XG4gICAgICB2YXIgbyA9IGkqKHcqNCkgKyAoaiAqIDQpO1xuICAgICAgaWYoYyA9PSAtMSkge1xuICAgICAgICBpbS5kYXRhW28gKyAwXSA9IDA7XG4gICAgICAgIGltLmRhdGFbbyArIDFdID0gMDtcbiAgICAgICAgaW0uZGF0YVtvICsgMl0gPSAwO1xuICAgICAgICBpbS5kYXRhW28gKyAzXSA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbS5kYXRhW28gKyAwXSA9IGMgPj4gMTYgJiAweGZmO1xuICAgICAgICBpbS5kYXRhW28gKyAxXSA9IGMgPj4gIDggJiAweGZmO1xuICAgICAgICBpbS5kYXRhW28gKyAyXSA9IGMgPj4gIDAgJiAwWGZmO1xuICAgICAgICBpbS5kYXRhW28gKyAzXSA9IDB4ZmY7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBpbVxufVxuLy9Qcm92aWRlczogY2FtbF9ncl9kdW1wX2ltYWdlXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9kdW1wX2ltYWdlKGltKXtcbiAgdmFyIGRhdGEgPSBbMF1cbiAgZm9yKHZhciBpPTA7IGk8aW0uaGVpZ2h0O2krKyl7XG4gICAgZGF0YVtpKzFdID0gWzBdXG4gICAgZm9yKHZhciBqPTA7IGo8aW0ud2lkdGg7aisrKXtcbiAgICAgIHZhciBvID0gaSooaW0ud2lkdGgqNCkgKyAoaiAqIDQpLFxuICAgICAgICAgIHIgPSBpbS5kYXRhW28rMF0sXG4gICAgICAgICAgZyA9IGltLmRhdGFbbysxXSxcbiAgICAgICAgICBiID0gaW0uZGF0YVtvKzJdO1xuICAgICAgZGF0YVtpKzFdW2orMV0gPSAociA8PCAxNikgKyAoZyA8PCA4KSArIGJcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZHJhd19pbWFnZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfZHJhd19pbWFnZShpbSx4LHkpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIGlmKCFpbS5pbWFnZSkge1xuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIGNhbnZhcy53aWR0aCA9IHMud2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IHMuaGVpZ2h0O1xuICAgIGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIikucHV0SW1hZ2VEYXRhKGltLDAsMCk7XG4gICAgdmFyIGltYWdlID0gbmV3IGdsb2JhbFRoaXMuSW1hZ2UoKTtcbiAgICBpbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzLmNvbnRleHQuZHJhd0ltYWdlKGltYWdlLHgscy5oZWlnaHQgLSBpbS5oZWlnaHQgLSB5KTtcbiAgICAgIGltLmltYWdlID0gaW1hZ2U7XG4gICAgfVxuICAgIGltYWdlLnNyYyA9IGNhbnZhcy50b0RhdGFVUkwoXCJpbWFnZS9wbmdcIik7XG4gIH0gZWxzZSB7XG4gICAgcy5jb250ZXh0LmRyYXdJbWFnZShpbS5pbWFnZSx4LHMuaGVpZ2h0IC0gaW0uaGVpZ2h0IC0geSk7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2NyZWF0ZV9pbWFnZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfY3JlYXRlX2ltYWdlKHgseSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcmV0dXJuIHMuY29udGV4dC5jcmVhdGVJbWFnZURhdGEoeCx5KTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfYmxpdF9pbWFnZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfYmxpdF9pbWFnZShpbSx4LHkpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHZhciBpbTIgPSBzLmNvbnRleHQuZ2V0SW1hZ2VEYXRhKHgscy5oZWlnaHQgLSBpbS5oZWlnaHQgLSB5LGltLndpZHRoLGltLmhlaWdodCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaW0yLmRhdGEubGVuZ3RoOyBpKz00KXtcbiAgICBpbS5kYXRhW2ldID0gaW0yLmRhdGFbaV07XG4gICAgaW0uZGF0YVtpKzFdID0gaW0yLmRhdGFbaSsxXTtcbiAgICBpbS5kYXRhW2krMl0gPSBpbTIuZGF0YVtpKzJdO1xuICAgIGltLmRhdGFbaSszXSA9IGltMi5kYXRhW2krM107XG4gIH1cbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NpZ2lvX2hhbmRsZXJcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2lnaW9faGFuZGxlcigpe3JldHVybiAwfVxuLy9Qcm92aWRlczogY2FtbF9ncl9zaWdpb19zaWduYWxcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2lnaW9fc2lnbmFsKCl7cmV0dXJuIDB9XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3dhaXRfZXZlbnRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfZ3Jfd2FpdF9ldmVudChfZXZsKXtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfZ3Jfd2FpdF9ldmVudCBub3QgSW1wbGVtZW50ZWQ6IHVzZSBHcmFwaGljc19qcyBpbnN0ZWFkXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3N5bmNocm9uaXplXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2dyX3N5bmNocm9uaXplICgpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfZ3Jfc3luY2hyb25pemUgbm90IEltcGxlbWVudGVkXCIpO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9yZW1lbWJlcl9tb2RlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2dyX3JlbWVtYmVyX21vZGUgKCkge1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9ncl9yZW1lbWJlcl9tb2RlIG5vdCBJbXBsZW1lbnRlZFwiKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZGlzcGxheV9tb2RlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2dyX2Rpc3BsYXlfbW9kZSgpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfZ3JfZGlzcGxheV9tb2RlIG5vdCBJbXBsZW1lbnRlZFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl93aW5kb3dfaWRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfZ3Jfd2luZG93X2lkKGEpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfZ3Jfd2luZG93X2lkIG5vdCBJbXBsZW1lbnRlZFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9vcGVuX3N1YndpbmRvd1xuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9ncl9vcGVuX3N1YndpbmRvdyhhLGIsYyxkKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2dyX29wZW5fc3Vid2luZG93IG5vdCBJbXBsZW1lbnRlZFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9jbG9zZV9zdWJ3aW5kb3dcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfZ3JfY2xvc2Vfc3Vid2luZG93KGEpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfZ3JfY2xvc2Vfc3Vid2luZG93IG5vdCBJbXBsZW1lbnRlZFwiKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX21hcnNoYWxfY29uc3RhbnRzXG52YXIgY2FtbF9tYXJzaGFsX2NvbnN0YW50cyA9IHtcbiAgUFJFRklYX1NNQUxMX0JMT0NLOiAgICAgICAgIDB4ODAsXG4gIFBSRUZJWF9TTUFMTF9JTlQ6ICAgICAgICAgICAweDQwLFxuICBQUkVGSVhfU01BTExfU1RSSU5HOiAgICAgICAgMHgyMCxcbiAgQ09ERV9JTlQ4OiAgICAgICAgICAgICAgICAgIDB4MDAsXG4gIENPREVfSU5UMTY6ICAgICAgICAgICAgICAgICAweDAxLFxuICBDT0RFX0lOVDMyOiAgICAgICAgICAgICAgICAgMHgwMixcbiAgQ09ERV9JTlQ2NDogICAgICAgICAgICAgICAgIDB4MDMsXG4gIENPREVfU0hBUkVEODogICAgICAgICAgICAgICAweDA0LFxuICBDT0RFX1NIQVJFRDE2OiAgICAgICAgICAgICAgMHgwNSxcbiAgQ09ERV9TSEFSRUQzMjogICAgICAgICAgICAgIDB4MDYsXG4gIENPREVfQkxPQ0szMjogICAgICAgICAgICAgICAweDA4LFxuICBDT0RFX0JMT0NLNjQ6ICAgICAgICAgICAgICAgMHgxMyxcbiAgQ09ERV9TVFJJTkc4OiAgICAgICAgICAgICAgIDB4MDksXG4gIENPREVfU1RSSU5HMzI6ICAgICAgICAgICAgICAweDBBLFxuICBDT0RFX0RPVUJMRV9CSUc6ICAgICAgICAgICAgMHgwQixcbiAgQ09ERV9ET1VCTEVfTElUVExFOiAgICAgICAgIDB4MEMsXG4gIENPREVfRE9VQkxFX0FSUkFZOF9CSUc6ICAgICAweDBELFxuICBDT0RFX0RPVUJMRV9BUlJBWThfTElUVExFOiAgMHgwRSxcbiAgQ09ERV9ET1VCTEVfQVJSQVkzMl9CSUc6ICAgIDB4MEYsXG4gIENPREVfRE9VQkxFX0FSUkFZMzJfTElUVExFOiAweDA3LFxuICBDT0RFX0NPREVQT0lOVEVSOiAgICAgICAgICAgMHgxMCxcbiAgQ09ERV9JTkZJWFBPSU5URVI6ICAgICAgICAgIDB4MTEsXG4gIENPREVfQ1VTVE9NOiAgICAgICAgICAgICAgICAweDEyLFxuICBDT0RFX0NVU1RPTV9MRU46ICAgICAgICAgICAgMHgxOCxcbiAgQ09ERV9DVVNUT01fRklYRUQ6ICAgICAgICAgIDB4MTlcbn1cblxuXG4vL1Byb3ZpZGVzOiBNbFN0cmluZ1JlYWRlclxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlcywgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gTWxTdHJpbmdSZWFkZXIgKHMsIGkpIHsgdGhpcy5zID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhzKTsgdGhpcy5pID0gaTsgfVxuTWxTdHJpbmdSZWFkZXIucHJvdG90eXBlID0ge1xuICByZWFkOHU6ZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5zLmNoYXJDb2RlQXQodGhpcy5pKyspOyB9LFxuICByZWFkOHM6ZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5zLmNoYXJDb2RlQXQodGhpcy5pKyspIDw8IDI0ID4+IDI0OyB9LFxuICByZWFkMTZ1OmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgMjtcbiAgICByZXR1cm4gKHMuY2hhckNvZGVBdChpKSA8PCA4KSB8IHMuY2hhckNvZGVBdChpICsgMSlcbiAgfSxcbiAgcmVhZDE2czpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDI7XG4gICAgcmV0dXJuIChzLmNoYXJDb2RlQXQoaSkgPDwgMjQgPj4gMTYpIHwgcy5jaGFyQ29kZUF0KGkgKyAxKTtcbiAgfSxcbiAgcmVhZDMydTpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDQ7XG4gICAgcmV0dXJuICgocy5jaGFyQ29kZUF0KGkpIDw8IDI0KSB8IChzLmNoYXJDb2RlQXQoaSsxKSA8PCAxNikgfFxuICAgICAgICAgICAgKHMuY2hhckNvZGVBdChpKzIpIDw8IDgpIHwgcy5jaGFyQ29kZUF0KGkrMykpID4+PiAwO1xuICB9LFxuICByZWFkMzJzOmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgNDtcbiAgICByZXR1cm4gKHMuY2hhckNvZGVBdChpKSA8PCAyNCkgfCAocy5jaGFyQ29kZUF0KGkrMSkgPDwgMTYpIHxcbiAgICAgIChzLmNoYXJDb2RlQXQoaSsyKSA8PCA4KSB8IHMuY2hhckNvZGVBdChpKzMpO1xuICB9LFxuICByZWFkc3RyOmZ1bmN0aW9uIChsZW4pIHtcbiAgICB2YXIgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgbGVuO1xuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHRoaXMucy5zdWJzdHJpbmcoaSwgaSArIGxlbikpO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IEJpZ1N0cmluZ1JlYWRlclxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfYXJyYXksIGNhbWxfYmFfZ2V0XzFcbmZ1bmN0aW9uIEJpZ1N0cmluZ1JlYWRlciAoYnMsIGkpIHsgdGhpcy5zID0gYnM7IHRoaXMuaSA9IGk7IH1cbkJpZ1N0cmluZ1JlYWRlci5wcm90b3R5cGUgPSB7XG4gIHJlYWQ4dTpmdW5jdGlvbiAoKSB7IHJldHVybiBjYW1sX2JhX2dldF8xKHRoaXMucyx0aGlzLmkrKyk7IH0sXG4gIHJlYWQ4czpmdW5jdGlvbiAoKSB7IHJldHVybiBjYW1sX2JhX2dldF8xKHRoaXMucyx0aGlzLmkrKykgPDwgMjQgPj4gMjQ7IH0sXG4gIHJlYWQxNnU6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyAyO1xuICAgIHJldHVybiAoY2FtbF9iYV9nZXRfMShzLGkpIDw8IDgpIHwgY2FtbF9iYV9nZXRfMShzLGkgKyAxKVxuICB9LFxuICByZWFkMTZzOmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgMjtcbiAgICByZXR1cm4gKGNhbWxfYmFfZ2V0XzEocyxpKSA8PCAyNCA+PiAxNikgfCBjYW1sX2JhX2dldF8xKHMsaSArIDEpO1xuICB9LFxuICByZWFkMzJ1OmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgNDtcbiAgICByZXR1cm4gKChjYW1sX2JhX2dldF8xKHMsaSkgICA8PCAyNCkgfCAoY2FtbF9iYV9nZXRfMShzLGkrMSkgPDwgMTYpIHxcbiAgICAgICAgICAgIChjYW1sX2JhX2dldF8xKHMsaSsyKSA8PCA4KSAgfCBjYW1sX2JhX2dldF8xKHMsaSszKSAgICAgICAgICkgPj4+IDA7XG4gIH0sXG4gIHJlYWQzMnM6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyA0O1xuICAgIHJldHVybiAoY2FtbF9iYV9nZXRfMShzLGkpICAgPDwgMjQpIHwgKGNhbWxfYmFfZ2V0XzEocyxpKzEpIDw8IDE2KSB8XG4gICAgICAoY2FtbF9iYV9nZXRfMShzLGkrMikgPDwgOCkgIHwgY2FtbF9iYV9nZXRfMShzLGkrMyk7XG4gIH0sXG4gIHJlYWRzdHI6ZnVuY3Rpb24gKGxlbikge1xuICAgIHZhciBpID0gdGhpcy5pO1xuICAgIHZhciBhcnIgPSBuZXcgQXJyYXkobGVuKVxuICAgIGZvcih2YXIgaiA9IDA7IGogPCBsZW47IGorKyl7XG4gICAgICBhcnJbal0gPSBjYW1sX2JhX2dldF8xKHRoaXMucywgaStqKTtcbiAgICB9XG4gICAgdGhpcy5pID0gaSArIGxlbjtcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfYXJyYXkoYXJyKTtcbiAgfVxufVxuXG5cblxuLy9Qcm92aWRlczogY2FtbF9mbG9hdF9vZl9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzLCBjYW1sX2ludDY0X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2Zsb2F0X29mX2J5dGVzIChhKSB7XG4gIHJldHVybiBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMgKGNhbWxfaW50NjRfb2ZfYnl0ZXMgKGEpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3N0cmluZyBtdXRhYmxlXG4vL1JlcXVpcmVzOiBNbFN0cmluZ1JlYWRlciwgY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlclxuZnVuY3Rpb24gY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3N0cmluZyhzLG9mcykge1xuICB2YXIgcmVhZGVyID0gbmV3IE1sU3RyaW5nUmVhZGVyIChzLCB0eXBlb2Ygb2ZzPT1cIm51bWJlclwiP29mczpvZnNbMF0pO1xuICByZXR1cm4gY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlcihyZWFkZXIsIG9mcylcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnB1dF92YWx1ZV9mcm9tX2J5dGVzIG11dGFibGVcbi8vUmVxdWlyZXM6IE1sU3RyaW5nUmVhZGVyLCBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyLCBjYW1sX3N0cmluZ19vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9pbnB1dF92YWx1ZV9mcm9tX2J5dGVzKHMsb2ZzKSB7XG4gIHZhciByZWFkZXIgPSBuZXcgTWxTdHJpbmdSZWFkZXIgKGNhbWxfc3RyaW5nX29mX2J5dGVzKHMpLCB0eXBlb2Ygb2ZzPT1cIm51bWJlclwiP29mczpvZnNbMF0pO1xuICByZXR1cm4gY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlcihyZWFkZXIsIG9mcylcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF91bm1hcnNoYWxcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfaW50NjRfdW5tYXJzaGFsKHJlYWRlciwgc2l6ZSl7XG4gIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICBzaXplWzBdID0gODtcbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfYnl0ZXMgKHQpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X21hcnNoYWxcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfaW50NjRfbWFyc2hhbCh3cml0ZXIsIHYsIHNpemVzKSB7XG4gIHZhciBiID0gY2FtbF9pbnQ2NF90b19ieXRlcyAodik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSB3cml0ZXIud3JpdGUgKDgsIGJbaV0pO1xuICBzaXplc1swXSA9IDg7IHNpemVzWzFdID0gODtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQzMl91bm1hcnNoYWxcbmZ1bmN0aW9uIGNhbWxfaW50MzJfdW5tYXJzaGFsKHJlYWRlciwgc2l6ZSl7XG4gIHNpemVbMF0gPSA0O1xuICByZXR1cm4gcmVhZGVyLnJlYWQzMnMgKCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbmF0aXZlaW50X3VubWFyc2hhbFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9uYXRpdmVpbnRfdW5tYXJzaGFsKHJlYWRlciwgc2l6ZSl7XG4gIHN3aXRjaCAocmVhZGVyLnJlYWQ4dSAoKSkge1xuICBjYXNlIDE6XG4gICAgc2l6ZVswXSA9IDQ7XG4gICAgcmV0dXJuIHJlYWRlci5yZWFkMzJzICgpO1xuICBjYXNlIDI6XG4gICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBuYXRpdmUgaW50ZWdlciB2YWx1ZSB0b28gbGFyZ2VcIik7XG4gIGRlZmF1bHQ6IGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogaWxsLWZvcm1lZCBuYXRpdmUgaW50ZWdlclwiKTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2N1c3RvbV9vcHNcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdW5tYXJzaGFsLCBjYW1sX2ludDY0X21hcnNoYWwsIGNhbWxfaW50NjRfY29tcGFyZSwgY2FtbF9pbnQ2NF9oYXNoXG4vL1JlcXVpcmVzOiBjYW1sX2ludDMyX3VubWFyc2hhbCwgY2FtbF9uYXRpdmVpbnRfdW5tYXJzaGFsXG4vL1JlcXVpcmVzOiBjYW1sX2JhX3NlcmlhbGl6ZSwgY2FtbF9iYV9kZXNlcmlhbGl6ZSwgY2FtbF9iYV9jb21wYXJlLCBjYW1sX2JhX2hhc2hcbnZhciBjYW1sX2N1c3RvbV9vcHMgPVxuICAgIHtcIl9qXCI6IHtcbiAgICAgIGRlc2VyaWFsaXplIDogY2FtbF9pbnQ2NF91bm1hcnNoYWwsXG4gICAgICBzZXJpYWxpemUgIDogY2FtbF9pbnQ2NF9tYXJzaGFsLFxuICAgICAgZml4ZWRfbGVuZ3RoIDogOCxcbiAgICAgIGNvbXBhcmUgOiBjYW1sX2ludDY0X2NvbXBhcmUsXG4gICAgICBoYXNoIDogY2FtbF9pbnQ2NF9oYXNoXG4gICAgfSxcbiAgICAgXCJfaVwiOiB7XG4gICAgICAgZGVzZXJpYWxpemUgOiBjYW1sX2ludDMyX3VubWFyc2hhbCxcbiAgICAgICBmaXhlZF9sZW5ndGggOiA0LFxuICAgICB9LFxuICAgICBcIl9uXCI6IHtcbiAgICAgICBkZXNlcmlhbGl6ZSA6IGNhbWxfbmF0aXZlaW50X3VubWFyc2hhbCxcbiAgICAgICBmaXhlZF9sZW5ndGggOiA0LFxuICAgICB9LFxuICAgICBcIl9iaWdhcnJheVwiOntcbiAgICAgICBkZXNlcmlhbGl6ZSA6IChmdW5jdGlvbiAocmVhZGVyLCBzeikge3JldHVybiBjYW1sX2JhX2Rlc2VyaWFsaXplIChyZWFkZXIsc3osXCJfYmlnYXJyYXlcIil9KSxcbiAgICAgICBzZXJpYWxpemUgOiBjYW1sX2JhX3NlcmlhbGl6ZSxcbiAgICAgICBjb21wYXJlIDogY2FtbF9iYV9jb21wYXJlLFxuICAgICAgIGhhc2g6IGNhbWxfYmFfaGFzaCxcbiAgICAgfSxcbiAgICAgXCJfYmlnYXJyMDJcIjp7XG4gICAgICAgZGVzZXJpYWxpemUgOiAoZnVuY3Rpb24gKHJlYWRlciwgc3opIHtyZXR1cm4gY2FtbF9iYV9kZXNlcmlhbGl6ZSAocmVhZGVyLHN6LFwiX2JpZ2FycjAyXCIpfSksXG4gICAgICAgc2VyaWFsaXplIDogY2FtbF9iYV9zZXJpYWxpemUsXG4gICAgICAgY29tcGFyZSA6IGNhbWxfYmFfY29tcGFyZSxcbiAgICAgICBoYXNoOiBjYW1sX2JhX2hhc2gsXG4gICAgIH1cbiAgICB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXIgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy9SZXF1aXJlczogY2FtbF9mbG9hdF9vZl9ieXRlcywgY2FtbF9jdXN0b21fb3BzXG5mdW5jdGlvbiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyKHJlYWRlciwgb2ZzKSB7XG4gIHZhciBfbWFnaWMgPSByZWFkZXIucmVhZDMydSAoKVxuICB2YXIgX2Jsb2NrX2xlbiA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICB2YXIgbnVtX29iamVjdHMgPSByZWFkZXIucmVhZDMydSAoKTtcbiAgdmFyIF9zaXplXzMyID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gIHZhciBfc2l6ZV82NCA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICB2YXIgc3RhY2sgPSBbXTtcbiAgdmFyIGludGVybl9vYmpfdGFibGUgPSAobnVtX29iamVjdHMgPiAwKT9bXTpudWxsO1xuICB2YXIgb2JqX2NvdW50ZXIgPSAwO1xuICBmdW5jdGlvbiBpbnRlcm5fcmVjICgpIHtcbiAgICB2YXIgY29kZSA9IHJlYWRlci5yZWFkOHUgKCk7XG4gICAgaWYgKGNvZGUgPj0gMHg0MCAvKmNzdC5QUkVGSVhfU01BTExfSU5UKi8pIHtcbiAgICAgIGlmIChjb2RlID49IDB4ODAgLypjc3QuUFJFRklYX1NNQUxMX0JMT0NLKi8pIHtcbiAgICAgICAgdmFyIHRhZyA9IGNvZGUgJiAweEY7XG4gICAgICAgIHZhciBzaXplID0gKGNvZGUgPj4gNCkgJiAweDc7XG4gICAgICAgIHZhciB2ID0gW3RhZ107XG4gICAgICAgIGlmIChzaXplID09IDApIHJldHVybiB2O1xuICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgIHN0YWNrLnB1c2godiwgc2l6ZSk7XG4gICAgICAgIHJldHVybiB2O1xuICAgICAgfSBlbHNlXG4gICAgICAgIHJldHVybiAoY29kZSAmIDB4M0YpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY29kZSA+PSAweDIwLypjc3QuUFJFRklYX1NNQUxMX1NUUklORyAqLykge1xuICAgICAgICB2YXIgbGVuID0gY29kZSAmIDB4MUY7XG4gICAgICAgIHZhciB2ID0gcmVhZGVyLnJlYWRzdHIgKGxlbik7XG4gICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2l0Y2goY29kZSkge1xuICAgICAgICBjYXNlIDB4MDA6IC8vY3N0LkNPREVfSU5UODpcbiAgICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWQ4cyAoKTtcbiAgICAgICAgY2FzZSAweDAxOiAvL2NzdC5DT0RFX0lOVDE2OlxuICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZDE2cyAoKTtcbiAgICAgICAgY2FzZSAweDAyOiAvL2NzdC5DT0RFX0lOVDMyOlxuICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZDMycyAoKTtcbiAgICAgICAgY2FzZSAweDAzOiAvL2NzdC5DT0RFX0lOVDY0OlxuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogaW50ZWdlciB0b28gbGFyZ2VcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgwNDogLy9jc3QuQ09ERV9TSEFSRUQ4OlxuICAgICAgICAgIHZhciBvZmZzZXQgPSByZWFkZXIucmVhZDh1ICgpO1xuICAgICAgICAgIHJldHVybiBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyIC0gb2Zmc2V0XTtcbiAgICAgICAgY2FzZSAweDA1OiAvL2NzdC5DT0RFX1NIQVJFRDE2OlxuICAgICAgICAgIHZhciBvZmZzZXQgPSByZWFkZXIucmVhZDE2dSAoKTtcbiAgICAgICAgICByZXR1cm4gaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlciAtIG9mZnNldF07XG4gICAgICAgIGNhc2UgMHgwNjogLy9jc3QuQ09ERV9TSEFSRUQzMjpcbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gICAgICAgICAgcmV0dXJuIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIgLSBvZmZzZXRdO1xuICAgICAgICBjYXNlIDB4MDg6IC8vY3N0LkNPREVfQkxPQ0szMjpcbiAgICAgICAgICB2YXIgaGVhZGVyID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gICAgICAgICAgdmFyIHRhZyA9IGhlYWRlciAmIDB4RkY7XG4gICAgICAgICAgdmFyIHNpemUgPSBoZWFkZXIgPj4gMTA7XG4gICAgICAgICAgdmFyIHYgPSBbdGFnXTtcbiAgICAgICAgICBpZiAoc2l6ZSA9PSAwKSByZXR1cm4gdjtcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgc3RhY2sucHVzaCh2LCBzaXplKTtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDEzOiAvL2NzdC5DT0RFX0JMT0NLNjQ6XG4gICAgICAgICAgY2FtbF9mYWlsd2l0aCAoXCJpbnB1dF92YWx1ZTogZGF0YSBibG9jayB0b28gbGFyZ2VcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgwOTogLy9jc3QuQ09ERV9TVFJJTkc4OlxuICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgdmFyIHYgPSByZWFkZXIucmVhZHN0ciAobGVuKTtcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwQTogLy9jc3QuQ09ERV9TVFJJTkczMjpcbiAgICAgICAgICB2YXIgbGVuID0gcmVhZGVyLnJlYWQzMnUoKTtcbiAgICAgICAgICB2YXIgdiA9IHJlYWRlci5yZWFkc3RyIChsZW4pO1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDBDOiAvL2NzdC5DT0RFX0RPVUJMRV9MSVRUTEU6XG4gICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwO2kgPCA4O2krKykgdFs3IC0gaV0gPSByZWFkZXIucmVhZDh1ICgpO1xuICAgICAgICAgIHZhciB2ID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MEI6IC8vY3N0LkNPREVfRE9VQkxFX0JJRzpcbiAgICAgICAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7aSA8IDg7aSsrKSB0W2ldID0gcmVhZGVyLnJlYWQ4dSAoKTtcbiAgICAgICAgICB2YXIgdiA9IGNhbWxfZmxvYXRfb2ZfYnl0ZXMgKHQpO1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDBFOiAvL2NzdC5DT0RFX0RPVUJMRV9BUlJBWThfTElUVExFOlxuICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgdmFyIHYgPSBuZXcgQXJyYXkobGVuKzEpO1xuICAgICAgICAgIHZbMF0gPSAyNTQ7XG4gICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMTtpIDw9IGxlbjtpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFs3IC0gal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgICB2W2ldID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MEQ6IC8vY3N0LkNPREVfRE9VQkxFX0FSUkFZOF9CSUc6XG4gICAgICAgICAgdmFyIGxlbiA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICB2YXIgdiA9IG5ldyBBcnJheShsZW4rMSk7XG4gICAgICAgICAgdlswXSA9IDI1NDtcbiAgICAgICAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxO2kgPD0gbGVuO2krKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICAgICAgdiBbaV0gPSBjYW1sX2Zsb2F0X29mX2J5dGVzICh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwNzogLy9jc3QuQ09ERV9ET1VCTEVfQVJSQVkzMl9MSVRUTEU6XG4gICAgICAgICAgdmFyIGxlbiA9IHJlYWRlci5yZWFkMzJ1KCk7XG4gICAgICAgICAgdmFyIHYgPSBuZXcgQXJyYXkobGVuKzEpO1xuICAgICAgICAgIHZbMF0gPSAyNTQ7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICAgICAgICBmb3IgKHZhciBpID0gMTtpIDw9IGxlbjtpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFs3IC0gal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgICB2W2ldID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MEY6IC8vY3N0LkNPREVfRE9VQkxFX0FSUkFZMzJfQklHOlxuICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDMydSgpO1xuICAgICAgICAgIHZhciB2ID0gbmV3IEFycmF5KGxlbisxKTtcbiAgICAgICAgICB2WzBdID0gMjU0O1xuICAgICAgICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICAgICAgICBmb3IgKHZhciBpID0gMTtpIDw9IGxlbjtpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICAgIHYgW2ldID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MTA6IC8vY3N0LkNPREVfQ09ERVBPSU5URVI6XG4gICAgICAgIGNhc2UgMHgxMTogLy9jc3QuQ09ERV9JTkZJWFBPSU5URVI6XG4gICAgICAgICAgY2FtbF9mYWlsd2l0aCAoXCJpbnB1dF92YWx1ZTogY29kZSBwb2ludGVyXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4MTI6IC8vY3N0LkNPREVfQ1VTVE9NOlxuICAgICAgICBjYXNlIDB4MTg6IC8vY3N0LkNPREVfQ1VTVE9NX0xFTjpcbiAgICAgICAgY2FzZSAweDE5OiAvL2NzdC5DT0RFX0NVU1RPTV9GSVhFRDpcbiAgICAgICAgICB2YXIgYywgcyA9IFwiXCI7XG4gICAgICAgICAgd2hpbGUgKChjID0gcmVhZGVyLnJlYWQ4dSAoKSkgIT0gMCkgcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlIChjKTtcbiAgICAgICAgICB2YXIgb3BzID0gY2FtbF9jdXN0b21fb3BzW3NdO1xuICAgICAgICAgIHZhciBleHBlY3RlZF9zaXplO1xuICAgICAgICAgIGlmKCFvcHMpXG4gICAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IHVua25vd24gY3VzdG9tIGJsb2NrIGlkZW50aWZpZXJcIik7XG4gICAgICAgICAgc3dpdGNoKGNvZGUpe1xuICAgICAgICAgIGNhc2UgMHgxMjogLy8gY3N0LkNPREVfQ1VTVE9NIChkZXByZWNhdGVkKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAweDE5OiAvLyBjc3QuQ09ERV9DVVNUT01fRklYRURcbiAgICAgICAgICAgIGlmKCFvcHMuZml4ZWRfbGVuZ3RoKVxuICAgICAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IGV4cGVjdGVkIGEgZml4ZWQtc2l6ZSBjdXN0b20gYmxvY2tcIik7XG4gICAgICAgICAgICBleHBlY3RlZF9zaXplID0gb3BzLmZpeGVkX2xlbmd0aDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMHgxODogLy8gY3N0LkNPREVfQ1VTVE9NX0xFTlxuICAgICAgICAgICAgZXhwZWN0ZWRfc2l6ZSA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICAgICAgICAgICAgLy8gU2tpcCBzaXplNjRcbiAgICAgICAgICAgIHJlYWRlci5yZWFkMzJzKCk7IHJlYWRlci5yZWFkMzJzKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG9sZF9wb3MgPSByZWFkZXIuaTtcbiAgICAgICAgICB2YXIgc2l6ZSA9IFswXTtcbiAgICAgICAgICB2YXIgdiA9IG9wcy5kZXNlcmlhbGl6ZShyZWFkZXIsIHNpemUpO1xuICAgICAgICAgIGlmKGV4cGVjdGVkX3NpemUgIT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgIGlmKGV4cGVjdGVkX3NpemUgIT0gc2l6ZVswXSlcbiAgICAgICAgICAgICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBpbmNvcnJlY3QgbGVuZ3RoIG9mIHNlcmlhbGl6ZWQgY3VzdG9tIGJsb2NrXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY2FtbF9mYWlsd2l0aCAoXCJpbnB1dF92YWx1ZTogaWxsLWZvcm1lZCBtZXNzYWdlXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciByZXMgPSBpbnRlcm5fcmVjICgpO1xuICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgIHZhciBzaXplID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHYgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgZCA9IHYubGVuZ3RoO1xuICAgIGlmIChkIDwgc2l6ZSkgc3RhY2sucHVzaCh2LCBzaXplKTtcbiAgICB2W2RdID0gaW50ZXJuX3JlYyAoKTtcbiAgfVxuICBpZiAodHlwZW9mIG9mcyE9XCJudW1iZXJcIikgb2ZzWzBdID0gcmVhZGVyLmk7XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWFyc2hhbF9kYXRhX3NpemUgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgY2FtbF9ieXRlc191bnNhZmVfZ2V0XG5mdW5jdGlvbiBjYW1sX21hcnNoYWxfZGF0YV9zaXplIChzLCBvZnMpIHtcbiAgZnVuY3Rpb24gZ2V0MzIocyxpKSB7XG4gICAgcmV0dXJuIChjYW1sX2J5dGVzX3Vuc2FmZV9nZXQocywgaSkgPDwgMjQpIHxcbiAgICAgIChjYW1sX2J5dGVzX3Vuc2FmZV9nZXQocywgaSArIDEpIDw8IDE2KSB8XG4gICAgICAoY2FtbF9ieXRlc191bnNhZmVfZ2V0KHMsIGkgKyAyKSA8PCA4KSB8XG4gICAgICBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQocywgaSArIDMpO1xuICB9XG4gIGlmIChnZXQzMihzLCBvZnMpICE9ICgweDg0OTVBNkJFfDApKVxuICAgIGNhbWxfZmFpbHdpdGgoXCJNYXJzaGFsLmRhdGFfc2l6ZTogYmFkIG9iamVjdFwiKTtcbiAgcmV0dXJuIChnZXQzMihzLCBvZnMgKyA0KSk7XG59XG5cbi8vUHJvdmlkZXM6IE1sT2JqZWN0VGFibGVcbnZhciBNbE9iamVjdFRhYmxlO1xuaWYgKHR5cGVvZiBnbG9iYWxUaGlzLldlYWtNYXAgPT09ICd1bmRlZmluZWQnKSB7XG4gIE1sT2JqZWN0VGFibGUgPSBmdW5jdGlvbigpIHtcbiAgICAvKiBwb2x5ZmlsbCAodXNpbmcgbGluZWFyIHNlYXJjaCkgKi9cbiAgICBmdW5jdGlvbiBOYWl2ZUxvb2t1cChvYmpzKSB7IHRoaXMub2JqcyA9IG9ianM7IH1cbiAgICBOYWl2ZUxvb2t1cC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24odikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm9ianMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMub2Jqc1tpXSA9PT0gdikgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfTtcbiAgICBOYWl2ZUxvb2t1cC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAvLyBEbyBub3RoaW5nIGhlcmUuIFtNbE9iamVjdFRhYmxlLnN0b3JlXSB3aWxsIHB1c2ggdG8gW3RoaXMub2Jqc10gZGlyZWN0bHkuXG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbiBNbE9iamVjdFRhYmxlKCkge1xuICAgICAgdGhpcy5vYmpzID0gW107IHRoaXMubG9va3VwID0gbmV3IE5haXZlTG9va3VwKHRoaXMub2Jqcyk7XG4gICAgfTtcbiAgfSgpO1xufVxuZWxzZSB7XG4gIE1sT2JqZWN0VGFibGUgPSBmdW5jdGlvbiBNbE9iamVjdFRhYmxlKCkge1xuICAgIHRoaXMub2JqcyA9IFtdOyB0aGlzLmxvb2t1cCA9IG5ldyBnbG9iYWxUaGlzLldlYWtNYXAoKTtcbiAgfTtcbn1cblxuTWxPYmplY3RUYWJsZS5wcm90b3R5cGUuc3RvcmUgPSBmdW5jdGlvbih2KSB7XG4gIHRoaXMubG9va3VwLnNldCh2LCB0aGlzLm9ianMubGVuZ3RoKTtcbiAgdGhpcy5vYmpzLnB1c2godik7XG59XG5cbk1sT2JqZWN0VGFibGUucHJvdG90eXBlLnJlY2FsbCA9IGZ1bmN0aW9uKHYpIHtcbiAgdmFyIGkgPSB0aGlzLmxvb2t1cC5nZXQodik7XG4gIHJldHVybiAoaSA9PT0gdW5kZWZpbmVkKVxuICAgID8gdW5kZWZpbmVkIDogdGhpcy5vYmpzLmxlbmd0aCAtIGk7ICAgLyogaW5kZXggaXMgcmVsYXRpdmUgKi9cbn1cblxuLy9Qcm92aWRlczogY2FtbF9sZWdhY3lfY3VzdG9tX2NvZGVcbi8vVmVyc2lvbjogPj0gNC4wOFxudmFyIGNhbWxfbGVnYWN5X2N1c3RvbV9jb2RlID0gZmFsc2VcblxuLy9Qcm92aWRlczogY2FtbF9sZWdhY3lfY3VzdG9tX2NvZGVcbi8vVmVyc2lvbjogPCA0LjA4XG52YXIgY2FtbF9sZWdhY3lfY3VzdG9tX2NvZGUgPSB0cnVlXG5cbi8vUHJvdmlkZXM6IGNhbWxfb3V0cHV0X3ZhbFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19ieXRlcywgY2FtbF9mYWlsd2l0aFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0XG4vL1JlcXVpcmVzOiBjYW1sX2lzX21sX2J5dGVzLCBjYW1sX21sX2J5dGVzX2xlbmd0aCwgY2FtbF9ieXRlc191bnNhZmVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2lzX21sX3N0cmluZywgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX3N0cmluZ191bnNhZmVfZ2V0XG4vL1JlcXVpcmVzOiBNbE9iamVjdFRhYmxlLCBjYW1sX2xpc3RfdG9fanNfYXJyYXksIGNhbWxfbGVnYWN5X2N1c3RvbV9jb2RlLCBjYW1sX2N1c3RvbV9vcHNcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCxjYW1sX3N0cmluZ19vZl9qc2J5dGVzLCBjYW1sX2lzX2NvbnRpbnVhdGlvbl90YWdcbnZhciBjYW1sX291dHB1dF92YWwgPSBmdW5jdGlvbiAoKXtcbiAgZnVuY3Rpb24gV3JpdGVyICgpIHsgdGhpcy5jaHVuayA9IFtdOyB9XG4gIFdyaXRlci5wcm90b3R5cGUgPSB7XG4gICAgY2h1bmtfaWR4OjIwLCBibG9ja19sZW46MCwgb2JqX2NvdW50ZXI6MCwgc2l6ZV8zMjowLCBzaXplXzY0OjAsXG4gICAgd3JpdGU6ZnVuY3Rpb24gKHNpemUsIHZhbHVlKSB7XG4gICAgICBmb3IgKHZhciBpID0gc2l6ZSAtIDg7aSA+PSAwO2kgLT0gOClcbiAgICAgICAgdGhpcy5jaHVua1t0aGlzLmNodW5rX2lkeCsrXSA9ICh2YWx1ZSA+PiBpKSAmIDB4RkY7XG4gICAgfSxcbiAgICB3cml0ZV9hdDpmdW5jdGlvbiAocG9zLCBzaXplLCB2YWx1ZSkge1xuICAgICAgdmFyIHBvcyA9IHBvcztcbiAgICAgIGZvciAodmFyIGkgPSBzaXplIC0gODtpID49IDA7aSAtPSA4KVxuICAgICAgICB0aGlzLmNodW5rW3BvcysrXSA9ICh2YWx1ZSA+PiBpKSAmIDB4RkY7XG4gICAgfSxcbiAgICB3cml0ZV9jb2RlOmZ1bmN0aW9uIChzaXplLCBjb2RlLCB2YWx1ZSkge1xuICAgICAgdGhpcy5jaHVua1t0aGlzLmNodW5rX2lkeCsrXSA9IGNvZGU7XG4gICAgICBmb3IgKHZhciBpID0gc2l6ZSAtIDg7aSA+PSAwO2kgLT0gOClcbiAgICAgICAgdGhpcy5jaHVua1t0aGlzLmNodW5rX2lkeCsrXSA9ICh2YWx1ZSA+PiBpKSAmIDB4RkY7XG4gICAgfSxcbiAgICB3cml0ZV9zaGFyZWQ6ZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgaWYgKG9mZnNldCA8ICgxIDw8IDgpKSB0aGlzLndyaXRlX2NvZGUoOCwgMHgwNCAvKmNzdC5DT0RFX1NIQVJFRDgqLywgb2Zmc2V0KTtcbiAgICAgIGVsc2UgaWYgKG9mZnNldCA8ICgxIDw8IDE2KSkgdGhpcy53cml0ZV9jb2RlKDE2LCAweDA1IC8qY3N0LkNPREVfU0hBUkVEMTYqLywgb2Zmc2V0KTtcbiAgICAgIGVsc2UgdGhpcy53cml0ZV9jb2RlKDMyLCAweDA2IC8qY3N0LkNPREVfU0hBUkVEMzIqLywgb2Zmc2V0KTtcbiAgICB9LFxuICAgIHBvczpmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmNodW5rX2lkeCB9LFxuICAgIGZpbmFsaXplOmZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuYmxvY2tfbGVuID0gdGhpcy5jaHVua19pZHggLSAyMDtcbiAgICAgIHRoaXMuY2h1bmtfaWR4ID0gMDtcbiAgICAgIHRoaXMud3JpdGUgKDMyLCAweDg0OTVBNkJFKTtcbiAgICAgIHRoaXMud3JpdGUgKDMyLCB0aGlzLmJsb2NrX2xlbik7XG4gICAgICB0aGlzLndyaXRlICgzMiwgdGhpcy5vYmpfY291bnRlcik7XG4gICAgICB0aGlzLndyaXRlICgzMiwgdGhpcy5zaXplXzMyKTtcbiAgICAgIHRoaXMud3JpdGUgKDMyLCB0aGlzLnNpemVfNjQpO1xuICAgICAgcmV0dXJuIHRoaXMuY2h1bms7XG4gICAgfVxuICB9XG4gIHJldHVybiBmdW5jdGlvbiAodiwgZmxhZ3MpIHtcbiAgICBmbGFncyA9IGNhbWxfbGlzdF90b19qc19hcnJheShmbGFncyk7XG5cbiAgICB2YXIgbm9fc2hhcmluZyA9IChmbGFncy5pbmRleE9mKDAgLypNYXJzaGFsLk5vX3NoYXJpbmcqLykgIT09IC0xKSxcbiAgICAgICAgY2xvc3VyZXMgPSAgKGZsYWdzLmluZGV4T2YoMSAvKk1hcnNoYWwuQ2xvc3VyZXMqLykgIT09IC0xKTtcbiAgICAvKiBNYXJzaGFsLkNvbXBhdF8zMiBpcyByZWR1bmRhbnQgc2luY2UgaW50ZWdlcnMgYXJlIDMyLWJpdCBhbnl3YXkgKi9cblxuICAgIGlmIChjbG9zdXJlcylcbiAgICAgIGNvbnNvbGUud2FybihcImluIGNhbWxfb3V0cHV0X3ZhbDogZmxhZyBNYXJzaGFsLkNsb3N1cmVzIGlzIG5vdCBzdXBwb3J0ZWQuXCIpO1xuXG4gICAgdmFyIHdyaXRlciA9IG5ldyBXcml0ZXIgKCk7XG4gICAgdmFyIHN0YWNrID0gW107XG4gICAgdmFyIGludGVybl9vYmpfdGFibGUgPSBub19zaGFyaW5nID8gbnVsbCA6IG5ldyBNbE9iamVjdFRhYmxlKCk7XG5cbiAgICBmdW5jdGlvbiBtZW1vKHYpIHtcbiAgICAgIGlmIChub19zaGFyaW5nKSByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgZXhpc3Rpbmdfb2Zmc2V0ID0gaW50ZXJuX29ial90YWJsZS5yZWNhbGwodik7XG4gICAgICBpZiAoZXhpc3Rpbmdfb2Zmc2V0KSB7IHdyaXRlci53cml0ZV9zaGFyZWQoZXhpc3Rpbmdfb2Zmc2V0KTsgcmV0dXJuIHRydWU7IH1cbiAgICAgIGVsc2UgeyBpbnRlcm5fb2JqX3RhYmxlLnN0b3JlKHYpOyByZXR1cm4gZmFsc2U7IH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHRlcm5fcmVjICh2KSB7XG4gICAgICBpZiAodi5jYW1sX2N1c3RvbSkge1xuICAgICAgICBpZiAobWVtbyh2KSkgcmV0dXJuO1xuICAgICAgICB2YXIgbmFtZSA9IHYuY2FtbF9jdXN0b207XG4gICAgICAgIHZhciBvcHMgPSBjYW1sX2N1c3RvbV9vcHNbbmFtZV07XG4gICAgICAgIHZhciBzel8zMl82NCA9IFswLDBdO1xuICAgICAgICBpZighb3BzLnNlcmlhbGl6ZSlcbiAgICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJvdXRwdXRfdmFsdWU6IGFic3RyYWN0IHZhbHVlIChDdXN0b20pXCIpO1xuICAgICAgICBpZihjYW1sX2xlZ2FjeV9jdXN0b21fY29kZSkge1xuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgMHgxMiAvKmNzdC5DT0RFX0NVU1RPTSovKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIG5hbWUuY2hhckNvZGVBdChpKSk7XG4gICAgICAgICAgd3JpdGVyLndyaXRlKDgsIDApO1xuICAgICAgICAgIG9wcy5zZXJpYWxpemUod3JpdGVyLCB2LCBzel8zMl82NCk7XG4gICAgICAgIH0gZWxzZSBpZihvcHMuZml4ZWRfbGVuZ3RoID09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAweDE4IC8qY3N0LkNPREVfQ1VTVE9NX0xFTiovKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIG5hbWUuY2hhckNvZGVBdChpKSk7XG4gICAgICAgICAgd3JpdGVyLndyaXRlKDgsIDApO1xuICAgICAgICAgIHZhciBoZWFkZXJfcG9zID0gd3JpdGVyLnBvcyAoKTtcbiAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgd3JpdGVyLndyaXRlKDgsIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvcHMuc2VyaWFsaXplKHdyaXRlciwgdiwgc3pfMzJfNjQpO1xuICAgICAgICAgIHdyaXRlci53cml0ZV9hdChoZWFkZXJfcG9zLCAzMiwgc3pfMzJfNjRbMF0pO1xuICAgICAgICAgIHdyaXRlci53cml0ZV9hdChoZWFkZXJfcG9zICsgNCwgMzIsIDApOyAvLyB6ZXJvXG4gICAgICAgICAgd3JpdGVyLndyaXRlX2F0KGhlYWRlcl9wb3MgKyA4LCAzMiwgc3pfMzJfNjRbMV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgMHgxOSAvKmNzdC5DT0RFX0NVU1RPTV9GSVhFRCovKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIG5hbWUuY2hhckNvZGVBdChpKSk7XG4gICAgICAgICAgd3JpdGVyLndyaXRlKDgsIDApO1xuICAgICAgICAgIHZhciBvbGRfcG9zID0gd3JpdGVyLnBvcygpO1xuICAgICAgICAgIG9wcy5zZXJpYWxpemUod3JpdGVyLCB2LCBzel8zMl82NCk7XG4gICAgICAgICAgaWYgKG9wcy5maXhlZF9sZW5ndGggIT0gd3JpdGVyLnBvcygpIC0gb2xkX3BvcylcbiAgICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJvdXRwdXRfdmFsdWU6IGluY29ycmVjdCBmaXhlZCBzaXplcyBzcGVjaWZpZWQgYnkgXCIgKyBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB3cml0ZXIuc2l6ZV8zMiArPSAyICsgKChzel8zMl82NFswXSArIDMpID4+IDIpO1xuICAgICAgICB3cml0ZXIuc2l6ZV82NCArPSAyICsgKChzel8zMl82NFsxXSArIDcpID4+IDMpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodiBpbnN0YW5jZW9mIEFycmF5ICYmIHZbMF0gPT09ICh2WzBdfDApKSB7XG4gICAgICAgIGlmICh2WzBdID09IDI1MSkge1xuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJvdXRwdXRfdmFsdWU6IGFic3RyYWN0IHZhbHVlIChBYnN0cmFjdClcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbWxfaXNfY29udGludWF0aW9uX3RhZyh2WzBdKSlcbiAgICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJvdXRwdXRfdmFsdWU6IGNvbnRpbnVhdGlvbiB2YWx1ZVwiKTtcbiAgICAgICAgaWYgKHYubGVuZ3RoID4gMSAmJiBtZW1vKHYpKSByZXR1cm47XG4gICAgICAgIGlmICh2WzBdIDwgMTYgJiYgdi5sZW5ndGggLSAxIDwgOClcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4ODAgLypjc3QuUFJFRklYX1NNQUxMX0JMT0NLKi8gKyB2WzBdICsgKCh2Lmxlbmd0aCAtIDEpPDw0KSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSgzMiwgMHgwOCAvKmNzdC5DT0RFX0JMT0NLMzIqLywgKCh2Lmxlbmd0aC0xKSA8PCAxMCkgfCB2WzBdKTtcbiAgICAgICAgd3JpdGVyLnNpemVfMzIgKz0gdi5sZW5ndGg7XG4gICAgICAgIHdyaXRlci5zaXplXzY0ICs9IHYubGVuZ3RoO1xuICAgICAgICBpZiAodi5sZW5ndGggPiAxKSBzdGFjay5wdXNoICh2LCAxKTtcbiAgICAgIH0gZWxzZSBpZiAoY2FtbF9pc19tbF9ieXRlcyh2KSkge1xuICAgICAgICBpZighKGNhbWxfaXNfbWxfYnl0ZXMoY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcIlwiKSkpKSB7XG4gICAgICAgICAgY2FtbF9mYWlsd2l0aChcIm91dHB1dF92YWx1ZTogW0J5dGVzLnRdIGNhbm5vdCBzYWZlbHkgYmUgbWFyc2hhbGVkIHdpdGggWy0tZW5hYmxlIHVzZS1qcy1zdHJpbmddXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZW1vKHYpKSByZXR1cm47XG4gICAgICAgIHZhciBsZW4gPSBjYW1sX21sX2J5dGVzX2xlbmd0aCh2KTtcbiAgICAgICAgaWYgKGxlbiA8IDB4MjApXG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAweDIwIC8qY3N0LlBSRUZJWF9TTUFMTF9TVFJJTkcqLyArIGxlbik7XG4gICAgICAgIGVsc2UgaWYgKGxlbiA8IDB4MTAwKVxuICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlICg4LCAweDA5Lypjc3QuQ09ERV9TVFJJTkc4Ki8sIGxlbik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSAoMzIsIDB4MEEgLypjc3QuQ09ERV9TVFJJTkczMiovLCBsZW4pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDtpIDwgbGVuO2krKylcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIGNhbWxfYnl0ZXNfdW5zYWZlX2dldCh2LGkpKTtcbiAgICAgICAgd3JpdGVyLnNpemVfMzIgKz0gMSArICgoKGxlbiArIDQpIC8gNCl8MCk7XG4gICAgICAgIHdyaXRlci5zaXplXzY0ICs9IDEgKyAoKChsZW4gKyA4KSAvIDgpfDApO1xuICAgICAgfSBlbHNlIGlmIChjYW1sX2lzX21sX3N0cmluZyh2KSkge1xuICAgICAgICB2YXIgbGVuID0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHYpO1xuICAgICAgICBpZiAobGVuIDwgMHgyMClcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4MjAgLypjc3QuUFJFRklYX1NNQUxMX1NUUklORyovICsgbGVuKTtcbiAgICAgICAgZWxzZSBpZiAobGVuIDwgMHgxMDApXG4gICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUgKDgsIDB4MDkvKmNzdC5DT0RFX1NUUklORzgqLywgbGVuKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlICgzMiwgMHgwQSAvKmNzdC5DT0RFX1NUUklORzMyKi8sIGxlbik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwO2kgPCBsZW47aSsrKVxuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgY2FtbF9zdHJpbmdfdW5zYWZlX2dldCh2LGkpKTtcbiAgICAgICAgd3JpdGVyLnNpemVfMzIgKz0gMSArICgoKGxlbiArIDQpIC8gNCl8MCk7XG4gICAgICAgIHdyaXRlci5zaXplXzY0ICs9IDEgKyAoKChsZW4gKyA4KSAvIDgpfDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHYgIT0gKHZ8MCkpe1xuICAgICAgICAgIHZhciB0eXBlX29mX3YgPSB0eXBlb2YgdjtcbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIElmIGEgZmxvYXQgaGFwcGVucyB0byBiZSBhbiBpbnRlZ2VyIGl0IGlzIHNlcmlhbGl6ZWQgYXMgYW4gaW50ZWdlclxuICAgICAgICAgIC8vIChKc19vZl9vY2FtbCBjYW5ub3QgdGVsbCB3aGV0aGVyIHRoZSB0eXBlIG9mIGFuIGludGVnZXIgbnVtYmVyIGlzXG4gICAgICAgICAgLy8gZmxvYXQgb3IgaW50ZWdlci4pIFRoaXMgY2FuIHJlc3VsdCBpbiB1bmV4cGVjdGVkIGNyYXNoZXMgd2hlblxuICAgICAgICAgIC8vIHVubWFyc2hhbGxpbmcgdXNpbmcgdGhlIHN0YW5kYXJkIHJ1bnRpbWUuIEl0IHNlZW1zIGJldHRlciB0b1xuICAgICAgICAgIC8vIHN5c3RlbWF0aWNhbGx5IGZhaWwgb24gbWFyc2hhbGxpbmcuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyAgICAgICAgICBpZih0eXBlX29mX3YgIT0gXCJudW1iZXJcIilcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwib3V0cHV0X3ZhbHVlOiBhYnN0cmFjdCB2YWx1ZSAoXCIrdHlwZV9vZl92K1wiKVwiKTtcbiAgICAgICAgICAvLyAgICAgICAgICB2YXIgdCA9IGNhbWxfaW50NjRfdG9fYnl0ZXMoY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0KHYpKTtcbiAgICAgICAgICAvLyAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4MEIgLypjc3QuQ09ERV9ET1VCTEVfQklHKi8pO1xuICAgICAgICAgIC8vICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGk8ODsgaSsrKXt3cml0ZXIud3JpdGUoOCx0W2ldKX1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2ID49IDAgJiYgdiA8IDB4NDApIHtcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDBYNDAgLypjc3QuUFJFRklYX1NNQUxMX0lOVCovICsgdik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHYgPj0gLSgxIDw8IDcpICYmIHYgPCAoMSA8PCA3KSlcbiAgICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlKDgsIDB4MDAgLypjc3QuQ09ERV9JTlQ4Ki8sIHYpO1xuICAgICAgICAgIGVsc2UgaWYgKHYgPj0gLSgxIDw8IDE1KSAmJiB2IDwgKDEgPDwgMTUpKVxuICAgICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUoMTYsIDB4MDEgLypjc3QuQ09ERV9JTlQxNiovLCB2KTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSgzMiwgMHgwMiAvKmNzdC5DT0RFX0lOVDMyKi8sIHYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGV4dGVybl9yZWMgKHYpO1xuICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgaSA9IHN0YWNrLnBvcCAoKTtcbiAgICAgIHZhciB2ID0gc3RhY2sucG9wICgpO1xuICAgICAgaWYgKGkgKyAxIDwgdi5sZW5ndGgpIHN0YWNrLnB1c2ggKHYsIGkgKyAxKTtcbiAgICAgIGV4dGVybl9yZWMgKHZbaV0pO1xuICAgIH1cbiAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgd3JpdGVyLm9ial9jb3VudGVyID0gaW50ZXJuX29ial90YWJsZS5vYmpzLmxlbmd0aDtcbiAgICB3cml0ZXIuZmluYWxpemUoKTtcbiAgICByZXR1cm4gd3JpdGVyLmNodW5rO1xuICB9XG59ICgpO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX291dHB1dF92YWx1ZV90b19zdHJpbmcgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9vdXRwdXRfdmFsLCBjYW1sX3N0cmluZ19vZl9hcnJheVxuZnVuY3Rpb24gY2FtbF9vdXRwdXRfdmFsdWVfdG9fc3RyaW5nICh2LCBmbGFncykge1xuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfYXJyYXkgKGNhbWxfb3V0cHV0X3ZhbCAodiwgZmxhZ3MpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnl0ZXMgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9vdXRwdXRfdmFsLCBjYW1sX2J5dGVzX29mX2FycmF5XG5mdW5jdGlvbiBjYW1sX291dHB1dF92YWx1ZV90b19ieXRlcyAodiwgZmxhZ3MpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfb2ZfYXJyYXkgKGNhbWxfb3V0cHV0X3ZhbCAodiwgZmxhZ3MpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnVmZmVyXG4vL1JlcXVpcmVzOiBjYW1sX291dHB1dF92YWwsIGNhbWxfZmFpbHdpdGgsIGNhbWxfYmxpdF9ieXRlc1xuZnVuY3Rpb24gY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnVmZmVyIChzLCBvZnMsIGxlbiwgdiwgZmxhZ3MpIHtcbiAgdmFyIHQgPSBjYW1sX291dHB1dF92YWwgKHYsIGZsYWdzKTtcbiAgaWYgKHQubGVuZ3RoID4gbGVuKSBjYW1sX2ZhaWx3aXRoIChcIk1hcnNoYWwudG9fYnVmZmVyOiBidWZmZXIgb3ZlcmZsb3dcIik7XG4gIGNhbWxfYmxpdF9ieXRlcyh0LCAwLCBzLCBvZnMsIHQubGVuZ3RoKTtcbiAgcmV0dXJuIDA7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSsOpcsO0bWUgVm91aWxsb24sIEh1Z28gSGV1emFyZFxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLy8vLy8vLy8vLy8vIElvXG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2Zkc1xudmFyIGNhbWxfc3lzX2ZkcyA9IG5ldyBBcnJheSgzKTtcblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY2xvc2Vcbi8vUmVxdWlyZXM6IGNhbWxfc3lzX2Zkc1xuZnVuY3Rpb24gY2FtbF9zeXNfY2xvc2UoZmQpIHtcbiAgdmFyIGZpbGUgPSBjYW1sX3N5c19mZHNbZmRdO1xuICBpZihmaWxlKSBmaWxlLmNsb3NlKCk7XG4gIGRlbGV0ZSBjYW1sX3N5c19mZHNbZmRdO1xuICByZXR1cm4gMDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19vcGVuXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvclxuLy9SZXF1aXJlczogTWxGYWtlRmRfb3V0XG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZVxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuLy9SZXF1aXJlczogZnNfbm9kZV9zdXBwb3J0ZWRcbi8vUmVxdWlyZXM6IGNhbWxfc3lzX2Zkc1xuLy9SZXF1aXJlczogY2FtbF9zeXNfb3Blbl9mb3Jfbm9kZVxuZnVuY3Rpb24gY2FtbF9zeXNfb3Blbl9pbnRlcm5hbChmaWxlLGlkeCkge1xuICBpZihpZHggPT0gdW5kZWZpbmVkKXtcbiAgICBpZHggPSBjYW1sX3N5c19mZHMubGVuZ3RoO1xuICB9XG4gIGNhbWxfc3lzX2Zkc1tpZHhdID0gZmlsZTtcbiAgcmV0dXJuIGlkeDtcbn1cbmZ1bmN0aW9uIGNhbWxfc3lzX29wZW4gKG5hbWUsIGZsYWdzLCBfcGVybXMpIHtcbiAgdmFyIGYgPSB7fTtcbiAgd2hpbGUoZmxhZ3Mpe1xuICAgIHN3aXRjaChmbGFnc1sxXSl7XG4gICAgY2FzZSAwOiBmLnJkb25seSA9IDE7YnJlYWs7XG4gICAgY2FzZSAxOiBmLndyb25seSA9IDE7YnJlYWs7XG4gICAgY2FzZSAyOiBmLmFwcGVuZCA9IDE7YnJlYWs7XG4gICAgY2FzZSAzOiBmLmNyZWF0ZSA9IDE7YnJlYWs7XG4gICAgY2FzZSA0OiBmLnRydW5jYXRlID0gMTticmVhaztcbiAgICBjYXNlIDU6IGYuZXhjbCA9IDE7IGJyZWFrO1xuICAgIGNhc2UgNjogZi5iaW5hcnkgPSAxO2JyZWFrO1xuICAgIGNhc2UgNzogZi50ZXh0ID0gMTticmVhaztcbiAgICBjYXNlIDg6IGYubm9uYmxvY2sgPSAxO2JyZWFrO1xuICAgIH1cbiAgICBmbGFncz1mbGFnc1syXTtcbiAgfVxuICBpZihmLnJkb25seSAmJiBmLndyb25seSlcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKG5hbWUpICsgXCIgOiBmbGFncyBPcGVuX3Jkb25seSBhbmQgT3Blbl93cm9ubHkgYXJlIG5vdCBjb21wYXRpYmxlXCIpO1xuICBpZihmLnRleHQgJiYgZi5iaW5hcnkpXG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoY2FtbF9qc2J5dGVzX29mX3N0cmluZyhuYW1lKSArIFwiIDogZmxhZ3MgT3Blbl90ZXh0IGFuZCBPcGVuX2JpbmFyeSBhcmUgbm90IGNvbXBhdGlibGVcIik7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHZhciBmaWxlID0gcm9vdC5kZXZpY2Uub3Blbihyb290LnJlc3QsZik7XG4gIHJldHVybiBjYW1sX3N5c19vcGVuX2ludGVybmFsIChmaWxlLCB1bmRlZmluZWQpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gZmlsZShmZCwgZmxhZ3MpIHtcbiAgICBpZihmc19ub2RlX3N1cHBvcnRlZCgpKSB7XG4gICAgICByZXR1cm4gY2FtbF9zeXNfb3Blbl9mb3Jfbm9kZShmZCwgZmxhZ3MpO1xuICAgIH1cbiAgICBlbHNlXG4gICAgICByZXR1cm4gbmV3IE1sRmFrZUZkX291dChmZCwgZmxhZ3MpXG4gIH1cbiAgY2FtbF9zeXNfb3Blbl9pbnRlcm5hbChmaWxlKDAse3Jkb25seToxLGFsdG5hbWU6XCIvZGV2L3N0ZGluXCIsaXNDaGFyYWN0ZXJEZXZpY2U6dHJ1ZX0pLCAwKTtcbiAgY2FtbF9zeXNfb3Blbl9pbnRlcm5hbChmaWxlKDEse2J1ZmZlcmVkOjIsd3Jvbmx5OjEsaXNDaGFyYWN0ZXJEZXZpY2U6dHJ1ZX0pLCAxKTtcbiAgY2FtbF9zeXNfb3Blbl9pbnRlcm5hbChmaWxlKDIse2J1ZmZlcmVkOjIsd3Jvbmx5OjEsaXNDaGFyYWN0ZXJEZXZpY2U6dHJ1ZX0pLCAyKTtcbn0pKClcblxuXG4vLyBvY2FtbCBDaGFubmVsc1xuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NldF9jaGFubmVsX25hbWVcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfc2V0X2NoYW5uZWxfbmFtZShjaGFuaWQsIG5hbWUpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGNoYW4ubmFtZSA9IG5hbWU7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY2hhbm5lbHNcbnZhciBjYW1sX21sX2NoYW5uZWxzID0gbmV3IEFycmF5KCk7XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3V0X2NoYW5uZWxzX2xpc3Rcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfb3V0X2NoYW5uZWxzX2xpc3QgKCkge1xuICB2YXIgbCA9IDA7XG4gIGZvcih2YXIgYyA9IDA7IGMgPCBjYW1sX21sX2NoYW5uZWxzLmxlbmd0aDsgYysrKXtcbiAgICBpZihjYW1sX21sX2NoYW5uZWxzW2NdICYmIGNhbWxfbWxfY2hhbm5lbHNbY10ub3BlbmVkICYmIGNhbWxfbWxfY2hhbm5lbHNbY10ub3V0KVxuICAgICAgbD1bMCxjYW1sX21sX2NoYW5uZWxzW2NdLmZkLGxdO1xuICB9XG4gIHJldHVybiBsO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX291dFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVscywgY2FtbF9zeXNfZmRzXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvclxuLy9SZXF1aXJlczogY2FtbF9zeXNfb3BlblxuZnVuY3Rpb24gY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3Jfb3V0IChmZCkge1xuICB2YXIgZmlsZSA9IGNhbWxfc3lzX2Zkc1tmZF07XG4gIGlmKGZpbGUuZmxhZ3MucmRvbmx5KSBjYW1sX3JhaXNlX3N5c19lcnJvcihcImZkIFwiKyBmZCArIFwiIGlzIHJlYWRvbmx5XCIpO1xuICB2YXIgYnVmZmVyZWQgPSAoZmlsZS5mbGFncy5idWZmZXJlZCAhPT0gdW5kZWZpbmVkKSA/IGZpbGUuZmxhZ3MuYnVmZmVyZWQgOiAxO1xuICB2YXIgY2hhbm5lbCA9IHtcbiAgICBmaWxlOmZpbGUsXG4gICAgb2Zmc2V0OmZpbGUuZmxhZ3MuYXBwZW5kP2ZpbGUubGVuZ3RoKCk6MCxcbiAgICBmZDpmZCxcbiAgICBvcGVuZWQ6dHJ1ZSxcbiAgICBvdXQ6dHJ1ZSxcbiAgICBidWZmZXJfY3VycjowLFxuICAgIGJ1ZmZlcjpuZXcgVWludDhBcnJheSg2NTUzNiksXG4gICAgYnVmZmVyZWQ6YnVmZmVyZWRcbiAgfTtcbiAgY2FtbF9tbF9jaGFubmVsc1tjaGFubmVsLmZkXT1jaGFubmVsO1xuICByZXR1cm4gY2hhbm5lbC5mZDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3JfaW5cbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfc3lzX2Zkc1xuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfc3lzX29wZW5cbmZ1bmN0aW9uIGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX2luIChmZCkgIHtcbiAgdmFyIGZpbGUgPSBjYW1sX3N5c19mZHNbZmRdO1xuICBpZihmaWxlLmZsYWdzLndyb25seSkgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJmZCBcIisgZmQgKyBcIiBpcyB3cml0ZW9ubHlcIik7XG4gIHZhciByZWZpbGwgPSBudWxsO1xuICB2YXIgY2hhbm5lbCA9IHtcbiAgICBmaWxlOmZpbGUsXG4gICAgb2Zmc2V0OmZpbGUuZmxhZ3MuYXBwZW5kP2ZpbGUubGVuZ3RoKCk6MCxcbiAgICBmZDpmZCxcbiAgICBvcGVuZWQ6dHJ1ZSxcbiAgICBvdXQ6IGZhbHNlLFxuICAgIGJ1ZmZlcl9jdXJyOjAsXG4gICAgYnVmZmVyX21heDowLFxuICAgIGJ1ZmZlcjpuZXcgVWludDhBcnJheSg2NTUzNiksXG4gICAgcmVmaWxsOnJlZmlsbFxuICB9O1xuICBjYW1sX21sX2NoYW5uZWxzW2NoYW5uZWwuZmRdPWNoYW5uZWw7XG4gIHJldHVybiBjaGFubmVsLmZkO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfY2hhbm5lbF9kZXNjcmlwdG9yXG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzXG4vL0FsaWFzOiB3aW5fZmlsZWRlc2NyX29mX2NoYW5uZWxcbmZ1bmN0aW9uIGNhbWxfY2hhbm5lbF9kZXNjcmlwdG9yKGNoYW5pZCl7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICByZXR1cm4gY2hhbi5mZDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZXRfYmluYXJ5X21vZGVcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfc2V0X2JpbmFyeV9tb2RlKGNoYW5pZCxtb2RlKXtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGNoYW4uZmlsZS5mbGFncy50ZXh0ID0gIW1vZGVcbiAgY2hhbi5maWxlLmZsYWdzLmJpbmFyeSA9IG1vZGVcbiAgcmV0dXJuIDA7XG59XG5cbi8vSW5wdXQgZnJvbSBpbl9jaGFubmVsXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY2xvc2VfY2hhbm5lbFxuLy9SZXF1aXJlczogY2FtbF9tbF9mbHVzaCwgY2FtbF9tbF9jaGFubmVsc1xuLy9SZXF1aXJlczogY2FtbF9zeXNfY2xvc2VcbmZ1bmN0aW9uIGNhbWxfbWxfY2xvc2VfY2hhbm5lbCAoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBjaGFuLm9wZW5lZCA9IGZhbHNlO1xuICBjYW1sX3N5c19jbG9zZShjaGFuLmZkKVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9jaGFubmVsX3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfY2hhbm5lbF9zaXplKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgcmV0dXJuIGNoYW4uZmlsZS5sZW5ndGgoKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9jaGFubmVsX3NpemVfNjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfZmxvYXQsY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9jaGFubmVsX3NpemVfNjQoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9mbG9hdChjaGFuLmZpbGUubGVuZ3RoICgpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZXRfY2hhbm5lbF9vdXRwdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfc2V0X2NoYW5uZWxfb3V0cHV0KGNoYW5pZCxmKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBjaGFuLm91dHB1dCA9IChmdW5jdGlvbiAocykge2Yocyl9KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2V0X2NoYW5uZWxfcmVmaWxsXG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX3NldF9jaGFubmVsX3JlZmlsbChjaGFuaWQsZikge1xuICBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF0ucmVmaWxsID0gZjtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmVmaWxsXG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfdWludDhfYXJyYXlfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3JlZmlsbCAoY2hhbikge1xuICBpZihjaGFuLnJlZmlsbCAhPSBudWxsKXtcbiAgICB2YXIgc3RyID0gY2hhbi5yZWZpbGwoKTtcbiAgICB2YXIgc3RyX2EgPSBjYW1sX3VpbnQ4X2FycmF5X29mX3N0cmluZyhzdHIpO1xuICAgIGlmIChzdHJfYS5sZW5ndGggPT0gMCkge1xuICAgICAgY2hhbi5yZWZpbGwgPSBudWxsXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYoY2hhbi5idWZmZXIubGVuZ3RoIDwgY2hhbi5idWZmZXJfbWF4ICsgc3RyX2EubGVuZ3RoKXtcbiAgICAgICAgdmFyIGIgPSBuZXcgVWludDhBcnJheShjaGFuLmJ1ZmZlcl9tYXggKyBzdHJfYS5sZW5ndGgpO1xuICAgICAgICBiLnNldChjaGFuLmJ1ZmZlcik7XG4gICAgICAgIGNoYW4uYnVmZmVyID0gYjtcbiAgICAgIH1cbiAgICAgIGNoYW4uYnVmZmVyLnNldChzdHJfYSxjaGFuLmJ1ZmZlcl9tYXgpO1xuICAgICAgY2hhbi5vZmZzZXQgKz0gc3RyX2EubGVuZ3RoO1xuICAgICAgY2hhbi5idWZmZXJfbWF4ICs9IHN0cl9hLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIG5yZWFkID0gY2hhbi5maWxlLnJlYWQoY2hhbi5vZmZzZXQsIGNoYW4uYnVmZmVyLCBjaGFuLmJ1ZmZlcl9tYXgsIGNoYW4uYnVmZmVyLmxlbmd0aCAtIGNoYW4uYnVmZmVyX21heCk7XG4gICAgY2hhbi5vZmZzZXQgKz0gbnJlYWQ7XG4gICAgY2hhbi5idWZmZXJfbWF4ICs9IG5yZWFkO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfaW5wdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfaW5wdXRfYmxvY2tcbi8vUmVxdWlyZXM6IGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbWxfaW5wdXQgKGNoYW5pZCwgYiwgaSwgbCkge1xuICB2YXIgYmEgPSBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzKGIpO1xuICByZXR1cm4gY2FtbF9tbF9pbnB1dF9ibG9jayhjaGFuaWQsIGJhLCBpLCBsKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2lucHV0X2Jsb2NrXG4vL1JlcXVpcmVzOiBjYW1sX3JlZmlsbCwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9pbnB1dF9ibG9jayAoY2hhbmlkLCBiYSwgaSwgbCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgdmFyIG4gPSBsO1xuICB2YXIgYXZhaWwgPSBjaGFuLmJ1ZmZlcl9tYXggLSBjaGFuLmJ1ZmZlcl9jdXJyO1xuICBpZihsIDw9IGF2YWlsKSB7XG4gICAgYmEuc2V0KGNoYW4uYnVmZmVyLnN1YmFycmF5KGNoYW4uYnVmZmVyX2N1cnIsY2hhbi5idWZmZXJfY3VyciArIGwpLCBpKTtcbiAgICBjaGFuLmJ1ZmZlcl9jdXJyICs9IGw7XG4gIH1cbiAgZWxzZSBpZihhdmFpbCA+IDApIHtcbiAgICBiYS5zZXQoY2hhbi5idWZmZXIuc3ViYXJyYXkoY2hhbi5idWZmZXJfY3VycixjaGFuLmJ1ZmZlcl9jdXJyICsgYXZhaWwpLCBpKTtcbiAgICBjaGFuLmJ1ZmZlcl9jdXJyICs9IGF2YWlsO1xuICAgIG4gPSBhdmFpbDtcbiAgfSBlbHNlIHtcbiAgICBjaGFuLmJ1ZmZlcl9jdXJyID0gMDtcbiAgICBjaGFuLmJ1ZmZlcl9tYXggPSAwO1xuICAgIGNhbWxfcmVmaWxsKGNoYW4pO1xuICAgIHZhciBhdmFpbCA9IGNoYW4uYnVmZmVyX21heCAtIGNoYW4uYnVmZmVyX2N1cnI7XG4gICAgaWYobiA+IGF2YWlsKSBuID0gYXZhaWw7XG4gICAgYmEuc2V0KGNoYW4uYnVmZmVyLnN1YmFycmF5KGNoYW4uYnVmZmVyX2N1cnIsY2hhbi5idWZmZXJfY3VyciArIG4pLCBpKTtcbiAgICBjaGFuLmJ1ZmZlcl9jdXJyICs9IG47XG4gIH1cbiAgcmV0dXJuIG47XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5wdXRfdmFsdWVcbi8vUmVxdWlyZXM6IGNhbWxfbWFyc2hhbF9kYXRhX3NpemUsIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9ieXRlcywgY2FtbF9jcmVhdGVfYnl0ZXMsIGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfYnl0ZXNfb2ZfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfcmVmaWxsLCBjYW1sX2ZhaWx3aXRoLCBjYW1sX3JhaXNlX2VuZF9vZl9maWxlXG5mdW5jdGlvbiBjYW1sX2lucHV0X3ZhbHVlIChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIHZhciBoZWFkZXIgPSBuZXcgVWludDhBcnJheSgyMCk7XG4gIGZ1bmN0aW9uIGJsb2NrKGJ1ZmZlciwgb2Zmc2V0LCBuKSB7XG4gICAgdmFyIHIgPSAwO1xuICAgIHdoaWxlKHIgPCBuKXtcbiAgICAgIGlmKGNoYW4uYnVmZmVyX2N1cnIgPj0gY2hhbi5idWZmZXJfbWF4KXtcbiAgICAgICAgY2hhbi5idWZmZXJfY3VyciA9IDA7XG4gICAgICAgIGNoYW4uYnVmZmVyX21heCA9IDA7XG4gICAgICAgIGNhbWxfcmVmaWxsKGNoYW4pO1xuICAgICAgfVxuICAgICAgaWYgKGNoYW4uYnVmZmVyX2N1cnIgPj0gY2hhbi5idWZmZXJfbWF4KVxuICAgICAgICBicmVhaztcbiAgICAgIGJ1ZmZlcltvZmZzZXQrcl0gPSBjaGFuLmJ1ZmZlcltjaGFuLmJ1ZmZlcl9jdXJyXTtcbiAgICAgIGNoYW4uYnVmZmVyX2N1cnIrKztcbiAgICAgIHIrKztcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgdmFyIHIgPSBibG9jayhoZWFkZXIsIDAsIDIwKTtcbiAgaWYociA9PSAwKVxuICAgIGNhbWxfcmFpc2VfZW5kX29mX2ZpbGUoKTtcbiAgZWxzZSBpZiAociA8IDIwKVxuICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogdHJ1bmNhdGVkIG9iamVjdFwiKTtcbiAgdmFyIGxlbiA9IGNhbWxfbWFyc2hhbF9kYXRhX3NpemUgKGNhbWxfYnl0ZXNfb2ZfYXJyYXkoaGVhZGVyKSwgMCk7XG4gIHZhciBidWYgPSBuZXcgVWludDhBcnJheShsZW4gKyAyMCk7XG4gIGJ1Zi5zZXQoaGVhZGVyLDApO1xuICB2YXIgciA9IGJsb2NrKGJ1ZiwgMjAsIGxlbilcbiAgaWYociA8IGxlbilcbiAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IHRydW5jYXRlZCBvYmplY3QgXCIgKyByICsgXCIgIFwiICsgbGVuKTtcbiAgdmFyIG9mZnNldCA9IFswXTtcbiAgdmFyIHJlcyA9IGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9ieXRlcyhjYW1sX2J5dGVzX29mX2FycmF5KGJ1ZiksIG9mZnNldCk7XG4gIGNoYW4ub2Zmc2V0ID0gY2hhbi5vZmZzZXQgKyBvZmZzZXRbMF07XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5wdXRfdmFsdWVfdG9fb3V0c2lkZV9oZWFwXG4vL1JlcXVpcmVzOiBjYW1sX2lucHV0X3ZhbHVlXG5mdW5jdGlvbiBjYW1sX2lucHV0X3ZhbHVlX3RvX291dHNpZGVfaGVhcChjKSB7XG4gIHJldHVybiBjYW1sX2lucHV0X3ZhbHVlKGMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2lucHV0X2NoYXJcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfZW5kX29mX2ZpbGUsIGNhbWxfYXJyYXlfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfcmVmaWxsXG5mdW5jdGlvbiBjYW1sX21sX2lucHV0X2NoYXIgKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgaWYoY2hhbi5idWZmZXJfY3VyciA+PSBjaGFuLmJ1ZmZlcl9tYXgpe1xuICAgIGNoYW4uYnVmZmVyX2N1cnIgPSAwO1xuICAgIGNoYW4uYnVmZmVyX21heCA9IDA7XG4gICAgY2FtbF9yZWZpbGwoY2hhbik7XG4gIH1cbiAgaWYgKGNoYW4uYnVmZmVyX2N1cnIgPj0gY2hhbi5idWZmZXJfbWF4KVxuICAgIGNhbWxfcmFpc2VfZW5kX29mX2ZpbGUoKTtcbiAgdmFyIHJlcyA9IGNoYW4uYnVmZmVyW2NoYW4uYnVmZmVyX2N1cnJdO1xuICBjaGFuLmJ1ZmZlcl9jdXJyKys7XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfaW5wdXRfaW50XG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2VuZF9vZl9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX21sX2lucHV0X2NoYXIsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfaW5wdXRfaW50IChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIHZhciByZXMgPSAwO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgNDsgaSsrKXtcbiAgICByZXMgPSAocmVzIDw8IDgpICsgY2FtbF9tbF9pbnB1dF9jaGFyKGNoYW5pZCk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zZWVrX2luXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9zZWVrX2luKGNoYW5pZCwgcG9zKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBpZiAoY2hhbi5yZWZpbGwgIT0gbnVsbCkgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJJbGxlZ2FsIHNlZWtcIik7XG4gIGlmKHBvcyA+PSBjaGFuLm9mZnNldCAtIGNoYW4uYnVmZmVyX21heFxuICAgICAmJiBwb3MgPD0gY2hhbi5vZmZzZXRcbiAgICAgJiYgY2hhbi5maWxlLmZsYWdzLmJpbmFyeSkge1xuICAgIGNoYW4uYnVmZmVyX2N1cnIgPSBjaGFuLmJ1ZmZlcl9tYXggLSAoY2hhbi5vZmZzZXQgLSBwb3MpO1xuICB9IGVsc2Uge1xuICAgIGNoYW4ub2Zmc2V0ID0gcG9zO1xuICAgIGNoYW4uYnVmZmVyX2N1cnIgPSAwO1xuICAgIGNoYW4uYnVmZmVyX21heCA9IDA7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2Vla19pblxuLy9SZXF1aXJlczogY2FtbF9zZWVrX2luXG5mdW5jdGlvbiBjYW1sX21sX3NlZWtfaW4oY2hhbmlkLHBvcyl7XG4gIHJldHVybiBjYW1sX3NlZWtfaW4oY2hhbmlkLHBvcyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2Vla19pbl82NFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19mbG9hdCwgY2FtbF9zZWVrX2luXG5mdW5jdGlvbiBjYW1sX21sX3NlZWtfaW5fNjQoY2hhbmlkLHBvcyl7XG4gIHZhciBwb3MgPSBjYW1sX2ludDY0X3RvX2Zsb2F0KHBvcyk7XG4gIHJldHVybiBjYW1sX3NlZWtfaW4oY2hhbmlkLCBwb3MpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3Bvc19pblxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9wb3NfaW4oY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICByZXR1cm4gY2hhbi5vZmZzZXQgLSAoY2hhbi5idWZmZXJfbWF4IC0gY2hhbi5idWZmZXJfY3Vycik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcG9zX2luXG4vL1JlcXVpcmVzOiBjYW1sX3Bvc19pblxuZnVuY3Rpb24gY2FtbF9tbF9wb3NfaW4oY2hhbmlkKSB7XG4gIHJldHVybiBjYW1sX3Bvc19pbihjaGFuaWQpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3Bvc19pbl82NFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9mbG9hdCwgY2FtbF9wb3NfaW5cbmZ1bmN0aW9uIGNhbWxfbWxfcG9zX2luXzY0KGNoYW5pZCkge1xuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9mbG9hdChjYW1sX3Bvc19pbihjaGFuaWQpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9pbnB1dF9zY2FuX2xpbmVcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfcmVmaWxsXG5mdW5jdGlvbiBjYW1sX21sX2lucHV0X3NjYW5fbGluZShjaGFuaWQpe1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgdmFyIHAgPSBjaGFuLmJ1ZmZlcl9jdXJyO1xuICBkbyB7XG4gICAgaWYocCA+PSBjaGFuLmJ1ZmZlcl9tYXgpIHtcbiAgICAgIGlmKGNoYW4uYnVmZmVyX2N1cnIgPiAwKSB7XG4gICAgICAgIGNoYW4uYnVmZmVyLnNldChjaGFuLmJ1ZmZlci5zdWJhcnJheShjaGFuLmJ1ZmZlcl9jdXJyKSwwKTtcbiAgICAgICAgcCAtPSBjaGFuLmJ1ZmZlcl9jdXJyO1xuICAgICAgICBjaGFuLmJ1ZmZlcl9tYXggLT0gY2hhbi5idWZmZXJfY3VycjtcbiAgICAgICAgY2hhbi5idWZmZXJfY3VyciA9IDA7XG4gICAgICB9XG4gICAgICBpZihjaGFuLmJ1ZmZlcl9tYXggPj0gY2hhbi5idWZmZXIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtKGNoYW4uYnVmZmVyX21heCk7XG4gICAgICB9XG4gICAgICB2YXIgcHJldl9tYXggPSBjaGFuLmJ1ZmZlcl9tYXg7XG4gICAgICBjYW1sX3JlZmlsbCAoY2hhbik7XG4gICAgICBpZihwcmV2X21heCA9PSBjaGFuLmJ1ZmZlcl9tYXgpIHtcbiAgICAgICAgcmV0dXJuIC0oY2hhbi5idWZmZXJfbWF4KTtcbiAgICAgIH1cbiAgICB9XG4gIH0gd2hpbGUgKGNoYW4uYnVmZmVyW3ArK10gIT0gMTApO1xuICByZXR1cm4gcCAtIGNoYW4uYnVmZmVyX2N1cnI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfZmx1c2hcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX21sX2NoYW5uZWxzXG4vL1JlcXVpcmVzOiBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbWxfZmx1c2ggKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgaWYoISBjaGFuLm9wZW5lZCkgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJDYW5ub3QgZmx1c2ggYSBjbG9zZWQgY2hhbm5lbFwiKTtcbiAgaWYoIWNoYW4uYnVmZmVyIHx8IGNoYW4uYnVmZmVyX2N1cnIgPT0gMCkgcmV0dXJuIDA7XG4gIGlmKGNoYW4ub3V0cHV0KSB7XG4gICAgY2hhbi5vdXRwdXQoY2FtbF9zdWJhcnJheV90b19qc2J5dGVzKGNoYW4uYnVmZmVyLCAwLCBjaGFuLmJ1ZmZlcl9jdXJyKSk7XG4gIH0gZWxzZSB7XG4gICAgY2hhbi5maWxlLndyaXRlKGNoYW4ub2Zmc2V0LCBjaGFuLmJ1ZmZlciwgMCwgY2hhbi5idWZmZXJfY3Vycik7XG4gIH1cbiAgY2hhbi5vZmZzZXQgKz0gY2hhbi5idWZmZXJfY3VycjtcbiAgY2hhbi5idWZmZXJfY3VyciA9IDA7XG4gIHJldHVybiAwO1xufVxuXG4vL291dHB1dCB0byBvdXRfY2hhbm5lbFxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX291dHB1dF9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9tbF9mbHVzaCxjYW1sX21sX2J5dGVzX2xlbmd0aFxuLy9SZXF1aXJlczogY2FtbF9jcmVhdGVfYnl0ZXMsIGNhbWxfYmxpdF9ieXRlcywgY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfc3RyaW5nX29mX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX21sX291dHB1dF9ieXRlcyhjaGFuaWQsYnVmZmVyLG9mZnNldCxsZW4pIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGlmKCEgY2hhbi5vcGVuZWQpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKFwiQ2Fubm90IG91dHB1dCB0byBhIGNsb3NlZCBjaGFubmVsXCIpO1xuICB2YXIgYnVmZmVyID0gY2FtbF91aW50OF9hcnJheV9vZl9ieXRlcyhidWZmZXIpO1xuICBidWZmZXIgPSBidWZmZXIuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBpZihjaGFuLmJ1ZmZlcl9jdXJyICsgYnVmZmVyLmxlbmd0aCA+IGNoYW4uYnVmZmVyLmxlbmd0aCkge1xuICAgIHZhciBiID0gbmV3IFVpbnQ4QXJyYXkoY2hhbi5idWZmZXJfY3VyciArIGJ1ZmZlci5sZW5ndGgpO1xuICAgIGIuc2V0KGNoYW4uYnVmZmVyKTtcbiAgICBjaGFuLmJ1ZmZlciA9IGJcbiAgfVxuICBzd2l0Y2goY2hhbi5idWZmZXJlZCl7XG4gIGNhc2UgMDogLy8gVW5idWZmZXJlZFxuICAgIGNoYW4uYnVmZmVyLnNldChidWZmZXIsIGNoYW4uYnVmZmVyX2N1cnIpO1xuICAgIGNoYW4uYnVmZmVyX2N1cnIgKz0gYnVmZmVyLmxlbmd0aDtcbiAgICBjYW1sX21sX2ZsdXNoIChjaGFuaWQpO1xuICAgIGJyZWFrXG4gIGNhc2UgMTogLy8gQnVmZmVyZWQgKHRoZSBkZWZhdWx0KVxuICAgIGNoYW4uYnVmZmVyLnNldChidWZmZXIsIGNoYW4uYnVmZmVyX2N1cnIpO1xuICAgIGNoYW4uYnVmZmVyX2N1cnIgKz0gYnVmZmVyLmxlbmd0aDtcbiAgICBpZihjaGFuLmJ1ZmZlcl9jdXJyID49IGNoYW4uYnVmZmVyLmxlbmd0aClcbiAgICAgIGNhbWxfbWxfZmx1c2ggKGNoYW5pZCk7XG4gICAgYnJlYWs7XG4gIGNhc2UgMjogLy8gQnVmZmVyZWQgKG9ubHkgZm9yIHN0ZG91dCBhbmQgc3RkZXJyKVxuICAgIHZhciBpZCA9IGJ1ZmZlci5sYXN0SW5kZXhPZigxMClcbiAgICBpZihpZCA8IDApIHtcbiAgICAgIGNoYW4uYnVmZmVyLnNldChidWZmZXIsIGNoYW4uYnVmZmVyX2N1cnIpO1xuICAgICAgY2hhbi5idWZmZXJfY3VyciArPSBidWZmZXIubGVuZ3RoO1xuICAgICAgaWYoY2hhbi5idWZmZXJfY3VyciA+PSBjaGFuLmJ1ZmZlci5sZW5ndGgpXG4gICAgICAgIGNhbWxfbWxfZmx1c2ggKGNoYW5pZCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY2hhbi5idWZmZXIuc2V0KGJ1ZmZlci5zdWJhcnJheSgwLCBpZCArIDEpLCBjaGFuLmJ1ZmZlcl9jdXJyKTtcbiAgICAgIGNoYW4uYnVmZmVyX2N1cnIgKz0gaWQgKyAxO1xuICAgICAgY2FtbF9tbF9mbHVzaCAoY2hhbmlkKTtcbiAgICAgIGNoYW4uYnVmZmVyLnNldChidWZmZXIuc3ViYXJyYXkoaWQgKyAxKSwgY2hhbi5idWZmZXJfY3Vycik7XG4gICAgICBjaGFuLmJ1ZmZlcl9jdXJyICs9IGJ1ZmZlci5sZW5ndGggLSBpZCAtIDE7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX291dHB1dFxuLy9SZXF1aXJlczogY2FtbF9tbF9vdXRwdXRfYnl0ZXMsIGNhbWxfYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX21sX291dHB1dChjaGFuaWQsYnVmZmVyLG9mZnNldCxsZW4pe1xuICByZXR1cm4gY2FtbF9tbF9vdXRwdXRfYnl0ZXMoY2hhbmlkLGNhbWxfYnl0ZXNfb2Zfc3RyaW5nKGJ1ZmZlciksb2Zmc2V0LGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3V0cHV0X2NoYXJcbi8vUmVxdWlyZXM6IGNhbWxfbWxfb3V0cHV0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX21sX291dHB1dF9jaGFyIChjaGFuaWQsYykge1xuICB2YXIgcyA9IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoU3RyaW5nLmZyb21DaGFyQ29kZShjKSk7XG4gIGNhbWxfbWxfb3V0cHV0KGNoYW5pZCxzLDAsMSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX291dHB1dF92YWx1ZVxuLy9SZXF1aXJlczogY2FtbF9vdXRwdXRfdmFsdWVfdG9fc3RyaW5nLCBjYW1sX21sX291dHB1dCxjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfb3V0cHV0X3ZhbHVlIChjaGFuaWQsdixmbGFncykge1xuICB2YXIgcyA9IGNhbWxfb3V0cHV0X3ZhbHVlX3RvX3N0cmluZyh2LCBmbGFncyk7XG4gIGNhbWxfbWxfb3V0cHV0KGNoYW5pZCxzLDAsY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpKTtcbiAgcmV0dXJuIDA7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9zZWVrX291dFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVscywgY2FtbF9tbF9mbHVzaFxuZnVuY3Rpb24gY2FtbF9zZWVrX291dChjaGFuaWQsIHBvcyl7XG4gIGNhbWxfbWxfZmx1c2goY2hhbmlkKTtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGNoYW4ub2Zmc2V0ID0gcG9zO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZWVrX291dFxuLy9SZXF1aXJlczogY2FtbF9zZWVrX291dFxuZnVuY3Rpb24gY2FtbF9tbF9zZWVrX291dChjaGFuaWQscG9zKXtcbiAgcmV0dXJuIGNhbWxfc2Vla19vdXQoY2hhbmlkLCBwb3MpO1xufVxuLy9Qcm92aWRlczogY2FtbF9tbF9zZWVrX291dF82NFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19mbG9hdCwgY2FtbF9zZWVrX291dFxuZnVuY3Rpb24gY2FtbF9tbF9zZWVrX291dF82NChjaGFuaWQscG9zKXtcbiAgdmFyIHBvcyA9IGNhbWxfaW50NjRfdG9fZmxvYXQocG9zKTtcbiAgcmV0dXJuIGNhbWxfc2Vla19vdXQoY2hhbmlkLCBwb3MpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3Bvc19vdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfbWxfZmx1c2hcbmZ1bmN0aW9uIGNhbWxfcG9zX291dChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIHJldHVybiBjaGFuLm9mZnNldCArIGNoYW4uYnVmZmVyX2N1cnJcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9wb3Nfb3V0XG4vL1JlcXVpcmVzOiBjYW1sX3Bvc19vdXRcbmZ1bmN0aW9uIGNhbWxfbWxfcG9zX291dChjaGFuaWQpIHtcbiAgcmV0dXJuIGNhbWxfcG9zX291dChjaGFuaWQpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3Bvc19vdXRfNjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfZmxvYXQsIGNhbWxfcG9zX291dFxuZnVuY3Rpb24gY2FtbF9tbF9wb3Nfb3V0XzY0KGNoYW5pZCkge1xuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9mbG9hdCAoY2FtbF9wb3Nfb3V0KGNoYW5pZCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX291dHB1dF9pbnRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfb3V0cHV0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9hcnJheVxuZnVuY3Rpb24gY2FtbF9tbF9vdXRwdXRfaW50IChjaGFuaWQsaSkge1xuICB2YXIgYXJyID0gWyhpPj4yNCkgJiAweEZGLChpPj4xNikgJiAweEZGLChpPj44KSAmIDB4RkYsaSAmIDB4RkYgXTtcbiAgdmFyIHMgPSBjYW1sX3N0cmluZ19vZl9hcnJheShhcnIpO1xuICBjYW1sX21sX291dHB1dChjaGFuaWQscywwLDQpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2lzX2J1ZmZlcmVkXG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX2lzX2J1ZmZlcmVkKGNoYW5pZCkge1xuICByZXR1cm4gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdLmJ1ZmZlcmVkID8gMSA6IDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZXRfYnVmZmVyZWRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfbWxfZmx1c2hcbmZ1bmN0aW9uIGNhbWxfbWxfc2V0X2J1ZmZlcmVkKGNoYW5pZCx2KSB7XG4gIGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXS5idWZmZXJlZCA9IHY7XG4gIGlmKCF2KSBjYW1sX21sX2ZsdXNoKGNoYW5pZCk7XG4gIHJldHVybiAwXG59XG4iLCJcblxuLy9Qcm92aWRlczogY2FtbF9nY19taW5vclxuZnVuY3Rpb24gY2FtbF9nY19taW5vcih1bml0KXtcbiAgLy9hdmFpbGFibGUgd2l0aCBbbm9kZSAtLWV4cG9zZS1nY11cbiAgaWYodHlwZW9mIGdsb2JhbFRoaXMuZ2MgPT0gJ2Z1bmN0aW9uJykgZ2xvYmFsVGhpcy5nYyh0cnVlKTtcbiAgcmV0dXJuIDBcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfbWFqb3JcbmZ1bmN0aW9uIGNhbWxfZ2NfbWFqb3IodW5pdCl7XG4gIC8vYXZhaWxhYmxlIHdpdGggW25vZGUgLS1leHBvc2UtZ2NdXG4gIGlmKHR5cGVvZiBnbG9iYWxUaGlzLmdjID09ICdmdW5jdGlvbicpIGdsb2JhbFRoaXMuZ2MoKTtcbiAgcmV0dXJuIDBcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfZnVsbF9tYWpvclxuZnVuY3Rpb24gY2FtbF9nY19mdWxsX21ham9yKHVuaXQpe1xuICAvL2F2YWlsYWJsZSB3aXRoIFtub2RlIC0tZXhwb3NlLWdjXVxuICBpZih0eXBlb2YgZ2xvYmFsVGhpcy5nYyA9PSAnZnVuY3Rpb24nKSBnbG9iYWxUaGlzLmdjKCk7XG4gIHJldHVybiAwXG59XG4vL1Byb3ZpZGVzOiBjYW1sX2djX2NvbXBhY3Rpb25cbmZ1bmN0aW9uIGNhbWxfZ2NfY29tcGFjdGlvbigpeyByZXR1cm4gMH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfY291bnRlcnNcbmZ1bmN0aW9uIGNhbWxfZ2NfY291bnRlcnMoKSB7IHJldHVybiBbMjU0LDAsMCwwXSB9XG4vL1Byb3ZpZGVzOiBjYW1sX2djX3F1aWNrX3N0YXRcbmZ1bmN0aW9uIGNhbWxfZ2NfcXVpY2tfc3RhdCgpe1xuICByZXR1cm4gWzAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMF1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ2Nfc3RhdFxuZnVuY3Rpb24gY2FtbF9nY19zdGF0KCkge1xuICByZXR1cm4gWzAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMF1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9nY19zZXRcbmZ1bmN0aW9uIGNhbWxfZ2Nfc2V0KF9jb250cm9sKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2djX2dldFxuZnVuY3Rpb24gY2FtbF9nY19nZXQoKXtcbiAgcmV0dXJuIFswLDAsMCwwLDAsMCwwLDAsMF1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9tZW1wcm9mX3NldFxuZnVuY3Rpb24gY2FtbF9tZW1wcm9mX3NldChfY29udHJvbCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9maW5hbF9yZWdpc3RlciBjb25zdFxuZnVuY3Rpb24gY2FtbF9maW5hbF9yZWdpc3RlciAoKSB7IHJldHVybiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmluYWxfcmVnaXN0ZXJfY2FsbGVkX3dpdGhvdXRfdmFsdWVcbnZhciBhbGxfZmluYWxpemVycyA9IG5ldyBnbG9iYWxUaGlzLlNldCgpXG5mdW5jdGlvbiBjYW1sX2ZpbmFsX3JlZ2lzdGVyX2NhbGxlZF93aXRob3V0X3ZhbHVlIChjYiwgYSkge1xuICBpZihnbG9iYWxUaGlzLkZpbmFsaXphdGlvblJlZ2lzdHJ5ICYmIGEgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICB2YXIgeCA9IG5ldyBnbG9iYWxUaGlzLkZpbmFsaXphdGlvblJlZ2lzdHJ5KGZ1bmN0aW9uICh4KXthbGxfZmluYWxpemVycy5kZWxldGUoeCk7IGNiKDApOyByZXR1cm47fSk7XG4gICAgeC5yZWdpc3RlcihhLHgpO1xuICAgIGFsbF9maW5hbGl6ZXJzLmFkZCh4KTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9maW5hbF9yZWxlYXNlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ZpbmFsX3JlbGVhc2UgKCkgeyByZXR1cm4gMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21lbXByb2Zfc3RhcnRcbmZ1bmN0aW9uIGNhbWxfbWVtcHJvZl9zdGFydChyYXRlLHN0YWNrX3NpemUsdHJhY2tlcil7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21lbXByb2Zfc3RvcFxuZnVuY3Rpb24gY2FtbF9tZW1wcm9mX3N0b3AodW5pdCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ldmVudGxvZ19yZXN1bWVcbmZ1bmN0aW9uIGNhbWxfZXZlbnRsb2dfcmVzdW1lKHVuaXQpIHsgcmV0dXJuIDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9ldmVudGxvZ19wYXVzZVxuZnVuY3Rpb24gY2FtbF9ldmVudGxvZ19wYXVzZSh1bml0KSB7IHJldHVybiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfaHVnZV9mYWxsYmFja19jb3VudFxuZnVuY3Rpb24gY2FtbF9nY19odWdlX2ZhbGxiYWNrX2NvdW50KHVuaXQpIHsgcmV0dXJuIDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9nY19tYWpvcl9zbGljZVxuZnVuY3Rpb24gY2FtbF9nY19tYWpvcl9zbGljZSh3b3JrKSB7IHJldHVybiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfbWlub3Jfd29yZHNcbmZ1bmN0aW9uIGNhbWxfZ2NfbWlub3Jfd29yZHModW5pdCkgeyByZXR1cm4gMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9taW5vcl9mcmVlXG5mdW5jdGlvbiBjYW1sX2dldF9taW5vcl9mcmVlKHVuaXQpIHsgcmV0dXJuIDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9nZXRfbWFqb3JfYnVja2V0XG5mdW5jdGlvbiBjYW1sX2dldF9tYWpvcl9idWNrZXQobikgeyByZXR1cm4gMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9tYWpvcl9jcmVkaXRcbmZ1bmN0aW9uIGNhbWxfZ2V0X21ham9yX2NyZWRpdChuKSB7IHJldHVybiAwOyB9XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSsOpcsO0bWUgVm91aWxsb24sIEh1Z28gSGV1emFyZCwgQW5keSBSYXlcbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cbi8vXG4vLyBCaWdhcnJheS5cbi8vXG4vLyAtIGFsbCBiaWdhcnJheSB0eXBlcyBpbmNsdWRpbmcgSW50NjQgYW5kIENvbXBsZXguXG4vLyAtIGZvcnRyYW4gKyBjIGxheW91dHNcbi8vIC0gc3ViL3NsaWNlL3Jlc2hhcGVcbi8vIC0gcmV0YWluIGZhc3QgcGF0aCBmb3IgMWQgYXJyYXkgYWNjZXNzXG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfaW5pdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9iYV9pbml0KCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9nZXRfc2l6ZVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2dldF9zaXplKGRpbXMpIHtcbiAgdmFyIG5fZGltcyA9IGRpbXMubGVuZ3RoO1xuICB2YXIgc2l6ZSA9IDE7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbl9kaW1zOyBpKyspIHtcbiAgICBpZiAoZGltc1tpXSA8IDApXG4gICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5jcmVhdGU6IG5lZ2F0aXZlIGRpbWVuc2lvblwiKTtcbiAgICBzaXplID0gc2l6ZSAqIGRpbXNbaV07XG4gIH1cbiAgcmV0dXJuIHNpemU7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnQoa2luZCl7XG4gIHN3aXRjaChraW5kKXtcbiAgY2FzZSA3OiBjYXNlIDEwOiBjYXNlIDExOiByZXR1cm4gMjtcbiAgZGVmYXVsdDogcmV0dXJuIDE7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9jcmVhdGVfYnVmZmVyXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50XG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfY3JlYXRlX2J1ZmZlcihraW5kLCBzaXplKXtcbiAgdmFyIHZpZXc7XG4gIHN3aXRjaChraW5kKXtcbiAgY2FzZSAwOiAgdmlldyA9IEZsb2F0MzJBcnJheTsgYnJlYWs7XG4gIGNhc2UgMTogIHZpZXcgPSBGbG9hdDY0QXJyYXk7IGJyZWFrO1xuICBjYXNlIDI6ICB2aWV3ID0gSW50OEFycmF5OyBicmVhaztcbiAgY2FzZSAzOiAgdmlldyA9IFVpbnQ4QXJyYXk7IGJyZWFrO1xuICBjYXNlIDQ6ICB2aWV3ID0gSW50MTZBcnJheTsgYnJlYWs7XG4gIGNhc2UgNTogIHZpZXcgPSBVaW50MTZBcnJheTsgYnJlYWs7XG4gIGNhc2UgNjogIHZpZXcgPSBJbnQzMkFycmF5OyBicmVhaztcbiAgY2FzZSA3OiAgdmlldyA9IEludDMyQXJyYXk7IGJyZWFrO1xuICBjYXNlIDg6ICB2aWV3ID0gSW50MzJBcnJheTsgYnJlYWs7XG4gIGNhc2UgOTogIHZpZXcgPSBJbnQzMkFycmF5OyBicmVhaztcbiAgY2FzZSAxMDogdmlldyA9IEZsb2F0MzJBcnJheTsgYnJlYWs7XG4gIGNhc2UgMTE6IHZpZXcgPSBGbG9hdDY0QXJyYXk7IGJyZWFrO1xuICBjYXNlIDEyOiB2aWV3ID0gVWludDhBcnJheTsgYnJlYWs7XG4gIH1cbiAgaWYgKCF2aWV3KSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5jcmVhdGU6IHVuc3VwcG9ydGVkIGtpbmRcIik7XG4gIHZhciBkYXRhID0gbmV3IHZpZXcoc2l6ZSAqIGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnQoa2luZCkpO1xuICByZXR1cm4gZGF0YTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9jdXN0b21fbmFtZVxuLy9WZXJzaW9uOiA8IDQuMTFcbnZhciBjYW1sX2JhX2N1c3RvbV9uYW1lID0gXCJfYmlnYXJyYXlcIlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2N1c3RvbV9uYW1lXG4vL1ZlcnNpb246ID49IDQuMTFcbnZhciBjYW1sX2JhX2N1c3RvbV9uYW1lID0gXCJfYmlnYXJyMDJcIlxuXG4vL1Byb3ZpZGVzOiBNbF9CaWdhcnJheVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvciwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2JhX2N1c3RvbV9uYW1lXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2NyZWF0ZV9sb19oaSwgY2FtbF9pbnQ2NF9oaTMyLCBjYW1sX2ludDY0X2xvMzJcbmZ1bmN0aW9uIE1sX0JpZ2FycmF5IChraW5kLCBsYXlvdXQsIGRpbXMsIGJ1ZmZlcikge1xuXG4gIHRoaXMua2luZCAgID0ga2luZCA7XG4gIHRoaXMubGF5b3V0ID0gbGF5b3V0O1xuICB0aGlzLmRpbXMgICA9IGRpbXM7XG4gIHRoaXMuZGF0YSA9IGJ1ZmZlcjtcbn1cblxuTWxfQmlnYXJyYXkucHJvdG90eXBlLmNhbWxfY3VzdG9tID0gY2FtbF9iYV9jdXN0b21fbmFtZTtcblxuTWxfQmlnYXJyYXkucHJvdG90eXBlLm9mZnNldCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgdmFyIG9mcyA9IDA7XG4gIGlmKHR5cGVvZiBhcmcgPT09IFwibnVtYmVyXCIpIGFyZyA9IFthcmddO1xuICBpZiAoISAoYXJnIGluc3RhbmNlb2YgQXJyYXkpKSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJiaWdhcnJheS5qczogaW52YWxpZCBvZmZzZXRcIik7XG4gIGlmICh0aGlzLmRpbXMubGVuZ3RoICE9IGFyZy5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuZ2V0L3NldDogYmFkIG51bWJlciBvZiBkaW1lbnNpb25zXCIpO1xuICBpZih0aGlzLmxheW91dCA9PSAwIC8qIGNfbGF5b3V0ICovKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRpbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhcmdbaV0gPCAwIHx8IGFyZ1tpXSA+PSB0aGlzLmRpbXNbaV0pXG4gICAgICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgICAgIG9mcyA9IChvZnMgKiB0aGlzLmRpbXNbaV0pICsgYXJnW2ldO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5kaW1zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpZiAoYXJnW2ldIDwgMSB8fCBhcmdbaV0gPiB0aGlzLmRpbXNbaV0pe1xuICAgICAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gICAgICB9XG4gICAgICBvZnMgPSAob2ZzICogdGhpcy5kaW1zW2ldKSArIChhcmdbaV0gLSAxKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9mcztcbn1cblxuTWxfQmlnYXJyYXkucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChvZnMpIHtcbiAgc3dpdGNoKHRoaXMua2luZCl7XG4gIGNhc2UgNzpcbiAgICAvLyBJbnQ2NFxuICAgIHZhciBsID0gdGhpcy5kYXRhW29mcyAqIDIgKyAwXTtcbiAgICB2YXIgaCA9IHRoaXMuZGF0YVtvZnMgKiAyICsgMV07XG4gICAgcmV0dXJuIGNhbWxfaW50NjRfY3JlYXRlX2xvX2hpKGwsaCk7XG4gIGNhc2UgMTA6IGNhc2UgMTE6XG4gICAgLy8gQ29tcGxleDMyLCBDb21wbGV4NjRcbiAgICB2YXIgciA9IHRoaXMuZGF0YVtvZnMgKiAyICsgMF07XG4gICAgdmFyIGkgPSB0aGlzLmRhdGFbb2ZzICogMiArIDFdO1xuICAgIHJldHVybiBbMjU0LCByLCBpXTtcbiAgZGVmYXVsdDpcbiAgICByZXR1cm4gdGhpcy5kYXRhW29mc11cbiAgfVxufVxuXG5NbF9CaWdhcnJheS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKG9mcyx2KSB7XG4gIHN3aXRjaCh0aGlzLmtpbmQpe1xuICBjYXNlIDc6XG4gICAgLy8gSW50NjRcbiAgICB0aGlzLmRhdGFbb2ZzICogMiArIDBdID0gY2FtbF9pbnQ2NF9sbzMyKHYpO1xuICAgIHRoaXMuZGF0YVtvZnMgKiAyICsgMV0gPSBjYW1sX2ludDY0X2hpMzIodik7XG4gICAgYnJlYWs7XG4gIGNhc2UgMTA6IGNhc2UgMTE6XG4gICAgLy8gQ29tcGxleDMyLCBDb21wbGV4NjRcbiAgICB0aGlzLmRhdGFbb2ZzICogMiArIDBdID0gdlsxXTtcbiAgICB0aGlzLmRhdGFbb2ZzICogMiArIDFdID0gdlsyXTtcbiAgICBicmVhaztcbiAgZGVmYXVsdDpcbiAgICB0aGlzLmRhdGFbb2ZzXSA9IHY7XG4gICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIDBcbn1cblxuXG5NbF9CaWdhcnJheS5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uICh2KSB7XG4gIHN3aXRjaCh0aGlzLmtpbmQpe1xuICBjYXNlIDc6XG4gICAgLy8gSW50NjRcbiAgICB2YXIgYSA9IGNhbWxfaW50NjRfbG8zMih2KTtcbiAgICB2YXIgYiA9IGNhbWxfaW50NjRfaGkzMih2KTtcbiAgICBpZihhID09IGIpe1xuICAgICAgdGhpcy5kYXRhLmZpbGwoYSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZm9yKHZhciBpID0gMDsgaTx0aGlzLmRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgICB0aGlzLmRhdGFbaV0gPSAoaSUyID09IDApID8gYSA6IGI7XG4gICAgICB9XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDEwOiBjYXNlIDExOlxuICAgIC8vIENvbXBsZXgzMiwgQ29tcGxleDY0XG4gICAgdmFyIGltID0gdlsxXTtcbiAgICB2YXIgcmUgPSB2WzJdO1xuICAgIGlmKGltID09IHJlKXtcbiAgICAgIHRoaXMuZGF0YS5maWxsKGltKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpPHRoaXMuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHRoaXMuZGF0YVtpXSA9IChpJTIgPT0gMCkgPyBpbSA6IHJlO1xuICAgICAgfVxuICAgIH1cbiAgICBicmVhaztcbiAgZGVmYXVsdDpcbiAgICB0aGlzLmRhdGEuZmlsbCh2KTtcbiAgICBicmVhaztcbiAgfVxufVxuXG5cbk1sX0JpZ2FycmF5LnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gKGIsIHRvdGFsKSB7XG4gIGlmICh0aGlzLmxheW91dCAhPSBiLmxheW91dCB8fCB0aGlzLmtpbmQgIT0gYi5raW5kKSB7XG4gICAgdmFyIGsxID0gdGhpcy5raW5kIHwgKHRoaXMubGF5b3V0IDw8IDgpO1xuICAgIHZhciBrMiA9ICAgIGIua2luZCB8IChiLmxheW91dCA8PCA4KTtcbiAgICByZXR1cm4gazIgLSBrMTtcbiAgfVxuICBpZiAodGhpcy5kaW1zLmxlbmd0aCAhPSBiLmRpbXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGIuZGltcy5sZW5ndGggLSB0aGlzLmRpbXMubGVuZ3RoO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kaW1zLmxlbmd0aDsgaSsrKVxuICAgIGlmICh0aGlzLmRpbXNbaV0gIT0gYi5kaW1zW2ldKVxuICAgICAgcmV0dXJuICh0aGlzLmRpbXNbaV0gPCBiLmRpbXNbaV0pID8gLTEgOiAxO1xuICBzd2l0Y2ggKHRoaXMua2luZCkge1xuICBjYXNlIDA6XG4gIGNhc2UgMTpcbiAgY2FzZSAxMDpcbiAgY2FzZSAxMTpcbiAgICAvLyBGbG9hdHNcbiAgICB2YXIgeCwgeTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgeCA9IHRoaXMuZGF0YVtpXTtcbiAgICAgIHkgPSBiLmRhdGFbaV07XG4gICAgICBpZiAoeCA8IHkpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIGlmICh4ID4geSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICBpZiAoeCAhPSB5KSB7XG4gICAgICAgIGlmICghdG90YWwpIHJldHVybiBOYU47XG4gICAgICAgIGlmICh4ID09IHgpIHJldHVybiAxO1xuICAgICAgICBpZiAoeSA9PSB5KSByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDc6XG4gICAgLy8gSW50NjRcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrPTIpIHtcbiAgICAgIC8vIENoZWNrIGhpZ2hlc3QgYml0cyBmaXJzdFxuICAgICAgaWYgKHRoaXMuZGF0YVtpKzFdIDwgYi5kYXRhW2krMV0pXG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIGlmICh0aGlzLmRhdGFbaSsxXSA+IGIuZGF0YVtpKzFdKVxuICAgICAgICByZXR1cm4gMTtcbiAgICAgIGlmICgodGhpcy5kYXRhW2ldID4+PiAwKSA8IChiLmRhdGFbaV0gPj4+IDApKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICBpZiAoKHRoaXMuZGF0YVtpXSA+Pj4gMCkgPiAoYi5kYXRhW2ldID4+PiAwKSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDI6XG4gIGNhc2UgMzpcbiAgY2FzZSA0OlxuICBjYXNlIDU6XG4gIGNhc2UgNjpcbiAgY2FzZSA4OlxuICBjYXNlIDk6XG4gIGNhc2UgMTI6XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLmRhdGFbaV0gPCBiLmRhdGFbaV0pXG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIGlmICh0aGlzLmRhdGFbaV0gPiBiLmRhdGFbaV0pXG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBicmVhaztcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogTWxfQmlnYXJyYXlfY18xXzFcbi8vUmVxdWlyZXM6IE1sX0JpZ2FycmF5LCBjYW1sX2FycmF5X2JvdW5kX2Vycm9yLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIE1sX0JpZ2FycmF5X2NfMV8xKGtpbmQsIGxheW91dCwgZGltcywgYnVmZmVyKSB7XG4gIHRoaXMua2luZCAgID0ga2luZCA7XG4gIHRoaXMubGF5b3V0ID0gbGF5b3V0O1xuICB0aGlzLmRpbXMgICA9IGRpbXM7XG4gIHRoaXMuZGF0YSAgID0gYnVmZmVyO1xufVxuXG5NbF9CaWdhcnJheV9jXzFfMS5wcm90b3R5cGUgPSBuZXcgTWxfQmlnYXJyYXkoKVxuTWxfQmlnYXJyYXlfY18xXzEucHJvdG90eXBlLm9mZnNldCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgaWYodHlwZW9mIGFyZyAhPT0gXCJudW1iZXJcIil7XG4gICAgaWYoKGFyZyBpbnN0YW5jZW9mIEFycmF5KSAmJiBhcmcubGVuZ3RoID09IDEpXG4gICAgICBhcmcgPSBhcmdbMF07XG4gICAgZWxzZSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJNbF9CaWdhcnJheV9jXzFfMS5vZmZzZXRcIik7XG4gIH1cbiAgaWYgKGFyZyA8IDAgfHwgYXJnID49IHRoaXMuZGltc1swXSlcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBhcmc7XG59XG5cbk1sX0JpZ2FycmF5X2NfMV8xLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAob2ZzKSB7XG4gIHJldHVybiB0aGlzLmRhdGFbb2ZzXTtcbn1cblxuTWxfQmlnYXJyYXlfY18xXzEucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChvZnMsdikge1xuICB0aGlzLmRhdGFbb2ZzXSA9IHY7XG4gIHJldHVybiAwXG59XG5cbk1sX0JpZ2FycmF5X2NfMV8xLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gKHYpIHtcbiAgdGhpcy5kYXRhLmZpbGwodik7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY29tcGFyZVxuZnVuY3Rpb24gY2FtbF9iYV9jb21wYXJlKGEsYix0b3RhbCl7XG4gIHJldHVybiBhLmNvbXBhcmUoYix0b3RhbClcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9jcmVhdGVfdW5zYWZlXG4vL1JlcXVpcmVzOiBNbF9CaWdhcnJheSwgTWxfQmlnYXJyYXlfY18xXzEsIGNhbWxfYmFfZ2V0X3NpemUsIGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnRcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGtpbmQsIGxheW91dCwgZGltcywgZGF0YSl7XG4gIHZhciBzaXplX3Blcl9lbGVtZW50ID0gY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudChraW5kKTtcbiAgaWYoY2FtbF9iYV9nZXRfc2l6ZShkaW1zKSAqIHNpemVfcGVyX2VsZW1lbnQgIT0gZGF0YS5sZW5ndGgpIHtcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJsZW5ndGggZG9lc24ndCBtYXRjaCBkaW1zXCIpO1xuICB9XG4gIGlmKGxheW91dCA9PSAwICYmIC8vIGNfbGF5b3V0XG4gICAgIGRpbXMubGVuZ3RoID09IDEgJiYgLy8gQXJyYXkxXG4gICAgIHNpemVfcGVyX2VsZW1lbnQgPT0gMSkgLy8gMS10by0xIG1hcHBpbmdcbiAgICByZXR1cm4gbmV3IE1sX0JpZ2FycmF5X2NfMV8xKGtpbmQsIGxheW91dCwgZGltcywgZGF0YSk7XG4gIHJldHVybiBuZXcgTWxfQmlnYXJyYXkoa2luZCwgbGF5b3V0LCBkaW1zLCBkYXRhKTtcblxufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY3JlYXRlXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0X3NpemUsIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfYnVmZmVyXG5mdW5jdGlvbiBjYW1sX2JhX2NyZWF0ZShraW5kLCBsYXlvdXQsIGRpbXNfbWwpIHtcbiAgdmFyIGRpbXMgPSBjYW1sX2pzX2Zyb21fYXJyYXkoZGltc19tbCk7XG4gIHZhciBkYXRhID0gY2FtbF9iYV9jcmVhdGVfYnVmZmVyKGtpbmQsIGNhbWxfYmFfZ2V0X3NpemUoZGltcykpO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGtpbmQsIGxheW91dCwgZGltcywgZGF0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY2hhbmdlX2xheW91dFxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfdW5zYWZlXG5mdW5jdGlvbiBjYW1sX2JhX2NoYW5nZV9sYXlvdXQoYmEsIGxheW91dCkge1xuICBpZihiYS5sYXlvdXQgPT0gbGF5b3V0KSByZXR1cm4gYmE7XG4gIHZhciBuZXdfZGltcyA9IFtdXG4gIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kaW1zLmxlbmd0aDsgaSsrKSBuZXdfZGltc1tpXSA9IGJhLmRpbXNbYmEuZGltcy5sZW5ndGggLSBpIC0gMV07XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoYmEua2luZCwgbGF5b3V0LCBuZXdfZGltcywgYmEuZGF0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfa2luZFxuZnVuY3Rpb24gY2FtbF9iYV9raW5kKGJhKSB7XG4gIHJldHVybiBiYS5raW5kO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2xheW91dFxuZnVuY3Rpb24gY2FtbF9iYV9sYXlvdXQoYmEpIHtcbiAgcmV0dXJuIGJhLmxheW91dDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9udW1fZGltc1xuZnVuY3Rpb24gY2FtbF9iYV9udW1fZGltcyhiYSkge1xuICByZXR1cm4gYmEuZGltcy5sZW5ndGg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZGltXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfZGltKGJhLCBpKSB7XG4gIGlmIChpIDwgMCB8fCBpID49IGJhLmRpbXMubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LmRpbVwiKTtcbiAgcmV0dXJuIGJhLmRpbXNbaV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZGltXzFcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZGltXG5mdW5jdGlvbiBjYW1sX2JhX2RpbV8xKGJhKSB7XG4gIHJldHVybiBjYW1sX2JhX2RpbShiYSwgMCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZGltXzJcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZGltXG5mdW5jdGlvbiBjYW1sX2JhX2RpbV8yKGJhKSB7XG4gIHJldHVybiBjYW1sX2JhX2RpbShiYSwgMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZGltXzNcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZGltXG5mdW5jdGlvbiBjYW1sX2JhX2RpbV8zKGJhKSB7XG4gIHJldHVybiBjYW1sX2JhX2RpbShiYSwgMik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0X2dlbmVyaWNcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9iYV9nZXRfZ2VuZXJpYyhiYSwgaSkge1xuICB2YXIgb2ZzID0gYmEub2Zmc2V0KGNhbWxfanNfZnJvbV9hcnJheShpKSk7XG4gIHJldHVybiBiYS5nZXQob2ZzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV91aW50OF9nZXQxNlxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9iYV91aW50OF9nZXQxNihiYSwgaTApIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChpMCk7XG4gIGlmKG9mcyArIDEgPj0gYmEuZGF0YS5sZW5ndGgpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gYmEuZ2V0KG9mcyk7XG4gIHZhciBiMiA9IGJhLmdldChvZnMgKyAxKTtcbiAgcmV0dXJuIChiMSB8IChiMiA8PCA4KSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdWludDhfZ2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYmFfdWludDhfZ2V0MzIoYmEsIGkwKSB7XG4gIHZhciBvZnMgPSBiYS5vZmZzZXQoaTApO1xuICBpZihvZnMgKyAzID49IGJhLmRhdGEubGVuZ3RoKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGJhLmdldChvZnMrMCk7XG4gIHZhciBiMiA9IGJhLmdldChvZnMrMSk7XG4gIHZhciBiMyA9IGJhLmdldChvZnMrMik7XG4gIHZhciBiNCA9IGJhLmdldChvZnMrMyk7XG4gIHJldHVybiAoIChiMSA8PCAwKSAgfFxuICAgICAgICAgICAoYjIgPDwgOCkgIHxcbiAgICAgICAgICAgKGIzIDw8IDE2KSB8XG4gICAgICAgICAgIChiNCA8PCAyNCkgKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV91aW50OF9nZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvciwgY2FtbF9pbnQ2NF9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9iYV91aW50OF9nZXQ2NChiYSwgaTApIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChpMCk7XG4gIGlmKG9mcyArIDcgPj0gYmEuZGF0YS5sZW5ndGgpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gYmEuZ2V0KG9mcyswKTtcbiAgdmFyIGIyID0gYmEuZ2V0KG9mcysxKTtcbiAgdmFyIGIzID0gYmEuZ2V0KG9mcysyKTtcbiAgdmFyIGI0ID0gYmEuZ2V0KG9mcyszKTtcbiAgdmFyIGI1ID0gYmEuZ2V0KG9mcys0KTtcbiAgdmFyIGI2ID0gYmEuZ2V0KG9mcys1KTtcbiAgdmFyIGI3ID0gYmEuZ2V0KG9mcys2KTtcbiAgdmFyIGI4ID0gYmEuZ2V0KG9mcys3KTtcbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfYnl0ZXMoW2I4LGI3LGI2LGI1LGI0LGIzLGIyLGIxXSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0XzFcbmZ1bmN0aW9uIGNhbWxfYmFfZ2V0XzEoYmEsIGkwKSB7XG4gIHJldHVybiBiYS5nZXQoYmEub2Zmc2V0KGkwKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0XzJcbmZ1bmN0aW9uIGNhbWxfYmFfZ2V0XzIoYmEsIGkwLCBpMSkge1xuICByZXR1cm4gYmEuZ2V0KGJhLm9mZnNldChbaTAsaTFdKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0XzNcbmZ1bmN0aW9uIGNhbWxfYmFfZ2V0XzMoYmEsIGkwLCBpMSwgaTIpIHtcbiAgcmV0dXJuIGJhLmdldChiYS5vZmZzZXQoW2kwLGkxLGkyXSkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NldF9nZW5lcmljXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfYmFfc2V0X2dlbmVyaWMoYmEsIGksIHYpIHtcbiAgYmEuc2V0KGJhLm9mZnNldChjYW1sX2pzX2Zyb21fYXJyYXkoaSkpLCB2KTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV91aW50OF9zZXQxNlxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9iYV91aW50OF9zZXQxNihiYSwgaTAsIHYpIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChpMCk7XG4gIGlmKG9mcyArIDEgPj0gYmEuZGF0YS5sZW5ndGgpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgYmEuc2V0KG9mcyswLCAgdiAgICAgICAgJiAweGZmKTtcbiAgYmEuc2V0KG9mcysxLCAodiA+Pj4gOCkgJiAweGZmKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdWludDhfc2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYmFfdWludDhfc2V0MzIoYmEsIGkwLCB2KSB7XG4gIHZhciBvZnMgPSBiYS5vZmZzZXQoaTApO1xuICBpZihvZnMgKyAzID49IGJhLmRhdGEubGVuZ3RoKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIGJhLnNldChvZnMrMCwgIHYgICAgICAgICAmIDB4ZmYpO1xuICBiYS5zZXQob2ZzKzEsICh2ID4+PiA4KSAgJiAweGZmKTtcbiAgYmEuc2V0KG9mcysyLCAodiA+Pj4gMTYpICYgMHhmZik7XG4gIGJhLnNldChvZnMrMywgKHYgPj4+IDI0KSAmIDB4ZmYpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV91aW50OF9zZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvciwgY2FtbF9pbnQ2NF90b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9iYV91aW50OF9zZXQ2NChiYSwgaTAsIHYpIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChpMCk7XG4gIGlmKG9mcyArIDcgPj0gYmEuZGF0YS5sZW5ndGgpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIHYgPSBjYW1sX2ludDY0X3RvX2J5dGVzKHYpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgODsgaSsrKSBiYS5zZXQob2ZzK2ksIHZbNy1pXSlcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc2V0XzFcbmZ1bmN0aW9uIGNhbWxfYmFfc2V0XzEoYmEsIGkwLCB2KSB7XG4gIGJhLnNldChiYS5vZmZzZXQoaTApLCB2KTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zZXRfMlxuZnVuY3Rpb24gY2FtbF9iYV9zZXRfMihiYSwgaTAsIGkxLCB2KSB7XG4gIGJhLnNldChiYS5vZmZzZXQoW2kwLGkxXSksIHYpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zZXRfM1xuZnVuY3Rpb24gY2FtbF9iYV9zZXRfMyhiYSwgaTAsIGkxLCBpMiwgdikge1xuICBiYS5zZXQoYmEub2Zmc2V0KFtpMCxpMSxpMl0pLCB2KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZmlsbFxuZnVuY3Rpb24gY2FtbF9iYV9maWxsKGJhLCB2KSB7XG4gIGJhLmZpbGwodik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2JsaXRcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9iYV9ibGl0KHNyYywgZHN0KSB7XG4gIGlmIChkc3QuZGltcy5sZW5ndGggIT0gc3JjLmRpbXMubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LmJsaXQ6IGRpbWVuc2lvbiBtaXNtYXRjaFwiKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkc3QuZGltcy5sZW5ndGg7IGkrKylcbiAgICBpZiAoZHN0LmRpbXNbaV0gIT0gc3JjLmRpbXNbaV0pXG4gICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5ibGl0OiBkaW1lbnNpb24gbWlzbWF0Y2hcIik7XG4gIGRzdC5kYXRhLnNldChzcmMuZGF0YSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3N1YlxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2JhX2NyZWF0ZV91bnNhZmUsIGNhbWxfYmFfZ2V0X3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfc3ViKGJhLCBvZnMsIGxlbikge1xuICB2YXIgY2hhbmdlZF9kaW07XG4gIHZhciBtdWwgPSAxO1xuICBpZiAoYmEubGF5b3V0ID09IDApIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGJhLmRpbXMubGVuZ3RoOyBpKyspXG4gICAgICBtdWwgPSBtdWwgKiBiYS5kaW1zW2ldO1xuICAgIGNoYW5nZWRfZGltID0gMDtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IChiYS5kaW1zLmxlbmd0aCAtIDEpOyBpKyspXG4gICAgICBtdWwgPSBtdWwgKiBiYS5kaW1zW2ldO1xuICAgIGNoYW5nZWRfZGltID0gYmEuZGltcy5sZW5ndGggLSAxO1xuICAgIG9mcyA9IG9mcyAtIDE7XG4gIH1cbiAgaWYgKG9mcyA8IDAgfHwgbGVuIDwgMCB8fCAob2ZzICsgbGVuKSA+IGJhLmRpbXNbY2hhbmdlZF9kaW1dKXtcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5zdWI6IGJhZCBzdWItYXJyYXlcIik7XG4gIH1cbiAgdmFyIG5ld19kaW1zID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYmEuZGltcy5sZW5ndGg7IGkrKylcbiAgICBuZXdfZGltc1tpXSA9IGJhLmRpbXNbaV07XG4gIG5ld19kaW1zW2NoYW5nZWRfZGltXSA9IGxlbjtcbiAgbXVsICo9IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnQoYmEua2luZCk7XG4gIHZhciBuZXdfZGF0YSA9IGJhLmRhdGEuc3ViYXJyYXkob2ZzICogbXVsLCAob2ZzICsgbGVuKSAqIG11bCk7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoYmEua2luZCwgYmEubGF5b3V0LCBuZXdfZGltcywgbmV3X2RhdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NsaWNlXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXksIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2JhX2dldF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50XG5mdW5jdGlvbiBjYW1sX2JhX3NsaWNlKGJhLCB2aW5kKSB7XG4gIHZpbmQgPSBjYW1sX2pzX2Zyb21fYXJyYXkodmluZCk7XG4gIHZhciBudW1faW5kcyA9IHZpbmQubGVuZ3RoO1xuICB2YXIgaW5kZXggPSBbXTtcbiAgdmFyIHN1Yl9kaW1zID0gW107XG4gIHZhciBvZnM7XG5cbiAgaWYgKG51bV9pbmRzID4gYmEuZGltcy5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuc2xpY2U6IHRvbyBtYW55IGluZGljZXNcIik7XG5cbiAgLy8gQ29tcHV0ZSBvZmZzZXQgYW5kIGNoZWNrIGJvdW5kc1xuICBpZiAoYmEubGF5b3V0ID09IDApIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9pbmRzOyBpKyspXG4gICAgICBpbmRleFtpXSA9IHZpbmRbaV07XG4gICAgZm9yICg7IGkgPCBiYS5kaW1zLmxlbmd0aDsgaSsrKVxuICAgICAgaW5kZXhbaV0gPSAwO1xuICAgIHN1Yl9kaW1zID0gYmEuZGltcy5zbGljZShudW1faW5kcyk7XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1faW5kczsgaSsrKVxuICAgICAgaW5kZXhbYmEuZGltcy5sZW5ndGggLSBudW1faW5kcyArIGldID0gdmluZFtpXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhLmRpbXMubGVuZ3RoIC0gbnVtX2luZHM7IGkrKylcbiAgICAgIGluZGV4W2ldID0gMTtcbiAgICBzdWJfZGltcyA9IGJhLmRpbXMuc2xpY2UoMCwgYmEuZGltcy5sZW5ndGggLSBudW1faW5kcyk7XG4gIH1cbiAgb2ZzID0gYmEub2Zmc2V0KGluZGV4KTtcbiAgdmFyIHNpemUgPSBjYW1sX2JhX2dldF9zaXplKHN1Yl9kaW1zKTtcbiAgdmFyIHNpemVfcGVyX2VsZW1lbnQgPSBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50KGJhLmtpbmQpO1xuICB2YXIgbmV3X2RhdGEgPSBiYS5kYXRhLnN1YmFycmF5KG9mcyAqIHNpemVfcGVyX2VsZW1lbnQsIChvZnMgKyBzaXplKSAqIHNpemVfcGVyX2VsZW1lbnQpO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGJhLmtpbmQsIGJhLmxheW91dCwgc3ViX2RpbXMsIG5ld19kYXRhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9yZXNoYXBlXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXksIGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9iYV9jcmVhdGVfdW5zYWZlLCBjYW1sX2JhX2dldF9zaXplXG5mdW5jdGlvbiBjYW1sX2JhX3Jlc2hhcGUoYmEsIHZpbmQpIHtcbiAgdmluZCA9IGNhbWxfanNfZnJvbV9hcnJheSh2aW5kKTtcbiAgdmFyIG5ld19kaW0gPSBbXTtcbiAgdmFyIG51bV9kaW1zID0gdmluZC5sZW5ndGg7XG5cbiAgaWYgKG51bV9kaW1zIDwgMCB8fCBudW1fZGltcyA+IDE2KXtcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5yZXNoYXBlOiBiYWQgbnVtYmVyIG9mIGRpbWVuc2lvbnNcIik7XG4gIH1cbiAgdmFyIG51bV9lbHRzID0gMTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZGltczsgaSsrKSB7XG4gICAgbmV3X2RpbVtpXSA9IHZpbmRbaV07XG4gICAgaWYgKG5ld19kaW1baV0gPCAwKVxuICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkucmVzaGFwZTogbmVnYXRpdmUgZGltZW5zaW9uXCIpO1xuICAgIG51bV9lbHRzID0gbnVtX2VsdHMgKiBuZXdfZGltW2ldO1xuICB9XG5cbiAgdmFyIHNpemUgPSBjYW1sX2JhX2dldF9zaXplKGJhLmRpbXMpO1xuICAvLyBDaGVjayB0aGF0IHNpemVzIGFncmVlXG4gIGlmIChudW1fZWx0cyAhPSBzaXplKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LnJlc2hhcGU6IHNpemUgbWlzbWF0Y2hcIik7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoYmEua2luZCwgYmEubGF5b3V0LCBuZXdfZGltLCBiYS5kYXRhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zZXJpYWxpemVcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCwgY2FtbF9pbnQ2NF90b19ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0XG5mdW5jdGlvbiBjYW1sX2JhX3NlcmlhbGl6ZSh3cml0ZXIsIGJhLCBzeikge1xuICB3cml0ZXIud3JpdGUoMzIsIGJhLmRpbXMubGVuZ3RoKTtcbiAgd3JpdGVyLndyaXRlKDMyLCAoYmEua2luZCB8IChiYS5sYXlvdXQgPDwgOCkpKTtcbiAgaWYoYmEuY2FtbF9jdXN0b20gPT0gXCJfYmlnYXJyMDJcIilcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGltcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYoYmEuZGltc1tpXSA8IDB4ZmZmZilcbiAgICAgICAgd3JpdGVyLndyaXRlKDE2LCBiYS5kaW1zW2ldKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICB3cml0ZXIud3JpdGUoMTYsIDB4ZmZmZik7XG4gICAgICAgIHdyaXRlci53cml0ZSgzMiwgMCk7XG4gICAgICAgIHdyaXRlci53cml0ZSgzMiwgYmEuZGltc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICBlbHNlXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRpbXMubGVuZ3RoOyBpKyspIHdyaXRlci53cml0ZSgzMixiYS5kaW1zW2ldKVxuICBzd2l0Y2goYmEua2luZCl7XG4gIGNhc2UgMjogIC8vSW50OEFycmF5XG4gIGNhc2UgMzogIC8vVWludDhBcnJheVxuICBjYXNlIDEyOiAvL1VpbnQ4QXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICB3cml0ZXIud3JpdGUoOCwgYmEuZGF0YVtpXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDQ6ICAvLyBJbnQxNkFycmF5XG4gIGNhc2UgNTogIC8vIFVpbnQxNkFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgd3JpdGVyLndyaXRlKDE2LCBiYS5kYXRhW2ldKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNjogIC8vIEludDMyQXJyYXkgKGludDMyKVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgIHdyaXRlci53cml0ZSgzMiwgYmEuZGF0YVtpXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDg6ICAvLyBJbnQzMkFycmF5IChpbnQpXG4gIGNhc2UgOTogIC8vIEludDMyQXJyYXkgKG5hdGl2ZWludClcbiAgICB3cml0ZXIud3JpdGUoOCwwKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICB3cml0ZXIud3JpdGUoMzIsIGJhLmRhdGFbaV0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA3OiAgLy8gSW50MzJBcnJheSAoaW50NjQpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoIC8gMjsgaSsrKXtcbiAgICAgIHZhciBiID0gY2FtbF9pbnQ2NF90b19ieXRlcyhiYS5nZXQoaSkpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA4OyBqKyspIHdyaXRlci53cml0ZSAoOCwgYltqXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDE6ICAvLyBGbG9hdDY0QXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICB2YXIgYiA9IGNhbWxfaW50NjRfdG9fYnl0ZXMoY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0KGJhLmdldChpKSkpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA4OyBqKyspIHdyaXRlci53cml0ZSAoOCwgYltqXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDA6ICAvLyBGbG9hdDMyQXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICB2YXIgYiA9IGNhbWxfaW50MzJfYml0c19vZl9mbG9hdChiYS5nZXQoaSkpO1xuICAgICAgd3JpdGVyLndyaXRlKDMyLCBiKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTA6IC8vIEZsb2F0MzJBcnJheSAoY29tcGxleDMyKVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aCAvIDI7IGkrKyl7XG4gICAgICB2YXIgaiA9IGJhLmdldChpKTtcbiAgICAgIHdyaXRlci53cml0ZSgzMiwgY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0KGpbMV0pKTtcbiAgICAgIHdyaXRlci53cml0ZSgzMiwgY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0KGpbMl0pKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTE6IC8vIEZsb2F0NjRBcnJheSAoY29tcGxleDY0KVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aCAvIDI7IGkrKyl7XG4gICAgICB2YXIgY29tcGxleCA9IGJhLmdldChpKTtcbiAgICAgIHZhciBiID0gY2FtbF9pbnQ2NF90b19ieXRlcyhjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQoY29tcGxleFsxXSkpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA4OyBqKyspIHdyaXRlci53cml0ZSAoOCwgYltqXSk7XG4gICAgICB2YXIgYiA9IGNhbWxfaW50NjRfdG9fYnl0ZXMoY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0KGNvbXBsZXhbMl0pKTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgODsgaisrKSB3cml0ZXIud3JpdGUgKDgsIGJbal0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgfVxuICBzelswXSA9ICg0ICsgYmEuZGltcy5sZW5ndGgpICogNDtcbiAgc3pbMV0gPSAoNCArIGJhLmRpbXMubGVuZ3RoKSAqIDg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZGVzZXJpYWxpemVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSwgY2FtbF9mYWlsd2l0aFxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfc2l6ZVxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9ieXRlcywgY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzXG4vL1JlcXVpcmVzOiBjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHNcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX2J1ZmZlclxuZnVuY3Rpb24gY2FtbF9iYV9kZXNlcmlhbGl6ZShyZWFkZXIsIHN6LCBuYW1lKXtcbiAgdmFyIG51bV9kaW1zID0gcmVhZGVyLnJlYWQzMnMoKTtcbiAgaWYgKG51bV9kaW1zIDwgMCB8fCBudW1fZGltcyA+IDE2KVxuICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogd3JvbmcgbnVtYmVyIG9mIGJpZ2FycmF5IGRpbWVuc2lvbnNcIik7XG4gIHZhciB0YWcgPSByZWFkZXIucmVhZDMycygpO1xuICB2YXIga2luZCA9IHRhZyAmIDB4ZmZcbiAgdmFyIGxheW91dCA9ICh0YWcgPj4gOCkgJiAxO1xuICB2YXIgZGltcyA9IFtdXG4gIGlmKG5hbWUgPT0gXCJfYmlnYXJyMDJcIilcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9kaW1zOyBpKyspIHtcbiAgICAgIHZhciBzaXplX2RpbSA9IHJlYWRlci5yZWFkMTZ1KCk7XG4gICAgICBpZihzaXplX2RpbSA9PSAweGZmZmYpe1xuICAgICAgICB2YXIgc2l6ZV9kaW1faGkgPSByZWFkZXIucmVhZDMydSgpO1xuICAgICAgICB2YXIgc2l6ZV9kaW1fbG8gPSByZWFkZXIucmVhZDMydSgpO1xuICAgICAgICBpZihzaXplX2RpbV9oaSAhPSAwKVxuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogYmlnYXJyYXkgZGltZW5zaW9uIG92ZXJmbG93IGluIDMyYml0XCIpO1xuICAgICAgICBzaXplX2RpbSA9IHNpemVfZGltX2xvO1xuICAgICAgfVxuICAgICAgZGltcy5wdXNoKHNpemVfZGltKTtcbiAgICB9XG4gIGVsc2VcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9kaW1zOyBpKyspIGRpbXMucHVzaChyZWFkZXIucmVhZDMydSgpKTtcbiAgdmFyIHNpemUgPSBjYW1sX2JhX2dldF9zaXplKGRpbXMpO1xuICB2YXIgZGF0YSA9IGNhbWxfYmFfY3JlYXRlX2J1ZmZlcihraW5kLCBzaXplKTtcbiAgdmFyIGJhID0gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGtpbmQsIGxheW91dCwgZGltcywgZGF0YSk7XG4gIHN3aXRjaChraW5kKXtcbiAgY2FzZSAyOiAgLy9JbnQ4QXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGRhdGFbaV0gPSByZWFkZXIucmVhZDhzKCk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDM6ICAvL1VpbnQ4QXJyYXlcbiAgY2FzZSAxMjogLy9VaW50OEFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBkYXRhW2ldID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA0OiAgLy8gSW50MTZBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZGF0YVtpXSA9IHJlYWRlci5yZWFkMTZzKCk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDU6ICAvLyBVaW50MTZBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZGF0YVtpXSA9IHJlYWRlci5yZWFkMTZ1KCk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDY6ICAvLyBJbnQzMkFycmF5IChpbnQzMilcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGRhdGFbaV0gPSByZWFkZXIucmVhZDMycygpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA4OiAgLy8gSW50MzJBcnJheSAoaW50KVxuICBjYXNlIDk6ICAvLyBJbnQzMkFycmF5IChuYXRpdmVpbnQpXG4gICAgdmFyIHNpeHR5ID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgIGlmKHNpeHR5KSBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IGNhbm5vdCByZWFkIGJpZ2FycmF5IHdpdGggNjQtYml0IE9DYW1sIGludHNcIik7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBkYXRhW2ldID0gcmVhZGVyLnJlYWQzMnMoKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNzogLy8gKGludDY0KVxuICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgIHZhciBpbnQ2NCA9IGNhbWxfaW50NjRfb2ZfYnl0ZXModCk7XG4gICAgICBiYS5zZXQoaSxpbnQ2NCk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDE6ICAvLyBGbG9hdDY0QXJyYXlcbiAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICB2YXIgZiA9IGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyhjYW1sX2ludDY0X29mX2J5dGVzKHQpKTtcbiAgICAgIGJhLnNldChpLGYpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAwOiAgLy8gRmxvYXQzMkFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICB2YXIgZiA9IGNhbWxfaW50MzJfZmxvYXRfb2ZfYml0cyhyZWFkZXIucmVhZDMycygpKTtcbiAgICAgIGJhLnNldChpLGYpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxMDogLy8gRmxvYXQzMkFycmF5IChjb21wbGV4MzIpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICB2YXIgcmUgPSBjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHMocmVhZGVyLnJlYWQzMnMoKSk7XG4gICAgICB2YXIgaW0gPSBjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHMocmVhZGVyLnJlYWQzMnMoKSk7XG4gICAgICBiYS5zZXQoaSxbMjU0LHJlLGltXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDExOiAvLyBGbG9hdDY0QXJyYXkgKGNvbXBsZXg2NClcbiAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICB2YXIgcmUgPSBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMoY2FtbF9pbnQ2NF9vZl9ieXRlcyh0KSk7XG4gICAgICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICB2YXIgaW0gPSBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMoY2FtbF9pbnQ2NF9vZl9ieXRlcyh0KSk7XG4gICAgICBiYS5zZXQoaSxbMjU0LHJlLGltXSk7XG4gICAgfVxuICAgIGJyZWFrXG4gIH1cbiAgc3pbMF0gPSAoNCArIG51bV9kaW1zKSAqIDQ7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoa2luZCwgbGF5b3V0LCBkaW1zLCBkYXRhKTtcbn1cblxuLy9EZXByZWNhdGVkXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2NyZWF0ZV9mcm9tXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUsIGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudFxuZnVuY3Rpb24gY2FtbF9iYV9jcmVhdGVfZnJvbShkYXRhMSwgZGF0YTIsIGpzdHlwLCBraW5kLCBsYXlvdXQsIGRpbXMpe1xuICBpZihkYXRhMiB8fCBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50KGtpbmQpID09IDIpe1xuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmFfY3JlYXRlX2Zyb206IHVzZSByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlXCIpO1xuICB9XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoa2luZCwgbGF5b3V0LCBkaW1zLCBkYXRhMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfaGFzaCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfc2l6ZSwgY2FtbF9oYXNoX21peF9pbnQsIGNhbWxfaGFzaF9taXhfZmxvYXRcbmZ1bmN0aW9uIGNhbWxfYmFfaGFzaChiYSl7XG4gIHZhciBudW1fZWx0cyA9IGNhbWxfYmFfZ2V0X3NpemUoYmEuZGltcyk7XG4gIHZhciBoID0gMDtcbiAgc3dpdGNoKGJhLmtpbmQpe1xuICBjYXNlIDI6ICAvL0ludDhBcnJheVxuICBjYXNlIDM6ICAvL1VpbnQ4QXJyYXlcbiAgY2FzZSAxMjogLy9VaW50OEFycmF5XG4gICAgaWYobnVtX2VsdHMgPiAyNTYpIG51bV9lbHRzID0gMjU2O1xuICAgIHZhciB3ID0gMCwgaSA9MDtcbiAgICBmb3IoaSA9IDA7IGkgKyA0IDw9IGJhLmRhdGEubGVuZ3RoOyBpKz00KXtcbiAgICAgIHcgPSBiYS5kYXRhW2krMF0gfCAoYmEuZGF0YVtpKzFdIDw8IDgpIHwgKGJhLmRhdGFbaSsyXSA8PCAxNikgfCAoYmEuZGF0YVtpKzNdIDw8IDI0KTtcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLHcpO1xuICAgIH1cbiAgICB3ID0gMDtcbiAgICBzd2l0Y2ggKG51bV9lbHRzICYgMykge1xuICAgIGNhc2UgMzogdyAgPSBiYS5kYXRhW2krMl0gPDwgMTY7ICAgIC8qIGZhbGx0aHJvdWdoICovXG4gICAgY2FzZSAyOiB3IHw9IGJhLmRhdGFbaSsxXSA8PCA4OyAgICAgLyogZmFsbHRocm91Z2ggKi9cbiAgICBjYXNlIDE6IHcgfD0gYmEuZGF0YVtpKzBdO1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHcpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA0OiAgLy8gSW50MTZBcnJheVxuICBjYXNlIDU6ICAvLyBVaW50MTZBcnJheVxuICAgIGlmKG51bV9lbHRzID4gMTI4KSBudW1fZWx0cyA9IDEyODtcbiAgICB2YXIgdyA9IDAsIGkgPTA7XG4gICAgZm9yKGkgPSAwOyBpICsgMiA8PSBiYS5kYXRhLmxlbmd0aDsgaSs9Mil7XG4gICAgICB3ID0gYmEuZGF0YVtpKzBdIHwgKGJhLmRhdGFbaSsxXSA8PCAxNik7XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCx3KTtcbiAgICB9XG4gICAgaWYgKChudW1fZWx0cyAmIDEpICE9IDApXG4gICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgYmEuZGF0YVtpXSk7XG4gICAgYnJlYWs7XG4gIGNhc2UgNjogIC8vIEludDMyQXJyYXkgKGludDMyKVxuICAgIGlmIChudW1fZWx0cyA+IDY0KSBudW1fZWx0cyA9IDY0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2VsdHM7IGkrKykgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIGJhLmRhdGFbaV0pO1xuICAgIGJyZWFrO1xuICBjYXNlIDg6ICAvLyBJbnQzMkFycmF5IChpbnQpXG4gIGNhc2UgOTogIC8vIEludDMyQXJyYXkgKG5hdGl2ZWludClcbiAgICBpZiAobnVtX2VsdHMgPiA2NCkgbnVtX2VsdHMgPSA2NDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9lbHRzOyBpKyspIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCBiYS5kYXRhW2ldKTtcbiAgICBicmVhaztcbiAgY2FzZSA3OiAgLy8gSW50MzJBcnJheSAoaW50NjQpXG4gICAgaWYgKG51bV9lbHRzID4gMzIpIG51bV9lbHRzID0gMzI7XG4gICAgbnVtX2VsdHMgKj0gMlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2VsdHM7IGkrKykge1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIGJhLmRhdGFbaV0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxMDogLy8gRmxvYXQzMkFycmF5IChjb21wbGV4MzIpXG4gICAgbnVtX2VsdHMgKj0yOyAvKiBmYWxsdGhyb3VnaCAqL1xuICBjYXNlIDA6ICAvLyBGbG9hdDMyQXJyYXlcbiAgICBpZiAobnVtX2VsdHMgPiA2NCkgbnVtX2VsdHMgPSA2NDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9lbHRzOyBpKyspIGggPSBjYW1sX2hhc2hfbWl4X2Zsb2F0KGgsIGJhLmRhdGFbaV0pO1xuICAgIGJyZWFrO1xuICBjYXNlIDExOiAvLyBGbG9hdDY0QXJyYXkgKGNvbXBsZXg2NClcbiAgICBudW1fZWx0cyAqPTI7IC8qIGZhbGx0aHJvdWdoICovXG4gIGNhc2UgMTogIC8vIEZsb2F0NjRBcnJheVxuICAgIGlmIChudW1fZWx0cyA+IDMyKSBudW1fZWx0cyA9IDMyO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2VsdHM7IGkrKykgaCA9IGNhbWxfaGFzaF9taXhfZmxvYXQoaCwgYmEuZGF0YVtpXSk7XG4gICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIGg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdG9fdHlwZWRfYXJyYXkgbXV0YWJsZVxuZnVuY3Rpb24gY2FtbF9iYV90b190eXBlZF9hcnJheShiYSl7XG4gIHJldHVybiBiYS5kYXRhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2tpbmRfb2ZfdHlwZWRfYXJyYXkgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2tpbmRfb2ZfdHlwZWRfYXJyYXkodGEpe1xuICB2YXIga2luZDtcbiAgaWYgICAgICAodGEgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpIGtpbmQgPSAwO1xuICBlbHNlIGlmICh0YSBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheSkga2luZCA9IDE7XG4gIGVsc2UgaWYgKHRhIGluc3RhbmNlb2YgSW50OEFycmF5KSBraW5kID0gMjtcbiAgZWxzZSBpZiAodGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSBraW5kID0gMztcbiAgZWxzZSBpZiAodGEgaW5zdGFuY2VvZiBJbnQxNkFycmF5KSBraW5kID0gNDtcbiAgZWxzZSBpZiAodGEgaW5zdGFuY2VvZiBVaW50MTZBcnJheSkga2luZCA9IDU7XG4gIGVsc2UgaWYgKHRhIGluc3RhbmNlb2YgSW50MzJBcnJheSkga2luZCA9IDY7XG4gIGVsc2UgaWYgKHRhIGluc3RhbmNlb2YgVWludDMyQXJyYXkpIGtpbmQgPSA2O1xuICBlbHNlIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmFfa2luZF9vZl90eXBlZF9hcnJheTogdW5zdXBwb3J0ZWQga2luZFwiKTtcbiAgcmV0dXJuIGtpbmQ7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZnJvbV90eXBlZF9hcnJheSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2tpbmRfb2ZfdHlwZWRfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVxuZnVuY3Rpb24gY2FtbF9iYV9mcm9tX3R5cGVkX2FycmF5KHRhKXtcbiAgdmFyIGtpbmQgPSBjYW1sX2JhX2tpbmRfb2ZfdHlwZWRfYXJyYXkodGEpO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGtpbmQsIDAsIFt0YS5sZW5ndGhdLCB0YSk7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBsaWJyYXJ5XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gSnNsaWJcblxuLy9Qcm92aWRlczogY2FtbF9qc19wdXJlX2V4cHIgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbGJhY2tcbmZ1bmN0aW9uIGNhbWxfanNfcHVyZV9leHByIChmKSB7IHJldHVybiBjYW1sX2NhbGxiYWNrKGYsIFswXSk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc19zZXQgKG11dGFibGUsIGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfc2V0KG8sZix2KSB7IG9bZl09djtyZXR1cm4gMH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfZ2V0IChjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX2dldChvLGYpIHsgcmV0dXJuIG9bZl07IH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfZGVsZXRlIChtdXRhYmxlLCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfZGVsZXRlKG8sZikgeyBkZWxldGUgb1tmXTsgcmV0dXJuIDB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfaW5zdGFuY2VvZiAoY29uc3QsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19pbnN0YW5jZW9mKG8sYykgeyByZXR1cm4gKG8gaW5zdGFuY2VvZiBjKSA/IDEgOiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfdHlwZW9mIChjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfdHlwZW9mKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9XG5cbi8vUHJvdmlkZXM6Y2FtbF90cmFtcG9saW5lXG5mdW5jdGlvbiBjYW1sX3RyYW1wb2xpbmUocmVzKSB7XG4gIHZhciBjID0gMTtcbiAgd2hpbGUocmVzICYmIHJlcy5qb29fdHJhbXApe1xuICAgIHJlcyA9IHJlcy5qb29fdHJhbXAuYXBwbHkobnVsbCwgcmVzLmpvb19hcmdzKTtcbiAgICBjKys7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczpjYW1sX3RyYW1wb2xpbmVfcmV0dXJuXG5mdW5jdGlvbiBjYW1sX3RyYW1wb2xpbmVfcmV0dXJuKGYsYXJncykge1xuICByZXR1cm4ge2pvb190cmFtcDpmLGpvb19hcmdzOmFyZ3N9O1xufVxuXG4vL1Byb3ZpZGVzOmNhbWxfc3RhY2tfZGVwdGhcbi8vSWY6IGVmZmVjdHNcbnZhciBjYW1sX3N0YWNrX2RlcHRoID0gMDtcblxuLy9Qcm92aWRlczpjYW1sX3N0YWNrX2NoZWNrX2RlcHRoXG4vL0lmOiBlZmZlY3RzXG4vL1JlcXVpcmVzOmNhbWxfc3RhY2tfZGVwdGhcbmZ1bmN0aW9uIGNhbWxfc3RhY2tfY2hlY2tfZGVwdGgoKSB7XG4gICAgcmV0dXJuIC0tY2FtbF9zdGFja19kZXB0aCA+IDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY2FsbGJhY2tcbi8vSWY6ICFlZmZlY3RzXG4vL1JlcXVpcmVzOmNhbWxfY2FsbF9nZW5cbnZhciBjYW1sX2NhbGxiYWNrID0gY2FtbF9jYWxsX2dlbjtcblxuLy9Qcm92aWRlczogY2FtbF9jYWxsYmFja1xuLy9JZjogZWZmZWN0c1xuLy9SZXF1aXJlczpjYW1sX3N0YWNrX2RlcHRoLCBjYW1sX2NhbGxfZ2VuLCBjYW1sX2V4bl9zdGFjaywgY2FtbF9maWJlcl9zdGFjaywgY2FtbF93cmFwX2V4Y2VwdGlvbiwgY2FtbF9yZXN1bWVfc3RhY2ssIGNhbWxfZnJlc2hfb29faWQsIGNhbWxfbmFtZWRfdmFsdWUsIGNhbWxfcmFpc2Vfd2l0aF9hcmcsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfY29uc3RhbnRcbmZ1bmN0aW9uIGNhbWxfY2FsbGJhY2soZixhcmdzKSB7XG4gIGZ1bmN0aW9uIHVuY2F1Z2h0X2VmZmVjdF9oYW5kbGVyKGVmZixrLG1zKSB7XG4gICAgLy8gUmVzdW1lcyB0aGUgY29udGludWF0aW9uIGsgYnkgcmFpc2luZyBleGNlcHRpb24gVW5oYW5kbGVkLlxuICAgIGNhbWxfcmVzdW1lX3N0YWNrKGtbMV0sbXMpO1xuICAgIHZhciBleG4gPSBjYW1sX25hbWVkX3ZhbHVlKFwiRWZmZWN0LlVuaGFuZGxlZFwiKTtcbiAgICBpZihleG4pIGNhbWxfcmFpc2Vfd2l0aF9hcmcoZXhuLCBlZmYpO1xuICAgIGVsc2Uge1xuICAgICAgZXhuID0gWzI0OCxjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwiRWZmZWN0LlVuaGFuZGxlZFwiKSwgY2FtbF9mcmVzaF9vb19pZCgwKV07XG4gICAgICBjYW1sX3JhaXNlX2NvbnN0YW50KGV4bik7XG4gICAgfVxuICB9XG4gIHZhciBzYXZlZF9zdGFja19kZXB0aCA9IGNhbWxfc3RhY2tfZGVwdGg7XG4gIHZhciBzYXZlZF9leG5fc3RhY2sgPSBjYW1sX2V4bl9zdGFjaztcbiAgdmFyIHNhdmVkX2ZpYmVyX3N0YWNrID0gY2FtbF9maWJlcl9zdGFjaztcbiAgdHJ5IHtcbiAgICBjYW1sX2V4bl9zdGFjayA9IDA7XG4gICAgY2FtbF9maWJlcl9zdGFjayA9XG4gICAgICB7aDpbMCwgMCwgMCwgdW5jYXVnaHRfZWZmZWN0X2hhbmRsZXJdLCByOntrOjAsIHg6MCwgZTowfX07XG4gICAgdmFyIHJlcyA9IHtqb29fdHJhbXA6IGYsXG4gICAgICAgICAgICAgICBqb29fYXJnczogYXJncy5jb25jYXQoZnVuY3Rpb24gKHgpe3JldHVybiB4O30pfTtcbiAgICBkbyB7XG4gICAgICBjYW1sX3N0YWNrX2RlcHRoID0gNDA7XG4gICAgICB0cnkge1xuICAgICAgICByZXMgPSBjYW1sX2NhbGxfZ2VuKHJlcy5qb29fdHJhbXAsIHJlcy5qb29fYXJncyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8qIEhhbmRsZSBleGNlcHRpb24gY29taW5nIGZyb20gSmF2YVNjcmlwdCBvciBmcm9tIHRoZSBydW50aW1lLiAqL1xuICAgICAgICBpZiAoIWNhbWxfZXhuX3N0YWNrLmxlbmd0aCkgdGhyb3cgZTtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBjYW1sX2V4bl9zdGFja1sxXTtcbiAgICAgICAgY2FtbF9leG5fc3RhY2sgPSBjYW1sX2V4bl9zdGFja1syXTtcbiAgICAgICAgcmVzID0ge2pvb190cmFtcDogaGFuZGxlcixcbiAgICAgICAgICAgICAgIGpvb19hcmdzOiBbY2FtbF93cmFwX2V4Y2VwdGlvbihlKV19O1xuICAgICAgfVxuICAgIH0gd2hpbGUocmVzICYmIHJlcy5qb29fYXJncylcbiAgfSBmaW5hbGx5IHtcbiAgICBjYW1sX3N0YWNrX2RlcHRoID0gc2F2ZWRfc3RhY2tfZGVwdGg7XG4gICAgY2FtbF9leG5fc3RhY2sgPSBzYXZlZF9leG5fc3RhY2s7XG4gICAgY2FtbF9maWJlcl9zdGFjayA9IHNhdmVkX2ZpYmVyX3N0YWNrO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaXNfanNcbmZ1bmN0aW9uIGNhbWxfaXNfanMoKSB7XG4gIHJldHVybiAxO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzb29fZmxhZ3NfdXNlX2pzX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc29vX2ZsYWdzX3VzZV9qc19zdHJpbmcodW5pdCl7XG4gIHJldHVybiBGTEFHKFwidXNlLWpzLXN0cmluZ1wiKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzb29fZmxhZ3NfZWZmZWN0c1xuZnVuY3Rpb24gY2FtbF9qc29vX2ZsYWdzX2VmZmVjdHModW5pdCl7XG4gIHJldHVybiBGTEFHKFwiZWZmZWN0c1wiKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3dyYXBfZXhjZXB0aW9uIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGEsY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcsY2FtbF9uYW1lZF92YWx1ZVxuLy9SZXF1aXJlczogY2FtbF9yZXR1cm5fZXhuX2NvbnN0YW50XG5mdW5jdGlvbiBjYW1sX3dyYXBfZXhjZXB0aW9uKGUpIHtcbiAgaWYgKEZMQUcoXCJleGN3cmFwXCIpKSB7XG4gICAgaWYoZSBpbnN0YW5jZW9mIEFycmF5KSByZXR1cm4gZTtcbiAgICAvL1N0YWNrX292ZXJmbG93OiBjaHJvbWUsIHNhZmFyaVxuICAgIGlmKGdsb2JhbFRoaXMuUmFuZ2VFcnJvclxuICAgICAgICYmIGUgaW5zdGFuY2VvZiBnbG9iYWxUaGlzLlJhbmdlRXJyb3JcbiAgICAgICAmJiBlLm1lc3NhZ2VcbiAgICAgICAmJiBlLm1lc3NhZ2UubWF0Y2goL21heGltdW0gY2FsbCBzdGFjay9pKSlcbiAgICAgIHJldHVybiBjYW1sX3JldHVybl9leG5fY29uc3RhbnQoY2FtbF9nbG9iYWxfZGF0YS5TdGFja19vdmVyZmxvdyk7XG4gICAgLy9TdGFja19vdmVyZmxvdzogZmlyZWZveFxuICAgIGlmKGdsb2JhbFRoaXMuSW50ZXJuYWxFcnJvclxuICAgICAgICYmIGUgaW5zdGFuY2VvZiBnbG9iYWxUaGlzLkludGVybmFsRXJyb3JcbiAgICAgICAmJiBlLm1lc3NhZ2VcbiAgICAgICAmJiBlLm1lc3NhZ2UubWF0Y2goL3RvbyBtdWNoIHJlY3Vyc2lvbi9pKSlcbiAgICAgIHJldHVybiBjYW1sX3JldHVybl9leG5fY29uc3RhbnQoY2FtbF9nbG9iYWxfZGF0YS5TdGFja19vdmVyZmxvdyk7XG4gICAgLy9XcmFwIEVycm9yIGluIEpzLkVycm9yIGV4Y2VwdGlvblxuICAgIGlmKGUgaW5zdGFuY2VvZiBnbG9iYWxUaGlzLkVycm9yICYmIGNhbWxfbmFtZWRfdmFsdWUoXCJqc0Vycm9yXCIpKVxuICAgICAgcmV0dXJuIFswLGNhbWxfbmFtZWRfdmFsdWUoXCJqc0Vycm9yXCIpLGVdO1xuICAgIC8vZmFsbGJhY2s6IHdyYXBwZWQgaW4gRmFpbHVyZVxuICAgIHJldHVybiBbMCxjYW1sX2dsb2JhbF9kYXRhLkZhaWx1cmUsY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcgKFN0cmluZyhlKSldO1xuICB9IGVsc2VcbiAgICByZXR1cm4gZTtcbn1cblxuLy8gRXhwZXJpbWVudGFsXG4vL1Byb3ZpZGVzOiBjYW1sX2V4bl93aXRoX2pzX2JhY2t0cmFjZVxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9leG5fd2l0aF9qc19iYWNrdHJhY2UoZXhuLCBmb3JjZSkge1xuICAvL25ldmVyIHJlcmFpc2UgZm9yIGNvbnN0YW50IGV4blxuICBpZighZXhuLmpzX2Vycm9yIHx8IGZvcmNlIHx8IGV4blswXSA9PSAyNDgpIGV4bi5qc19lcnJvciA9IG5ldyBnbG9iYWxUaGlzLkVycm9yKFwiSnMgZXhjZXB0aW9uIGNvbnRhaW5pbmcgYmFja3RyYWNlXCIpO1xuICByZXR1cm4gZXhuO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZXJyb3Jfb3B0aW9uX29mX2V4Y2VwdGlvblxuZnVuY3Rpb24gY2FtbF9qc19lcnJvcl9vcHRpb25fb2ZfZXhjZXB0aW9uKGV4bikge1xuICBpZihleG4uanNfZXJyb3IpIHsgcmV0dXJuIFswLCBleG4uanNfZXJyb3JdOyB9XG4gIHJldHVybiAwO1xufVxuXG5cblxuLy9Qcm92aWRlczogY2FtbF9qc19mcm9tX2Jvb2wgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19mcm9tX2Jvb2woeCkgeyByZXR1cm4gISF4OyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3RvX2Jvb2wgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc190b19ib29sKHgpIHsgcmV0dXJuICt4OyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Zyb21fZmxvYXQgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19mcm9tX2Zsb2F0KHgpIHsgcmV0dXJuIHg7IH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfdG9fZmxvYXQgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc190b19mbG9hdCh4KSB7IHJldHVybiB4OyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZnJvbV9hcnJheSBtdXRhYmxlIChzaGFsbG93KVxuZnVuY3Rpb24gY2FtbF9qc19mcm9tX2FycmF5KGEpIHtcbiAgcmV0dXJuIGEuc2xpY2UoMSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3RvX2FycmF5IG11dGFibGUgKHNoYWxsb3cpXG5mdW5jdGlvbiBjYW1sX2pzX3RvX2FycmF5KGEpIHtcbiAgdmFyIGxlbiA9IGEubGVuZ3RoO1xuICB2YXIgYiA9IG5ldyBBcnJheShsZW4rMSk7XG4gIGJbMF0gPSAwO1xuICBmb3IodmFyIGk9MDtpPGxlbjtpKyspIGJbaSsxXSA9IGFbaV07XG4gIHJldHVybiBiO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xpc3Rfb2ZfanNfYXJyYXkgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9saXN0X29mX2pzX2FycmF5KGEpe1xuICB2YXIgbCA9IDA7XG4gIGZvcih2YXIgaT1hLmxlbmd0aCAtIDE7IGk+PTA7IGktLSl7XG4gICAgdmFyIGUgPSBhW2ldO1xuICAgIGwgPSBbMCxlLGxdO1xuICB9XG4gIHJldHVybiBsXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbGlzdF90b19qc19hcnJheSBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2xpc3RfdG9fanNfYXJyYXkobCl7XG4gIHZhciBhID0gW107XG4gIGZvcig7IGwgIT09IDA7IGwgPSBsWzJdKSB7XG4gICAgYS5wdXNoKGxbMV0pO1xuICB9XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3ZhciBtdXRhYmxlIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzX3Zhcih4KSB7XG4gIHZhciB4ID0gY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcoeCk7XG4gIC8vQ2hlY2tzIHRoYXQgeCBoYXMgdGhlIGZvcm0gaWRlbnRbLmlkZW50XSpcbiAgaWYoIXgubWF0Y2goL15bYS16QS1aXyRdW2EtekEtWl8kMC05XSooXFwuW2EtekEtWl8kXVthLXpBLVpfJDAtOV0qKSokLykpe1xuICAgIGNvbnNvbGUuZXJyb3IoXCJjYW1sX2pzX3ZhcjogXFxcIlwiICsgeCArIFwiXFxcIiBpcyBub3QgYSB2YWxpZCBKYXZhU2NyaXB0IHZhcmlhYmxlLiBjb250aW51aW5nIC4uXCIpO1xuICAgIC8vY29uc29sZS5lcnJvcihcIkpzLlVuc2FmZS5ldmFsX3N0cmluZ1wiKVxuICB9XG4gIHJldHVybiBldmFsKHgpO1xufVxuLy9Qcm92aWRlczogY2FtbF9qc19jYWxsIChjb25zdCwgbXV0YWJsZSwgc2hhbGxvdylcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9qc19jYWxsKGYsIG8sIGFyZ3MpIHsgcmV0dXJuIGYuYXBwbHkobywgY2FtbF9qc19mcm9tX2FycmF5KGFyZ3MpKTsgfVxuLy9Qcm92aWRlczogY2FtbF9qc19mdW5fY2FsbCAoY29uc3QsIHNoYWxsb3cpXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfanNfZnVuX2NhbGwoZiwgYSkge1xuICBzd2l0Y2ggKGEubGVuZ3RoKSB7XG4gIGNhc2UgMTogcmV0dXJuIGYoKTtcbiAgY2FzZSAyOiByZXR1cm4gZiAoYVsxXSk7XG4gIGNhc2UgMzogcmV0dXJuIGYgKGFbMV0sYVsyXSk7XG4gIGNhc2UgNDogcmV0dXJuIGYgKGFbMV0sYVsyXSxhWzNdKTtcbiAgY2FzZSA1OiByZXR1cm4gZiAoYVsxXSxhWzJdLGFbM10sYVs0XSk7XG4gIGNhc2UgNjogcmV0dXJuIGYgKGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSk7XG4gIGNhc2UgNzogcmV0dXJuIGYgKGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSxhWzZdKTtcbiAgY2FzZSA4OiByZXR1cm4gZiAoYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdLGFbNl0sYVs3XSk7XG4gIH1cbiAgcmV0dXJuIGYuYXBwbHkobnVsbCwgY2FtbF9qc19mcm9tX2FycmF5KGEpKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfbWV0aF9jYWxsIChtdXRhYmxlLCBjb25zdCwgc2hhbGxvdylcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfanNfbWV0aF9jYWxsKG8sIGYsIGFyZ3MpIHtcbiAgcmV0dXJuIG9bY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcoZildLmFwcGx5KG8sIGNhbWxfanNfZnJvbV9hcnJheShhcmdzKSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX25ldyAoY29uc3QsIHNoYWxsb3cpXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfanNfbmV3KGMsIGEpIHtcbiAgc3dpdGNoIChhLmxlbmd0aCkge1xuICBjYXNlIDE6IHJldHVybiBuZXcgYztcbiAgY2FzZSAyOiByZXR1cm4gbmV3IGMgKGFbMV0pO1xuICBjYXNlIDM6IHJldHVybiBuZXcgYyAoYVsxXSxhWzJdKTtcbiAgY2FzZSA0OiByZXR1cm4gbmV3IGMgKGFbMV0sYVsyXSxhWzNdKTtcbiAgY2FzZSA1OiByZXR1cm4gbmV3IGMgKGFbMV0sYVsyXSxhWzNdLGFbNF0pO1xuICBjYXNlIDY6IHJldHVybiBuZXcgYyAoYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdKTtcbiAgY2FzZSA3OiByZXR1cm4gbmV3IGMgKGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSxhWzZdKTtcbiAgY2FzZSA4OiByZXR1cm4gbmV3IGMgKGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSxhWzZdLGFbN10pO1xuICB9XG4gIGZ1bmN0aW9uIEYoKSB7IHJldHVybiBjLmFwcGx5KHRoaXMsIGNhbWxfanNfZnJvbV9hcnJheShhKSk7IH1cbiAgRi5wcm90b3R5cGUgPSBjLnByb3RvdHlwZTtcbiAgcmV0dXJuIG5ldyBGO1xufVxuLy9Qcm92aWRlczogY2FtbF9vanNfbmV3X2FyciAoY29uc3QsIHNoYWxsb3cpXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfb2pzX25ld19hcnIoYywgYSkge1xuICBzd2l0Y2ggKGEubGVuZ3RoKSB7XG4gIGNhc2UgMDogcmV0dXJuIG5ldyBjO1xuICBjYXNlIDE6IHJldHVybiBuZXcgYyAoYVswXSk7XG4gIGNhc2UgMjogcmV0dXJuIG5ldyBjIChhWzBdLGFbMV0pO1xuICBjYXNlIDM6IHJldHVybiBuZXcgYyAoYVswXSxhWzFdLGFbMl0pO1xuICBjYXNlIDQ6IHJldHVybiBuZXcgYyAoYVswXSxhWzFdLGFbMl0sYVszXSk7XG4gIGNhc2UgNTogcmV0dXJuIG5ldyBjIChhWzBdLGFbMV0sYVsyXSxhWzNdLGFbNF0pO1xuICBjYXNlIDY6IHJldHVybiBuZXcgYyAoYVswXSxhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0pO1xuICBjYXNlIDc6IHJldHVybiBuZXcgYyAoYVswXSxhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0sYVs2XSk7XG4gIH1cbiAgZnVuY3Rpb24gRigpIHsgcmV0dXJuIGMuYXBwbHkodGhpcywgYSk7IH1cbiAgRi5wcm90b3R5cGUgPSBjLnByb3RvdHlwZTtcbiAgcmV0dXJuIG5ldyBGO1xufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX2NhbGxiYWNrIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbGJhY2tcbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9jYWxsYmFjayhmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgaWYobGVuID4gMCl7XG4gICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShsZW4pO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXJncyA9IFt1bmRlZmluZWRdO1xuICAgIH1cbiAgICB2YXIgcmVzID0gY2FtbF9jYWxsYmFjayhmLCBhcmdzKTtcbiAgICByZXR1cm4gKHJlcyBpbnN0YW5jZW9mIEZ1bmN0aW9uKT9jYW1sX2pzX3dyYXBfY2FsbGJhY2socmVzKTpyZXM7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX2NhbGxiYWNrX2FyZ3VtZW50c1xuLy9SZXF1aXJlczogY2FtbF9jYWxsYmFja1xuZnVuY3Rpb24gY2FtbF9qc193cmFwX2NhbGxiYWNrX2FyZ3VtZW50cyhmKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgcmV0dXJuIGNhbWxfY2FsbGJhY2soZiwgW2FyZ3NdKTtcbiAgfVxufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX2NhbGxiYWNrX3N0cmljdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9jYWxsYmFja1xuZnVuY3Rpb24gY2FtbF9qc193cmFwX2NhbGxiYWNrX3N0cmljdChhcml0eSwgZikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcml0eSk7XG4gICAgdmFyIGxlbiA9IE1hdGgubWluKGFyZ3VtZW50cy5sZW5ndGgsIGFyaXR5KVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgcmV0dXJuIGNhbWxfY2FsbGJhY2soZiwgYXJncyk7XG4gIH07XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfY2FsbGJhY2tfdW5zYWZlIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbGJhY2ssIGNhbWxfanNfZnVuY3Rpb25fYXJpdHlcbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9jYWxsYmFja191bnNhZmUoZikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsZW4gPSBjYW1sX2pzX2Z1bmN0aW9uX2FyaXR5KGYpO1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICByZXR1cm4gY2FtbF9jYWxsYmFjayhmLCBhcmdzKTsgfVxufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2sgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jYWxsYmFjaywgY2FtbF9qc193cmFwX2NhbGxiYWNrXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFjayhmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobGVuICsgMSk7XG4gICAgYXJnc1swXSA9IHRoaXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpKzFdID0gYXJndW1lbnRzW2ldO1xuICAgIHZhciByZXMgPSBjYW1sX2NhbGxiYWNrKGYsYXJncyk7XG4gICAgcmV0dXJuIChyZXMgaW5zdGFuY2VvZiBGdW5jdGlvbik/Y2FtbF9qc193cmFwX2NhbGxiYWNrKHJlcyk6cmVzO1xuICB9XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19hcmd1bWVudHMgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jYWxsYmFja1xuZnVuY3Rpb24gY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfYXJndW1lbnRzKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgcmV0dXJuIGNhbWxfY2FsbGJhY2soZixbdGhpcyxhcmdzXSk7XG4gIH1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX3N0cmljdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9jYWxsYmFja1xuZnVuY3Rpb24gY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfc3RyaWN0KGFyaXR5LCBmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJpdHkgKyAxKTtcbiAgICB2YXIgbGVuID0gTWF0aC5taW4oYXJndW1lbnRzLmxlbmd0aCwgYXJpdHkpXG4gICAgYXJnc1swXSA9IHRoaXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpKzFdID0gYXJndW1lbnRzW2ldO1xuICAgIHJldHVybiBjYW1sX2NhbGxiYWNrKGYsIGFyZ3MpO1xuICB9O1xufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfdW5zYWZlIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbGJhY2ssIGNhbWxfanNfZnVuY3Rpb25fYXJpdHlcbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX3Vuc2FmZShmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlbiA9IGNhbWxfanNfZnVuY3Rpb25fYXJpdHkoZikgLSAxO1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGxlbiArIDEpO1xuICAgIGFyZ3NbMF0gPSB0aGlzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGFyZ3NbaSsxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICByZXR1cm4gY2FtbF9jYWxsYmFjayhmLCBhcmdzKTsgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Z1bmN0aW9uX2FyaXR5XG4vL0lmOiAhZWZmZWN0c1xuZnVuY3Rpb24gY2FtbF9qc19mdW5jdGlvbl9hcml0eShmKSB7XG4gIHJldHVybiBmLmxlbmd0aFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Z1bmN0aW9uX2FyaXR5XG4vL0lmOiBlZmZlY3RzXG5mdW5jdGlvbiBjYW1sX2pzX2Z1bmN0aW9uX2FyaXR5KGYpIHtcbiAgLy8gRnVuY3Rpb25zIGhhdmUgYW4gYWRkaXRpb25hbCBjb250aW51YXRpb24gcGFyYW1ldGVyLiBUaGlzIHNob3VsZFxuICAvLyBub3QgYmUgdmlzaWJsZSB3aGVuIGNhbGxpbmcgdGhlbSBmcm9tIEphdmFTY3JpcHRcbiAgcmV0dXJuIGYubGVuZ3RoIC0gMVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2VxdWFscyBtdXRhYmxlIChjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX2VxdWFscyAoeCwgeSkgeyByZXR1cm4gKyh4ID09IHkpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZXZhbF9zdHJpbmcgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNfZXZhbF9zdHJpbmcgKHMpIHtyZXR1cm4gZXZhbChjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKSk7fVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2V4cHIgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNfZXhwcihzKSB7XG4gIGNvbnNvbGUuZXJyb3IoXCJjYW1sX2pzX2V4cHI6IGZhbGxiYWNrIHRvIHJ1bnRpbWUgZXZhbHVhdGlvblxcblwiKTtcbiAgcmV0dXJuIGV2YWwoY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocykpO31cblxuLy9Qcm92aWRlczogY2FtbF9wdXJlX2pzX2V4cHIgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfcHVyZV9qc19leHByIChzKXtcbiAgY29uc29sZS5lcnJvcihcImNhbWxfcHVyZV9qc19leHByOiBmYWxsYmFjayB0byBydW50aW1lIGV2YWx1YXRpb25cXG5cIik7XG4gIHJldHVybiBldmFsKGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpKTt9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfb2JqZWN0IChvYmplY3RfbGl0ZXJhbClcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzX29iamVjdCAoYSkge1xuICB2YXIgbyA9IHt9O1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcCA9IGFbaV07XG4gICAgb1tjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhwWzFdKV0gPSBwWzJdO1xuICB9XG4gIHJldHVybiBvO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9mb3JtYXRfaW50IGNvbnN0IChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3BhcnNlX2Zvcm1hdCwgY2FtbF9maW5pc2hfZm9ybWF0dGluZywgY2FtbF9zdHJfcmVwZWF0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2Zvcm1hdF9pbnQoZm10LCBpKSB7XG4gIGlmIChjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKGZtdCkgPT0gXCIlZFwiKSByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcIlwiK2kpO1xuICB2YXIgZiA9IGNhbWxfcGFyc2VfZm9ybWF0KGZtdCk7XG4gIGlmIChpIDwgMCkgeyBpZiAoZi5zaWduZWRjb252KSB7IGYuc2lnbiA9IC0xOyBpID0gLWk7IH0gZWxzZSBpID4+Pj0gMDsgfVxuICB2YXIgcyA9IGkudG9TdHJpbmcoZi5iYXNlKTtcbiAgaWYgKGYucHJlYyA+PSAwKSB7XG4gICAgZi5maWxsZXIgPSAnICc7XG4gICAgdmFyIG4gPSBmLnByZWMgLSBzLmxlbmd0aDtcbiAgICBpZiAobiA+IDApIHMgPSBjYW1sX3N0cl9yZXBlYXQgKG4sICcwJykgKyBzO1xuICB9XG4gIHJldHVybiBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nKGYsIHMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2Vcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlIChzKSB7XG4gIHZhciBpID0gMCwgbGVuID0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpLCBiYXNlID0gMTAsIHNpZ24gPSAxO1xuICBpZiAobGVuID4gMCkge1xuICAgIHN3aXRjaCAoY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLGkpKSB7XG4gICAgY2FzZSA0NTogaSsrOyBzaWduID0gLTE7IGJyZWFrO1xuICAgIGNhc2UgNDM6IGkrKzsgc2lnbiA9IDE7IGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoaSArIDEgPCBsZW4gJiYgY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpKSA9PSA0OClcbiAgICBzd2l0Y2ggKGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSArIDEpKSB7XG4gICAgY2FzZSAxMjA6IGNhc2UgODg6IGJhc2UgPSAxNjsgaSArPSAyOyBicmVhaztcbiAgICBjYXNlIDExMTogY2FzZSA3OTogYmFzZSA9ICA4OyBpICs9IDI7IGJyZWFrO1xuICAgIGNhc2UgIDk4OiBjYXNlIDY2OiBiYXNlID0gIDI7IGkgKz0gMjsgYnJlYWs7XG4gICAgY2FzZSAxMTc6IGNhc2UgODU6IGkgKz0gMjsgYnJlYWs7XG4gICAgfVxuICByZXR1cm4gW2ksIHNpZ24sIGJhc2VdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3BhcnNlX2RpZ2l0XG5mdW5jdGlvbiBjYW1sX3BhcnNlX2RpZ2l0KGMpIHtcbiAgaWYgKGMgPj0gNDggJiYgYyA8PSA1NykgIHJldHVybiBjIC0gNDg7XG4gIGlmIChjID49IDY1ICYmIGMgPD0gOTApICByZXR1cm4gYyAtIDU1O1xuICBpZiAoYyA+PSA5NyAmJiBjIDw9IDEyMikgcmV0dXJuIGMgLSA4NztcbiAgcmV0dXJuIC0xO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludF9vZl9zdHJpbmcgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX3N0cmluZ191bnNhZmVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2UsIGNhbWxfcGFyc2VfZGlnaXQsIGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfaW50X29mX3N0cmluZyAocykge1xuICB2YXIgciA9IGNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZSAocyk7XG4gIHZhciBpID0gclswXSwgc2lnbiA9IHJbMV0sIGJhc2UgPSByWzJdO1xuICB2YXIgbGVuID0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpO1xuICB2YXIgdGhyZXNob2xkID0gLTEgPj4+IDA7XG4gIHZhciBjID0gKGkgPCBsZW4pP2NhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSk6MDtcbiAgdmFyIGQgPSBjYW1sX3BhcnNlX2RpZ2l0KGMpO1xuICBpZiAoZCA8IDAgfHwgZCA+PSBiYXNlKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgdmFyIHJlcyA9IGQ7XG4gIGZvciAoaSsrO2k8bGVuO2krKykge1xuICAgIGMgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkpO1xuICAgIGlmIChjID09IDk1KSBjb250aW51ZTtcbiAgICBkID0gY2FtbF9wYXJzZV9kaWdpdChjKTtcbiAgICBpZiAoZCA8IDAgfHwgZCA+PSBiYXNlKSBicmVhaztcbiAgICByZXMgPSBiYXNlICogcmVzICsgZDtcbiAgICBpZiAocmVzID4gdGhyZXNob2xkKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgfVxuICBpZiAoaSAhPSBsZW4pIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICAvLyBGb3IgYmFzZSBkaWZmZXJlbnQgZnJvbSAxMCwgd2UgZXhwZWN0IGFuIHVuc2lnbmVkIHJlcHJlc2VudGF0aW9uLFxuICAvLyBoZW5jZSBhbnkgdmFsdWUgb2YgJ3JlcycgKGxlc3MgdGhhbiAndGhyZXNob2xkJykgaXMgYWNjZXB0YWJsZS5cbiAgLy8gQnV0IHdlIGhhdmUgdG8gY29udmVydCB0aGUgcmVzdWx0IGJhY2sgdG8gYSBzaWduZWQgaW50ZWdlci5cbiAgcmVzID0gc2lnbiAqIHJlcztcbiAgaWYgKChiYXNlID09IDEwKSAmJiAoKHJlcyB8IDApICE9IHJlcykpXG4gICAgLyogU2lnbmVkIHJlcHJlc2VudGF0aW9uIGV4cGVjdGVkLCBhbGxvdyAtMl4obmJpdHMtMSkgdG8gMl4obmJpdHMtMSkgLSAxICovXG4gICAgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIHJldHVybiByZXMgfCAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX211bCBjb25zdFxuZnVuY3Rpb24gY2FtbF9tdWwoYSxiKXtcbiAgcmV0dXJuIE1hdGguaW11bChhLGIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2RpdlxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV96ZXJvX2RpdmlkZVxuZnVuY3Rpb24gY2FtbF9kaXYoeCx5KSB7XG4gIGlmICh5ID09IDApIGNhbWxfcmFpc2VfemVyb19kaXZpZGUgKCk7XG4gIHJldHVybiAoeC95KXwwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21vZFxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV96ZXJvX2RpdmlkZVxuZnVuY3Rpb24gY2FtbF9tb2QoeCx5KSB7XG4gIGlmICh5ID09IDApIGNhbWxfcmFpc2VfemVyb19kaXZpZGUgKCk7XG4gIHJldHVybiB4JXk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnN3YXAxNlxuZnVuY3Rpb24gY2FtbF9ic3dhcDE2KHgpIHtcbiAgcmV0dXJuICgoKCh4ICYgMHgwMEZGKSA8PCA4KSB8XG4gICAgICAgICAgICgoeCAmIDB4RkYwMCkgPj4gOCkpKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfaW50MzJfYnN3YXBcbmZ1bmN0aW9uIGNhbWxfaW50MzJfYnN3YXAoeCkge1xuICByZXR1cm4gKCgoeCAmIDB4MDAwMDAwRkYpIDw8IDI0KSB8XG4gICAgICAgICAgKCh4ICYgMHgwMDAwRkYwMCkgPDwgOCkgfFxuICAgICAgICAgICgoeCAmIDB4MDBGRjAwMDApID4+PiA4KSB8XG4gICAgICAgICAgKCh4ICYgMHhGRjAwMDAwMCkgPj4+IDI0KSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2Jzd2FwXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2J5dGVzLCBjYW1sX2ludDY0X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2ludDY0X2Jzd2FwKHgpIHtcbiAgdmFyIHkgPSBjYW1sX2ludDY0X3RvX2J5dGVzKHgpO1xuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9ieXRlcyhbeVs3XSwgeVs2XSwgeVs1XSwgeVs0XSwgeVszXSwgeVsyXSwgeVsxXSwgeVswXV0pO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBIYXNodGJsXG5cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX3VuaXZfcGFyYW0gbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9pc19tbF9zdHJpbmcsIGNhbWxfaXNfbWxfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfbWxfYnl0ZXNfY29udGVudFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19ieXRlcywgY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0LCBjYW1sX2N1c3RvbV9vcHNcbi8vUmVxdWlyZXM6IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG4vL1ZlcnNpb246IDwgNC4xMlxuZnVuY3Rpb24gY2FtbF9oYXNoX3VuaXZfcGFyYW0gKGNvdW50LCBsaW1pdCwgb2JqKSB7XG4gIHZhciBoYXNoX2FjY3UgPSAwO1xuICBmdW5jdGlvbiBoYXNoX2F1eCAob2JqKSB7XG4gICAgbGltaXQgLS07XG4gICAgaWYgKGNvdW50IDwgMCB8fCBsaW1pdCA8IDApIHJldHVybjtcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgQXJyYXkgJiYgb2JqWzBdID09PSAob2JqWzBdfDApKSB7XG4gICAgICBzd2l0Y2ggKG9ialswXSkge1xuICAgICAgY2FzZSAyNDg6XG4gICAgICAgIC8vIE9iamVjdFxuICAgICAgICBjb3VudCAtLTtcbiAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDY1NTk5ICsgb2JqWzJdKSB8IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNTA6XG4gICAgICAgIC8vIEZvcndhcmRcbiAgICAgICAgbGltaXQrKzsgaGFzaF9hdXgob2JqKTsgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb3VudCAtLTtcbiAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDE5ICsgb2JqWzBdKSB8IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSBvYmoubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkgaGFzaF9hdXggKG9ialtpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjYW1sX2lzX21sX2J5dGVzKG9iaikpIHtcbiAgICAgIGNvdW50IC0tO1xuICAgICAgdmFyIGNvbnRlbnQgPSBjYW1sX21sX2J5dGVzX2NvbnRlbnQob2JqKTtcbiAgICAgIGlmKHR5cGVvZiBjb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGZvciAodmFyIGIgPSBjb250ZW50LCBsID0gYi5sZW5ndGgsIGkgPSAwOyBpIDwgbDsgaSsrKVxuICAgICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiAxOSArIGIuY2hhckNvZGVBdChpKSkgfCAwO1xuICAgICAgfSBlbHNlIHsgLyogQVJSQVkgKi9cbiAgICAgICAgZm9yICh2YXIgYSA9IGNvbnRlbnQsIGwgPSBhLmxlbmd0aCwgaSA9IDA7IGkgPCBsOyBpKyspXG4gICAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDE5ICsgYVtpXSkgfCAwO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2FtbF9pc19tbF9zdHJpbmcob2JqKSkge1xuICAgICAgdmFyIGpzYnl0ZXMgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKG9iaik7XG4gICAgICBmb3IgKHZhciBiID0ganNieXRlcywgbCA9IGpzYnl0ZXMubGVuZ3RoLCBpID0gMDsgaSA8IGw7IGkrKylcbiAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDE5ICsgYi5jaGFyQ29kZUF0KGkpKSB8IDA7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBmb3IgKHZhciBiID0gb2JqLCBsID0gb2JqLmxlbmd0aCwgaSA9IDA7IGkgPCBsOyBpKyspXG4gICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiAxOSArIGIuY2hhckNvZGVBdChpKSkgfCAwO1xuICAgIH0gZWxzZSBpZiAob2JqID09PSAob2JqfDApKSB7XG4gICAgICAvLyBJbnRlZ2VyXG4gICAgICBjb3VudCAtLTtcbiAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiA2NTU5OSArIG9iaikgfCAwO1xuICAgIH0gZWxzZSBpZiAob2JqID09PSArb2JqKSB7XG4gICAgICAvLyBGbG9hdFxuICAgICAgY291bnQtLTtcbiAgICAgIHZhciBwID0gY2FtbF9pbnQ2NF90b19ieXRlcyAoY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0IChvYmopKTtcbiAgICAgIGZvciAodmFyIGkgPSA3OyBpID49IDA7IGktLSkgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDE5ICsgcFtpXSkgfCAwO1xuICAgIH0gZWxzZSBpZihvYmogJiYgb2JqLmNhbWxfY3VzdG9tKSB7XG4gICAgICBpZihjYW1sX2N1c3RvbV9vcHNbb2JqLmNhbWxfY3VzdG9tXSAmJiBjYW1sX2N1c3RvbV9vcHNbb2JqLmNhbWxfY3VzdG9tXS5oYXNoKSB7XG4gICAgICAgIHZhciBoID0gY2FtbF9jdXN0b21fb3BzW29iai5jYW1sX2N1c3RvbV0uaGFzaChvYmopIHwgMDtcbiAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDY1NTk5ICsgaCkgfCAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBoYXNoX2F1eCAob2JqKTtcbiAgcmV0dXJuIGhhc2hfYWNjdSAmIDB4M0ZGRkZGRkY7XG59XG5cbi8vZnVuY3Rpb24gUk9UTDMyKHgsbikgeyByZXR1cm4gKCh4IDw8IG4pIHwgKHggPj4+ICgzMi1uKSkpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2ludFxuLy9SZXF1aXJlczogY2FtbF9tdWxcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfaW50KGgsZCkge1xuICBkID0gY2FtbF9tdWwoZCwgMHhjYzllMmQ1MXwwKTtcbiAgZCA9ICgoZCA8PCAxNSkgfCAoZCA+Pj4gKDMyLTE1KSkpOyAvLyBST1RMMzIoZCwgMTUpO1xuICBkID0gY2FtbF9tdWwoZCwgMHgxYjg3MzU5Myk7XG4gIGggXj0gZDtcbiAgaCA9ICgoaCA8PCAxMykgfCAoaCA+Pj4gKDMyLTEzKSkpOyAgIC8vUk9UTDMyKGgsIDEzKTtcbiAgcmV0dXJuICgoKGggKyAoaCA8PCAyKSl8MCkgKyAoMHhlNjU0NmI2NHwwKSl8MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9maW5hbFxuLy9SZXF1aXJlczogY2FtbF9tdWxcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfZmluYWwoaCkge1xuICBoIF49IGggPj4+IDE2O1xuICBoID0gY2FtbF9tdWwgKGgsIDB4ODVlYmNhNmJ8MCk7XG4gIGggXj0gaCA+Pj4gMTM7XG4gIGggPSBjYW1sX211bCAoaCwgMHhjMmIyYWUzNXwwKTtcbiAgaCBePSBoID4+PiAxNjtcbiAgcmV0dXJuIGg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfZmxvYXRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCwgY2FtbF9oYXNoX21peF9pbnQ2NFxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9mbG9hdCAoaCwgdjApIHtcbiAgcmV0dXJuIGNhbWxfaGFzaF9taXhfaW50NjQoaCwgY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0ICh2MCkpO1xufVxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9pbnQ2NFxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9pbnRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfbG8zMiwgY2FtbF9pbnQ2NF9oaTMyXG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2ludDY0IChoLCB2KSB7XG4gIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCBjYW1sX2ludDY0X2xvMzIodikpO1xuICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgY2FtbF9pbnQ2NF9oaTMyKHYpKTtcbiAgcmV0dXJuIGg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfanNieXRlc1xuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9pbnRcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfanNieXRlcyhoLCBzKSB7XG4gIHZhciBsZW4gPSBzLmxlbmd0aCwgaSwgdztcbiAgZm9yIChpID0gMDsgaSArIDQgPD0gbGVuOyBpICs9IDQpIHtcbiAgICB3ID0gcy5jaGFyQ29kZUF0KGkpXG4gICAgICB8IChzLmNoYXJDb2RlQXQoaSsxKSA8PCA4KVxuICAgICAgfCAocy5jaGFyQ29kZUF0KGkrMikgPDwgMTYpXG4gICAgICB8IChzLmNoYXJDb2RlQXQoaSszKSA8PCAyNCk7XG4gICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHcpO1xuICB9XG4gIHcgPSAwO1xuICBzd2l0Y2ggKGxlbiAmIDMpIHtcbiAgY2FzZSAzOiB3ICA9IHMuY2hhckNvZGVBdChpKzIpIDw8IDE2O1xuICBjYXNlIDI6IHcgfD0gcy5jaGFyQ29kZUF0KGkrMSkgPDwgODtcbiAgY2FzZSAxOlxuICAgIHcgfD0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB3KTtcbiAgZGVmYXVsdDpcbiAgfVxuICBoIF49IGxlbjtcbiAgcmV0dXJuIGg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfYnl0ZXNfYXJyXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2ludFxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9ieXRlc19hcnIoaCwgcykge1xuICB2YXIgbGVuID0gcy5sZW5ndGgsIGksIHc7XG4gIGZvciAoaSA9IDA7IGkgKyA0IDw9IGxlbjsgaSArPSA0KSB7XG4gICAgdyA9IHNbaV1cbiAgICAgIHwgKHNbaSsxXSA8PCA4KVxuICAgICAgfCAoc1tpKzJdIDw8IDE2KVxuICAgICAgfCAoc1tpKzNdIDw8IDI0KTtcbiAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdyk7XG4gIH1cbiAgdyA9IDA7XG4gIHN3aXRjaCAobGVuICYgMykge1xuICBjYXNlIDM6IHcgID0gc1tpKzJdIDw8IDE2O1xuICBjYXNlIDI6IHcgfD0gc1tpKzFdIDw8IDg7XG4gIGNhc2UgMTogdyB8PSBzW2ldO1xuICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB3KTtcbiAgZGVmYXVsdDpcbiAgfVxuICBoIF49IGxlbjtcbiAgcmV0dXJuIGg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfbWxfYnl0ZXNfY29udGVudFxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9qc2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2J5dGVzX2FyclxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9ieXRlcyhoLCB2KSB7XG4gIHZhciBjb250ZW50ID0gY2FtbF9tbF9ieXRlc19jb250ZW50KHYpO1xuICBpZih0eXBlb2YgY29udGVudCA9PT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4gY2FtbF9oYXNoX21peF9qc2J5dGVzKGgsIGNvbnRlbnQpXG4gIGVsc2UgLyogQVJSQVkgKi9cbiAgICByZXR1cm4gY2FtbF9oYXNoX21peF9ieXRlc19hcnIoaCwgY29udGVudCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2pzYnl0ZXMsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfc3RyaW5nKGgsIHYpIHtcbiAgcmV0dXJuIGNhbWxfaGFzaF9taXhfanNieXRlcyhoLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHYpKTtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2ggbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9pc19tbF9zdHJpbmcsIGNhbWxfaXNfbWxfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfaW50LCBjYW1sX2hhc2hfbWl4X2ZpbmFsXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2Zsb2F0LCBjYW1sX2hhc2hfbWl4X3N0cmluZywgY2FtbF9oYXNoX21peF9ieXRlcywgY2FtbF9jdXN0b21fb3BzXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2pzYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaXNfY29udGludWF0aW9uX3RhZ1xuZnVuY3Rpb24gY2FtbF9oYXNoIChjb3VudCwgbGltaXQsIHNlZWQsIG9iaikge1xuICB2YXIgcXVldWUsIHJkLCB3ciwgc3osIG51bSwgaCwgdiwgaSwgbGVuO1xuICBzeiA9IGxpbWl0O1xuICBpZiAoc3ogPCAwIHx8IHN6ID4gMjU2KSBzeiA9IDI1NjtcbiAgbnVtID0gY291bnQ7XG4gIGggPSBzZWVkO1xuICBxdWV1ZSA9IFtvYmpdOyByZCA9IDA7IHdyID0gMTtcbiAgd2hpbGUgKHJkIDwgd3IgJiYgbnVtID4gMCkge1xuICAgIHYgPSBxdWV1ZVtyZCsrXTtcbiAgICBpZiAodiAmJiB2LmNhbWxfY3VzdG9tKXtcbiAgICAgIGlmKGNhbWxfY3VzdG9tX29wc1t2LmNhbWxfY3VzdG9tXSAmJiBjYW1sX2N1c3RvbV9vcHNbdi5jYW1sX2N1c3RvbV0uaGFzaCkge1xuICAgICAgICB2YXIgaGggPSBjYW1sX2N1c3RvbV9vcHNbdi5jYW1sX2N1c3RvbV0uaGFzaCh2KTtcbiAgICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50IChoLCBoaCk7XG4gICAgICAgIG51bSAtLTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodiBpbnN0YW5jZW9mIEFycmF5ICYmIHZbMF0gPT09ICh2WzBdfDApKSB7XG4gICAgICBzd2l0Y2ggKHZbMF0pIHtcbiAgICAgIGNhc2UgMjQ4OlxuICAgICAgICAvLyBPYmplY3RcbiAgICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHZbMl0pO1xuICAgICAgICBudW0tLTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI1MDpcbiAgICAgICAgLy8gRm9yd2FyZFxuICAgICAgICBxdWV1ZVstLXJkXSA9IHZbMV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYoY2FtbF9pc19jb250aW51YXRpb25fdGFnKHZbMF0pKSB7XG4gICAgICAgICAgLyogQWxsIGNvbnRpbnVhdGlvbnMgaGFzaCB0byB0aGUgc2FtZSB2YWx1ZSxcbiAgICAgICAgICAgICBzaW5jZSB3ZSBoYXZlIG5vIGlkZWEgaG93IHRvIGRpc3Rpbmd1aXNoIHRoZW0uICovXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRhZyA9ICgodi5sZW5ndGggLSAxKSA8PCAxMCkgfCB2WzBdO1xuICAgICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdGFnKTtcbiAgICAgICAgZm9yIChpID0gMSwgbGVuID0gdi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlmICh3ciA+PSBzeikgYnJlYWs7XG4gICAgICAgICAgcXVldWVbd3IrK10gPSB2W2ldO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2FtbF9pc19tbF9ieXRlcyh2KSkge1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfYnl0ZXMoaCx2KVxuICAgICAgbnVtLS07XG4gICAgfSBlbHNlIGlmIChjYW1sX2lzX21sX3N0cmluZyh2KSkge1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfc3RyaW5nKGgsdilcbiAgICAgIG51bS0tO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHYgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2pzYnl0ZXMoaCx2KVxuICAgICAgbnVtLS07XG4gICAgfSBlbHNlIGlmICh2ID09PSAodnwwKSkge1xuICAgICAgLy8gSW50ZWdlclxuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHYrdisxKTtcbiAgICAgIG51bS0tO1xuICAgIH0gZWxzZSBpZiAodiA9PT0gK3YpIHtcbiAgICAgIC8vIEZsb2F0XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9mbG9hdChoLHYpO1xuICAgICAgbnVtLS07XG4gICAgfVxuICB9XG4gIGggPSBjYW1sX2hhc2hfbWl4X2ZpbmFsKGgpO1xuICByZXR1cm4gaCAmIDB4M0ZGRkZGRkY7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2hhc2hcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfZmluYWwsIGNhbWxfaGFzaF9taXhfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19oYXNoKGgsIHYpe1xuICB2YXIgaCA9IGNhbWxfaGFzaF9taXhfc3RyaW5nKGgsdik7XG4gIHZhciBoID0gY2FtbF9oYXNoX21peF9maW5hbChoKTtcbiAgcmV0dXJuIGggJiAweDNGRkZGRkZGO1xufVxuIiwiLy9Qcm92aWRlczogQmFzZV9pbnRlcm5hbGhhc2hfZm9sZF9pbnQ2NFxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9pbnQ2NFxudmFyIEJhc2VfaW50ZXJuYWxoYXNoX2ZvbGRfaW50NjQgPSBjYW1sX2hhc2hfbWl4X2ludDY0O1xuLy9Qcm92aWRlczogQmFzZV9pbnRlcm5hbGhhc2hfZm9sZF9pbnRcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfaW50XG52YXIgQmFzZV9pbnRlcm5hbGhhc2hfZm9sZF9pbnQgPSBjYW1sX2hhc2hfbWl4X2ludDtcbi8vUHJvdmlkZXM6IEJhc2VfaW50ZXJuYWxoYXNoX2ZvbGRfZmxvYXRcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfZmxvYXRcbnZhciBCYXNlX2ludGVybmFsaGFzaF9mb2xkX2Zsb2F0ID0gY2FtbF9oYXNoX21peF9mbG9hdDtcbi8vUHJvdmlkZXM6IEJhc2VfaW50ZXJuYWxoYXNoX2ZvbGRfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X3N0cmluZ1xudmFyIEJhc2VfaW50ZXJuYWxoYXNoX2ZvbGRfc3RyaW5nID0gY2FtbF9oYXNoX21peF9zdHJpbmc7XG4vL1Byb3ZpZGVzOiBCYXNlX2ludGVybmFsaGFzaF9nZXRfaGFzaF92YWx1ZVxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9maW5hbFxuZnVuY3Rpb24gQmFzZV9pbnRlcm5hbGhhc2hfZ2V0X2hhc2hfdmFsdWUoc2VlZCkge1xuICB2YXIgaCA9IGNhbWxfaGFzaF9taXhfZmluYWwoc2VlZCk7XG4gIHJldHVybiBoICYgMHgzRkZGRkZGRjtcbn1cbiIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0aXZlIENhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgKi9cbi8qICBlbiBBdXRvbWF0aXF1ZS4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgICAgKi9cbi8qICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSwgd2l0aCAgICAgKi9cbi8qICB0aGUgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gZmlsZSAuLi9MSUNFTlNFLiAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLyogJElkOiBwYXJzaW5nLmMgODk4MyAyMDA4LTA4LTA2IDA5OjM4OjI1WiB4bGVyb3kgJCAqL1xuXG4vKiBUaGUgUERBIGF1dG9tYXRvbiBmb3IgcGFyc2VycyBnZW5lcmF0ZWQgYnkgY2FtbHlhY2MgKi9cblxuLyogVGhlIHB1c2hkb3duIGF1dG9tYXRhICovXG5cbi8vUHJvdmlkZXM6IGNhbWxfcGFyc2VyX3RyYWNlXG52YXIgY2FtbF9wYXJzZXJfdHJhY2UgPSAwO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3BhcnNlX2VuZ2luZVxuLy9SZXF1aXJlczogY2FtbF9sZXhfYXJyYXksIGNhbWxfcGFyc2VyX3RyYWNlLGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX21sX291dHB1dCwgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nLCBNbEJ5dGVzXG5mdW5jdGlvbiBjYW1sX3BhcnNlX2VuZ2luZSh0YWJsZXMsIGVudiwgY21kLCBhcmcpXG57XG4gIHZhciBFUlJDT0RFID0gMjU2O1xuXG4gIC8vdmFyIFNUQVJUID0gMDtcbiAgLy92YXIgVE9LRU5fUkVBRCA9IDE7XG4gIC8vdmFyIFNUQUNLU19HUk9XTl8xID0gMjtcbiAgLy92YXIgU1RBQ0tTX0dST1dOXzIgPSAzO1xuICAvL3ZhciBTRU1BTlRJQ19BQ1RJT05fQ09NUFVURUQgPSA0O1xuICAvL3ZhciBFUlJPUl9ERVRFQ1RFRCA9IDU7XG4gIHZhciBsb29wID0gNjtcbiAgdmFyIHRlc3RzaGlmdCA9IDc7XG4gIHZhciBzaGlmdCA9IDg7XG4gIHZhciBzaGlmdF9yZWNvdmVyID0gOTtcbiAgdmFyIHJlZHVjZSA9IDEwO1xuXG4gIHZhciBSRUFEX1RPS0VOID0gMDtcbiAgdmFyIFJBSVNFX1BBUlNFX0VSUk9SID0gMTtcbiAgdmFyIEdST1dfU1RBQ0tTXzEgPSAyO1xuICB2YXIgR1JPV19TVEFDS1NfMiA9IDM7XG4gIHZhciBDT01QVVRFX1NFTUFOVElDX0FDVElPTiA9IDQ7XG4gIHZhciBDQUxMX0VSUk9SX0ZVTkNUSU9OID0gNTtcblxuICB2YXIgZW52X3Nfc3RhY2sgPSAxO1xuICB2YXIgZW52X3Zfc3RhY2sgPSAyO1xuICB2YXIgZW52X3N5bWJfc3RhcnRfc3RhY2sgPSAzO1xuICB2YXIgZW52X3N5bWJfZW5kX3N0YWNrID0gNDtcbiAgdmFyIGVudl9zdGFja3NpemUgPSA1O1xuICB2YXIgZW52X3N0YWNrYmFzZSA9IDY7XG4gIHZhciBlbnZfY3Vycl9jaGFyID0gNztcbiAgdmFyIGVudl9sdmFsID0gODtcbiAgdmFyIGVudl9zeW1iX3N0YXJ0ID0gOTtcbiAgdmFyIGVudl9zeW1iX2VuZCA9IDEwO1xuICB2YXIgZW52X2FzcCA9IDExO1xuICB2YXIgZW52X3J1bGVfbGVuID0gMTI7XG4gIHZhciBlbnZfcnVsZV9udW1iZXIgPSAxMztcbiAgdmFyIGVudl9zcCA9IDE0O1xuICB2YXIgZW52X3N0YXRlID0gMTU7XG4gIHZhciBlbnZfZXJyZmxhZyA9IDE2O1xuXG4gIC8vIHZhciBfdGJsX2FjdGlvbnMgPSAxO1xuICB2YXIgdGJsX3RyYW5zbF9jb25zdCA9IDI7XG4gIHZhciB0YmxfdHJhbnNsX2Jsb2NrID0gMztcbiAgdmFyIHRibF9saHMgPSA0O1xuICB2YXIgdGJsX2xlbiA9IDU7XG4gIHZhciB0YmxfZGVmcmVkID0gNjtcbiAgdmFyIHRibF9kZ290byA9IDc7XG4gIHZhciB0Ymxfc2luZGV4ID0gODtcbiAgdmFyIHRibF9yaW5kZXggPSA5O1xuICB2YXIgdGJsX2dpbmRleCA9IDEwO1xuICB2YXIgdGJsX3RhYmxlc2l6ZSA9IDExO1xuICB2YXIgdGJsX3RhYmxlID0gMTI7XG4gIHZhciB0YmxfY2hlY2sgPSAxMztcbiAgLy8gdmFyIF90YmxfZXJyb3JfZnVuY3Rpb24gPSAxNDtcbiAgdmFyIHRibF9uYW1lc19jb25zdCA9IDE1O1xuICB2YXIgdGJsX25hbWVzX2Jsb2NrID0gMTY7XG5cblxuICBmdW5jdGlvbiBsb2coeCkge1xuICAgIHZhciBzID0gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyh4ICsgXCJcXG5cIik7XG4gICAgY2FtbF9tbF9vdXRwdXQoMiwgcywgMCwgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRva2VuX25hbWUobmFtZXMsIG51bWJlcilcbiAge1xuICAgIHZhciBzdHIgPSBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhuYW1lcyk7XG4gICAgaWYgKHN0clswXSA9PSAnXFx4MDAnKVxuICAgICAgcmV0dXJuIFwiPHVua25vd24gdG9rZW4+XCI7XG4gICAgcmV0dXJuIHN0ci5zcGxpdCgnXFx4MDAnKVtudW1iZXJdO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRfdG9rZW4oc3RhdGUsIHRvaylcbiAge1xuICAgIHZhciB0b2tlbiwga2luZDtcbiAgICBpZiAodG9rIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIHRva2VuID0gdG9rZW5fbmFtZSh0YWJsZXNbdGJsX25hbWVzX2Jsb2NrXSwgdG9rWzBdKTtcbiAgICAgIGlmICh0eXBlb2YgdG9rWzFdID09IFwibnVtYmVyXCIpXG4gICAgICAgIGtpbmQgPSBcIlwiICsgdG9rWzFdO1xuICAgICAgZWxzZSBpZiAodHlwZW9mIHRva1sxXSA9PSBcInN0cmluZ1wiKVxuICAgICAgICBraW5kID0gdG9rWzFdXG4gICAgICBlbHNlIGlmICh0b2tbMV0gaW5zdGFuY2VvZiBNbEJ5dGVzKVxuICAgICAgICBraW5kID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyh0b2tbMV0pXG4gICAgICBlbHNlXG4gICAgICAgIGtpbmQgPSBcIl9cIlxuICAgICAgbG9nKFwiU3RhdGUgXCIgKyBzdGF0ZSArIFwiOiByZWFkIHRva2VuIFwiICsgdG9rZW4gKyBcIihcIiArIGtpbmQgKyBcIilcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRva2VuID0gdG9rZW5fbmFtZSh0YWJsZXNbdGJsX25hbWVzX2NvbnN0XSwgdG9rKTtcbiAgICAgIGxvZyhcIlN0YXRlIFwiICsgc3RhdGUgKyBcIjogcmVhZCB0b2tlbiBcIiArIHRva2VuKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXRhYmxlcy5kZ290bykge1xuICAgIHRhYmxlcy5kZWZyZWQgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9kZWZyZWRdKTtcbiAgICB0YWJsZXMuc2luZGV4ID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0Ymxfc2luZGV4XSk7XG4gICAgdGFibGVzLmNoZWNrICA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX2NoZWNrXSk7XG4gICAgdGFibGVzLnJpbmRleCA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX3JpbmRleF0pO1xuICAgIHRhYmxlcy50YWJsZSAgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF90YWJsZV0pO1xuICAgIHRhYmxlcy5sZW4gICAgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9sZW5dKTtcbiAgICB0YWJsZXMubGhzICAgID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0YmxfbGhzXSk7XG4gICAgdGFibGVzLmdpbmRleCA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX2dpbmRleF0pO1xuICAgIHRhYmxlcy5kZ290byAgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9kZ290b10pO1xuICB9XG5cbiAgdmFyIHJlcyA9IDAsIG4sIG4xLCBuMiwgc3RhdGUxO1xuXG4gIC8vIFJFU1RPUkVcbiAgdmFyIHNwID0gZW52W2Vudl9zcF07XG4gIHZhciBzdGF0ZSA9IGVudltlbnZfc3RhdGVdO1xuICB2YXIgZXJyZmxhZyA9IGVudltlbnZfZXJyZmxhZ107XG5cbiAgZXhpdDpmb3IgKDs7KSB7XG4gICAgbmV4dDpzd2l0Y2goY21kKSB7XG4gICAgY2FzZSAwOi8vU1RBUlQ6XG4gICAgICBzdGF0ZSA9IDA7XG4gICAgICBlcnJmbGFnID0gMDtcbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuXG4gICAgY2FzZSA2Oi8vbG9vcDpcbiAgICAgIG4gPSB0YWJsZXMuZGVmcmVkW3N0YXRlXTtcbiAgICAgIGlmIChuICE9IDApIHsgY21kID0gcmVkdWNlOyBicmVhazsgfVxuICAgICAgaWYgKGVudltlbnZfY3Vycl9jaGFyXSA+PSAwKSB7IGNtZCA9IHRlc3RzaGlmdDsgYnJlYWs7IH1cbiAgICAgIHJlcyA9IFJFQURfVE9LRU47XG4gICAgICBicmVhayBleGl0O1xuICAgICAgLyogVGhlIE1MIGNvZGUgY2FsbHMgdGhlIGxleGVyIGFuZCB1cGRhdGVzICovXG4gICAgICAvKiBzeW1iX3N0YXJ0IGFuZCBzeW1iX2VuZCAqL1xuICAgIGNhc2UgMTovL1RPS0VOX1JFQUQ6XG4gICAgICBpZiAoYXJnIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgZW52W2Vudl9jdXJyX2NoYXJdID0gdGFibGVzW3RibF90cmFuc2xfYmxvY2tdW2FyZ1swXSArIDFdO1xuICAgICAgICBlbnZbZW52X2x2YWxdID0gYXJnWzFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW52W2Vudl9jdXJyX2NoYXJdID0gdGFibGVzW3RibF90cmFuc2xfY29uc3RdW2FyZyArIDFdO1xuICAgICAgICBlbnZbZW52X2x2YWxdID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChjYW1sX3BhcnNlcl90cmFjZSkgcHJpbnRfdG9rZW4gKHN0YXRlLCBhcmcpO1xuICAgICAgLy8gRmFsbCB0aHJvdWdoXG5cbiAgICBjYXNlIDc6Ly90ZXN0c2hpZnQ6XG4gICAgICBuMSA9IHRhYmxlcy5zaW5kZXhbc3RhdGVdO1xuICAgICAgbjIgPSBuMSArIGVudltlbnZfY3Vycl9jaGFyXTtcbiAgICAgIGlmIChuMSAhPSAwICYmIG4yID49IDAgJiYgbjIgPD0gdGFibGVzW3RibF90YWJsZXNpemVdICYmXG4gICAgICAgICAgdGFibGVzLmNoZWNrW24yXSA9PSBlbnZbZW52X2N1cnJfY2hhcl0pIHtcbiAgICAgICAgY21kID0gc2hpZnQ7IGJyZWFrO1xuICAgICAgfVxuICAgICAgbjEgPSB0YWJsZXMucmluZGV4W3N0YXRlXTtcbiAgICAgIG4yID0gbjEgKyBlbnZbZW52X2N1cnJfY2hhcl07XG4gICAgICBpZiAobjEgIT0gMCAmJiBuMiA+PSAwICYmIG4yIDw9IHRhYmxlc1t0YmxfdGFibGVzaXplXSAmJlxuICAgICAgICAgIHRhYmxlcy5jaGVja1tuMl0gPT0gZW52W2Vudl9jdXJyX2NoYXJdKSB7XG4gICAgICAgIG4gPSB0YWJsZXMudGFibGVbbjJdO1xuICAgICAgICBjbWQgPSByZWR1Y2U7IGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGVycmZsYWcgPD0gMCkge1xuICAgICAgICByZXMgPSBDQUxMX0VSUk9SX0ZVTkNUSU9OO1xuICAgICAgICBicmVhayBleGl0O1xuICAgICAgfVxuICAgICAgLy8gRmFsbCB0aHJvdWdoXG4gICAgICAvKiBUaGUgTUwgY29kZSBjYWxscyB0aGUgZXJyb3IgZnVuY3Rpb24gKi9cbiAgICBjYXNlIDU6Ly9FUlJPUl9ERVRFQ1RFRDpcbiAgICAgIGlmIChlcnJmbGFnIDwgMykge1xuICAgICAgICBlcnJmbGFnID0gMztcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIHN0YXRlMSA9IGVudltlbnZfc19zdGFja11bc3AgKyAxXTtcbiAgICAgICAgICBuMSA9IHRhYmxlcy5zaW5kZXhbc3RhdGUxXTtcbiAgICAgICAgICBuMiA9IG4xICsgRVJSQ09ERTtcbiAgICAgICAgICBpZiAobjEgIT0gMCAmJiBuMiA+PSAwICYmIG4yIDw9IHRhYmxlc1t0YmxfdGFibGVzaXplXSAmJlxuICAgICAgICAgICAgICB0YWJsZXMuY2hlY2tbbjJdID09IEVSUkNPREUpIHtcbiAgICAgICAgICAgIGlmIChjYW1sX3BhcnNlcl90cmFjZSlcbiAgICAgICAgICAgICAgbG9nKFwiUmVjb3ZlcmluZyBpbiBzdGF0ZSBcIiArIHN0YXRlMSk7XG4gICAgICAgICAgICBjbWQgPSBzaGlmdF9yZWNvdmVyOyBicmVhayBuZXh0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoY2FtbF9wYXJzZXJfdHJhY2UpXG4gICAgICAgICAgICAgIGxvZyhcIkRpc2NhcmRpbmcgc3RhdGUgXCIgKyBzdGF0ZTEpO1xuICAgICAgICAgICAgaWYgKHNwIDw9IGVudltlbnZfc3RhY2tiYXNlXSkge1xuICAgICAgICAgICAgICBpZiAoY2FtbF9wYXJzZXJfdHJhY2UpXG4gICAgICAgICAgICAgICAgbG9nKFwiTm8gbW9yZSBzdGF0ZXMgdG8gZGlzY2FyZFwiKTtcbiAgICAgICAgICAgICAgcmV0dXJuIFJBSVNFX1BBUlNFX0VSUk9SO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogVGhlIE1MIGNvZGUgcmFpc2VzIFBhcnNlX2Vycm9yICovXG4gICAgICAgICAgICBzcC0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGVudltlbnZfY3Vycl9jaGFyXSA9PSAwKVxuICAgICAgICAgIHJldHVybiBSQUlTRV9QQVJTRV9FUlJPUjsgLyogVGhlIE1MIGNvZGUgcmFpc2VzIFBhcnNlX2Vycm9yICovXG4gICAgICAgIGlmIChjYW1sX3BhcnNlcl90cmFjZSlcbiAgICAgICAgICBsb2coXCJEaXNjYXJkaW5nIGxhc3QgdG9rZW4gcmVhZFwiKTtcbiAgICAgICAgZW52W2Vudl9jdXJyX2NoYXJdID0gLTE7XG4gICAgICAgIGNtZCA9IGxvb3A7IGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gRmFsbCB0aHJvdWdoXG4gICAgY2FzZSA4Oi8vc2hpZnQ6XG4gICAgICBlbnZbZW52X2N1cnJfY2hhcl0gPSAtMTtcbiAgICAgIGlmIChlcnJmbGFnID4gMCkgZXJyZmxhZy0tO1xuICAgICAgLy8gRmFsbCB0aHJvdWdoXG4gICAgY2FzZSA5Oi8vc2hpZnRfcmVjb3ZlcjpcbiAgICAgIGlmIChjYW1sX3BhcnNlcl90cmFjZSlcbiAgICAgICAgbG9nKFwiU3RhdGUgXCIgKyBzdGF0ZSArIFwiOiBzaGlmdCB0byBzdGF0ZSBcIiArIHRhYmxlcy50YWJsZVtuMl0pO1xuICAgICAgc3RhdGUgPSB0YWJsZXMudGFibGVbbjJdO1xuICAgICAgc3ArKztcbiAgICAgIGlmIChzcCA+PSBlbnZbZW52X3N0YWNrc2l6ZV0pIHtcbiAgICAgICAgcmVzID0gR1JPV19TVEFDS1NfMTtcbiAgICAgICAgYnJlYWsgZXhpdDtcbiAgICAgIH1cbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuICAgICAgLyogVGhlIE1MIGNvZGUgcmVzaXplcyB0aGUgc3RhY2tzICovXG4gICAgY2FzZSAyOi8vU1RBQ0tTX0dST1dOXzE6XG4gICAgICBlbnZbZW52X3Nfc3RhY2tdW3NwICsgMV0gPSBzdGF0ZTtcbiAgICAgIGVudltlbnZfdl9zdGFja11bc3AgKyAxXSA9IGVudltlbnZfbHZhbF07XG4gICAgICBlbnZbZW52X3N5bWJfc3RhcnRfc3RhY2tdW3NwICsgMV0gPSBlbnZbZW52X3N5bWJfc3RhcnRdO1xuICAgICAgZW52W2Vudl9zeW1iX2VuZF9zdGFja11bc3AgKyAxXSA9IGVudltlbnZfc3ltYl9lbmRdO1xuICAgICAgY21kID0gbG9vcDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAxMDovL3JlZHVjZTpcbiAgICAgIGlmIChjYW1sX3BhcnNlcl90cmFjZSlcbiAgICAgICAgbG9nKFwiU3RhdGUgXCIgKyBzdGF0ZSArIFwiOiByZWR1Y2UgYnkgcnVsZSBcIiArIG4pO1xuICAgICAgdmFyIG0gPSB0YWJsZXMubGVuW25dO1xuICAgICAgZW52W2Vudl9hc3BdID0gc3A7XG4gICAgICBlbnZbZW52X3J1bGVfbnVtYmVyXSA9IG47XG4gICAgICBlbnZbZW52X3J1bGVfbGVuXSA9IG07XG4gICAgICBzcCA9IHNwIC0gbSArIDE7XG4gICAgICBtID0gdGFibGVzLmxoc1tuXTtcbiAgICAgIHN0YXRlMSA9IGVudltlbnZfc19zdGFja11bc3BdO1xuICAgICAgbjEgPSB0YWJsZXMuZ2luZGV4W21dO1xuICAgICAgbjIgPSBuMSArIHN0YXRlMTtcbiAgICAgIGlmIChuMSAhPSAwICYmIG4yID49IDAgJiYgbjIgPD0gdGFibGVzW3RibF90YWJsZXNpemVdICYmXG4gICAgICAgICAgdGFibGVzLmNoZWNrW24yXSA9PSBzdGF0ZTEpXG4gICAgICAgIHN0YXRlID0gdGFibGVzLnRhYmxlW24yXTtcbiAgICAgIGVsc2VcbiAgICAgICAgc3RhdGUgPSB0YWJsZXMuZGdvdG9bbV07XG4gICAgICBpZiAoc3AgPj0gZW52W2Vudl9zdGFja3NpemVdKSB7XG4gICAgICAgIHJlcyA9IEdST1dfU1RBQ0tTXzI7XG4gICAgICAgIGJyZWFrIGV4aXQ7XG4gICAgICB9XG4gICAgICAvLyBGYWxsIHRocm91Z2hcbiAgICAgIC8qIFRoZSBNTCBjb2RlIHJlc2l6ZXMgdGhlIHN0YWNrcyAqL1xuICAgIGNhc2UgMzovL1NUQUNLU19HUk9XTl8yOlxuICAgICAgcmVzID0gQ09NUFVURV9TRU1BTlRJQ19BQ1RJT047XG4gICAgICBicmVhayBleGl0O1xuICAgICAgLyogVGhlIE1MIGNvZGUgY2FsbHMgdGhlIHNlbWFudGljIGFjdGlvbiAqL1xuICAgIGNhc2UgNDovL1NFTUFOVElDX0FDVElPTl9DT01QVVRFRDpcbiAgICAgIGVudltlbnZfc19zdGFja11bc3AgKyAxXSA9IHN0YXRlO1xuICAgICAgZW52W2Vudl92X3N0YWNrXVtzcCArIDFdID0gYXJnO1xuICAgICAgdmFyIGFzcCA9IGVudltlbnZfYXNwXTtcbiAgICAgIGVudltlbnZfc3ltYl9lbmRfc3RhY2tdW3NwICsgMV0gPSBlbnZbZW52X3N5bWJfZW5kX3N0YWNrXVthc3AgKyAxXTtcbiAgICAgIGlmIChzcCA+IGFzcCkge1xuICAgICAgICAvKiBUaGlzIGlzIGFuIGVwc2lsb24gcHJvZHVjdGlvbi4gVGFrZSBzeW1iX3N0YXJ0IGVxdWFsIHRvIHN5bWJfZW5kLiAqL1xuICAgICAgICBlbnZbZW52X3N5bWJfc3RhcnRfc3RhY2tdW3NwICsgMV0gPSBlbnZbZW52X3N5bWJfZW5kX3N0YWNrXVthc3AgKyAxXTtcbiAgICAgIH1cbiAgICAgIGNtZCA9IGxvb3A7IGJyZWFrO1xuICAgICAgLyogU2hvdWxkIG5vdCBoYXBwZW4gKi9cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFJBSVNFX1BBUlNFX0VSUk9SO1xuICAgIH1cbiAgfVxuICAvLyBTQVZFXG4gIGVudltlbnZfc3BdID0gc3A7XG4gIGVudltlbnZfc3RhdGVdID0gc3RhdGU7XG4gIGVudltlbnZfZXJyZmxhZ10gPSBlcnJmbGFnO1xuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3NldF9wYXJzZXJfdHJhY2UgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfcGFyc2VyX3RyYWNlXG5mdW5jdGlvbiBjYW1sX3NldF9wYXJzZXJfdHJhY2UoYm9vbCkge1xuICB2YXIgb2xkZmxhZyA9IGNhbWxfcGFyc2VyX3RyYWNlO1xuICBjYW1sX3BhcnNlcl90cmFjZSA9IGJvb2w7XG4gIHJldHVybiBvbGRmbGFnO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF91cGRhdGVfZHVtbXlcbmZ1bmN0aW9uIGNhbWxfdXBkYXRlX2R1bW15ICh4LCB5KSB7XG4gIGlmKCB0eXBlb2YgeT09PVwiZnVuY3Rpb25cIiApIHsgeC5mdW4gPSB5OyByZXR1cm4gMDsgfVxuICBpZiggeS5mdW4gKSB7IHguZnVuID0geS5mdW47IHJldHVybiAwOyB9XG4gIHZhciBpID0geS5sZW5ndGg7IHdoaWxlIChpLS0pIHhbaV0gPSB5W2ldOyByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfaXNfYmxvY2sgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9vYmpfaXNfYmxvY2sgKHgpIHsgcmV0dXJuICsoeCBpbnN0YW5jZW9mIEFycmF5KTsgfVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3RhZ1xuLy9SZXF1aXJlczogY2FtbF9pc19tbF9ieXRlcywgY2FtbF9pc19tbF9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfb2JqX3RhZyAoeCkge1xuICBpZiAoKHggaW5zdGFuY2VvZiBBcnJheSkgJiYgeFswXSA9PSAoeFswXSA+Pj4gMCkpXG4gICAgcmV0dXJuIHhbMF1cbiAgZWxzZSBpZiAoY2FtbF9pc19tbF9ieXRlcyh4KSlcbiAgICByZXR1cm4gMjUyXG4gIGVsc2UgaWYgKGNhbWxfaXNfbWxfc3RyaW5nKHgpKVxuICAgIHJldHVybiAyNTJcbiAgZWxzZSBpZiAoKHggaW5zdGFuY2VvZiBGdW5jdGlvbikgfHwgdHlwZW9mIHggPT0gXCJmdW5jdGlvblwiKVxuICAgIHJldHVybiAyNDdcbiAgZWxzZSBpZiAoeCAmJiB4LmNhbWxfY3VzdG9tKVxuICAgIHJldHVybiAyNTVcbiAgZWxzZVxuICAgIHJldHVybiAxMDAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3NldF90YWcgKG11dGFibGUsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9vYmpfc2V0X3RhZyAoeCwgdGFnKSB7IHhbMF0gPSB0YWc7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX29ial9ibG9jayBjb25zdCAoY29uc3QsY29uc3QpXG5mdW5jdGlvbiBjYW1sX29ial9ibG9jayAodGFnLCBzaXplKSB7XG4gIHZhciBvID0gbmV3IEFycmF5KHNpemUrMSk7XG4gIG9bMF09dGFnO1xuICBmb3IgKHZhciBpID0gMTsgaSA8PSBzaXplOyBpKyspIG9baV0gPSAwO1xuICByZXR1cm4gbztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfd2l0aF90YWdcbmZ1bmN0aW9uIGNhbWxfb2JqX3dpdGhfdGFnKHRhZyx4KSB7XG4gIHZhciBsID0geC5sZW5ndGg7XG4gIHZhciBhID0gbmV3IEFycmF5KGwpO1xuICBhWzBdID0gdGFnO1xuICBmb3IodmFyIGkgPSAxOyBpIDwgbDsgaSsrICkgYVtpXSA9IHhbaV07XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial9kdXAgbXV0YWJsZSAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX29ial9kdXAgKHgpIHtcbiAgdmFyIGwgPSB4Lmxlbmd0aDtcbiAgdmFyIGEgPSBuZXcgQXJyYXkobCk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsOyBpKysgKSBhW2ldID0geFtpXTtcbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3RydW5jYXRlIChtdXRhYmxlLCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9vYmpfdHJ1bmNhdGUgKHgsIHMpIHtcbiAgaWYgKHM8PTAgfHwgcyArIDEgPiB4Lmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiT2JqLnRydW5jYXRlXCIpO1xuICBpZiAoeC5sZW5ndGggIT0gcyArIDEpIHgubGVuZ3RoID0gcyArIDE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial9tYWtlX2ZvcndhcmRcbmZ1bmN0aW9uIGNhbWxfb2JqX21ha2VfZm9yd2FyZCAoYix2KSB7XG4gIGJbMF09MjUwO1xuICBiWzFdPXY7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX2NvbXBhcmVfYW5kX3N3YXBcbmZ1bmN0aW9uIGNhbWxfb2JqX2NvbXBhcmVfYW5kX3N3YXAoeCxpLG9sZCxuKXtcbiAgaWYoeFtpKzFdID09IG9sZCkge1xuICAgIHhbaSsxXSA9IG47XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfaXNfc2hhcmVkXG5mdW5jdGlvbiBjYW1sX29ial9pc19zaGFyZWQoeCl7XG4gIHJldHVybiAxXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbGF6eV9tYWtlX2ZvcndhcmQgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9sYXp5X21ha2VfZm9yd2FyZCAodikgeyByZXR1cm4gWzI1MCwgdl07IH1cblxuLy8vLy8vLy8vLy8vLyBDYW1saW50ZXJuYWxPT1xuLy9Qcm92aWRlczogY2FtbF9nZXRfcHVibGljX21ldGhvZCBjb25zdFxudmFyIGNhbWxfbWV0aG9kX2NhY2hlID0gW107XG5mdW5jdGlvbiBjYW1sX2dldF9wdWJsaWNfbWV0aG9kIChvYmosIHRhZywgY2FjaGVpZCkge1xuICB2YXIgbWV0aHMgPSBvYmpbMV07XG4gIHZhciBvZnMgPSBjYW1sX21ldGhvZF9jYWNoZVtjYWNoZWlkXTtcbiAgaWYgKG9mcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gTWFrZSBzdXJlIHRoZSBhcnJheSBpcyBub3Qgc3BhcnNlXG4gICAgZm9yICh2YXIgaSA9IGNhbWxfbWV0aG9kX2NhY2hlLmxlbmd0aDsgaSA8IGNhY2hlaWQ7IGkrKylcbiAgICAgIGNhbWxfbWV0aG9kX2NhY2hlW2ldID0gMDtcbiAgfSBlbHNlIGlmIChtZXRoc1tvZnNdID09PSB0YWcpIHtcbiAgICByZXR1cm4gbWV0aHNbb2ZzIC0gMV07XG4gIH1cbiAgdmFyIGxpID0gMywgaGkgPSBtZXRoc1sxXSAqIDIgKyAxLCBtaTtcbiAgd2hpbGUgKGxpIDwgaGkpIHtcbiAgICBtaSA9ICgobGkraGkpID4+IDEpIHwgMTtcbiAgICBpZiAodGFnIDwgbWV0aHNbbWkrMV0pIGhpID0gbWktMjtcbiAgICBlbHNlIGxpID0gbWk7XG4gIH1cbiAgY2FtbF9tZXRob2RfY2FjaGVbY2FjaGVpZF0gPSBsaSArIDE7XG4gIC8qIHJldHVybiAwIGlmIHRhZyBpcyBub3QgdGhlcmUgKi9cbiAgcmV0dXJuICh0YWcgPT0gbWV0aHNbbGkrMV0gPyBtZXRoc1tsaV0gOiAwKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vb19sYXN0X2lkXG52YXIgY2FtbF9vb19sYXN0X2lkID0gMDtcblxuLy9Qcm92aWRlczogY2FtbF9zZXRfb29faWRcbi8vUmVxdWlyZXM6IGNhbWxfb29fbGFzdF9pZFxuZnVuY3Rpb24gY2FtbF9zZXRfb29faWQgKGIpIHtcbiAgYlsyXT1jYW1sX29vX2xhc3RfaWQrKztcbiAgcmV0dXJuIGI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZnJlc2hfb29faWQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfb29fbGFzdF9pZFxuZnVuY3Rpb24gY2FtbF9mcmVzaF9vb19pZCgpIHtcbiAgcmV0dXJuIGNhbWxfb29fbGFzdF9pZCsrO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial9yYXdfZmllbGRcbmZ1bmN0aW9uIGNhbWxfb2JqX3Jhd19maWVsZChvLGkpIHsgcmV0dXJuIG9baSsxXSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3NldF9yYXdfZmllbGRcbmZ1bmN0aW9uIGNhbWxfb2JqX3NldF9yYXdfZmllbGQobyxpLHYpIHsgcmV0dXJuIG9baSsxXSA9IHYgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial9yZWFjaGFibGVfd29yZHNcbmZ1bmN0aW9uIGNhbWxfb2JqX3JlYWNoYWJsZV93b3JkcyhvKSB7IHJldHVybiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX2FkZF9vZmZzZXRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfb2JqX2FkZF9vZmZzZXQodixvZmZzZXQpIHtcbiAgY2FtbF9mYWlsd2l0aChcIk9iai5hZGRfb2Zmc2V0IGlzIG5vdCBzdXBwb3J0ZWRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3VwZGF0ZV90YWdcbmZ1bmN0aW9uIGNhbWxfb2JqX3VwZGF0ZV90YWcoYixvLG4pIHtcbiAgICBpZihiWzBdPT1vKSB7IGJbMF0gPSBuOyByZXR1cm4gMSB9XG4gICAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9sYXp5X3VwZGF0ZV90b19mb3JjaW5nXG4vL1JlcXVpcmVzOiBjYW1sX29ial90YWcsIGNhbWxfb2JqX3VwZGF0ZV90YWcsIGNhbWxfbWxfZG9tYWluX3VuaXF1ZV90b2tlblxuZnVuY3Rpb24gY2FtbF9sYXp5X3VwZGF0ZV90b19mb3JjaW5nKG8pIHtcbiAgdmFyIHQgPSBjYW1sX29ial90YWcobyk7XG4gIGlmKHQgIT0gMjQ2ICYmIHQgIT0gMjUwICYmIHQgIT0gMjQ0KVxuICAgIHJldHVybiA0XG4gIGlmKGNhbWxfb2JqX3VwZGF0ZV90YWcobywgMjQ2LCAyNDQpKSB7XG4gICAgcmV0dXJuIDBcbiAgfSBlbHNlIHtcbiAgICB2YXIgZmllbGQwID0gb1sxXTtcbiAgICB0ID0gb1swXVxuICAgIGlmKHQgPT0gMjQ0KSB7XG4gICAgICBpZihmaWVsZDAgPT0gY2FtbF9tbF9kb21haW5fdW5pcXVlX3Rva2VuKDApKVxuICAgICAgICByZXR1cm4gMVxuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gMlxuICAgIH0gZWxzZSBpZiAodCA9PSAyNTApIHtcbiAgICAgIHJldHVybiAzO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhc3NlcnQgdCA9IGxhenlfdGFnXG4gICAgICByZXR1cm4gMjtcbiAgICB9XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9sYXp5X3VwZGF0ZV90b19mb3J3YXJkXG4vL1JlcXVpcmVzOiBjYW1sX29ial91cGRhdGVfdGFnXG4gIGZ1bmN0aW9uIGNhbWxfbGF6eV91cGRhdGVfdG9fZm9yd2FyZChvKSB7XG4gIGNhbWxfb2JqX3VwZGF0ZV90YWcobywyNDQsMjUwKTtcbiAgcmV0dXJuIDA7IC8vIHVuaXRcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xhenlfcmVzZXRfdG9fbGF6eVxuLy9SZXF1aXJlczogY2FtbF9vYmpfdXBkYXRlX3RhZ1xuZnVuY3Rpb24gY2FtbF9sYXp5X3Jlc2V0X3RvX2xhenkobykge1xuICBjYW1sX29ial91cGRhdGVfdGFnKG8sMjQ0LDI0Nik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xhenlfcmVhZF9yZXN1bHRcbi8vUmVxdWlyZXM6IGNhbWxfb2JqX3RhZ1xuZnVuY3Rpb24gY2FtbF9sYXp5X3JlYWRfcmVzdWx0KG8pIHtcbiAgcmV0dXJuIChjYW1sX29ial90YWcobykgPT0gMjUwKT9vWzFdOm87XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9pc19jb250aW51YXRpb25fdGFnXG4vL1ZlcnNpb246IDwgNVxuZnVuY3Rpb24gY2FtbF9pc19jb250aW51YXRpb25fdGFnKHQpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaXNfY29udGludWF0aW9uX3RhZ1xuLy9WZXJzaW9uOiA+PSA1XG5mdW5jdGlvbiBjYW1sX2lzX2NvbnRpbnVhdGlvbl90YWcodCkge1xuICByZXR1cm4gKHQgPT0gMjQ1KSA/IDEgOiAwO1xufVxuIiwiLy9Qcm92aWRlczogY2FtbF9kb21haW5fZGxzXG52YXIgY2FtbF9kb21haW5fZGxzID0gWzBdO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2RvbWFpbl9kbHNfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2RvbWFpbl9kbHNcbmZ1bmN0aW9uIGNhbWxfZG9tYWluX2Rsc19zZXQoYSkge1xuICBjYW1sX2RvbWFpbl9kbHMgPSBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2RvbWFpbl9kbHNfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2RvbWFpbl9kbHNcbmZ1bmN0aW9uIGNhbWxfZG9tYWluX2Rsc19nZXQodW5pdCkge1xuICByZXR1cm4gY2FtbF9kb21haW5fZGxzO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfYXRvbWljX2xvYWRcbmZ1bmN0aW9uIGNhbWxfYXRvbWljX2xvYWQocmVmKXtcbiAgcmV0dXJuIHJlZlsxXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hdG9taWNfY2FzXG5mdW5jdGlvbiBjYW1sX2F0b21pY19jYXMocmVmLG8sbikge1xuICBpZihyZWZbMV0gPT09IG8pe1xuICAgIHJlZlsxXSA9IG47XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXRvbWljX2ZldGNoX2FkZFxuZnVuY3Rpb24gY2FtbF9hdG9taWNfZmV0Y2hfYWRkKHJlZiwgaSkge1xuICB2YXIgb2xkID0gcmVmWzFdO1xuICByZWZbMV0gKz0gaTtcbiAgcmV0dXJuIG9sZDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hdG9taWNfZXhjaGFuZ2VcbmZ1bmN0aW9uIGNhbWxfYXRvbWljX2V4Y2hhbmdlKHJlZiwgdikge1xuICB2YXIgciA9IHJlZlsxXTtcbiAgcmVmWzFdID0gdjtcbiAgcmV0dXJuIHI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfZG9tYWluX3VuaXF1ZV90b2tlblxudmFyIGNhbWxfbWxfZG9tYWluX3VuaXF1ZV90b2tlbl8gPSBbMF1cbmZ1bmN0aW9uIGNhbWxfbWxfZG9tYWluX3VuaXF1ZV90b2tlbih1bml0KSB7XG4gIHJldHVybiBjYW1sX21sX2RvbWFpbl91bmlxdWVfdG9rZW5fXG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9tbF9kb21haW5fc2V0X25hbWVcbmZ1bmN0aW9uIGNhbWxfbWxfZG9tYWluX3NldF9uYW1lKF9uYW1lKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JlY29tbWVuZGVkX2RvbWFpbl9jb3VudFxuZnVuY3Rpb24gY2FtbF9yZWNvbW1lbmRlZF9kb21haW5fY291bnQodW5pdCkgeyByZXR1cm4gMSB9XG5cblxuLy9Qcm92aWRlczogY2FtbF9kb21haW5faWRcbnZhciBjYW1sX2RvbWFpbl9pZCA9IDA7XG5cbi8vUHJvdmlkZXM6IGNhbWxfZG9tYWluX3NwYXduXG4vL1JlcXVpcmVzOiBjYW1sX21sX211dGV4X3VubG9ja1xuLy9SZXF1aXJlczogY2FtbF9kb21haW5faWRcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbGJhY2tcbnZhciBjYW1sX2RvbWFpbl9sYXRlc3RfaWR4ID0gMVxuZnVuY3Rpb24gY2FtbF9kb21haW5fc3Bhd24oZixtdXRleCl7XG4gICAgdmFyIGlkID0gY2FtbF9kb21haW5fbGF0ZXN0X2lkeCsrO1xuICAgIHZhciBvbGQgPSBjYW1sX2RvbWFpbl9pZDtcbiAgICBjYW1sX2RvbWFpbl9pZCA9IGlkO1xuICAgIGNhbWxfY2FsbGJhY2soZixbMF0pO1xuICAgIGNhbWxfZG9tYWluX2lkID0gb2xkO1xuICAgIGNhbWxfbWxfbXV0ZXhfdW5sb2NrKG11dGV4KTtcbiAgICByZXR1cm4gaWQ7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9tbF9kb21haW5faWRcbi8vUmVxdWlyZXM6IGNhbWxfZG9tYWluX2lkXG5mdW5jdGlvbiBjYW1sX21sX2RvbWFpbl9pZCh1bml0KXtcbiAgICByZXR1cm4gY2FtbF9kb21haW5faWQ7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9tbF9kb21haW5fY3B1X3JlbGF4XG5mdW5jdGlvbiBjYW1sX21sX2RvbWFpbl9jcHVfcmVsYXgodW5pdCl7XG4gICAgcmV0dXJuIDA7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbXBhcmVfdmFsX3RhZ1xuLy9SZXF1aXJlczogY2FtbF9pc19tbF9zdHJpbmcsIGNhbWxfaXNfbWxfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfY29tcGFyZV92YWxfdGFnKGEpe1xuICBpZiAodHlwZW9mIGEgPT09IFwibnVtYmVyXCIpIHJldHVybiAxMDAwOyAvLyBpbnRfdGFnICh3ZSB1c2UgaXQgZm9yIGFsbCBudW1iZXJzKVxuICBlbHNlIGlmIChjYW1sX2lzX21sX2J5dGVzKGEpKSByZXR1cm4gMjUyOyAvLyBzdHJpbmdfdGFnXG4gIGVsc2UgaWYgKGNhbWxfaXNfbWxfc3RyaW5nKGEpKSByZXR1cm4gMTI1MjsgLy8gb2NhbWwgc3RyaW5nIChpZiBkaWZmZXJlbnQgZnJvbSBieXRlcylcbiAgZWxzZSBpZiAoYSBpbnN0YW5jZW9mIEFycmF5ICYmIGFbMF0gPT09IChhWzBdPj4+MCkgJiYgYVswXSA8PSAyNTUpIHtcbiAgICAvLyBMb29rIGxpa2UgYW4gb2NhbWwgYmxvY2tcbiAgICB2YXIgdGFnID0gYVswXSB8IDA7XG4gICAgLy8gaWdub3JlIGRvdWJsZV9hcnJheV90YWcgYmVjYXVzZSB3ZSBjYW5ub3QgYWNjdXJhdGVseSBzZXRcbiAgICAvLyB0aGlzIHRhZyB3aGVuIHdlIGNyZWF0ZSBhbiBhcnJheSBvZiBmbG9hdC5cbiAgICByZXR1cm4gKHRhZyA9PSAyNTQpPzA6dGFnXG4gIH1cbiAgZWxzZSBpZiAoYSBpbnN0YW5jZW9mIFN0cmluZykgcmV0dXJuIDEyNTIwOyAvLyBqYXZhc2NyaXB0IHN0cmluZywgbGlrZSBzdHJpbmdfdGFnICgyNTIpXG4gIGVsc2UgaWYgKHR5cGVvZiBhID09IFwic3RyaW5nXCIpIHJldHVybiAxMjUyMDsgLy8gamF2YXNjcmlwdCBzdHJpbmcsIGxpa2Ugc3RyaW5nX3RhZyAoMjUyKVxuICBlbHNlIGlmIChhIGluc3RhbmNlb2YgTnVtYmVyKSByZXR1cm4gMTAwMDsgLy8gaW50X3RhZyAod2UgdXNlIGl0IGZvciBhbGwgbnVtYmVycylcbiAgZWxzZSBpZiAoYSAmJiBhLmNhbWxfY3VzdG9tKSByZXR1cm4gMTI1NTsgLy8gbGlrZSBjdXN0b21fdGFnICgyNTUpXG4gIGVsc2UgaWYgKGEgJiYgYS5jb21wYXJlKSByZXR1cm4gMTI1NjsgLy8gbGlrZSBjdXN0b21fdGFnICgyNTUpXG4gIGVsc2UgaWYgKHR5cGVvZiBhID09IFwiZnVuY3Rpb25cIikgcmV0dXJuIDEyNDc7IC8vIGxpa2UgY2xvc3VyZV90YWcgKDI0NylcbiAgZWxzZSBpZiAodHlwZW9mIGEgPT0gXCJzeW1ib2xcIikgcmV0dXJuIDEyNTE7XG4gIHJldHVybiAxMDAxOyAvL291dF9vZl9oZWFwX3RhZ1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b21cbi8vUmVxdWlyZXM6IGNhbWxfY3VzdG9tX29wc1xuZnVuY3Rpb24gY2FtbF9jb21wYXJlX3ZhbF9nZXRfY3VzdG9tKGEpe1xuICByZXR1cm4gY2FtbF9jdXN0b21fb3BzW2EuY2FtbF9jdXN0b21dICYmIGNhbWxfY3VzdG9tX29wc1thLmNhbWxfY3VzdG9tXS5jb21wYXJlO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbXBhcmVfdmFsX251bWJlcl9jdXN0b21cbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbVxuZnVuY3Rpb24gY2FtbF9jb21wYXJlX3ZhbF9udW1iZXJfY3VzdG9tKG51bSwgY3VzdG9tLCBzd2FwLCB0b3RhbCkge1xuICB2YXIgY29tcCA9IGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbShjdXN0b20pO1xuICBpZihjb21wKSB7XG4gICAgdmFyIHggPSAoc3dhcCA+IDApP2NvbXAoY3VzdG9tLG51bSx0b3RhbCk6Y29tcChudW0sY3VzdG9tLHRvdGFsKTtcbiAgICBpZih0b3RhbCAmJiB4ICE9IHgpIHJldHVybiBzd2FwOyAvLyB0b3RhbCAmJiBuYW5cbiAgICBpZigreCAhPSAreCkgcmV0dXJuICt4OyAvLyBuYW5cbiAgICBpZigoeCB8IDApICE9IDApIHJldHVybiAoeCB8IDApOyAvLyAhbmFuXG4gIH1cbiAgcmV0dXJuIHN3YXBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jb21wYXJlX3ZhbCAoY29uc3QsIGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfaW50X2NvbXBhcmUsIGNhbWxfc3RyaW5nX2NvbXBhcmUsIGNhbWxfYnl0ZXNfY29tcGFyZVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b20sIGNhbWxfY29tcGFyZV92YWxfdGFnXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsX251bWJlcl9jdXN0b21cbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfaXNfY29udGludWF0aW9uX3RhZ1xuZnVuY3Rpb24gY2FtbF9jb21wYXJlX3ZhbCAoYSwgYiwgdG90YWwpIHtcbiAgdmFyIHN0YWNrID0gW107XG4gIGZvcig7Oykge1xuICAgIGlmICghKHRvdGFsICYmIGEgPT09IGIpKSB7XG4gICAgICB2YXIgdGFnX2EgPSBjYW1sX2NvbXBhcmVfdmFsX3RhZyhhKTtcbiAgICAgIC8vIGZvcndhcmRfdGFnID9cbiAgICAgIGlmKHRhZ19hID09IDI1MCkgeyBhID0gYVsxXTsgY29udGludWUgfVxuXG4gICAgICB2YXIgdGFnX2IgPSBjYW1sX2NvbXBhcmVfdmFsX3RhZyhiKTtcbiAgICAgIC8vIGZvcndhcmRfdGFnID9cbiAgICAgIGlmKHRhZ19iID09IDI1MCkgeyBiID0gYlsxXTsgY29udGludWUgfVxuXG4gICAgICAvLyB0YWdzIGFyZSBkaWZmZXJlbnRcbiAgICAgIGlmKHRhZ19hICE9PSB0YWdfYikge1xuICAgICAgICBpZih0YWdfYSA9PSAxMDAwKSB7XG4gICAgICAgICAgaWYodGFnX2IgPT0gMTI1NSkgeyAvL2ltbWVkaWF0ZSBjYW4gY29tcGFyZSBhZ2FpbnN0IGN1c3RvbVxuICAgICAgICAgICAgcmV0dXJuIGNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbShhLCBiLCAtMSwgdG90YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gLTFcbiAgICAgICAgfVxuICAgICAgICBpZih0YWdfYiA9PSAxMDAwKSB7XG4gICAgICAgICAgaWYodGFnX2EgPT0gMTI1NSkgeyAvL2ltbWVkaWF0ZSBjYW4gY29tcGFyZSBhZ2FpbnN0IGN1c3RvbVxuICAgICAgICAgICAgcmV0dXJuIGNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbShiLCBhLCAxLCB0b3RhbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAxXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICh0YWdfYSA8IHRhZ19iKT8tMToxO1xuICAgICAgfVxuICAgICAgc3dpdGNoKHRhZ19hKXtcbiAgICAgICAgLy8gMjQ2OiBMYXp5X3RhZyBoYW5kbGVkIGJlbGxvd1xuICAgICAgY2FzZSAyNDc6IC8vIENsb3N1cmVfdGFnXG4gICAgICAgIC8vIENhbm5vdCBoYXBwZW5cbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY29tcGFyZTogZnVuY3Rpb25hbCB2YWx1ZVwiKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgMjQ4OiAvLyBPYmplY3RcbiAgICAgICAgdmFyIHggPSBjYW1sX2ludF9jb21wYXJlKGFbMl0sIGJbMl0pO1xuICAgICAgICBpZiAoeCAhPSAwKSByZXR1cm4gKHggfCAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI0OTogLy8gSW5maXhcbiAgICAgICAgLy8gQ2Fubm90IGhhcHBlblxuICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjb21wYXJlOiBmdW5jdGlvbmFsIHZhbHVlXCIpO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAyNTA6IC8vIEZvcndhcmQgdGFnXG4gICAgICAgIC8vIENhbm5vdCBoYXBwZW4sIGhhbmRsZWQgYWJvdmVcbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiZXF1YWw6IGdvdCBGb3J3YXJkX3RhZywgc2hvdWxkIG5vdCBoYXBwZW5cIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNTE6IC8vQWJzdHJhY3RcbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiZXF1YWw6IGFic3RyYWN0IHZhbHVlXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjUyOiAvLyBPQ2FtbCBieXRlc1xuICAgICAgICBpZiAoYSAhPT0gYikge1xuICAgICAgICAgIHZhciB4ID0gY2FtbF9ieXRlc19jb21wYXJlKGEsIGIpO1xuICAgICAgICAgIGlmICh4ICE9IDApIHJldHVybiAoeCB8IDApO1xuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjUzOiAvLyBEb3VibGVfdGFnXG4gICAgICAgIC8vIENhbm5vdCBoYXBwZW5cbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiZXF1YWw6IGdvdCBEb3VibGVfdGFnLCBzaG91bGQgbm90IGhhcHBlblwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI1NDogLy8gRG91YmxlX2FycmF5X3RhZ1xuICAgICAgICAvLyBDYW5ub3QgaGFwcGVuLCBoYW5kbGVkIGFib3ZlXG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImVxdWFsOiBnb3QgRG91YmxlX2FycmF5X3RhZywgc2hvdWxkIG5vdCBoYXBwZW5cIik7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDI1NTogLy8gQ3VzdG9tX3RhZ1xuICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJlcXVhbDogZ290IEN1c3RvbV90YWcsIHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTI0NzogLy8gRnVuY3Rpb25cbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY29tcGFyZTogZnVuY3Rpb25hbCB2YWx1ZVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyNTU6IC8vIEN1c3RvbVxuICAgICAgICB2YXIgY29tcCA9IGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbShhKTtcbiAgICAgICAgaWYoY29tcCAhPSBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b20oYikpe1xuICAgICAgICAgIHJldHVybiAoYS5jYW1sX2N1c3RvbTxiLmNhbWxfY3VzdG9tKT8tMToxO1xuICAgICAgICB9XG4gICAgICAgIGlmKCFjb21wKVxuICAgICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNvbXBhcmU6IGFic3RyYWN0IHZhbHVlXCIpO1xuICAgICAgICB2YXIgeCA9IGNvbXAoYSxiLHRvdGFsKTtcbiAgICAgICAgaWYoeCAhPSB4KXsgLy8gUHJvdGVjdCBhZ2FpbnN0IGludmFsaWQgVU5PUkRFUkVEXG4gICAgICAgICAgcmV0dXJuIHRvdGFsPy0xOng7XG4gICAgICAgIH1cbiAgICAgICAgaWYoeCAhPT0gKHh8MCkpeyAvLyBQcm90ZWN0IGFnYWluc3QgaW52YWxpZCByZXR1cm4gdmFsdWVcbiAgICAgICAgICByZXR1cm4gLTFcbiAgICAgICAgfVxuICAgICAgICBpZiAoeCAhPSAwKSByZXR1cm4gKHggfCAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyNTY6IC8vIGNvbXBhcmUgZnVuY3Rpb25cbiAgICAgICAgdmFyIHggPSBhLmNvbXBhcmUoYix0b3RhbCk7XG4gICAgICAgIGlmKHggIT0geCkgeyAvLyBQcm90ZWN0IGFnYWluc3QgaW52YWxpZCBVTk9SREVSRURcbiAgICAgICAgICByZXR1cm4gdG90YWw/LTE6eDtcbiAgICAgICAgfVxuICAgICAgICBpZih4ICE9PSAoeHwwKSl7IC8vIFByb3RlY3QgYWdhaW5zdCBpbnZhbGlkIHJldHVybiB2YWx1ZVxuICAgICAgICAgIHJldHVybiAtMVxuICAgICAgICB9XG4gICAgICAgIGlmICh4ICE9IDApIHJldHVybiAoeCB8IDApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTAwMDogLy8gTnVtYmVyXG4gICAgICAgIGEgPSArYTtcbiAgICAgICAgYiA9ICtiO1xuICAgICAgICBpZiAoYSA8IGIpIHJldHVybiAtMTtcbiAgICAgICAgaWYgKGEgPiBiKSByZXR1cm4gMTtcbiAgICAgICAgaWYgKGEgIT0gYikge1xuICAgICAgICAgIGlmICghdG90YWwpIHJldHVybiBOYU47XG4gICAgICAgICAgaWYgKGEgPT0gYSkgcmV0dXJuIDE7XG4gICAgICAgICAgaWYgKGIgPT0gYikgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMDAxOiAvLyBUaGUgcmVzdFxuICAgICAgICAvLyBIZXJlIHdlIGNhbiBiZSBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxuICAgICAgICAvLyAxLiBKYXZhU2NyaXB0IHByaW1pdGl2ZSB0eXBlc1xuICAgICAgICAvLyAyLiBKYXZhU2NyaXB0IG9iamVjdCB0aGF0IGNhbiBiZSBjb2VyY2VkIHRvIHByaW1pdGl2ZSB0eXBlc1xuICAgICAgICAvLyAzLiBKYXZhU2NyaXB0IG9iamVjdCB0aGFuIGNhbm5vdCBiZSBjb2VyY2VkIHRvIHByaW1pdGl2ZSB0eXBlc1xuICAgICAgICAvL1xuICAgICAgICAvLyAoMykgd2lsbCByYWlzZSBhIFtUeXBlRXJyb3JdXG4gICAgICAgIC8vICgyKSB3aWxsIGNvZXJjZSB0byBwcmltaXRpdmUgdHlwZXMgdXNpbmcgW3ZhbHVlT2ZdIG9yIFt0b1N0cmluZ11cbiAgICAgICAgLy8gKDIpIGFuZCAoMyksIGFmdGVyIGV2ZW50dWFsIGNvZXJjaW9uXG4gICAgICAgIC8vIC0gaWYgYSBhbmQgYiBhcmUgc3RyaW5ncywgYXBwbHkgbGV4aWNvZ3JhcGhpYyBjb21wYXJpc29uXG4gICAgICAgIC8vIC0gaWYgYSBvciBiIGFyZSBub3Qgc3RyaW5ncywgY29udmVydCBhIGFuZCBiIHRvIG51bWJlclxuICAgICAgICAvLyAgIGFuZCBhcHBseSBzdGFuZGFyZCBjb21wYXJpc29uXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEV4Y2VwdGlvbjogYCE9YCB3aWxsIG5vdCBjb2VyY2UvY29udmVydCBpZiBib3RoIGEgYW5kIGIgYXJlIG9iamVjdHNcbiAgICAgICAgaWYgKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgICAgIGlmIChhID4gYikgcmV0dXJuIDE7XG4gICAgICAgIGlmIChhICE9IGIpIHtcbiAgICAgICAgICBpZiAoIXRvdGFsKSByZXR1cm4gTmFOO1xuICAgICAgICAgIGlmIChhID09IGEpIHJldHVybiAxO1xuICAgICAgICAgIGlmIChiID09IGIpIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTI1MTogLy8gSmF2YVNjcmlwdCBTeW1ib2wsIG5vIG9yZGVyaW5nLlxuICAgICAgICBpZihhICE9PSBiKSB7XG4gICAgICAgICAgaWYgKCF0b3RhbCkgcmV0dXJuIE5hTjtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTI1MjogLy8gb2NhbWwgc3RyaW5nc1xuICAgICAgICB2YXIgYSA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcoYSk7XG4gICAgICAgIHZhciBiID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhiKTtcbiAgICAgICAgaWYoYSAhPT0gYikge1xuICAgICAgICAgIGlmKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgICAgICAgaWYoYSA+IGIpIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMjUyMDogLy8gamF2YXNjcmlwdCBzdHJpbmdzXG4gICAgICAgIHZhciBhID0gYS50b1N0cmluZygpO1xuICAgICAgICB2YXIgYiA9IGIudG9TdHJpbmcoKTtcbiAgICAgICAgaWYoYSAhPT0gYikge1xuICAgICAgICAgIGlmKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgICAgICAgaWYoYSA+IGIpIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNDY6IC8vIExhenlfdGFnXG4gICAgICBjYXNlIDI1NDogLy8gRG91YmxlX2FycmF5XG4gICAgICBkZWZhdWx0OiAvLyBCbG9jayB3aXRoIG90aGVyIHRhZ1xuICAgICAgICBpZihjYW1sX2lzX2NvbnRpbnVhdGlvbl90YWcodGFnX2EpKSB7XG4gICAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY29tcGFyZTogY29udGludWF0aW9uIHZhbHVlXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aCkgcmV0dXJuIChhLmxlbmd0aCA8IGIubGVuZ3RoKT8tMToxO1xuICAgICAgICBpZiAoYS5sZW5ndGggPiAxKSBzdGFjay5wdXNoKGEsIGIsIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0YWNrLmxlbmd0aCA9PSAwKSByZXR1cm4gMDtcbiAgICB2YXIgaSA9IHN0YWNrLnBvcCgpO1xuICAgIGIgPSBzdGFjay5wb3AoKTtcbiAgICBhID0gc3RhY2sucG9wKCk7XG4gICAgaWYgKGkgKyAxIDwgYS5sZW5ndGgpIHN0YWNrLnB1c2goYSwgYiwgaSArIDEpO1xuICAgIGEgPSBhW2ldO1xuICAgIGIgPSBiW2ldO1xuICB9XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2NvbXBhcmUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfY29tcGFyZSAoYSwgYikgeyByZXR1cm4gY2FtbF9jb21wYXJlX3ZhbCAoYSwgYiwgdHJ1ZSk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfaW50X2NvbXBhcmUgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9pbnRfY29tcGFyZSAoYSwgYikge1xuICBpZiAoYSA8IGIpIHJldHVybiAoLTEpOyBpZiAoYSA9PSBiKSByZXR1cm4gMDsgcmV0dXJuIDE7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2VxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfZXF1YWwgKHgsIHkpIHsgcmV0dXJuICsoY2FtbF9jb21wYXJlX3ZhbCh4LHksZmFsc2UpID09IDApOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX25vdGVxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfbm90ZXF1YWwgKHgsIHkpIHsgcmV0dXJuICsoY2FtbF9jb21wYXJlX3ZhbCh4LHksZmFsc2UpICE9IDApOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2dyZWF0ZXJlcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2dyZWF0ZXJlcXVhbCAoeCwgeSkgeyByZXR1cm4gKyhjYW1sX2NvbXBhcmVfdmFsKHgseSxmYWxzZSkgPj0gMCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JlYXRlcnRoYW4gbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9ncmVhdGVydGhhbiAoeCwgeSkgeyByZXR1cm4gKyhjYW1sX2NvbXBhcmVfdmFsKHgseSxmYWxzZSkgPiAwKTsgfVxuLy9Qcm92aWRlczogY2FtbF9sZXNzZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9sZXNzZXF1YWwgKHgsIHkpIHsgcmV0dXJuICsoY2FtbF9jb21wYXJlX3ZhbCh4LHksZmFsc2UpIDw9IDApOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2xlc3N0aGFuIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfbGVzc3RoYW4gKHgsIHkpIHsgcmV0dXJuICsoY2FtbF9jb21wYXJlX3ZhbCh4LHksZmFsc2UpIDwgMCk7IH1cbiIsIi8vIEpzX29mX29jYW1sIGxpYnJhcnlcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBKc2xpYjogY29kZSBzcGVjaWZpYyB0byBKc19vZl9vY2FtbFxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX29uX2llIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2pzX29uX2llICgpIHtcbiAgdmFyIHVhID1cbiAgICAgIGdsb2JhbFRoaXMubmF2aWdhdG9yP2dsb2JhbFRoaXMubmF2aWdhdG9yLnVzZXJBZ2VudDpcIlwiO1xuICByZXR1cm4gdWEuaW5kZXhPZihcIk1TSUVcIikgIT0gLTEgJiYgdWEuaW5kZXhPZihcIk9wZXJhXCIpICE9IDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfaHRtbF9lc2NhcGUgY29uc3QgKGNvbnN0KVxudmFyIGNhbWxfanNfcmVnZXhwcyA9IHsgYW1wOi8mL2csIGx0Oi88L2csIHF1b3Q6L1xcXCIvZywgYWxsOi9bJjxcXFwiXS8gfTtcbmZ1bmN0aW9uIGNhbWxfanNfaHRtbF9lc2NhcGUgKHMpIHtcbiAgaWYgKCFjYW1sX2pzX3JlZ2V4cHMuYWxsLnRlc3QocykpIHJldHVybiBzO1xuICByZXR1cm4gcy5yZXBsYWNlKGNhbWxfanNfcmVnZXhwcy5hbXAsIFwiJmFtcDtcIilcbiAgICAucmVwbGFjZShjYW1sX2pzX3JlZ2V4cHMubHQsIFwiJmx0O1wiKVxuICAgIC5yZXBsYWNlKGNhbWxfanNfcmVnZXhwcy5xdW90LCBcIiZxdW90O1wiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc19odG1sX2VudGl0aWVzXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2pzX2h0bWxfZW50aXRpZXMocykge1xuICB2YXIgZW50aXR5ID0gL14mIz9bMC05YS16QS1aXSs7JC9cbiAgaWYocy5tYXRjaChlbnRpdHkpKVxuICB7XG4gICAgdmFyIHN0ciwgdGVtcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKTtcbiAgICB0ZW1wLmlubmVySFRNTD0gcztcbiAgICBzdHI9IHRlbXAudGV4dENvbnRlbnQgfHwgdGVtcC5pbm5lclRleHQ7XG4gICAgdGVtcD1udWxsO1xuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgZWxzZSB7XG4gICAgY2FtbF9mYWlsd2l0aChcIkludmFsaWQgZW50aXR5IFwiICsgcyk7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc19nZXRfY29uc29sZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9qc19nZXRfY29uc29sZSAoKSB7XG4gIHZhciBjID0gY29uc29sZTtcbiAgdmFyIG0gPSBbXCJsb2dcIiwgXCJkZWJ1Z1wiLCBcImluZm9cIiwgXCJ3YXJuXCIsIFwiZXJyb3JcIiwgXCJhc3NlcnRcIiwgXCJkaXJcIiwgXCJkaXJ4bWxcIixcbiAgICAgICAgICAgXCJ0cmFjZVwiLCBcImdyb3VwXCIsIFwiZ3JvdXBDb2xsYXBzZWRcIiwgXCJncm91cEVuZFwiLCBcInRpbWVcIiwgXCJ0aW1lRW5kXCJdO1xuICBmdW5jdGlvbiBmICgpIHt9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbS5sZW5ndGg7IGkrKykgaWYgKCFjW21baV1dKSBjW21baV1dPWY7XG4gIHJldHVybiBjO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3htbGh0dHByZXF1ZXN0X2NyZWF0ZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy9XZWFrZGVmXG5mdW5jdGlvbiBjYW1sX3htbGh0dHByZXF1ZXN0X2NyZWF0ZSh1bml0KXtcbiAgaWYodHlwZW9mIGdsb2JhbFRoaXMuWE1MSHR0cFJlcXVlc3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBnbG9iYWxUaGlzLlhNTEh0dHBSZXF1ZXN0IH0gY2F0Y2ggKGUpIHsgfTtcbiAgfVxuICBpZih0eXBlb2YgZ2xvYmFsVGhpcy5hY3RpdmVYT2JqZWN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRyeSB7IHJldHVybiBuZXcgZ2xvYmFsVGhpcy5hY3RpdmVYT2JqZWN0KFwiTXN4bWwyLlhNTEhUVFBcIikgfSBjYXRjaChlKXsgfTtcbiAgICB0cnkgeyByZXR1cm4gbmV3IGdsb2JhbFRoaXMuYWN0aXZlWE9iamVjdChcIk1zeG1sMy5YTUxIVFRQXCIpIH0gY2F0Y2goZSl7IH07XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBnbG9iYWxUaGlzLmFjdGl2ZVhPYmplY3QoXCJNaWNyb3NvZnQuWE1MSFRUUFwiKSB9IGNhdGNoKGUpeyB9O1xuICB9XG4gIGNhbWxfZmFpbHdpdGgoXCJDYW5ub3QgY3JlYXRlIGEgWE1MSHR0cFJlcXVlc3RcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZXJyb3Jfb2ZfZXhjZXB0aW9uXG5mdW5jdGlvbiBjYW1sX2pzX2Vycm9yX29mX2V4Y2VwdGlvbihleG4pIHtcbiAgaWYoZXhuLmpzX2Vycm9yKSB7IHJldHVybiBleG4uanNfZXJyb3I7IH1cbiAgcmV0dXJuIG51bGw7XG59XG4iLCIvLy8vLy8vLy8gQklHU1RSSU5HXG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfYmlnc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2J5dGVzX2FyclxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9iaWdzdHJpbmcoaCwgYnMpIHtcbiAgcmV0dXJuIGNhbWxfaGFzaF9taXhfYnl0ZXNfYXJyKGgsYnMuZGF0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ190b19hcnJheV9idWZmZXIgbXV0YWJsZVxuZnVuY3Rpb24gYmlnc3RyaW5nX3RvX2FycmF5X2J1ZmZlcihicykge1xuICByZXR1cm4gYnMuZGF0YS5idWZmZXJcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX3RvX3R5cGVkX2FycmF5IG11dGFibGVcbmZ1bmN0aW9uIGJpZ3N0cmluZ190b190eXBlZF9hcnJheShicykge1xuICByZXR1cm4gYnMuZGF0YVxufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfb2ZfYXJyYXlfYnVmZmVyIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVxuZnVuY3Rpb24gYmlnc3RyaW5nX29mX2FycmF5X2J1ZmZlcihhYikge1xuICB2YXIgdGEgPSBuZXcgVWludDhBcnJheShhYik7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoMTIsIDAsIFt0YS5sZW5ndGhdLCB0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ19vZl90eXBlZF9hcnJheSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV91bnNhZmVcbmZ1bmN0aW9uIGJpZ3N0cmluZ19vZl90eXBlZF9hcnJheShiYSkge1xuICB2YXIgdGEgPSBuZXcgVWludDhBcnJheShiYS5idWZmZXIsIGJhLmJ5dGVPZmZzZXQsIGJhLmxlbmd0aCAqIGJhLkJZVEVTX1BFUl9FTEVNRU5UKTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSgxMiwgMCwgW3RhLmxlbmd0aF0sIHRhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iaWdzdHJpbmdfbWVtY21wXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF8xXG5mdW5jdGlvbiBjYW1sX2JpZ3N0cmluZ19tZW1jbXAoczEsIHBvczEsIHMyLCBwb3MyLCBsZW4pe1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIGEgPSBjYW1sX2JhX2dldF8xKHMxLHBvczEgKyBpKTtcbiAgICB2YXIgYiA9IGNhbWxfYmFfZ2V0XzEoczIscG9zMiArIGkpO1xuICAgIGlmIChhIDwgYikgcmV0dXJuIC0xO1xuICAgIGlmIChhID4gYikgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmFcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYShiYTEsIHBvczEsIGJhMiwgcG9zMiwgbGVuKXtcbiAgaWYoMTIgIT0gYmExLmtpbmQpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYToga2luZCBtaXNtYXRjaFwiKTtcbiAgaWYoMTIgIT0gYmEyLmtpbmQpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYToga2luZCBtaXNtYXRjaFwiKTtcbiAgaWYobGVuID09IDApIHJldHVybiAwO1xuICB2YXIgb2ZzMSA9IGJhMS5vZmZzZXQocG9zMSk7XG4gIHZhciBvZnMyID0gYmEyLm9mZnNldChwb3MyKTtcbiAgaWYob2ZzMSArIGxlbiA+IGJhMS5kYXRhLmxlbmd0aCl7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIGlmKG9mczIgKyBsZW4gPiBiYTIuZGF0YS5sZW5ndGgpe1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICB2YXIgc2xpY2UgPSBiYTEuZGF0YS5zdWJhcnJheShvZnMxLG9mczErbGVuKTtcbiAgYmEyLmRhdGEuc2V0KHNsaWNlLHBvczIpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2FycmF5X2JvdW5kX2Vycm9yLCBjYW1sX3VpbnQ4X2FycmF5X29mX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYShzdHIxLCBwb3MxLCBiYTIsIHBvczIsIGxlbil7XG4gIGlmKDEyICE9IGJhMi5raW5kKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhOiBraW5kIG1pc21hdGNoXCIpO1xuICBpZihsZW4gPT0gMCkgcmV0dXJuIDA7XG4gIHZhciBvZnMyID0gYmEyLm9mZnNldChwb3MyKTtcbiAgaWYocG9zMSArIGxlbiA+IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzdHIxKSkge1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICBpZihvZnMyICsgbGVuID4gYmEyLmRhdGEubGVuZ3RoKSB7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIHZhciBzbGljZSA9IGNhbWxfdWludDhfYXJyYXlfb2Zfc3RyaW5nKHN0cjEpLnNsaWNlKHBvczEscG9zMSArIGxlbik7XG4gIGJhMi5kYXRhLnNldChzbGljZSxvZnMyKTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iaWdzdHJpbmdfYmxpdF9ieXRlc190b19iYVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2FycmF5X2JvdW5kX2Vycm9yLCBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX21sX2J5dGVzX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9iaWdzdHJpbmdfYmxpdF9ieXRlc190b19iYShzdHIxLCBwb3MxLCBiYTIsIHBvczIsIGxlbil7XG4gIGlmKDEyICE9IGJhMi5raW5kKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhOiBraW5kIG1pc21hdGNoXCIpO1xuICBpZihsZW4gPT0gMCkgcmV0dXJuIDA7XG4gIHZhciBvZnMyID0gYmEyLm9mZnNldChwb3MyKTtcbiAgaWYocG9zMSArIGxlbiA+IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKHN0cjEpKSB7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIGlmKG9mczIgKyBsZW4gPiBiYTIuZGF0YS5sZW5ndGgpIHtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgdmFyIHNsaWNlID0gY2FtbF91aW50OF9hcnJheV9vZl9ieXRlcyhzdHIxKS5zbGljZShwb3MxLHBvczEgKyBsZW4pO1xuICBiYTIuZGF0YS5zZXQoc2xpY2Usb2ZzMik7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9ibGl0X2J5dGVzLCBjYW1sX2J5dGVzX29mX2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX21sX2J5dGVzX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19ieXRlcyhiYTEsIHBvczEsIGJ5dGVzMiwgcG9zMiwgbGVuKXtcbiAgaWYoMTIgIT0gYmExLmtpbmQpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmE6IGtpbmQgbWlzbWF0Y2hcIik7XG4gIGlmKGxlbiA9PSAwKSByZXR1cm4gMDtcbiAgdmFyIG9mczEgPSBiYTEub2Zmc2V0KHBvczEpO1xuICBpZihvZnMxICsgbGVuID4gYmExLmRhdGEubGVuZ3RoKXtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgaWYocG9zMiArIGxlbiA+IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKGJ5dGVzMikpe1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICB2YXIgc2xpY2UgPSBiYTEuZGF0YS5zbGljZShvZnMxLCBvZnMxK2xlbik7XG4gIGNhbWxfYmxpdF9ieXRlcyhjYW1sX2J5dGVzX29mX2FycmF5KHNsaWNlKSwgMCwgYnl0ZXMyLCBwb3MyLCBsZW4pO1xuICByZXR1cm4gMFxufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWQ1X2NoYW5cbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2VuZF9vZl9maWxlLCBjYW1sX21sX2lucHV0X2Jsb2NrXG4vL1JlcXVpcmVzOiBjYW1sX01ENUluaXQsIGNhbWxfTUQ1VXBkYXRlLCBjYW1sX01ENUZpbmFsXG5mdW5jdGlvbiBjYW1sX21kNV9jaGFuKGNoYW5pZCx0b3JlYWQpe1xuICB2YXIgY3R4ID0gY2FtbF9NRDVJbml0KCk7XG4gIHZhciBidWZmZXIgPSBuZXcgVWludDhBcnJheSg0MDk2KTtcbiAgaWYodG9yZWFkIDwgMCl7XG4gICAgd2hpbGUodHJ1ZSl7XG4gICAgICB2YXIgcmVhZCA9IGNhbWxfbWxfaW5wdXRfYmxvY2soY2hhbmlkLGJ1ZmZlciwwLGJ1ZmZlci5sZW5ndGgpO1xuICAgICAgaWYocmVhZCA9PSAwKSBicmVhaztcbiAgICAgIGNhbWxfTUQ1VXBkYXRlKGN0eCxidWZmZXIuc3ViYXJyYXkoMCwgcmVhZCksIHJlYWQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB3aGlsZSh0b3JlYWQgPiAwKSB7XG4gICAgICB2YXIgcmVhZCA9IGNhbWxfbWxfaW5wdXRfYmxvY2soY2hhbmlkLGJ1ZmZlciwwLCAodG9yZWFkID4gYnVmZmVyLmxlbmd0aCA/IGJ1ZmZlci5sZW5ndGggOiB0b3JlYWQpKTtcbiAgICAgIGlmKHJlYWQgPT0gMCkgY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSgpO1xuICAgICAgY2FtbF9NRDVVcGRhdGUoY3R4LGJ1ZmZlci5zdWJhcnJheSgwLCByZWFkKSwgcmVhZCk7XG4gICAgICB0b3JlYWQgLT0gcmVhZFxuICAgIH1cbiAgfVxuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfYXJyYXkoY2FtbF9NRDVGaW5hbChjdHgpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tZDVfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX29mX3N0cmluZywgY2FtbF9tZDVfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbWQ1X3N0cmluZyhzLCBvZnMsIGxlbikge1xuICByZXR1cm4gY2FtbF9tZDVfYnl0ZXMoY2FtbF9ieXRlc19vZl9zdHJpbmcocyksb2ZzLGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfTUQ1VHJhbnNmb3JtXG52YXIgY2FtbF9NRDVUcmFuc2Zvcm0gPSAoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBhZGQgKHgsIHkpIHsgcmV0dXJuICh4ICsgeSkgfCAwOyB9XG4gIGZ1bmN0aW9uIHh4KHEsYSxiLHgscyx0KSB7XG4gICAgYSA9IGFkZChhZGQoYSwgcSksIGFkZCh4LCB0KSk7XG4gICAgcmV0dXJuIGFkZCgoYSA8PCBzKSB8IChhID4+PiAoMzIgLSBzKSksIGIpO1xuICB9XG4gIGZ1bmN0aW9uIGZmKGEsYixjLGQseCxzLHQpIHtcbiAgICByZXR1cm4geHgoKGIgJiBjKSB8ICgofmIpICYgZCksIGEsIGIsIHgsIHMsIHQpO1xuICB9XG4gIGZ1bmN0aW9uIGdnKGEsYixjLGQseCxzLHQpIHtcbiAgICByZXR1cm4geHgoKGIgJiBkKSB8IChjICYgKH5kKSksIGEsIGIsIHgsIHMsIHQpO1xuICB9XG4gIGZ1bmN0aW9uIGhoKGEsYixjLGQseCxzLHQpIHsgcmV0dXJuIHh4KGIgXiBjIF4gZCwgYSwgYiwgeCwgcywgdCk7IH1cbiAgZnVuY3Rpb24gaWkoYSxiLGMsZCx4LHMsdCkgeyByZXR1cm4geHgoYyBeIChiIHwgKH5kKSksIGEsIGIsIHgsIHMsIHQpOyB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICh3LCBidWZmZXIpIHtcbiAgICB2YXIgYSA9IHdbMF0sIGIgPSB3WzFdLCBjID0gd1syXSwgZCA9IHdbM107XG5cbiAgICBhID0gZmYoYSwgYiwgYywgZCwgYnVmZmVyWyAwXSwgNywgMHhENzZBQTQ3OCk7XG4gICAgZCA9IGZmKGQsIGEsIGIsIGMsIGJ1ZmZlclsgMV0sIDEyLCAweEU4QzdCNzU2KTtcbiAgICBjID0gZmYoYywgZCwgYSwgYiwgYnVmZmVyWyAyXSwgMTcsIDB4MjQyMDcwREIpO1xuICAgIGIgPSBmZihiLCBjLCBkLCBhLCBidWZmZXJbIDNdLCAyMiwgMHhDMUJEQ0VFRSk7XG4gICAgYSA9IGZmKGEsIGIsIGMsIGQsIGJ1ZmZlclsgNF0sIDcsIDB4RjU3QzBGQUYpO1xuICAgIGQgPSBmZihkLCBhLCBiLCBjLCBidWZmZXJbIDVdLCAxMiwgMHg0Nzg3QzYyQSk7XG4gICAgYyA9IGZmKGMsIGQsIGEsIGIsIGJ1ZmZlclsgNl0sIDE3LCAweEE4MzA0NjEzKTtcbiAgICBiID0gZmYoYiwgYywgZCwgYSwgYnVmZmVyWyA3XSwgMjIsIDB4RkQ0Njk1MDEpO1xuICAgIGEgPSBmZihhLCBiLCBjLCBkLCBidWZmZXJbIDhdLCA3LCAweDY5ODA5OEQ4KTtcbiAgICBkID0gZmYoZCwgYSwgYiwgYywgYnVmZmVyWyA5XSwgMTIsIDB4OEI0NEY3QUYpO1xuICAgIGMgPSBmZihjLCBkLCBhLCBiLCBidWZmZXJbMTBdLCAxNywgMHhGRkZGNUJCMSk7XG4gICAgYiA9IGZmKGIsIGMsIGQsIGEsIGJ1ZmZlclsxMV0sIDIyLCAweDg5NUNEN0JFKTtcbiAgICBhID0gZmYoYSwgYiwgYywgZCwgYnVmZmVyWzEyXSwgNywgMHg2QjkwMTEyMik7XG4gICAgZCA9IGZmKGQsIGEsIGIsIGMsIGJ1ZmZlclsxM10sIDEyLCAweEZEOTg3MTkzKTtcbiAgICBjID0gZmYoYywgZCwgYSwgYiwgYnVmZmVyWzE0XSwgMTcsIDB4QTY3OTQzOEUpO1xuICAgIGIgPSBmZihiLCBjLCBkLCBhLCBidWZmZXJbMTVdLCAyMiwgMHg0OUI0MDgyMSk7XG5cbiAgICBhID0gZ2coYSwgYiwgYywgZCwgYnVmZmVyWyAxXSwgNSwgMHhGNjFFMjU2Mik7XG4gICAgZCA9IGdnKGQsIGEsIGIsIGMsIGJ1ZmZlclsgNl0sIDksIDB4QzA0MEIzNDApO1xuICAgIGMgPSBnZyhjLCBkLCBhLCBiLCBidWZmZXJbMTFdLCAxNCwgMHgyNjVFNUE1MSk7XG4gICAgYiA9IGdnKGIsIGMsIGQsIGEsIGJ1ZmZlclsgMF0sIDIwLCAweEU5QjZDN0FBKTtcbiAgICBhID0gZ2coYSwgYiwgYywgZCwgYnVmZmVyWyA1XSwgNSwgMHhENjJGMTA1RCk7XG4gICAgZCA9IGdnKGQsIGEsIGIsIGMsIGJ1ZmZlclsxMF0sIDksIDB4MDI0NDE0NTMpO1xuICAgIGMgPSBnZyhjLCBkLCBhLCBiLCBidWZmZXJbMTVdLCAxNCwgMHhEOEExRTY4MSk7XG4gICAgYiA9IGdnKGIsIGMsIGQsIGEsIGJ1ZmZlclsgNF0sIDIwLCAweEU3RDNGQkM4KTtcbiAgICBhID0gZ2coYSwgYiwgYywgZCwgYnVmZmVyWyA5XSwgNSwgMHgyMUUxQ0RFNik7XG4gICAgZCA9IGdnKGQsIGEsIGIsIGMsIGJ1ZmZlclsxNF0sIDksIDB4QzMzNzA3RDYpO1xuICAgIGMgPSBnZyhjLCBkLCBhLCBiLCBidWZmZXJbIDNdLCAxNCwgMHhGNEQ1MEQ4Nyk7XG4gICAgYiA9IGdnKGIsIGMsIGQsIGEsIGJ1ZmZlclsgOF0sIDIwLCAweDQ1NUExNEVEKTtcbiAgICBhID0gZ2coYSwgYiwgYywgZCwgYnVmZmVyWzEzXSwgNSwgMHhBOUUzRTkwNSk7XG4gICAgZCA9IGdnKGQsIGEsIGIsIGMsIGJ1ZmZlclsgMl0sIDksIDB4RkNFRkEzRjgpO1xuICAgIGMgPSBnZyhjLCBkLCBhLCBiLCBidWZmZXJbIDddLCAxNCwgMHg2NzZGMDJEOSk7XG4gICAgYiA9IGdnKGIsIGMsIGQsIGEsIGJ1ZmZlclsxMl0sIDIwLCAweDhEMkE0QzhBKTtcblxuICAgIGEgPSBoaChhLCBiLCBjLCBkLCBidWZmZXJbIDVdLCA0LCAweEZGRkEzOTQyKTtcbiAgICBkID0gaGgoZCwgYSwgYiwgYywgYnVmZmVyWyA4XSwgMTEsIDB4ODc3MUY2ODEpO1xuICAgIGMgPSBoaChjLCBkLCBhLCBiLCBidWZmZXJbMTFdLCAxNiwgMHg2RDlENjEyMik7XG4gICAgYiA9IGhoKGIsIGMsIGQsIGEsIGJ1ZmZlclsxNF0sIDIzLCAweEZERTUzODBDKTtcbiAgICBhID0gaGgoYSwgYiwgYywgZCwgYnVmZmVyWyAxXSwgNCwgMHhBNEJFRUE0NCk7XG4gICAgZCA9IGhoKGQsIGEsIGIsIGMsIGJ1ZmZlclsgNF0sIDExLCAweDRCREVDRkE5KTtcbiAgICBjID0gaGgoYywgZCwgYSwgYiwgYnVmZmVyWyA3XSwgMTYsIDB4RjZCQjRCNjApO1xuICAgIGIgPSBoaChiLCBjLCBkLCBhLCBidWZmZXJbMTBdLCAyMywgMHhCRUJGQkM3MCk7XG4gICAgYSA9IGhoKGEsIGIsIGMsIGQsIGJ1ZmZlclsxM10sIDQsIDB4Mjg5QjdFQzYpO1xuICAgIGQgPSBoaChkLCBhLCBiLCBjLCBidWZmZXJbIDBdLCAxMSwgMHhFQUExMjdGQSk7XG4gICAgYyA9IGhoKGMsIGQsIGEsIGIsIGJ1ZmZlclsgM10sIDE2LCAweEQ0RUYzMDg1KTtcbiAgICBiID0gaGgoYiwgYywgZCwgYSwgYnVmZmVyWyA2XSwgMjMsIDB4MDQ4ODFEMDUpO1xuICAgIGEgPSBoaChhLCBiLCBjLCBkLCBidWZmZXJbIDldLCA0LCAweEQ5RDREMDM5KTtcbiAgICBkID0gaGgoZCwgYSwgYiwgYywgYnVmZmVyWzEyXSwgMTEsIDB4RTZEQjk5RTUpO1xuICAgIGMgPSBoaChjLCBkLCBhLCBiLCBidWZmZXJbMTVdLCAxNiwgMHgxRkEyN0NGOCk7XG4gICAgYiA9IGhoKGIsIGMsIGQsIGEsIGJ1ZmZlclsgMl0sIDIzLCAweEM0QUM1NjY1KTtcblxuICAgIGEgPSBpaShhLCBiLCBjLCBkLCBidWZmZXJbIDBdLCA2LCAweEY0MjkyMjQ0KTtcbiAgICBkID0gaWkoZCwgYSwgYiwgYywgYnVmZmVyWyA3XSwgMTAsIDB4NDMyQUZGOTcpO1xuICAgIGMgPSBpaShjLCBkLCBhLCBiLCBidWZmZXJbMTRdLCAxNSwgMHhBQjk0MjNBNyk7XG4gICAgYiA9IGlpKGIsIGMsIGQsIGEsIGJ1ZmZlclsgNV0sIDIxLCAweEZDOTNBMDM5KTtcbiAgICBhID0gaWkoYSwgYiwgYywgZCwgYnVmZmVyWzEyXSwgNiwgMHg2NTVCNTlDMyk7XG4gICAgZCA9IGlpKGQsIGEsIGIsIGMsIGJ1ZmZlclsgM10sIDEwLCAweDhGMENDQzkyKTtcbiAgICBjID0gaWkoYywgZCwgYSwgYiwgYnVmZmVyWzEwXSwgMTUsIDB4RkZFRkY0N0QpO1xuICAgIGIgPSBpaShiLCBjLCBkLCBhLCBidWZmZXJbIDFdLCAyMSwgMHg4NTg0NUREMSk7XG4gICAgYSA9IGlpKGEsIGIsIGMsIGQsIGJ1ZmZlclsgOF0sIDYsIDB4NkZBODdFNEYpO1xuICAgIGQgPSBpaShkLCBhLCBiLCBjLCBidWZmZXJbMTVdLCAxMCwgMHhGRTJDRTZFMCk7XG4gICAgYyA9IGlpKGMsIGQsIGEsIGIsIGJ1ZmZlclsgNl0sIDE1LCAweEEzMDE0MzE0KTtcbiAgICBiID0gaWkoYiwgYywgZCwgYSwgYnVmZmVyWzEzXSwgMjEsIDB4NEUwODExQTEpO1xuICAgIGEgPSBpaShhLCBiLCBjLCBkLCBidWZmZXJbIDRdLCA2LCAweEY3NTM3RTgyKTtcbiAgICBkID0gaWkoZCwgYSwgYiwgYywgYnVmZmVyWzExXSwgMTAsIDB4QkQzQUYyMzUpO1xuICAgIGMgPSBpaShjLCBkLCBhLCBiLCBidWZmZXJbIDJdLCAxNSwgMHgyQUQ3RDJCQik7XG4gICAgYiA9IGlpKGIsIGMsIGQsIGEsIGJ1ZmZlclsgOV0sIDIxLCAweEVCODZEMzkxKTtcblxuICAgIHdbMF0gPSBhZGQoYSwgd1swXSk7XG4gICAgd1sxXSA9IGFkZChiLCB3WzFdKTtcbiAgICB3WzJdID0gYWRkKGMsIHdbMl0pO1xuICAgIHdbM10gPSBhZGQoZCwgd1szXSk7XG4gIH19KSgpXG5cbi8vUHJvdmlkZXM6IGNhbWxfTUQ1SW5pdFxuZnVuY3Rpb24gY2FtbF9NRDVJbml0KCkge1xuICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDY0KTtcbiAgdmFyIGIzMiA9IG5ldyBVaW50MzJBcnJheShidWZmZXIpO1xuICB2YXIgYjggPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICByZXR1cm4ge2xlbjowLFxuICAgICAgICAgIHc6bmV3IFVpbnQzMkFycmF5KFsweDY3NDUyMzAxLCAweEVGQ0RBQjg5LCAweDk4QkFEQ0ZFLCAweDEwMzI1NDc2XSksXG4gICAgICAgICAgYjMyOmIzMixcbiAgICAgICAgICBiODpiOH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9NRDVVcGRhdGVcbi8vUmVxdWlyZXM6IGNhbWxfTUQ1VHJhbnNmb3JtXG5mdW5jdGlvbiBjYW1sX01ENVVwZGF0ZShjdHgsIGlucHV0LCBpbnB1dF9sZW4pe1xuICB2YXIgaW5fYnVmID0gY3R4LmxlbiAmIDB4M2Y7XG4gIHZhciBpbnB1dF9wb3MgPSAwO1xuICBjdHgubGVuICs9IGlucHV0X2xlbjtcbiAgaWYoaW5fYnVmKXtcbiAgICB2YXIgbWlzc2luZyA9IDY0IC0gaW5fYnVmO1xuICAgIGlmKGlucHV0X2xlbiA8IG1pc3NpbmcpIHtcbiAgICAgIGN0eC5iOC5zZXQoaW5wdXQuc3ViYXJyYXkoMCxpbnB1dF9sZW4pLGluX2J1Zik7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY3R4LmI4LnNldChpbnB1dC5zdWJhcnJheSgwLG1pc3NpbmcpLGluX2J1Zik7XG4gICAgY2FtbF9NRDVUcmFuc2Zvcm0oY3R4LncsIGN0eC5iMzIpO1xuICAgIGlucHV0X2xlbiAtPSBtaXNzaW5nO1xuICAgIGlucHV0X3BvcyArPSBtaXNzaW5nO1xuICB9XG4gIHdoaWxlKGlucHV0X2xlbiA+PSA2NCl7XG4gICAgY3R4LmI4LnNldChpbnB1dC5zdWJhcnJheShpbnB1dF9wb3MsaW5wdXRfcG9zICsgNjQpLCAwKTtcbiAgICBjYW1sX01ENVRyYW5zZm9ybShjdHgudywgY3R4LmIzMik7XG4gICAgaW5wdXRfbGVuIC09IDY0O1xuICAgIGlucHV0X3BvcyArPSA2NDtcbiAgfVxuICBpZihpbnB1dF9sZW4pXG4gICAgY3R4LmI4LnNldChpbnB1dC5zdWJhcnJheShpbnB1dF9wb3MsaW5wdXRfcG9zICsgaW5wdXRfbGVuKSwgMCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfTUQ1RmluYWxcbi8vUmVxdWlyZXM6IGNhbWxfTUQ1VHJhbnNmb3JtXG5mdW5jdGlvbiBjYW1sX01ENUZpbmFsKGN0eCl7XG4gIHZhciBpbl9idWYgPSBjdHgubGVuICYgMHgzZjtcbiAgY3R4LmI4W2luX2J1Zl0gPSAweDgwO1xuICBpbl9idWYgKys7XG4gIGlmKGluX2J1ZiA+IDU2KSB7XG4gICAgZm9yKHZhciBqID0gaW5fYnVmOyBqIDwgNjQ7IGorKyl7XG4gICAgICBjdHguYjhbal0gPSAwO1xuICAgIH1cbiAgICBjYW1sX01ENVRyYW5zZm9ybShjdHgudywgY3R4LmIzMik7XG4gICAgZm9yKHZhciBqID0gMDsgaiA8IDU2OyBqKyspe1xuICAgICAgY3R4LmI4W2pdID0gMDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yKHZhciBqID0gaW5fYnVmOyBqIDwgNTY7IGorKyl7XG4gICAgICBjdHguYjhbal0gPSAwO1xuICAgIH1cbiAgfVxuICBjdHguYjMyWzE0XSA9IGN0eC5sZW4gPDwgMztcbiAgY3R4LmIzMlsxNV0gPSAoY3R4LmxlbiA+PiAyOSkgJiAweDFGRkZGRkZGO1xuICBjYW1sX01ENVRyYW5zZm9ybShjdHgudywgY3R4LmIzMik7XG4gIHZhciB0ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKylcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IDQ7IGorKylcbiAgICAgIHRbaSAqIDQgKyBqXSA9IChjdHgud1tpXSA+PiAoOCAqIGopKSAmIDB4RkY7XG4gIHJldHVybiB0O1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWQ1X2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzLCBjYW1sX3N0cmluZ19vZl9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9NRDVJbml0LCBjYW1sX01ENVVwZGF0ZSwgY2FtbF9NRDVGaW5hbFxuZnVuY3Rpb24gY2FtbF9tZDVfYnl0ZXMocywgb2ZzLCBsZW4pIHtcbiAgdmFyIGN0eCA9IGNhbWxfTUQ1SW5pdCgpO1xuICB2YXIgYSA9IGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXMocyk7XG4gIGNhbWxfTUQ1VXBkYXRlKGN0eCxhLnN1YmFycmF5KG9mcywgb2ZzICsgbGVuKSwgbGVuKTtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2FycmF5KGNhbWxfTUQ1RmluYWwoY3R4KSk7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2RlYnVnX2luZm9fc3RhdHVzIGNvbnN0XG5mdW5jdGlvbiBjYW1sX21sX2RlYnVnX2luZm9fc3RhdHVzICgpIHsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfYmFja3RyYWNlX3N0YXR1cyBjb25zdFxuZnVuY3Rpb24gY2FtbF9iYWNrdHJhY2Vfc3RhdHVzICgpIHsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X2V4Y2VwdGlvbl9iYWNrdHJhY2UgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZ2V0X2V4Y2VwdGlvbl9iYWNrdHJhY2UgKCkgeyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9nZXRfZXhjZXB0aW9uX3Jhd19iYWNrdHJhY2UgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZ2V0X2V4Y2VwdGlvbl9yYXdfYmFja3RyYWNlICgpIHsgcmV0dXJuIFswXTsgfVxuLy9Qcm92aWRlczogY2FtbF9yZWNvcmRfYmFja3RyYWNlXG5mdW5jdGlvbiBjYW1sX3JlY29yZF9iYWNrdHJhY2UgKCkgeyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2UgY29uc3RcbmZ1bmN0aW9uIGNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlICgpIHsgcmV0dXJuIFswXTsgfVxuLy9Qcm92aWRlczogY2FtbF9yYXdfYmFja3RyYWNlX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9yYXdfYmFja3RyYWNlX2xlbmd0aCgpIHsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfcmF3X2JhY2t0cmFjZV9uZXh0X3Nsb3RcbmZ1bmN0aW9uIGNhbWxfcmF3X2JhY2t0cmFjZV9uZXh0X3Nsb3QoKSB7IHJldHVybiAwIH1cbi8vUHJvdmlkZXM6IGNhbWxfcmF3X2JhY2t0cmFjZV9zbG90XG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfcmF3X2JhY2t0cmFjZV9zbG90ICgpIHtcbiAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiUHJpbnRleGMuZ2V0X3Jhd19iYWNrdHJhY2Vfc2xvdDogaW5kZXggb3V0IG9mIGJvdW5kc1wiKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfcmVzdG9yZV9yYXdfYmFja3RyYWNlXG5mdW5jdGlvbiBjYW1sX3Jlc3RvcmVfcmF3X2JhY2t0cmFjZShleG4sIGJ0KSB7IHJldHVybiAwIH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X2N1cnJlbnRfY2FsbHN0YWNrIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2dldF9jdXJyZW50X2NhbGxzdGFjayAoKSB7IHJldHVybiBbMF07IH1cblxuLy9Qcm92aWRlczogY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2Vfc2xvdFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2Vfc2xvdCgpe1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2Vfc2xvdFwiKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAyMCAtIEh1Z28gSGV1emFyZFxuLy8gQ29weXJpZ2h0IChDKSAyMDIwIC0gU2hhY2hhciBJdHpoYWt5XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLyBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vb2NhbWwvb2NhbWwvYmxvYi80LjA3L290aGVybGlicy9zdHIvc3Ryc3R1YnMuY1xuLy8gQ29waWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2pzY29xL2pzY29xL2Jsb2IvdjguMTEvY29xLWpzL2pzX3N0dWIvc3RyLmpzXG5cbi8vUHJvdmlkZXM6IHJlX21hdGNoXG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nLCBjYW1sX2pzX2Zyb21fYXJyYXksIGNhbWxfdWludDhfYXJyYXlfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19nZXRcblxudmFyIHJlX21hdGNoID0gZnVuY3Rpb24oKXtcbiAgdmFyIHJlX3dvcmRfbGV0dGVycyA9IFtcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAgICAgICAvKiAweDAwLTB4MUY6IG5vbmUgKi9cbiAgICAweDAwLCAweDAwLCAweEZGLCAweDAzLCAgICAgICAvKiAweDIwLTB4M0Y6IGRpZ2l0cyAwLTkgKi9cbiAgICAweEZFLCAweEZGLCAweEZGLCAweDg3LCAgICAgICAvKiAweDQwLTB4NUY6IEEgdG8gWiwgXyAqL1xuICAgIDB4RkUsIDB4RkYsIDB4RkYsIDB4MDcsICAgICAgIC8qIDB4NjAtMHg3RjogYSB0byB6ICovXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgICAgICAgLyogMHg4MC0weDlGOiBub25lICovXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgICAgICAgLyogMHhBMC0weEJGOiBub25lICovXG4gICAgMHhGRiwgMHhGRiwgMHg3RiwgMHhGRiwgICAgICAgLyogMHhDMC0weERGOiBMYXRpbi0xIGFjY2VudGVkIHVwcGVyY2FzZSAqL1xuICAgIDB4RkYsIDB4RkYsIDB4N0YsIDB4RkYgICAgICAgIC8qIDB4RTAtMHhGRjogTGF0aW4tMSBhY2NlbnRlZCBsb3dlcmNhc2UgKi9cbiAgXTtcblxuICB2YXIgb3Bjb2RlcyA9IHtcbiAgICBDSEFSOiAwLCBDSEFSTk9STTogMSwgU1RSSU5HOiAyLCBTVFJJTkdOT1JNOiAzLCBDSEFSQ0xBU1M6IDQsXG4gICAgQk9MOiA1LCBFT0w6IDYsIFdPUkRCT1VOREFSWTogNyxcbiAgICBCRUdHUk9VUDogOCwgRU5ER1JPVVA6IDksIFJFRkdST1VQOiAxMCxcbiAgICBBQ0NFUFQ6IDExLFxuICAgIFNJTVBMRU9QVDogMTIsIFNJTVBMRVNUQVI6IDEzLCBTSU1QTEVQTFVTOiAxNCxcbiAgICBHT1RPOiAxNSwgUFVTSEJBQ0s6IDE2LCBTRVRNQVJLOiAxNyxcbiAgICBDSEVDS1BST0dSRVNTOiAxOFxuICB9O1xuXG4gIGZ1bmN0aW9uIGlzX3dvcmRfbGV0dGVyKGMpIHtcbiAgICByZXR1cm4gKHJlX3dvcmRfbGV0dGVyc1sgIChjID4+IDMpXSA+PiAoYyAmIDcpKSAmIDE7XG4gIH1cblxuICBmdW5jdGlvbiBpbl9iaXRzZXQocyxpKSB7XG4gICAgcmV0dXJuIChjYW1sX3N0cmluZ19nZXQocywoaSA+PiAzKSkgPj4gKGkgJiA3KSkgJiAxO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVfbWF0Y2hfaW1wbChyZSwgcywgcG9zLCBwYXJ0aWFsKSB7XG5cbiAgICB2YXIgcHJvZyAgICAgICAgICA9IGNhbWxfanNfZnJvbV9hcnJheShyZVsxXSksXG4gICAgICAgIGNwb29sICAgICAgICAgPSBjYW1sX2pzX2Zyb21fYXJyYXkocmVbMl0pLFxuICAgICAgICBub3JtdGFibGUgICAgID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhyZVszXSksXG4gICAgICAgIG51bWdyb3VwcyAgICAgPSByZVs0XSB8IDAsXG4gICAgICAgIG51bXJlZ2lzdGVycyAgPSByZVs1XSB8IDAsXG4gICAgICAgIHN0YXJ0Y2hhcnMgICAgPSByZVs2XSB8IDA7XG5cbiAgICB2YXIgcyA9IGNhbWxfdWludDhfYXJyYXlfb2Zfc3RyaW5nKHMpO1xuXG4gICAgdmFyIHBjID0gMCxcbiAgICAgICAgcXVpdCA9IGZhbHNlLFxuICAgICAgICBzdGFjayA9IFtdLFxuICAgICAgICBncm91cHMgPSBuZXcgQXJyYXkobnVtZ3JvdXBzKSxcbiAgICAgICAgcmVfcmVnaXN0ZXIgPSBuZXcgQXJyYXkobnVtcmVnaXN0ZXJzKTtcblxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspe1xuICAgICAgZ3JvdXBzW2ldID0ge3N0YXJ0OiAtMSwgZW5kOi0xfVxuICAgIH1cbiAgICBncm91cHNbMF0uc3RhcnQgPSBwb3M7XG5cbiAgICB2YXIgYmFja3RyYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgICAgICB2YXIgaXRlbSA9IHN0YWNrLnBvcCgpO1xuICAgICAgICBpZiAoaXRlbS51bmRvKSB7XG4gICAgICAgICAgaXRlbS51bmRvLm9ialtpdGVtLnVuZG8ucHJvcF0gPSBpdGVtLnVuZG8udmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihpdGVtLnBvcykge1xuICAgICAgICAgIHBjID0gaXRlbS5wb3MucGM7XG4gICAgICAgICAgcG9zID0gaXRlbS5wb3MudHh0O1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcXVpdCA9IHRydWU7XG4gICAgfTtcblxuICAgIHZhciBwdXNoID0gZnVuY3Rpb24oaXRlbSkgeyBzdGFjay5wdXNoKGl0ZW0pOyB9O1xuXG4gICAgdmFyIGFjY2VwdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGdyb3Vwc1swXS5lbmQgPSBwb3M7XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KDEgKyBncm91cHMubGVuZ3RoKjIpO1xuICAgICAgcmVzdWx0WzBdID0gMDsgLy8gdGFnXG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGcgPSBncm91cHNbaV07XG4gICAgICAgIGlmKGcuc3RhcnQgPCAwIHx8IGcuZW5kIDwgMCkge1xuICAgICAgICAgIGcuc3RhcnQgPSBnLmVuZCA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFsyKmkgKyAxIF0gPSBnLnN0YXJ0O1xuICAgICAgICByZXN1bHRbMippICsgMSArIDEgXSA9IGcuZW5kO1xuICAgICAgfTtcbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9O1xuXG4gICAgdmFyIHByZWZpeF9tYXRjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmKHBhcnRpYWwpIHJldHVybiBhY2NlcHQgKCk7XG4gICAgICBlbHNlIGJhY2t0cmFjayAoKTtcbiAgICB9XG5cbiAgICAvKiBNYWluIERGQSBpbnRlcnByZXRlciBsb29wICovXG4gICAgd2hpbGUgKCFxdWl0KSB7XG4gICAgICB2YXIgb3AgPSBwcm9nW3BjXSAmIDB4ZmYsXG4gICAgICAgICAgc2FyZyA9IHByb2dbcGNdID4+IDgsXG4gICAgICAgICAgdWFyZyA9IHNhcmcgJiAweGZmLFxuICAgICAgICAgIGMgPSBzW3Bvc10sXG4gICAgICAgICAgZ3JvdXA7XG5cbiAgICAgIHBjKys7XG5cbiAgICAgIHN3aXRjaCAob3ApIHtcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5DSEFSOlxuICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgIGlmIChjID09PSB1YXJnKSBwb3MrKztcbiAgICAgICAgZWxzZSBiYWNrdHJhY2soKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuQ0hBUk5PUk06XG4gICAgICAgIGlmKHBvcyA9PT0gcy5sZW5ndGgpIHtwcmVmaXhfbWF0Y2ggKCk7IGJyZWFrfTtcbiAgICAgICAgaWYgKG5vcm10YWJsZS5jaGFyQ29kZUF0KGMpID09PSB1YXJnKSBwb3MrKztcbiAgICAgICAgZWxzZSBiYWNrdHJhY2soKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuU1RSSU5HOlxuICAgICAgICBmb3IgKHZhciBhcmcgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKGNwb29sW3VhcmddKSwgaSA9IDA7IGkgPCBhcmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgICAgaWYgKGMgPT09IGFyZy5jaGFyQ29kZUF0KGkpKVxuICAgICAgICAgICAgYyA9IHNbKytwb3NdO1xuICAgICAgICAgIGVsc2UgeyBiYWNrdHJhY2soKTsgYnJlYWs7IH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5TVFJJTkdOT1JNOlxuICAgICAgICBmb3IgKHZhciBhcmcgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKGNwb29sW3VhcmddKSwgaSA9IDA7IGkgPCBhcmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgICAgaWYgKG5vcm10YWJsZS5jaGFyQ29kZUF0KGMpID09PSBhcmcuY2hhckNvZGVBdChpKSlcbiAgICAgICAgICAgIGMgPSBzWysrcG9zXTtcbiAgICAgICAgICBlbHNlIHsgYmFja3RyYWNrKCk7IGJyZWFrOyB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuQ0hBUkNMQVNTOlxuICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgIGlmIChpbl9iaXRzZXQoY3Bvb2xbdWFyZ10sIGMpKSBwb3MrKztcbiAgICAgICAgZWxzZSBiYWNrdHJhY2soKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuQk9MOlxuICAgICAgICBpZihwb3MgPiAwICYmIHNbcG9zIC0gMV0gIT0gMTAgLyogXFxuICovKSB7YmFja3RyYWNrKCl9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLkVPTDpcbiAgICAgICAgaWYocG9zIDwgcy5sZW5ndGggJiYgc1twb3NdICE9IDEwIC8qIFxcbiAqLykge2JhY2t0cmFjaygpfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5XT1JEQk9VTkRBUlk6XG4gICAgICAgIGlmKHBvcyA9PSAwKSB7XG4gICAgICAgICAgaWYocG9zID09PSBzLmxlbmd0aCkge3ByZWZpeF9tYXRjaCAoKTsgYnJlYWt9O1xuICAgICAgICAgIGlmKGlzX3dvcmRfbGV0dGVyKHNbMF0pKSBicmVhaztcbiAgICAgICAgICBiYWNrdHJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwb3MgPT09IHMubGVuZ3RoKSB7XG4gICAgICAgICAgaWYoaXNfd29yZF9sZXR0ZXIoc1twb3MgLSAxXSkpIGJyZWFrO1xuICAgICAgICAgIGJhY2t0cmFjayAoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZihpc193b3JkX2xldHRlcihzW3BvcyAtIDFdKSAhPSBpc193b3JkX2xldHRlcihzW3Bvc10pKSBicmVhaztcbiAgICAgICAgICBiYWNrdHJhY2sgKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuQkVHR1JPVVA6XG4gICAgICAgIGdyb3VwID0gZ3JvdXBzW3VhcmddO1xuICAgICAgICBwdXNoKHt1bmRvOiB7b2JqOmdyb3VwLFxuICAgICAgICAgICAgICAgICAgICAgcHJvcDonc3RhcnQnLFxuICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGdyb3VwLnN0YXJ0fX0pO1xuICAgICAgICBncm91cC5zdGFydCA9IHBvcztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuRU5ER1JPVVA6XG4gICAgICAgIGdyb3VwID0gZ3JvdXBzW3VhcmddO1xuICAgICAgICBwdXNoKHt1bmRvOiB7b2JqOiBncm91cCxcbiAgICAgICAgICAgICAgICAgICAgIHByb3A6J2VuZCcsXG4gICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZ3JvdXAuZW5kfX0pO1xuICAgICAgICBncm91cC5lbmQgPSBwb3M7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlJFRkdST1VQOlxuICAgICAgICBncm91cCA9IGdyb3Vwc1t1YXJnXTtcbiAgICAgICAgaWYoZ3JvdXAuc3RhcnQgPCAwIHx8IGdyb3VwLmVuZCA8IDApIHtiYWNrdHJhY2sgKCk7IGJyZWFrfVxuICAgICAgICBmb3IgKHZhciBpID0gZ3JvdXAuc3RhcnQ7IGkgPCBncm91cC5lbmQ7IGkrKyl7XG4gICAgICAgICAgaWYocG9zID09PSBzLmxlbmd0aCkge3ByZWZpeF9tYXRjaCAoKTsgYnJlYWt9O1xuICAgICAgICAgIGlmKHNbaV0gIT0gc1twb3NdKSB7YmFja3RyYWNrICgpOyBicmVha31cbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5TSU1QTEVPUFQ6XG4gICAgICAgIGlmIChpbl9iaXRzZXQoY3Bvb2xbdWFyZ10sIGMpKSBwb3MrKztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuU0lNUExFU1RBUjpcbiAgICAgICAgd2hpbGUgKGluX2JpdHNldChjcG9vbFt1YXJnXSwgYykpXG4gICAgICAgICAgYyA9IHNbKytwb3NdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5TSU1QTEVQTFVTOlxuICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgIGlmIChpbl9iaXRzZXQoY3Bvb2xbdWFyZ10sIGMpKSB7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgYyA9IHNbKytwb3NdO1xuICAgICAgICAgIH0gd2hpbGUgKGluX2JpdHNldChjcG9vbFt1YXJnXSwgYykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgYmFja3RyYWNrKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLkFDQ0VQVDpcbiAgICAgICAgcmV0dXJuIGFjY2VwdCgpO1xuICAgICAgY2FzZSBvcGNvZGVzLkdPVE86XG4gICAgICAgIHBjID0gcGMgKyBzYXJnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5QVVNIQkFDSzpcbiAgICAgICAgcHVzaCh7cG9zOiB7cGM6IHBjICsgc2FyZywgdHh0OiBwb3N9fSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlNFVE1BUks6XG4gICAgICAgIHB1c2goe3VuZG86IHtvYmo6cmVfcmVnaXN0ZXIsXG4gICAgICAgICAgICAgICAgICAgICBwcm9wOiB1YXJnLFxuICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlX3JlZ2lzdGVyW3VhcmddfX0pO1xuICAgICAgICByZV9yZWdpc3Rlclt1YXJnXSA9IHBvcztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuQ0hFQ0tQUk9HUkVTUzpcbiAgICAgICAgaWYgKHJlX3JlZ2lzdGVyW3VhcmddID09PSBwb3MpIGJhY2t0cmFjaygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYnl0ZWNvZGVcIik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIHJlX21hdGNoX2ltcGw7XG59KCk7XG5cblxuLy9Qcm92aWRlczogcmVfc2VhcmNoX2ZvcndhcmRcbi8vUmVxdWlyZXM6IHJlX21hdGNoLCBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gcmVfc2VhcmNoX2ZvcndhcmQocmUsIHMsIHBvcykge1xuICBpZihwb3MgPCAwIHx8IHBvcyA+IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSlcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJTdHIuc2VhcmNoX2ZvcndhcmRcIilcbiAgd2hpbGUgKHBvcyA8PSBjYW1sX21sX3N0cmluZ19sZW5ndGgocykpIHtcbiAgICB2YXIgcmVzID0gcmVfbWF0Y2gocmUsIHMsIHBvcywgMCk7XG4gICAgaWYgKHJlcykgcmV0dXJuIHJlcztcbiAgICBwb3MrKztcbiAgfVxuXG4gIHJldHVybiBbMF07ICAvKiBbfHxdIDogaW50IGFycmF5ICovXG59XG5cbi8vUHJvdmlkZXM6IHJlX3NlYXJjaF9iYWNrd2FyZFxuLy9SZXF1aXJlczogcmVfbWF0Y2gsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiByZV9zZWFyY2hfYmFja3dhcmQocmUsIHMsIHBvcykge1xuICBpZihwb3MgPCAwIHx8IHBvcyA+IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSlcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJTdHIuc2VhcmNoX2JhY2t3YXJkXCIpXG4gIHdoaWxlIChwb3MgPj0gMCkge1xuICAgIHZhciByZXMgPSByZV9tYXRjaChyZSwgcywgcG9zLCAwKTtcbiAgICBpZiAocmVzKSByZXR1cm4gcmVzO1xuICAgIHBvcy0tO1xuICB9XG5cbiAgcmV0dXJuIFswXTsgIC8qIFt8fF0gOiBpbnQgYXJyYXkgKi9cbn1cblxuXG4vL1Byb3ZpZGVzOiByZV9zdHJpbmdfbWF0Y2hcbi8vUmVxdWlyZXM6IHJlX21hdGNoLCBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gcmVfc3RyaW5nX21hdGNoKHJlLHMscG9zKXtcbiAgaWYocG9zIDwgMCB8fCBwb3MgPiBjYW1sX21sX3N0cmluZ19sZW5ndGgocykpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiU3RyLnN0cmluZ19tYXRjaFwiKVxuICB2YXIgcmVzID0gcmVfbWF0Y2gocmUsIHMsIHBvcywgMCk7XG4gIGlmIChyZXMpIHJldHVybiByZXM7XG4gIGVsc2UgcmV0dXJuIFswXTtcbn1cblxuLy9Qcm92aWRlczogcmVfcGFydGlhbF9tYXRjaFxuLy9SZXF1aXJlczogcmVfbWF0Y2gsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiByZV9wYXJ0aWFsX21hdGNoKHJlLHMscG9zKXtcbiAgaWYocG9zIDwgMCB8fCBwb3MgPiBjYW1sX21sX3N0cmluZ19sZW5ndGgocykpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiU3RyLnBhcnRpYWxfbWF0Y2hcIilcbiAgdmFyIHJlcyA9IHJlX21hdGNoKHJlLCBzLCBwb3MsIDEpO1xuICBpZiAocmVzKSByZXR1cm4gcmVzO1xuICBlbHNlIHJldHVybiBbMF07XG59XG5cbi8vUHJvdmlkZXM6IHJlX3JlcGxhY2VtZW50X3RleHRcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmcsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vLyBleHRlcm5hbCByZV9yZXBsYWNlbWVudF90ZXh0OiBzdHJpbmcgLT4gaW50IGFycmF5IC0+IHN0cmluZyAtPiBzdHJpbmdcbmZ1bmN0aW9uIHJlX3JlcGxhY2VtZW50X3RleHQocmVwbCxncm91cHMsb3JpZykge1xuICB2YXIgcmVwbCA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcocmVwbCk7XG4gIHZhciBsZW4gPSByZXBsLmxlbmd0aDtcbiAgdmFyIG9yaWcgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKG9yaWcpO1xuICB2YXIgcmVzID0gXCJcIjsgLy9yZXN1bHRcbiAgdmFyIG4gPSAwOyAvLyBjdXJyZW50IHBvc2l0aW9uXG4gIHZhciBjdXI7IC8vY3VycmVudCBjaGFyXG4gIHZhciBzdGFydCwgZW5kLCBjO1xuICB3aGlsZShuIDwgbGVuKXtcbiAgICBjdXIgPSByZXBsLmNoYXJBdChuKyspO1xuICAgIGlmKGN1ciAhPSAnXFxcXCcpe1xuICAgICAgcmVzICs9IGN1cjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZihuID09IGxlbikgY2FtbF9mYWlsd2l0aChcIlN0ci5yZXBsYWNlOiBpbGxlZ2FsIGJhY2tzbGFzaCBzZXF1ZW5jZVwiKTtcbiAgICAgIGN1ciA9IHJlcGwuY2hhckF0KG4rKyk7XG4gICAgICBzd2l0Y2goY3VyKXtcbiAgICAgIGNhc2UgJ1xcXFwnOlxuICAgICAgICByZXMgKz0gY3VyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzAnOiBjYXNlICcxJzogY2FzZSAnMic6IGNhc2UgJzMnOiBjYXNlICc0JzpcbiAgICAgIGNhc2UgJzUnOiBjYXNlICc2JzogY2FzZSAnNyc6IGNhc2UgJzgnOiBjYXNlICc5JzpcbiAgICAgICAgYyA9ICtjdXI7XG4gICAgICAgIGlmIChjKjIgPj0gZ3JvdXBzLmxlbmd0aCAtIDEgKVxuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJTdHIucmVwbGFjZTogcmVmZXJlbmNlIHRvIHVubWF0Y2hlZCBncm91cFwiICk7XG4gICAgICAgIHN0YXJ0ID0gY2FtbF9hcnJheV9nZXQoZ3JvdXBzLGMqMik7XG4gICAgICAgIGVuZCA9IGNhbWxfYXJyYXlfZ2V0KGdyb3VwcywgYyoyICsxKTtcbiAgICAgICAgaWYgKHN0YXJ0ID09IC0xKVxuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJTdHIucmVwbGFjZTogcmVmZXJlbmNlIHRvIHVubWF0Y2hlZCBncm91cFwiKTtcbiAgICAgICAgcmVzKz1vcmlnLnNsaWNlKHN0YXJ0LGVuZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmVzICs9ICgnXFxcXCcgICsgY3VyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMocmVzKTsgfVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyX2luaXRpYWxpemVcbmZ1bmN0aW9uIGNhbWxfc3RyX2luaXRpYWxpemUodW5pdCkge1xuICByZXR1cm4gMDtcbn1cbiIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0aXZlIENhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgKi9cbi8qICBlbiBBdXRvbWF0aXF1ZS4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgICAgKi9cbi8qICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSwgd2l0aCAgICAgKi9cbi8qICB0aGUgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gZmlsZSAuLi9MSUNFTlNFLiAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLyogJElkOiBsZXhpbmcuYyA2MDQ1IDIwMDQtMDEtMDEgMTY6NDI6NDNaIGRvbGlnZXogJCAqL1xuXG4vKiBUaGUgdGFibGUtZHJpdmVuIGF1dG9tYXRvbiBmb3IgbGV4ZXJzIGdlbmVyYXRlZCBieSBjYW1sbGV4LiAqL1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2xleF9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9sZXhfYXJyYXkocykge1xuICBzID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhzKTtcbiAgdmFyIGwgPSBzLmxlbmd0aCAvIDI7XG4gIHZhciBhID0gbmV3IEFycmF5KGwpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKylcbiAgICBhW2ldID0gKHMuY2hhckNvZGVBdCgyICogaSkgfCAocy5jaGFyQ29kZUF0KDIgKiBpICsgMSkgPDwgOCkpIDw8IDE2ID4+IDE2O1xuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9sZXhfZW5naW5lXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoLCBjYW1sX2xleF9hcnJheSwgY2FtbF91aW50OF9hcnJheV9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9sZXhfZW5naW5lKHRibCwgc3RhcnRfc3RhdGUsIGxleGJ1Zikge1xuICB2YXIgbGV4X2J1ZmZlciA9IDI7XG4gIHZhciBsZXhfYnVmZmVyX2xlbiA9IDM7XG4gIHZhciBsZXhfc3RhcnRfcG9zID0gNTtcbiAgdmFyIGxleF9jdXJyX3BvcyA9IDY7XG4gIHZhciBsZXhfbGFzdF9wb3MgPSA3O1xuICB2YXIgbGV4X2xhc3RfYWN0aW9uID0gODtcbiAgdmFyIGxleF9lb2ZfcmVhY2hlZCA9IDk7XG4gIHZhciBsZXhfYmFzZSA9IDE7XG4gIHZhciBsZXhfYmFja3RyayA9IDI7XG4gIHZhciBsZXhfZGVmYXVsdCA9IDM7XG4gIHZhciBsZXhfdHJhbnMgPSA0O1xuICB2YXIgbGV4X2NoZWNrID0gNTtcblxuICBpZiAoIXRibC5sZXhfZGVmYXVsdCkge1xuICAgIHRibC5sZXhfYmFzZSA9ICAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2Jhc2VdKTtcbiAgICB0YmwubGV4X2JhY2t0cmsgPSBjYW1sX2xleF9hcnJheSAodGJsW2xleF9iYWNrdHJrXSk7XG4gICAgdGJsLmxleF9jaGVjayA9ICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfY2hlY2tdKTtcbiAgICB0YmwubGV4X3RyYW5zID0gICBjYW1sX2xleF9hcnJheSAodGJsW2xleF90cmFuc10pO1xuICAgIHRibC5sZXhfZGVmYXVsdCA9IGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2RlZmF1bHRdKTtcbiAgfVxuXG4gIHZhciBjLCBzdGF0ZSA9IHN0YXJ0X3N0YXRlO1xuXG4gIHZhciBidWZmZXIgPSBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzKGxleGJ1ZltsZXhfYnVmZmVyXSk7XG5cbiAgaWYgKHN0YXRlID49IDApIHtcbiAgICAvKiBGaXJzdCBlbnRyeSAqL1xuICAgIGxleGJ1ZltsZXhfbGFzdF9wb3NdID0gbGV4YnVmW2xleF9zdGFydF9wb3NdID0gbGV4YnVmW2xleF9jdXJyX3Bvc107XG4gICAgbGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPSAtMTtcbiAgfSBlbHNlIHtcbiAgICAvKiBSZWVudHJ5IGFmdGVyIHJlZmlsbCAqL1xuICAgIHN0YXRlID0gLXN0YXRlIC0gMTtcbiAgfVxuICBmb3IoOzspIHtcbiAgICAvKiBMb29rdXAgYmFzZSBhZGRyZXNzIG9yIGFjdGlvbiBudW1iZXIgZm9yIGN1cnJlbnQgc3RhdGUgKi9cbiAgICB2YXIgYmFzZSA9IHRibC5sZXhfYmFzZVtzdGF0ZV07XG4gICAgaWYgKGJhc2UgPCAwKSByZXR1cm4gLWJhc2UtMTtcbiAgICAvKiBTZWUgaWYgaXQncyBhIGJhY2t0cmFjayBwb2ludCAqL1xuICAgIHZhciBiYWNrdHJrID0gdGJsLmxleF9iYWNrdHJrW3N0YXRlXTtcbiAgICBpZiAoYmFja3RyayA+PSAwKSB7XG4gICAgICBsZXhidWZbbGV4X2xhc3RfcG9zXSA9IGxleGJ1ZltsZXhfY3Vycl9wb3NdO1xuICAgICAgbGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPSBiYWNrdHJrO1xuICAgIH1cbiAgICAvKiBTZWUgaWYgd2UgbmVlZCBhIHJlZmlsbCAqL1xuICAgIGlmIChsZXhidWZbbGV4X2N1cnJfcG9zXSA+PSBsZXhidWZbbGV4X2J1ZmZlcl9sZW5dKXtcbiAgICAgIGlmIChsZXhidWZbbGV4X2VvZl9yZWFjaGVkXSA9PSAwKVxuICAgICAgICByZXR1cm4gLXN0YXRlIC0gMTtcbiAgICAgIGVsc2VcbiAgICAgICAgYyA9IDI1NjtcbiAgICB9ZWxzZXtcbiAgICAgIC8qIFJlYWQgbmV4dCBpbnB1dCBjaGFyICovXG4gICAgICBjID0gYnVmZmVyW2xleGJ1ZltsZXhfY3Vycl9wb3NdXTtcbiAgICAgIGxleGJ1ZltsZXhfY3Vycl9wb3NdICsrO1xuICAgIH1cbiAgICAvKiBEZXRlcm1pbmUgbmV4dCBzdGF0ZSAqL1xuICAgIGlmICh0YmwubGV4X2NoZWNrW2Jhc2UgKyBjXSA9PSBzdGF0ZSlcbiAgICAgIHN0YXRlID0gdGJsLmxleF90cmFuc1tiYXNlICsgY107XG4gICAgZWxzZVxuICAgICAgc3RhdGUgPSB0YmwubGV4X2RlZmF1bHRbc3RhdGVdO1xuICAgIC8qIElmIG5vIHRyYW5zaXRpb24gb24gdGhpcyBjaGFyLCByZXR1cm4gdG8gbGFzdCBiYWNrdHJhY2sgcG9pbnQgKi9cbiAgICBpZiAoc3RhdGUgPCAwKSB7XG4gICAgICBsZXhidWZbbGV4X2N1cnJfcG9zXSA9IGxleGJ1ZltsZXhfbGFzdF9wb3NdO1xuICAgICAgaWYgKGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dID09IC0xKVxuICAgICAgICBjYW1sX2ZhaWx3aXRoKFwibGV4aW5nOiBlbXB0eSB0b2tlblwiKTtcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dO1xuICAgIH1lbHNle1xuICAgICAgLyogRXJhc2UgdGhlIEVPRiBjb25kaXRpb24gb25seSBpZiB0aGUgRU9GIHBzZXVkby1jaGFyYWN0ZXIgd2FzXG4gICAgICAgICBjb25zdW1lZCBieSB0aGUgYXV0b21hdG9uIChpLmUuIHRoZXJlIHdhcyBubyBiYWNrdHJhY2sgYWJvdmUpXG4gICAgICAqL1xuICAgICAgaWYgKGMgPT0gMjU2KSBsZXhidWZbbGV4X2VvZl9yZWFjaGVkXSA9IDA7XG4gICAgfVxuICB9XG59XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qIE5ldyBsZXhlciBlbmdpbmUsIHdpdGggbWVtb3J5IG9mIHBvc2l0aW9ucyAgKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLy9Qcm92aWRlczogY2FtbF9uZXdfbGV4X2VuZ2luZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgY2FtbF9sZXhfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmcsIGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbGV4X3J1bl9tZW0ocywgaSwgbWVtLCBjdXJyX3Bvcykge1xuICBmb3IgKDs7KSB7XG4gICAgdmFyIGRzdCA9IHMuY2hhckNvZGVBdChpKTsgaSsrO1xuICAgIGlmIChkc3QgPT0gMHhmZikgcmV0dXJuO1xuICAgIHZhciBzcmMgPSBzLmNoYXJDb2RlQXQoaSk7IGkrKztcbiAgICBpZiAoc3JjID09IDB4ZmYpXG4gICAgICBtZW0gW2RzdCArIDFdID0gY3Vycl9wb3M7XG4gICAgZWxzZVxuICAgICAgbWVtIFtkc3QgKyAxXSA9IG1lbSBbc3JjICsgMV07XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FtbF9sZXhfcnVuX3RhZyhzLCBpLCBtZW0pIHtcbiAgZm9yICg7Oykge1xuICAgIHZhciBkc3QgPSBzLmNoYXJDb2RlQXQoaSk7IGkrKztcbiAgICBpZiAoZHN0ID09IDB4ZmYpIHJldHVybiA7XG4gICAgdmFyIHNyYyA9IHMuY2hhckNvZGVBdChpKTsgaSsrO1xuICAgIGlmIChzcmMgPT0gMHhmZilcbiAgICAgIG1lbSBbZHN0ICsgMV0gPSAtMTtcbiAgICBlbHNlXG4gICAgICBtZW0gW2RzdCArIDFdID0gbWVtIFtzcmMgKyAxXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYW1sX25ld19sZXhfZW5naW5lKHRibCwgc3RhcnRfc3RhdGUsIGxleGJ1Zikge1xuICB2YXIgbGV4X2J1ZmZlciA9IDI7XG4gIHZhciBsZXhfYnVmZmVyX2xlbiA9IDM7XG4gIHZhciBsZXhfc3RhcnRfcG9zID0gNTtcbiAgdmFyIGxleF9jdXJyX3BvcyA9IDY7XG4gIHZhciBsZXhfbGFzdF9wb3MgPSA3O1xuICB2YXIgbGV4X2xhc3RfYWN0aW9uID0gODtcbiAgdmFyIGxleF9lb2ZfcmVhY2hlZCA9IDk7XG4gIHZhciBsZXhfbWVtID0gMTA7XG4gIHZhciBsZXhfYmFzZSA9IDE7XG4gIHZhciBsZXhfYmFja3RyayA9IDI7XG4gIHZhciBsZXhfZGVmYXVsdCA9IDM7XG4gIHZhciBsZXhfdHJhbnMgPSA0O1xuICB2YXIgbGV4X2NoZWNrID0gNTtcbiAgdmFyIGxleF9iYXNlX2NvZGUgPSA2O1xuICB2YXIgbGV4X2JhY2t0cmtfY29kZSA9IDc7XG4gIHZhciBsZXhfZGVmYXVsdF9jb2RlID0gODtcbiAgdmFyIGxleF90cmFuc19jb2RlID0gOTtcbiAgdmFyIGxleF9jaGVja19jb2RlID0gMTA7XG4gIHZhciBsZXhfY29kZSA9IDExO1xuXG4gIGlmICghdGJsLmxleF9kZWZhdWx0KSB7XG4gICAgdGJsLmxleF9iYXNlID0gICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfYmFzZV0pO1xuICAgIHRibC5sZXhfYmFja3RyayA9IGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2JhY2t0cmtdKTtcbiAgICB0YmwubGV4X2NoZWNrID0gICBjYW1sX2xleF9hcnJheSAodGJsW2xleF9jaGVja10pO1xuICAgIHRibC5sZXhfdHJhbnMgPSAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X3RyYW5zXSk7XG4gICAgdGJsLmxleF9kZWZhdWx0ID0gY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfZGVmYXVsdF0pO1xuICB9XG4gIGlmICghdGJsLmxleF9kZWZhdWx0X2NvZGUpIHtcbiAgICB0YmwubGV4X2Jhc2VfY29kZSA9ICAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2Jhc2VfY29kZV0pO1xuICAgIHRibC5sZXhfYmFja3Rya19jb2RlID0gY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfYmFja3Rya19jb2RlXSk7XG4gICAgdGJsLmxleF9jaGVja19jb2RlID0gICBjYW1sX2xleF9hcnJheSAodGJsW2xleF9jaGVja19jb2RlXSk7XG4gICAgdGJsLmxleF90cmFuc19jb2RlID0gICBjYW1sX2xleF9hcnJheSAodGJsW2xleF90cmFuc19jb2RlXSk7XG4gICAgdGJsLmxleF9kZWZhdWx0X2NvZGUgPSBjYW1sX2xleF9hcnJheSAodGJsW2xleF9kZWZhdWx0X2NvZGVdKTtcbiAgfVxuICBpZiAodGJsLmxleF9jb2RlID09IG51bGwpIHRibC5sZXhfY29kZSA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcodGJsW2xleF9jb2RlXSk7XG5cbiAgdmFyIGMsIHN0YXRlID0gc3RhcnRfc3RhdGU7XG5cbiAgdmFyIGJ1ZmZlciA9IGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXMobGV4YnVmW2xleF9idWZmZXJdKTtcblxuICBpZiAoc3RhdGUgPj0gMCkge1xuICAgIC8qIEZpcnN0IGVudHJ5ICovXG4gICAgbGV4YnVmW2xleF9sYXN0X3Bvc10gPSBsZXhidWZbbGV4X3N0YXJ0X3Bvc10gPSBsZXhidWZbbGV4X2N1cnJfcG9zXTtcbiAgICBsZXhidWZbbGV4X2xhc3RfYWN0aW9uXSA9IC0xO1xuICB9IGVsc2Uge1xuICAgIC8qIFJlZW50cnkgYWZ0ZXIgcmVmaWxsICovXG4gICAgc3RhdGUgPSAtc3RhdGUgLSAxO1xuICB9XG4gIGZvcig7Oykge1xuICAgIC8qIExvb2t1cCBiYXNlIGFkZHJlc3Mgb3IgYWN0aW9uIG51bWJlciBmb3IgY3VycmVudCBzdGF0ZSAqL1xuICAgIHZhciBiYXNlID0gdGJsLmxleF9iYXNlW3N0YXRlXTtcbiAgICBpZiAoYmFzZSA8IDApIHtcbiAgICAgIHZhciBwY19vZmYgPSB0YmwubGV4X2Jhc2VfY29kZVtzdGF0ZV07XG4gICAgICBjYW1sX2xleF9ydW5fdGFnKHRibC5sZXhfY29kZSwgcGNfb2ZmLCBsZXhidWZbbGV4X21lbV0pO1xuICAgICAgcmV0dXJuIC1iYXNlLTE7XG4gICAgfVxuICAgIC8qIFNlZSBpZiBpdCdzIGEgYmFja3RyYWNrIHBvaW50ICovXG4gICAgdmFyIGJhY2t0cmsgPSB0YmwubGV4X2JhY2t0cmtbc3RhdGVdO1xuICAgIGlmIChiYWNrdHJrID49IDApIHtcbiAgICAgIHZhciBwY19vZmYgPSB0YmwubGV4X2JhY2t0cmtfY29kZVtzdGF0ZV07XG4gICAgICBjYW1sX2xleF9ydW5fdGFnKHRibC5sZXhfY29kZSwgcGNfb2ZmLCBsZXhidWZbbGV4X21lbV0pO1xuICAgICAgbGV4YnVmW2xleF9sYXN0X3Bvc10gPSBsZXhidWZbbGV4X2N1cnJfcG9zXTtcbiAgICAgIGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dID0gYmFja3RyaztcbiAgICB9XG4gICAgLyogU2VlIGlmIHdlIG5lZWQgYSByZWZpbGwgKi9cbiAgICBpZiAobGV4YnVmW2xleF9jdXJyX3Bvc10gPj0gbGV4YnVmW2xleF9idWZmZXJfbGVuXSl7XG4gICAgICBpZiAobGV4YnVmW2xleF9lb2ZfcmVhY2hlZF0gPT0gMClcbiAgICAgICAgcmV0dXJuIC1zdGF0ZSAtIDE7XG4gICAgICBlbHNlXG4gICAgICAgIGMgPSAyNTY7XG4gICAgfWVsc2V7XG4gICAgICAvKiBSZWFkIG5leHQgaW5wdXQgY2hhciAqL1xuICAgICAgYyA9IGJ1ZmZlcltsZXhidWZbbGV4X2N1cnJfcG9zXV07XG4gICAgICBsZXhidWZbbGV4X2N1cnJfcG9zXSArKztcbiAgICB9XG4gICAgLyogRGV0ZXJtaW5lIG5leHQgc3RhdGUgKi9cbiAgICB2YXIgcHN0YXRlID0gc3RhdGUgO1xuICAgIGlmICh0YmwubGV4X2NoZWNrW2Jhc2UgKyBjXSA9PSBzdGF0ZSlcbiAgICAgIHN0YXRlID0gdGJsLmxleF90cmFuc1tiYXNlICsgY107XG4gICAgZWxzZVxuICAgICAgc3RhdGUgPSB0YmwubGV4X2RlZmF1bHRbc3RhdGVdO1xuICAgIC8qIElmIG5vIHRyYW5zaXRpb24gb24gdGhpcyBjaGFyLCByZXR1cm4gdG8gbGFzdCBiYWNrdHJhY2sgcG9pbnQgKi9cbiAgICBpZiAoc3RhdGUgPCAwKSB7XG4gICAgICBsZXhidWZbbGV4X2N1cnJfcG9zXSA9IGxleGJ1ZltsZXhfbGFzdF9wb3NdO1xuICAgICAgaWYgKGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dID09IC0xKVxuICAgICAgICBjYW1sX2ZhaWx3aXRoKFwibGV4aW5nOiBlbXB0eSB0b2tlblwiKTtcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dO1xuICAgIH1lbHNle1xuICAgICAgLyogSWYgc29tZSB0cmFuc2l0aW9uLCBnZXQgYW5kIHBlcmZvcm0gbWVtb3J5IG1vdmVzICovXG4gICAgICB2YXIgYmFzZV9jb2RlID0gdGJsLmxleF9iYXNlX2NvZGVbcHN0YXRlXSwgcGNfb2ZmO1xuICAgICAgaWYgKHRibC5sZXhfY2hlY2tfY29kZVtiYXNlX2NvZGUgKyBjXSA9PSBwc3RhdGUpXG4gICAgICAgIHBjX29mZiA9IHRibC5sZXhfdHJhbnNfY29kZVtiYXNlX2NvZGUgKyBjXTtcbiAgICAgIGVsc2VcbiAgICAgICAgcGNfb2ZmID0gdGJsLmxleF9kZWZhdWx0X2NvZGVbcHN0YXRlXTtcbiAgICAgIGlmIChwY19vZmYgPiAwKVxuICAgICAgICBjYW1sX2xleF9ydW5fbWVtXG4gICAgICAodGJsLmxleF9jb2RlLCBwY19vZmYsIGxleGJ1ZltsZXhfbWVtXSwgbGV4YnVmW2xleF9jdXJyX3Bvc10pO1xuICAgICAgLyogRXJhc2UgdGhlIEVPRiBjb25kaXRpb24gb25seSBpZiB0aGUgRU9GIHBzZXVkby1jaGFyYWN0ZXIgd2FzXG4gICAgICAgICBjb25zdW1lZCBieSB0aGUgYXV0b21hdG9uIChpLmUuIHRoZXJlIHdhcyBubyBiYWNrdHJhY2sgYWJvdmUpXG4gICAgICAqL1xuICAgICAgaWYgKGMgPT0gMjU2KSBsZXhidWZbbGV4X2VvZl9yZWFjaGVkXSA9IDA7XG4gICAgfVxuICB9XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLy8vLy8vLy8vLy8vIEFycmF5XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfc3ViIG11dGFibGVcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfc3ViIChhLCBpLCBsZW4pIHtcbiAgdmFyIGEyID0gbmV3IEFycmF5KGxlbisxKTtcbiAgYTJbMF09MDtcbiAgZm9yKHZhciBpMiA9IDEsIGkxPSBpKzE7IGkyIDw9IGxlbjsgaTIrKyxpMSsrICl7XG4gICAgYTJbaTJdPWFbaTFdO1xuICB9XG4gIHJldHVybiBhMjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9hcHBlbmQgbXV0YWJsZVxuZnVuY3Rpb24gY2FtbF9hcnJheV9hcHBlbmQoYTEsIGEyKSB7XG4gIHZhciBsMSA9IGExLmxlbmd0aCwgbDIgPSBhMi5sZW5ndGg7XG4gIHZhciBsID0gbDErbDItMVxuICB2YXIgYSA9IG5ldyBBcnJheShsKTtcbiAgYVswXSA9IDA7XG4gIHZhciBpID0gMSxqID0gMTtcbiAgZm9yKDtpPGwxO2krKykgYVtpXT1hMVtpXTtcbiAgZm9yKDtpPGw7aSsrLGorKykgYVtpXT1hMltqXTtcbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfY29uY2F0IG11dGFibGVcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfY29uY2F0KGwpIHtcbiAgdmFyIGEgPSBbMF07XG4gIHdoaWxlIChsICE9PSAwKSB7XG4gICAgdmFyIGIgPSBsWzFdO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYi5sZW5ndGg7IGkrKykgYS5wdXNoKGJbaV0pO1xuICAgIGwgPSBsWzJdO1xuICB9XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X2JsaXRcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfYmxpdChhMSwgaTEsIGEyLCBpMiwgbGVuKSB7XG4gIGlmIChpMiA8PSBpMSkge1xuICAgIGZvciAodmFyIGogPSAxOyBqIDw9IGxlbjsgaisrKSBhMltpMiArIGpdID0gYTFbaTEgKyBqXTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBqID0gbGVuOyBqID49IDE7IGotLSkgYTJbaTIgKyBqXSA9IGExW2kxICsgal07XG4gIH07XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zsb2F0YXJyYXlfYmxpdFxuZnVuY3Rpb24gY2FtbF9mbG9hdGFycmF5X2JsaXQoYTEsIGkxLCBhMiwgaTIsIGxlbikge1xuICBpZiAoaTIgPD0gaTEpIHtcbiAgICBmb3IgKHZhciBqID0gMTsgaiA8PSBsZW47IGorKykgYTJbaTIgKyBqXSA9IGExW2kxICsgal07XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaiA9IGxlbjsgaiA+PSAxOyBqLS0pIGEyW2kyICsgal0gPSBhMVtpMSArIGpdO1xuICB9O1xuICByZXR1cm4gMDtcbn1cblxuLy8vLy8vLy8vLy8vLyBQZXJ2YXNpdmVcbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfc2V0IChtdXRhYmxlLCBjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2FycmF5X3NldCAoYXJyYXksIGluZGV4LCBuZXd2YWwpIHtcbiAgaWYgKChpbmRleCA8IDApIHx8IChpbmRleCA+PSBhcnJheS5sZW5ndGggLSAxKSkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICBhcnJheVtpbmRleCsxXT1uZXd2YWw7IHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X2dldCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2FycmF5X2dldCAoYXJyYXksIGluZGV4KSB7XG4gIGlmICgoaW5kZXggPCAwKSB8fCAoaW5kZXggPj0gYXJyYXkubGVuZ3RoIC0gMSkpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgcmV0dXJuIGFycmF5W2luZGV4KzFdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X2ZpbGxcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfZmlsbChhcnJheSwgb2ZzLCBsZW4sIHYpe1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspe1xuICAgIGFycmF5W29mcytpKzFdID0gdjtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jaGVja19ib3VuZCAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9jaGVja19ib3VuZCAoYXJyYXksIGluZGV4KSB7XG4gIGlmIChpbmRleCA+Pj4gMCA+PSBhcnJheS5sZW5ndGggLSAxKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBhcnJheTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tYWtlX3ZlY3QgY29uc3QgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfbWFrZV92ZWN0IChsZW4sIGluaXQpIHtcbiAgaWYgKGxlbiA8IDApIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGxlbiA9IGxlbiArIDEgfCAwO1xuICB2YXIgYiA9IG5ldyBBcnJheShsZW4pO1xuICBiWzBdPTA7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIGJbaV0gPSBpbml0O1xuICByZXR1cm4gYjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tYWtlX2Zsb2F0X3ZlY3QgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9tYWtlX2Zsb2F0X3ZlY3QobGVuKXtcbiAgaWYgKGxlbiA8IDApIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGxlbiA9IGxlbiArIDEgfCAwO1xuICB2YXIgYiA9IG5ldyBBcnJheShsZW4pO1xuICBiWzBdPTI1NDtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykgYltpXSA9IDA7XG4gIHJldHVybiBiXG59XG4vL1Byb3ZpZGVzOiBjYW1sX2Zsb2F0YXJyYXlfY3JlYXRlIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfZmxvYXRhcnJheV9jcmVhdGUobGVuKXtcbiAgaWYgKGxlbiA8IDApIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGxlbiA9IGxlbiArIDEgfCAwO1xuICB2YXIgYiA9IG5ldyBBcnJheShsZW4pO1xuICBiWzBdPTI1NDtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykgYltpXSA9IDA7XG4gIHJldHVybiBiXG59XG4iLCIvL1Byb3ZpZGVzOiBCYXNlX2ludF9tYXRoX2ludF9wb3Bjb3VudCBjb25zdFxuZnVuY3Rpb24gQmFzZV9pbnRfbWF0aF9pbnRfcG9wY291bnQodikge1xuICB2ID0gdiAtICgodiA+Pj4gMSkgJiAweDU1NTU1NTU1KTtcbiAgdiA9ICh2ICYgMHgzMzMzMzMzMykgKyAoKHYgPj4+IDIpICYgMHgzMzMzMzMzMyk7XG4gIHJldHVybiAoKHYgKyAodiA+Pj4gNCkgJiAweEYwRjBGMEYpICogMHgxMDEwMTAxKSA+Pj4gMjQ7XG59XG5cbi8vUHJvdmlkZXM6IEJhc2VfY2xlYXJfY2FtbF9iYWNrdHJhY2VfcG9zIGNvbnN0XG5mdW5jdGlvbiBCYXNlX2NsZWFyX2NhbWxfYmFja3RyYWNlX3Bvcyh4KSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBCYXNlX2NhbWxfZXhuX2lzX21vc3RfcmVjZW50X2V4biBjb25zdFxuZnVuY3Rpb24gQmFzZV9jYW1sX2V4bl9pc19tb3N0X3JlY2VudF9leG4oeCkge1xuICByZXR1cm4gMTtcbn1cblxuLy9Qcm92aWRlczogQmFzZV9pbnRfbWF0aF9pbnQzMl9jbHogY29uc3RcbmZ1bmN0aW9uIEJhc2VfaW50X21hdGhfaW50MzJfY2x6KHgpIHtcbiAgdmFyIG4gPSAzMjtcbiAgdmFyIHk7XG4gIHkgPSB4ID4+MTY7IGlmICh5ICE9IDApIHsgbiA9IG4gLTE2OyB4ID0geTsgfVxuICB5ID0geCA+PiA4OyBpZiAoeSAhPSAwKSB7IG4gPSBuIC0gODsgeCA9IHk7IH1cbiAgeSA9IHggPj4gNDsgaWYgKHkgIT0gMCkgeyBuID0gbiAtIDQ7IHggPSB5OyB9XG4gIHkgPSB4ID4+IDI7IGlmICh5ICE9IDApIHsgbiA9IG4gLSAyOyB4ID0geTsgfVxuICB5ID0geCA+PiAxOyBpZiAoeSAhPSAwKSByZXR1cm4gbiAtIDI7XG4gIHJldHVybiBuIC0geDtcbn1cblxuLy9Qcm92aWRlczogQmFzZV9pbnRfbWF0aF9pbnRfY2x6IGNvbnN0XG4vL1JlcXVpcmVzOiBCYXNlX2ludF9tYXRoX2ludDMyX2NselxuZnVuY3Rpb24gQmFzZV9pbnRfbWF0aF9pbnRfY2x6KHgpIHsgcmV0dXJuIEJhc2VfaW50X21hdGhfaW50MzJfY2x6KHgpOyB9XG5cbi8vUHJvdmlkZXM6IEJhc2VfaW50X21hdGhfbmF0aXZlaW50X2NseiBjb25zdFxuLy9SZXF1aXJlczogQmFzZV9pbnRfbWF0aF9pbnQzMl9jbHpcbmZ1bmN0aW9uIEJhc2VfaW50X21hdGhfbmF0aXZlaW50X2Nseih4KSB7IHJldHVybiBCYXNlX2ludF9tYXRoX2ludDMyX2Nseih4KTsgfVxuXG4vL1Byb3ZpZGVzOiBCYXNlX2ludF9tYXRoX2ludDY0X2NseiBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCwgY2FtbF9pbnQ2NF9pc196ZXJvLCBjYW1sX2ludDY0X3RvX2ludDMyXG5mdW5jdGlvbiBCYXNlX2ludF9tYXRoX2ludDY0X2Nseih4KSB7XG4gIHZhciBuID0gNjQ7XG4gIHZhciB5O1xuICB5ID0gY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCh4LCAzMik7XG4gIGlmICghY2FtbF9pbnQ2NF9pc196ZXJvKHkpKSB7IG4gPSBuIC0zMjsgeCA9IHk7IH1cbiAgeSA9IGNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWQoeCwgMTYpO1xuICBpZiAoIWNhbWxfaW50NjRfaXNfemVybyh5KSkgeyBuID0gbiAtMTY7IHggPSB5OyB9XG4gIHkgPSBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkKHgsIDgpO1xuICBpZiAoIWNhbWxfaW50NjRfaXNfemVybyh5KSkgeyBuID0gbiAtIDg7IHggPSB5OyB9XG4gIHkgPSBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkKHgsIDQpO1xuICBpZiAoIWNhbWxfaW50NjRfaXNfemVybyh5KSkgeyBuID0gbiAtIDQ7IHggPSB5OyB9XG4gIHkgPSBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkKHgsIDIpO1xuICBpZiAoIWNhbWxfaW50NjRfaXNfemVybyh5KSkgeyBuID0gbiAtIDI7IHggPSB5OyB9XG4gIHkgPSBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkKHgsIDEpO1xuICBpZiAoIWNhbWxfaW50NjRfaXNfemVybyh5KSkgcmV0dXJuIG4gLSAyO1xuICByZXR1cm4gbiAtIGNhbWxfaW50NjRfdG9faW50MzIoeCk7XG59XG5cbi8vUHJvdmlkZXM6IEJhc2VfaW50X21hdGhfaW50MzJfY3R6IGNvbnN0XG5mdW5jdGlvbiBCYXNlX2ludF9tYXRoX2ludDMyX2N0eih4KSB7XG4gIGlmICh4ID09PSAwKSB7IHJldHVybiAzMjsgfVxuICB2YXIgbiA9IDE7XG4gIGlmICggKHggJiAweDAwMDBGRkZGKSA9PT0gMCkgeyBuID0gbiArIDE2OyB4ID0geCA+PiAxNjsgfVxuICBpZiAoICh4ICYgMHgwMDAwMDBGRikgPT09IDApIHsgbiA9IG4gKyAgODsgeCA9IHggPj4gIDg7IH1cbiAgaWYgKCAoeCAmIDB4MDAwMDAwMEYpID09PSAwKSB7IG4gPSBuICsgIDQ7IHggPSB4ID4+ICA0OyB9XG4gIGlmICggKHggJiAweDAwMDAwMDAzKSA9PT0gMCkgeyBuID0gbiArICAyOyB4ID0geCA+PiAgMjsgfVxuICByZXR1cm4gbiAtICh4ICYgMSk7XG59XG5cbi8vUHJvdmlkZXM6IEJhc2VfaW50X21hdGhfaW50X2N0eiBjb25zdFxuLy9SZXF1aXJlczogQmFzZV9pbnRfbWF0aF9pbnQzMl9jdHpcbmZ1bmN0aW9uIEJhc2VfaW50X21hdGhfaW50X2N0eih4KSB7IHJldHVybiBCYXNlX2ludF9tYXRoX2ludDMyX2N0eih4KTsgfVxuXG4vL1Byb3ZpZGVzOiBCYXNlX2ludF9tYXRoX25hdGl2ZWludF9jdHogY29uc3Rcbi8vUmVxdWlyZXM6IEJhc2VfaW50X21hdGhfaW50MzJfY3R6XG5mdW5jdGlvbiBCYXNlX2ludF9tYXRoX25hdGl2ZWludF9jdHooeCkgeyByZXR1cm4gQmFzZV9pbnRfbWF0aF9pbnQzMl9jdHooeCk7IH1cblxuLy9Qcm92aWRlczogQmFzZV9pbnRfbWF0aF9pbnQ2NF9jdHogY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWQsIGNhbWxfaW50NjRfaXNfemVybywgY2FtbF9pbnQ2NF90b19pbnQzMlxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9hbmQsIGNhbWxfaW50NjRfb2ZfaW50MzIsIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpXG5mdW5jdGlvbiBCYXNlX2ludF9tYXRoX2ludDY0X2N0eih4KSB7XG4gIGlmIChjYW1sX2ludDY0X2lzX3plcm8oeCkpIHsgcmV0dXJuIDY0OyB9XG4gIHZhciBuID0gMTtcbiAgZnVuY3Rpb24gaXNfemVybyAoeCkgICAgeyByZXR1cm4gY2FtbF9pbnQ2NF9pc196ZXJvKHgpOyB9XG4gIGZ1bmN0aW9uIGxhbmQgKHgseSkgICAgIHsgcmV0dXJuIGNhbWxfaW50NjRfYW5kKHgsIHkpOyB9XG4gIGZ1bmN0aW9uIHNtYWxsX2ludDY0KHgpIHsgcmV0dXJuIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpKHgsMCwwKTsgfVxuICBpZiAoaXNfemVybyhsYW5kKHgsIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpKDB4RkZGRkZGLCAweDAwMDBGRiwgMHgwMDAwKSkpKSB7XG4gICAgbiA9IG4gKyAzMjsgeCA9IGNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWQoeCwgMzIpO1xuICB9XG4gIGlmIChpc196ZXJvKGxhbmQoeCwgc21hbGxfaW50NjQoMHgwMEZGRkYpKSkpIHtcbiAgICBuID0gbiArIDE2OyB4ID0gY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCh4LCAxNik7XG4gIH1cbiAgaWYgKGlzX3plcm8obGFuZCh4LCBzbWFsbF9pbnQ2NCgweDAwMDBGRikpKSkge1xuICAgIG4gPSBuICsgIDg7IHggPSBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkKHgsIDgpO1xuICB9XG4gIGlmIChpc196ZXJvKGxhbmQoeCwgc21hbGxfaW50NjQoMHgwMDAwMEYpKSkpIHtcbiAgICBuID0gbiArICA0OyB4ID0gY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCh4LCA0KTtcbiAgfVxuICBpZiAoaXNfemVybyhsYW5kKHgsIHNtYWxsX2ludDY0KDB4MDAwMDAzKSkpKSB7XG4gICAgbiA9IG4gKyAgMjsgeCA9IGNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWQoeCwgMik7XG4gIH1cbiAgcmV0dXJuIG4gLSAoY2FtbF9pbnQ2NF90b19pbnQzMihjYW1sX2ludDY0X2FuZCh4LCBzbWFsbF9pbnQ2NCgweDAwMDAwMSkpKSk7XG59XG5cbi8vUHJvdmlkZXM6IEJhc2VfaW50X21hdGhfaW50X3Bvd19zdHViIGNvbnN0XG5mdW5jdGlvbiBCYXNlX2ludF9tYXRoX2ludF9wb3dfc3R1YihiYXNlLCBleHBvbmVudCkge1xuICB2YXIgb25lID0gMTtcbiAgdmFyIG11bCA9IFtvbmUsIGJhc2UsIG9uZSwgb25lXTtcbiAgdmFyIHJlcyA9IG9uZTtcbiAgd2hpbGUgKCFleHBvbmVudD09MCkge1xuICAgIG11bFsxXSA9IChtdWxbMV0gKiBtdWxbM10pIHwgMDtcbiAgICBtdWxbMl0gPSAobXVsWzFdICogbXVsWzFdKSB8IDA7XG4gICAgbXVsWzNdID0gKG11bFsyXSAqIG11bFsxXSkgfCAwO1xuICAgIHJlcyA9IChyZXMgKiBtdWxbZXhwb25lbnQgJiAzXSkgfCAwO1xuICAgIGV4cG9uZW50ID0gZXhwb25lbnQgPj4gMjtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBCYXNlX2ludF9tYXRoX2ludDY0X3Bvd19zdHViIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X211bCwgY2FtbF9pbnQ2NF9pc196ZXJvLCBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2NyZWF0ZV9sb19oaSwgY2FtbF9pbnQ2NF9sbzMyXG5mdW5jdGlvbiBCYXNlX2ludF9tYXRoX2ludDY0X3Bvd19zdHViKGJhc2UsIGV4cG9uZW50KSB7XG4gIHZhciBvbmUgPSBjYW1sX2ludDY0X2NyZWF0ZV9sb19oaSgxLDApO1xuICB2YXIgbXVsID0gW29uZSwgYmFzZSwgb25lLCBvbmVdO1xuICB2YXIgcmVzID0gb25lO1xuICB3aGlsZSAoIWNhbWxfaW50NjRfaXNfemVybyhleHBvbmVudCkpIHtcbiAgICBtdWxbMV0gPSBjYW1sX2ludDY0X211bChtdWxbMV0sIG11bFszXSk7XG4gICAgbXVsWzJdID0gY2FtbF9pbnQ2NF9tdWwobXVsWzFdLCBtdWxbMV0pO1xuICAgIG11bFszXSA9IGNhbWxfaW50NjRfbXVsKG11bFsyXSwgbXVsWzFdKTtcbiAgICByZXMgPSBjYW1sX2ludDY0X211bChyZXMsIG11bFtjYW1sX2ludDY0X2xvMzIoZXhwb25lbnQpICYgM10pO1xuICAgIGV4cG9uZW50ID0gY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZChleHBvbmVudCwgMik7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogQmFzZV9oYXNoX3N0cmluZyBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hcbmZ1bmN0aW9uIEJhc2VfaGFzaF9zdHJpbmcocykge1xuICByZXR1cm4gY2FtbF9oYXNoKDEsMSwwLHMpXG59XG4vL1Byb3ZpZGVzOiBCYXNlX2hhc2hfZG91YmxlIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hcbmZ1bmN0aW9uIEJhc2VfaGFzaF9kb3VibGUoZCkge1xuICByZXR1cm4gY2FtbF9oYXNoKDEsMSwwLGQpO1xufVxuXG4vL1Byb3ZpZGVzOiBCYXNlX2FtX3Rlc3RpbmcgY29uc3Rcbi8vV2Vha2RlZlxuZnVuY3Rpb24gQmFzZV9hbV90ZXN0aW5nKHgpIHtcbiAgcmV0dXJuIDA7XG59XG4iLCJcbi8vUHJvdmlkZXM6IE1sTXV0ZXhcbmZ1bmN0aW9uIE1sTXV0ZXgoKSB7XG4gIHRoaXMubG9ja2VkID0gZmFsc2Vcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9tdXRleF9uZXdcbi8vUmVxdWlyZXM6IE1sTXV0ZXhcbmZ1bmN0aW9uIGNhbWxfbWxfbXV0ZXhfbmV3KHVuaXQpIHtcbiAgcmV0dXJuIG5ldyBNbE11dGV4KCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfbXV0ZXhfbG9ja1xuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9tbF9tdXRleF9sb2NrKHQpIHtcbiAgaWYodC5sb2NrZWQpXG4gICAgY2FtbF9mYWlsd2l0aChcIk11dGV4LmxvY2s6IG11dGV4IGFscmVhZHkgbG9ja2VkLiBDYW5ub3Qgd2FpdC5cIik7XG4gIGVsc2UgdC5sb2NrZWQgPSB0cnVlO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9tdXRleF90cnlfbG9ja1xuZnVuY3Rpb24gY2FtbF9tbF9tdXRleF90cnlfbG9jayh0KSB7XG4gIGlmKCF0LmxvY2tlZCkge1xuICAgIHQubG9ja2VkID0gdHJ1ZTtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9tdXRleF91bmxvY2tcbmZ1bmN0aW9uIGNhbWxfbWxfbXV0ZXhfdW5sb2NrKHQpIHtcbiAgdC5sb2NrZWQgPSBmYWxzZTtcbiAgcmV0dXJuIDA7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8gV2VhayBBUElcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2tleV9vZmZzZXRcbnZhciBjYW1sX2VwaGVfa2V5X29mZnNldCA9IDNcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG52YXIgY2FtbF9lcGhlX2RhdGFfb2Zmc2V0ID0gMlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfc2V0X2tleVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2VwaGVfa2V5X29mZnNldFxuZnVuY3Rpb24gY2FtbF9lcGhlX3NldF9rZXkoeCwgaSwgdikge1xuICBpZihpIDwgMCB8fCBjYW1sX2VwaGVfa2V5X29mZnNldCArIGkgPj0geC5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcIldlYWsuc2V0XCIpO1xuICBpZiAodiBpbnN0YW5jZW9mIE9iamVjdCAmJiBnbG9iYWxUaGlzLldlYWtSZWYpIHtcbiAgICBpZih4WzFdLnJlZ2lzdGVyKSB4WzFdLnJlZ2lzdGVyKHYsIHVuZGVmaW5lZCwgdik7XG4gICAgeFtjYW1sX2VwaGVfa2V5X29mZnNldCArIGldID0gbmV3IGdsb2JhbFRoaXMuV2Vha1JlZih2KTtcbiAgfVxuICBlbHNlIHhbY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpXSA9IHY7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV91bnNldF9rZXlcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9lcGhlX2tleV9vZmZzZXRcbmZ1bmN0aW9uIGNhbWxfZXBoZV91bnNldF9rZXkoeCwgaSkge1xuICBpZihpIDwgMCB8fCBjYW1sX2VwaGVfa2V5X29mZnNldCArIGkgPj0geC5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcIldlYWsuc2V0XCIpO1xuICBpZihnbG9iYWxUaGlzLldlYWtSZWYgJiYgeFtjYW1sX2VwaGVfa2V5X29mZnNldCArIGldIGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5XZWFrUmVmICYmIHhbMV0udW5yZWdpc3Rlcikge1xuICAgIHZhciBvbGQgPSB4W2NhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaV0uZGVyZWYoKTtcbiAgICBpZihvbGQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGNvdW50ID0gMFxuICAgICAgZm9yKHZhciBqID0gY2FtbF9lcGhlX2tleV9vZmZzZXQ7IGogPCB4Lmxlbmd0aDsgaisrKXtcbiAgICAgICAgdmFyIGtleSA9IHhbal07XG4gICAgICAgIGlmKGtleSBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuV2Vha1JlZil7XG4gICAgICAgICAga2V5ID0ga2V5LmRlcmVmKClcbiAgICAgICAgICBpZihrZXkgPT09IG9sZCkgY291bnQrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYoY291bnQgPT0gMSkgeFsxXS51bnJlZ2lzdGVyKG9sZCk7XG4gICAgfVxuICB9XG4gIHhbY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpXSA9IHVuZGVmaW5lZDtcbiAgcmV0dXJuIDBcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfY3JlYXRlXG4vL1JlcXVpcmVzOiBjYW1sX3dlYWtfY3JlYXRlLCBjYW1sX2VwaGVfZGF0YV9vZmZzZXRcbmZ1bmN0aW9uIGNhbWxfZXBoZV9jcmVhdGUgKG4pIHtcbiAgdmFyIHggPSBjYW1sX3dlYWtfY3JlYXRlKG4pO1xuICByZXR1cm4geDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF93ZWFrX2NyZWF0ZVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2tleV9vZmZzZXQsIGNhbWxfaW52YWxpZF9hcmd1bWVudCxjYW1sX2VwaGVfZGF0YV9vZmZzZXRcbmZ1bmN0aW9uIGNhbWxfd2Vha19jcmVhdGUgKG4pIHtcbiAgaWYgKG4gPCAwKSBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiV2Vhay5jcmVhdGVcIik7XG4gIHZhciB4ID0gWzI1MSxcImNhbWxfZXBoZV9saXN0X2hlYWRcIl07XG4gIHgubGVuZ3RoID0gY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBuO1xuICByZXR1cm4geDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF93ZWFrX3NldFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfc2V0X2tleSwgY2FtbF9lcGhlX3Vuc2V0X2tleVxuZnVuY3Rpb24gY2FtbF93ZWFrX3NldCh4LCBpLCB2KSB7XG4gIGlmKHYgPT0gMCkgY2FtbF9lcGhlX3Vuc2V0X2tleSh4LGkpXG4gIGVsc2UgY2FtbF9lcGhlX3NldF9rZXkoeCxpLHZbMV0pXG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2dldF9rZXlcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0LCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbi8vQWxpYXM6IGNhbWxfd2Vha19nZXRcbmZ1bmN0aW9uIGNhbWxfZXBoZV9nZXRfa2V5KHgsIGkpIHtcbiAgaWYoaSA8IDAgfHwgY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpID49IHgubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudCAoXCJXZWFrLmdldF9rZXlcIik7XG4gIHZhciB3ZWFrID0geFtjYW1sX2VwaGVfa2V5X29mZnNldCArIGkgXTtcbiAgaWYoZ2xvYmFsVGhpcy5XZWFrUmVmICYmIHdlYWsgaW5zdGFuY2VvZiBnbG9iYWxUaGlzLldlYWtSZWYpIHdlYWsgPSB3ZWFrLmRlcmVmKCk7XG4gIHJldHVybiAod2Vhaz09PXVuZGVmaW5lZCk/MDpbMCwgd2Vha107XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfZ2V0X2tleV9jb3B5XG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZ2V0X2tleSxjYW1sX2VwaGVfa2V5X29mZnNldFxuLy9SZXF1aXJlczogY2FtbF9vYmpfZHVwLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbi8vQWxpYXM6IGNhbWxfd2Vha19nZXRfY29weVxuZnVuY3Rpb24gY2FtbF9lcGhlX2dldF9rZXlfY29weSh4LCBpKSB7XG4gIGlmKGkgPCAwIHx8IGNhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaSA+PSB4Lmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiV2Vhay5nZXRfY29weVwiKTtcbiAgdmFyIHkgPSBjYW1sX2VwaGVfZ2V0X2tleSh4LCBpKTtcbiAgaWYgKHkgPT09IDApIHJldHVybiB5O1xuICB2YXIgeiA9IHlbMV07XG4gIGlmICh6IGluc3RhbmNlb2YgQXJyYXkpIHJldHVybiBbMCwgY2FtbF9vYmpfZHVwKHopXTtcbiAgcmV0dXJuIHk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9jaGVja19rZXkgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2tleV9vZmZzZXRcbi8vQWxpYXM6IGNhbWxfd2Vha19jaGVja1xuZnVuY3Rpb24gY2FtbF9lcGhlX2NoZWNrX2tleSh4LCBpKSB7XG4gIHZhciB3ZWFrID0geFtjYW1sX2VwaGVfa2V5X29mZnNldCArIGldO1xuICBpZihnbG9iYWxUaGlzLldlYWtSZWYgJiYgd2VhayBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuV2Vha1JlZikgd2VhayA9IHdlYWsuZGVyZWYoKTtcbiAgaWYod2Vhaz09PXVuZGVmaW5lZClcbiAgICByZXR1cm4gMDtcbiAgZWxzZVxuICAgIHJldHVybiAxO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfYmxpdF9rZXlcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYmxpdFxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2tleV9vZmZzZXRcbi8vQWxpYXM6IGNhbWxfd2Vha19ibGl0XG5mdW5jdGlvbiBjYW1sX2VwaGVfYmxpdF9rZXkoYTEsIGkxLCBhMiwgaTIsIGxlbikge1xuICAvLyBtaW51cyBvbmUgYmVjYXVzZSBjYW1sX2FycmF5X2JsaXQgd29ya3Mgb24gb2NhbWwgYXJyYXlcbiAgY2FtbF9hcnJheV9ibGl0KGExLCBjYW1sX2VwaGVfa2V5X29mZnNldCArIGkxIC0gMSxcbiAgICAgICAgICAgICAgICAgIGEyLCBjYW1sX2VwaGVfa2V5X29mZnNldCArIGkyIC0gMSxcbiAgICAgICAgICAgICAgICAgIGxlbik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfYmxpdF9kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZGF0YV9vZmZzZXQsIGNhbWxfZXBoZV9zZXRfZGF0YSwgY2FtbF9lcGhlX3Vuc2V0X2RhdGFcbmZ1bmN0aW9uIGNhbWxfZXBoZV9ibGl0X2RhdGEoc3JjLCBkc3Qpe1xuICB2YXIgbiA9IHNyY1tjYW1sX2VwaGVfZGF0YV9vZmZzZXRdO1xuICBpZihuID09PSB1bmRlZmluZWQpIGNhbWxfZXBoZV91bnNldF9kYXRhKGRzdCk7XG4gIGVsc2UgY2FtbF9lcGhlX3NldF9kYXRhKGRzdCwgbik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfZ2V0X2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldFxuZnVuY3Rpb24gY2FtbF9lcGhlX2dldF9kYXRhKHgpe1xuICBpZih4W2NhbWxfZXBoZV9kYXRhX29mZnNldF0gPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gMDtcbiAgZWxzZVxuICAgIHJldHVybiBbMCwgeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2dldF9kYXRhX2NvcHlcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldFxuLy9SZXF1aXJlczogY2FtbF9vYmpfZHVwXG5mdW5jdGlvbiBjYW1sX2VwaGVfZ2V0X2RhdGFfY29weSh4KXtcbiAgaWYoeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIDA7XG4gIGVsc2VcbiAgICByZXR1cm4gWzAsIGNhbWxfb2JqX2R1cCh4W2NhbWxfZXBoZV9kYXRhX29mZnNldF0pXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX3NldF9kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZGF0YV9vZmZzZXQsIGNhbWxfZXBoZV9rZXlfb2Zmc2V0LCBjYW1sX2VwaGVfdW5zZXRfZGF0YVxuZnVuY3Rpb24gY2FtbF9lcGhlX3NldF9kYXRhKHgsIGRhdGEpe1xuICBpZihnbG9iYWxUaGlzLkZpbmFsaXphdGlvblJlZ2lzdHJ5ICYmIGdsb2JhbFRoaXMuV2Vha1JlZikge1xuICAgIGlmKCEgKHhbMV0gaW5zdGFuY2VvZiBnbG9iYWxUaGlzLkZpbmFsaXphdGlvblJlZ2lzdHJ5KSkge1xuICAgICAgeFsxXSA9IG5ldyBnbG9iYWxUaGlzLkZpbmFsaXphdGlvblJlZ2lzdHJ5KGZ1bmN0aW9uICgpIHsgY2FtbF9lcGhlX3Vuc2V0X2RhdGEoeCkgfSk7XG4gICAgICAvL3JlZ2lzdGVyIGFsbCBrZXlzXG4gICAgICBmb3IodmFyIGogPSBjYW1sX2VwaGVfa2V5X29mZnNldDsgaiA8IHgubGVuZ3RoOyBqKyspe1xuICAgICAgICB2YXIga2V5ID0geFtqXTtcbiAgICAgICAgaWYoa2V5IGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5XZWFrUmVmKSB7XG4gICAgICAgICAga2V5ID0ga2V5LmRlcmVmKCk7XG4gICAgICAgICAgaWYoa2V5KSB4WzFdLnJlZ2lzdGVyKGtleSwgdW5kZWZpbmVkLCBrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSA9IGRhdGE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfdW5zZXRfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0LCBjYW1sX2VwaGVfa2V5X29mZnNldFxuZnVuY3Rpb24gY2FtbF9lcGhlX3Vuc2V0X2RhdGEoeCl7XG4gIGlmKGdsb2JhbFRoaXMuRmluYWxpemF0aW9uUmVnaXN0cnkgJiYgZ2xvYmFsVGhpcy5XZWFrUmVmKSB7XG4gICAgaWYoeFsxXSBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuRmluYWxpemF0aW9uUmVnaXN0cnkpe1xuICAgICAgLy91bnJlZ2lzdGVyIGFsbCBrZXlzXG4gICAgICBmb3IodmFyIGogPSBjYW1sX2VwaGVfa2V5X29mZnNldDsgaiA8IHgubGVuZ3RoOyBqKyspe1xuICAgICAgICB2YXIga2V5ID0geFtqXTtcbiAgICAgICAgaWYoa2V5IGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5XZWFrUmVmKSB7XG4gICAgICAgICAga2V5ID0ga2V5LmRlcmVmKCk7XG4gICAgICAgICAgaWYoa2V5KSB4WzFdLnVucmVnaXN0ZXIoa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICB4W2NhbWxfZXBoZV9kYXRhX29mZnNldF0gPSB1bmRlZmluZWQ7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfY2hlY2tfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG5mdW5jdGlvbiBjYW1sX2VwaGVfY2hlY2tfZGF0YSh4KXtcbiAgaWYoeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIDA7XG4gIGVsc2VcbiAgICByZXR1cm4gMTtcbn1cbiIsIlxuLy9Qcm92aWRlczogY2FtbF9seG1fbmV4dFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9zaGlmdF9sZWZ0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29yXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3hvclxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9hZGRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfbXVsXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF8xXG4vL1JlcXVpcmVzOiBjYW1sX2JhX3NldF8xXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9uZXdfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2x4bV9uZXh0KHYpIHtcbiAgZnVuY3Rpb24gc2hpZnRfbCh4LCBrKXtcbiAgICByZXR1cm4gY2FtbF9pbnQ2NF9zaGlmdF9sZWZ0KHgsayk7XG4gIH1cbiAgZnVuY3Rpb24gc2hpZnRfcih4LCBrKXtcbiAgICByZXR1cm4gY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCh4LGspO1xuICB9XG4gIGZ1bmN0aW9uIG9yKGEsIGIpe1xuICAgIHJldHVybiBjYW1sX2ludDY0X29yKGEsYik7XG4gIH1cbiAgZnVuY3Rpb24geG9yKGEsIGIpe1xuICAgIHJldHVybiBjYW1sX2ludDY0X3hvcihhLGIpO1xuICB9XG4gIGZ1bmN0aW9uIGFkZChhLCBiKXtcbiAgICByZXR1cm4gY2FtbF9pbnQ2NF9hZGQoYSxiKTtcbiAgfVxuICBmdW5jdGlvbiBtdWwoYSwgYil7XG4gICAgcmV0dXJuIGNhbWxfaW50NjRfbXVsKGEsYik7XG4gIH1cbiAgZnVuY3Rpb24gcm90bCh4LCBrKSB7XG4gICAgcmV0dXJuIG9yKHNoaWZ0X2woeCxrKSxzaGlmdF9yICh4LCA2NCAtIGspKTtcbiAgfVxuICBmdW5jdGlvbiBnZXQoYSwgaSkge1xuICAgIHJldHVybiBjYW1sX2JhX2dldF8xKGEsIGkpO1xuICB9XG4gIGZ1bmN0aW9uIHNldChhLCBpLCB4KSB7XG4gICAgcmV0dXJuIGNhbWxfYmFfc2V0XzEoYSwgaSwgeCk7XG4gIH1cbiAgdmFyIE0gPSBjYW1sX2ludDY0X29mX3N0cmluZyhjYW1sX25ld19zdHJpbmcoXCIweGQxMzQyNTQzZGU4MmVmOTVcIikpO1xuICB2YXIgZGFiYSA9IGNhbWxfaW50NjRfb2Zfc3RyaW5nKGNhbWxfbmV3X3N0cmluZyhcIjB4ZGFiYTBiNmViMDkzMjJlM1wiKSk7XG4gIHZhciB6LCBxMCwgcTE7XG4gIHZhciBzdCA9IHY7XG4gIHZhciBhID0gZ2V0KHN0LDApO1xuICB2YXIgcyA9IGdldChzdCwxKTtcbiAgdmFyIHgwID0gZ2V0KHN0LDIpO1xuICB2YXIgeDEgPSBnZXQoc3QsMyk7XG4gIC8qIENvbWJpbmluZyBvcGVyYXRpb24gKi9cbiAgeiA9IGFkZChzLCB4MCk7XG4gIC8qIE1peGluZyBmdW5jdGlvbiAqL1xuICB6ID0gbXVsKHhvcih6LHNoaWZ0X3IoeiwzMikpLCBkYWJhKTtcbiAgeiA9IG11bCh4b3IoeixzaGlmdF9yKHosMzIpKSwgZGFiYSk7XG4gIHogPSB4b3IoeixzaGlmdF9yKHosMzIpKTtcbiAgLyogTENHIHVwZGF0ZSAqL1xuICBzZXQoc3QsIDEsIGFkZCAobXVsKHMsTSksIGEpKTtcbiAgLyogWEJHIHVwZGF0ZSAqL1xuICB2YXIgcTAgPSB4MFxuICB2YXIgcTEgPSB4MVxuICBxMSA9IHhvcihxMSxxMCk7XG4gIHEwID0gcm90bChxMCwgMjQpO1xuICBxMCA9IHhvcih4b3IocTAsIHExKSwgKHNoaWZ0X2wocTEsMTYpKSk7XG4gIHExID0gcm90bChxMSwgMzcpO1xuICBzZXQoc3QsIDIsIHEwKTtcbiAgc2V0KHN0LCAzLCBxMSk7XG4gIC8qIFJldHVybiByZXN1bHQgKi9cbiAgcmV0dXJuIHo7XG59XG4iLCIvL1RoZSBmb2xsb3dpbmcgYXJlIGRlZmluZWQgaW4gQ3N0cnVjdFxuLy9UaGVyZSBhcmUganVzdCBwcm92aWRlZCBoZXJlIGZvciBjb21wYXRpYmlsaXR5IHJlYXNvbnNcblxuLy9Qcm92aWRlczogY2FtbF9ibGl0X2JpZ3N0cmluZ190b19iaWdzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmFcbi8vV2Vha2RlZlxudmFyIGNhbWxfYmxpdF9iaWdzdHJpbmdfdG9fYmlnc3RyaW5nID0gY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYVxuLy9Qcm92aWRlczogY2FtbF9ibGl0X2JpZ3N0cmluZ190b19zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYnl0ZXNcbi8vV2Vha2RlZlxudmFyIGNhbWxfYmxpdF9iaWdzdHJpbmdfdG9fc3RyaW5nID0gY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19ieXRlc1xuLy9Qcm92aWRlczogY2FtbF9ibGl0X3N0cmluZ190b19iaWdzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhXG4vL1dlYWtkZWZcbnZhciBjYW1sX2JsaXRfc3RyaW5nX3RvX2JpZ3N0cmluZyA9IGNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhXG4iLCIvLy8vLy8vLy8gVElNRV9OT1dcblxuLy9Qcm92aWRlczogdGltZV9ub3dfbmFub3NlY29uZHNfc2luY2VfdW5peF9lcG9jaF9vcl96ZXJvXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X211bCwgY2FtbF9pbnQ2NF9vZl9mbG9hdCwgY2FtbF9pbnQ2NF9vZl9pbnQzMlxudmFyIG1zX3RvX25hbm8gPSBjYW1sX2ludDY0X29mX2ludDMyKDEwMDAqMTAwMCk7XG5mdW5jdGlvbiB0aW1lX25vd19uYW5vc2Vjb25kc19zaW5jZV91bml4X2Vwb2NoX29yX3plcm8oKXtcbiAgICB2YXIgbXMgPSBEYXRlLm5vdygpO1xuICAgIC8vIG11bHRpcGxlIGJ5IHR3byAtIGludDYzIGludGVnZXJzIGFyZSBzaGlmdGVkIHRvIHRoZSBsZWZ0XG4gICAgdmFyIG1zX2k2MyA9IGNhbWxfaW50NjRfb2ZfZmxvYXQobXMqMik7XG4gICAgcmV0dXJuIGNhbWxfaW50NjRfbXVsKG1zX2k2Myxtc190b19uYW5vKTtcbn1cbiJdfQ==
